## 从一维编排到多维编排，从平面存储到3D存储 - 数据存储优化之路
    
### 作者    
digoal    
    
### 日期    
2017-06-13    
    
### 标签    
PostgreSQL , cluster , 预排 , 一维数据 , 多维数据 , 视觉编排 , 数据编排 , IO优化  
    
----    
    
## 背景    
中华文化源远流长，比如这句古语“远水不救近火，远亲不如近邻”，在数据库的优化中亦有体现。接下来我们来揭示这个道理。

大多数数据库的存储为块存储，一个块里面可能涉及到多条记录，当用户输入查询条件进行数据检索时，即使返回的结果集较小，也可能需要扫描多个数据块，因为你不知道你要的记录落在哪些数据块里面。

例子

随机写入一批数据

```
create table tbl(id int, info text default repeat(random()::text,10), crt_time timestamp default now());
insert into tbl (id) select random()*10000 from generate_series(1,1000000);
```

查询ID<100的记录，这些记录落在哪些数据块里面？

```
postgres=# select ctid from tbl where id<100;
    ctid    
------------
 (4,10)
 (6,32)
 (7,33)
 (17,14)
 (22,15)
 (22,16)
 (25,2)
 (29,21)
 (41,13)
 (42,27)
 (43,27)
 (54,11)
 (54,33)
 (56,1)
 (60,13)
。。。。。。
```

可以看到，数据散落在不同的数据块里面。也就是说访问了很多数据块。

很多用户遇到了类似的问题，我做了一些总结和优化之道，请参考下面的文章。

[《索引顺序扫描引发的堆扫描IO放大背后的统计学原理与解决办法》](../201404/20140426_01.md)  

[《懒人推动社会进步 - 多列聚合, gin与数据分布(选择性)》](../201706/20170612_04.md)  

[《索引扫描优化之 - GIN数据重组优化(按元素聚合) 想象在玩多阶魔方》](../201706/20170612_05.md)  

以上文章提到了优化的方法：数据重新编排存储。让数据尽量的根据搜索条件进行聚集，减少扫描成本。

## 数据存储优化 - 编排
数据存储编排的目的很简单，让数据尽量的根据搜索条件进行聚集，减少扫描成本。

但是数据种类不一样，编排优化也不太一样。前面提到的例子针对的都是一维的数据，一维数据的操作很简单，=, >, <, >=, <=, in等。

如果数据类型不是一维类型，而是多值类型或者异构类型呢？例如数组、空间类型、全文检索类型等。数据的编排还有这么简单吗？

### 一维数据编排
一维类型的编排，按搜索列排序是最简单有效的编排方法。业界也叫预排序，PostgreSQL叫cluster，通过cluster命令即可完成编排。

https://www.postgresql.org/docs/9.6/static/sql-cluster.html

### 多维数据编排
一位编排比较简单，但是多维编排会更加复杂。我通过一个游戏来说明编排的目的。

我们来玩一个游戏，假设全球有10000个国家，每个国家挑选若干人（每个国家挑选的人数可以不一样，例如A国家挑选了1000人，B国家挑选了10人，假设总共挑选了100万人）进行混合分组，每个分组包含了若干不同国家的人（每个分组每个国家仅限1人）。下面进行排队，横坐标为分组ID，纵坐标为国家ID。接下来要进行搬运游戏，从左导游，每个国家的人，需要将它手里的球搬运给右边的相同国家的人，如果他们相邻，则不计成本。如果他们之间隔了其他分组，则计算成本（相隔的分组个数）。最终计算每个国家的搬运成本，某些国家的搬运成本，或者所有国家相加的总搬运成本。 

如何降低总成本，如何降低某些国家的成本，如何降低某个国家的成本？

例如第一种排列方式，1号国家的搬运成本为2， 6号，7号国家的搬运成本为1，其他国家的搬运成本为0。

![pic](20170612_05_pic_002.jpg)

第二种排列方式如下，所有国家的搬运成本都为0。

![pic](20170612_05_pic_004.jpg)

这就是数组类型编排要取得的目的，由于数组类型通常是按数组的元素进行检索的，因此我们需要根据元素来进行编排。数组类型的编排方式同样适用于全文检索类型，TOKEN类型。

其他类型的编排则根据数据类型来定，例如空间类型，可以根据GEOHASH的值进行排序编排。

下面我们讲一下数组类型编排的实现过程。

### 生成测试数据
生成一些随机数组的行。

postgres=# create or replace function gen_array(range int, cnt int) returns int[] as $$
select array(select (random()*range)::int from generate_series(1,cnt) group by 1);
$$ language sql strict volatile;
CREATE FUNCTION
postgres=# select gen_array(10,5);
 gen_array 
-----------
 {9,1,5,8}
(1 row)

postgres=# select gen_array(10, 20);
       gen_array        
------------------------
 {9,3,1,4,5,2,7,6,8,10}
(1 row)

postgres=# select gen_array(100,10) from generate_series(1,100);
            gen_array             
----------------------------------
 {9,16,51,72,31,27,20,63,41,65}
 {88,1,59,39,87,28,24,32,21}
 {69,78,34,11,84,79,97,80,85,56}
 {3,90,42,81,83,41,76,99,65,25}
 {14,4,42,50,37,13,72,75,29,74}
 {23,92,53,74,77,71,93,82}
 {1,16,81,51,79,76,62,94,77}
 {48,64,18,35,43,36,54,41,29,98}
 {100,84,28,99,80,8,85,77,10,33}
 {96,31,39,7,87,53,36,54,30,77}
 {70,49,90,91,13,40,31,54,97,94}
 {58,55,35,75,29,6,65,56,98}
......


postgres=# create table tbl2(id int, arr int[]);
CREATE TABLE

postgres=# insert into tbl2 select id, gen_array(100,10) from generate_series(1,1000) t(id);
INSERT 0 1000

postgres=# select * from tbl2 limit 10;
 id |               arr               
----+---------------------------------
  1 | {81,38,13,2,44,41,62,15}
  2 | {14,3,67,13,73,2,12,98,17}
  3 | {88,61,58,78,19,73,34,7,77,25}
  4 | {61,42,5,91,13,83,57,11,99,93}
  5 | {45,96,5,72,75,92,84,56,82}
  6 | {9,1,16,55,40,63,29,84,82}
  7 | {61,3,78,83,66,35,94,85,0}
  8 | {70,49,55,100,83,86,53,74,8,56}
  9 | {58,42,48,83,31,79,85,33,82}
 10 | {45,51,48,37,83,86,30,52,65,15}
(10 rows)


### 排列组合

[《PostgreSQL n阶乘计算, 排列组合计算 - 如何计算可变参数中有没有重复参数》](../201604/20160402_01.md)  

图


### 统计每一种排列组合，各个元素的检索成本

计算每一种排列组合，对应元素的聚合度（越靠近0，越聚合）

按行号进行排列组合


数组元素取值

select distinct(unnest(arr)) from tbl2;

计算每个取值的聚合度



热点问题


### 


## 存储

### 平面存储

### 3D存储


## GPU - 视觉编排


## 未来硬件的变革
访问路径的变革


## 行列混合
shard



列存编排优化

数据的访问是多样化的，怎么优化？

bitmap

shard


## 小结



技术的变革

多项技术的打通


PG广告









记忆规整


顺序存储

3D存储

视觉优化


