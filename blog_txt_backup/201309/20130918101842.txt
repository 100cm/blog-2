PostgreSQL research

PostgreSQL pending patch : record identical byte-for-byte compare operator ===

2013-09-18 10:18:42   查看原文>>

From:   Kevin Grittner <kgrittn(at)ymail(dot)com>
To:     "pgsql-hackers(at)postgresql(dot)org" <pgsql-hackers(at)postgresql(dot)org>
Subject:        record identical operator
Date:   2013-09-12 22:27:27
Message-ID:     1379024847.48294.YahooMailNeo@web162904.mail.bf1.yahoo.com (view raw)
Attached is a patch for a bit of infrastructure I believe to be
necessary for correct behavior of REFRESH MATERIALIZED VIEW
CONCURRENTLY as well as incremental maintenance of matviews.

The idea is that after RMVC or incremental maintenance, the matview
should not be visibly different that it would have been at creation
or on a non-concurrent REFRESH.  The issue is easy to demonstrate
with citext, but anywhere that the = operator allows user-visible
differences between "equal" values it can be an issue.

test=# CREATE TABLE citext_table (
test(#   id serial primary key,
test(#   name citext
test(# );
CREATE TABLE
test=# INSERT INTO citext_table (name)
test-#   VALUES ('one'), ('two'), ('three'), (NULL), (NULL);
INSERT 0 5
test=# CREATE MATERIALIZED VIEW citext_matview AS
test-#   SELECT * FROM citext_table;
SELECT 5
test=# CREATE UNIQUE INDEX citext_matview_id
test-#   ON citext_matview (id);
CREATE INDEX
test=# UPDATE citext_table SET name = 'Two' WHERE name = 'TWO';
UPDATE 1

At this point, the table and the matview have visibly different
values, yet without the patch the query used to find differences
for RMVC would be essentially like this (slightly simplified for
readability):

test=# SELECT *
  FROM citext_matview m
  FULL JOIN citext_table t ON (t.id = m.id AND t = m)
  WHERE t IS NULL OR m IS NULL;
 id | name | id | name
----+------+----+------
(0 rows)

No differences were found, so without this patch, the matview would
remain visibly different from the results generated by a run of its
defining query.

The patch adds an "identical" operator (===) for the record type:

test=# SELECT *
  FROM citext_matview m
  FULL JOIN citext_table t ON (t.id = m.id AND t === m)
  WHERE t IS NULL OR m IS NULL;
 id | name | id | name
----+------+----+------
    |      |  2 | Two
  2 | two  |    |
(2 rows)

The difference is now found, so RMVC makes the appropriate change.

test=# REFRESH MATERIALIZED VIEW CONCURRENTLY citext_matview;
REFRESH MATERIALIZED VIEW
test=# SELECT * FROM citext_matview ORDER BY id;
 id | name  
----+-------
  1 | one
  2 | Two
  3 | three
  4 |
  5 |
(5 rows)

The patch adds all of the functions, operators, and catalog
information to support merge joins using the "identical" operator.

The new operator is logically similar to IS NOT DISTINCT FROM for a
record, although its implementation is very different.  For one
thing, it doesn't replace the operation with column level operators
in the parser.  For another thing, it doesn't look up operators for
each type, so the "identical" operator does not need to be
implemented for each type to use it as shown above.  It compares
values byte-for-byte, after detoasting.  The test for identical
records can avoid the detoasting altogether for any values with
different lengths, and it stops when it finds the first column with
a difference.

I toyed with the idea of supporting hashing of records using this
operator, but could not see how that would be a performance win.

The identical (===) and not identical (!==) operator names were
chosen because of a vague similarity to the "exactly equals"
concepts in JavaScript and PHP, which use that name.  The semantics
aren't quite the same, but it seemed close enough not to be too
surprising.  The additional operator names seemed natural to me
based on the first two, but I'm not really that attached to these
names for the operators if someone has a better idea.

Since the comparison of record values is not documented (only
comparisons involving row value constructors), it doesn't seem like
we should document this special case.  It is intended primarily for
support of matview refresh and maintenance, and it seems likely
that record comparison was not documented on the basis that it is
intended primarily for support of such things as indexing and merge
joins -- so leaving the new operators undocumented seems consistent
with existing policy.  I'm open to arguments that the policy should
change.

--
Kevin Grittner
EDB: http://www.enterprisedb.com
The Enterprise PostgreSQL Company


这个补丁的目的是新增1个record比较的操作符. 使用字节流的方式进行比较, 而不是每列的比较.
因为值的比较和类型有关, 例如numeric的=操作符, 末尾的0多少个不关心, 只关心值是否相等.
例如 : 

digoal=# select numeric '1.0' = numeric '1.00';
 ?column? 
----------
 t
(1 row)


但实际上这两个值的含义不一样, 在磁盘上存储的字节流也不一样.

digoal=# select byteain(numeric_out(1.0)) = byteain(numeric_out(1.00));
 ?column? 
----------
 f
(1 row)
digoal=# select byteain(numeric_out(1.00)), byteain(numeric_out(1.0));
  byteain   | byteain  
------------+----------
 \x312e3030 | \x312e30
(1 row)


除了numeric以外, 还有citext也有类似情况. 例如 : 

digoal=# create extension citext;
CREATE EXTENSION
digoal=# select citext 'abc' = citext 'ABC';
 ?column? 
----------
 t
(1 row)
digoal=# select byteain(citextout(citext 'abc')) = byteain(citextout(citext 'ABC'));
 ?column? 
----------
 f
(1 row)
digoal=# select byteain(citextout(citext 'abc'));
 byteain  
----------
 \x616263
(1 row)

digoal=# select byteain(citextout(citext 'ABC'));
 byteain  
----------
 \x414243
(1 row)


本文谈到的这个补丁不采用各种类型的=操作符进行比较, 而是直接拿磁盘上存储的字节流来比较, (如果是toast存储的字段, 使用解压后的字节流)
打补丁 : 

[root@db-172-16-3-33 postgresql-dd778e9]# wget http://www.postgresql.org/message-id/attachment/30102/record-identical-v1.patch
[root@db-172-16-3-33 postgresql-dd778e9]# patch -p1 < record-identical-v1.patch 
patching file contrib/citext/expected/citext.out
patching file contrib/citext/expected/citext_1.out
patching file contrib/citext/sql/citext.sql
patching file src/backend/commands/matview.c
patching file src/backend/utils/adt/rowtypes.c
patching file src/include/catalog/pg_amop.h
patching file src/include/catalog/pg_amproc.h
patching file src/include/catalog/pg_opclass.h
patching file src/include/catalog/pg_operator.h
patching file src/include/catalog/pg_opfamily.h
patching file src/include/catalog/pg_proc.h
patching file src/include/utils/builtins.h
patching file src/test/regress/expected/opr_sanity.out


# 注意, 这个补丁修改了citext和matview(物化视图的刷新部分).

[root@db-172-16-3-33 postgresql-dd778e9]# gmake && gmake install
[root@db-172-16-3-33 postgresql-dd778e9]# cd contrib
[root@db-172-16-3-33 contrib]# gmake && gmake install


# 因为动了catalog, 所以需要重新初始化数据库. (可以通过pg_upgrade来升级, 这里测试环境就不搞这么复杂了, 直接初始化)

[root@db-172-16-3-33 contrib]# su - pg94
pg94@db-172-16-3-33-> initdb -D $PGDATA -E UTF8 --locale=C -W -U postgres
pg94@db-172-16-3-33-> pg_ctl start
pg94@db-172-16-3-33-> psql
psql (9.4devel)
Type "help" for help.
digoal=# \do *.*===*
                               List of operators
   Schema   | Name | Left arg type | Right arg type | Result type | Description 
------------+------+---------------+----------------+-------------+-------------
 pg_catalog | ===  | record        | record         | boolean     | identical
(1 row)
digoal=# SELECT (ARRAY[1,2,3,NULL])[1:3] = ARRAY[1,2,3];
 ?column? 
----------
 t
(1 row)

digoal=# SELECT row((ARRAY[1,2,3,NULL])[1:3])::record = row(ARRAY[1,2,3])::record;
 ?column? 
----------
 t
(1 row)

digoal=# SELECT row((ARRAY[1,2,3,NULL])[1:3])::record === row(ARRAY[1,2,3])::record;
 ?column? 
----------
 f
(1 row)


array的空字节使用byteain看不出来 : 

digoal=# SELECT byteain(record_out(row((ARRAY[1,2,3,NULL])[1:3])::record)) , byteain(record_out(row(ARRAY[1,2,3])::record));
         byteain          |         byteain          
--------------------------+--------------------------
 \x28227b312c322c337d2229 | \x28227b312c322c337d2229
(1 row)


I haven't yet tested your patch, but what I am talking about is that
e.g.: SELECT (ARRAY[1,2,3,NULL])[1:3] = ARRAY[1,2,3];
obviously should be true. But both arrays don't have the same binary
representation since the former has a null bitmap, the latter not.
So, if you had a composite type like (int4[]) and would compare that
without invoking operators you'd return something false in some cases
because of the null bitmaps.


接下来测试物化视图增量刷新的部分 : 
1. 打补丁后 : 

digoal=# create extension citext;
CREATE EXTENSION
digoal=# create table test(id int primary key, c1 citext, c2 numeric);
CREATE TABLE
digoal=# insert into test values (1,'abc',1.0);
INSERT 0 1
digoal=# insert into test values (2,'ABC',1.0);
INSERT 0 1
digoal=# insert into test values (3,'ABC',1.00);
INSERT 0 1
digoal=# insert into test values (4,'abc',1.00);
INSERT 0 1
digoal=# select * from test;
 id | c1  |  c2  
----+-----+------
  1 | abc |  1.0
  2 | ABC |  1.0
  3 | ABC | 1.00
  4 | abc | 1.00
(4 rows)


创建物化视图

digoal=# CREATE MATERIALIZED VIEW mv_test AS select * from test;
SELECT 4
digoal=# select * from mv_test;
 id | c1  |  c2  
----+-----+------
  1 | abc |  1.0
  2 | ABC |  1.0
  3 | ABC | 1.00
  4 | abc | 1.00
(4 rows)


给物化视图创建唯一索引, 以便增量更新

digoal=# create unique index idx_test_id on mv_test(id);
CREATE INDEX


更新citext字段, Abc, 这个更新后, new和old值使用这个类型对应的=操作符实际上是相等的.

digoal=# update test set c1='Abc' where id=1;
UPDATE 1
digoal=# refresh MATERIALIZED VIEW CONCURRENTLY mv_test;
REFRESH MATERIALIZED VIEW


打补丁后, record的比较按字节流进行, 所以id=1的值发生的变更会造成刷新.

digoal=# select * from mv_test;
 id | c1  |  c2  
----+-----+------
  2 | ABC |  1.0
  3 | ABC | 1.00
  4 | abc | 1.00
  1 | Abc |  1.0
(4 rows)


更新numeric的值, 增加1个有效值. 虽然使用numeric对应的=操作符比较1.0=1.00. 
但是打补丁后使用的是===进行比较, 所以刷新时还是会更新这条记录

digoal=# update test set c2=1.00 where id=1;
UPDATE 1
digoal=# refresh MATERIALIZED VIEW CONCURRENTLY mv_test;
REFRESH MATERIALIZED VIEW
digoal=# select * from mv_test;
 id | c1  |  c2  
----+-----+------
  2 | ABC |  1.0
  3 | ABC | 1.00
  4 | abc | 1.00
  1 | Abc | 1.00
(4 rows)


打补丁后, 物化视图的刷新更真实, 会完全匹配到基表.

2. 打补丁前 : 

digoal=# create table test(id int primary key, c1 citext, c2 numeric);
CREATE TABLE
digoal=# insert into test values (1,'abc',1.0);
INSERT 0 1
digoal=# insert into test values (2,'ABC',1.0);
INSERT 0 1
digoal=# insert into test values (3,'ABC',1.00);
INSERT 0 1
digoal=# insert into test values (4,'abc',1.00);
INSERT 0 1
digoal=# select * from test;
 id | c1  |  c2  
----+-----+------
  1 | abc |  1.0
  2 | ABC |  1.0
  3 | ABC | 1.00
  4 | abc | 1.00
(4 rows)

digoal=# CREATE MATERIALIZED VIEW mv_test AS select * from test;
SELECT 4
digoal=# select * from mv_test;
 id | c1  |  c2  
----+-----+------
  1 | abc |  1.0
  2 | ABC |  1.0
  3 | ABC | 1.00
  4 | abc | 1.00
(4 rows)

digoal=# create unique index idx_test_id on mv_test(id);
CREATE INDEX
digoal=# update test set c1='Abc' where id=1;
UPDATE 1
digoal=# refresh MATERIALIZED VIEW CONCURRENTLY mv_test;
REFRESH MATERIALIZED VIEW
digoal=# select * from mv_test;
 id | c1  |  c2  
----+-----+------
  1 | abc |  1.0
  2 | ABC |  1.0
  3 | ABC | 1.00
  4 | abc | 1.00
(4 rows)

digoal=# update test set c2=1.00 where id=1;
UPDATE 1
digoal=# select * from mv_test;
 id | c1  |  c2  
----+-----+------
  1 | abc |  1.0
  2 | ABC |  1.0
  3 | ABC | 1.00
  4 | abc | 1.00
(4 rows)


显然打补丁前, 物化视图对于这类更新没有体现在物化视图上.

[小结]
1. 使用本补丁时需要注意, ===这个操作符是对record进行byte-for-byte的比较, 虽然numeric 1.0和numeric 1.00看起来应该相等, 但是底层的存储实际上是不一样的. 这种情况下使用===就比较有用了.
2. 对于物化视图的增量刷新场景, 每条记录要做出比较, 本补丁将物化视图增量刷新做出了修改, 把record的对比改成使用===这种模式, 所以对于citext这种类型, 可以看出打补丁前后发生的明显变化.

[参考]
1. http://www.postgresql.org/message-id/flat/1379024847.48294.YahooMailNeo@web162904.mail.bf1.yahoo.com#1379024847.48294.YahooMailNeo@web162904.mail.bf1.yahoo.com
2. src/backend/utils/adt/arrayfuncs.c

/*
 * Set a specific array element's null-bitmap entry
 *
 * nullbitmap: pointer to array's null bitmap (mustn't be NULL)
 * offset: 0-based linear element number of array element
 * isNull: null status to set
 */
static void
array_set_isnull(bits8 *nullbitmap, int offset, bool isNull)
{
        int                     bitmask;

        nullbitmap += offset / 8;
        bitmask = 1 << (offset % 8);
        if (isNull)
                *nullbitmap &= ~bitmask;
        else
                *nullbitmap |= bitmask;
}



