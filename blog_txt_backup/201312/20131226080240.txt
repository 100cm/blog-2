PostgreSQL research

lua计算"序列型table"数据类型元素个数的"诡异"

2013-12-26 8:02:40   查看原文>>

序列型的table指没有气泡的一串list, 如a[1],a[2],...a[10]是一个长度为10的序列型表, 那么#a=10.
但是如果a[1],a[3],a[10]这样存储的话#a=1; 因为出现了气泡.

> c={}
> c[1]=10
> c[3]=1
> = #c
1


#a表示的是序列型的表数据类型的长度. 
因此不难解释以下.

> d={}
> d[2]=10
> = #d
0


因为序列型的表的index协定是从1开始计数的.

lua在计算table数据类型存储的元素个数时比较"诡异".
例如 : 

> a = {1,2;"hello","nihao";4,5}
> = #a
6


这个表有6个元素可以理解. 接下来这个元素就变成4个了. 貌似没有记录中间两个, 因为他们的下标用法和"数组"型的表不太一样.

> a = {1,2;x="hello",y="nihao";4,5}
> return  #a
4
> return a[1]
1
> return a[4]
5
> return a["x"]
hello
> return a.y
nihao


另外还有需要注意的是, 当元素中有nil值时, 也不会记录进去.
例如 : 

> a = {}
> a[100] = "hello"
> = #a
0


为什么显示元素个数为0, 因为a[1]没有值. 我估计lua计算元素个数时从a[1]开始一个一个去检索, 直至a[n]=nil, 那么元素个数就是n-1.
例如 : 

> = a[1]
nil
> a[1] = "nihao"
> = #a
1


所以这种类型的表元素显示为0, 因为它的a[1]=nil

> a = {x=1, y=2}
> = #a
0
> = a[1]
nil


但是更诡异的是, 以下怎么理解呢? 是不是因为它是初始化时指定的表呢, 所以可以显示出6个元素?

> a = {1,2,nil,nil,3,4}
> = #a
6


那么未初始化, 而后定义的表就不会显示6个元素, 例如

> a = {}
> a[1] = 1
> a[2] = 2
> a[3] = nil
> a[4] = nil
> a[5] = 3
> a[6] = 4
> = #a
2


以上表lua显示只有2个元素.
乖乖, 为什么这样初始化的表, 元素个数又变成2了, 相比{1,2,nil,nil,3,4}, 只是末尾多了几个nil呀,

> a = {1,2,nil,nil,3,4,nil,nil,nil}
> = #a
2
> a = {1,2,nil,nil,3,4,nil}
> return  #a
2


另外一位哥们也写过一篇关于这种诡异的BLOG
http://blog.csdn.net/dssdss123/article/details/12676329
意见就是不要随意在lua的table中使用nil.
