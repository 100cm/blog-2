<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">about PostgreSQL hot standby query conflict with XLOG replay</h2>
	<h5 id="">2015-03-25 11:00:14&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020152259343787/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>在hot standby执行查询时, 有可能这些未结束的查询会和将要发生的WAL apply发生冲突, 当发生冲突时, hot standby的startup进程(即恢复进程) 需要处理这样的冲突, 怎么处理呢?</div><div>有两个参数 :&nbsp;</div><div><br></div><div><dt style="font-family: verdana, sans-serif; font-size: 12.1599998474121px; line-height: normal;"   ><tt>max_standby_archive_delay</tt>&nbsp;(<tt>integer</tt>)</dt><dd style="font-family: verdana, sans-serif; font-size: 12.1599998474121px; line-height: normal;"   ><p style="font-size: 1em; line-height: 1.5em; margin: 1.2em 0em;"   >When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in&nbsp;<a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/hot-standby.html#HOT-STANDBY-CONFLICT"   >Section 25.5.2</a>.&nbsp;<tt>max_standby_archive_delay</tt>&nbsp;applies when WAL data is being read from WAL archive (and is therefore not current). The default is 30 seconds. Units are milliseconds if not specified. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the&nbsp;<tt>postgresql.conf</tt>&nbsp;file or on the server command line.</p><p style="font-size: 1em; line-height: 1.5em; margin: 1.2em 0em;"   >Note that&nbsp;<tt>max_standby_archive_delay</tt>&nbsp;is not the same as the maximum length of time a query can run before cancellation; rather it is the maximum total time allowed to apply any one WAL segment's data. Thus, if one query has resulted in significant delay earlier in the WAL segment, subsequent conflicting queries will have much less grace time.</p></dd><dt style="font-family: verdana, sans-serif; font-size: 12.1599998474121px; line-height: normal;"   ><a id="GUC-MAX-STANDBY-STREAMING-DELAY" name="GUC-MAX-STANDBY-STREAMING-DELAY" rel="nofollow"   ></a><tt>max_standby_streaming_delay</tt>&nbsp;(<tt>integer</tt>)</dt><dd style="font-family: verdana, sans-serif; font-size: 12.1599998474121px; line-height: normal;"   ><p style="font-size: 1em; line-height: 1.5em; margin: 1.2em 0em;"   >When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in&nbsp;<a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/hot-standby.html#HOT-STANDBY-CONFLICT"   >Section 25.5.2</a>.&nbsp;<tt>max_standby_streaming_delay</tt>&nbsp;applies when WAL data is being received via streaming replication. The default is 30 seconds. Units are milliseconds if not specified. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the&nbsp;<tt>postgresql.conf</tt>&nbsp;file or on the server command line.</p><p style="font-size: 1em; line-height: 1.5em; margin: 1.2em 0em;"   >Note that&nbsp;<tt>max_standby_streaming_delay</tt>&nbsp;is not the same as the maximum length of time a query can run before cancellation; rather it is the maximum total time allowed to apply WAL data once it has been received from the primary server. Thus, if one query has resulted in significant delay, subsequent conflicting queries will have much less grace time until the standby server has caught up again.</p></dd></div><div>以上两个参数决定了startup遇到冲突时的等待时间.</div><div><br></div><div>等待时间的计算方法对应源码 :&nbsp;</div><div>src/backend/storage/ipc/standby.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Determine the cutoff time at which we want to start canceling conflicting</font></div><div><font size="2"   >&nbsp;* transactions. &nbsp;Returns zero (a time safely in the past) if we are willing</font></div><div><font size="2"   >&nbsp;* to wait forever.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static TimestampTz</font></div><div><font size="2"   >GetStandbyLimitTime(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz rtime;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fromStream;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The cutoff time is the last WAL data receipt time plus the appropriate</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* delay variable. &nbsp;Delay of -1 means wait forever.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; GetXLogReceiptTime(&amp;rtime, &amp;fromStream);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (fromStream)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (max_standby_streaming_delay &lt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* wait forever */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return TimestampTzPlusMilliseconds(rtime, max_standby_streaming_delay);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (max_standby_archive_delay &lt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* wait forever */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return TimestampTzPlusMilliseconds(rtime, max_standby_archive_delay);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>发生冲突的原因有几个, 信号定义如下 :&nbsp;</div><div>有锁冲突, 表空间, 数据库冲突, 快照(MVCC)冲突, bufferpin冲突等.</div><div><div style="line-height: 28px;"   >src/include/storage/procsignal.h</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >/*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* Reasons for signalling a Postgres child process (a backend or an auxiliary</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* process, like checkpointer). &nbsp;We can cope with concurrent signals for different</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* reasons. &nbsp;However, if the same reason is signaled multiple times in quick</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* succession, the process is likely to observe only one notification of it.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* This is okay for the present uses.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* Also, because of race conditions, it's important that all the signals be</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* defined so that no harm is done if a process mistakenly receives one.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 28px;"   ><font size="2"   >typedef enum</font></div><div style="line-height: 28px;"   ><font size="2"   >{</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PROCSIG_CATCHUP_INTERRUPT, &nbsp; &nbsp; &nbsp;/* sinval catchup interrupt */</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PROCSIG_NOTIFY_INTERRUPT, &nbsp; &nbsp; &nbsp; /* listen/notify interrupt */</font></div><div style="line-height: 28px;"   ><font size="2"   ><br style="line-height: 28px;"   ></font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Recovery conflict reasons */</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PROCSIG_RECOVERY_CONFLICT_DATABASE,</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PROCSIG_RECOVERY_CONFLICT_TABLESPACE,</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PROCSIG_RECOVERY_CONFLICT_LOCK,</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PROCSIG_RECOVERY_CONFLICT_SNAPSHOT,</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PROCSIG_RECOVERY_CONFLICT_BUFFERPIN,</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK,</font></div><div style="line-height: 28px;"   ><font size="2"   ><br style="line-height: 28px;"   ></font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; NUM_PROCSIGNALS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Must be last! */</font></div><div style="line-height: 28px;"   ><font size="2"   >} ProcSignalReason;</font></div><p></p></pre></div><div style="line-height: 28px;"   ><br></div></div></div><div>发生冲突导致Cancel query in hot standby的时候输出的错误日志 :&nbsp;</div><div>src/backend/tcop/postgres.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* errdetail_recovery_conflict</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Add an errdetail() line showing conflict source.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static int</font></div><div><font size="2"   >errdetail_recovery_conflict(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; switch (RecoveryConflictReason)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case PROCSIG_RECOVERY_CONFLICT_BUFFERPIN:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errdetail("User was holding shared buffer pin for too long.");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case PROCSIG_RECOVERY_CONFLICT_LOCK:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errdetail("User was holding a relation lock for too long.");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case PROCSIG_RECOVERY_CONFLICT_TABLESPACE:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errdetail("User was or might have been using tablespace that must be dropped.");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case PROCSIG_RECOVERY_CONFLICT_SNAPSHOT:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errdetail("User query might have needed to see row versions that must be removed.");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errdetail("User transaction caused buffer deadlock with recovery.");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case PROCSIG_RECOVERY_CONFLICT_DATABASE:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errdetail("User was connected to a database that must be dropped.");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* no errdetail */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>如何检查冲突</div><div><div>src/backend/storage/ipc/procsignal.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* CheckProcSignal - check to see if a particular reason has been</font></div><div><font size="2"   >&nbsp;* signaled, and clear the signal flag. &nbsp;Should be called after receiving</font></div><div><font size="2"   >&nbsp;* SIGUSR1.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static bool</font></div><div><font size="2"   >CheckProcSignal(ProcSignalReason reason)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; volatile ProcSignalSlot *slot = MyProcSignalSlot;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (slot != NULL)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Careful here --- don't clear flag if we haven't seen it set */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (slot-&gt;pss_signalFlags[reason])</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;pss_signalFlags[reason] = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* procsignal_sigusr1_handler - handle SIGUSR1 signal.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >procsignal_sigusr1_handler(SIGNAL_ARGS)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (CheckProcSignal(PROCSIG_CATCHUP_INTERRUPT))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HandleCatchupInterrupt();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (CheckProcSignal(PROCSIG_NOTIFY_INTERRUPT))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HandleNotifyInterrupt();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (CheckProcSignal(PROCSIG_RECOVERY_CONFLICT_DATABASE))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecoveryConflictInterrupt(PROCSIG_RECOVERY_CONFLICT_DATABASE);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (CheckProcSignal(PROCSIG_RECOVERY_CONFLICT_TABLESPACE))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecoveryConflictInterrupt(PROCSIG_RECOVERY_CONFLICT_TABLESPACE);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (CheckProcSignal(PROCSIG_RECOVERY_CONFLICT_LOCK))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecoveryConflictInterrupt(PROCSIG_RECOVERY_CONFLICT_LOCK);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (CheckProcSignal(PROCSIG_RECOVERY_CONFLICT_SNAPSHOT))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecoveryConflictInterrupt(PROCSIG_RECOVERY_CONFLICT_SNAPSHOT);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (CheckProcSignal(PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecoveryConflictInterrupt(PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (CheckProcSignal(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecoveryConflictInterrupt(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (set_latch_on_sigusr1 &amp;&amp; MyProc != NULL)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetLatch(&amp;MyProc-&gt;procLatch);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; latch_sigusr1_handler();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div></div><div><br></div><div>冲突达到预设时间后的处理方法 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* ProcessInterrupts: out-of-line portion of CHECK_FOR_INTERRUPTS() macro</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* If an interrupt condition is pending, and it's safe to service it,</font></div><div><font size="2"   >&nbsp;* then clear the flag and accept the interrupt. &nbsp;Called only when</font></div><div><font size="2"   >&nbsp;* InterruptPending is true.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >ProcessInterrupts(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* OK to accept any interrupts now? */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (InterruptHoldoffCount != 0 || CritSectionCount != 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; InterruptPending = false;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (ProcDiePending)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcDiePending = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QueryCancelPending = false; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* ProcDie trumps QueryCancel */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ImmediateInterruptOK = false; &nbsp; /* not idle anymore */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockErrorCleanup();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DisableNotifyInterrupt();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DisableCatchupInterrupt();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* As in quickdie, don't risk sending to client during auth */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ClientAuthInProgress &amp;&amp; whereToSendOutput == DestRemote)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; whereToSendOutput = DestNone;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (IsAutoVacuumWorkerProcess())</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_ADMIN_SHUTDOWN),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("terminating autovacuum process due to administrator command")));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (RecoveryConflictPending &amp;&amp; RecoveryConflictRetryable)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_recovery_conflict(RecoveryConflictReason);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_T_R_SERIALIZATION_FAILURE),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errmsg("terminating connection due to conflict with recovery"),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errdetail_recovery_conflict()));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (RecoveryConflictPending)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Currently there is only one non-retryable recovery conflict */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(RecoveryConflictReason == PROCSIG_RECOVERY_CONFLICT_DATABASE);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_recovery_conflict(RecoveryConflictReason);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_DATABASE_DROPPED),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errmsg("terminating connection due to conflict with recovery"),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errdetail_recovery_conflict()));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><div><font size="2"   >.....</font></div><p></p></pre></div><div><br></div><div>各种冲突的处理方法</div><div>src/backend/storage/ipc/standby.c</div><div>src/include/storage/standby.h</div><div><br></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >static void ResolveRecoveryConflictWithVirtualXIDs(VirtualTransactionId *waitlist,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ProcSignalReason reason);</font></div><div><font size="2"   >static void ResolveRecoveryConflictWithLock(Oid dbOid, Oid relOid);</font></div></div><div><div><font size="2"   >extern void ResolveRecoveryConflictWithSnapshot(TransactionId latestRemovedXid,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileNode node);</font></div><div><font size="2"   >extern void ResolveRecoveryConflictWithTablespace(Oid tsid);</font></div><div><font size="2"   >extern void ResolveRecoveryConflictWithDatabase(Oid dbid);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >extern void ResolveRecoveryConflictWithBufferPin(void);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >void</font></div><div><font size="2"   >ResolveRecoveryConflictWithDatabase(Oid dbid)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We don't do ResolveRecoveryConflictWithVirtualXIDs() here since that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* only waits for transactions and completely idle sessions would block</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* us. This is rare enough that we do this as simply as possible: no wait,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* just force them off immediately.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* No locking is required here because we already acquired</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* AccessExclusiveLock. Anybody trying to connect while we do this will</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* block during InitPostgres() and then disconnect when they see the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* database has been removed.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; while (CountDBBackends(dbid) &gt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CancelDBBackends(dbid, PROCSIG_RECOVERY_CONFLICT_DATABASE, true);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Wait awhile for them to die so that we avoid flooding an</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* unresponsive backend when system is heavily loaded.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_usleep(10000);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >static void</font></div><div><font size="2"   >ResolveRecoveryConflictWithLock(Oid dbOid, Oid relOid)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId *backends;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lock_acquired = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_attempts = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG &nbsp; &nbsp; &nbsp; &nbsp; locktag;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_RELATION(locktag, dbOid, relOid);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If blowing away everybody with conflicting locks doesn't work, after</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the first two attempts then we just start blowing everybody away until</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* it does work. We do this because its likely that we either have too</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* many locks and we just can't get one at all, or that there are many</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* people crowding for the same table. Recovery must win; the end</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* justifies the means.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; while (!lock_acquired)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (++num_attempts &lt; 3)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backends = GetLockConflicts(&amp;locktag, AccessExclusiveLock);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backends = GetConflictingVirtualXIDs(InvalidTransactionId,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;InvalidOid);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResolveRecoveryConflictWithVirtualXIDs(backends,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PROCSIG_RECOVERY_CONFLICT_LOCK);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (LockAcquireExtended(&amp;locktag, AccessExclusiveLock, true, true, false)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; != LOCKACQUIRE_NOT_AVAIL)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock_acquired = true;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >........</font></div><p></p></pre></div><div>注意, 在恢复模式中, startup进程负责恢复(即wal apply), 所以锁冲突检测很容易理解.</div><div>startup进程作为原始锁OWNER的代理, 并且只跟踪<span style="line-height: 28px;"   >AccessExclusiveLocks锁, 其他锁不关心, 所以在standby中的QUERY, 只有当其获得的锁和未来startup 进程从WAL解析到的对应数据库和对象的</span><span style="line-height: 28px;"   >AccessExclusiveLocks锁发生冲突时, 才会出现apply等待的情况.</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* -----------------------------------------------------</font></div><div><font size="2"   >&nbsp;* Locking in Recovery Mode</font></div><div><font size="2"   >&nbsp;* -----------------------------------------------------</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* All locks are held by the Startup process using a single virtual</font></div><div><font size="2"   >&nbsp;* transaction. This implementation is both simpler and in some senses,</font></div><div><font size="2"   >&nbsp;* more correct. The locks held mean "some original transaction held</font></div><div><font size="2"   >&nbsp;* this lock, so query access is not allowed at this time". So the Startup</font></div><div><font size="2"   >&nbsp;* process is the proxy by which the original locks are implemented.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We only keep track of AccessExclusiveLocks, which are only ever held by</font></div><div><font size="2"   >&nbsp;* one transaction on one relation, and don't worry about lock queuing.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We keep a single dynamically expandible list of locks in local memory,</font></div><div><font size="2"   >&nbsp;* RelationLockList, so we can keep track of the various entries made by</font></div><div><font size="2"   >&nbsp;* the Startup process's virtual xid in the shared lock table.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We record the lock against the top-level xid, rather than individual</font></div><div><font size="2"   >&nbsp;* subtransaction xids. This means AccessExclusiveLocks held by aborted</font></div><div><font size="2"   >&nbsp;* subtransactions are not released as early as possible on standbys.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* List elements use type xl_rel_lock, since the WAL record type exactly</font></div><div><font size="2"   >&nbsp;* matches the information that we need to keep track of.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We use session locks rather than normal locks so we don't need</font></div><div><font size="2"   >&nbsp;* ResourceOwners.</font></div><div><font size="2"   >&nbsp;*/</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >void</font></div><div><font size="2"   >StandbyAcquireAccessExclusiveLock(TransactionId xid, Oid dbOid, Oid relOid)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; xl_standby_lock *newlock;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG &nbsp; &nbsp; &nbsp; &nbsp; locktag;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Already processed? */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!TransactionIdIsValid(xid) ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdDidCommit(xid) ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdDidAbort(xid))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; elog(trace_recovery(DEBUG4),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"adding recovery lock: db %u rel %u", dbOid, relOid);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* dbOid is InvalidOid when we are locking a shared relation. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(relOid));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; newlock = palloc(sizeof(xl_standby_lock));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; newlock-&gt;xid = xid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; newlock-&gt;dbOid = dbOid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; newlock-&gt;relOid = relOid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; RecoveryLockList = lappend(RecoveryLockList, newlock);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Attempt to acquire the lock as requested, if not resolve conflict</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_RELATION(locktag, newlock-&gt;dbOid, newlock-&gt;relOid);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (LockAcquireExtended(&amp;locktag, AccessExclusiveLock, true, true, false)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; == LOCKACQUIRE_NOT_AVAIL)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResolveRecoveryConflictWithLock(newlock-&gt;dbOid, newlock-&gt;relOid);</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div>
<div><br></div><a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="about PostgreSQL hot standby query conflict with XLOG replay - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>