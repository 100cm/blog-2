<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.5 separate trigger Checkpoint & recycle xlogs</h2>
	<h5 id="">2015-03-26 11:55:55&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402015226114157379/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">PostgreSQL 9.5 以前的版本, 通过checkpoint_segments 来触发基于XLOG个数的检查点,&nbsp;<wbr><div>通过 " (2 + checkpoint_completion_target) * checkpoint_segments + 1 " 这个公式来技术保留的XLOG个数.</div><div><br></div><div>PostgreSQL 9.5 将废弃<span style="line-height: 28px;"   >checkpoint_segments</span><span style="line-height: 28px;"   >&nbsp;参数, 并引入</span>max_wal_size 和&nbsp;min_wal_size 参数, 通过<span style="line-height: 28px;"   >max_wal_size和</span>checkpoint_completion_target 参数来控制产生多少个XLOG后触发检查点, 通过<span style="line-height: 28px;"   >min_wal_size和</span><span style="line-height: 28px;"   >max_wal_size参数来控制哪些XLOG可以循环使用</span><span style="line-height: 28px;"   >.</span></div><div><span style="line-height: 28px;"   ><br></span></div><div>那么PostgreSQL 9.5如何计算什么时候触发检查点呢?</div><div>通过<span style="line-height: 28px;"   >CalculateCheckpointSegments函数来计算, 依赖</span><span style="line-height: 28px;"   >max_wal_size和</span><span style="line-height: 28px;"   >CheckPointCompletionTarget</span></div><div><span style="line-height: 28px;"   >target = (double ) max_wal_size / (2.0 + CheckPointCompletionTarget);</span></div><div><a target="_blank" rel="nofollow" href="http://git.postgresql.org/gitweb/?p=postgresql.git;a=blobdiff;f=src/backend/access/transam/xlog.c;h=a28155f977d67bac2fe8fe05461c730ea93cbca1;hp=f68f82b255c0608d7a7f958865a2abe3d179911c;hb=88e982302684;hpb=0fec000365c25fd89ea583673de226e816dba60f"   >http://git.postgresql.org/gitweb/?p=postgresql.git;a=blobdiff;f=src/backend/access/transam/xlog.c;h=a28155f977d67bac2fe8fe05461c730ea93cbca1;hp=f68f82b255c0608d7a7f958865a2abe3d179911c;hb=88e982302684;hpb=0fec000365c25fd89ea583673de226e816dba60f</a></div><div><span style="font-family: monospace; font-size: small; line-height: normal;"   >Replace&nbsp;checkpoint_segments&nbsp;with&nbsp;min_wal_size&nbsp;and&nbsp;max_wal_size.</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >Instead&nbsp;of&nbsp;having&nbsp;a&nbsp;single&nbsp;knob&nbsp;(checkpoint_segments)&nbsp;that&nbsp;both&nbsp;triggers</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >checkpoints,&nbsp;and&nbsp;determines&nbsp;how&nbsp;many&nbsp;checkpoints&nbsp;to&nbsp;recycle,&nbsp;they&nbsp;are&nbsp;now</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >separate&nbsp;concerns.&nbsp;There&nbsp;is&nbsp;still&nbsp;an&nbsp;internal&nbsp;variable&nbsp;called</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >CheckpointSegments,&nbsp;which&nbsp;triggers&nbsp;checkpoints.&nbsp;But&nbsp;it&nbsp;no&nbsp;longer&nbsp;determines</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >how&nbsp;many&nbsp;segments&nbsp;to&nbsp;recycle&nbsp;at&nbsp;a&nbsp;checkpoint.&nbsp;That&nbsp;is&nbsp;now&nbsp;auto-tuned&nbsp;by</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >keeping&nbsp;a&nbsp;moving&nbsp;average&nbsp;of&nbsp;the&nbsp;distance&nbsp;between&nbsp;checkpoints&nbsp;(in&nbsp;bytes),</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >and&nbsp;trying&nbsp;to&nbsp;keep&nbsp;that&nbsp;many&nbsp;segments&nbsp;in&nbsp;reserve.&nbsp;The&nbsp;advantage&nbsp;of&nbsp;this&nbsp;is</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >that&nbsp;you&nbsp;can&nbsp;set&nbsp;max_wal_size&nbsp;very&nbsp;high,&nbsp;but&nbsp;the&nbsp;system&nbsp;won't&nbsp;actually</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >consume&nbsp;that&nbsp;much&nbsp;space&nbsp;if&nbsp;there&nbsp;isn't&nbsp;any&nbsp;need&nbsp;for&nbsp;it.&nbsp;The&nbsp;min_wal_size</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >sets&nbsp;a&nbsp;floor&nbsp;for&nbsp;that;&nbsp;you&nbsp;can&nbsp;effectively&nbsp;disable&nbsp;the&nbsp;auto-tuning&nbsp;behavior</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >by&nbsp;setting&nbsp;min_wal_size&nbsp;equal&nbsp;to&nbsp;max_wal_size.</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >The&nbsp;max_wal_size&nbsp;setting&nbsp;is&nbsp;now&nbsp;the&nbsp;actual&nbsp;target&nbsp;size&nbsp;of&nbsp;WAL&nbsp;at&nbsp;which&nbsp;a</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >new&nbsp;checkpoint&nbsp;is&nbsp;triggered,&nbsp;instead&nbsp;of&nbsp;the&nbsp;distance&nbsp;between&nbsp;checkpoints.</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >Previously,&nbsp;you&nbsp;could&nbsp;calculate&nbsp;the&nbsp;actual&nbsp;WAL&nbsp;usage&nbsp;with&nbsp;the&nbsp;formula</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >"(2&nbsp;+&nbsp;checkpoint_completion_target)&nbsp;*&nbsp;checkpoint_segments&nbsp;+&nbsp;1".&nbsp;With&nbsp;this</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >patch,&nbsp;you&nbsp;set&nbsp;the&nbsp;desired&nbsp;WAL&nbsp;usage&nbsp;with&nbsp;max_wal_size,&nbsp;and&nbsp;the&nbsp;system</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >calculates&nbsp;the&nbsp;appropriate&nbsp;CheckpointSegments&nbsp;with&nbsp;the&nbsp;reverse&nbsp;of&nbsp;that</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >formula.&nbsp;That's&nbsp;a&nbsp;lot&nbsp;more&nbsp;intuitive&nbsp;for&nbsp;administrators&nbsp;to&nbsp;set.</span><br style="font-family: monospace; font-size: small; line-height: normal;"   ><br style="font-family: monospace; font-size: small; line-height: normal;"   ><span style="font-family: monospace; font-size: small; line-height: normal;"   >Reviewed&nbsp;by&nbsp;Amit&nbsp;Kapila&nbsp;and&nbsp;Venkata&nbsp;Balaji&nbsp;N.</span></div><div><br></div><div><br></div><div>src/backend/access/transam/xlog.c</div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 28px;"   ><font size="2"   >+ * Calculate CheckPointSegments based on max_wal_size and</font></span></div><div><div><font size="2"   >+ * checkpoint_completion_target.</font></div><div><font size="2"   >+ */</font></div><div><font size="2"   >+static void</font></div><div><font size="2"   >+CalculateCheckpointSegments(void)</font></div><div><font size="2"   >+{</font></div><div><font size="2"   >+ &nbsp; double &nbsp; &nbsp; &nbsp;target;</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; /*-------</font></div><div><font size="2"   >+ &nbsp; &nbsp;* Calculate the distance at which to trigger a checkpoint, to avoid</font></div><div><font size="2"   >+ &nbsp; &nbsp;* exceeding max_wal_size. This is based on two assumptions:</font></div><div><font size="2"   >+ &nbsp; &nbsp;*</font></div><div><font size="2"   >+ &nbsp; &nbsp;* a) we keep WAL for two checkpoint cycles, back to the "prev" checkpoint.</font></div><div><font size="2"   >+ &nbsp; &nbsp;* b) during checkpoint, we consume checkpoint_completion_target *</font></div><div><font size="2"   >+ &nbsp; &nbsp;* &nbsp; &nbsp;number of segments consumed between checkpoints.</font></div><div><font size="2"   >+ &nbsp; &nbsp;*-------</font></div><div><font size="2"   >+ &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; target = (double ) max_wal_size / (2.0 + CheckPointCompletionTarget);</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; /* round down */</font></div><div><font size="2"   >+ &nbsp; CheckPointSegments = (int) target;</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; if (CheckPointSegments &lt; 1)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; CheckPointSegments = 1;</font></div><div><font size="2"   >+}</font></div></div><p></p></pre></div><div><br></div><div>计算哪些旧的XLOG可以循环使用(不删除, 直接INIT).</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >+/*</font></div><div><font size="2"   >+ * At a checkpoint, how many WAL segments to recycle as preallocated future</font></div><div><font size="2"   >+ * XLOG segments? Returns the highest segment that should be preallocated.</font></div><div><font size="2"   >+ */</font></div><div><font size="2"   >+static XLogSegNo</font></div><div><font size="2"   >+XLOGfileslop(XLogRecPtr PriorRedoPtr)</font></div><div><font size="2"   >+{</font></div><div><font size="2"   >+ &nbsp; XLogSegNo &nbsp; minSegNo;</font></div><div><font size="2"   >+ &nbsp; XLogSegNo &nbsp; maxSegNo;</font></div><div><font size="2"   >+ &nbsp; double &nbsp; &nbsp; &nbsp;distance;</font></div><div><font size="2"   >+ &nbsp; XLogSegNo &nbsp; recycleSegNo;</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp;* Calculate the segment numbers that min_wal_size and max_wal_size</font></div><div><font size="2"   >+ &nbsp; &nbsp;* correspond to. Always recycle enough segments to meet the minimum, and</font></div><div><font size="2"   >+ &nbsp; &nbsp;* remove enough segments to stay below the maximum.</font></div><div><font size="2"   >+ &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; minSegNo = PriorRedoPtr / XLOG_SEG_SIZE + min_wal_size - 1;</font></div><div><font size="2"   >+ &nbsp; maxSegNo = &nbsp;PriorRedoPtr / XLOG_SEG_SIZE + max_wal_size - 1;</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp;* Between those limits, recycle enough segments to get us through to the</font></div><div><font size="2"   >+ &nbsp; &nbsp;* estimated end of next checkpoint.</font></div><div><font size="2"   >+ &nbsp; &nbsp;*</font></div><div><font size="2"   >+ &nbsp; &nbsp;* To estimate where the next checkpoint will finish, assume that the</font></div><div><font size="2"   >+ &nbsp; &nbsp;* system runs steadily consuming CheckPointDistanceEstimate</font></div><div><font size="2"   >+ &nbsp; &nbsp;* bytes between every checkpoint.</font></div><div><font size="2"   >+ &nbsp; &nbsp;*</font></div><div><font size="2"   >+ &nbsp; &nbsp;* The reason this calculation is done from the prior checkpoint, not the</font></div><div><font size="2"   >+ &nbsp; &nbsp;* one that just finished, is that this behaves better if some checkpoint</font></div><div><font size="2"   >+ &nbsp; &nbsp;* cycles are abnormally short, like if you perform a manual checkpoint</font></div><div><font size="2"   >+ &nbsp; &nbsp;* right after a timed one. The manual checkpoint will make almost a full</font></div><div><font size="2"   >+ &nbsp; &nbsp;* cycle's worth of WAL segments available for recycling, because the</font></div><div><font size="2"   >+ &nbsp; &nbsp;* segments from the prior's prior, fully-sized checkpoint cycle are no</font></div><div><font size="2"   >+ &nbsp; &nbsp;* longer needed. However, the next checkpoint will make only few segments</font></div><div><font size="2"   >+ &nbsp; &nbsp;* available for recycling, the ones generated between the timed</font></div><div><font size="2"   >+ &nbsp; &nbsp;* checkpoint and the manual one right after that. If at the manual</font></div><div><font size="2"   >+ &nbsp; &nbsp;* checkpoint we only retained enough segments to get us to the next timed</font></div><div><font size="2"   >+ &nbsp; &nbsp;* one, and removed the rest, then at the next checkpoint we would not</font></div><div><font size="2"   >+ &nbsp; &nbsp;* have enough segments around for recycling, to get us to the checkpoint</font></div><div><font size="2"   >+ &nbsp; &nbsp;* after that. Basing the calculations on the distance from the prior redo</font></div><div><font size="2"   >+ &nbsp; &nbsp;* pointer largely fixes that problem.</font></div><div><font size="2"   >+ &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; distance = (2.0 + CheckPointCompletionTarget) * CheckPointDistanceEstimate;</font></div><div><font size="2"   >+ &nbsp; /* add 10% for good measure. */</font></div><div><font size="2"   >+ &nbsp; distance *= 1.10;</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; recycleSegNo = (XLogSegNo) ceil(((double) PriorRedoPtr + distance) / XLOG_SEG_SIZE);</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; if (recycleSegNo &lt; minSegNo)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; recycleSegNo = minSegNo;</font></div><div><font size="2"   >+ &nbsp; if (recycleSegNo &gt; maxSegNo)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; recycleSegNo = maxSegNo;</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; return recycleSegNo;</font></div><div><font size="2"   >+}</font></div><p></p></pre></div><div><br></div><div>参数解释 :&nbsp;</div><div><p><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/runtime-config-wal.html"   >http://www.postgresql.org/docs/devel/static/runtime-config-wal.html</a></p></div><div><dt style="font-family: verdana, sans-serif; font-size: 12.1599998474121px; line-height: normal;"   ><tt>min_wal_size</tt>&nbsp;(<tt>integer</tt>)</dt><dd style="font-family: verdana, sans-serif; font-size: 12.1599998474121px; line-height: normal;"   ><p style="font-size: 1em; line-height: 1.5em; margin: 1.2em 0em;"   >As long as WAL disk usage stays below this setting, old WAL files are always recycled for future use at a checkpoint, rather than removed. This can be used to ensure that enough WAL space is reserved to handle spikes in WAL usage, for example when running large batch jobs. The default is 80 MB. This parameter can only be set in the&nbsp;<tt>postgresql.conf</tt>&nbsp;file or on the server command line.</p></dd></div><div><dt style="font-family: verdana, sans-serif; font-size: 12.1599998474121px; line-height: normal;"   ><tt>max_wal_size</tt>&nbsp;(<tt>integer</tt>)</dt><dd style="font-family: verdana, sans-serif; font-size: 12.1599998474121px; line-height: normal;"   ><p style="font-size: 1em; line-height: 1.5em; margin: 1.2em 0em;"   >Maximum size to let the WAL grow to between automatic WAL checkpoints. This is a soft limit; WAL size can exceed&nbsp;<tt>max_wal_size</tt>&nbsp;under special circumstances, like under heavy load, a failing&nbsp;<tt>archive_command</tt>, or a high&nbsp;<tt>wal_keep_segments</tt>&nbsp;setting. The default is 1 GB. Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the&nbsp;<tt>postgresql.conf</tt>&nbsp;file or on the server command line.</p></dd></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL 9.5 separate trigger Checkpoint  recycle xlogs - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>