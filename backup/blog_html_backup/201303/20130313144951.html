<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.3 Event Trigger</h2>
	<h5 id="">2013-03-13 14:49:51&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020132131361949/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 9.3 将引入事件触发器, 与普通触发器不同的是, 事件触发器是数据库全局的触发器, 可以由DDL事件来触发.</div><div><pre class="prettyprint"   ><p><font size="2"   >Unlike regular triggers, which are attached to a single table and capture only DML events, event triggers are global to a particular database and are capable of capturing DDL events.</font></p></pre></div><div>事件触发器同样可以使用C, plpgsql或者其他的过程语言的函数来编写, 但是不能使用SQL语言函数来编写.</div><div>由于事件触发器涉及的权限较大, 例如能禁止DDL操作等, 所以只能使用超级用户创建事件触发器.</div><div>在创建事件触发器之前必须先创建触发器函数, 触发器函数的返回类型为event_trigger. (注意区分我们以前所熟悉的普通触发器函数的返回类型为trigger.)</div><div>事件触发器的语法 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Command: &nbsp; &nbsp; CREATE EVENT TRIGGER</font></div><div><font size="2"   >Description: define a new event trigger</font></div><div><font size="2"   >Syntax:</font></div><div><font size="2"   >CREATE EVENT TRIGGER name</font></div><div><font size="2"   >&nbsp; ON event</font></div><div><font size="2"   >&nbsp; [ WHEN filter_variable IN (filter_value [, ... ]) [ AND ... ] ]</font></div><div><font size="2"   >&nbsp; EXECUTE PROCEDURE function_name()</font></div><p></p></pre></div><div>语法解释 :&nbsp;</div><div>-- name : 触发器名称</div><div>-- event : 事件名称, 现在支持的事件为ddl_command_start 和 ddl_command_end.</div><div><span style="line-height: 22px;"   >支持触发事件触发器的DDL如下(包括select into) :&nbsp;</span></div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/event-trigger-matrix.html"   >http://www.postgresql.org/docs/devel/static/event-trigger-matrix.html</a></div><div>但是触发事件中不包括对系统共享对象的CREATE, ALTER, DROP操作, 如 :&nbsp;</div><div>databases, roles, and tablespaces</div><div>同样对事件触发器本身的DDL操作也不会触发事件触发器.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >The ddl_command_start event occurs just before the execution of a CREATE, ALTER, or DROP command. As an exception, however, this event does not occur for DDL commands targeting shared objects - databases, roles, and tablespaces - or for command targeting event triggers themselves. The event trigger mechanism does not support these object types. ddl_command_start also occurs just before the execution of a SELECT INTO command, since this is equivalent to CREATE TABLE AS.&nbsp;</font></div><div><font size="2"   >The ddl_command_end event occurs just after the execution of this same set of commands.</font></div><p></p></pre></div><div>-- filter_variable目前只支持TAG</div><div>-- filter_value是<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/event-trigger-matrix.html"   >http://www.postgresql.org/docs/devel/static/event-trigger-matrix.html</a>这里定义的<span style="line-height: 22px;"   >DDL</span></div><div>-- function_name就是我们创建好的事件触发器函数.</div><div><br></div><div>以plpgsql函数语言为例讲解事件触发器函数的创建方法 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >PL/pgSQL can be used to define event triggers. PostgreSQL requires that a procedure that is to be called as an event trigger must be declared as a function with no arguments and a return type of event_trigger.</font></div><div><font size="2"   >When a PL/pgSQL function is called as a event trigger, several special variables are created automatically in the top-level block. They are:</font></div><div><font size="2"   >TG_EVENT</font></div><div><font size="2"   >Data type text; a string representing the event the trigger is fired for.</font></div><div><font size="2"   >TG_TAG</font></div><div><font size="2"   >Data type text; variable that contains the command tag for which the trigger is fired.</font></div><p></p></pre></div><div>事件触发器函数的返回类型为event_trigger, 同时事件触发器的顶级块带入了两个特殊变量, TG_EVENT和TG_TAG.</div><div>TG_EVENT表示EVENT信息, 如现在支持的为<span style="line-height: 22px;"   >ddl_command_start 和 ddl_command_end.</span></div><div><span style="line-height: 22px;"   >TG_TAG表示的是DDL信息, 信息在</span><a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/event-trigger-matrix.html"   >http://www.postgresql.org/docs/devel/static/event-trigger-matrix.html</a>查询.</div><div><br></div><div>【如果同一个事件上建立了多个事件触发器, 执行顺序按触发器名字的字母先后顺序来执行, 这个和普通触发器的触发规则是一样的.】</div><div>如下 :&nbsp;</div><div>-- 创建两个触发器函数, 返回event_trigger类型 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >CREATE OR REPLACE FUNCTION etgr1() &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; RETURNS event_trigger &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp; AS $$</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; RAISE NOTICE 'this is etgr1, event:%, command:%', tg_event, tg_tag;</font></div><div><font size="2"   >&nbsp;END;</font></div><div><font size="2"   >$$;</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >CREATE OR REPLACE FUNCTION etgr2() &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; RETURNS event_trigger &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp; AS $$</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; RAISE NOTICE 'this is etgr2, event:%, command:%', tg_event, tg_tag;</font></div><div><font size="2"   >&nbsp;END;</font></div><div><font size="2"   >$$;</font></div></div><p></p></pre></div><div>-- 创建事件触发器, 这里未使用WHEN, 也就是所有的DDL都触发这些事件触发器(除了前面提到的触发器本身的DDL和共享对象的DDL) :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE EVENT TRIGGER b ON ddl_command_start EXECUTE PROCEDURE etgr1();</font></div><div><font size="2"   >CREATE EVENT TRIGGER a ON ddl_command_start EXECUTE PROCEDURE etgr2();</font></div><p></p></pre></div><div><br></div><div>--&nbsp;<span style="line-height: 22px;"   >同一个事件类型ddl_command_start下创建了2个事件触发器,&nbsp;</span><span style="line-height: 22px;"   >事件触发器的名称分别为a和b, 调用的先后顺序按字母顺序来, 如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table digoal(id int);</font></div><div><font size="2"   >NOTICE: &nbsp;this is etgr2, event:ddl_command_start, command:CREATE TABLE</font></div><div><font size="2"   >NOTICE: &nbsp;this is etgr1, event:ddl_command_start, command:CREATE TABLE</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div><br></div><div>-- 查询当前数据库中有哪些事件触发器 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from pg_event_trigger ;</font></div><div><font size="2"   >&nbsp;evtname | &nbsp; &nbsp; evtevent &nbsp; &nbsp; &nbsp;| evtowner | evtfoid | evtenabled | evttags&nbsp;</font></div><div><font size="2"   >---------+-------------------+----------+---------+------------+---------</font></div><div><font size="2"   >&nbsp;b &nbsp; &nbsp; &nbsp; | ddl_command_start | &nbsp; &nbsp; &nbsp; 10 | &nbsp; 16669 | O &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;a &nbsp; &nbsp; &nbsp; | ddl_command_start | &nbsp; &nbsp; &nbsp; 10 | &nbsp; 16671 | O &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>-- evtowner是创建事件触发器的用户, 例如上面两个事件触发器我是用postgres用户创建的。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select rolname from pg_roles where oid=10;</font></div><div><font size="2"   >&nbsp;rolname &nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;postgres</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>-- evtfoid指事件触发器函数的oid,</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select proname from pg_proc where oid=16669;</font></div><div><font size="2"   >&nbsp;proname&nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;etgr1</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=# select proname from pg_proc where oid=16671;</font></div><div><font size="2"   >&nbsp;proname&nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;etgr2</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div><br></div><div>【事件触发器和DDL语句本身是在同一个事务中处理的, 所以任何事件触发器抛出异常的话, 整个事务都会回滚, 并且后续的操作也不会执行下去.】</div><div>例如 :&nbsp;</div><div>-- 创建事件触发器函数, 函数直接抛出异常.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create or replace function abort1() returns event_trigger as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; raise exception 'event:%, command:%. abort.', TG_EVENT, TG_TAG;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><p></p></pre></div><div>-- 创建<span style="line-height: 22px;"   >ddl_command_end</span><span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >事件触发器</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create event trigger tg_abort1 on ddl_command_end execute procedure abort1();</font></div><div><font size="2"   >CREATE EVENT TRIGGER</font></div><p></p></pre></div><div>-- 执行DDL语句, 如下, 在调用了a和b事件触发器后, 最后调用ddl_command_end的触发器, 抛出异常</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table digoal1(id int);</font></div><div><font size="2"   >NOTICE: &nbsp;this is etgr2, event:ddl_command_start, command:CREATE TABLE</font></div><div><font size="2"   >NOTICE: &nbsp;this is etgr1, event:ddl_command_start, command:CREATE TABLE</font></div><div><font size="2"   >ERROR: &nbsp;event:ddl_command_end, command:CREATE TABLE. abort.</font></div><p></p></pre></div></div><div>-- 异常导致表创建失败</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# \d digoal1</font></div><div><font size="2"   >Did not find any relation named "digoal1".</font></div><p></p></pre></div><div>-- 再创建1个事件触发器, 放在ddl_command_start 事件中</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create event trigger tg_abort2 on ddl_command_start execute procedure abort1();</font></div><div><font size="2"   >CREATE EVENT TRIGGER</font></div><div><font size="2"   >digoal=# create table digoal1(id int);</font></div><div><font size="2"   >NOTICE: &nbsp;this is etgr2, event:ddl_command_start, command:CREATE TABLE</font></div><div><font size="2"   >NOTICE: &nbsp;this is etgr1, event:ddl_command_start, command:CREATE TABLE</font></div><div><font size="2"   >ERROR: &nbsp;event:ddl_command_start, command:CREATE TABLE. abort.</font></div><p></p></pre></div><div>-- 同样会导致DDL执行失败. 这就达到了禁止执行DDL的目的.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create event trigger abort2 on ddl_command_start execute procedure abort1();</font></div><div><font size="2"   >CREATE EVENT TRIGGER</font></div></div><div><div><font size="2"   >digoal=# create table digoal1(id int);</font></div><div><font size="2"   >NOTICE: &nbsp;this is etgr2, event:ddl_command_start, command:CREATE TABLE</font></div><div><font size="2"   >ERROR: &nbsp;event:ddl_command_start, command:CREATE TABLE. abort.</font></div></div><div><div><font size="2"   >digoal=# \d digoal1</font></div><div><font size="2"   >Did not find any relation named "digoal1".</font></div></div><p></p></pre></div><div>-- 当前数据库中的事件触发器如下</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from pg_event_trigger ;</font></div><div><font size="2"   >&nbsp; evtname &nbsp;| &nbsp; &nbsp; evtevent &nbsp; &nbsp; &nbsp;| evtowner | evtfoid | evtenabled | evttags&nbsp;</font></div><div><font size="2"   >-----------+-------------------+----------+---------+------------+---------</font></div><div><font size="2"   >&nbsp;b &nbsp; &nbsp; &nbsp; &nbsp; | ddl_command_start | &nbsp; &nbsp; &nbsp; 10 | &nbsp; 16669 | O &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;a &nbsp; &nbsp; &nbsp; &nbsp; | ddl_command_start | &nbsp; &nbsp; &nbsp; 10 | &nbsp; 16671 | O &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;tg_abort1 | ddl_command_end &nbsp; | &nbsp; &nbsp; &nbsp; 10 | &nbsp; 16676 | O &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;tg_abort2 | ddl_command_start | &nbsp; &nbsp; &nbsp; 10 | &nbsp; 16676 | O &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;abort2 &nbsp; &nbsp;| ddl_command_start | &nbsp; &nbsp; &nbsp; 10 | &nbsp; 16676 | O &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div><br></div><div>【事件触发器应用举例 : 】</div><div>1. 禁止postgres用户在数据库digoal中执行CREATE TABLE和DROP TABLE命令.</div><div>首先把已有的事件触发器删除, 方便观看测试效果.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# drop event trigger tg_abort1;</font></div><div><font size="2"   >DROP EVENT TRIGGER</font></div><div><font size="2"   >digoal=# drop event trigger tg_abort2;</font></div><div><font size="2"   >DROP EVENT TRIGGER</font></div><div><font size="2"   >digoal=# drop event trigger abort2;</font></div><div><font size="2"   >DROP EVENT TRIGGER</font></div></div><div><div><font size="2"   >digoal=# drop event trigger a;</font></div><div><font size="2"   >DROP EVENT TRIGGER</font></div><div><font size="2"   >digoal=# drop event trigger b;</font></div><div><font size="2"   >DROP EVENT TRIGGER</font></div></div><div><div><font size="2"   >digoal=# select * from pg_event_trigger ;</font></div><div><font size="2"   >&nbsp;evtname | evtevent | evtowner | evtfoid | evtenabled | evttags&nbsp;</font></div><div><font size="2"   >---------+----------+----------+---------+------------+---------</font></div><div><font size="2"   >(0 rows)</font></div></div><p></p></pre></div><div>-- 创建触发器函数 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE OR REPLACE FUNCTION abort() &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; RETURNS event_trigger &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp; AS $$</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; if current_user = 'postgres' then</font></div><div><font size="2"   >&nbsp; &nbsp; RAISE EXCEPTION 'event:%, command:%', tg_event, tg_tag;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp;END;</font></div><div><font size="2"   >$$;</font></div><p></p></pre></div><div>-- 创建触发器 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create event trigger a on ddl_command_start when TAG IN ('CREATE TABLE', 'DROP TABLE') execute procedure abort();</font></div><div><font size="2"   >CREATE EVENT TRIGGER</font></div><div><font size="2"   >digoal=# select * from pg_event_trigger ;</font></div><div><font size="2"   >&nbsp;evtname | &nbsp; &nbsp; evtevent &nbsp; &nbsp; &nbsp;| evtowner | evtfoid | evtenabled | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;evttags &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >---------+-------------------+----------+---------+------------+-------------------------------</font></div><div><font size="2"   >&nbsp;a &nbsp; &nbsp; &nbsp; | ddl_command_start | &nbsp; &nbsp; &nbsp; 10 | &nbsp; 16683 | O &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| {"CREATE TABLE","DROP TABLE"}</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>-- 测试postgres用户是否可以使用create table和drop table .</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# \c digoal postgres</font></div><div><font size="2"   >You are now connected to database "digoal" as user "postgres".</font></div><div><font size="2"   >-- 无法新建表了</font></div><div><font size="2"   >digoal=# create table new(id int);</font></div><div><font size="2"   >ERROR: &nbsp;event:ddl_command_start, command:CREATE TABLE</font></div><div><font size="2"   >digoal=# \d new</font></div><div><font size="2"   >Did not find any relation named "new".</font></div></div><div><div><font size="2"   >digoal=# \dt</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp;Name &nbsp; | Type &nbsp;| &nbsp;Owner &nbsp;&nbsp;</font></div><div><font size="2"   >--------+---------+-------+----------</font></div><div><font size="2"   >&nbsp;public | digoal &nbsp;| table | postgres</font></div><div><font size="2"   >&nbsp;public | digoal1 | table | postgres</font></div><div><font size="2"   >&nbsp;public | test &nbsp; &nbsp;| table | postgres</font></div><div><font size="2"   >(3 rows)</font></div><div><font size="2"   >-- 无法删表了</font></div><div><font size="2"   >digoal=# drop table digoal;</font></div><div><font size="2"   >ERROR: &nbsp;event:ddl_command_start, command:DROP TABLE</font></div><div><font size="2"   >digoal=# \d digoal</font></div><div><font size="2"   >&nbsp; &nbsp; Table "public.digoal"</font></div><div><font size="2"   >&nbsp;Column | &nbsp;Type &nbsp; | Modifiers&nbsp;</font></div><div><font size="2"   >--------+---------+-----------</font></div><div><font size="2"   >&nbsp;id &nbsp; &nbsp; | integer |&nbsp;</font></div></div><p></p></pre></div><div>-- 测试其他用户是否会有影响</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# \c digoal digoal</font></div><div><font size="2"   >You are now connected to database "digoal" as user "digoal".</font></div><div><font size="2"   >digoal=&gt; create table tbl(id int);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=&gt; drop table tbl;</font></div><div><font size="2"   >DROP TABLE</font></div></div><div><font size="2"   >-- 未受到影响.</font></div><p></p></pre></div><div><br></div><div>【其他】</div><div>1. 事件触发器还可以结合会话参数session_replication_role来使用, 例如仅针对replica角色生效, 其他不生效.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Command: &nbsp; &nbsp; ALTER EVENT TRIGGER</font></div><div><font size="2"   >Description: change the definition of an event trigger</font></div><div><font size="2"   >Syntax:</font></div><div><font size="2"   >ALTER EVENT TRIGGER name DISABLE</font></div><div><font size="2"   >ALTER EVENT TRIGGER name ENABLE [ REPLICA | ALWAYS ]</font></div><div><font size="2"   >ALTER EVENT TRIGGER name OWNER TO new_owner</font></div><div><font size="2"   >ALTER EVENT TRIGGER name RENAME TO new_name</font></div><p></p></pre></div><div>具体用法可参见trigger的用法介绍 :&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402013283547959/"   >http://blog.163.com/digoal@126/blog/static/1638770402013283547959/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402013211102130526/"   >http://blog.163.com/digoal@126/blog/static/1638770402013211102130526/</a></div><div>2.&nbsp;<span style="line-height: 22px;"   >我们知道PostgreSQL没有像Oracle里面的DBA_OBJECTS表, 无法得知创建时间, ALTER时间.</span></div><div style="line-height: 22px;"   >&nbsp; &nbsp;使用事件触发器这个将会变成可能, 但是目前的事件触发器函数仅仅支持TG_EVENT和TG_TAG变量, 如果能加入TG_RELID, 那么就可以在DDL的时候记录这个事件到一个对象表中. 从而达到跟踪对象被执行DDL的时间的目的.</div><div style="line-height: 22px;"   >3. 事件触发器实际上是通过钩子实现的，例如 InvokeObjectPostCreateHook 在创建对象结束时调用。</div><div style="line-height: 22px;"   >src/backend/catalog/objectaccess.c</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* RunObjectPostCreateHook</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* It is entrypoint of OAT_POST_CREATE event</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >RunObjectPostCreateHook(Oid classId, Oid objectId, int subId,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool is_internal)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ObjectAccessPostCreate pc_arg;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* caller should check, but just in case... */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(object_access_hook != NULL);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;pc_arg, 0, sizeof(ObjectAccessPostCreate));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pc_arg.is_internal = is_internal;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; (*object_access_hook) (OAT_POST_CREATE,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;classId, objectId, subId,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(void *) &amp;pc_arg);</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div style="line-height: 22px;"   ><br></div></div><div>src/include/catalog/objectaccess.h</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/* Core code uses these functions to call the hook (see macros below). */</font></div><div><font size="2"   >extern void RunObjectPostCreateHook(Oid classId, Oid objectId, int subId,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool is_internal);</font></div><div><font size="2"   >extern void RunObjectDropHook(Oid classId, Oid objectId, int subId,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int dropflags);</font></div><div><font size="2"   >extern void RunObjectPostAlterHook(Oid classId, Oid objectId, int subId,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Oid auxiliaryId, bool is_internal);</font></div><div><font size="2"   >extern bool RunNamespaceSearchHook(Oid objectId, bool ereport_on_volation);</font></div><div><font size="2"   >extern void RunFunctionExecuteHook(Oid objectId);</font></div></div><div><font size="2"   >。。。。。。</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* The following macros are wrappers around the functions above; these should</font></div><div><font size="2"   >&nbsp;* normally be used to invoke the hook in lieu of calling the above functions</font></div><div><font size="2"   >&nbsp;* directly.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define InvokeObjectPostCreateHook(classId,objectId,subId) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; InvokeObjectPostCreateHookArg((classId),(objectId),(subId),false)</font></div><div><font size="2"   >#define InvokeObjectPostCreateHookArg(classId,objectId,subId,is_internal) \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; do { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (object_access_hook) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RunObjectPostCreateHook((classId),(objectId),(subId), &nbsp; \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (is_internal)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; } while(0)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >。。。。。。</font></div><p></p></pre></div><div>在函数中执行DDL，同样被审查，因为HOOK不是语义层面的，而是执行层面的。</div><div>例如：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create or replace function fe() returns event_trigger as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; if current_user = 'digoal' then</font></div><div><font size="2"   >&nbsp; &nbsp; raise exception 'can not execute ddl';</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql strict;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# CREATE EVENT TRIGGER a ON ddl_command_start EXECUTE PROCEDURE fe();</font></div><div><font size="2"   >CREATE EVENT TRIGGER</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# \c postgres digoal</font></div><div><font size="2"   >You are now connected to database "postgres" as user "digoal".</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=&gt; create table tbl(id int);</font></div><div><font size="2"   >ERROR: &nbsp;can not execute ddl</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=&gt; do language plpgsql $$</font></div><div><font size="2"   >postgres$&gt; declare</font></div><div><font size="2"   >postgres$&gt; begin</font></div><div><font size="2"   >postgres$&gt; &nbsp; execute 'create table tbl (id int)';</font></div><div><font size="2"   >postgres$&gt; end;</font></div><div><font size="2"   >postgres$&gt; $$;</font></div><div><font size="2"   >ERROR: &nbsp;can not execute ddl</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "create table tbl (id int)"</font></div><div><font size="2"   >PL/pgSQL function inline_code_block line 4 at EXECUTE statement</font></div><p></p></pre></div><div><br></div>【参考】<div>1.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/event-triggers.html"   >http://www.postgresql.org/docs/devel/static/event-triggers.html</a></div><div>2.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/plpgsql-trigger.html"   >http://www.postgresql.org/docs/devel/static/plpgsql-trigger.html</a></div><div>3.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/sql-createeventtrigger.html"   >http://www.postgresql.org/docs/devel/static/sql-createeventtrigger.html</a><br>4.&nbsp;<wbr><a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/catalog-pg-event-trigger.html"   >http://www.postgresql.org/docs/devel/static/catalog-pg-event-trigger.html</a></div><div><div style="line-height: 22px;"   >5.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402013283547959/"   >http://blog.163.com/digoal@126/blog/static/1638770402013283547959/</a></div><div style="line-height: 22px;"   >6.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402013211102130526/"   >http://blog.163.com/digoal@126/blog/static/1638770402013211102130526/</a></div></div>7.&nbsp;<a target="_blank" rel="nofollow" href="http://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=3a0e4d36ebd7f477822d5bae41ba121a40d22ccc"   >http://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=3a0e4d36ebd7f477822d5bae41ba121a40d22ccc</a></div>
	</div>
</div>
</body>
</html>