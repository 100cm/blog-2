<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.3 tuplesort memory usage: grow_memtuples</h2>
	<h5 id="">2013-03-13 12:53:56&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013213113359140/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>2012年3月份的一个SUBJECT, 减少排序的内存使用量.</div><div>测试 :&nbsp;</div><div>打补丁前 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >ocz@db-172-16-3-150-&gt; psql</font></div><div><font size="2"   >psql (9.2.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >postgres=# \timing</font></div><div><font size="2"   >Timing is on.</font></div><div><font size="2"   >postgres=# set work_mem=16384;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >Time: 0.281 ms</font></div><div><font size="2"   >postgres=# set client_min_messages =log;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >Time: 0.131 ms</font></div><div><font size="2"   >postgres=# set trace_sort = on;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >Time: 0.132 ms</font></div><div><font size="2"   >postgres=# \set VERBOSITY verbose</font></div><div><font size="2"   >postgres=# select count(distinct foo) from (select random() as foo from</font></div><div><font size="2"   >generate_series(1,524200)) asdf;</font></div><div><font size="2"   >LOG: &nbsp;00000: begin datum sort: workMem = 16384, randomAccess = f</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_begin_datum, tuplesort.c:809</font></div><div><font size="2"   >LOG: &nbsp;00000: performsort starting: CPU 0.01s/0.14u sec elapsed 0.15 sec</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_performsort, tuplesort.c:1232</font></div><div><font size="2"   >LOG: &nbsp;00000: performsort done: CPU 0.01s/0.58u sec elapsed 0.59 sec</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_performsort, tuplesort.c:1307</font></div><div><font size="2"   >LOG: &nbsp;00000: <font color="#ff0000"   >internal sort</font> ended, <font color="#ff0000"   >12289 KB used</font>: CPU 0.01s/0.63u sec elapsed 0.64 sec</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_end, tuplesort.c:923</font></div><div><font size="2"   >&nbsp;count &nbsp;</font></div><div><font size="2"   >--------</font></div><div><font size="2"   >&nbsp;524134</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 778.650 ms</font></div><div><font size="2"   >postgres=# select count(distinct foo) from (select random() as foo from</font></div><div><font size="2"   >generate_series(1,524300)) asdf;</font></div><div><font size="2"   >LOG: &nbsp;00000: begin datum sort: workMem = 16384, randomAccess = f</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_begin_datum, tuplesort.c:809</font></div><div><font size="2"   >LOG: &nbsp;00000: switching to external sort with 59 tapes: CPU 0.01s/0.14u sec elapsed 0.15 sec</font></div><div><font size="2"   >LOCATION: &nbsp;inittapes, tuplesort.c:1683</font></div><div><font size="2"   >LOG: &nbsp;00000: performsort starting: CPU 0.01s/0.20u sec elapsed 0.22 sec</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_performsort, tuplesort.c:1232</font></div><div><font size="2"   >LOG: &nbsp;00000: finished writing final run 1 to tape 0: CPU 0.02s/1.14u sec elapsed 1.17 sec</font></div><div><font size="2"   >LOCATION: &nbsp;dumptuples, tuplesort.c:2227</font></div><div><font size="2"   >LOG: &nbsp;00000: performsort done: CPU 0.02s/1.14u sec elapsed 1.17 sec</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_performsort, tuplesort.c:1307</font></div><div><font size="2"   >LOG: &nbsp;00000: <font color="#ff0000"   >external sort</font> ended, <font color="#ff0000"   >769 disk blocks used</font>: CPU 0.03s/1.21u sec elapsed 1.25 sec</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_end, tuplesort.c:920</font></div><div><font size="2"   >&nbsp;count &nbsp;</font></div><div><font size="2"   >--------</font></div><div><font size="2"   >&nbsp;524243</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 1387.698 ms</font></div><div><font size="2"   >-- 加大work_mem后, 使用内部排序, 但是可以看到消耗的内存上涨到24MB.</font></div><div><font size="2"   >postgres=# set work_mem=1633333;<br>SET<br>Time: 0.219 ms</font></div><div><font size="2"   >postgres=# select count(distinct foo) from (select random() as foo from<br>generate_series(1,524300)) asdf;<br>LOG:  00000: begin datum sort: workMem = 1633333, randomAccess = f<br>LOCATION:  tuplesort_begin_datum, tuplesort.c:809<br>LOG:  00000: performsort starting: CPU 0.00s/0.11u sec elapsed 0.12 sec<br>LOCATION:  tuplesort_performsort, tuplesort.c:1232<br>LOG:  00000: performsort done: CPU 0.00s/0.54u sec elapsed 0.55 sec<br>LOCATION:  tuplesort_performsort, tuplesort.c:1307<br>LOG:  00000: <font color="#ff0000"   >internal sort ended, 24577 KB used</font>: CPU 0.00s/0.60u sec elapsed 0.61 sec<br>LOCATION:  tuplesort_end, tuplesort.c:923<br> count  <br>--------<br> 524232<br>(1 row)<br>Time: 716.238 ms</font></div><p></p></pre></div><div><br></div><div>打补丁后 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pgdev@db-172-16-3-150-&gt; psql</font></div><div><font size="2"   >psql (9.3devel)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >digoal=# \timing</font></div><div><font size="2"   >Timing is on.</font></div><div><font size="2"   >digoal=# set work_mem=16384;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >Time: 0.781 ms</font></div><div><font size="2"   >digoal=# set client_min_messages =log;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >Time: 0.587 ms</font></div><div><font size="2"   >digoal=# set trace_sort = on;</font></div><div><font size="2"   >LOG: &nbsp;statement: set trace_sort = on;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >Time: 0.693 ms</font></div><div><font size="2"   >digoal=# \set VERBOSITY verbose</font></div><div><font size="2"   >digoal=# select count(distinct foo) from (select random() as foo from</font></div><div><font size="2"   >digoal(# generate_series(1,524200)) asdf;</font></div><div><font size="2"   >LOG: &nbsp;00000: statement: select count(distinct foo) from (select random() as foo from</font></div><div><font size="2"   >generate_series(1,524200)) asdf;</font></div><div><font size="2"   >LOCATION: &nbsp;exec_simple_query, postgres.c:890</font></div><div><font size="2"   >LOG: &nbsp;00000: begin datum sort: workMem = 16384, randomAccess = f</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_begin_datum, tuplesort.c:819</font></div><div><font size="2"   >LOG: &nbsp;00000: performsort starting: CPU 0.01s/0.17u sec elapsed 0.18 sec</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_performsort, tuplesort.c:1319</font></div><div><font size="2"   >LOG: &nbsp;00000: performsort done: CPU 0.01s/0.59u sec elapsed 0.61 sec</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_performsort, tuplesort.c:1394</font></div><div><font size="2"   >LOG: &nbsp;00000: <font color="#ff0000"   >internal sort</font> ended, <font color="#ff0000"   >12289 KB used</font>: CPU 0.01s/0.64u sec elapsed 0.66 sec</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_end, tuplesort.c:932</font></div><div><font size="2"   >&nbsp;count &nbsp;</font></div><div><font size="2"   >--------</font></div><div><font size="2"   >&nbsp;524117</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 821.121 ms</font></div><div><font size="2"   >-- grow work memory to power of 2 size. 16384 KB</font></div><div><font size="2"   >digoal=# select count(distinct foo) from (select random() as foo from</font></div><div><font size="2"   >digoal(# generate_series(1,524300)) asdf;</font></div><div><font size="2"   >LOG: &nbsp;00000: statement: select count(distinct foo) from (select random() as foo from</font></div><div><font size="2"   >generate_series(1,524300)) asdf;</font></div><div><font size="2"   >LOCATION: &nbsp;exec_simple_query, postgres.c:890</font></div><div><font size="2"   >LOG: &nbsp;00000: begin datum sort: workMem = 16384, randomAccess = f</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_begin_datum, tuplesort.c:819</font></div><div><font size="2"   >LOG: &nbsp;00000: performsort starting: CPU 0.00s/0.18u sec elapsed 0.19 sec</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_performsort, tuplesort.c:1319</font></div><div><font size="2"   >LOG: &nbsp;00000: performsort done: CPU 0.00s/0.60u sec elapsed 0.61 sec</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_performsort, tuplesort.c:1394</font></div><div><font size="2"   >LOG: &nbsp;00000: <font color="#ff0000"   >internal sort</font> ended, <font color="#ff0000"   >16384 KB used</font>: CPU 0.00s/0.65u sec elapsed 0.66 sec</font></div><div><font size="2"   >LOCATION: &nbsp;tuplesort_end, tuplesort.c:932</font></div><div><font size="2"   >&nbsp;count &nbsp;</font></div><div><font size="2"   >--------</font></div><div><font size="2"   >&nbsp;524236</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 825.702 ms</font></div><p></p></pre></div><div><br></div>【参考】<wbr><div>1.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/message-id/flat/CAEYLb_X4ofwU4UHQP=dXGWRqdB2AM1qU__wvuexRTBDh6NgHWg@mail.gmail.com#CAEYLb_X4ofwU4UHQP=dXGWRqdB2AM1qU__wvuexRTBDh6NgHWg@mail.gmail.com"   >http://www.postgresql.org/message-id/flat/CAEYLb_X4ofwU4UHQP=dXGWRqdB2AM1qU__wvuexRTBDh6NgHWg@mail.gmail.com#CAEYLb_X4ofwU4UHQP=dXGWRqdB2AM1qU__wvuexRTBDh6NgHWg@mail.gmail.com</a></div><div>2. PostgreSQL 9.3</div><div>src/backend/utils/sort/tuplesort.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Grow the memtuples[] array, if possible within our memory constraint.</font></div><div><font size="2"   >&nbsp;* Return TRUE if we were able to enlarge the array, FALSE if not.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Normally, at each increment we double the size of the array. &nbsp;When we no</font></div><div><font size="2"   >&nbsp;* longer have enough memory to do that, we attempt one last, smaller increase</font></div><div><font size="2"   >&nbsp;* (and then clear the growmemtuples flag so we don't try any more). &nbsp;That</font></div><div><font size="2"   >&nbsp;* allows us to use allowedMem as fully as possible; sticking to the pure</font></div><div><font size="2"   >&nbsp;* doubling rule could result in almost half of allowedMem going unused.</font></div><div><font size="2"   >&nbsp;* Because availMem moves around with tuple addition/removal, we need some</font></div><div><font size="2"   >&nbsp;* rule to prevent making repeated small increases in memtupsize, which would</font></div><div><font size="2"   >&nbsp;* just be useless thrashing. &nbsp;The growmemtuples flag accomplishes that and</font></div><div><font size="2"   >&nbsp;* also prevents useless recalculations in this function.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static bool</font></div><div><font size="2"   >grow_memtuples(Tuplesortstate *state)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memtupsize = state-&gt;memtupsize;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; long &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;memNowUsed = state-&gt;allowedMem - state-&gt;availMem;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Forget it if we've already maxed out memtuples, per comment above */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!state-&gt;growmemtuples)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Select new value of memtupsize */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (memNowUsed &lt;= state-&gt;availMem)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* It is surely safe to double memtupsize if we've used no more than</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* half of allowedMem.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: it might seem that we need to worry about memtupsize * 2</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* overflowing an int, but the MaxAllocSize clamp applied below</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ensures the existing memtupsize can't be large enough for that.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize = memtupsize * 2;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* This will be the last increment of memtupsize. &nbsp;Abandon doubling</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* strategy and instead increase as much as we safely can.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* To stay within allowedMem, we can't increase memtupsize by more</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* than availMem / sizeof(SortTuple) elements. &nbsp;In practice, we want</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to increase it by considerably less, because we need to leave some</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* space for the tuples to which the new array slots will refer. &nbsp;We</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* assume the new tuples will be about the same size as the tuples</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we've already seen, and thus we can extrapolate from the space</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* consumption so far to estimate an appropriate new size for the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* memtuples array. &nbsp;The optimal value might be higher or lower than</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* this estimate, but it's hard to know that in advance.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* This calculation is safe against enlarging the array so much that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* LACKMEM becomes true, because the memory currently used includes</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the present array; thus, there would be enough allowedMem for the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* new array elements even if no other memory were currently used.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We do the arithmetic in float8, because otherwise the product of</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* memtupsize and allowedMem could overflow. &nbsp;(A little algebra shows</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* that grow_ratio must be less than 2 here, so we are not risking</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* integer overflow this way.) &nbsp;Any inaccuracy in the result should be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* insignificant; but even if we computed a completely insane result,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the checks below will prevent anything really bad from happening.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;grow_ratio;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grow_ratio = (double) state-&gt;allowedMem / (double) memNowUsed;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize = (int) (memtupsize * grow_ratio);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* We won't make any further enlargement attempts */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;growmemtuples = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Must enlarge array by at least one element, else report failure */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (newmemtupsize &lt;= memtupsize)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto noalloc;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* On a 64-bit machine, allowedMem could be more than MaxAllocSize. &nbsp;Clamp</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to ensure our request won't be rejected by palloc.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if ((Size) newmemtupsize &gt;= MaxAllocSize / sizeof(SortTuple))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize = (int) (MaxAllocSize / sizeof(SortTuple));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;growmemtuples = false; &nbsp; /* can't grow any more */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We need to be sure that we do not cause LACKMEM to become true, else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the space management algorithm will go nuts. &nbsp;The code above should</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* never generate a dangerous request, but to be safe, check explicitly</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* that the array growth fits within availMem. &nbsp;(We could still cause</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* LACKMEM if the memory chunk overhead associated with the memtuples</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* array were to increase. &nbsp; &nbsp; &nbsp;That shouldn't happen with any sane value of</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* allowedMem, because at any array size large enough to risk LACKMEM,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* palloc would be treating both old and new arrays as separate chunks.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* But we'll check LACKMEM explicitly below just in case.)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (state-&gt;availMem &lt; (long) ((newmemtupsize - memtupsize) * sizeof(SortTuple)))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto noalloc;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* OK, do it */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FREEMEM(state, GetMemoryChunkSpace(state-&gt;memtuples));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtupsize = newmemtupsize;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtuples = (SortTuple *)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repalloc(state-&gt;memtuples,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;state-&gt;memtupsize * sizeof(SortTuple));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; USEMEM(state, GetMemoryChunkSpace(state-&gt;memtuples));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (LACKMEM(state))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "unexpected out-of-memory situation during sort");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"   >noalloc:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* If for any reason we didn't realloc, shut off future attempts */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;growmemtuples = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>3. PostgreSQL 9.2</div><div>src/backend/utils/sort/tuplesort.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Grow the memtuples[] array, if possible within our memory constraint.</font></div><div><font size="2"   >&nbsp;* Return TRUE if able to enlarge the array, FALSE if not.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* At each increment we double the size of the array. &nbsp;When we are short</font></div><div><font size="2"   >&nbsp;* on memory we could consider smaller increases, but because availMem</font></div><div><font size="2"   >&nbsp;* moves around with tuple addition/removal, this might result in thrashing.</font></div><div><font size="2"   >&nbsp;* Small increases in the array size are likely to be pretty inefficient.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static bool</font></div><div><font size="2"   >grow_memtuples(Tuplesortstate *state)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We need to be sure that we do not cause LACKMEM to become true, else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the space management algorithm will go nuts. &nbsp;We assume here that the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* memory chunk overhead associated with the memtuples array is constant</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* and so there will be no unexpected addition to what we ask for. &nbsp; &nbsp; &nbsp;(The</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* minimum array size established in tuplesort_begin_common is large</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* enough to force palloc to treat it as a separate chunk, so this</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* assumption should be good. &nbsp;But let's check it.)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (state-&gt;availMem &lt;= (long) (state-&gt;memtupsize * sizeof(SortTuple)))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* On a 64-bit machine, allowedMem could be high enough to get us into</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* trouble with MaxAllocSize, too.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if ((Size) (state-&gt;memtupsize * 2) &gt;= MaxAllocSize / sizeof(SortTuple))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FREEMEM(state, GetMemoryChunkSpace(state-&gt;memtuples));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtupsize *= 2;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtuples = (SortTuple *)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repalloc(state-&gt;memtuples,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;state-&gt;memtupsize * sizeof(SortTuple));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; USEMEM(state, GetMemoryChunkSpace(state-&gt;memtuples));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (LACKMEM(state))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "unexpected out-of-memory situation during sort");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"   >}</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>