<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">使用 ssh -R 建立反向/远程TCP端口转发代理</h2>
	<h5 id="">2014-06-14 20:25:01&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201451464251856/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>ssh是一个非常棒的工具, 不但能建立动态转发, 例如chrome的Switchy插件用到的就是这个技术.</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201141821810103/"   >http://blog.163.com/digoal@126/blog/static/163877040201141821810103/</a></div><div>还能建立TCP的转发隧道, 例如我以前写过的关于使用ssh 隧道加密和加速WAN传输的几个例子.</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201342383123592/"   >http://blog.163.com/digoal@126/blog/static/163877040201342383123592/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020115294425540/"   >http://blog.163.com/digoal@126/blog/static/16387704020115294425540/</a></div><div>上面的例子可以理解为正向的TCP端口转发代理(如local$ ssh -L 7001:1.1.1.1:1000 remote_A), 即本地服务器local建立和远程服务器的SSH连接, 本地监听一个端口7001, 连接本地的监听端口7001相当于"通过远程服务器remote_A访问指定的IP 1.1.1.1和PORT 1000".</div><div>这种方法适用于本地网络中其他服务器想访问远程的服务器, 但是其他服务器没有直接访问远程服务器的权限, 通过本地网络中有权限的服务器做端口转发的场景.</div><div><br></div><div>还有一种应用场景是这样的, 本地网络环境中没有任何一台服务器可以直接访问远程服务器, 但是远程服务器可以反过来访问本地的某台服务器, 这样的话也能实现本地服务器去访问远程服务器的目的. 这就是反向代理.</div><div>实际的应用场景如, 1. 家里的网络是动态拨号网络, 没有固定IP, 如果想在上班的时候控制家里的电脑怎么办呢? 如果公司有一台服务器是可以在家拨号过去访问的, 那么你可以在家里的电脑上建立和这台公司服务器的反向代理, 到公司后, 就可以连接这台服务器上的反向代理(监听)来连接家里的电脑了.</div><div>2. 有的客户可能不希望提供VPN给你去访问他们的服务器, 但是又需要得到你的远程协助, 怎么办呢?</div><div>你可以提供一台服务器让客户主动来访问你的服务器, 客户建立这样的反向代理, 然后你通过这个反向代理来连接客户开放的端口如VNC桌面共享, 进行远程协助. (这种方法比QQ远程协助是更安全的, 因为客户和这台服务器之间的数据时加密的, QQ远程协助毕竟有一定的风险存在.)</div><div>以下是反向代理的图例,&nbsp;<span style="line-height: 28px;"   >如图1 :&nbsp;</span></div><div>箭头表示允许访问的方向, 也就是说Server C可以访问Server A和Server B以及Client A.</div><div>而Client B和Client C可以访问Client A.</div><div>我们的目的是要让Client 可以访问Server. 这里就要用到SSH的反向端口转发, 或远程端口转发.</div><div><br></div><div><div><img title="使用 ssh -R 建立反向/远程TCP端口转发代理 - 德哥@Digoal - PostgreSQL"   alt="使用 ssh -R 建立反向/远程TCP端口转发代理 - 德哥@Digoal - PostgreSQL"   style="margin:0 10px 0 0;"   src="http://img0.ph.126.net/Yw2zbG6yARzg4y6oyaRIdg==/6608849934236162607.png"   ></div><div><br></div><div>反向代理应用场景.</div>例如, 以下虚线表示Client C最终要访问Server A的22端口.</div><div>实现的步骤</div><div>1. Client A需要修改一下sshd_config, 开启GatewayPorts, 这样才能监听回环地址以外的地址, 如0.0.0.0, 这样的话其他服务器才能访问到这个端口.</div><div>2. Server C建立和Client A的反向端口转发, 让Client A在0.0.0.0上监听7001端口, 访问这个端口的数据转发到IP_SA的22端口.</div><div><font size="2"   color="#99cc00"   >ssh -CqTfnN -R &nbsp;0.0.0.0:7001:IP_SA:22 &nbsp; IP_CA</font></div><div>其实再深层次一点, &nbsp;因为client c和server a已经可以建立ssh了, 那么通过client c和server a建立反向代理, Server A也可以访问Client c. 这样需要经过了多层ssh隧道( IP_CA-&gt;IP_SC, IP_SA-&gt;IP_CC )</div><div><br><div><img title="使用 ssh -R 建立反向/远程TCP端口转发代理 - 德哥@Digoal - PostgreSQL"   alt="使用 ssh -R 建立反向/远程TCP端口转发代理 - 德哥@Digoal - PostgreSQL"   style="margin:0 10px 0 0;"   src="http://img1.ph.126.net/FMrrTWw5IoL8gmGbLXIASw==/6608944492236153394.png"   ></div><div><br></div><div>这种反向代理的用法很容易应用到实际的场景中, 例如前面提到的 :</div><div><div style="line-height: 28px;"   >有的客户可能不希望提供VPN给你去访问他们的服务器, 但是又需要得到你的远程协助, 怎么办呢?</div><div style="line-height: 28px;"   >你可以提供一台服务器让客户主动来访问你的服务器, 客户建立这样的反向代理, 然后你通过这个反向代理来连接客户开放的端口如VNC桌面共享, 进行远程协助.</div></div><div>如图 :&nbsp;</div><div>Public A是一台公用主机, 可以被客户和服务提供商同时访问.</div><div>当客户需要远程协助时.</div><div>1. 客户在SERVER C上开启一个VNC server</div><div>2. 客户将需要远程协助的窗口先登录好, 例如某些内网服务器(SERVER A , SERVER B)的telnet或ssh终端. 以供服务提供商使用.</div><div>3. 客户在SERVER C主动建立和这台公用主机的反向代理, 将端口转发到server c的vnc监听端口.</div><div>4. 服务提供商使用VNC客户端连接这台公共服务器的SSH代理监听端口, 相当于连接到了server c的vnc server. 以提供远程协助.</div><div>5. 客户可以在server c上观看, 录像, 控制这个VNC会话等.</div><div><br></div><div><div><img title="使用 ssh -R 建立反向/远程TCP端口转发代理 - 德哥@Digoal - PostgreSQL"   alt="使用 ssh -R 建立反向/远程TCP端口转发代理 - 德哥@Digoal - PostgreSQL"   style="margin:0 10px 0 0;"   src="http://img1.ph.126.net/0kVBZ44jNvEg5PmN-wZkSg==/6608181431167460269.png"   ></div></div><br></div><div>下面来举个例子 :&nbsp;</div><div>场景 :&nbsp;</div><div>家里有一台WINDOWS服务器, 通过VPN拨号到公司网络.</div><div>WINDOWS服务器上跑了两个VMWARE的虚拟机, 分别是FreeBSD和CentOS.</div><div>公司有1台主机172.16.3.150, 安装了CentOS,&nbsp;</div><div>拨号后, 家里的虚拟机FreeBSD可以访问172.16.3.150.</div><div>现在要让公司的其他服务器如172.16.3.167可以访问到家里的192.168.198.129虚拟机.</div><div><br></div><div><div><img title="使用 ssh -R 建立反向/远程TCP端口转发代理 - 德哥@Digoal - PostgreSQL"   alt="使用 ssh -R 建立反向/远程TCP端口转发代理 - 德哥@Digoal - PostgreSQL"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/Pj59DiHylahWR04f-06CnA==/6608598146073403055.png"   ></div>简单步骤.</div><div>1. 拨号, 略</div><div>2. 172.16.3.150上需要修改sshd_config.</div><div><font size="2"   color="#99cc00"   >[root@db-172-16-3-150 ~]# vi /etc/ssh/sshd_config</font></div><div><font size="2"   color="#99cc00"   >GatewayPorts yes</font></div><div><div><font size="2"   color="#99cc00"   >[root@db-172-16-3-150 ~]# service sshd reload</font></div><div><font size="2"   color="#99cc00"   >Reloading sshd: [ &nbsp;OK &nbsp;]</font></div></div><div>3. 通过虚拟机192.168.198.130连接到172.16.3.150开启反向端口代理. (如果130不是LINUX是WINDOWS, 也可以用securecrt类似的软件进行代理配置.)</div><div><div><font size="2"   color="#99cc00"   >root@digoal:~ # ssh -CqTfnN -R 0.0.0.0:7001:192.168.198.129:22 172.16.3.150</font></div><div><font size="2"   color="#99cc00"   >root@172.16.3.150's password:&nbsp;</font></div></div><div>4. 在172.16.3.150上可以看到这个监听.</div><div><div><font size="2"   color="#99cc00"   >[root@db-172-16-3-150 ~]# netstat -anp|grep 7001</font></div><div><font size="2"   color="#99cc00"   >tcp &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp;0 0.0.0.0:7001 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0.0.0.0:* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LISTEN &nbsp; &nbsp; &nbsp;2392/sshd &nbsp;</font></div></div><div><font size="2"   color="#99cc00"   >tcp &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp;0 :::7001 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :::* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LISTEN &nbsp; &nbsp; &nbsp;2392/sshd &nbsp;&nbsp;</font></div><div>5. 现在到172.16.3.167上连接172.16.3.150的7001端口.</div><div><div><font size="2"   color="#99cc00"   >[root@db5 ~]# ifconfig</font></div><div><font size="2"   color="#99cc00"   >bond0 &nbsp; &nbsp; Link encap:Ethernet &nbsp;HWaddr 00:23:7D:A3:F0:4E &nbsp;</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inet addr:172.16.3.176 &nbsp;Bcast:172.16.3.255 &nbsp;Mask:255.255.255.0</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inet6 addr: fe80::223:7dff:fea3:f04e/64 Scope:Link</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UP BROADCAST RUNNING MASTER MULTICAST &nbsp;MTU:1500 &nbsp;Metric:1</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RX packets:200422824 errors:0 dropped:0 overruns:0 frame:0</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TX packets:16849618 errors:0 dropped:0 overruns:0 carrier:0</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collisions:0 txqueuelen:0&nbsp;</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RX bytes:23012276676 (21.4 GiB) &nbsp;TX bytes:3567071726 (3.3 GiB)</font></div></div><div><div><font size="2"   color="#99cc00"   >[root@db5 ~]# ping 172.16.3.150</font></div><div><font size="2"   color="#99cc00"   >PING 172.16.3.150 (172.16.3.150) 56(84) bytes of data.</font></div><div><font size="2"   color="#99cc00"   >64 bytes from 172.16.3.150: icmp_seq=1 ttl=64 time=0.337 ms</font></div><div><font size="2"   color="#99cc00"   ><br></font></div><div><font size="2"   color="#99cc00"   >--- 172.16.3.150 ping statistics ---</font></div><div><font size="2"   color="#99cc00"   >1 packets transmitted, 1 received, 0% packet loss, time 0ms</font></div><div><font size="2"   color="#99cc00"   >rtt min/avg/max/mdev = 0.337/0.337/0.337/0.000 ms</font></div><div><font size="2"   color="#99cc00"   >[root@db5 ~]# ssh -p 7001 172.16.3.150</font></div><div><font size="2"   color="#99cc00"   >Password for root@digoal.org:</font></div></div><div><div><font size="2"   color="#99cc00"   >root@digoal:~ # ifconfig</font></div><div><font size="2"   color="#99cc00"   >em0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; options=9b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM&gt;</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; ether 00:0c:29:c0:4b:65</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; inet 192.168.198.129 netmask 0xffffff00 broadcast 192.168.198.255&nbsp;</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; nd6 options=29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; media: Ethernet autoselect (1000baseT &lt;full-duplex&gt;)</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; status: active</font></div></div><div>到这里反向代理的测试完成.</div><div><br></div><div>接下来我们看看如何在反向代理的基础上, 再做一层反向代理.</div><div>例如我要在172.16.3.167建立和192.168.198.129的反向代理, 让192.168.198.130通过<span style="line-height: 28px;"   >192.168.198.129来访问172.16.3.150.</span></div><div><span style="line-height: 28px;"   >1. 首先要修改192.168.198.129的sshd_config</span></div><div><font size="2"   color="#99cc00"   >root@digoal:~ # vi /etc/ssh/sshd_config</font></div><div><font size="2"   color="#99cc00"   >GatewayPorts yes&nbsp;</font></div><div><div><font size="2"   color="#99cc00"   >root@digoal:~ # service sshd reload</font></div><div><font size="2"   color="#99cc00"   >Performing sanity check on sshd configuration.</font></div><div><font size="2"   color="#99cc00"   >root@digoal:~ # exit</font></div><div><font size="2"   color="#99cc00"   >logout</font></div><div><font size="2"   color="#99cc00"   >Connection to 172.16.3.150 closed.</font></div></div><div>2.&nbsp;<span style="line-height: 28px;"   >在172.16.3.167建立和192.168.198.129的</span><span style="line-height: 28px;"   >反向代理</span></div><div><div><font size="2"   color="#99cc00"   >[root@db5 ~]# ssh -CqTfnN -p 7001 -R 0.0.0.0:7001:172.16.3.150:22 172.16.3.150</font></div><div><font size="2"   color="#99cc00"   >Password for root@digoal.org:</font></div></div><div>3. 在<span style="line-height: 28px;"   >192.168.198.129上查看监听.</span></div><div><div><font size="2"   color="#99cc00"   >root@digoal:~ # netstat -AaLnSTW</font></div><div><font size="2"   color="#99cc00"   >Current listen queue sizes (qlen/incqlen/maxqlen)</font></div><div><font size="2"   color="#99cc00"   >Tcpcb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Proto Listen &nbsp; &nbsp; &nbsp; &nbsp; Local Address &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   color="#99cc00"   >fffff800076ce800 tcp4 &nbsp;0/0/128 &nbsp; &nbsp; &nbsp; &nbsp;*.7001&nbsp;</font></div></div><div>4. 在192.168.198.130上<span style="line-height: 28px;"   >通过</span><span style="line-height: 28px;"   >192.168.198.129:7001来访问172.16.3.150:22.</span></div><div><div><font size="2"   color="#99cc00"   >[root@digoal ~]# ssh -p 7001 192.168.198.129</font></div><div><font size="2"   color="#99cc00"   >The authenticity of host '[192.168.198.129]:7001 ([192.168.198.129]:7001)' can't be established.</font></div><div><font size="2"   color="#99cc00"   >RSA key fingerprint is 01:0b:96:e1:a8:be:a3:a3:69:a4:0a:11:5d:2a:6f:c2.</font></div><div><font size="2"   color="#99cc00"   >Are you sure you want to continue connecting (yes/no)? yes</font></div><div><font size="2"   color="#99cc00"   >Warning: Permanently added '[192.168.198.129]:7001' (RSA) to the list of known hosts.</font></div><div><font size="2"   color="#99cc00"   >root@192.168.198.129's password:&nbsp;</font></div><div><font size="2"   color="#99cc00"   >Last login: Sat Jun 14 18:20:23 2014 from 10.0.0.60</font></div><div><font size="2"   color="#99cc00"   >[root@db-172-16-3-150 ~]#&nbsp;</font></div></div><div><br></div><div>[注意]</div><div>1. 当使用vncserver共享桌面时, 有几点需要注意, 需要使用或勾选Shared connection选项, 否则一个连上来, 其他的就会断掉.</div><div>2. 使用vncserver共享桌面, 只要把5901端口共享出来就可以了.</div><div>例如</div><div>在<span style="line-height: 28px;"   >172.16.3.150建立和</span><span style="line-height: 28px;"   >172.16.3.221的反向隧道, 代理VNCSERVER端口的反向转发.</span></div><div># ssh -CqTfnN -p 22 -R 0.0.0.0:5901:172.16.3.150:5901 172.16.3.221</div><div>这个使用的是172.16.3.221:5901来代理<span style="line-height: 28px;"   >172.16.3.150:5901</span></div><div><span style="line-height: 28px;"   >在172.16.3.150开启一个vncserver, 让A主机可以连到这个vncserver.</span></div><div><span style="line-height: 28px;"   >在A主机开启一个vncviewer, 并打开共享连接, 连接到</span><span style="line-height: 28px;"   >172.16.3.150:5901</span></div><div>在B主机开启一个<span style="line-height: 28px;"   >vncviewer, 并打开共享连接, 连接到</span><span style="line-height: 28px;"   >172.16.3.221:5901</span></div><div><span style="line-height: 28px;"   >最终, A变成了监控机, B是操作方.</span></div><div><span style="line-height: 28px;"   >&nbsp;B的操作, A可以在VNCVIEWER观看到.</span></div><div><span style="line-height: 28px;"   >使用完成后, 断开</span><span style="line-height: 28px;"   >172.16.3.150和</span><span style="line-height: 28px;"   >172.16.3.221的连接即可, 或者关闭</span><span style="line-height: 28px;"   >172.16.3.150的vncserver服务即可. vncserver -kill :?.</span></div><div><span style="line-height: 28px;"   >3. 如果是跨广域网的隧道, 中间经过的某些网络设备可能会有会话空闲自动断开机制, 为了确保隧道不会被这种机制自动干掉, 我们可以设置一下SSH连接的心跳.</span></div><div><div># sysctl -w net.ipv4.tcp_keepalive_time=30</div><div>net.ipv4.tcp_keepalive_time = 30</div></div><div># ssh -CqTfnN -o TCPKeepAlive=yes -o ServerAliveInterval=10 -o ServerAliveCountMax=10 -p 22 -R 0.0.0.0:5901:172.16.3.150:5901 目标IP</div><div>现在TCP的心跳时间缩短了, 空闲会自动发送TCP心跳包.</div><div><div>[root@150 ~]# netstat -anpo|grep ssh</div><div>tcp &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp;0 0.0.0.0:22 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0.0.0.0:* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LISTEN &nbsp; &nbsp; &nbsp;2699/sshd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off (0.00/0/0)</div><div>tcp &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp;0 172.16.3.150:62230 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;目标IP:22 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ESTABLISHED 21721/ssh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keepalive (21.48/0/0)</div></div><div>4. 如果目标机的5901端口监听被占用了, 可以换个端口, 那么使用vncviewer或者其他客户端连接时, 需要使用::port指定端口.</div><div>例如172.16.3.150::6666</div><div>5. 考虑到跨广域网的带宽有限问题, vncserver启动时, 最好设置一下位宽, 因为大多数操作不需要那么好的色彩, 例如 :&nbsp;</div><div># vncserver :1&nbsp;-geometry 1200x700 -depth 8&nbsp;-cc 3&nbsp;</div><div>初次配置时, 输入密码</div><div># vi ~/.vnc/xstartup&nbsp;</div><div><div>#twm &amp;</div><div>gnome-session &amp;</div></div><div><br></div><div># vncserver -kill :1</div><div><span style="line-height: 28px;"   ># vncserver :1&nbsp;-geometry&nbsp;</span><span style="line-height: 28px;"   >1200x700</span><span style="line-height: 28px;"   >&nbsp;-depth 8&nbsp;-cc 3&nbsp;</span></div><div><br></div><div>参考</div><div>man vncserver</div><div><br></div><div><span style="line-height: 28px;"   >[参考]</span></div><wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201141821810103/"   >http://blog.163.com/digoal@126/blog/static/163877040201141821810103/</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020115294425540/"   >http://blog.163.com/digoal@126/blog/static/16387704020115294425540/</a></div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201342383123592/"   >http://blog.163.com/digoal@126/blog/static/163877040201342383123592/</a></div><div>4. man ssh</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp;-R [bind_address:]port:host:hostport</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Specifies that the given port on the remote (server) host is to be forwarded to the given host and port</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on the local side. &nbsp;This works by allocating a socket to listen to port on the remote side, and whenever</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a connection is made to this port, the connection is forwarded over the secure channel, and a connection</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;is made to host port hostport from the local machine.</font></div><div><font size="2"   color="#99cc00"   ><br></font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Port forwardings can also be specified in the configuration file. &nbsp;Privileged ports can be forwarded only</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;when logging in as root on the remote machine. &nbsp;IPv6 addresses can be specified by enclosing the address</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;in square braces or using an alternative syntax: [bind_address/]host/port/hostport.</font></div><div><font size="2"   color="#99cc00"   ><br></font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;By default, the listening socket on the server will be bound to the loopback interface only. &nbsp;This may be</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;overridden by specifying a bind_address. &nbsp;An empty bind_address, or the address ‘*’, indicates that the</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;remote socket should listen on all interfaces. &nbsp;Specifying a remote bind_address will only succeed if the</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;server’s GatewayPorts option is enabled (see sshd_config(5)).</font></div><div><font size="2"   color="#99cc00"   ><br></font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If the port argument is ‘0’, the listen port will be dynamically allocated on the server and reported to</font></div><div><font size="2"   color="#99cc00"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the client at run time.</font></div><p></p></pre></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="使用 ssh -R 建立反向/远程TCP端口转发代理 - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>