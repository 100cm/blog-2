<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Waiting PostgreSQL 9.5 support update data from table use window function or by ctid now</h2>
	<h5 id="">2014-06-13 15:19:01&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201451321945521/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div><span style="line-height: 28px;"   >今天同事问的一个问题, 在MySQL中where 条件不允许在update里面写被更新的表.</span></div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >update xxx_com_table&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >set iflive=1 &nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >where name="www.xxx.com" &nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >and rdata ="xxx.xxx.xxx.xxx"&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >and weight &gt; (select min(weight) from&nbsp;<span style="line-height: 28px;"   >xxx_com_table</span>&nbsp;where name="www.xxx.com") ;</font></div><p></p></pre></div></div><div style="line-height: 28px;"   >以上SQL在MySQL中报错.</div><div style="line-height: 28px;"   >更新为以下写法则可以通过.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >update xxx_com_table&nbsp;</font></div><div><font size="2"   >set iflive=1 &nbsp;</font></div><div><font size="2"   >where name="www.xxx.com" &nbsp;</font></div><div><font size="2"   >and rdata ="xxx.xxx.xxx.xxx"&nbsp;</font></div><div><font size="2"   >and weight &gt; (select weight from (select min(weight) as weight from&nbsp;<span style="line-height: 28px;"   >xxx_com_table&nbsp;</span><span style="line-height: 28px;"   >where name="www.xxx.com"</span><span style="line-height: 28px;"   >) as a) ;</span></font></div><p></p></pre></div></div><div><br></div><div>本文不讨论MySQL, 来说说PostgreSQL.</div><div>这个SQL只是引子, 需求很简单, 更新指定分组内除最小weight以外的所有行.</div><div>在PostgreSQL中, 早些时间有一个补丁, 可以用来更新排序后的若干行.</div><div>参见<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402014224113459340/"   >http://blog.163.com/digoal@126/blog/static/1638770402014224113459340/</a>.</div><div>其实本文的用意也很明显, 是不是有这样的语法来支持这种更新呢?</div><div>在PostgreSQL中, 这种查询倒是有, 但是还没有类似的语法,</div><div>查询用到窗口函数, 如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create table a(id int, c1 text, c2 text, c3 int);</font></div><div><font size="2"   >CREATE TABLE</font></div></div><div><div><font size="2"   >digoal=# insert into a values (1,'a','a',1);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into a values (2,'a','a',2);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into a values (2,'a','a',3);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into a values (2,'a','b',1);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into a values (2,'a','b',2);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into a values (2,'a','b',3);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into a values (2,'a','c',1);</font></div><div><font size="2"   >INSERT 0 1</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# select ctid,* from (select *,ctid,row_number() over(partition by c1,c2 order by c3) as rn from a) as t where rn=1;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | c1 | c2 | c3 | ctid &nbsp;| rn&nbsp;</font></div><div><font size="2"   >-------+----+----+----+----+-------+----</font></div><div><font size="2"   >&nbsp;(0,1) | &nbsp;1 | a &nbsp;| a &nbsp;| &nbsp;1 | (0,1) | &nbsp;1</font></div><div><font size="2"   >&nbsp;(0,4) | &nbsp;2 | a &nbsp;| b &nbsp;| &nbsp;1 | (0,4) | &nbsp;1</font></div><div><font size="2"   >&nbsp;(0,7) | &nbsp;2 | a &nbsp;| c &nbsp;| &nbsp;1 | (0,7) | &nbsp;1</font></div><div><font size="2"   >(3 rows)</font></div></div><p></p></pre></div><div><br></div><div>最高效的方法应该是通过游标, 只需要扫一遍数据, 但是显然不能如愿, 因为更新游标不支持非简单查询.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# do language plpgsql $$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; rec record;</font></div><div><font size="2"   >&nbsp; cu cursor for select * from (select *,row_number() over(partition by c1,c2 order by c3) as rn from a) as t where rn&lt;&gt;1;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; for rec in cu loop</font></div><div><font size="2"   >&nbsp; &nbsp; update a set id=1 where current of cu;</font></div><div><font size="2"   >&nbsp; end loop;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$;</font></div><div><font size="2"   >ERROR: &nbsp;cursor "cu" is not a simply updatable scan of table "a"</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "update a set id=1 where current of cu"</font></div><div><font size="2"   >PL/pgSQL function inline_code_block line 7 at SQL statement</font></div><p></p></pre></div><div><br></div><div>目前可以用的办法是找到表的唯一ID, 或行号, 进行排除更新, 或直接更新.</div><div>唯一ID的话把下面的ctid替换成PK即可. 走索引扫描的话如果数据量比较大的情况, 扫描集小的话性能会高很多.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# update a set id=101 where ctid not in (select ctid from (select *,ctid,row_number() over(partition by c1,c2 order by c3) as rn from a) as t where rn=1);</font></div><div><font size="2"   >UPDATE 4</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select * from a;</font></div><div><font size="2"   >&nbsp;id &nbsp;| c1 | c2 | c3&nbsp;</font></div><div><font size="2"   >-----+----+----+----</font></div><div><font size="2"   >&nbsp; &nbsp;1 | a &nbsp;| a &nbsp;| &nbsp;1</font></div><div><font size="2"   >&nbsp; &nbsp;2 | a &nbsp;| b &nbsp;| &nbsp;1</font></div><div><font size="2"   >&nbsp; &nbsp;2 | a &nbsp;| c &nbsp;| &nbsp;1</font></div><div><font size="2"   >&nbsp;101 | a &nbsp;| a &nbsp;| &nbsp;2</font></div><div><font size="2"   >&nbsp;101 | a &nbsp;| a &nbsp;| &nbsp;3</font></div><div><font size="2"   >&nbsp;101 | a &nbsp;| b &nbsp;| &nbsp;2</font></div><div><font size="2"   >&nbsp;101 | a &nbsp;| b &nbsp;| &nbsp;3</font></div><div><font size="2"   >(7 rows)</font></div><p></p></pre></div><div>但是这种方法, 显然会导致数据重复扫描.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain update a set id=101 where ctid not in (select ctid from (select *,ctid,row_number() over(partition by c1,c2 order by c3) as rn from a) as t where rn=1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Update on a &nbsp;(cost=229.06..180793.53 rows=1605 width=74)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on a &nbsp;(cost=229.06..180793.53 rows=1605 width=74)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (NOT (SubPlan 1))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SubPlan 1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Materialize &nbsp;(cost=229.06..341.49 rows=16 width=6)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Subquery Scan on t &nbsp;(cost=229.06..341.41 rows=16 width=6)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (t.rn = 1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;WindowAgg &nbsp;(cost=229.06..301.28 rows=3210 width=78)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Sort &nbsp;(cost=229.06..237.08 rows=3210 width=78)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Key: a_1.c1, a_1.c2, a_1.c3</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on a a_1 &nbsp;(cost=0.00..42.10 rows=3210 width=78)</font></div><div><font size="2"   >(11 rows)</font></div><p></p></pre></div></div><div>期待PostgreSQL 9.5可以出简洁的语法, 减少扫描次数. 像本例游标那样, 扫一次.</div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402014224113459340/"   >http://blog.163.com/digoal@126/blog/static/1638770402014224113459340/</a></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="Waiting PostgreSQL 9.5 support update data from table use window function or by ctid now - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>