<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">[psqlodbc manual] psqlODBC Configuration Options</h2>
	<h5 id="">2010-06-04 17:02:40&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402010545240119/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><SPAN style="WIDOWS: 2; TEXT-TRANSFORM: none; TEXT-INDENT: 0px; BORDER-COLLAPSE: separate; FONT: medium Simsun; WHITE-SPACE: normal; ORPHANS: 2; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;"  >  <H1>psqlODBC Configuration Options</H1>  <H2>Advanced Options 1/2 Dialog Box</H2>  <UL>  <LI><B>DEFAULTS:</B><SPAN>&nbsp;</SPAN>Press to this button restore the normal defaults for the settings described below.<BR>&nbsp;</LI>  <LI><B>Disable Genetic Optimizer:</B><SPAN>&nbsp;</SPAN>Automatically turns off the backend genetic optimizer at connection time. This is a convenience feature rather than having to type it in the connect settings. This feature was added when we noticed the backend seemed to have big problems optimizing some queries.<BR>&nbsp;</LI>  <LI><B>KSQO (Keyset Query Optimization):</B><SPAN>&nbsp;</SPAN><B><EM>Deprecated for 7.1+ servers.</EM></B><SPAN>&nbsp;</SPAN>Check this option when connecting 7.0- servers and the application seems to be suffering from the following kind of queries:<BR><BR><FONT face="NSimsun" ><CODE>select...where (a = 1 AND b = 1 AND c = 1) OR (a=1 AND b=1 AND c = 2)...</CODE><BR></FONT>&nbsp;</LI>  <LI><B>Recognize Unique Indexes:</B><SPAN>&nbsp;</SPAN>Check this option.<BR>&nbsp;</LI>  <LI><B>Use Declare/Fetch:</B><SPAN>&nbsp;</SPAN>If true, the driver automatically uses declare cursor/fetch to handle SELECT statements and keeps 100 rows in a cache. This is mostly a great advantage, especially if you are only interested in reading and not updating. It results in the driver not sucking down lots of memory to buffer the entire result set. If set to false, cursors will not be used and the driver will retrieve the entire result set. For very large tables, this is very inefficient and may use up all the Windows memory/resources. However, it may handle updates better since the tables are not kept open, as they are when using cursors. This was the style of the old podbc32 driver. However, the behavior of the memory allocation is much improved so even when not using cursors, performance should at least be better than the old podbc32.<BR>&nbsp;</LI>  <LI><B>CommLog (C:\psqlodbc_xxxx.log):</B><SPAN>&nbsp;</SPAN>Log communications to/from the backend to that file. This is good for debugging problems.<BR>&nbsp;</LI>  <LI><B>Parse Statements:</B><SPAN>&nbsp;</SPAN>Tell the driver how to gather the information about result columns of queries. See also<SPAN>&nbsp;</SPAN><EM>Disallow Premature</EM><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><EM>ServerSide Prepare</EM>options.<BR>The driver checks this option first. If disabled then it checks the Server Side Prepare option. If disabled also it checks the Disallow Premature option.<BR>If neither of them is specified the driver would execute the prepared statement prematurely when the application inquires the result columns' info.<BR><BR>If this option is enabled, the driver will parse an SQL query statement to identify the columns and tables and gather statistics about them such as precision, nullability, aliases, etc. It then reports this information in SQLDescribeCol, SQLColAttributes, and SQLNumResultCols.<SPAN>&nbsp;</SPAN><B>Prior to PostgreSQL 6.4, this was the only accurate way of getting information on precision from a query result.</B><BR><BR>If the parser can not deal with a column (because it is a function or expression, etc.), it will fallback to executing the statement which is the old style of getting the info. The parser is fairly sophisticated and can handle many things such as column and table aliases, quoted identifiers, literals, joins, cross-products, etc. It can correctly identify a function or expression column, regardless of the complexity, but it does not attempt to determine the data type or precision of these columns.<BR>&nbsp;</LI>  <LI><B>Cancel as FreeStmt:</B><SPAN>&nbsp;</SPAN><BR>&nbsp;</LI>  <LI><B>MyLog (C:\mylog_xxxx.log):</B><SPAN>&nbsp;</SPAN>Log debug messages to that file. This is good for debugging problems with the driver.<BR>&nbsp;</LI>  <LI><B>Unknown Sizes:<SPAN>&nbsp;</SPAN></B>This controls what SQLDescribeCol and SQLColAttributes will return as to precision for character data types (varchar, text, and unknown) in a result set when the precision is unknown.<SPAN>&nbsp;</SPAN><B>This was more of a workaround for pre-6.4 versions of PostgreSQL not being able to return the defined column width of the varchar data type</B>.<BR><BR>  <UL>  <LI><I>Maximum</I>: Always return the maximum precision of the data type.</LI>  <LI><I>Dont Know</I>: Return "Don't Know" value and let application decide.</LI>  <LI><I>Longest</I>: Return the longest string length of the column of any row. Beware of this setting when using cursors because the cache size may not be a good representation of the longest column in the cache.</LI><BR><I>MS Access</I>: Seems to handle<SPAN>&nbsp;</SPAN><I>Maximum</I><SPAN>&nbsp;</SPAN>setting ok, as well as all the others.<BR><I>Borland</I>: If sizes are large and lots of columns, Borland may crash badly (it doesn't seem to handle memory allocation well) if using<SPAN>&nbsp;</SPAN><I>Maximum</I><SPAN>&nbsp;</SPAN>size.</UL><BR></LI>  <LI><B>Data Type Options:</B><SPAN>&nbsp;</SPAN>affects how some data types are mapped:<BR>&nbsp;</LI>  <UL>  <LI><I>Text as LongVarChar</I>: PostgreSQL TEXT type is mapped to SQLLongVarchar, otherwise SQLVarchar.</LI>  <LI><I>Unknowns as LongVarChar</I>: Unknown types (arrays, etc) are mapped to SQLLongVarChar, otherwise SQLVarchar</LI>  <LI><I>Bools as Char</I>: Bools are mapped to SQL_CHAR, otherwise to SQL_BIT.</LI></UL><BR>  <LI><B>Max Varchar</B><SPAN>&nbsp;</SPAN>The maximum precision of the Varchar and BPChar(char[x]) types. The default is 254 which actually means 255 because of the null terminator. Note, if you set this value higher than 254, Access will not let you index on varchar columns!<BR>&nbsp;</LI>  <LI><B>Cache Size:</B>When using cursors, this is the row size of the tuple cache. If not using cursors, this is how many tuples to allocate memory for at any given time. The default is 100 rows for either case.<BR>&nbsp;</LI>  <LI><B>Max LongVarChar:</B><SPAN>&nbsp;</SPAN>The maximum precision of the LongVarChar type. The default is 4094 which actually means 4095 with the null terminator. You can even specify (-4) for this size, which is the odbc SQL_NO_TOTAL value.<BR>&nbsp;</LI>  <LI><B>SysTable Prefixes:</B><SPAN>&nbsp;</SPAN>The additional prefixes of table names to regard as System Tables. The driver already treats names that begin with "pg_" as system tables. Here you can add additional ones, such as data dictionary tables (dd_). Separate each prefix with a semicolon (;)<BR>&nbsp;</LI></UL>  <H2>Advanced Options 2/2 Dialog Box</H2>  <UL>  <LI><B>ReadOnly:</B><SPAN>&nbsp;</SPAN>Whether the datasource will allow updates.<BR>&nbsp;</LI>  <LI><B>Show System Tables:</B><SPAN>&nbsp;</SPAN>The driver will treat system tables as regular tables in SQLTables. This is good for Access so you can see system tables.<BR>&nbsp;</LI>  <LI><B>LF &lt;-&gt; CR/LF conversion:</B><SPAN>&nbsp;</SPAN>Convert Unix style line endings to DOS style.<BR>&nbsp;</LI>  <LI><B>Updateable Cursors:</B><SPAN>&nbsp;</SPAN>Enable updateable cursor emulation in the driver.<BR>&nbsp;</LI>  <LI><B>Bytea as LO:</B><SPAN>&nbsp;</SPAN>Allow the use of bytea columns for Large Objects.<SPAN>&nbsp;</SPAN><BR>&nbsp;</LI>  <LI><B>Row Versioning:</B><SPAN>&nbsp;</SPAN>Allows applications to detect whether data has been modified by other users while you are attempting to update a row. It also speeds the update process since every single column does not need to be specified in the where clause to update a row. The driver uses the "xmin" system field of PostgreSQL to allow for row versioning. Microsoft products seem to use this option well. See the<SPAN>&nbsp;</SPAN><A http="" rel="nofollow" psqlodbcprojectspostgresqlorg="" faqhtml=""  >faq</A><SPAN>&nbsp;</SPAN>for details on what you need to do to your database to allow for the row versioning feature to be used.<BR>&nbsp;</LI>  <LI><B>Disallow Premature:</B><SPAN>&nbsp;</SPAN>Mainly for 7.1 to 7.3 servers.<SPAN>&nbsp;</SPAN><B><EM>Server side prepare</EM></B><SPAN>&nbsp;</SPAN>is a more preferable option for 7.4+ servers.<BR>Tell the driver how to gather the information about result columns. See also<SPAN>&nbsp;</SPAN><EM>Parse Staements</EM><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><EM>Server Side Prepare</EM><SPAN>&nbsp;</SPAN>options.<BR>This is an option to compensate for the lack of a server's<SPAN>&nbsp;</SPAN><EM>Prepare</EM><SPAN>&nbsp;</SPAN>functionality. For example, (Middleware) applications issue the following ODBC API calls.<BR><BR>SQLPreapare(hstmt, "select ...", ..)<BR><BR>In most cases they have to know how many fields, what kind of fields they would return and so they would issue<BR><BR>SQLNumResultCols and/or<SPAN>&nbsp;</SPAN><BR>SQLDescribeCols/SQLColAttribute etc.<BR><BR>The problem is how the psqlODBC driver answers the inquiry. PostgreSQL hadn't provided the<SPAN>&nbsp;</SPAN><EM>Prepare</EM><SPAN>&nbsp;</SPAN>functionality until 7.4 and we couldn't ask the backend about it directly. When using Disallow Premature, the driver will get the column info as follows:<BR><BR><I>&nbsp;&nbsp;&nbsp;begin;(unless in a transaction)<BR>&nbsp;&nbsp;&nbsp;declare cursor .. for select ...<BR>&nbsp;&nbsp;&nbsp;fetch backward in ..<BR>&nbsp;&nbsp;&nbsp;close ..<BR><BR></I>The driver gets the field info using the fetch backward's result. The fetch backward command returns no row but returns the field info. Though the command is expected to be returned immediately it isn't true for 7.0- servers unfortunately. The 7.1 or later servers<SPAN>&nbsp;</SPAN><B>do</B><SPAN>&nbsp;</SPAN>seem to return from the fetch backward command immediately.<BR>&nbsp;</LI>  <LI><B>True is -1:</B><SPAN>&nbsp;</SPAN>Represent TRUE as -1 for compatibility with some applications.<SPAN>&nbsp;</SPAN><BR>&nbsp;</LI>  <LI><B>Server side prepare:</B><SPAN>&nbsp;</SPAN>Applicable for 7.3+ servers and<SPAN>&nbsp;</SPAN><EM>recommended for 7.4+.</EM><BR>&nbsp; (7.4+) Tell the driver how to gather the information about result columns. See also<SPAN>&nbsp;</SPAN><EM>Parse Statement</EM><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><EM>Disallow Premature</EM><SPAN>&nbsp;</SPAN>options.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; By using extended query protocol the driver replies to the inquiry correctly and effectively.<BR>&nbsp; (7.4+) By using extended query protocol the driver replies to the inquiry for the information of parameters.<BR>&nbsp; (7.3+) When using prepared statements, prepare them on the server rather than in the driver. This can give a slight performance advantage as the server<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doesn't need to re-parse the statement each time it is used.<BR>&nbsp;</LI>  <LI><B>Int8 As:</B><SPAN>&nbsp;</SPAN>Define what datatype to report int8 columns as.<BR>&nbsp;</LI>  <LI><B>Extra Opts:</B><SPAN>&nbsp;</SPAN>combination of the following bits.<BR><BR>&nbsp; 0x1: Force the output of short-length formatted connection string. Check this bit when you use MFC CDatabase class.<BR>&nbsp; 0x2: Fake MS SQL Server so that MS Access recognizes PostgreSQL's serial type as AutoNumber type.<BR>&nbsp; 0x4: Reply ANSI (not Unicode) char types for the inquiries from applications. Try to check this bit when your applications don't seem to be good at handling Unicode data.<BR>&nbsp;</LI>  <LI><B>Protocol:</B><SPAN>&nbsp;</SPAN>Note that when using SSL connections this setting is ignored.<BR>&nbsp;  <UL>  <LI><I>6.2:</I><SPAN>&nbsp;</SPAN>Forces driver to use PostgreSQL 6.2(V0) protocol, which had different byte ordering, protocol, and other semantics.<BR>&nbsp;</LI>  <LI><I>6.3</I>: Use the 6.3(V1) protocol. This is compatible with both V1(6.3) and V2(6.4 to 7.3) backends.<BR>&nbsp;</LI>  <LI><I>6.4+</I>: Use the 6.4(V2) protocol. This is only compatible with 6.4 and higher backends.<BR>&nbsp;</LI>  <LI><I>7.4+</I>: Use the 7.4(V3) protocol. This is only compatible with 7.4 and higher backends.<BR>&nbsp;</LI></UL></LI>  <LI><B>Level of rollback on errors:</B><SPAN>&nbsp;</SPAN>Specifies what to rollback should an error occur.<BR>&nbsp;  <UL>  <LI><I>Nop(0):</I><SPAN>&nbsp;</SPAN>Don't rollback anything and let the application handle the error.<BR>&nbsp;</LI>  <LI><I>Transaction(1):</I><SPAN>&nbsp;</SPAN>Rollback the entire transaction.<BR>&nbsp;</LI>  <LI><I>Statement(2):</I><SPAN>&nbsp;</SPAN>Rollback the statement.<BR>&nbsp;</LI><BR><B>Notes in a setup: This specification is set up with a PROTOCOL option parameter.</B><BR><BR>PROTOCOL=[6.2|6.3|6.4|7.4][-(0|1|2)]<BR>default value is a sentence unit (it is a transaction unit before 8.0).<BR><BR></UL></LI>  <LI><B>OID Options:</B><BR>&nbsp;  <UL>  <LI><I>Show Column:<SPAN>&nbsp;</SPAN></I>Includes the OID in SQLColumns. This is good for using as a unique identifier to update records if no good key exists OR if the key has many parts, which blows up the backend.<BR>&nbsp;</LI>  <LI><I>Fake Index:<SPAN>&nbsp;</SPAN></I>This option fakes a unique index on OID. This is useful when there is not a real unique index on OID and for apps which can't ask what the unique identifier should be (i.e, Access 2.0).<BR>&nbsp;</LI></UL></LI>  <LI><B>Connect Settings:</B><SPAN>&nbsp;</SPAN>The driver sends these commands to the backend upon a successful connection.&nbsp; It sends these settings AFTER it sends the driver "Connect Settings". Use a semi-colon (;) to separate commands. This can now handle any query, even if it returns results. The results will be thrown away however!<BR>&nbsp;</LI></UL>  <H2>Global settings Dialog Box</H2>  <P>This dialog allows you to specify pre-connection/default logging options</P>  <UL>  <LI><B>CommLog (C:\psqlodbc_xxxx.log - Communications log):</B><SPAN>&nbsp;</SPAN>Log communications to/from the backend to that file. This is good for debugging problems.<BR>&nbsp;</LI>  <LI><B>MyLog (C:\mylog_xxxx.log - Detailed debug output):</B><SPAN>&nbsp;</SPAN>Log debug messages to that file. This is good for debugging problems with the driver.<BR>&nbsp;</LI>  <LI><B>MSDTCLog (C:\pgdtclog\mylog_xxxx.log - MSDTC debug output):</B><SPAN>&nbsp;</SPAN>Log debug messages to that file. This is good for debugging problems with the MSDTC.<BR>&nbsp;</LI>  <LI><B>Specification of the holder for log outputs:</B><SPAN>&nbsp;</SPAN>Adjustment of write permission.<BR>&nbsp;</LI></UL>  <H2>Manage DSN Dialog Box</H2>  <P>This dialog allows you to select which PostgreSQL ODBC driver to use for this connection. Note that this may not work with third party drivers.</P>  <H2>How to specify as a connection option</H2>  <P>There is a method of specifying a connection option in a keyword strings.</P>  <P>Example:VBA</P>  <UL>  <LI><B>myConn = "ODBC;DRIVER={PostgreSQL};" &amp; serverConn &amp; _ "A0=0;A1=6.4;A2=0;A3=0;A4=0;A5=0;A6=;A7=100;A8=4096;A9=0;" &amp; _ "B0=254;B1=8190;B2=0;B3=0;B4=1;B5=1;B6=0;B7=1;B8=0;B9=1;" &amp; _ "C0=0;C1=0;C2=dd_"</B></LI></UL></SPAN></div>
	</div>
</div>
</body>
</html>