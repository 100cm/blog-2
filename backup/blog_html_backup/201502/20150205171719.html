<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">which xlog fsync method support O_DIRECT bypasses the kernel buffers</h2>
	<h5 id="">2015-02-05 17:17:19&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020151551617584/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><span style="line-height: 28px;"   >PostgreSQL WAL日志的fsync方法较多, 哪些方法支持O_DIRECT呢?</span></div><div><div style="line-height: 28px;"   >所有支持的fsync方法 :&nbsp;</div><div style="line-height: 28px;"   ><pre class="prettyprint"   style="line-height: 28px;"   ><p style="line-height: 28px;"   ></p><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >#wal_sync_method = fsync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# the default is the first option</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # supported by the operating system:</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; open_datasync</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; fdatasync (default on Linux)</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; fsync</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; fsync_writethrough</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; open_sync</font></div><p style="line-height: 28px;"   ></p></pre></div></div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >从代码来看,&nbsp;</span><span style="line-height: 28px;"   >只有</span><span style="line-height: 28px;"   >open_sync和</span><span style="line-height: 28px;"   >open_datasync支持</span><span style="line-height: 28px;"   >O_DIRECT , 旁路内核buffer, 但是要旁路内核BUFFER, 还需要符合一个条件.</span></div><div>未开启归档, 没有下游节点使用流复制协议来复制XLOG数据.</div><div>原因是开启归档或有下游流复制节点时, XLOG文件写入后还会被读出来, 所以O_DIRECT没有意义.</div><div><br></div><div><span style="line-height: 28px;"   >涉及代码如下 :&nbsp;</span></div><div>1. src/include/access/xlogdefs.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;Because O_DIRECT bypasses the kernel buffers, and because we never</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;read those buffers except during crash recovery or if wal_level != minimal,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;it is a win to use it in all cases where we sync on each write(). &nbsp;We could</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;allow O_DIRECT with fsync(), but it is unclear if fsync() could process</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;writes not buffered in the kernel. &nbsp;Also, O_DIRECT is never enough to force</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;data to the drives, it merely tries to bypass the kernel cache, so we still</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;need O_SYNC/O_DSYNC.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#ifdef O_DIRECT</font></div><div><font size="2"   >#define PG_O_DIRECT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; O_DIRECT</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define PG_O_DIRECT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#if defined(O_SYNC)</font></div><div><font size="2"   >#define OPEN_SYNC_FLAG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;O_SYNC</font></div><div><font size="2"   >#elif defined(O_FSYNC)</font></div><div><font size="2"   >#define OPEN_SYNC_FLAG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;O_FSYNC</font></div><div><font size="2"   >#endif</font></div><p></p></pre></div><div><br></div><div>2. src/backend/access/transam/xlog.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* GUC support</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >const struct config_enum_entry sync_method_options[] = {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {"fsync", SYNC_METHOD_FSYNC, false},</font></div><div><font size="2"   >#ifdef HAVE_FSYNC_WRITETHROUGH</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {"fsync_writethrough", SYNC_METHOD_FSYNC_WRITETHROUGH, false},</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >#ifdef HAVE_FDATASYNC</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {"fdatasync", SYNC_METHOD_FDATASYNC, false},</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >#ifdef OPEN_SYNC_FLAG</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {"open_sync", SYNC_METHOD_OPEN, false},</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >#ifdef OPEN_DATASYNC_FLAG</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {"open_datasync", SYNC_METHOD_OPEN_DSYNC, false},</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {NULL, 0, false}</font></div><div><font size="2"   >};</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Return the (possible) sync flag used for opening a file, depending on the</font></div><div><font size="2"   >&nbsp;* value of the GUC wal_sync_method.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static int</font></div><div><font size="2"   >get_sync_bit(int method)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; o_direct_flag = 0;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* If fsync is disabled, never open in sync mode */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!enableFsync)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Optimize writes by bypassing kernel cache with O_DIRECT when using</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* O_SYNC/O_FSYNC and O_DSYNC. &nbsp;But only if archiving and streaming are</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* disabled, otherwise the archive command or walsender process will read</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the WAL soon after writing it, which is guaranteed to cause a physical</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* read if we bypassed the kernel cache. We also skip the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* posix_fadvise(POSIX_FADV_DONTNEED) call in XLogFileClose() for the same</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* reason.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Never use O_DIRECT in walreceiver process for similar reasons; the WAL</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* written by walreceiver is normally read by the startup process soon</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* after its written. Also, walreceiver performs unaligned writes, which</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* don't work with O_DIRECT, so it is required for correctness too.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!XLogIsNeeded() &amp;&amp; !AmWalReceiverProcess())</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; o_direct_flag = PG_O_DIRECT;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; switch (method)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* enum values for all sync options are defined even if they are</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* not supported on the current platform. &nbsp;But if not, they are</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* not included in the enum option array, and therefore will never</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* be seen here.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case SYNC_METHOD_FSYNC:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case SYNC_METHOD_FSYNC_WRITETHROUGH:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case SYNC_METHOD_FDATASYNC:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"   >#ifdef OPEN_SYNC_FLAG</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case SYNC_METHOD_OPEN:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return OPEN_SYNC_FLAG | o_direct_flag;</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >#ifdef OPEN_DATASYNC_FLAG</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case SYNC_METHOD_OPEN_DSYNC:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return OPEN_DATASYNC_FLAG | o_direct_flag;</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* can't happen (unless we are out of sync with option array) */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "unrecognized wal_sync_method: %d", method);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* silence warning */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div><p></p></pre></div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="which xlog fsync method support O_DIRECT bypasses the kernel buffers - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>