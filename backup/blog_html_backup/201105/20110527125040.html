<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Use ltree extension deal tree-like data type</h2>
	<h5 id="">2011-05-27 12:50:40&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402011427104710922/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">PostgreSQL 9.1里面的一个ltree extension.<wbr><div>由两位国外PostgreSQL贡献者共同开发</div><div>【网站】</div><div><span style="font-family: verdana, sans-serif; line-height: normal; font-size: medium;"  ><a style="color: rgb(0, 0, 0);" target="_top" rel="nofollow" href="http://www.sai.msu.su/~megera/postgres/gist/"  >http://www.sai.msu.su/~megera/postgres/gist</a></span></div><div><br></div><div>这个extension带有四个数据类型，多个函数，支持多样化的操作符。</div><div>对于树形结构的数据处理可见一斑。</div><div>之前我的一位同事在设计数据结构的时候有用到这种树形数据，当时是用PostgreSQL的递归查询来满足的需求。</div><div>文章地址:</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201132843255911/"  >http://blog.163.com/digoal@126/blog/static/163877040201132843255911/</a></div><div><br></div><div>如果使用ltree extension的话，会方便很多。</div><div>简易模块加载步骤:</div><div>1. 安装PostgreSQL的时候</div><div>gmake world</div><div>gmake install-world</div><div><br></div><div>2. 在需要新增此EXTENSION的数据库，使用超级用户新增。</div><div><div>digoal=# select * from pg_extension ;</div><div>&nbsp;extname &nbsp;| extowner | extnamespace | extrelocatable | extversion | extconfig | extcondition&nbsp;</div><div>----------+----------+--------------+----------------+------------+-----------+--------------</div><div>&nbsp;plpgsql &nbsp;| &nbsp; &nbsp; &nbsp; 10 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 1.0 &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</div><div>&nbsp;file_fdw | &nbsp; &nbsp; &nbsp; 10 | &nbsp; &nbsp; &nbsp; &nbsp; 2200 | t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 1.0 &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</div><div>(2 rows)</div><div><br></div><div>digoal=# create extension ltree;</div><div>CREATE EXTENSION</div><div>digoal=# select * from pg_extension ;</div><div>&nbsp;extname &nbsp;| extowner | extnamespace | extrelocatable | extversion | extconfig | extcondition&nbsp;</div><div>----------+----------+--------------+----------------+------------+-----------+--------------</div><div>&nbsp;plpgsql &nbsp;| &nbsp; &nbsp; &nbsp; 10 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 1.0 &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</div><div>&nbsp;file_fdw | &nbsp; &nbsp; &nbsp; 10 | &nbsp; &nbsp; &nbsp; &nbsp; 2200 | t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 1.0 &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</div><div>&nbsp;ltree &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; 10 | &nbsp; &nbsp; &nbsp; &nbsp; 2200 | t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 1.0 &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</div><div>(3 rows)</div><div><br></div><div>digoal=# \dT+</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List of data types</div><div>&nbsp;Schema | &nbsp; &nbsp;Name &nbsp; &nbsp;| Internal name | Size | Elements | Description&nbsp;</div><div>--------+------------+---------------+------+----------+-------------</div><div>&nbsp;public | lquery &nbsp; &nbsp; | lquery &nbsp; &nbsp; &nbsp; &nbsp;| var &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</div><div>&nbsp;public | ltree &nbsp; &nbsp; &nbsp;| ltree &nbsp; &nbsp; &nbsp; &nbsp; | var &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</div><div>&nbsp;public | ltree_gist | ltree_gist &nbsp; &nbsp;| var &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</div><div>&nbsp;public | ltxtquery &nbsp;| ltxtquery &nbsp; &nbsp; | var &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</div><div>(4 rows)</div></div><div><br></div><div>简单的介绍一下这几个类型 :&nbsp;</div><div>1. ltree (目前只支持A-Z,a-z,0-9,_作为label的合法字符)</div><div>树形结构类型,一个ltree被称为一个path,由1或多个LABEL组成,每个label由A-Z,a-z,0-9,_组成。</div><div><br></div><div>2. lquery</div><div>规则表达式,用于匹配ltree类型.</div><div>具体参考手册,需要注意的是%匹配的不是一个label,而是label里的一个单词(_为单词分隔符</div><div><br></div><div>3. ltxtquery</div><div>一般用于全文扫描，注意，只有ltxtquery类型是符号和匹配的内容是可以有空格隔开的,lquery和ltree不支持空格。</div><div><br></div><div>操作符介绍:</div><div><span style="font-family: verdana, sans-serif; line-height: normal; font-size: medium;"  ><p><b>Table F-12.&nbsp;<tt>ltree</tt>&nbsp;Operators</b></p><table border="1"  ><colgroup><col><col><col><thead><tr><th>Operator</th><th>Returns</th><th>Description</th></tr></thead><tbody><tr><td><tt>ltree</tt>&nbsp;<tt>@&gt;</tt>&nbsp;<tt>ltree</tt></td><td><tt>boolean</tt></td><td>is left argument an ancestor of right (or equal)?</td></tr><tr><td><tt>ltree</tt>&nbsp;<tt>&lt;@</tt>&nbsp;<tt>ltree</tt></td><td><tt>boolean</tt></td><td>is left argument a descendant of right (or equal)?</td></tr><tr><td><tt>ltree</tt>&nbsp;<tt>~</tt>&nbsp;<tt>lquery</tt></td><td><tt>boolean</tt></td><td>does&nbsp;<tt>ltree</tt>&nbsp;match&nbsp;<tt>lquery</tt>?</td></tr><tr><td><tt>lquery</tt>&nbsp;<tt>~</tt>&nbsp;<tt>ltree</tt></td><td><tt>boolean</tt></td><td>does&nbsp;<tt>ltree</tt>&nbsp;match&nbsp;<tt>lquery</tt>?</td></tr><tr><td><tt>ltree</tt>&nbsp;<tt>?</tt>&nbsp;<tt>lquery[]</tt></td><td><tt>boolean</tt></td><td>does&nbsp;<tt>ltree</tt>&nbsp;match any&nbsp;<tt>lquery</tt>&nbsp;in array?</td></tr><tr><td><tt>lquery[]</tt>&nbsp;<tt>?</tt>&nbsp;<tt>ltree</tt></td><td><tt>boolean</tt></td><td>does&nbsp;<tt>ltree</tt>&nbsp;match any&nbsp;<tt>lquery</tt>&nbsp;in array?</td></tr><tr><td><tt>ltree</tt>&nbsp;<tt>@</tt>&nbsp;<tt>ltxtquery</tt></td><td><tt>boolean</tt></td><td>does&nbsp;<tt>ltree</tt>&nbsp;match&nbsp;<tt>ltxtquery</tt>?</td></tr><tr><td><tt>ltxtquery</tt>&nbsp;<tt>@</tt>&nbsp;<tt>ltree</tt></td><td><tt>boolean</tt></td><td>does&nbsp;<tt>ltree</tt>&nbsp;match&nbsp;<tt>ltxtquery</tt>?</td></tr><tr><td><tt>ltree</tt>&nbsp;<tt>||</tt>&nbsp;<tt>ltree</tt></td><td><tt>ltree</tt></td><td>concatenate&nbsp;<tt>ltree</tt>&nbsp;paths</td></tr><tr><td><tt>ltree</tt>&nbsp;<tt>||</tt>&nbsp;<tt>text</tt></td><td><tt>ltree</tt></td><td>convert text to&nbsp;<tt>ltree</tt>&nbsp;and concatenate</td></tr><tr><td><tt>text</tt>&nbsp;<tt>||</tt>&nbsp;<tt>ltree</tt></td><td><tt>ltree</tt></td><td>convert text to&nbsp;<tt>ltree</tt>&nbsp;and concatenate</td></tr><tr><td><tt>ltree[]</tt>&nbsp;<tt>@&gt;</tt>&nbsp;<tt>ltree</tt></td><td><tt>boolean</tt></td><td>does array contain an ancestor of&nbsp;<tt>ltree</tt>?</td></tr><tr><td><tt>ltree</tt>&nbsp;<tt>&lt;@</tt>&nbsp;<tt>ltree[]</tt></td><td><tt>boolean</tt></td><td>does array contain an ancestor of&nbsp;<tt>ltree</tt>?</td></tr><tr><td><tt>ltree[]</tt>&nbsp;<tt>&lt;@</tt>&nbsp;<tt>ltree</tt></td><td><tt>boolean</tt></td><td>does array contain a descendant of&nbsp;<tt>ltree</tt>?</td></tr><tr><td><tt>ltree</tt>&nbsp;<tt>@&gt;</tt>&nbsp;<tt>ltree[]</tt></td><td><tt>boolean</tt></td><td>does array contain a descendant of&nbsp;<tt>ltree</tt>?</td></tr><tr><td><tt>ltree[]</tt>&nbsp;<tt>~</tt>&nbsp;<tt>lquery</tt></td><td><tt>boolean</tt></td><td>does array contain any path matching&nbsp;<tt>lquery</tt>?</td></tr><tr><td><tt>lquery</tt>&nbsp;<tt>~</tt>&nbsp;<tt>ltree[]</tt></td><td><tt>boolean</tt></td><td>does array contain any path matching&nbsp;<tt>lquery</tt>?</td></tr><tr><td><tt>ltree[]</tt>&nbsp;<tt>?</tt>&nbsp;<tt>lquery[]</tt></td><td><tt>boolean</tt></td><td>does&nbsp;<tt>ltree</tt>&nbsp;array contain any path matching any&nbsp;<tt>lquery</tt>?</td></tr><tr><td><tt>lquery[]</tt>&nbsp;<tt>?</tt>&nbsp;<tt>ltree[]</tt></td><td><tt>boolean</tt></td><td>does&nbsp;<tt>ltree</tt>&nbsp;array contain any path matching any&nbsp;<tt>lquery</tt>?</td></tr><tr><td><tt>ltree[]</tt>&nbsp;<tt>@</tt>&nbsp;<tt>ltxtquery</tt></td><td><tt>boolean</tt></td><td>does array contain any path matching&nbsp;<tt>ltxtquery</tt>?</td></tr><tr><td><tt>ltxtquery</tt>&nbsp;<tt>@</tt>&nbsp;<tt>ltree[]</tt></td><td><tt>boolean</tt></td><td>does array contain any path matching&nbsp;<tt>ltxtquery</tt>?</td></tr><tr><td><tt>ltree[]</tt>&nbsp;<tt>?@&gt;</tt>&nbsp;<tt>ltree</tt></td><td><tt>ltree</tt></td><td>first array entry that is an ancestor of&nbsp;<tt>ltree</tt>; NULL if none</td></tr><tr><td><tt>ltree[]</tt>&nbsp;<tt>?&lt;@</tt>&nbsp;<tt>ltree</tt></td><td><tt>ltree</tt></td><td>first array entry that is a descendant of&nbsp;<tt>ltree</tt>; NULL if none</td></tr><tr><td><tt>ltree[]</tt>&nbsp;<tt>?~</tt>&nbsp;<tt>lquery</tt></td><td><tt>ltree</tt></td><td>first array entry that matches&nbsp;<tt>lquery</tt>; NULL if none</td></tr><tr><td><tt>ltree[]</tt>&nbsp;<tt>?@</tt>&nbsp;<tt>ltxtquery</tt></td><td><tt>ltree</tt></td><td>first array entry that matches&nbsp;<tt>ltxtquery</tt>; NULL if none</td></tr></table></span></div><div><br></div><div><br></div><div>函数简单介绍:</div><div><span style="font-family: verdana, sans-serif; line-height: normal; font-size: medium;"  ><table border="1"  ><colgroup><col><col><col><col><col><thead><tr><th>Function</th><th>Return Type</th><th>Description</th><th>Example</th><th>Result</th></tr></thead><tbody><tr><td><code>subltree(ltree, int start, int end)</code></td><td><tt>ltree</tt></td><td>subpath of&nbsp;<tt>ltree</tt>&nbsp;from position&nbsp;<tt>start</tt>&nbsp;to position&nbsp;<tt>end</tt>-1 (counting from 0)</td><td><tt>subltree('Top.Child1.Child2',1,2)</tt></td><td><tt>Child1</tt></td></tr><tr><td><code>subpath(ltree, int offset, int len)</code></td><td><tt>ltree</tt></td><td>subpath of&nbsp;<tt>ltree</tt>&nbsp;starting at position&nbsp;<tt>offset</tt>, length&nbsp;<tt>len</tt>. If&nbsp;<tt>offset</tt>&nbsp;is negative, subpath starts that far from the end of the path. If&nbsp;<tt>len</tt>&nbsp;is negative, leaves that many labels off the end of the path.</td><td><tt>subpath('Top.Child1.Child2',0,2)</tt></td><td><tt>Top.Child1</tt></td></tr><tr><td><code>subpath(ltree, int offset)</code></td><td><tt>ltree</tt></td><td>subpath of&nbsp;<tt>ltree</tt>&nbsp;starting at position&nbsp;<tt>offset</tt>, extending to end of path. If&nbsp;<tt>offset</tt>&nbsp;is negative, subpath starts that far from the end of the path.</td><td><tt>subpath('Top.Child1.Child2',1)</tt></td><td><tt>Child1.Child2</tt></td></tr><tr><td><code>nlevel(ltree)</code></td><td><tt>integer</tt></td><td>number of labels in path</td><td><tt>nlevel('Top.Child1.Child2')</tt></td><td><tt>3</tt></td></tr><tr><td><code>index(ltree a, ltree b)</code></td><td><tt>integer</tt></td><td>position of first occurrence of&nbsp;<tt>b</tt>&nbsp;in&nbsp;<tt>a</tt>; -1 if not found</td><td><tt>index('0.1.2.3.5.4.5.6.8.5.6.8','5.6')</tt></td><td><tt>6</tt></td></tr><tr><td><code>index(ltree a, ltree b, int offset)</code></td><td><tt>integer</tt></td><td>position of first occurrence of&nbsp;<tt>b</tt>&nbsp;in&nbsp;<tt>a</tt>, searching starting at&nbsp;<tt>offset</tt>; negative&nbsp;<tt>offset</tt>means start&nbsp;<tt>-offset</tt>&nbsp;labels from the end of the path</td><td><tt>index('0.1.2.3.5.4.5.6.8.5.6.8','5.6',-4)</tt></td><td><tt>9</tt></td></tr><tr><td><code>text2ltree(text)</code></td><td><tt>ltree</tt></td><td>cast&nbsp;<tt>text</tt>&nbsp;to&nbsp;<tt>ltree</tt></td><td><tt></tt></td><td><tt></tt></td></tr><tr><td><code>ltree2text(ltree)</code></td><td><tt>text</tt></td><td>cast&nbsp;<tt>ltree</tt>&nbsp;to&nbsp;<tt>text</tt></td><td><tt></tt></td><td><tt></tt></td></tr><tr><td><code>lca(ltree, ltree, ...)</code></td><td><tt>ltree</tt></td><td>lowest common ancestor, i.e., longest common prefix of paths (up to 8 arguments supported)</td><td><tt>lca('1.2.2.3','1.2.3.4.5.6')</tt></td><td><tt>1.2</tt></td></tr><tr><td><code>lca(ltree[])</code></td><td><tt>ltree</tt></td><td>lowest common ancestor, i.e., longest common prefix of paths</td><td><tt>lca(array['1.2.2.3'::ltree,'1.2.3'])</tt></td><td><tt>1.2</tt></td></tr></table></span></div><div><br></div><div>实例:</div><div><div>digoal=&gt; create table tbl_music(id serial4,song ltree not null);</div><div>NOTICE: &nbsp;CREATE TABLE will create implicit sequence "tbl_music_id_seq" for serial column "tbl_music.id"</div><div>CREATE TABLE</div></div><div><br></div><div>digoal=&gt; insert into tbl_music (song) values ('GangTai.NanGeShou.LiuDeHua.AiNiYiWanNian');</div><div><div>digoal=&gt; insert into tbl_music (song) values ('GangTai.NanGeShou.LiuDeHua.JinTian');</div><div>INSERT 0 1</div><div>digoal=&gt; insert into tbl_music (song) values ('GangTai.NanGeShou.LiuDeHua.WangQinShui');</div><div>INSERT 0 1</div><div>digoal=&gt; insert into tbl_music (song) values ('GangTai.NanGeShou.ZhangXueYou.WenBie');</div><div>INSERT 0 1</div><div>digoal=&gt; insert into tbl_music (song) values ('GangTai.NanGeShou.ZhangXueYou.QingShu');</div><div>INSERT 0 1</div><div>digoal=&gt; insert into tbl_music (song) values ('GangTai.NvGeShou.ZhenXiuWen.MeiFeiSeWu');</div><div>INSERT 0 1</div><div>digoal=&gt; insert into tbl_music (song) values ('GangTai.NvGeShou.ZhenXiuWen.ZhongShenMeiLi');</div><div>INSERT 0 1</div><div>digoal=&gt; insert into tbl_music (song) values ('DaLu.NanGeShou.DaoLang.2002NianDeDiYiChangXue');</div><div>INSERT 0 1</div><div>digoal=&gt; insert into tbl_music (song) values ('DaLu.NvGeShou.FanBinBin.FeiNiao');</div></div><div><br></div><div><div>digoal=&gt; select * from tbl_music;</div><div>&nbsp;id | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; song &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div><div>----+-----------------------------------------------</div><div>&nbsp; 2 | GangTai.NanGeShou.LiuDeHua.AiNiYiWanNian</div><div>&nbsp; 3 | GangTai.NanGeShou.LiuDeHua.JinTian</div><div>&nbsp; 4 | GangTai.NanGeShou.LiuDeHua.WangQinShui</div><div>&nbsp; 5 | GangTai.NanGeShou.ZhangXueYou.WenBie</div><div>&nbsp; 6 | GangTai.NanGeShou.ZhangXueYou.QingShu</div><div>&nbsp; 7 | GangTai.NvGeShou.ZhenXiuWen.MeiFeiSeWu</div><div>&nbsp; 8 | GangTai.NvGeShou.ZhenXiuWen.ZhongShenMeiLi</div><div>&nbsp; 9 | DaLu.NanGeShou.DaoLang.2002NianDeDiYiChangXue</div><div>&nbsp;10 | DaLu.NvGeShou.FanBinBin.FeiNiao</div></div><div><br></div><div>检索刘德华的所有歌曲.</div><div><div>digoal=&gt; select subltree(song,3,4) from tbl_music where subltree(song,2,3)='LiuDeHua';</div><div>&nbsp; &nbsp;subltree &nbsp; &nbsp;</div><div>---------------</div><div>&nbsp;AiNiYiWanNian</div><div>&nbsp;JinTian</div><div>&nbsp;WangQinShui</div><div>(3 rows)</div></div><div><br></div><div>查找与刘德华同一个区域（港台。男歌手）的歌手。</div><div><div>digoal=&gt; select distinct subltree(song,2,3) from tbl_music where song &lt;@ (select &nbsp;subpath(song,0,2) from tbl_music where subltree(song,2,3)='LiuDeHua' limit 1);</div><div>&nbsp; subltree &nbsp;&nbsp;</div><div>-------------</div><div>&nbsp;LiuDeHua</div><div>&nbsp;ZhangXueYou</div><div>(2 rows)</div><div><br></div><div>其他不再举例.</div></div><div><br></div><div>【参考】</div><div>postgresql-9.1beta1/postgresql-9.1beta1/doc/src/sgml/html/ltree.html</div><div>with recursive</div></div>
	</div>
</div>
</body>
</html>