<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL cluster role switchover between primary and standby</h2>
	<h5 id="">2011-05-11 20:57:57&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201141154024306/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">虽然PostgreSQL没有明确指出 primary 和 standby 节点的角色可以相互切换。（即standby promote成primary ,primary demote成standby .不需要重建集群）<div>但是经过实际测试，是可以实现的。<br>以下测试数据库版本9.0.2 . 低版本可能有一定差异。(比如有一个版本改进了standby shutdown后自动获取checkpoint的功能，最初的9.0是没有的，没有这个功能重启后需要用到一些已经APPLY的WAL，带来比较麻烦的问题。有兴趣的朋友可以参考我以前写的BLOG)<br>首先来看几个和XLOG相关的东西，要确保安全的SWITCHOVER，必须确保一下提及的数据在primary和standby切换前是一致的。<br>1. primary 和 standby 关闭后使用pg_controldata输出的checkpoint location (-m immediate关闭的话这个值不可信,因此必须确保都是-m fast 或者 smart模式关闭的，fast和smart关闭都是干净的关闭模式，起来时不需要recovery)<br></div><div><br>具体的操作步骤：<br>1. on primary <br>pg_ctl stop -m fast $PGDATA <br>确认返回成功后<br>查看pg_controldata输出 <br>Latest checkpoint location:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1B/6C000020<br>Latest checkpoint's REDO location:&nbsp;&nbsp;&nbsp; 1B/6C000020<br>2. on standby<br>pg_ctl stop -m fast $PGDATA<br>确认返回成功后<br>查看pg_controldata输出 <br>Latest checkpoint location:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1B/6C000020<br> Latest checkpoint's REDO location:&nbsp;&nbsp;&nbsp; 1B/6C000020<br>3. 确保standby和primary 的pg_controldata&nbsp;&nbsp;&nbsp; checkpoint的输出结果一致。就可以切换standby 和 primary了。<br>4. 启动standby,并且touch一个在recovery.conf中的trigger文件，使standby promote.为primary库<br>5. 修改原primary库的配置文件 并新建recovery.conf,需要注意的是新增一条<br>recovery_target_timeline = 'latest' ,否则会报类似如下错误timeline 6 of the primary does not match recovery target timeline 5。（其他配置略，清参考我以前写的BLOG。）<br>6. 启动原primary , 此时切换完成,primary 变standby ,standby 变primary ,而且可以再次切换。<br><br>切换完成后查看pg_controldata的输出，TimeLineID 将变大。<br>TimeLineID递增后，在新的PRIMARY 库会出现类似如下进程<br>postgres: archiver process&nbsp;&nbsp; last was 00000005.history<br>而TimeLineID可能就等于5.<br>与此同时，新的standby TimeLineID还是老的，因为还没有更新过来。<br>要更新过来的话，要么等CHECKPOINT，要么关闭主节点，然后再关闭副节点。起来之后就同步了。<br><br>下面来分析一下,一个archive和stream都打开的主副数据库集群.<br>1. 主节点在干净的关闭数据库时干了些啥？<br>对于一个STREAM复制的环境，主节点上面有一个WAL_SENDER进程，干净关闭数据库时，postmaster对这个进程的处理方法和普通的SERVER PROCESS不一样，数据库关闭时首先发信号给server process关闭，然后写shutdown checkpoint ,（有兴趣的朋友可以看一看CHECKPOINT的源码，CHECKPOINT分为好几种），然后postmaster告知wal_sender shutdown_checkpoint，并且把截止这个CHECKPOINT的XLOG发送给standby上面的wal_receiver进程。</div><div>从而主节点干净的关闭数据库时，standby节点可以接收到shutdown_checkpoint，达到一致的目的。</div><div>原文引用:</div><div><div>Therefore postmaster treats walsenders like the pgarch process,</div><div>and instructs them to terminate at PM_SHUTDOWN_2 phase, after all regular</div><div>backends have died and bgwriter has written the shutdown checkpoint.</div><br>2. 副节点在干净的关闭数据库时干了些啥？<br>standby节点干净的关闭数据库，直接关闭，目前的版本不尝试且不等待正在从archive ，pg_xlog，或wal_sender恢复完成。但是已经接收到的CHECKPOINT将被写入持久化存储,因此关闭后pg_controldata与主节点一致.</div><div><br><br>干净的关闭后的primary 和standby 库的pg_controldata输入示例 : <br>primary : <br><pre class="prettyprint"   ><p><font size="2"   >postgres@digoal-172-16-3-39-&gt; pg_controldata <br>pg_control version number:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 903<br>Catalog version number:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 201008051<br>Database system identifier:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5556352067747738614<br>Database cluster state:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shut down<br>pg_control last modified:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wed 11 May 2011 08:52:38 PM CST<br>Latest checkpoint location:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1B/70000020<br>Prior checkpoint location:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1B/6C000078<br>Latest checkpoint's REDO location:&nbsp;&nbsp;&nbsp; 1B/70000020<br>Latest checkpoint's TimeLineID:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5<br>Latest checkpoint's NextXID:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0/4369<br>Latest checkpoint's NextOID:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2074455<br>Latest checkpoint's NextMultiXactId:&nbsp; 1<br>Latest checkpoint's NextMultiOffset:&nbsp; 0<br>Latest checkpoint's oldestXID:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 655<br>Latest checkpoint's oldestXID's DB:&nbsp;&nbsp; 1<br>Latest checkpoint's oldestActiveXID:&nbsp; 0<br>Time of latest checkpoint:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wed 11 May 2011 08:52:38 PM CST<br>Minimum recovery ending location:&nbsp;&nbsp;&nbsp;&nbsp; 0/0<br>Backup start location:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0/0<br>Current wal_level setting:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hot_standby<br>Current max_connections setting:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2000<br>Current max_prepared_xacts setting:&nbsp;&nbsp; 50<br>Current max_locks_per_xact setting:&nbsp;&nbsp; 64<br>Maximum data alignment:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8<br>Database block size:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192<br>Blocks per segment of large relation: 1048576<br>WAL block size:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192<br>Bytes per WAL segment:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67108864<br>Maximum length of identifiers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64<br>Maximum columns in an index:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32<br>Maximum size of a TOAST chunk:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1996<br>Date/time type storage:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64-bit integers<br>Float4 argument passing:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; by value<br>Float8 argument passing:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; by value</font></p></pre><br>standby : <br><pre class="prettyprint"   ><p><font size="2"   >postgres@digoal-172-16-3-33-&gt; pg_controldata <br>pg_control version number:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 903<br>Catalog version number:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 201008051<br>Database system identifier:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5556352067747738614<br>Database cluster state:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shut down in recovery<br>pg_control last modified:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wed 11 May 2011 08:52:52 PM CST<br>Latest checkpoint location:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1B/70000020<br>Prior checkpoint location:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1B/6C000020<br>Latest checkpoint's REDO location:&nbsp;&nbsp;&nbsp; 1B/70000020<br>Latest checkpoint's TimeLineID:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5<br>Latest checkpoint's NextXID:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0/4369<br>Latest checkpoint's NextOID:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2074455<br>Latest checkpoint's NextMultiXactId:&nbsp; 1<br>Latest checkpoint's NextMultiOffset:&nbsp; 0<br>Latest checkpoint's oldestXID:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 655<br>Latest checkpoint's oldestXID's DB:&nbsp;&nbsp; 1<br>Latest checkpoint's oldestActiveXID:&nbsp; 0<br>Time of latest checkpoint:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wed 11 May 2011 08:52:38 PM CST<br>Minimum recovery ending location:&nbsp;&nbsp;&nbsp;&nbsp; 1B/6C000020<br>Backup start location:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0/0<br>Current wal_level setting:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hot_standby<br>Current max_connections setting:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2000<br>Current max_prepared_xacts setting:&nbsp;&nbsp; 50<br>Current max_locks_per_xact setting:&nbsp;&nbsp; 64<br>Maximum data alignment:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8<br>Database block size:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192<br>Blocks per segment of large relation: 1048576<br>WAL block size:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192<br>Bytes per WAL segment:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67108864<br>Maximum length of identifiers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64<br>Maximum columns in an index:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32<br>Maximum size of a TOAST chunk:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1996<br>Date/time type storage:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64-bit integers<br>Float4 argument passing:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; by value<br>Float8 argument passing:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; by value</font></p></pre><br><br>对于一个因异常而FAILOVER的库，因为failover时不能确保primary 和 standby 的checkpoint一致,所以，在primary数据库服务器修复后，不能直接转换为standby，而需要一个checkpoint小于standby切换为primary时的standby库的checkpoint的基础备份，并且需要足够的archive log来做apply,<br>因此failover后主备集群的重新建立的速度或简易程度，大部分决定于平时对standby和archive log的备份。<br><wbr></div><div><br></div><div><br></div><div># 补充</div><div># 2011-06-09 今天对一个生产系统做了切换，版本是9.0.3</div><div># 切换后，起主节点的时候一直处于等待状态</div><div>postgres: startup process &nbsp; waiting for 00000001000001200000001C</div><div># 日志里面报错如下:</div><div>cp: cannot stat `/opt/pg_arch/00000002.history': No such file or directory</div><div>#&nbsp;00000002.history这个文件来自于新的primary节点pg_xlog目录,拷贝到/opt/pg_arch/00000002.history,另外</div><div>拷贝00000001000001200000001C到/opt/pg_arch/.</div><div># 拷贝完后重启老的primary节点.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2011-06-09 14:31:57.095 CST,,,1357,,4df068dd.54d,1,,2011-06-09 14:31:57 CST,,0,LOG,00000,"database system was shut down in recovery at 2011-06-09 14:31:53 CST",,,,,,,,,""</font></div><div><font size="2"   >2011-06-09 14:31:57.099 CST,,,1357,,4df068dd.54d,2,,2011-06-09 14:31:57 CST,,0,LOG,00000,"restored log file ""00000002.history"" from archive",,,,,,,,,""</font></div><div><font size="2"   >2011-06-09 14:31:57.105 CST,,,1357,,4df068dd.54d,3,,2011-06-09 14:31:57 CST,,0,LOG,00000,"restored log file ""00000002.history"" from archive",,,,,,,,,""</font></div><div><font size="2"   >2011-06-09 14:31:57.105 CST,,,1357,,4df068dd.54d,4,,2011-06-09 14:31:57 CST,,0,LOG,00000,"entering standby mode",,,,,,,,,""</font></div><div><font size="2"   >2011-06-09 14:31:57.275 CST,,,1357,,4df068dd.54d,5,,2011-06-09 14:31:57 CST,,0,LOG,00000,"restored log file ""00000001000001200000001C"" from archive",,,,,,,,,""</font></div><div><font size="2"   >2011-06-09 14:31:58.120 CST,,,1357,,4df068dd.54d,6,,2011-06-09 14:31:57 CST,1/0,0,LOG,00000,"consistent recovery state reached at 120/70000078",,,,,,,,,""</font></div><div><font size="2"   >2011-06-09 14:31:58.120 CST,,,1357,,4df068dd.54d,7,,2011-06-09 14:31:57 CST,1/0,0,LOG,00000,"invalid record length at 120/70000078",,,,,,,,,""</font></div><div><font size="2"   >2011-06-09 14:31:58.121 CST,,,1355,,4df068dc.54b,1,,2011-06-09 14:31:56 CST,,0,LOG,00000,"database system is ready to accept read only connections",,,,,,,,,""</font></div><div><font size="2"   >2011-06-09 14:31:58.126 CST,,,1365,,4df068de.555,1,,2011-06-09 14:31:58 CST,,0,LOG,00000,"streaming replication successfully connected to primary",,,,,,,,,""</font></div><div><font size="2"   >2011-06-09 14:31:59.320 CST,,,1357,,4df068dd.54d,8,,2011-06-09 14:31:57 CST,1/0,0,LOG,00000,"redo starts at 120/70000078",,,,,,,,,""</font></div><p></p></pre></div><div>成功的切换为standby节点.</div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL cluster role switchover between primary and standby - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">Ling - 2012-06-06 16:08:22</h5>
				<div><div>我想请问一下，要是的主库的操作系统是的Win 764位元，而备库的操作系统是XP32位元，这样环境下的主备库还是建立的起来吗？<br><br></div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 Ling - 2012-06-06 16:08:22</h5>
				<div style="width:600px;">你试试看,理论上来说是不可以的.<br><br></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">Ling 回复 德哥@Digoal - 2012-06-06 16:08:22</h5>
				<div style="width:600px;"><div>我试了一下确实是不行!!但错误原因却很奇怪的不是说位元无法转换!!我想在请问一下~ 请问postgreSQL有像oracle那样有转换64bit跟32bit间的工具吗?? 我都找不到相关介绍!! 谢谢你唷^^<br><br></div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 Ling - 2012-06-06 16:08:22</h5>
				<div style="width:600px;">没有这样的工具</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 Ling - 2012-06-06 16:08:22</h5>
				<div style="width:600px;">但是你可以选择其他复制方法,例如londiste.<div>可以参考我的blog</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201243051338137/"  >http://blog.163.com/digoal@126/blog/static/163877040201243051338137/</a> </div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020125441314324/"  >http://blog.163.com/digoal@126/blog/static/16387704020125441314324/</a> </div></div>
			</div>
			<div id="">
				<h5 id="">kelly_lin2005 - 2011-10-27 16:02:57</h5>
				<div>您好，非常感谢您的文章，帮助很大，有2个问题想请教：<div>1.如果有磁阵共享存储，用heartbeat管理postgre服务，共享PGDATA能行吗？</div><div>2.同样有共享存储，用windows server 2003 Cluster Service能实现postgre主备吗？</div><div>非常感谢<br><br></div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 kelly_lin2005 - 2011-10-27 16:02:57</h5>
				<div style="width:600px;">HI,<div>1.共享可以，同一时间只能有一个节点操作数据文件，否则会破坏数据文件的完整性，建议使用集群文件系统如GFS。</div><div>2. win不熟，我还是建议使用LINUX.<br><div><br></div></div></div>
			</div>
			<div id="">
				<h5 id="">dyj6628648 - 2011-06-22 16:17:04</h5>
				<div><P>德哥你好，我是一个PG的初级用户，想问一下pg在primary 和 standby 切换时是自动切换的还是手动切换的? 如果是自动切换的需要怎样配置<IMG src="http://b.bst.126.net/common/portrait/face/preview/face0.gif"></P></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 dyj6628648 - 2011-06-22 16:17:04</h5>
				<div style="width:600px;">HI,有些第三方工具可以实现自动切。比如pgpoolii，需要配置切换脚本。</div>
			</div>
			<div id="">
				<h5 id="">cql3829 - 2011-05-24 16:00:08</h5>
				<div>您好，最近在研究postgre集群的方案，刚一口气看了多篇您博文中的相关内容，收获很大，结合自己的项目实际情况，想就几个方面的问题听听您的意见，望不吝赐教：<div>1.如果配备有磁盘阵列公共存储，想要实现postgre双机热备切换，用什么样的部署方案比较好？</div><div>2.因为是企业级的应用，要求可靠性比较高，您觉得那种备份方案最可靠？（不限于磁盘阵列）<br><br></div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 cql3829 - 2011-05-24 16:00:08</h5>
				<div style="width:600px;">HI,<div>1. RHCS</div><div>2. stream replication</div></div>
			</div>
	</div>
</div>
</body>
</html>