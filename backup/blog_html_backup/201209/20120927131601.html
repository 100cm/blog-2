<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.1.6 & 9.2.1 Data Corruption Issue patch</h2>
	<h5 id="">2012-09-27 13:16:01&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012827111238272/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">  <div>9.1.6和9.2.1修复了一个非常严重的BUG, 这个BUG的问题描述如下 :&nbsp;</div>  <div><pre class="prettyprint"  ><p></p><div><font size="2"  >Description of the Problem</font></div><div><font size="2"  >&nbsp; Versions 9.1 and 9.2 of PostgreSQL have a bug with flushing dirty blocks from memory, or "checkpointing", introduced accidentally as a side effect of performance optimizations and new features, mainly Unlogged Tables. This bug can cause data of certain types to not be written to disk if the database shuts down or restarts for any of the following reasons:</font></div><div><font size="2"  >&nbsp; 1. PostgreSQL crash</font></div><div><font size="2"  >&nbsp; 2. Server crash or power loss</font></div><div><font size="2"  >&nbsp; 3. "immediate" shutdown (pg_ctl -m immediate)</font></div><div><font size="2"  >&nbsp; 4. "kill -9" or Out-Of-Memory-Kill of the postmaster service</font></div><div><font size="2"  >&nbsp; 5. database is a standby which was promoted to master</font></div><div><font size="2"  >&nbsp; Under these circumstances, the database can suffer from recoverable data corruption. The nature of this corruption is such that it can produce wrong, but seemingly valid, answers to queries, so it is critical that users who may have been affected by this corruption take steps to clean it up very soon.</font></div><div><font size="2"  >&nbsp; First, there is a low probability of corruption of BTREE and GIN indexes. Shutting down cleanly will limit the further spread of this issue. It's very likely that if corruption has occurred that it would be visible in the form of error messages when the index is used.</font></div><div><font size="2"  >&nbsp; Second, there is a significant probability of corruption of relation visibility maps (approaching 100% on standbys). This affects 9.1 very differently from 9.2, however. On PostgreSQL 9.1 the worst consequence is some transient inefficiency and/or failure to recover free space during VACUUM. On PostgreSQL 9.2, we use the visibility map during index only scans and so these are likely to produce wrong answers.</font></div><div><font size="2"  >The PostgreSQL Global Development Group apologizes for the inconvenience caused by these issues.</font></div><p></p></pre></div>  <div>&nbsp; 也就是说遇到这5种情况, 就可能触发这个BUG. </div>  <div>&nbsp; 而这个BUG最恐怖的地方应该是对于9.2 由于使用index only scan需要用到VM文件, 这个BUG可能导致走index only scan的执行计划和其他执行计划得到不一致的结果, 原因是vm文件flush 异常.&nbsp;</div>  <div>&nbsp; 但是我在使用以上3,5这两种情况测试9.2.0的版本时并没有触发这个BUG. index only scan和其他执行计划得到的同样的结果.</div>  <div>&nbsp; 这个BUG的修复涉及到以下两个源码文件 :&nbsp;</div>  <div>  <div><pre class="prettyprint"  style="font-size: small;"  ><p>src/backend/access/transam/xlogutils.c</p><div><font size="2"  >src/backend/storage/buffer/bufmgr.c</font></div><p></p></pre><pre><font size="3"  >以下列举9.2.1对应这个BUG的修改如下 :&nbsp;</font></pre></div></div>  <div>  <div>1. Properly set relpersistence for fake relcache entries.</div>  <div><pre class="prettyprint"  ><p><font size="2"  >&nbsp; &nbsp;This can result in buffers failing to be properly flushed at checkpoint time, leading to data loss.</font></p></pre></div>  <div>  <div><img title="PostgreSQL 9.1.6  9.2.1 Data Corruption Issue patch - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL 9.1.6  9.2.1 Data Corruption Issue patch - 德哥@Digoal - The Heart,The World."  style="MARGIN: 0px 10px 0px 0px;"  src="http://img3.ph.126.net/tl4PQzrGmix7BTzTfPshbg==/1273111319680143373.jpg"  ></div>&nbsp;<br></div>  <div>2. Fix bufmgr so CHECKPOINT_END_OF_RECOVERY behaves as a shutdown checkpoint.</div>  <div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp;Recovery code documents clearly that a shutdown checkpoint is executed at end of recovery - a shutdown checkpoint WAL record is written but the buffer manager had been altered to treat end of recovery as a normal checkpoint. This bug exacerbates the bufmgr relpersistence bug.</font></div>  <div><font size="2"  >/*<br>* BufferSync -- Write out all dirty buffers in the pool.<br>*<br>* This is called at checkpoint time to write out all dirty shared buffers.<br>* The checkpoint request flags should be passed in. If CHECKPOINT_IMMEDIATE<br>* is set, we disable delays between writes; if CHECKPOINT_IS_SHUTDOWN is<br>* set, we write even unlogged buffers, which are otherwise skipped. The<br>* remaining flags currently have no effect here.<br>*/</font></div><p></p></pre></div></div>  <div>  <div><img title="PostgreSQL 9.1.6  9.2.1 Data Corruption Issue patch - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL 9.1.6  9.2.1 Data Corruption Issue patch - 德哥@Digoal - The Heart,The World."  style="MARGIN: 0px 10px 0px 0px;"  src="http://img2.ph.126.net/7RrT7GdPUIdg4LTnHNf6pA==/2491897968837228222.jpg"  ></div>&nbsp;</div>  <div>我这边用到的再现BUG测试 :&nbsp;</div><div>1. 单库</div><div>测试表 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; \d user_info</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Table "digoal.user_info"</font></div><div><font size="2"  >&nbsp; Column &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Modifiers&nbsp;</font></div><div><font size="2"  >-----------+--------------------------------+-----------</font></div><div><font size="2"  >&nbsp;id &nbsp; &nbsp; &nbsp; &nbsp;| integer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| not null</font></div><div><font size="2"  >&nbsp;firstname | name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;lastname &nbsp;| name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;age &nbsp; &nbsp; &nbsp; | integer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;email &nbsp; &nbsp; | text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;pwd &nbsp; &nbsp; &nbsp; | text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;crt_time &nbsp;| timestamp(0) without time zone |&nbsp;</font></div><div><font size="2"  >&nbsp;mod_time &nbsp;| timestamp(0) without time zone |&nbsp;</font></div><div><font size="2"  >Indexes:</font></div><div><font size="2"  >&nbsp; &nbsp; "user_info_pkey" PRIMARY KEY, btree (id)</font></div><div><font size="2"  >&nbsp; &nbsp; "idx_user_info_mod_time" btree (mod_time)</font></div><p></p></pre></div><div>测试数据 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >insert into user_info (id,firstname,lastname,age,email,pwd,crt_time) select generate_series(1,10000000),'zhou','digoal',29,'digoal@1</font></div><div><font size="2"  >26.com','thisistest',now();</font></div><p></p></pre></div><div>测试脚本 :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.2.0@db-172-16-3-150-&gt; cat pgbench.sql&nbsp;</font></div><div><font size="2"  >\setrandom id 1 10000000</font></div><div><font size="2"  >update user_info set mod_time=now() where id=:id;</font></div><p></p></pre></div><div>测试使用pgbench :&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >pg9.2.0@db-172-16-3-150-&gt; pgbench -M prepared -c 4 -f ./pgbench.sql -j 4 -n -r -T 600 -U digoal digoal</font></p></pre></div></div><div>加压过程中将数据库异常关闭,</div><div><pre class="prettyprint"  ><p><font size="2"  >pg_ctl stop -m immediate</font></p></pre></div><div>重启数据库</div><div>查询数据 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.2.0@db-172-16-3-150-&gt; psql</font></div><div><font size="2"  >psql (9.2.0)</font></div><div><font size="2"  >Type "help" for help.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >postgres=# \c digoal digoal</font></div><div><font size="2"  >You are now connected to database "digoal" as user "digoal".</font></div><div><font size="2"  >digoal=&gt; explain select count(*) from user_info where mod_time &gt;= '2012-09-27 08:10:00' and mod_time &lt;='2012-09-27 13:20:50';</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >-------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=270743.89..270743.90 rows=1 width=0)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using idx_user_info_mod_time on user_info &nbsp;(cost=0.00..267655.92 rows=1235188 width=0)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((mod_time &gt;= '2012-09-27 08:10:00'::timestamp without time zone) AND (mod_time &lt;= '2012-09-27 13:20:50'::times</font></div><div><font size="2"  >tamp without time zone))</font></div><div><font size="2"  >(3 rows)</font></div><div><font size="2"  >digoal=&gt; select count(*) from user_info where mod_time &gt;= '2012-09-27 08:10:00' and mod_time &lt;='2012-09-27 13:20:50';</font></div><div><font size="2"  >&nbsp; count &nbsp;</font></div><div><font size="2"  >---------</font></div><div><font size="2"  >&nbsp;6446993</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=&gt; set enable_indexonlyscan=off;</font></div><div><font size="2"  >SET</font></div><div><font size="2"  >digoal=&gt; set enable_indexscan=off;</font></div><div><font size="2"  >SET</font></div><div><font size="2"  >digoal=&gt; set enable_bitmapscan=off;</font></div><div><font size="2"  >SET</font></div><div><font size="2"  >digoal=&gt; explain select count(*) from user_info where mod_time &gt;= '2012-09-27 08:10:00' and mod_time &lt;='2012-09-27 13:20:50';</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >---------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=426642.09..426642.10 rows=1 width=0)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on user_info &nbsp;(cost=0.00..422820.99 rows=1528437 width=0)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: ((mod_time &gt;= '2012-09-27 08:10:00'::timestamp without time zone) AND (mod_time &lt;= '2012-09-27 13:20:50'::timestamp</font></div><div><font size="2"  >&nbsp;without time zone))</font></div><div><font size="2"  >(3 rows)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=&gt; select count(*) from user_info where mod_time &gt;= '2012-09-27 08:10:00' and mod_time &lt;='2012-09-27 13:20:50';</font></div><div><font size="2"  >&nbsp; count &nbsp;</font></div><div><font size="2"  >---------</font></div><div><font size="2"  >&nbsp;6446993</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div>2. standby 库(与以上相同, 只是测试的是standby 库.)</div><div>2.1 pgbench在primary库上执行.</div><div>2.2 在standby库上执行pg_ctl promote</div><div>2.3 在standby库上查询以上SQL.</div><div>使用indexonlyscan和seqscan得到的结果一致.</div><div>所以我在测试中用到的是BUG PATCH中提到的3和5点, 但是都没有能够触发这个BUG.</div><div><br></div><div>【修复】</div><div>修复这个BUG, 9.1和9.2的操作略有区别, 摘录如下 :&nbsp;</div><div><div>Steps for Users of PostgreSQL 9.1</div><div><pre class="prettyprint"  ><div><font size="2"  >If you are running 9.1, and suspect that you may be vulnerable to database corruption because your database has shut down unexpectedly or failed over during the last few months:</font></div><div><font size="2"  >Download new 9.1.6 packages</font></div><div><font size="2"  >Do a clean shutdown of PostgreSQL, using one of the following mechanisms:</font></div><div><font size="2"  >init script or service manager</font></div><div><font size="2"  >pg_ctl -m smart stop</font></div><div><font size="2"  >pg_ctl -m fast stop</font></div><div><font size="2"  >Install 9.1.6</font></div><div><font size="2"  >Restart the database system</font></div><div><font size="2"  >Gradually rebuild all of your BTree and GIN indexes (see below)</font></div><div><font size="2"  >Schedule a manual vacuum of the whole database during a convenient slow period (see below)</font></div><div><font size="2"  >If you are planning to upgrade to PostgreSQL 9.2 using pg_upgrade, it is critical for you to run the full database VACUUM first.</font></div><p></p></pre></div><div><br></div><div>Steps for Users of PostgreSQL 9.2</div><div><pre class="prettyprint"  ><div><font size="2"  >If you are running 9.2.0, and suspect that you may be vulnerable to database corruption because your database has shut down unexpectedly or failed over during the last two weeks:</font></div><div><font size="2"  >Download new 9.2.1 packages</font></div><div><font size="2"  >Do a clean shutdown of PostgreSQL, using one of the following mechanisms:</font></div><div><font size="2"  >init script or service manager</font></div><div><font size="2"  >pg_ctl -m smart stop</font></div><div><font size="2"  >pg_ctl -m fast stop</font></div><div><font size="2"  >Install 9.2.1</font></div><div><font size="2"  >Restart the database system</font></div><div><font size="2"  >VACUUM all tables in your database immediately</font></div><div><font size="2"  >Gradually rebuild all of your BTree and GIN indexes (see below)</font></div><p></p></pre></div></div><div><div>How to VACUUM All Tables</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >To correct corruption of the visibility map, users should run a vacuum and force a scan of all database blocks in order to reset the entire map. Since this means effectively scanning the entire database, it will generate considerable IO and take significant time to execute for large databases. One way to ameliorate the impact on concurrently running database load is to use cost delay to spread out the vacuum:</font></div><div><font size="2"  >&nbsp; &nbsp;SET vacuum_cost_delay = 50;</font></div><p></p></pre></div><div>Interactive VACUUM</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >For each database, you should:</font></div><div><font size="2"  >log in to psql as the Postgres superuser</font></div><div><font size="2"  >set vacuum_cost_delay, if doing so</font></div><div><font size="2"  >run "VACUUM ( FREEZE, VERBOSE, ANALYZE );" (ANALYZE is optional)</font></div><div><font size="2"  >This will produce a lot of output, allowing you to track progress of the full-database vacuum.</font></div><div><font size="2"  >You can also VACUUM one table at a time instead of doing them all one after the other, provided that you have some way to track which tables have and have not been vacuumed.</font></div><p></p></pre></div><div>vacuumdb</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >If you have multiple databases to vacuum, you may find it convenient to use the vacuumdb utility instead. This would work by:</font></div><div><font size="2"  >set vacuum_cost_delay in postgresql.conf, if doing so (and reload database)</font></div><div><font size="2"  >run "vacuumdb -F -v -z -a" as the postgres superuser</font></div><div><font size="2"  >Note that you may need to give vacuumdb additional parameters in order to connect with the database server. The -z (analyze) and -v (verbose) options are optional.</font></div><p></p></pre></div><div>Rebuild BTree/GIN Indexes</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >It is likely that any indexes which are corrupted because of the issues fixed in this update release will display error messages when accessed, and can be easily identified. However, it is possible (though unlikely) that a few indexes may be corrupted so that they return incorrect answers without errors.</font></div><div><font size="2"  >The VACUUM FREEZE recommended above will correct some types of index corruption. However, users who have strong data integrity concerns, or feel they are especially at risk due to multiple crashes or failovers in their server history, should take the extra step of rebuilding indexes in order to eliminate any possible corruption.</font></div><p></p></pre></div><div>Rebuilding an Individual Index</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >Whether you are being precautionary, or because you have found an index corruption error, you can rebuild indexes one at a time. The simplest way is via REINDEX.</font></div><div><font size="2"  >&nbsp; &nbsp;REINDEX TABLE &lt;tablename&gt;;</font></div><div><font size="2"  >or for a single index:</font></div><div><font size="2"  >&nbsp; &nbsp;REINDEX INDEX &lt;indexname&gt;;</font></div><div><font size="2"  >You may want to increase the RAM available to REINDEX, by increasing maintenance_work_mem, up to 1/8 of your available RAM (up to a maximum of 2GB). REINDEX takes a full table write lock, however, and depending on the size of the table, can take a considerable time to run. In order to rebuild indexes while under concurrent database load, use CREATE INDEX CONCURRENTLY:</font></div><div><font size="2"  >&nbsp; &nbsp;CREATE INDEX CONCURRENTLY &lt;indexname&gt;_tmp &lt;index_definition&gt;;</font></div><div><font size="2"  >&nbsp; &nbsp;BEGIN;</font></div><div><font size="2"  >&nbsp; &nbsp;DROP INDEX &lt;indexname&gt;;</font></div><div><font size="2"  >&nbsp; &nbsp;ALTER INDEX &lt;indexname&gt;_tmp RENAME TO &lt;indexname&gt;;</font></div><div><font size="2"  >&nbsp; &nbsp;END;</font></div><div><font size="2"  >This locks the table only during the final drop and rename stage. It is, however, more complex.</font></div><div><font size="2"  >Either approach will generate considerable IO while running on large tables.</font></div><p></p></pre></div><div>Getting a List of Btree and GIN Indexes</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >Regardless of your approach towards rebuilding your indexes, you may want to get a list of all BTree and GIN indexes in the database. BTree is the most common type of index, so this will include most of the indexes in your database. Given that GiST indexes can be quite large, though, you may want to omit them from rebuilding.</font></div><div><font size="2"  >Use this query:</font></div><div><font size="2"  >&nbsp; &nbsp;SELECT tablename, indexname, indexdef</font></div><div><font size="2"  >&nbsp; &nbsp;FROM pg_indexes</font></div><div><font size="2"  >&nbsp; &nbsp;WHERE ( indexdef ILIKE '%USING btree%'</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;OR indexdef ILIKE '%USING GIN%' )</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;AND schemaname &lt;&gt; 'pg_catalog'</font></div><div><font size="2"  >&nbsp; &nbsp;ORDER BY tablename, indexname;</font></div><p></p></pre></div><div>Reindexing Everything</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >If you can afford the required downtime, and want to be absolutely certain that you've prevented all corruption, you can reindex every index in your database using the reindexdb utility. Note that this will cause GiST indexes to be rebuilt as well, even though they are not in danger of corruption.</font></div><div><font size="2"  >Run the following as the postgres superuser to reindex one database:</font></div><div><font size="2"  >&nbsp; &nbsp;reindexdb &lt;databasename&gt;</font></div><div><font size="2"  >Or to reindex all databases:</font></div><div><font size="2"  >&nbsp; &nbsp;reindexdb -a</font></div><div><font size="2"  >Additional options may be required for reindexdb to connect to your database. Since reindexdb will take a lock on entire tables in your installation, one at a time, this is best done during a downtime.</font></div><p></p></pre></div></div><div><br></div>【参考】<wbr>  <div><a rel="nofollow" href="http://wiki.postgresql.org/wiki/20120924updaterelease"  >http://wiki.postgresql.org/wiki/20120924updaterelease</a> </div>  <div><a rel="nofollow" href="https://github.com/postgres/postgres/commit/eb6e9b5ea4a5e733da705c053906f3aff47c9bf5"  >https://github.com/postgres/postgres/commit/eb6e9b5ea4a5e733da705c053906f3aff47c9bf5</a> </div>  <div><a rel="nofollow" href="https://github.com/postgres/postgres/commit/9c855045809362f2cdabc110afd6ab8a4b250507"  >https://github.com/postgres/postgres/commit/9c855045809362f2cdabc110afd6ab8a4b250507</a> </div></div>
	</div>
</div>
</body>
</html>