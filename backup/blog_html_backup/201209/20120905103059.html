<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL array range get && Redis LRANGE</h2>
	<h5 id="">2012-09-05 10:30:59&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020128594046594/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">某业务使用redis作为前端缓存, 存储list, ver, appid[] 这样的数据<div>例如:</div><div>LIST :&nbsp;<br><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1:1, "1,2,3,4,5,6,7,8,9,......10W"</font></div><div><span style="line-height: 22px;"  ><font size="2"  >1:2, "2,1,5,4,3,6,7,8,9,......10W"</font></span></div><p></p></pre></div><div>分页取数据, 每次取20个appid :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >LRANGE 1:2 1 20</font></div><div><span style="line-height: 22px;"  ><font size="2"  >LRANGE 1:2 21 40</font></span></div><p></p></pre></div><div>appid[]的数据是通过PostgreSQL里面的表生成的.</div><div><span style="line-height: 22px;"  >运营人员对list进行调整后将写入到redis数据库中.</span></div><div>如select list_id||':'||ver, appid from tbl_appid_info where list_id=? and ver=? order by download_cnt desc;</div><div>假设redis异常, 或者在redis中未找到相关的list:ver信息. 业务系统将需要从PostgreSQL取数据, 也就是需要调用</div><div><span style="line-height: 22px;"  >select list_id||':'||ver, appid from tbl_appid_info where list_id=? and ver=? order by download_cnt desc limit ? offset ?.</span></div><div><span style="line-height: 22px;"  >这种SQL如果并发请求很大的情况下, 数据库负载将急剧升高, 无法满足业务需求.</span></div><div><span style="line-height: 22px;"  ><br></span></div><div><span style="line-height: 22px;"  >所以需要针对这种情况做出一定的优化.</span></div><div>在PostgreSQL中array类型同样可以处理range操作的请求, 如 :</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# select a[3:6] from (select array[1,2,3,4,4,35,6,7,8,9] as a)t ;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;a &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >------------</font></div><div><font size="2"  >&nbsp;{3,4,4,35}</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >所以只要在PostgreSQL中增加一个存储和Redis中存储的类似的信息表即可.</span></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >create table t1(appid int[]);</font></div><div><font size="2"  >insert into t1 select array_agg(id) from (select generate_series(1, 150000) id)t;</font></div><div><font size="2"  >create table digoal(list_id int, list_ver int, appid int[]);</font></div><div><font size="2"  >create table digoal1 (like digoal including all);</font></div><div><font size="2"  >insert into digoal select generate_series(1, 500), 1, appid from t1;</font></div><div><font size="2"  >insert into digoal1 select * from digoal;</font></div><div><font size="2"  >insert into digoal select list_id, generate_series(2, 20), appid from digoal1;</font></div><div><font size="2"  >alter table digoal add constraint digoal_pkey primary key (list_id, list_ver);</font></div><p></p></pre></div><div>-- 单个LIST(15W个appid)的存储大小585KB</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=&gt; select pg_column_size(appid)/1024 from t1;</font></div><div><font size="2"  >&nbsp;?column?&nbsp;</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; 585</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>-- 10W个LIST(含索引)共计5945MB.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=&gt; select pg_total_relation_size('digoal')/1024/1024;</font></div><div><font size="2"  >&nbsp;?column?&nbsp;</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;5945</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div>测试脚本 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@-&gt; cat digoal.sql&nbsp;</font></div><div><font size="2"  >\setrandom appid1 1 149980</font></div><div><font size="2"  >\set appid2 20 + :appid1</font></div><div><font size="2"  >\setrandom list_id 1 500</font></div><div><font size="2"  >\setrandom list_ver 1 20</font></div><div><font size="2"  >select appid[:appid1: :appid2] from digoal where list_id=:list_id and list_ver=:list_ver;</font></div><p></p></pre></div><div><br></div><div>PostgreSQL 9.2rc1版本 测试结果 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@-&gt; pgbench -M prepared -f ./digoal.sql -c 8 -j 8 -n -r -T 30 -h $PGDATA -U skyaaa postgres</font></div><div><font size="2"  >transaction type: Custom query</font></div><div><font size="2"  >scaling factor: 1</font></div><div><font size="2"  >query mode: prepared</font></div><div><font size="2"  >number of clients: 8</font></div><div><font size="2"  >number of threads: 8</font></div><div><font size="2"  >duration: 30 s</font></div><div><font size="2"  >number of transactions actually processed: 360385</font></div><div><font size="2"  >tps = 12012.515402 (including connections establishing)</font></div><div><font size="2"  >tps = 12014.450228 (excluding connections establishing)</font></div><div><font size="2"  >statement latencies in milliseconds:</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 0.002113 &nbsp; &nbsp; &nbsp; &nbsp;\setrandom appid1 1 149980</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 0.000629 &nbsp; &nbsp; &nbsp; &nbsp;\set appid2 20 + :appid1</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 0.000523 &nbsp; &nbsp; &nbsp; &nbsp;\setrandom list_id 1 500</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 0.000543 &nbsp; &nbsp; &nbsp; &nbsp;\setrandom list_ver 1 20</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 0.659888 &nbsp; &nbsp; &nbsp; &nbsp;select appid[:appid1: :appid2] from digoal where list_id=:list_id and list_ver=:list_ver;</font></div><p></p></pre></div><div><br></div><div>所以如果redis挂掉, PostgreSQL数据库还能支撑每秒1.2W次这样的请求.</div><div><br></div><div>【redis测试结果】</div><div>redis 版本2.4.17.</div><div>配置 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 ~]# cat /etc/redis.conf |grep -v "^$"|grep -v "^#"</font></div><div><font size="2"  >daemonize yes</font></div><div><font size="2"  >pidfile /var/run/redis.pid</font></div><div><font size="2"  >port 6379</font></div><div><font size="2"  >bind 0.0.0.0</font></div><div><font size="2"  >unixsocket /tmp/redis.sock</font></div><div><font size="2"  >unixsocketperm 755</font></div><div><font size="2"  >timeout 0</font></div><div><font size="2"  >loglevel verbose</font></div><div><font size="2"  >logfile stdout</font></div><div><font size="2"  >databases 16</font></div><div><font size="2"  >save 900 1</font></div><div><font size="2"  >save 300 10</font></div><div><font size="2"  >save 60 10000</font></div><div><font size="2"  >rdbcompression yes</font></div><div><font size="2"  >dbfilename dump.rdb</font></div><div><font size="2"  >dir /redis</font></div><div><font size="2"  >slave-serve-stale-data yes</font></div><div><font size="2"  >slave-priority 100</font></div><div><font size="2"  >maxclients 128</font></div><div><font size="2"  >maxmemory 10240000000</font></div><div><font size="2"  >appendonly no</font></div><div><font size="2"  >appendfsync everysec</font></div><div><font size="2"  >no-appendfsync-on-rewrite no</font></div><div><font size="2"  >auto-aof-rewrite-percentage 100</font></div><div><font size="2"  >auto-aof-rewrite-min-size 64mb</font></div><div><font size="2"  >slowlog-log-slower-than 10000</font></div><div><font size="2"  >slowlog-max-len 128</font></div><div><font size="2"  >vm-enabled no</font></div><div><font size="2"  >vm-swap-file /tmp/redis.swap</font></div><div><font size="2"  >vm-max-memory 0</font></div><div><font size="2"  >vm-page-size 32</font></div><div><font size="2"  >vm-pages 134217728</font></div><div><font size="2"  >vm-max-threads 4</font></div><div><font size="2"  >hash-max-zipmap-entries 512</font></div><div><font size="2"  >hash-max-zipmap-value 64</font></div><div><font size="2"  >list-max-ziplist-entries 512</font></div><div><font size="2"  >list-max-ziplist-value 64</font></div><div><font size="2"  >set-max-intset-entries 512</font></div><div><font size="2"  >zset-max-ziplist-entries 128</font></div><div><font size="2"  >zset-max-ziplist-value 64</font></div><div><font size="2"  >activerehashing yes</font></div><p></p></pre></div><div><br></div><div>测试数据插入程序 :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat a.c</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; int id;</font></div><div><font size="2"  >&nbsp; int ver;</font></div><div><font size="2"  >&nbsp; char command[500];</font></div><div><font size="2"  >&nbsp; char * command1 = "/usr/local/bin/redis-benchmark -n 150000 -d 4 lpush mylist" ;</font></div><div><font size="2"  >&nbsp; char * command2 = "ele:rand:00000000000000000" ;</font></div><div><font size="2"  >&nbsp; for (id=1; id&lt;=500; id++) {</font></div><div><font size="2"  >&nbsp; &nbsp; for (ver=1; ver&lt;=20; ver++) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; sprintf(command, "%s%d:%d %s", command1, id, ver, command2);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(stdout, "command:%s\n", command);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; system(command);</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o a</font></div><p></p></pre></div><div><br></div><div>先把redis-server中的数据清除 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# redis-cli</font></div><div><font size="2"  >redis 127.0.0.1:6379&gt; flushdb</font></div><div><font size="2"  >OK</font></div><div><font size="2"  >(22.16s)</font></div><div><font size="2"  >redis 127.0.0.1:6379&gt; exit</font></div><p></p></pre></div><div><br></div><div>开始插入测试数据 :&nbsp;</div><div>[root@db-172-16-3-150 zzz]# ./a</div><div>写入速度 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >command:/usr/local/bin/redis-benchmark -n 150000 -d 4 lpush mylist5:12 ele:rand:00000000000000000</font></div><div><font size="2"  >====== lpush mylist5:12 ele:rand:00000000000000000 ======</font></div><div><font size="2"  >&nbsp; 150000 requests completed in 2.33 seconds</font></div><div><font size="2"  >&nbsp; 50 parallel clients</font></div><div><font size="2"  >&nbsp; 4 bytes payload</font></div><div><font size="2"  >&nbsp; keep alive: 1</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >99.90% &lt;= 1 milliseconds</font></div><div><font size="2"  >100.00% &lt;= 1 milliseconds</font></div><div><font size="2"  >64488.39 requests per second</font></div><p></p></pre></div><div><br></div><div>使用lrange取出的测试结果 :&nbsp;</div><div>lrange速度 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 ~]# redis-benchmark -s /tmp/redis.sock -c 8 -n 1000000 -t lrange mylist1:20 100000 100020</font></div><div><font size="2"  >====== mylist1:20 100000 100020 ======</font></div><div><font size="2"  >&nbsp; 1000000 requests completed in 70.61 seconds</font></div><div><font size="2"  >&nbsp; 8 parallel clients</font></div><div><font size="2"  >&nbsp; 3 bytes payload</font></div><div><font size="2"  >&nbsp; keep alive: 1</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >99.72% &lt;= 1 milliseconds</font></div><div><font size="2"  >100.00% &lt;= 2 milliseconds</font></div><div><font size="2"  >100.00% &lt;= 43 milliseconds</font></div><div><font size="2"  >100.00% &lt;= 43 milliseconds</font></div><div><font size="2"  >14163.30 requests per second</font></div><p></p></pre></div></div><div><br></div><div>【其他】</div><div>1. 如果有更复杂的信息在PostgreSQL中可以选择存储为json数组类型. json[]</div></div><div>2. range 取值范围前段和后段性能差别不大.</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >postgres=&gt; select appid[120001:120020] from test where list_id=100 and list_ver=5;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;appid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >-----------</font></div><div><font size="2"  >&nbsp;{120001,120002,120003,120004,120005,120006,120007,120008,120009,120010,120011,120012,120013,120014,120015,120016,120017,120018,1200</font></div><div><font size="2"  >19,120020}</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Time: 0.591 ms</font></div></div><div><div><font size="2"  >postgres=&gt; select appid[1:20] from test where list_id=100 and list_ver=5;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >------------------------------------------------------</font></div><div><font size="2"  >&nbsp;{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Time: 0.598 ms</font></div></div><p></p></pre></div><div>3. 由于redis-server是线程的, 所以在处理连接数较多的场景时, 相比PG更优优势. 当然如果PG前段加个pgbouncer也可以起到很好的优化效果.</div><div><br></div></div></div>
	</div>
</div>
</body>
</html>