<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Realtime update in redis merge to PostgreSQL case</h2>
	<h5 id="">2013-06-20 16:33:56&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201352041730210/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 的update操作实际上是修改了老记录的xmax信息以及新增一条更新后的记录, 以此来提供并发控制.&nbsp;</div><div>因此在更新完成后, 老的记录需要vacuum进程来进行回收.</div><div>另外, 更新还可能带来新行写新块, 此时还会带来索引的变更. 所以在PostgreSQL中update的开销比insert大很多.</div><div>一位朋友想把redis中的实时更新在PostgreSQL中也保留一份实时的状态, 但是又担心更新太多.</div><div>redis中存储了key, value的最新状态.</div><div>因此想了一个办法如下,</div><div>在PostgreSQL中把实时的更新改掉, 由实时的插入来替代实时的更新, 所以插入的数据key值会有重复的现象, 同时定期对插入的数据进行合并.&nbsp;</div><div>数据合并时将key对应的最新状态更新到总状态表中.</div><div><br></div><div>过程如下 :&nbsp;</div><div>总状态表 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table tp_cache_info(key int8, value text, stamp timestamp without time zone default now());</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>提供插入的临时表1 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table tmp_cache_info_1(like tp_cache_info including all);</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >提供插入的临时表2 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table tmp_cache_info_2(like tp_cache_info including all);</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>记录合并状态信息的表 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table tp_cache_manage(tablename name primary key, key int8);</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div><br></div><div>合并数据的函数, 如果当前正在插入<span style="line-height: 22px;"   >tmp_cache_info_2, 那么此时可以合并</span><span style="line-height: 22px;"   >tmp_cache_info_1的数据.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create or replace function merge_tp(i_tablename name, i_batch smallint, i_advisory_key int8) returns void as</font></div><div><font size="2"   >$$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; v_key int8;</font></div><div><font size="2"   >&nbsp; v_key_loop int8;</font></div><div><font size="2"   >&nbsp; v_value_loop text;</font></div><div><font size="2"   >&nbsp; v_key_init int8 := 0;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; if pg_try_advisory_lock(i_advisory_key) then</font></div><div><font size="2"   >&nbsp; &nbsp; select key into v_key from tp_cache_manage where tablename=i_tablename;</font></div><div><font size="2"   >&nbsp; &nbsp; if found then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; for v_key_loop,v_value_loop in execute format('select key,value from (select key,value,row_number() over (partition by key order by stamp desc) AS rn from %I) t where key&gt;$1 and rn=1 order by key limit $2', i_tablename) USING v_key,i_batch loop</font></div><div><font size="2"   ><span>	    </span>update tp_cache_info set value=v_value_loop where key=v_key_loop;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if not found then</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert into tp_cache_info values (v_key_loop,v_value_loop);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; end if;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; end loop;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if v_key_loop is null then</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; raise notice '所有数据已合并完, 清除数据';</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; delete from tp_cache_manage where tablename=i_tablename;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; execute 'truncate table '||i_tablename;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; update tp_cache_manage set key=v_key_loop where tablename=i_tablename;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; end if;</font></div><div><font size="2"   >&nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; insert into tp_cache_manage (tablename, key) values (i_tablename, v_key_init);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; raise notice '初始化';</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; &nbsp; end if;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '禁止并行调用.';</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; return;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><p></p></pre></div><div># 插入测试数据</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# insert into tp_cache_info select generate_series(1,1000),'test';</font></div><div><font size="2"   >INSERT 0 1000</font></div><div><font size="2"   >digoal=# insert into tmp_cache_info_1 select generate_series(100,2000),'new';</font></div><div><font size="2"   >INSERT 0 1901</font></div><div><font size="2"   >digoal=# insert into tmp_cache_info_1 select generate_series(800,3000),'new1';</font></div><div><font size="2"   >INSERT 0 2201</font></div><p></p></pre></div><div># 合并</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from merge_tp('tmp_cache_info_1', 10::int2, 10);</font></div><div><font size="2"   >NOTICE: &nbsp;初始化</font></div><div><font size="2"   >&nbsp;merge_tp&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>查看合并信息表 :&nbsp;</div><div><p></p><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from tp_cache_manage ;</font></div><div><font size="2"   >&nbsp; &nbsp; tablename &nbsp; &nbsp; | key&nbsp;</font></div><div><font size="2"   >------------------+-----</font></div><div><font size="2"   >&nbsp;tmp_cache_info_1 | &nbsp; 0</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   ><font size="2"   ># 合并</font></span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from merge_tp('tmp_cache_info_1', 10::int2, 10);</font></div><div><font size="2"   >&nbsp;merge_tp&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><p></p></div><div><span style="line-height: 22px;"   >查看合并信息表 :&nbsp;</span></div><div><p></p><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from tp_cache_manage ;</font></div><div><font size="2"   >&nbsp; &nbsp; tablename &nbsp; &nbsp; | key&nbsp;</font></div><div><font size="2"   >------------------+-----</font></div><div><font size="2"   >&nbsp;tmp_cache_info_1 | 109</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   ><font size="2"   ># 合并</font></span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from merge_tp('tmp_cache_info_1', 100::int2, 10);</font></div><div><font size="2"   >&nbsp;merge_tp&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><p></p></div><div><span style="line-height: 22px;"   >查看合并信息表 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from tp_cache_manage ;</font></div><div><font size="2"   >&nbsp; &nbsp; tablename &nbsp; &nbsp; | key&nbsp;</font></div><div><font size="2"   >------------------+-----</font></div><div><font size="2"   >&nbsp;tmp_cache_info_1 | 209</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   ># 合并</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from merge_tp('tmp_cache_info_1', 10000::int2, 10);</font></div><div><font size="2"   >&nbsp;merge_tp&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   ># 合并, 所有数据已取完.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from merge_tp('tmp_cache_info_1', 10000::int2, 10);</font></div><div><font size="2"   >NOTICE: &nbsp;所有数据已合并完, 清除数据</font></div><div><font size="2"   >&nbsp;merge_tp&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>查看合并后的数据 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select value,count(*) from tp_cache_info group by value;</font></div><div><font size="2"   >&nbsp;value | count&nbsp;</font></div><div><font size="2"   >-------+-------</font></div><div><font size="2"   >&nbsp;test &nbsp;| &nbsp; &nbsp;99</font></div><div><font size="2"   >&nbsp;new1 &nbsp;| &nbsp;2201</font></div><div><font size="2"   >&nbsp;new &nbsp; | &nbsp; 700</font></div><div><font size="2"   >(3 rows)</font></div><p></p></pre></div><div><br></div></div><div>[小结]</div><div>1. 为什么要分批合并呢, 一次性搞定不就好了吗?</div><div>前面已经提到了, update是会造成表的膨胀的, 如果一次update很多记录的话, 那么膨胀系数就很大了, 因为在update的时候无法回收垃圾.</div><div>所以分批做的话, 数据库的autovacuum进程可以有效的回收tp_cache_info表的垃圾, 不会导致tp_cache_info表膨胀过大的现象.</div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="Realtime update in redis merge to PostgreSQL case - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>