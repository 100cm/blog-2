<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">gc buffer busy</h2>
	<h5 id="">2010-12-28 8:42:58&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201011287575822/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">前段时间有一套RAC系统偶然会出现负载异常升高的情况，后来查出来跟节点内部通信有关系，之后升级RAC系统的网卡驱动,其中一个节点重启,另一个节点通过rmmod,modprobe加载新的网卡驱动,导致混合连接,gc buffer busy频繁 : 
<pre>SQL&gt; select INST_ID,username,count(*) from gv$session group by inst_id,username order by INST_ID,username;<br><br>   INST_ID USERNAME                         COUNT(*)<br>---------- ------------------------------ ----------<br>         1 SKYCAC                                206<br>         1 SYS                                     7<br>         1                                        28<br>         2 EXP_MAN                                 1<br>         2 SKYCAC                                206<br>         2 SKYCACB                                30<br>         2 SYS                                     6<br>         2                                        28<br><br>with stats as (<br>select owner,object_name,statistic_name,value<br>from v$segment_statistics<br>where statistic_name = 'gc buffer busy'<br>order by value desc<br>)<br>select * from stats where rownum&lt;=10<br>/<br><br>OWNER        OBJECT_NAME                      STATISTIC_NAME                        VALUE<br>------------ -------------------------------- -------------------------------- ----------<br>SKYCAC       IDX_CAC_PLAYER_INFO              gc buffer busy                       283355<br>SKYCAC       IDX_CAC_PLAYER_INFO_NICK_NAME    gc buffer busy                        19832<br>SKYCAC       CAC_PLAYER_PRIZE                 gc buffer busy                        17370<br>SKYCAC       CAC_MONITOR_PLAYER               gc buffer busy                        10278<br>SKYCAC       CAC_GAME_ACCESS_RECORD           gc buffer busy                         8344<br>SKYCAC       PK_CAC_PLAYER_PRIZE              gc buffer busy                         8278<br>SKYCAC       CAC_ROOM                         gc buffer busy                         4016<br>SKYCAC       IDX_CAC_GAME_ACS_REC_TIME        gc buffer busy                         3300<br>SKYCAC       CAC_PLAYER_INFO                  gc buffer busy                         1198<br>SKYCAC       IDX_CAC_PLAYER_INFO_SKY_ID       gc buffer busy                          592                                                        592<br><br>处理掉2 SKYCAC                                206这部分连接的话,将恢复正常.<br><br><br>类似案例 : <br>The new application, recently installed to run against a RAC database (3<br>nodes, 64 bit linux, Oracle 10.2.0.5) is making heavy use of advanced<br>queueing. My problem is that the queue tables are incessant source of<br>contention, suffering from all kinds of buffer busy waits, both local and<br>global. If I check V$SEGMENT_STATISTIC with the following query,<br><br>with stats as (<br>select owner,object_name,statistic_name,value<br>from v$segment_statistics<br>where statistic_name = 'gc buffer busy'<br>order by value desc<br>)<br>select * from stats where rownum&lt;=10<br>/<br><br><br>The result looks like this:<br>OWNER           OBJECT_NAME                    STATISTIC_NAME<br>VALUE<br>--------------- ------------------------------ --------------------<br>----------<br>SYS             I_JOB_JOB                      gc buffer busy<br>30184683<br>SYS             JOB$                           gc buffer busy<br>10128719<br>ADBASE          PK_PENDING_ALERTS              gc buffer busy<br>7899852<br>SYS             I_JOB_NEXT                     gc buffer busy<br>5302448<br>ADBASE          PENDING_ALERTS                 gc buffer busy<br>5288135<br>LOCATIONSERVICE AQ$_MMSRES_MMSAGENT_TABLE_I    gc buffer busy<br>1082715<br>LOCATIONSERVICE MMSRES_MMSAGENT_TABLE          gc buffer busy<br>1055558<br>LOCATIONSERVICE SPEECH2TEXT_Q_TABLE            gc buffer busy<br>622833<br>LOCATIONSERVICE TASKS                          gc buffer busy<br>358430<br>LOCATIONSERVICE DQV2MIN_STARTDATE_IDX          gc buffer busy<br>256124<br><br>Now, everything that is not owned by SYS and is not index is a queue<br>table. The problem is systemic in nature, queue tables are by their very<br>nature the point of contention. What can be done to alleviate the<br>contention, short of restricting the queue to a single node only?<br>Every queue has retention time set to 0. Developers argue that setting<br>retry_delay to something &gt;0 would be extremely detrimental to performance.</pre>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="gc buffer busy - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>