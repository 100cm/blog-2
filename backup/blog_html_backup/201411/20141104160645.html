<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Dockerfile best practices</h2>
	<h5 id="">2014-11-04 16:06:45&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201410422325198/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>使用Dockerfile创建image前, 建议遵循的一些规则.</div><div>1. container是阅后即焚式的, 即运行一次后, 如果停掉了, 那么重新运行一个(全新的).&nbsp;</div><div>这点和虚拟机有点不一样, 虚拟机有自己的东西, 可以存在虚拟机内部, 如果虚拟机停掉, 再起来, 在虚拟机运行过程中的变更是会被保留的.</div><div>但是container不一样, container产生的变更都会"消失", 除非挂载外部的volume并将变更写入外部volume.&nbsp;</div><div>所以设计时应该考虑到container的特性, image只是一个只读的环境而已, container每次启动就是一个全新的环境.&nbsp;</div><div>为了打破这个问题, 例如要将container的数据持久化, 那么必须挂载外部volume来保存, 在container停止或rm后, 还可以启动其他的container来挂载这个volume.</div><div>例如数据库的数据文件, 建议外挂volume.</div><div>image我们可以只作为一个运行环境来设计, 例如数据库的image就只有数据库软件; WEB服务的image就只有web服务对应的软件; 而数据文件以及WEB站点文件夹都应该外挂的方式来访问. 这样的话, 当container rm后, 数据还在. 再启动container即可.</div><div><br></div><div>2. 使用,dockerignore文件排除建立image不需要的文件和文件夹.</div><div>或者使用空文件夹来放Dockerfile.</div><div><br></div><div>3. 在image中避免安装不必要的包, 例如database image不需要text edit包. 尽量使image小一点.</div><div><br></div><div>4. 每个container只允许一个进程, 如果一个服务有多个进程并且需要相互访问的话, 建议起多个container, 并使用container link来将各个进程连接起来. 方便container的重用.</div><div>参考</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201492710339762/"   >http://blog.163.com/digoal@126/blog/static/163877040201492710339762/</a></div><div><br></div><div>5. 简化Dockerfile层次, 提高可读性.</div><div><br></div><div>6. 当指令比较长时, 建议分行</div><div>例如</div><div><div>RUN apt-get update &amp;&amp; apt-get install -y \</div><div>&nbsp; bzr \</div><div>&nbsp; cvs \</div><div>&nbsp; git \</div><div>&nbsp; mercurial \</div><div>&nbsp; subversion</div></div><div><br></div><div>7. 使用镜像缓存注意, 在指令执行前, 判断是否有镜像缓存可以直接使用</div><div>例如 :&nbsp;</div><div>ADD a /</div><div>将检查a文件的checksum , 对比以前是否调用过同样的指令, 并且checksum一致.</div><div>以上指令将产生一个镜像, 但是在执行前, 可以检查docker server中是否已经存在该image, 那么就直接使用. 而不需要重新生成一个新的中间过程image.</div><div>--no-cache=true 表示不使用cache,</div><div><br></div><div>8. 指令使用建议&nbsp;</div><div>FROM</div><div><pre class="prettyprint"   ><p><font size="2"   >建议使用最小化的image.</font></p></pre></div><div><br></div><div>RUN</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >有依赖的指令, 最好使用&amp;&amp;写在一条指令中, 例如</font></div><div><font size="2"   >RUN apt-get update &amp;&amp; apt-get install -y package-bar package-foo package-baz</font></div><font size="2"   ><wbr></font><div><font size="2"   ><br></font></div><div><font size="2"   >比较长的指令, 最好分行, 并排序</font></div><div><div><font size="2"   >RUN apt-get update &amp;&amp; apt-get install -y \</font></div><div><font size="2"   >&nbsp; &nbsp; aufs-tools \</font></div><div><font size="2"   >&nbsp; &nbsp; automake \</font></div><div><font size="2"   >&nbsp; &nbsp; btrfs-tools \</font></div><div><font size="2"   >&nbsp; &nbsp; build-essential \</font></div><div><font size="2"   >&nbsp; &nbsp; curl \</font></div><div><font size="2"   >&nbsp; &nbsp; dpkg-sig \</font></div><div><font size="2"   >&nbsp; &nbsp; git \</font></div><div><font size="2"   >&nbsp; &nbsp; iptables \</font></div><div><font size="2"   >&nbsp; &nbsp; libapparmor-dev \</font></div><div><font size="2"   >&nbsp; &nbsp; libcap-dev \</font></div><div><font size="2"   >&nbsp; &nbsp; libsqlite3-dev \</font></div><div><font size="2"   >&nbsp; &nbsp; lxc=1.0* \</font></div><div><font size="2"   >&nbsp; &nbsp; mercurial \</font></div><div><font size="2"   >&nbsp; &nbsp; parallel \</font></div><div><font size="2"   >&nbsp; &nbsp; reprepro \</font></div><div><font size="2"   >&nbsp; &nbsp; ruby1.9.1 \</font></div><div><font size="2"   >&nbsp; &nbsp; ruby1.9.1-dev \</font></div><div><font size="2"   >&nbsp; &nbsp; s3cmd=1.1.0*</font></div></div><p></p></pre></div><div><br></div><div>ENV</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >可用于设置路径, 软件需要的特殊环境变量, 或者便于管理的环境变量等.</font></div><div><font size="2"   >使用docker inspect可查.</font></div><div><font size="2"   >For example, ENV PATH /usr/local/nginx/bin:$PATH will ensure that CMD [“nginx”] just works.</font></div><div><font size="2"   >The ENV instruction is also useful for providing required environment variables specific to services you wish to containerize, such as Postgres’s PGDATA.</font></div><div><div><font size="2"   >Lastly, ENV can also be used to set commonly used version numbers so that version bumps are easier to maintain, as seen in the following example:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >ENV PG_MAJOR 9.3</font></div><div><font size="2"   >ENV PG_VERSION 9.3.4</font></div><div><font size="2"   >RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</font></div><div><font size="2"   >ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</font></div></div><p></p></pre></div><div><br></div><div>ADD &amp; COPY</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >一般建议使用COPY, 如果要下载URL到image, 建议使用wget或curl ,然后解压.</font></div><div><div><font size="2"   >For example, you should avoid doing things like:</font></div><div><font size="2"   >ADD http://example.com/big.tar.xz /usr/src/things/</font></div><div><font size="2"   >RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</font></div><div><font size="2"   >RUN make -C /usr/src/things all</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >And instead, do something like:</font></div><div><font size="2"   >RUN mdkir -p /usr/src/things \</font></div><div><font size="2"   >&nbsp; &nbsp; &amp;&amp; curl -SL http://example.com/big.tar.gz \</font></div><div><font size="2"   >&nbsp; &nbsp; | tar -xJC /usr/src/things \</font></div><div><font size="2"   >&nbsp; &nbsp; &amp;&amp; make -C /usr/src/things all</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >不需要帮忙自动解压的地方, 建议使用COPY.</font></div><p></p></pre></div><div><br></div><div>ENTRYPOINT</div><div>一般建议在末尾加上exec "$@" 那么将传递给ENTRYPOINT脚本.</div><div>例如 postgresql的Dockerfile对应的ENTRYPOINT脚本 :&nbsp;</div><div><a target="_blank" rel="nofollow" href="https://github.com/docker-library/postgres"   >https://github.com/docker-library/postgres</a></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >#!/bin/bash</font></div><div><font size="2"   >set -e</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >if [ "$1" = 'postgres' ]; then</font></div><div><font size="2"   >&nbsp; &nbsp; chown -R postgres "$PGDATA"</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; if [ -z "$(ls -A "$PGDATA")" ]; then</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; gosu postgres initdb</font></div><div><font size="2"   >&nbsp; &nbsp; fi</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; exec gosu postgres "$@"</font></div><div><font size="2"   >fi</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >exec "$@"</font></div><p></p></pre></div><div><br></div><div>另一个例子 :&nbsp;</div><div><pre class="prettyprint"   ><p><font size="2"   >(for example, docker run -it mysql mysqld --some --flags will transparently run mysqld --some --flags after ENTRYPOINT runs initdb).</font></p></pre></div><div>mysql的ENTRYPOINT脚本 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >#!/bin/bash</font></div><div><font size="2"   >set -e</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >if [ -z "$(ls -A /var/lib/mysql)" -a "${1%_safe}" = 'mysqld' ]; then</font></div><div><font size="2"   ><span>	</span>if [ -z "$MYSQL_ROOT_PASSWORD" ]; then</font></div><div><font size="2"   ><span>		</span>echo &gt;&amp;2 'error: database is uninitialized and MYSQL_ROOT_PASSWORD not set'</font></div><div><font size="2"   ><span>		</span>echo &gt;&amp;2 ' &nbsp;Did you forget to add -e MYSQL_ROOT_PASSWORD=... ?'</font></div><div><font size="2"   ><span>		</span>exit 1</font></div><div><font size="2"   ><span>	</span>fi</font></div><div><span><font size="2"   >	</font></span></div><div><font size="2"   ><span>	</span>mysql_install_db --user=mysql --datadir=/var/lib/mysql</font></div><div><span><font size="2"   >	</font></span></div><div><font size="2"   ><span>	</span># These statements _must_ be on individual lines, and _must_ end with</font></div><div><font size="2"   ><span>	</span># semicolons (no line breaks or comments are permitted).</font></div><div><font size="2"   ><span>	</span># TODO proper SQL escaping on ALL the things D:</font></div><div><font size="2"   ><span>	</span>TEMP_FILE='/tmp/mysql-first-time.sql'</font></div><div><font size="2"   ><span>	</span>cat &gt; "$TEMP_FILE" &lt;&lt;-EOSQL</font></div><div><font size="2"   ><span>		</span>DELETE FROM mysql.user ;</font></div><div><font size="2"   ><span>		</span>CREATE USER 'root'@'%' IDENTIFIED BY '${MYSQL_ROOT_PASSWORD}' ;</font></div><div><font size="2"   ><span>		</span>GRANT ALL ON *.* TO 'root'@'%' WITH GRANT OPTION ;</font></div><div><font size="2"   ><span>		</span>DROP DATABASE IF EXISTS test ;</font></div><div><font size="2"   ><span>	</span>EOSQL</font></div><div><span><font size="2"   >	</font></span></div><div><font size="2"   ><span>	</span>if [ "$MYSQL_DATABASE" ]; then</font></div><div><font size="2"   ><span>		</span>echo "CREATE DATABASE IF NOT EXISTS $MYSQL_DATABASE ;" &gt;&gt; "$TEMP_FILE"</font></div><div><font size="2"   ><span>	</span>fi</font></div><div><span><font size="2"   >	</font></span></div><div><font size="2"   ><span>	</span>if [ "$MYSQL_USER" -a "$MYSQL_PASSWORD" ]; then</font></div><div><font size="2"   ><span>		</span>echo "CREATE USER '$MYSQL_USER'@'%' IDENTIFIED BY '$MYSQL_PASSWORD' ;" &gt;&gt; "$TEMP_FILE"</font></div><div><span><font size="2"   >		</font></span></div><div><font size="2"   ><span>		</span>if [ "$MYSQL_DATABASE" ]; then</font></div><div><font size="2"   ><span>			</span>echo "GRANT ALL ON $MYSQL_DATABASE.* TO '$MYSQL_USER'@'%' ;" &gt;&gt; "$TEMP_FILE"</font></div><div><font size="2"   ><span>		</span>fi</font></div><div><font size="2"   ><span>	</span>fi</font></div><div><span><font size="2"   >	</font></span></div><div><font size="2"   ><span>	</span>echo 'FLUSH PRIVILEGES ;' &gt;&gt; "$TEMP_FILE"</font></div><div><span><font size="2"   >	</font></span></div><div><font size="2"   ><span>	</span>set -- "$@" --init-file="$TEMP_FILE"</font></div><div><font size="2"   >fi</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >chown -R mysql:mysql /var/lib/mysql</font></div><div><font size="2"   >exec "$@"</font></div><p></p></pre></div><div><br></div><div>使用例子 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >COPY ./docker-entrypoint.sh /</font></div><div><font size="2"   >ENTRYPOINT ["/docker-entrypoint.sh"]</font></div><p></p></pre></div><div><br></div><div>VOLUME</div><div>The VOLUME instruction should be used to expose any database storage area, configuration storage, or files/folders created by your docker container. You are strongly encouraged to use VOLUME for any mutable and/or user-serviceable parts of your image.</div><div><br></div><div>USER</div><div>如果服务不需要使用root权限, 那么建议使用非root用户执行,</div><div>避免使用sudo(可能引起问题).</div><div>不要频繁的变更USER, 会带来更多的层级.&nbsp;</div><div><br></div><div>WORKDIR</div><div>改变工作目录可以使用WORKDIR, 或者在同一条指令中执行, 例如 :&nbsp;</div><div>RUN cd … &amp;&amp; do-something</div><div>但是为了提高可读性, 建议使用WORKDIR指令.</div><div><br></div><div>ONBUILD</div><div>ONBUILD一般用于后续会有其他image要基于该image来创建, 并需要依赖一些环境的情况(那么这些依赖的环境可以写在ONBUILD中安装执行)</div><div><div>ONBUILD is only useful for images that are going to be built FROM a given image. For example, you would use ONBUILD for a language stack image that builds arbitrary user software written in that language within the Dockerfile, as you can see in Ruby’s ONBUILD variants.</div><div><br></div><div>Images built from ONBUILD should get a separate tag, for example: ruby:1.9-onbuild or ruby:2.0-onbuild.</div><div><br></div><div>Be careful when putting ADD or COPY in ONBUILD. The “onbuild” image will fail catastrophically if the new build's context is missing the resource being added. Adding a separate tag, as recommended above, will help mitigate this by allowing the Dockerfile author to make a choice.</div></div><div>不建议在ONBUILD中使用ADD COPY.</div><div><br></div><div><br></div>[参考]<div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://docs.docker.com/articles/dockerfile_best-practices/"   >https://docs.docker.com/articles/dockerfile_best-practices/</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://github.com/docker-library/postgres"   >https://github.com/docker-library/postgres</a></div><div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="Dockerfile best practices - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a><br></div></div>
	</div>
</div>
</body>
</html>