<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL can auto close server process on server when client dead?</h2>
	<h5 id="">2014-11-10 17:24:34&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201410105419967/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>有朋友反映在客户端杀掉后, PostgreSQL服务端依旧在运行并占用100%CPU的情况.</div><div>这里来做一个测试 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select * from generate_series(1,10000000000);</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@150 backup]# ps -ewf|grep psql</font></div><div><font size="2"   >postgres 12578 12310 &nbsp;0 16:42 pts/1 &nbsp; &nbsp;00:00:00 psql -h 172.16.3.221 -p 5432 -U postgres postgres</font></div><div><font size="2"   >root &nbsp; &nbsp; 12580 &nbsp;8582 &nbsp;0 16:43 pts/0 &nbsp; &nbsp;00:00:00 grep psql</font></div><div><font size="2"   >[root@150 backup]# kill -9 12578</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >Killed</font></div><p></p></pre></div><div><br></div><div>服务端依旧存在</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; PID USER &nbsp; &nbsp; &nbsp;PR &nbsp;NI &nbsp;VIRT &nbsp;RES &nbsp;SHR S %CPU %MEM &nbsp; &nbsp;TIME+ &nbsp;COMMAND &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp;6710 postgres &nbsp;20 &nbsp; 0 2515m 7472 4536 R 99.3 &nbsp;0.0 &nbsp;23:38.37 postgres: postgres postgres 172.16.3.150(51130) SELECT &nbsp;</font></div><p></p></pre></div><div><br></div><div>甚至服务端的sock已经不在了, 服务端进程依旧存在.</div><div>碰到这种情况, 只能通过主动pg_terminate_backend, 或等SQL执行完.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# select * from pg_stat_activity ;</font></div><div><font size="2"   >-[ RECORD 1 ]----+----------------------------------------------</font></div><div><font size="2"   >datid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 12840</font></div><div><font size="2"   >datname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| postgres</font></div><div><font size="2"   >pid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 6710</font></div><div><font size="2"   >usesysid &nbsp; &nbsp; &nbsp; &nbsp; | 10</font></div><div><font size="2"   >usename &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| postgres</font></div><div><font size="2"   >application_name | psql</font></div><div><font size="2"   >client_addr &nbsp; &nbsp; &nbsp;| 172.16.3.150</font></div><div><font size="2"   >client_hostname &nbsp;|&nbsp;</font></div><div><font size="2"   >client_port &nbsp; &nbsp; &nbsp;| 51130</font></div><div><font size="2"   >backend_start &nbsp; &nbsp;| 2014-11-10 16:43:18.327109+08</font></div><div><font size="2"   >xact_start &nbsp; &nbsp; &nbsp; | 2014-11-10 16:43:29.070519+08</font></div><div><font size="2"   >query_start &nbsp; &nbsp; &nbsp;| 2014-11-10 16:43:29.070519+08</font></div><div><font size="2"   >state_change &nbsp; &nbsp; | 2014-11-10 16:43:29.070522+08</font></div><div><font size="2"   >waiting &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| f</font></div><div><font size="2"   >state &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| active</font></div><div><font size="2"   >query &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| select * from generate_series(1,10000000000);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres@db-172-16-3-221-&gt; netstat -anpo|grep 6710</font></div><div><font size="2"   >(Not all processes could be identified, non-owned process info</font></div><div><font size="2"   >&nbsp;will not be shown, you would have to be root to see it all.)</font></div></div><p></p></pre></div><div><br></div><div>从以下图来看, 客户端被KILL后, 客户端发出了主动关闭申请, 并等待服务端这边的应用程序关闭SOCKet.</div><div>但是服务端一直在运行<span style="line-height: 28px;"   >select * from generate_series(1,10000000000);, 并没有响应客户端关闭socket的请求.</span></div><div><span style="line-height: 28px;"   >当客户端socket到达fin timeout后, 客户端的内核主动关闭了socket,</span></div><div><span style="line-height: 28px;"   >服务端也在多次keepalive timeout后, kernel主动关闭了socket.</span></div><div><span style="line-height: 28px;"   >而服务端的postgresql backend process已经在运行</span><span style="font-family: monospace; line-height: 21px; white-space: pre;"   ><font size="3"   >select * from generate_series(1,10000000000); CPU占用100%</font></span></div><div>和TCP keep alive无关.</div><div><br></div><div><div><img title="PostgreSQL can active close server process on server when client dead? - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL can active close server process on server when client dead? - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/Ticgg04E-gMfwE6lE_10yw==/6608495891492636129.png"   ></div></div><div><div><img title="PostgreSQL can active close server process on server when client dead? - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL can active close server process on server when client dead? - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img0.ph.126.net/WvFF3fWSlBEv2a2mJbkMXw==/2887651786092135105.jpg"   ></div></div><div><br></div><div>换一个例子 :&nbsp;</div><div>直接从表输出数据, (全表扫描).</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# \dt+ t11</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List of relations</font></div><div><font size="2"   >&nbsp;Schema | Name | Type &nbsp;| &nbsp;Owner &nbsp; | Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+------+-------+----------+-------+-------------</font></div><div><font size="2"   >&nbsp;public | t11 &nbsp;| table | postgres | 10 GB |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# select * from t11;</font></div><div><font size="2"   >Killed</font></div></div><p></p></pre></div><div>杀掉后, 服务端立刻回收资源.</div><div>数据传输过程杀掉客户端进程, 服务端可以感知并迅速关闭资源.</div><div>说明服务端在不处理数据传输时, 并未监测SOCKET的状态, 如果有这个监测的话, 可以更快的释放资源.</div><div><br></div><div>这个监测任务可以交给postmaster进程,一个新的进程,或backend process线程来处理 这样的话在遇到本文第一个例子出现的情况时, 可以缩短关闭服务端process的时间.</div><div>在没有这项功能前, 我们可以在服务端主动监测和执行pg_terminate_backend;</div><div>例如 :&nbsp;</div><div>1. 当服务端的tcp端口状态变成close_wait后, 其实说明客户端已经主动关闭了SOCKET, 这时就可以执行<span style="line-height: 28px;"   >pg_terminate_backend杀服务端进程了.</span></div><div><span style="line-height: 28px;"   >2. 当服务端的tcp端口不存在时, 说明已经被内核主动关闭了, 也可以</span><span style="line-height: 28px;"   >执行</span><span style="line-height: 28px;"   >pg_terminate_backend杀服务端进程了.</span></div><div><span style="line-height: 28px;"   >注意不要错杀unix socket的连接.</span></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol"   >http://en.wikipedia.org/wiki/Transmission_Control_Protocol</a></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL can active close server process on server when client dead? - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>