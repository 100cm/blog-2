<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Dockerfile introduce</h2>
	<h5 id="">2014-11-04 14:22:03&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402014104113817237/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><span style="line-height: 28px;"   >使用Dockerfile创建image, 比使用container直接打包更灵活.</span></div><div><span style="line-height: 28px;"   >本文将介绍一下Dockerfile的用法, 使用Dockerfile建立image, 需要了解4部分的内容.</span></div><div><span style="line-height: 28px;"   >在docker库也可以找到很多Dockerfile的示例.</span></div><div><a target="_blank" rel="nofollow" href="https://github.com/docker-library"   >https://github.com/docker-library</a></div><div>使用docker inspect则可以查看image或container的内容, 里面有很多信息可以和制作image用到的Dockerfile对应.</div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >1. 上下文目录</span></div><div><span style="line-height: 28px;"   >首先要创建</span><span style="line-height: 28px;"   >上下文目录, 用于存放Dockerfile,&nbsp;</span>.dockerignore, 以及要传到image中的文件.</div><div><br></div><div>2. 文件</div><div>在上下文目录中, 包含几类文件<span style="line-height: 28px;"   >Dockerfile,&nbsp;</span><span style="line-height: 28px;"   >.dockerignore, 以及要传到image中的文件.</span></div><div><span style="line-height: 28px;"   >2.1 Dockerfile即用来制作image的一些指令集合.</span></div><div><span style="line-height: 28px;"   >2.2 .dockerignore即用来忽略上下文目录中包含的一些image用不到的文件, 在.dockerignore中的文件或目录, 在制作image时, 不会传送到docker server.</span></div><div><span style="line-height: 28px;"   >2.3 要传输到docker server的文件和目录都放在上下文目录中, (例如使用ADD, COPY时, 源文件必须在上下文目录中)</span></div><div><br></div><div>3. Dockerfile 的语法</div><div><div># Comment</div><div>INSTRUCTION arguments</div></div><div>注意第一条指令必须是FROM. 即基础镜像是哪个.</div><div><br></div><div>4. Dockerfile 指令集介绍</div><div>在Dockerfile文件中, 指令不区分大小写, 但是为了易读, 建议统一使用大写指令.</div><div><div>4.1 FROM</div><div>FROM &lt;image&gt;</div><div>Or</div><div>FROM &lt;image&gt;:&lt;tag&gt;</div></div><div>解释, 指定一个基础镜像, 用以制作本镜像. 如果image有多个tag, 但是未指定tag的话, 默认使用latest. (即最新的镜像)</div><div>例如,&nbsp;</div><div>FROM centos:centos6</div><div><br></div><div><div>4.2 MAINTAINER</div><div>MAINTAINER &lt;name&gt;</div></div><div><div style="line-height: 28px;"   >解释, 可用于告知该image的制作作者是谁.</div><div style="line-height: 28px;"   >例如,&nbsp;</div></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >MAINTAINER digoal@126.com</span></div><div style="line-height: 28px;"   ><br></div><div><div>4.3 RUN</div><div>RUN has 2 forms:</div><div>RUN &lt;command&gt; (the command is run in a shell - /bin/sh -c - shell form)</div><div>RUN ["executable", "param1", "param2"] (exec form)</div></div><div><div style="line-height: 28px;"   >解释, 在building过程中执行的命令, 可以写多条, 有两个格式, 分别表示在shell环境中执行, 或者直接执行.</div><div style="line-height: 28px;"   >例如,&nbsp;</div></div><div style="line-height: 28px;"   >RUN yum install -y postgresql</div><div style="line-height: 28px;"   >RUN ["/bin/bash", "-c", "yum install -y postgresql"]</div><div style="line-height: 28px;"   >注意, 当环境中没有shell环境时, 使用第一种格式会有问题, 必须使用第二种格式, 或者没有/bin/sh但是有其他shell环境的话, 也必须使用第二种格式.</div><div style="line-height: 28px;"   >环境变量只有在shell 中被替换, 所以必须使用shell格式或在exec格式中使用shell, 例如 :&nbsp;</div><div style="line-height: 28px;"   >RUN [ "sh", "-c", "echo", "$HOME" ]</div><div style="line-height: 28px;"   >RUN echo $HOME</div><div style="line-height: 28px;"   ><br></div><div><div>4.4 CMD</div><div>The CMD instruction has three forms:</div><div>CMD ["executable","param1","param2"] (exec form, this is the preferred form)</div><div>CMD ["param1","param2"] (as default parameters to ENTRYPOINT)</div><div>CMD command param1 param2 (shell form)</div></div><div><div style="line-height: 28px;"   >解释, CMD在Dockerfile中只需要使用一次, 如果写了多条, 那么只有最后一条生效. CMD不是在building时被调用的, 而是在docker run时自动调用的command, 并且会被docker run后面写的command覆盖. 可参考 :&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201410411715832/"   >http://blog.163.com/digoal@126/blog/static/163877040201410411715832/</a></div><div>CMD还可以和ENTRYPOINT结合使用, 当做ENTRYPOINT的传入参数.</div><div style="line-height: 28px;"   >例如,&nbsp;</div></div><div><div style="line-height: 28px;"   >FROM ubuntu</div><div style="line-height: 28px;"   >CMD echo "This is a test." | wc -</div><div style="line-height: 28px;"   ><br></div><div>CMD ["/usr/bin/wc","--help"]</div><div style="line-height: 28px;"   ><br></div></div><div><div>4.5 EXPOSE</div><div>EXPOSE &lt;port&gt; [&lt;port&gt;...]</div></div><div><div style="line-height: 28px;"   >解释, 用于container inter connection, 参考<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201492710339762/"   >http://blog.163.com/digoal@126/blog/static/163877040201492710339762/</a></div><div style="line-height: 28px;"   >指该image启动后的监听端口, 和-p或-P的功能不一样, EXPOSE仅仅用于container之间内部连接, 即自动创建端口对应的环境变量. 如果要将端口映射到宿主机还是需要使用-p或-P的.</div><div style="line-height: 28px;"   ><br></div></div><div><div>4.6 ENV</div><div>ENV &lt;key&gt; &lt;value&gt;</div></div><div><div style="line-height: 28px;"   >解释, 用于设置环境变量, 我们可以使用docker inspect查看当前image设置的环境变量, 同时可以在运行时覆盖已经设置的环境变量,&nbsp;docker run --env &lt;key&gt;=&lt;value&gt;</div></div><div style="line-height: 28px;"   ><br></div><div><div>4.7 ADD</div><div>ADD &lt;src&gt;... &lt;dest&gt;</div></div><div><div style="line-height: 28px;"   >解释, 用于将上下文目录中的文件或目录拷贝到image中, 同时还可以直接从URL下载文件并拷贝到image中, 注意, 如果文件是压缩文件的话(identity, gzip, bzip2 or xz), 会自动解压. 如果你不希望自动解压, 那么请使用COPY , 而不要使用ADD.</div><div style="line-height: 28px;"   >支持通配符.</div><div style="line-height: 28px;"   >例如,&nbsp;</div></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   >ADD hom* /mydir/ &nbsp; &nbsp; &nbsp; &nbsp;# adds all files starting with "hom"</div><div style="line-height: 28px;"   >ADD hom?.txt /mydir/ &nbsp; &nbsp;# ? is replaced with any single character</div><div style="line-height: 28px;"   ><br></div></div><div><div>4.8 COPY</div><div>COPY &lt;src&gt;... &lt;dest&gt;</div></div><div><div style="line-height: 28px;"   >解释, 与ADD略有不同(不解压, 不支持URL), 参考 :&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201410341236664/"   >http://blog.163.com/digoal@126/blog/static/163877040201410341236664/</a></div><div style="line-height: 28px;"   >例如,&nbsp;</div></div><div style="line-height: 28px;"   ><br></div><div><div>4.9 ENTRYPOINT</div><div>ENTRYPOINT has two forms:</div><div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >ENTRYPOINT ["executable", "param1", "param2"] (exec form, the preferred form)</span></div><div style="line-height: 28px;"   >ENTRYPOINT command param1 param2 (shell form)</div></div><div><div style="line-height: 28px;"   >解释, 在Dockerfile中只需要写一条ENTRYPOINT指令, 多条的话最后一条生效, 和CMD一样, 在run image的时候被调用, 在build image时不会调用. 但是与CMD略有不同, 不会被docker run的COMMAND部分覆盖, 参考 :&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201410411715832/"   >http://blog.163.com/digoal@126/blog/static/163877040201410411715832/</a></div><div style="line-height: 28px;"   >例如,&nbsp;</div></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   >COPY ./docker-entrypoint.sh /</div><div style="line-height: 28px;"   >ENTRYPOINT ["/docker-entrypoint.sh"]</div><div style="line-height: 28px;"   ><br></div></div></div><div><div>4.10 VOLUME</div><div>VOLUME ["/data"]</div></div><div><div style="line-height: 28px;"   >解释, 创建卷, 一般可用于存储数据库数据文件, 配置文件等container特定的文件.</div><div style="line-height: 28px;"   >例如,&nbsp;</div></div><div><span style="line-height: 28px;"   >VOLUME ["/data"]</span></div><div><br></div><div><div>4.11 USER</div><div>USER daemon</div></div><div><div style="line-height: 28px;"   >解释, 设置后续的RUN指令执行的用户.</div><div style="line-height: 28px;"   >例如,&nbsp;</div></div><div style="line-height: 28px;"   >RUN useradd postgres</div><div style="line-height: 28px;"   >USER postgres</div><div style="line-height: 28px;"   >RUN pg_ctl start</div><div><br></div><div><div>4.12 WORKDIR</div><div>WORKDIR /path/to/workdir</div></div><div><div style="line-height: 28px;"   >解释, 改变当前的工作目录, 因为RUN并不会改变工作目录, 所以要改变工作目录时, 可以使用 WORKDIR或者使用一行指令.</div><div style="line-height: 28px;"   >例如,&nbsp;</div></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   >ENV DIRPATH /path</div><div style="line-height: 28px;"   >WORKDIR $DIRPATH/$DIRNAME</div><div style="line-height: 28px;"   ><br></div></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   >WORKDIR /a</div><div style="line-height: 28px;"   >WORKDIR b</div><div style="line-height: 28px;"   >WORKDIR c</div><div style="line-height: 28px;"   >RUN pwd</div><div style="line-height: 28px;"   >或者</div><div style="line-height: 28px;"   >RUN cd /a/b/c &amp;&amp; pwd</div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >返回/a/b/c</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><br></span></div><div style="line-height: 28px;"   >但是</div><div style="line-height: 28px;"   >RUN cd /a/b/c</div><div style="line-height: 28px;"   >RUN pwd&nbsp;</div><div style="line-height: 28px;"   >无法得到/a/b/c</div></div><div><br></div><div><div>4.13 ONBUILD</div><div>ONBUILD [INSTRUCTION]</div></div><div><div style="line-height: 28px;"   >解释, ONBUILD中的指令不会被触发, 而是在其他image使用该image时, 自动在FROM后面加上这些 ONBUILD后的指令, 如果这些指令执行失败的话, 以该image创建其他image的操作也会失败.</div><div style="line-height: 28px;"   >ONBUILD不会被继承, 即其他image使用该image创建的话, 不会继承该image的ONBUILD指令.</div><div style="line-height: 28px;"   >例如,&nbsp;</div></div><div><div>ONBUILD ADD . /app/src</div><div>ONBUILD RUN /usr/local/bin/python-build --dir /app/src</div></div><div>使用该image创建其他image时, 会自动在FROM后加上</div><div><div style="line-height: 28px;"   >ADD . /app/src</div><div style="line-height: 28px;"   >RUN /usr/local/bin/python-build --dir /app/src</div></div><wbr><div><br></div>[参考]<div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://docs.docker.com/reference/builder/"   >https://docs.docker.com/reference/builder/</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://docs.docker.com/articles/dockerfile_best-practices/"   >https://docs.docker.com/articles/dockerfile_best-practices/</a></div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://github.com/docker-library"   >https://github.com/docker-library</a></div><div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="Dockerfile introduce - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a><br></div></div>
	</div>
</div>
</body>
</html>