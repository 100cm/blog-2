<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL limit 1 tuple output influenced by access method</h2>
	<h5 id="">2014-03-20 14:51:29&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020142202114143/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">如何输出表的第一行, 这个SQL怎么写, 今天群里有朋友问到这个问题.<div>首先第一行是什么意思呢? 可以有两种理解.</div><div>1. 物理存储位置的第一行, 也就是ctid最小的记录.</div><div>2. 第一行插入的数据, 也就是最早插入的一条记录.<br><div>我们这里分两种情况来说明如何获得想要的第一行.</div><div>1.&nbsp;<span style="line-height: 28px;"   >物理存储位置的第一行, 也就是ctid最小的记录.&nbsp;</span></div><div><span style="line-height: 28px;"   >最简单的方法是select * from tbl order by ctid limit 1;</span></div><div><span style="line-height: 28px;"   >但是这样显然会全表扫描, 然后按照ctid排序, 然后再取第一行, 表大的话, 开销极大, 例如 :&nbsp;</span></div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >digoal=# create table test(id int, info text, crt_time timestamp);</font></div><div style="line-height: 28px;"   ><font size="2"   >CREATE TABLE</font></div><div style="line-height: 28px;"   ><font size="2"   >digoal=# insert into test select generate_series(1,1000000),md5(random()::text),clock_timestamp();</font></div><div style="line-height: 28px;"   ><font size="2"   >INSERT 0 1000000</font></div><div style="line-height: 28px;"   ><font size="2"   >digoal=# explain analyze select * from test order by ctid limit 1;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >-----------------------------------------------------------------------------------------------------------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;Limit &nbsp;(cost=17326.00..17326.00 rows=1 width=51) (actual time=706.818..706.819 rows=1 loops=1)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Sort &nbsp;(cost=17326.00..19826.00 rows=1000000 width=51) (actual time=706.806..706.806 rows=1 loops=1)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Key: ctid</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Method: top-N heapsort &nbsp;Memory: 25kB</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..12326.00 rows=1000000 width=51) (actual time=0.040..292.568 rows=1000000 loops=1)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;Total runtime: 706.884 ms</font></div><div style="line-height: 28px;"   ><font size="2"   >(6 rows)</font></div><div style="line-height: 28px;"   ><div><font size="2"   >digoal=# select ctid,* from test order by ctid limit 1;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------+----+----------------------------------+---------------------------</font></div><div><font size="2"   >&nbsp;(0,1) | &nbsp;1 | 981e4fafc8a787e813a4560e933f955a | 2014-03-20 14:17:15.25116</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div style="line-height: 28px;"   >其实, 使用全表扫描的话, heap tuple get的方法就是从第一个数据块开始的, 所以这里完全没有必要order by ctid后limit 1.</div><div style="line-height: 28px;"   >得到的数据也是按数据块顺序扫描的第一条有效记录.</div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select ctid,* from test limit 1;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------+----+----------------------------------+---------------------------</font></div><div><font size="2"   >&nbsp;(0,1) | &nbsp;1 | 981e4fafc8a787e813a4560e933f955a | 2014-03-20 14:17:15.25116</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div style="line-height: 28px;"   >例如我们删掉前面的数据, 再次使用limit 1进行取数, 只要执行计划是全表扫描, 那么<span style="line-height: 28px;"   >得到的数据也是按数据块顺序扫描的第一条有效记录.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# delete from test where id&lt;90000;</font></div><div><font size="2"   >DELETE 89999</font></div><div><font size="2"   >digoal=# select ctid,* from test limit 1;</font></div><div><font size="2"   >&nbsp; &nbsp;ctid &nbsp; &nbsp;| &nbsp;id &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------+-------+----------------------------------+----------------------------</font></div><div><font size="2"   >&nbsp;(209,130) | 90000 | 934649c297a1c475c442385cb5ae8602 | 2014-03-20 14:17:15.888583</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div>我们这里提到了执行计划, 因为扫描节点是seq scan, 所以要去了解对应的扫描方法.</div><div>因此得知根据seq scan limit 1这里得到的肯定是第一条物理行. 省去了order by ctid limit 1 的开销.</div><div>但是, 如果是带where条件的查询, 要取第一个物理行就需要斟酌了, 因为可能走索引扫描.&nbsp;</div><div>我们重新创建一个表来测试这个场景, ID无序插入几条记录.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create table test(id int, info text, crt_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# insert into test values (9,'test',now());</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test values (7,'test',now());</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test values (10,'test',now());</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test values (4,'test',now());</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test values (1,'test',now());</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test values (100,'test',now());</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test values (10,'test',now());</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test values (19,'test',now());</font></div><div><font size="2"   >INSERT 0 1</font></div></div><div><div><font size="2"   >digoal=# select ctid,* from test;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id &nbsp;| info | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------+-----+------+----------------------------</font></div><div><font size="2"   >&nbsp;(0,1) | &nbsp; 9 | test | 2014-03-20 14:25:10.940698</font></div><div><font size="2"   >&nbsp;(0,2) | &nbsp; 7 | test | 2014-03-20 14:25:13.966694</font></div><div><font size="2"   >&nbsp;(0,3) | &nbsp;10 | test | 2014-03-20 14:25:16.991702</font></div><div><font size="2"   >&nbsp;(0,4) | &nbsp; 4 | test | 2014-03-20 14:25:22.027702</font></div><div><font size="2"   >&nbsp;(0,5) | &nbsp; 1 | test | 2014-03-20 14:25:24.634616</font></div><div><font size="2"   >&nbsp;(0,6) | 100 | test | 2014-03-20 14:25:27.908709</font></div><div><font size="2"   >&nbsp;(0,7) | &nbsp;10 | test | 2014-03-20 14:25:31.186769</font></div><div><font size="2"   >&nbsp;(0,8) | &nbsp;19 | test | 2014-03-20 14:25:33.597672</font></div><div><font size="2"   >(8 rows)</font></div></div><p></p></pre></div><div>在ID列创建索引</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create index idx_test_1 on test(id);</font></div><div><font size="2"   >CREATE INDEX</font></div></div><div><div><font size="2"   >digoal=# insert into test select generate_series(1000,2000),'test',clock_timestamp();</font></div><div><font size="2"   >INSERT 0 1001</font></div></div><p></p></pre></div><div>ID列过滤条件进行查询, 走索引的情况下, limit 1取到的是索引定义顺序的第一条记录.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain select * from test where id&lt;100 limit 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Limit &nbsp;(cost=0.15..0.83 rows=1 width=17)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test_1 on test &nbsp;(cost=0.15..2.20 rows=3 width=17)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id &lt; 100)</font></div><div><font size="2"   >(3 rows)</font></div><p></p></pre></div><div>这条记录的ID=1, 符合&lt;100的条件, 并且在索引顺序中排在第一位, 物理行为(0,5).</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select ctid,* from test where id&lt;100 limit 1;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | info | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------+----+------+----------------------------</font></div><div><font size="2"   >&nbsp;(0,5) | &nbsp;1 | test | 2014-03-20 14:25:24.634616</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>如果关闭索引扫描, 将走位图排序扫描.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# set enable_indexscan=off;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain select * from test where id&lt;100 limit 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Limit &nbsp;(cost=1.17..1.85 rows=1 width=17)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Heap Scan on test &nbsp;(cost=1.17..3.21 rows=3 width=17)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Recheck Cond: (id &lt; 100)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_test_1 &nbsp;(cost=0.00..1.17 rows=3 width=0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id &lt; 100)</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div>位图排序扫描的话, 将符合条件的ctid排序后取tuple, 因此本例得到的是(0,1)的记录.&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select ctid,* from test where id&lt;100 limit 1;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | info | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------+----+------+----------------------------</font></div><div><font size="2"   >&nbsp;(0,1) | &nbsp;9 | test | 2014-03-20 14:25:10.940698</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div>关闭位图扫描的话, 走全表扫描, 得到的是第一个符合条件的数据块的记录, 和位图扫描结果一致.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# set enable_bitmapscan=off;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain select * from test where id&lt;100 limit 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Limit &nbsp;(cost=0.00..4.87 rows=1 width=17)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..14.61 rows=3 width=17)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (id &lt; 100)</font></div><div><font size="2"   >(3 rows)</font></div><div><font size="2"   >digoal=# select ctid,* from test where id&lt;100 limit 1;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | info | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------+----+------+----------------------------</font></div><div><font size="2"   >&nbsp;(0,1) | &nbsp;9 | test | 2014-03-20 14:25:10.940698</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>因此在带条件的情况下, 要得到第一条物理记录, 可以选择位图扫描或者全表扫描的方法, 效果是一样的.</div><div><br></div><div><span style="line-height: 28px;"   >2. 第一行插入的数据, 也就是最早插入的一条记录.</span></div><div>这个就不能使用ctid来判断了, 可以考虑使用xid或者增加一个时间字段存储数据插入时间来判断.</div><div>使用xid来判断的话, 取xmin最小的, 但是需要注意一点, 数据库的vacuum freeze会把这部分信息擦除, 变成FrozenXID.</div><div>例如在未擦除前, xmin存储了这条记录插入时的事务ID. 越小的话, 说明记录越早被插入.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select xmin,* from test limit 10;</font></div><div><font size="2"   >&nbsp; &nbsp; xmin &nbsp; &nbsp;| &nbsp;id &nbsp;| info | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------+------+------+----------------------------</font></div><div><font size="2"   >&nbsp;3268512800 | &nbsp; &nbsp;9 | test | 2014-03-20 14:25:10.940698</font></div><div><font size="2"   >&nbsp;3268512801 | &nbsp; &nbsp;7 | test | 2014-03-20 14:25:13.966694</font></div><div><font size="2"   >&nbsp;3268512802 | &nbsp; 10 | test | 2014-03-20 14:25:16.991702</font></div><div><font size="2"   >&nbsp;3268512803 | &nbsp; &nbsp;4 | test | 2014-03-20 14:25:22.027702</font></div><div><font size="2"   >&nbsp;3268512804 | &nbsp; &nbsp;1 | test | 2014-03-20 14:25:24.634616</font></div><div><font size="2"   >&nbsp;3268512805 | &nbsp;100 | test | 2014-03-20 14:25:27.908709</font></div><div><font size="2"   >&nbsp;3268512806 | &nbsp; 10 | test | 2014-03-20 14:25:31.186769</font></div><div><font size="2"   >&nbsp;3268512807 | &nbsp; 19 | test | 2014-03-20 14:25:33.597672</font></div><div><font size="2"   >&nbsp;3268512809 | 1000 | test | 2014-03-20 14:26:55.513254</font></div><div><font size="2"   >&nbsp;3268512809 | 1001 | test | 2014-03-20 14:26:55.51336</font></div><div><font size="2"   >(10 rows)</font></div><p></p></pre></div><div>取出时序上的第一条记录 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select xmin,* from test order by xmin::text::int8 limit 1;</font></div><div><font size="2"   >&nbsp; &nbsp; xmin &nbsp; &nbsp;| id | info | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------+----+------+----------------------------</font></div><div><font size="2"   >&nbsp;3268512800 | &nbsp;9 | test | 2014-03-20 14:25:10.940698</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>那么如果被擦除了的话, 这个方法就无效了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# vacuum freeze test;</font></div><div><font size="2"   >VACUUM</font></div><div><span style="line-height: 28px;"   ><font size="2"   >digoal=# select xmin,* from test limit 10;</font></span></div><div><font size="2"   >&nbsp;xmin | &nbsp;id &nbsp;| info | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------+------+------+----------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; 2 | &nbsp; &nbsp;9 | test | 2014-03-20 14:25:10.940698</font></div><div><font size="2"   >&nbsp; &nbsp; 2 | &nbsp; &nbsp;7 | test | 2014-03-20 14:25:13.966694</font></div><div><font size="2"   >&nbsp; &nbsp; 2 | &nbsp; 10 | test | 2014-03-20 14:25:16.991702</font></div><div><font size="2"   >&nbsp; &nbsp; 2 | &nbsp; &nbsp;4 | test | 2014-03-20 14:25:22.027702</font></div><div><font size="2"   >&nbsp; &nbsp; 2 | &nbsp; &nbsp;1 | test | 2014-03-20 14:25:24.634616</font></div><div><font size="2"   >&nbsp; &nbsp; 2 | &nbsp;100 | test | 2014-03-20 14:25:27.908709</font></div><div><font size="2"   >&nbsp; &nbsp; 2 | &nbsp; 10 | test | 2014-03-20 14:25:31.186769</font></div><div><font size="2"   >&nbsp; &nbsp; 2 | &nbsp; 19 | test | 2014-03-20 14:25:33.597672</font></div><div><font size="2"   >&nbsp; &nbsp; 2 | 1000 | test | 2014-03-20 14:26:55.513254</font></div><div><font size="2"   >&nbsp; &nbsp; 2 | 1001 | test | 2014-03-20 14:26:55.51336</font></div><div><font size="2"   >(10 rows)</font></div><p></p></pre></div><div>这个时候需要使用crt_time字段, 为了加快速度, 可以在这个列加索引.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select xmin,* from test order by crt_time limit 1;</font></div><div><font size="2"   >&nbsp;xmin | id | info | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------+----+------+----------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; 2 | &nbsp;9 | test | 2014-03-20 14:25:10.940698</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>正因为数据库各种访问方法的固定性, 所以如果要随机的取数, 就必须依赖某些字段来加速.</div><div>以下是我以前写的一篇文章, 管理离散数据的取法的优化.</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201111292628555/"   >http://blog.163.com/digoal@126/blog/static/163877040201111292628555/</a></div><div><br></div><div>[参考]</div><div>1.&nbsp;src/backend/access/heap</div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/storage-page-layout.html"   >http://www.postgresql.org/docs/9.3/static/storage-page-layout.html</a></div><div>3.&nbsp;src/include/storage/bufpage.h</div></div>4.&nbsp;src/backend/access/heap/heapam.c</div>
	</div>
</div>
</body>
</html>