<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL query in function tuning case</h2>
	<h5 id="">2014-03-24 15:17:32&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201422425556130/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">帮一位朋友那边处理的一个优化案例.<wbr><div>情形大概是这样的, 一个函数, 调用比较慢.</div><div>一般的做法是在函数内的每个SQL前后加一个raise notice, 输出当前的clock_timestamp, 这样能够得到慢在处理哪个SQL上.</div><div>还有一种方法是使用pg_stat_statements 插件, 这个插件会记录包括函数本身在内, 以及函数内的所有SQL的调用时间.</div><div>因为是个测试库, 而且这个函数非常长, 还有大量的循环, 使用raise notice来输出时间不太合理, 看都看不过来.</div><div>所以我这里使用了pg_stat_statements来分析这个函数到底慢在什么地方.</div><div>函数内容涉及隐私就不列出来了.</div><div>我这里只说一下优化方法和过程.</div><div>1. 配置pg_stat_statements</div><div>2. 调用pg_stat_statements_reset()清除统计信息.</div><div>3. 调用这个执行较慢的函数.</div><div>4. 查看pg_stat_statements得到这个函数以及所有函数内部SQL的执行时间, 调用次数.</div><pre class="prettyprint"   ><p></p><div><font size="2"   >select query,calls,total_time,total_time/calls from pg_stat_statements where userid=(select oid from pg_roles where rolname='game') and dbid=(select oid from pg_database where datname='report') order by 3 desc limit 10;</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >total_time最大的就是罪魁祸首.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >query &nbsp; &nbsp; &nbsp;| select aid,server,chan_id as channel,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sum(1),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sum( (case when date_part('epoch',(v_t-p.recv_dt)) between 0 and 5*60 then 1 else 0 end) ),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;max(xid), max(recv_dt)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;from (select t.gusr_id, t.xid,t.aid,t.server,b.chan_id,t.recv_dt, row_number() over (partition by t.gusr_id order by t.recv_dt) as rn from t1 as t, t2 b where t.sess_seq=b.xid and (date_part('epoch',(v_t-t.recv_dt)) between 0 and v_minute*60+5*60) ) as p&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; where p.rn=1 &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; group by aid,server,channel</font></div><div><font size="2"   >calls &nbsp; &nbsp; &nbsp;| 21</font></div><div><font size="2"   >total_time | 23953.651</font></div><div><font size="2"   >?column? &nbsp; | 1140.65004761905</font></div><p></p></pre></div><div>把这个SQL拿出来, 看看执行计划, 以及real time.</div><pre class="prettyprint"   ><p></p><div><font size="2"   >explain (analyze,verbose) SQL;</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >从real time来看, 大部分时间来自t表的分表全表扫描 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on t1 t &nbsp;(cost=0.00..21.10 rows=2 width=40)&nbsp;</font></div><div><font size="2"   >(actual time=73.495..73.495 rows=0 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: t.gusr_id, t.xid, t.aid, t.server, t.recv_dt, t.sess_seq</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: ((date_part('epoch'::text, (('2014-02-05 18:19:55'::timestamp without time zone</font></div><div><font size="2"   >)::timestamp with time zone - t.recv_dt)) &gt;= 0::double precision) AND (date_part('epoch'::text, (('2014-02-05 18:19:55'::timestamp w</font></div><div><font size="2"   >ithout time zone)::timestamp with time zone - t.recv_dt)) &lt;= 1440::double precision))</font></div></div><div><font size="2"   >..&nbsp;</font></div><p></p></pre></div><div>大约有几时个这样的分表, 累计开销占用了总开销的大部分, 1.5秒左右.</div><div>这个表在recv_dt 字段有索引, 但是因为SQL写法的关系, 没有使用这个索引.</div><div>把SQL语句的<span style="line-height: 28px;"   >date_part('epoch',(v_t-t.recv_dt)) between 0 and v_minute*60+5*60</span><span style="line-height: 28px;"   >部分优化成如下 :&nbsp;</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 28px;"   >v_t</span>&nbsp;&gt;= t.recv_dt and&nbsp;<span style="line-height: 28px;"   >v_t</span>-(10*60+5*60||' sec')::interval &lt;= t.recv_dt</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >修改后这个查询走recv_dt索引, 时间降到50毫秒左右.</span></div><div>使用原来的写法不走索引 , 原因很简单, 因为优化器不会帮你改成优化后的写法, 所以SQL的写法是特别需要注意的, 不要图省事.</div><br><div>如果可以调整函数内容的话, 可以在函数中加入raise notice '%', clock_timestamp();</div><div>每执行一次SQL, 输出一下时间. 以此来判断SQL的执行时间.</div></div>
	</div>
</div>
</body>
</html>