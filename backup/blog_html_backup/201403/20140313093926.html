<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL Why IndexOnlyScan startup_cost > 0 and bitmap index scan startup_cost=0 ?</h2>
	<h5 id="">2014-03-13 9:39:26&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201421392811622/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">在查看explain输出时, 每个节点的成本部分的输出包含两个部分.<wbr><div>一个是启动成本也叫startup_cost, 另一个是总的成本, 包含该节点的启动成本以及输出所有行的成本也叫total_cost.</div><div>索引扫描的启动成本怎么计算的可以参考src/backend/utils/adt/selfuncs.c</div><div>例如btree索引访问的成本计算通过<span style="line-height: 28px;"   >btcostestimate来计算.</span></div><div><pre class="prettyprint"   ><div><div><font size="2"   >digoal=# select amcostestimate,amname from pg_am;</font></div><div><font size="2"   >&nbsp; amcostestimate &nbsp;| amname&nbsp;</font></div><div><font size="2"   >------------------+--------</font></div><div><font size="2"   >&nbsp;btcostestimate &nbsp; | btree</font></div><div><font size="2"   >&nbsp;hashcostestimate | hash</font></div><div><font size="2"   >&nbsp;gistcostestimate | gist</font></div><div><font size="2"   >&nbsp;gincostestimate &nbsp;| gin</font></div><div><font size="2"   >&nbsp;spgcostestimate &nbsp;| spgist</font></div><div><font size="2"   >(5 rows)</font></div></div><div><div><font size="2"   >digoal=# \sf+ btcostestimate</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CREATE OR REPLACE FUNCTION pg_catalog.btcostestimate(internal, internal, internal, internal, internal, internal, internal)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RETURNS void</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LANGUAGE internal</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STRICT</font></div><div><font size="2"   >1 &nbsp; &nbsp; &nbsp; AS $function$btcostestimate$function$</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >启动成本(</span><span style="line-height: 28px;"   >indexStartupCost):</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Add a CPU-cost component to represent the costs of initial btree</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* descent. &nbsp;We don't charge any I/O cost for touching upper btree levels,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* since they tend to stay in cache, but we still have to do about log2(N)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* comparisons to descend a btree of N leaf tuples. &nbsp;We charge one</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* cpu_operator_cost per comparison.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If there are ScalarArrayOpExprs, charge this once per SA scan. &nbsp;The</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ones after the first one are not startup cost so far as the overall</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* plan is concerned, so add them only to "total" cost.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (index-&gt;tuples &gt; 1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* avoid computing log(0) */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; descentCost = ceil(log(index-&gt;tuples) / log(2.0)) * cpu_operator_cost;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; costs.indexStartupCost += descentCost;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; costs.indexTotalCost += costs.num_sa_scans * descentCost;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Even though we're not charging I/O cost for touching upper btree pages,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* it's still reasonable to charge some CPU cost per page descended</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* through. &nbsp;Moreover, if we had no such charge at all, bloated indexes</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* would appear to have the same search cost as unbloated ones, at least</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* in cases where only a single leaf page is expected to be visited. &nbsp;This</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* cost is somewhat arbitrarily set at 50x cpu_operator_cost per page</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* touched. &nbsp;The number of such pages is btree tree height plus one (ie,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we charge for the leaf page too). &nbsp;As above, charge once per SA scan.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; descentCost = (index-&gt;tree_height + 1) * 50.0 * cpu_operator_cost;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; costs.indexStartupCost += descentCost;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; costs.indexTotalCost += costs.num_sa_scans * descentCost;</font></div></pre></div><div>获得btree索引root页的heigh或level.</div><div>src/backend/access/nbtree/nbtpage.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;_bt_getrootheight() -- Get the height of the btree search tree.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;We return the level (counting from zero) of the current fast root.</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This represents the number of tree levels we'd have to descend through</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;to start any btree index search.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This is used by the planner for cost-estimation purposes. &nbsp;Since it's</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;only an estimate, slightly-stale data is fine, hence we don't worry</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;about updating previously cached data.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >int</font></div><div><font size="2"   >_bt_getrootheight(Relation rel)</font></div><p></p></pre></div><div><br></div><div>实际例子 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create table t11(id int primary key, info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# insert into t11 select generate_series(1,100000),'test';</font></div><div><font size="2"   >INSERT 0 100000</font></div><div><font size="2"   >digoal=# explain select * from t11 where id=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >--------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using t11_pkey on t11 &nbsp;(cost=0.29..4.31 rows=1 width=9) &nbsp;-- 启动成本是0.29, 因为输出第一行前需要先扫描索引. 因为实际的行是从heap page输出的. </font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (id = 1)</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   >btree节点的startup_cost计算方法 : </font></div><div><font size="2"   >digoal=# select reltuples from pg_class where relname='t11_pkey';<br> reltuples <br>-----------<br>    100000<br>(1 row)</font></div><div><font size="2"   >digoal=# show cpu_operator_cost;<br> cpu_operator_cost <br>-------------------<br> 0.0025<br>(1 row)</font></div><div><font size="2"   >digoal=# select (log(100000)/log(2.0))*0.0025;<br>     ?column?      <br>-------------------<br> 0.041524101186092<br>(1 row)<br>digoal=# create extension pageinspect;<br>CREATE EXTENSION<br>digoal=# SELECT * FROM bt_metap('t11_pkey');<br> magic  | version | root | level | fastroot | fastlevel <br>--------+---------+------+-------+----------+-----------<br> 340322 |       2 |    3 |     1 |        3 |         1<br>(1 row)<br>digoal=# select (1+1)*50*0.0025;<br> ?column? <br>----------<br>   0.2500<br>(1 row)<br>digoal=# select 0.041524101186092+0.2500;<br>     ?column?      <br>-------------------<br> 0.291524101186092<br>(1 row)</font></div><div><br></div><div><font size="2"   >digoal=# explain select id from t11 where id=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Only Scan using t11_pkey on t11 &nbsp;(cost=0.29..4.31 rows=1 width=4) &nbsp;-- 计算方法同上, 但是实际上index only scan比index scan慢. 后面看原因</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (id = 1)</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# set enable_indexscan=off;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain select id from t11 where id=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Bitmap Heap Scan on t11 &nbsp;(cost=2.30..4.31 rows=1 width=4) &nbsp;-- 这里的启动成本包含了所有子节点的成本.&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp;Recheck Cond: (id = 1)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on t11_pkey &nbsp;(cost=0.00..2.30 rows=1 width=0) &nbsp;-- bitmap index scan节点的启动成本被算到bitmap heap scan上了, 所以在bitmap index scan节点不显示这部分开销, TomLane对这点的解释见末尾.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = 1)</font></div><div><font size="2"   >(4 rows)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# set enable_bitmapscan=off;</font></div><div><span style="line-height: 28px;"   ><font size="2"   >SET</font></span></div><div><font size="2"   >digoal=# explain select id from t11 where id=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on t11 &nbsp;(cost=0.00..1385.00 rows=1 width=4) &nbsp;-- 全表扫描不计算启动成本, 因为扫描的是heap page同时也是直接从heap page输出.</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"   >(2 rows)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >我们看看为什么index only scan比index scan更慢.</font></div><div><div><font size="2"   >digoal=# explain (analyze,verbose,costs,buffers,timing) select * from t11 where id&lt;10000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using t11_pkey on public.t11 &nbsp;(cost=0.29..200.78 rows=9799 width=9) (actual time=0.074..3.530 rows=9999 loops=1) &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (t11.id &lt; 10000)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=22</font></div><div><font size="2"   >&nbsp;Total runtime: 4.677 ms</font></div><div><font size="2"   >(5 rows)</font></div></div><div><font size="2"   >从结果看index only scan实际执行时间更长一点点.</font></div><div><div><font size="2"   >digoal=# explain (analyze,verbose,costs,buffers,timing) select id from t11 where id&lt;10000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Only Scan using t11_pkey on public.t11 &nbsp;(cost=0.29..204.20 rows=9995 width=4) (actual time=0.088..3.623 rows=9999 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (t11.id &lt; 10000)</font></div><div><font size="2"   >&nbsp; &nbsp;Heap Fetches: 9999 &nbsp;-- 区别就在这里, 在没有vm文件之前, 需要fetch所有的heap page拿到行的版本信息.</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=22</font></div><div><font size="2"   >&nbsp;Total runtime: 4.748 ms</font></div><div><font size="2"   >(6 rows)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# vacuum ANALYZE t11;</font></div><div><font size="2"   >VACUUM</font></div><div><font size="2"   >digoal=# explain (analyze,verbose,costs,buffers,timing) select id from t11 where id&lt;10000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Only Scan using t11_pkey on public.t11 &nbsp;(cost=0.29..191.64 rows=10020 width=4) (actual time=0.088..2.597 rows=9999 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (t11.id &lt; 10000)</font></div><div><font size="2"   >&nbsp; &nbsp;Heap Fetches: 0 &nbsp;-- 使用vacuum analyze生成vm文件之后, 通过查看vm得到所有的页都是可见的, 所以不需要fetch heap后取得行版本信息.但是多了逻辑, 时间还是比index scan更长.</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=9</font></div><div><font size="2"   >&nbsp;Total runtime: 3.634 ms</font></div><div><font size="2"   >(6 rows)</font></div></div><p></p></pre></div><div><br></div><div><div style="line-height: 120%; direction: ltr; vertical-align: baseline; margin-bottom: 0pt; text-indent: -0.38in; margin-top: 3.36pt; unicode-bidi: embed; margin-left: 0.38in;"   ><span style="font-size:14.0pt;"   ><span style="
font-size:90%;mso-special-format:bullet;color:#FF9900;font-family:Wingdings;"   >n</span></span><span style="font-size: 14pt; font-family: 宋体;"   >关于</span><span style="font-size: 14pt; font-family: 'Times New Roman';"   >bitmap
index scan startup_cost=0, TomLane</span><span style="font-size: 14pt; font-family: 宋体;"   >的解释
</span><span style="font-size: 14pt; font-family: 'Times New Roman';"   >:
</span></div>

<div style="line-height: 120%; direction: ltr; vertical-align: baseline; margin-bottom: 0pt; text-indent: -0.38in; margin-top: 3.36pt; unicode-bidi: embed; margin-left: 0.38in;"   ><span style="font-size:14.0pt;"   ><span style="
font-size:90%;mso-special-format:bullet;color:#FF9900;font-family:Wingdings;"   >n</span></span><span style="font-size: 14pt; font-family: 'Times New Roman';"   >We
</span><span style="font-size: 14pt; font-family: 'Times New Roman';"   >don't
bother to store/show the indexscan's startup cost in such cases,</span></div>

<div style="line-height: 120%; direction: ltr; vertical-align: baseline; margin-bottom: 0pt; text-indent: -0.38in; margin-top: 3.36pt; unicode-bidi: embed; margin-left: 0.38in;"   ><span style="font-size:14.0pt;"   ><span style="
font-size:90%;mso-special-format:bullet;color:#FF9900;font-family:Wingdings;"   >n</span></span><span style="font-size: 14pt; font-family: 'Times New Roman';"   >since
it has no effect whatsoever on subsequent planning: the total cost</span></div>

<div style="line-height: 120%; direction: ltr; vertical-align: baseline; margin-bottom: 0pt; text-indent: -0.38in; margin-top: 3.36pt; unicode-bidi: embed; margin-left: 0.38in;"   ><span style="font-size:14.0pt;"   ><span style="
font-size:90%;mso-special-format:bullet;color:#FF9900;font-family:Wingdings;"   >n</span></span><span style="font-size: 14pt; font-family: 'Times New Roman';"   >of
the indexscan will go into the parent's startup cost anyway.</span></div></div><div><br></div><div>[参考]</div><div>1.&nbsp;src/backend/utils/adt/selfuncs.c</div><div>2.&nbsp;src/backend/executor/nodeIndexonlyscan.c</div><div>3.&nbsp;src/backend/optimizer/path/costsize.c</div><div>4.&nbsp;src/backend/access/nbtree/nbtpage.c</div><div>5.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/sql-explain.html"   >http://www.postgresql.org/docs/9.3/static/sql-explain.html</a></div><div>6.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/using-explain.html"   >http://www.postgresql.org/docs/9.3/static/using-explain.html</a></div></div>
	</div>
</div>
</body>
</html>