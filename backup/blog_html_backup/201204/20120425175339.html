<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">个人分析-阿里遇到的GreenPlum故障</h2>
	<h5 id="">2012-04-25 17:53:39&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201232552636538/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">老唐他们最近在维护GreenPlum时遇到的一个问题案例, 根据他们的排错来看, 可能是遇到了GreenPlum的BUG.<div>但是对于BUG的详细定位我还是有一定的怀疑。具体排错如下：</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >最近在维护greenplum中，发现pg_class表的索引很大了，为了增加提高性能，就做了一个reindex table pg_class;但做完后，就发现整个greenplum数据库的性能降低到只有以前的几分之一了，通dtrace脚本跟踪发现是一直在狂读pg_class，也不清楚为什么。当时没有办法，只好新建了一张与pg_class结构和索引都完全一样的表，然后把pg_class的内容导到这个新建的表中，然后关闭数据库，交换两个表的底层文件后，故障消失了。当时是一直不明白为什么，也把这个问题报给了EMC公司，也一直没有定位到原因。</font></div><div><font size="2"   >由于我们还有一个容灾环境，在容灾环境上建了一个greenplum的clone，然后在这个环境上也重现的故障。通过几天的定位，终于把原因找到了。</font></div><div><font size="2"   >原因是当重建pg_class表的索引时，导致索引pg_class_oid_index在pg_class表中的物理位置发生了变化。</font></div><div><font size="2"   >原先物理位置在0号块，</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >aligputf8=# select ctid,relname,oid from pg_class where oid=2662;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; ctid &nbsp; | &nbsp; &nbsp; &nbsp;relname &nbsp; &nbsp; &nbsp; | oid &nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >---------+--------------------+------</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp;(0,108) | pg_class_oid_index | 2662</font></div><div><font size="2"   ><span style="line-height: 19px;"   ><br></span></font></div><div><font size="2"   >reindex table pg_class后，索引pg_class_oid_index的位置移到了文件的最后：</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >aligputf8=# select ctid,relname,oid from pg_class where relname='pg_class_oid_index';</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; ctid &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;relname &nbsp; &nbsp; &nbsp; | oid &nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >------------+--------------------+------</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp;(43585,32) | pg_class_oid_index | 2662</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >而为什么索引pg_class_oid_index在pg_class表中的条 目的物理位置移到最后就会导致狂读pg_class的问题发生呢？</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >原因是，当访问任何一个表时，就需要从pg_class表中提取这个表的元数据信息，而在pg_class中查找表的原数据信息，需要访问索 引pg_class_oid_index，而访问索引pg_class_oid_index，也需要从pg_class表中获得索引pg_class_oid_index的元数据信息，<font color="#ff0000"   >而获得索引pg_class_oid_index自己的元数据信息，就不能再通过索引自己去查找自己的信息了，这里就只能从头扫描表pg_class来获得，而由于索引pg_class_oid_index的条目被移到了最后的位置，所以导致需要几乎把pg_class从头 扫描到尾才能找到pg_class_oid_index的条目，这样就大大的降低了数据库的性能。</font></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >greenplum中，有几百万张表。&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >这个问题在原生的PostgreSQL中是否存在。从理论上看，估计也可能会有。</font></div><div><font size="2"   >查询表在pg_class中的信息是调用RelationIdGetRelation函数的。当在内存中找不到相关信息时，而这个函数一般是通过索引pg_class_oid_index去查找的。</font></div><div><font size="2"   >而数据库第一次起来的时候，如果通过RelationIdGetRelation函数获得索引pg_class_oid_index自己的信息，则自己不能通过自己去查找，所以必须全表扫描pg_class来得到，所以第一次时，估计也会比较慢。</font></div><p></p></pre></div><div><br></div><div><span style="color: rgb(255, 0, 0); font-family: monospace; line-height: 19px; white-space: pre; font-size: small;"   >而获得索引pg_class_oid_index自己的元数据信息，就不能再通过索引自己去查找自己的信息了，这里就只能从头扫描表pg_class来获得，而由于索引pg_class_oid_index的条目被移到了最后的位置，所以导致需要几乎把pg_class从头 扫描到尾才能找到pg_class_oid_index的条目，这样就大大的降低了数据库的性能。</span></div><div><br></div><div>这部分内容在我使用PostgreSQL 9.1.3进行测试后, 无法得到印证. 因为PostgreSQL启动时会加载system catalog到内存中.</div><div>详见</div><div>src/backend/utils/cache/relcache.c</div><div>测试过程如下 :&nbsp;</div><div>首先调用函数创建100W张测试表.</div><div>先修改max_pred_locks_per_transaction, 改到一个比较大的数字, 否则一次建几百万表会有资源溢出的可能.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create or replace function crt_table(i_prefix varchar(15),i_min int,i_max int) returns int as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >for i in i_min..i_max loop</font></div><div><font size="2"   >execute 'create table '||i_prefix||i||' (c1 int,c2 timestamp(0),c3 varchar(64))';</font></div><div><font size="2"   >end loop;</font></div><div><font size="2"   >return 0;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><p></p></pre></div><div>-- 使用shell调用这个函数来建表.</div><div><div>cat crt_table.sh&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >#!/bin/bash</font></div><div><font size="2"   >func()</font></div><div><font size="2"   >{</font></div><div><font size="2"   >s=10000</font></div><div><font size="2"   >for i in $(seq 1 200)</font></div><div><font size="2"   >do</font></div><div><font size="2"   >SQL="select 1 from crt_table('$1',$(($s*($i-1)+1)),$(($s*($i))));"</font></div><div><font size="2"   >echo -e $SQL|psql -f -</font></div><div><font size="2"   >done</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >func b &amp;</font></div><div><font size="2"   >func c &amp;</font></div><div><font size="2"   >func d &amp;</font></div><div><font size="2"   >func e &amp;</font></div><div><font size="2"   >func f &amp;</font></div><div><font size="2"   >func g &amp;</font></div><div><font size="2"   >func h &amp;</font></div><p></p></pre></div></div><div>-- 查询当前数据库中的pg_class记录数, 全表扫描, 耗时274</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# select count(*) from pg_class;</font></div><div><font size="2"   >&nbsp; count &nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;1100292</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Time: 274.327 ms</font></div><p></p></pre></div><div>-- 为避免受CACHE影响, 再次查询, 以得到真实的查询速度.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# select count(*) from pg_class;</font></div><div><font size="2"   >&nbsp; count &nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;1100292</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Time: 274.398 ms</font></div><p></p></pre></div><div>-- pg_class表大小目前是209MB左右</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# select pg_relation_size('pg_class')/1024;</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp;213064</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Time: 1.258 ms</font></div><p></p></pre></div><div>-- 重建pg_class的索引, 其中包含pg_class_oid_index.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# REINDEX TABLE pg_class;</font></div><div><font size="2"   >REINDEX</font></div><div><font size="2"   >Time: 3524.714 ms</font></div><div><font size="2"   >test=# \d pg_class</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; Table "pg_catalog.pg_class"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;Column &nbsp; &nbsp; | &nbsp; Type &nbsp; &nbsp;| Modifiers&nbsp;</font></div><div><font size="2"   >----------------+-----------+-----------</font></div><div><font size="2"   >&nbsp;relname &nbsp; &nbsp; &nbsp; &nbsp;| name &nbsp; &nbsp; &nbsp;| not null</font></div><div><font size="2"   >&nbsp;relnamespace &nbsp; | oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;reltype &nbsp; &nbsp; &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;reloftype &nbsp; &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relowner &nbsp; &nbsp; &nbsp; | oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relam &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relfilenode &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;reltablespace &nbsp;| oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relpages &nbsp; &nbsp; &nbsp; | integer &nbsp; | not null</font></div><div><font size="2"   >&nbsp;reltuples &nbsp; &nbsp; &nbsp;| real &nbsp; &nbsp; &nbsp;| not null</font></div><div><font size="2"   >&nbsp;reltoastrelid &nbsp;| oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;reltoastidxid &nbsp;| oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relhasindex &nbsp; &nbsp;| boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relisshared &nbsp; &nbsp;| boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relpersistence | "char" &nbsp; &nbsp;| not null</font></div><div><font size="2"   >&nbsp;relkind &nbsp; &nbsp; &nbsp; &nbsp;| "char" &nbsp; &nbsp;| not null</font></div><div><font size="2"   >&nbsp;relnatts &nbsp; &nbsp; &nbsp; | smallint &nbsp;| not null</font></div><div><font size="2"   >&nbsp;relchecks &nbsp; &nbsp; &nbsp;| smallint &nbsp;| not null</font></div><div><font size="2"   >&nbsp;relhasoids &nbsp; &nbsp; | boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relhaspkey &nbsp; &nbsp; | boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relhasrules &nbsp; &nbsp;| boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relhastriggers | boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relhassubclass | boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relfrozenxid &nbsp; | xid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relacl &nbsp; &nbsp; &nbsp; &nbsp; | aclitem[] |&nbsp;</font></div><div><font size="2"   >&nbsp;reloptions &nbsp; &nbsp; | text[] &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >Indexes:</font></div><div><font size="2"   >&nbsp; &nbsp; "pg_class_oid_index" UNIQUE, btree (oid)</font></div><div><font size="2"   >&nbsp; &nbsp; "pg_class_relname_nsp_index" UNIQUE, btree (relname, relnamespace)</font></div><p></p></pre></div><div><br></div><div>-- 重建后pg_class_oid_index这条记录被放到了第26632个块中. 这个也是正常的, 因为我创建的表都是比p开头小的字母的表.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# select ctid from pg_class where relname='pg_class_oid_index';</font></div><div><font size="2"   >&nbsp; &nbsp;ctid &nbsp; &nbsp;</font></div><div><font size="2"   >-----------</font></div><div><font size="2"   >&nbsp;(26632,5)</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Time: 1.368 ms</font></div><p></p></pre></div><div>-- 我的block_size=8K, 所以可以计算出pg_class_oid_index这条记录在pg_class中基本上是靠在最后的.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# select 26632*8;</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp;213056</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Time: 0.353 ms</font></div><p></p></pre></div><div>-- 接下来测试一下是否会出现走pg_class_oid_index这个索引时需要重读pg_class的情况.&nbsp;</div><div>-- 因为pg_class_oid_index的元数据已经在内存存在, 从以下的测试结果来没有对pg_class进行全表扫描.</div><div>-- 因为全表扫pg_class耗费了274毫秒.</div><div>-- 另外我还不是太确定 "获取<span style="line-height: 22px;"   >pg_class_oid_index这个索引的元数据时, 如果没有在内存中存在, 则需要重读pg_class" 这句描述到底对不对?</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# select oid from pg_class order by oid desc limit 10;</font></div><div><font size="2"   >&nbsp; &nbsp;oid &nbsp;&nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;3944301</font></div><div><font size="2"   >&nbsp;3944298</font></div><div><font size="2"   >&nbsp;3944295</font></div><div><font size="2"   >&nbsp;3944292</font></div><div><font size="2"   >&nbsp;3944289</font></div><div><font size="2"   >&nbsp;3944286</font></div><div><font size="2"   >&nbsp;3944283</font></div><div><font size="2"   >&nbsp;3944280</font></div><div><font size="2"   >&nbsp;3944277</font></div><div><font size="2"   >&nbsp;3944274</font></div><div><font size="2"   >(10 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Time: 0.904 ms</font></div><div><font size="2"   >test=# select * from pg_class where oid=3944274;</font></div><div><font size="2"   >&nbsp;relname | relnamespace | reltype | reloftype | relowner | relam | relfilenode | reltablespace | relpages | reltuples | reltoastreli</font></div><div><font size="2"   >d | reltoastidxid | relhasindex | relisshared | relpersistence | relkind | relnatts | relchecks | relhasoids | relhaspkey | relhasru</font></div><div><font size="2"   >les | relhastriggers | relhassubclass | relfrozenxid | relacl | reloptions&nbsp;</font></div><div><font size="2"   >---------+--------------+---------+-----------+----------+-------+-------------+---------------+----------+-----------+-------------</font></div><div><font size="2"   >--+---------------+-------------+-------------+----------------+---------+----------+-----------+------------+------------+---------</font></div><div><font size="2"   >----+----------------+----------------+--------------+--------+------------</font></div><div><font size="2"   >&nbsp;l99991 &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; 2200 | 3944276 | &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; 10 | &nbsp; &nbsp; 0 | &nbsp; &nbsp; 3944274 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | p &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| r &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp;3 | &nbsp; &nbsp; &nbsp; &nbsp; 0 | f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; | f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 78352779 | &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Time: 0.510 ms</font></div><p></p></pre></div></div><div><br></div><div>不管&nbsp;<span style="line-height: 22px;"   >"获取</span><span style="line-height: 22px;"   >pg_class_oid_index这个索引的元数据时, 如果没有在内存中存在, 则需要重读pg_class" 这个是不是对的,</span></div><div><span style="line-height: 22px;"   >PostgreSQL 在启动时会把system catalog 全部加载到内存, 这个是事实.</span></div><div>14591 postgres &nbsp;18 &nbsp; 0 &nbsp;<font color="#ff0000"   ><u>209m</u></font> &nbsp;53m &nbsp;52m S &nbsp;0.0 &nbsp;0.2 &nbsp; 0:00.89 /opt/pgsql/bin/postgres&nbsp;</div><div>209M刚好符合pg_class的SIZE,&nbsp;</div><div>但是索引(注意索引pg_class_oid_index这条在pg_class中的元数据已经进到内存了)并没有加载进去, 如下, 包含索引应该有264MB.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# select pg_total_relation_size('pg_class')/1024/1024;</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 264</font></div><p></p></pre></div><div>&nbsp;正因为启动的时候要加载system catalog到内存, 所以pg_class越大, 启动速度约慢.</div></div><div>并且pg_class的内容可能被刷出缓存, 视OS的CACHE机制而定.</div><div><br></div><div>【小结】</div><div>1. 如果&nbsp;<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >"获取</span><span style="line-height: 22px;"   >pg_class_oid_index这个索引的元数据时, 如果没有在内存中存在, 则需要重读pg_class" &nbsp;这个观点是正确的,</span></div><div><span style="line-height: 22px;"   >那么老唐他们遇到的问题可能是pg_class的包含了pg_class_oid_index这台记录的内容刷出缓存后造成的. 但是也不应该造成pg_class频繁的读, 因为读一次就够了, pg_class_oid_index的内容很快会回到CACHE中. 频繁使用的东西也不那么容易从CACHE中出去. 所以造成频繁PG_CLASS读, 这个可能性不大.</span></div><div>2. 第二种可能性我认为是pg_class_oid_index失效了. 以前使用EDB 8.3时遇到过索引失效的问题, 导致执行计划全变成全表扫描了.</div><div>这个可能性我认为比较大.</div><div>参考如下, 《记录一次EnterpriseDB的索引异常失效处理》</div><div><a href="http://blog.163.com/digoal@126/blog/static/1638770402010411102112458/"   >http://blog.163.com/digoal@126/blog/static/1638770402010411102112458/</a></div><div>3. 由于系统是GreenPlum的, 也可能是GreenPlum带来的其他BUG。</div><div><pre class="prettyprint"   ><p><font size="2"   >直接通过PGOPTIONS='-c gp_session_role=utility' psql -p 50001连接时，只有数据库刚起来时，第一次连接时，才会出现全表扫描pg_class的情况，以后估计是因为cache在内存中的了，就不会再这样了。但如果是master过来的连接，则经常发生这样。</font></p></pre></div><wbr></div>根据这个来分析, 应该是PG_CLASS变大后的一个普遍现象, 例如很多情况下会涉及到某些系统表和pg_class关联进行查询, 导致使用了pg_class的全表扫描, 比如<div>\dS操作会执行如下SQL,&nbsp;<br><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SELECT n.nspname as "Schema",</font></div><div><font size="2"   >&nbsp; c.relname as "Name",</font></div><div><font size="2"   >&nbsp; CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 's' THEN 'special' WHEN 'f' THEN 'foreign table' END as "Type",</font></div><div><font size="2"   >&nbsp; pg_catalog.pg_get_userbyid(c.relowner) as "Owner"</font></div><div><font size="2"   >FROM pg_catalog.pg_class c</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace</font></div><div><font size="2"   >WHERE c.relkind IN ('r','v','S','s','f','')</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; AND n.nspname !~ '^pg_toast'</font></div><div><font size="2"   >&nbsp; AND pg_catalog.pg_table_is_visible(c.oid)</font></div><div><font size="2"   >ORDER BY 1,2;</font></div><p></p></pre></div><div>这个SQL的执行计划如下, 用到了pg_class的全表扫描.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp;Sort &nbsp;(cost=17.57..17.69 rows=45 width=133)</font></div><div><font size="2"   >&nbsp; &nbsp;Sort Key: n.nspname, c.relname</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Hash Join &nbsp;(cost=1.14..16.34 rows=45 width=133)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Hash Cond: (c.relnamespace = n.oid)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on pg_class c &nbsp;(cost=0.00..13.76 rows=54 width=73)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (pg_table_is_visible(oid) AND (relkind = ANY ('{r,v,S,s,f,""}'::"char"[])))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Hash &nbsp;(cost=1.07..1.07 rows=5 width=68)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on pg_namespace n &nbsp;(cost=0.00..1.07 rows=5 width=68)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (nspname !~ '^pg_toast'::text)</font></div><p></p></pre></div><div>不知道master连接segment node的过程是不是会产生一些类似的全表扫描.</div></div></div></div>
	</div>
</div>
</body>
</html>