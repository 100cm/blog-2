<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">why where clause use non-leading column's or non-clause-column's index</h2>
	<h5 id="">2012-04-26 18:23:29&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012326686816/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">今天一位网友发现一个比较奇怪的问题,<div>select * from table where col1=0;</div><div>走了一个索引btree (col2,col1)</div><div>而select * from table where col1=1则全表扫描.</div><div>这其实是一个跳跃索引的例子.&nbsp;</div><div><br>什么情况下where clause子句会使用非前导列的索引, 或者干脆就使用无此列的索引呢?<wbr></div><div><div style="line-height: 28px;"   >不管是前导列col2还是非前导列col1, 要走索引扫描, 势必让走索引的成本最低, 或者强制走索引.</div><div style="line-height: 28px;"   >只不过走前导列的开销(可能是部分索引扫描)大多数情况下要小于走非前导列的开销(整个索引的扫描).</div></div><div style="line-height: 28px;"   ><br></div><div>-- 创建测试表</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create table test (id int,name text,crt_time timestamp(0));</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>-- 插入测试数据</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# insert into test select generate_series(1,100000),'digoal'||generate_series(1,100000),now();</font></div><div><font size="2"   >INSERT 0 100000</font></div><p></p></pre></div><div>-- 插入索引列值为空的记录一条, 这条为了说明PostgreSQL 当今版本记录了NULL值列的信息.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# insert into test(id,name,crt_time) values (1,null,null);</font></div><div><font size="2"   >INSERT 0 1</font></div><p></p></pre></div><div><div style="line-height: 28px;"   >见8.3 Release的时候有如下信息:</div><div style="line-height: 28px;"   >Allow col IS NULL to use an index (Teodor)</div><div style="line-height: 28px;"   >也就是必须8.3含以上版本才可用.</div></div><div><br></div><div>-- 创建一个不包含id的索引. 但是包含了where子句.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create index idx_test_1 on test(name) where id=1;</font></div><div><font size="2"   >CREATE INDEX</font></div><p></p></pre></div><div>-- 收集test表的统计信息</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# analyze test;</font></div><div><font size="2"   >ANALYZE</font></div><p></p></pre></div><div>--这条SQL就走了索引.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain analyze select * from test where id=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_test_1 on test &nbsp;(cost=0.00..6.28 rows=1 width=23) (actual time=0.047..0.049 rows=2 loops=1)</font></div><div><font size="2"   >&nbsp;Total runtime: 0.083 ms</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>-- 而这条不会走索引, 因为索引中没有id=0的信息.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain analyze select * from test where id=0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on test &nbsp;(cost=0.00..1887.01 rows=1 width=23) (actual time=16.943..16.943 rows=0 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (id = 0)</font></div><div><font size="2"   >&nbsp;Total runtime: 16.982 ms</font></div><div><font size="2"   >(3 rows)</font></div><p></p></pre></div></div><div>很有意思, PostgreSQL精彩无处不在.</div><div>另外, 我们再回到主题, 当索引有两列或多列时, 如何让SQL走非前导列的扫描呢?</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create table tt(c1 int, c2 int, c3 int,c4 int) ;</font></div><div><font size="2"   >CREATE TABLE</font></div></div><div><div><font size="2"   >postgres=# insert into tt select round(random()*id),round(random()*id),round(random()*id),round(random()*id) from generate_series(1,1000000) t(id);</font></div><div><font size="2"   >INSERT 0 1000000</font></div></div><div><div><font size="2"   >postgres=# create index idx_1 on tt(c1,c2,c3);</font></div><div><font size="2"   >CREATE INDEX</font></div></div><div><div><font size="2"   >postgres=# set enable_seqscan=off;</font></div><div><font size="2"   >SET</font></div></div><div><div><font size="2"   >postgres=# analyze tt;</font></div><div><font size="2"   >ANALYZE</font></div><div><font size="2"   >postgres=# explain select * from tt where c1=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_1 on tt &nbsp;(cost=0.42..14.47 rows=3 width=16)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (c1 = 1)</font></div><div><font size="2"   >(2 rows)</font></div></div><p></p></pre></div><div><div>从explain的结果看,使用非前导列时, &nbsp;postgresql走索引扫描, 从返回第一条记录, 到所有记录返回完毕, 扫描的成本比直接扫描前导列高了, 因为要整个索引全扫一遍才能得到非前导列的结果.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain select * from tt where c2=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_1 on tt &nbsp;(cost=0.42..11523.94 rows=67 width=16)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (c2 = 1)</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   >postgres=# explain select * from tt where c3=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >---------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_1 on tt &nbsp;(cost=0.42..11334.45 rows=3 width=16)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (c3 = 1)</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div></div></div>
	</div>
</div>
</body>
</html>