<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Use the heap for dynamic storage</h2>
	<h5 id="">2012-08-09 23:30:21&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012799320331/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">在C中, 本地变量存储在进程的stack内存区域.<div>当函数执行完后, 函数体内的本地变量占用的内存会自动释放掉.</div><div>在Linux中使用ulimit -a可以查看到stack的限制, 也可以通过/etc/security/limits.conf设置.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# ulimit -a</font></div><div><font size="2"  >core file size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(blocks, -c) 0</font></div><div><font size="2"  >data seg size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (kbytes, -d) unlimited</font></div><div><font size="2"  >scheduling priority &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (-e) 0</font></div><div><font size="2"  >file size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (blocks, -f) unlimited</font></div><div><font size="2"  >pending signals &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (-i) 204800</font></div><div><font size="2"  >max locked memory &nbsp; &nbsp; &nbsp; (kbytes, -l) 50000000</font></div><div><font size="2"  >max memory size &nbsp; &nbsp; &nbsp; &nbsp; (kbytes, -m) unlimited</font></div><div><font size="2"  >open files &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(-n) 131072</font></div><div><font size="2"  >pipe size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(512 bytes, -p) 8</font></div><div><font size="2"  >POSIX message queues &nbsp; &nbsp; (bytes, -q) 819200</font></div><div><font size="2"  >real-time priority &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(-r) 0</font></div><div><font size="2"  >stack size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(kbytes, -s) 10240</font></div><div><font size="2"  >cpu time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (seconds, -t) unlimited</font></div><div><font size="2"  >max user processes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(-u) 131072</font></div><div><font size="2"  >virtual memory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(kbytes, -v) unlimited</font></div><div><font size="2"  >file locks &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(-x) unlimited</font></div><p></p></pre></div><div><br></div><div>由于stack区域的内存大小比较小, 所以适合存放临时性的变量. 不适合存放大量的需要hold在内存中的数据.</div><div>大数据或者不可预知的数据或者是需要在函数执行完后还需要HOLD在内存中的数据, 可以放到HEAP中。</div><div>但是HEAP中的数据与STACK不同，不会自动释放，也没有自动的垃圾回收机制。</div><div>如使用malloc申请的内存需要使用free释放, 否则如果没有任何指针指向这块内存区域后, 这块内存将无法回收, 直到进程退出 .</div><div>所以建议不用的内存要用free释放掉. 否则容易造成内存泄漏.</div><div>另外就是有一个工具valgrind可以用来侦察内存泄漏.</div><div>malloc语法</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >void *malloc(size_t size);</font></div><div><font size="2"  >// 返回一个空指针. 因为空指针可以存放任何类型的指针数据.&nbsp;</font></div><div><font size="2"  >malloc() allocates size bytes and returns a pointer to the allocated memory. &nbsp;The memory is not cleared.</font></div><p></p></pre></div><div><br></div><div>malloc与free是一对, free语法 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >void free(void *ptr);</font></div><div><div><font size="2"  >free() frees the memory space pointed to by ptr, which must have been returned by a previous call to &nbsp;malloc(),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;calloc() &nbsp;or realloc(). &nbsp;Otherwise, or if free(ptr) has already been called before, undefined behaviour occurs.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;If ptr is NULL, no operation is performed.</font></div></div><p></p></pre></div><div><br></div><div>用法举例 :&nbsp;</div><div>场景参照上一篇linked list数据结构的例子.</div><div><br></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat g.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >typedef struct island {</font></div><div><font size="2"  >&nbsp; char *name;</font></div><div><font size="2"  >&nbsp; char *opens;</font></div><div><font size="2"  >&nbsp; char *closes;</font></div><div><font size="2"  >&nbsp; struct island *next;</font></div><div><font size="2"  >} island;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void display(island *start)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; island *i = start;</font></div><div><font size="2"  >&nbsp; for (; i != NULL; i = i-&gt;next) {</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "Name: %s open: %s - %s\n", i-&gt;name, i-&gt;opens, i-&gt;closes);</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >island* create(char *name)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; island *i = malloc(sizeof(island));</font></div><div><font size="2"  >&nbsp; i-&gt;name = strdup(name);  // strdup调用了malloc,并且将字符串复制到heap区域, 返回指针.</font></div><div><font size="2"  >&nbsp; i-&gt;opens = "09:00";</font></div><div><font size="2"  >&nbsp; i-&gt;closes = "17:00";</font></div><div><font size="2"  >&nbsp; i-&gt;next = NULL;</font></div><div><font size="2"  >&nbsp; return i;</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void release(island *start) {</font></div><div><font size="2"  >&nbsp; island *i = start;</font></div><div><font size="2"  >&nbsp; island *next = NULL;</font></div><div><font size="2"  >&nbsp; for (; i != NULL; i=next) {</font></div><div><font size="2"  >&nbsp; &nbsp; next = i-&gt;next;</font></div><div><font size="2"  >&nbsp; &nbsp; free(i-&gt;name);</font></div><div><font size="2"  >&nbsp; &nbsp; free(i);</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; island *start = NULL;</font></div><div><font size="2"  >&nbsp; island *i = NULL;</font></div><div><font size="2"  >&nbsp; island *next = NULL;</font></div><div><font size="2"  >&nbsp; char name[80];</font></div><div><font size="2"  >&nbsp; for(; fgets(name,80,stdin) != NULL; i = next) {</font></div><div><font size="2"  >&nbsp; &nbsp; next = create(name);</font></div><div><font size="2"  >&nbsp; &nbsp; if (start == NULL)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; start = next ;</font></div><div><font size="2"  >&nbsp; &nbsp; if (i != NULL)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; i-&gt;next = next;</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; display(start);</font></div><div><font size="2"  >&nbsp; release(start);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><div><font size="2"  >执行结果 :&nbsp;</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./g.c -o g &amp;&amp; ./g</font></div><div><font size="2"  >// 输入</font></div><div><font size="2"  >a</font></div><div><font size="2"  >b</font></div><div><font size="2"  >c</font></div><div><font size="2"  >d</font></div><div><font size="2"  >// 输入 CTRL+D</font></div><div><font size="2"  >// 输出</font></div><div><font size="2"  >Name: a</font></div><div><font size="2"  >&nbsp;open: 09:00 - 17:00</font></div><div><font size="2"  >Name: b</font></div><div><font size="2"  >&nbsp;open: 09:00 - 17:00</font></div><div><font size="2"  >Name: c</font></div><div><font size="2"  >&nbsp;open: 09:00 - 17:00</font></div><div><font size="2"  >Name: d</font></div><div><font size="2"  >&nbsp;open: 09:00 - 17:00</font></div><p></p></pre></div><div><br></div><div>其他 :&nbsp;</div><div>1. strdup</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;string.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;char *strdup(const char *s);</font></div></div><div><div><font size="2"  >The &nbsp;strdup() &nbsp;function returns a pointer to a new string which is a duplicate of the string s. &nbsp;Memory for the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;new string is obtained with malloc(3), and can be freed with free(3).</font></div></div><p></p></pre></div><div>2. 在释放struct在heap的空间之前, 必须先通过<span style="line-height: 22px;"  >这个struct存储的指向heap中字符串的指针去</span>释放这串strdup拷贝到heap的内存区域. 如果struct先释放, 那这块字符串区域将没有任何指针指向它, 也无法回收. 造成内存泄漏.</div><div><br></div><div>3. 内存泄漏举例 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat g.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >typedef struct island {</font></div><div><font size="2"  >&nbsp; char *name;</font></div><div><font size="2"  >&nbsp; char *opens;</font></div><div><font size="2"  >&nbsp; char *closes;</font></div><div><font size="2"  >&nbsp; struct island *next;</font></div><div><font size="2"  >} island;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void display(island *start)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; island *i = start;</font></div><div><font size="2"  >&nbsp; for (; i != NULL; i = i-&gt;next) {</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "Name: %s open: %s - %s\n", i-&gt;name, i-&gt;opens, i-&gt;closes);</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >island* create(char *name)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; island *i = malloc(sizeof(island));</font></div><div><font size="2"  >&nbsp; i-&gt;name = strdup(name);</font></div><div><font size="2"  >&nbsp; i-&gt;opens = "09:00";</font></div><div><font size="2"  >&nbsp; i-&gt;closes = "17:00";</font></div><div><font size="2"  >&nbsp; i-&gt;next = NULL;</font></div><div><font size="2"  >&nbsp; return i;</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void release(island *start) {</font></div><div><font size="2"  >&nbsp; island *i = start;</font></div><div><font size="2"  >&nbsp; island *next = NULL;</font></div><div><font size="2"  >&nbsp; for (; i != NULL; i=next) {</font></div><div><font size="2"  >&nbsp; &nbsp; next = i-&gt;next;</font></div><div><font size="2"  >&nbsp; &nbsp; // 注释掉这行,也就是不回收调用strdup时申请的内存空间. free(i-&gt;name);</font></div><div><font size="2"  >&nbsp; &nbsp; free(i);</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; island *start = NULL;</font></div><div><font size="2"  >&nbsp; island *i = NULL;</font></div><div><font size="2"  >&nbsp; island *next = NULL;</font></div><div><font size="2"  >&nbsp; char name[80];</font></div><div><font size="2"  >&nbsp; for(; fgets(name,80,stdin) != NULL; i = next) {</font></div><div><font size="2"  >&nbsp; &nbsp; next = create(name);</font></div><div><font size="2"  >&nbsp; &nbsp; if (start == NULL)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; start = next ;</font></div><div><font size="2"  >&nbsp; &nbsp; if (i != NULL)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; i-&gt;next = next;</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; display(start);</font></div><div><font size="2"  >&nbsp; release(start);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><span style="line-height: 19px;"  >// 使用gcc -g 编译参数时, 编译的可执行文件包含了 debug 信息. 便于valgrind跟踪时打印详细的信息</span></font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./g.c -o g &amp;&amp; valgrind --leak-check=full ./g</font></div><div><font size="2"  >==2166== Memcheck, a memory error detector</font></div><div><font size="2"  >==2166== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.</font></div><div><font size="2"  >==2166== Using Valgrind-3.5.0 and LibVEX; rerun with -h for copyright info</font></div><div><font size="2"  >==2166== Command: ./g</font></div><div><font size="2"  >==2166==&nbsp;</font></div><div><font size="2"  >// 输入</font></div><div><font size="2"  >a</font></div><div><font size="2"  >b</font></div><div><font size="2"  >c</font></div><div><font size="2"  >d</font></div><div><font size="2"  >// 输入 CTRL+D </font></div><div><font size="2"  >Name: a</font></div><div><font size="2"  >&nbsp;open: 09:00 - 17:00</font></div><div><font size="2"  >Name: b</font></div><div><font size="2"  >&nbsp;open: 09:00 - 17:00</font></div><div><font size="2"  >Name: c</font></div><div><font size="2"  >&nbsp;open: 09:00 - 17:00</font></div><div><font size="2"  >Name: d</font></div><div><font size="2"  >&nbsp;open: 09:00 - 17:00</font></div><div><font size="2"  >==2166==&nbsp;</font></div><div><font size="2"  >==2166== HEAP SUMMARY:</font></div><div><font size="2"  >==2166== &nbsp; &nbsp; in use at exit: 12 bytes in 4 blocks</font></div><div><font size="2"  >==2166== &nbsp; total heap usage: 8 allocs, 4 frees, 140 bytes allocated</font></div><div><font size="2"  >==2166==&nbsp;</font></div><div><font size="2"  >==2166== 12 bytes in 4 blocks are definitely lost in loss record 1 of 1</font></div><div><font size="2"  >==2166== &nbsp; &nbsp;at 0x4A0610C: malloc (vg_replace_malloc.c:195)</font></div><div><font size="2"  >==2166== &nbsp; &nbsp;by 0x345FA798C1: strdup (in /lib64/libc-2.5.so)</font></div><div><font size="2"  >==2166== &nbsp; &nbsp;by 0x400725: main (g.c:23)</font></div><div><font size="2"  >==2166==&nbsp;</font></div><div><font size="2"  >==2166== LEAK SUMMARY:</font></div><div><font size="2"  >==2166== &nbsp; &nbsp;definitely lost: 12 bytes in 4 blocks</font></div><div><font size="2"  >==2166== &nbsp; &nbsp;indirectly lost: 0 bytes in 0 blocks</font></div><div><font size="2"  >==2166== &nbsp; &nbsp; &nbsp;possibly lost: 0 bytes in 0 blocks</font></div><div><font size="2"  >==2166== &nbsp; &nbsp;still reachable: 0 bytes in 0 blocks</font></div><div><font size="2"  >==2166== &nbsp; &nbsp; &nbsp; &nbsp; suppressed: 0 bytes in 0 blocks</font></div><div><font size="2"  >==2166==&nbsp;</font></div><div><font size="2"  >==2166== For counts of detected and suppressed errors, rerun with: -v</font></div><div><font size="2"  >==2166== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 4 from 4)</font></div><p></p></pre></div><div>3. valgrind为什么可以跟踪内存泄漏呢?<wbr></div><div>因为valgrind自己有malloc和free函数, 并且拦截了进程的malloc和free操作, 使用它自己的malloc和free替代. 进行跟踪.</div><div>因此等进程退出的时候, 可以发现有哪些HEAP中的内存是没有被free掉的.</div><div><div><img title="Use the heap for dynamic storage - 德哥@Digoal - The Heart,The World."  alt="Use the heap for dynamic storage - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img2.ph.126.net/xXSUCHzy3Qq6KpVx-Vu0Cw==/2724959249553530962.jpg"  ></div>&nbsp;</div><br><div>4. 特别需要注意在heap中的变量, 在修改引用这个地址的指针时, 要先释放掉前面的指针值, 再赋予新的值。否则老的那块内存区域就内存泄漏了.</div></div>
	</div>
</div>
</body>
</html>