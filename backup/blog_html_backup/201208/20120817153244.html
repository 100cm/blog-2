<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">pipe and fifo(first-in first-out special file, named pipe)</h2>
	<h5 id="">2012-08-17 15:32:44&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201271713259671/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>详细介绍参考man手册.</div><div>这篇blog主要</div><div>1. 验证write的原子操作情况.</div><div>2. 验证pipe只读一遍</div><div><br></div><div>例如 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;time.h&gt;</font></div><div><font size="2"  >#include &lt;sys/types.h&gt;</font></div><div><font size="2"  >#include &lt;sys/stat.h&gt;</font></div><div><font size="2"  >#include &lt;fcntl.h&gt;</font></div><div><font size="2"  >#include &lt;sys/wait.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >// 定义fork多少个子进程. 预编译过程将代码中的MAX_P替换成2.</font></div><div><font size="2"  >#define MAX_P 2</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >char * path = "/tmp/test.fifo";</font></div><div><font size="2"  >char msg[] = "digoalhelloworldxxxxxxxxxxxxxxxxxxxx";</font></div><div><font size="2"  >int i;</font></div><div><font size="2"  >int fd_fifo;</font></div><div><font size="2"  >pid_t p[MAX_P];</font></div><div><font size="2"  >int status[MAX_P];</font></div><div><font size="2"  >char out[2000];</font></div><div><font size="2"  >ssize_t read_sz;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; // 打印flag数值</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "flag O_RDWR:%i, O_NONBLOCK:%i\n", O_RDWR, O_NONBLOCK);</font></div><div><font size="2"  >&nbsp; // 检测要创建的pipe文件是否已经存在, 不存在则创建</font></div><div><font size="2"  >&nbsp; if ( access(path, 0) != -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "file %s exists, it will not revoke mkfifo().\n", path);</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; else if ( mkfifo(path, 0644) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "error: %s\n", strerror(errno));</font></div><div><font size="2"  >&nbsp; &nbsp; exit(1);</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; // 在主进程以读写方式打开这个fifo pipe文件. 主进程只有读的需求, 可以使用O_RDONLY.</font></div><div><font size="2"  >&nbsp; // 这里使用O_RDWR 只是为了验证fifo pipe只占用一个fd table条目, 在/proc/$pid/fd/里面可以看到.</font></div><div><font size="2"  >&nbsp; // 多个flag可以使用+(数学运算加)或者|(位运算或), 位运算比数学运算快, 推荐使用.</font></div><div><font size="2"  >&nbsp; // 并且数学运算的加减还要考虑溢出和正负的问题. 不推荐使用</font></div><div><font size="2"  >&nbsp; fd_fifo = open(path, O_RDWR|O_NONBLOCK, 0644);</font></div><div><font size="2"  >&nbsp; if (fd_fifo == -1) {</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "error: %s\n", strerror(errno));</font></div><div><font size="2"  >&nbsp; &nbsp; exit(1);</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; // fork子进程</font></div><div><font size="2"  >&nbsp; for(i=0; i&lt;MAX_P; i++) {</font></div><div><font size="2"  >&nbsp; &nbsp; if ( (p[i] = fork()) == -1) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(stdout, "error: %s\n", strerror(errno));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; exit(1);</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; // 如果是子进程, 则跳出fork循环, 如果没有break子进程会继续这个循环, 继续fork, 这样会造成不可预估的后果.</font></div><div><font size="2"  >&nbsp; &nbsp; if (!p[i]) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; // 子进程执行如下代码</font></div><div><font size="2"  >&nbsp; if(!p[i]) {</font></div><div><font size="2"  >&nbsp; &nbsp; // 修改flag 使用fcntl &nbsp;( int fcntl(int fd, int cmd, long arg) ). 子进程这里选择O_WRONLY, 只写.</font></div><div><font size="2"  >&nbsp; &nbsp; if ( fcntl(fd_fifo, F_SETFD, O_WRONLY|O_NONBLOCK) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(stdout, "modify child process's pipe flag error: %s\n", strerror(errno));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; exit(1);</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; // 从msg这个地址开始往pipe里面写入长sizeof(msg)的数据(byte stream), 原子操作参见man 7 pipe,&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; // 原子操作确保多进程同时写入pipe的数据不会被相互混淆, 例如两个进程都写了digoal, 那不会出现类似ddigoigoalal这样的情况.</font></div><div><font size="2"  >&nbsp; &nbsp; // 如果写入的长度小于pipe所剩空间并且大于<span style="line-height: 19px;"  >PIPE_BUF(Linux下为4096字节)</span></font><span style="font-size: small;"  >, 则这次写操作将变成非原子操作(partial write).</span></div><div><font size="2"  >&nbsp; &nbsp; // 由于pipe写入是byte stream, 所以一次写入的最小单位是字节.</font></div><div><font size="2"  >&nbsp; &nbsp; // 因此非原子操作的情况下, 大于1字节的数据类型如int型的数据写入可能会导致数据混淆无法正确读取. 暂无测试.</font></div><div><font size="2"  >&nbsp; &nbsp; // 如0x98765432 这个int类型数据, 可能被拆成0x98 0x76 0x54 0x32 在入pipe的过程中, 可能被其他进程穿插写入, 那么就会造成这个int数据被拆散</font></div><div><font size="2"  >&nbsp; &nbsp; if (write(fd_fifo, msg, sizeof(msg)) == -1) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(stdout, "error: %s\n", strerror(errno));</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; // pipe用完记得关闭.</font></div><div><font size="2"  >&nbsp; &nbsp; if ( close(fd_fifo) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(stdout, "error: %s\n", strerror(errno));</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; // 子进程执行完直接从main函数return, 后面的代码将不会执行.</font></div><div><font size="2"  >&nbsp; &nbsp; return 0;</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >// 指主进程要不要等待所有的子进程运行结束再继续执行后面的代码,</font></div><div><font size="2"  >// 这里如果主进程选择等待, 很有可能前面fork出来的子进程在write时会报错.</font></div><div><font size="2"  >// 因为这个fifo pipe到此还没有被read, 有溢出的可能.(Linux下pipe的容量是64KB, 超出的话write会出错)</font></div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp; for(i=0; i&lt;MAX_P; i++) {</font></div><div><font size="2"  >&nbsp; &nbsp; waitpid(p[i], &amp;status[i], 0);</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >*/</font></div><div><font size="2"  >&nbsp; // 主进程循环从pipe里读取数据, 并打印到stdout.</font></div><div><font size="2"  >&nbsp; // 读取的数据将从pipe out出去.</font></div><div><font size="2"  >&nbsp; while (1) {</font></div><div><font size="2"  >&nbsp; &nbsp; // read_sz记录read读取的字节数, 如果=0则表示数据读完了</font></div><div><font size="2"  >&nbsp; &nbsp; read_sz = read(fd_fifo, out, sizeof(msg));</font></div><div><font size="2"  >&nbsp; &nbsp; if ( read_sz == 0 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; if ( close(fd_fifo) == -1) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fprintf(stdout, "error: %s\n", strerror(errno));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(stdout, "no any data leave in fd_fifo.\n");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; else if( read_sz == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(stdout, "parent proc, error: %s\n", strerror(errno));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; else {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(stdout, "read size:%i, %s\n", (int) read_sz, out);</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; // 因为读取的数据已经out了, 所以其他进程再也读不到pipe里的数据.</font></div><div><font size="2"  >&nbsp; // 也就是说pipe里的数据只能被读取到一次.</font></div><div><font size="2"  >&nbsp; if(! fork()) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; while (1) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; read_sz = read(fd_fifo, out, sizeof(msg));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; if ( read_sz == 0 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if ( close(fd_fifo) == -1) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(stdout, "error: %s\n", strerror(errno));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fprintf(stdout, "no any data leave in fd_fifo.\n");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; else if( read_sz == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fprintf(stdout, "child proc, error: %s\n", strerror(errno));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; else {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fprintf(stdout, "read size:%i, %s\n", (int) read_sz, out);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; // 一般子进程代码中末尾都加上return, 以免执行到主进程的代码段.</font></div><div><font size="2"  >&nbsp; &nbsp; return 0;</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; //sleep(100);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>结果 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o abcd &amp;&amp; ./abcd</font></div><div><font size="2"  >flag O_RDWR:2, O_NONBLOCK:2048</font></div><div><font size="2"  >file /tmp/test.fifo exists, it will not revoke mkfifo().</font></div><div><font size="2"  >read size:37, digoalhelloworldxxxxxxxxxxxxxxxxxxxx</font></div><div><font size="2"  >read size:37, digoalhelloworldxxxxxxxxxxxxxxxxxxxx</font></div><div><font size="2"  >parent proc, error: Resource temporarily unavailable</font></div><div><font size="2"  >child proc, error: Resource temporarily unavailable</font></div><p></p></pre></div><div>关于非原子操作, Linux下pipe_buf = 4096 字节 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;O_NONBLOCK enabled, n &gt; PIPE_BUF</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If the pipe is full, then write(2) fails, with errno set to EAGAIN. &nbsp;Otherwise, from 1 to n bytes may be</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; written (i.e., a "partial write" may occur; the caller should check the return value &nbsp;from &nbsp;write(2) &nbsp;to</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; see &nbsp;how many bytes were actually written), and these bytes may be interleaved with writes by other pro-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cesses.</font></div><p></p></pre></div><div>将以上代码修改一下, 把char msg[] 改成 long double msg[] 存入超过4096字节的数据,&nbsp;</div><div>同时分两批子进程, 一批往pipe里面写入单个超过4096字节的数据, 另一批写入单个1字节的数据, 再次测试会发现问题, 代码如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat a.c<br>#include &lt;unistd.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;errno.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;time.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;sys/wait.h&gt;<br><br>// 定义fork多少个子进程. 预编译过程将代码中的MAX_P替换成2.<br>#define MAX_P 200<br><br>int pt=1;<br>char * path = "/tmp/test.fifo";<br>int m;<br>long double msg[] = {987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456, 987654321000123456789.123456};<br>int i;<br>int fd_fifo;<br>pid_t p[MAX_P];<br>int status[MAX_P];<br>unsigned char out[99999999];<br>ssize_t read_sz;<br><br>int main() {<br>  // 检测要创建的pipe文件是否已经存在, 不存在则创建<br>  if ( access(path, 0) != -1 ) {<br>    fprintf(stderr, "file %s exists, it will not revoke mkfifo().\n", path);<br>  }<br>  else if ( mkfifo(path, 0644) == -1 ) {<br>    fprintf(stderr, "error: %s\n", strerror(errno));<br>    exit(1);<br>  }<br>  fd_fifo = open(path, O_RDWR|O_NONBLOCK, 0644);<br>  if (fd_fifo == -1) {<br>    fprintf(stderr, "error: %s\n", strerror(errno));<br>    exit(1);<br>  }<br>  for(i=0; i&lt;MAX_P; i++) {<br>    if ( (p[i] = fork()) == -1) {<br>      fprintf(stderr, "error: %s\n", strerror(errno));<br>      exit(1);<br>    }<br>    if (!p[i]) {<br>      break;<br>    }<br>  }<br>  if(!p[i]) {<br>    int x;<br>    char n = 'A';<br>    switch(i%2) {<br>      case 0:<br>        for(x=0; x&lt;50000; x++) {<br>          if (write(fd_fifo, &amp;n, 1) == -1) {<br>            fprintf(stderr, "child error: %s\n", strerror(errno));<br>          }<br>        }<br>        break;<br>      case 1:<br>        for(x=0; x&lt;500; x++) {<br>          if (write(fd_fifo, msg, sizeof(msg)) == -1) {<br>            fprintf(stderr, "child error: %s\n", strerror(errno));<br>          }<br>        }<br>        break;<br>    }<br>    if ( close(fd_fifo) == -1 ) {<br>      fprintf(stderr, "child error: %s\n", strerror(errno));<br>    }<br>    return 0;<br>  }<br> <br>  while (1) {<br>    read_sz = read(fd_fifo, out, 1);<br>    if( read_sz == -1 ) {<br>      fprintf(stderr, "parent proc, error: %s\n", strerror(errno));<br>      return 1;<br>    }<br>    else if (read_sz != 0) {<br>      if( (pt != 0) &amp;&amp; ((pt%16) == 0) ) {<br>        fprintf(stdout, "%02x\n", *out );<br>      }<br>      else {<br>        fprintf(stdout, "%02x", *out );<br>      }<br>    }<br>    else {<br>      return 1;<br>    }<br>    pt++;<br>  }<br>  return 0;<br>}</font></div><p></p></pre></div><div>结果如下 :&nbsp;</div><div><pre class="prettyprint"  ><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -g ./a.c -o abcd &amp;&amp; ./abcd &gt;/tmp/test.log 2&gt;/dev/null<br>[root@db-172-16-3-150 zzz]# cat /tmp/test.log |sort|uniq<br>4000000000000000f0ef8710d429d644<br>40000000000000414141414141414141<br>4141414141414100f0ef8710d429d644<br>4141414141414141414141<br>414141414141414141414100f0ef8710<br>41414141414141414141414141414141<br>d429d6444000000000000000f0ef8710<br>d429d644400000000000004141414141</font></div><p></p></pre></div><div>从/tmp/test.log的数据来看, msg已经被截断成了多段小于等于4096字节的内容, 但是单个long double元素(占用16字节)还是完整的(41 都是出现在msg中的两个long double值之间, 并没有截断long double).&nbsp;</div><div>这个可能跟pipe的处理有关, 估计每次保证提交的原子操作数据是16的倍数(猜测.未经证实)</div><div>但是如果你的元素大于16字节, 比如struct, 那必然元素也会遭到破坏.</div><div><br></div><div>【参考】</div><div>man 7 pipe</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;pipe - overview of pipes and FIFOs</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Pipes &nbsp;and &nbsp;FIFOs &nbsp;(also &nbsp;known as named pipes) provide a unidirectional interprocess communication channel. &nbsp;A</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;pipe has a read end and a write end. &nbsp;Data written to the write end of a pipe can be read from the read end &nbsp;of</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the pipe.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;A &nbsp;pipe &nbsp;is &nbsp;created using pipe(2), which creates a new pipe and returns two file descriptors, one referring to</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the read end of the pipe, the other referring to the write end. &nbsp;Pipes can be used to &nbsp;create &nbsp;a &nbsp;communication</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;channel between related processes; see pipe(2) for an example.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;A &nbsp;FIFO &nbsp;(short &nbsp;for &nbsp;First &nbsp;In &nbsp;First Out) has a name within the file system (created using mkfifo(3)), and is</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;opened using open(2). &nbsp;Any process may open a FIFO, assuming the file permissions allow it. &nbsp;The &nbsp;read &nbsp;end &nbsp;is</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;opened &nbsp;using &nbsp;the &nbsp;O_RDONLY &nbsp;flag; &nbsp;the &nbsp;write end is opened using the O_WRONLY flag. &nbsp;See fifo(7) for further</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;details. &nbsp;Note: although FIFOs have a pathname in the file system, I/O on FIFOs does not involve operations &nbsp;on</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the underlying device (if there is one).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp;I/O on Pipes and FIFOs</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The &nbsp;only &nbsp;difference &nbsp;between &nbsp;pipes and FIFOs is the manner in which they are created and opened. &nbsp;Once these</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;tasks have been accomplished, I/O on pipes and FIFOs has exactly the same semantics.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;If a process attempts to read from an empty pipe, then read(2) will block until data is available. &nbsp;If &nbsp;a &nbsp;pro-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;cess &nbsp;attempts &nbsp;to &nbsp;write &nbsp;to a full pipe (see below), then write(2) blocks until sufficient data has been read</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;from the pipe to allow the write to complete. &nbsp;Non-blocking I/O is possible by using the fcntl(2) F_SETFL oper-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;ation to enable the O_NONBLOCK open file status flag.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The communication channel provided by a pipe is a byte stream: there is no concept of message boundaries.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;If &nbsp;all file descriptors referring to the write end of a pipe have been closed, then an attempt to read(2) from</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the pipe will see end-of-file (read(2) will return 0). &nbsp;If all file descriptors referring to the read end of &nbsp;a</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;pipe have been closed, then a write(2) will cause a SIGPIPE signal to be generated for the calling process. &nbsp;If</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the calling process is ignoring this signal, then write(2) fails with the error &nbsp;EPIPE. &nbsp; An &nbsp;application &nbsp;that</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;uses &nbsp;pipe(2) &nbsp;and &nbsp;fork(2) should use suitable close(2) calls to close unnecessary duplicate file descriptors;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;this ensures that end-of-file and SIGPIPE/EPIPE are delivered when appropriate.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;It is not possible to apply lseek(2) to a pipe.</font></div></div><div><font size="2"  ><br></font></div><div><div><font size="2"  >&nbsp; &nbsp;Pipe Capacity</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;A pipe has a limited capacity. &nbsp;If the pipe is full, then a write(2) will block or fail, depending &nbsp;on &nbsp;whether</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the O_NONBLOCK flag is set (see below). &nbsp;Different implementations have different limits for the pipe capacity.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Applications should not rely on a particular capacity: an application should be designed so that a reading pro-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;cess consumes data as soon as it is available, so that a writing process does not remain blocked.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;In &nbsp;Linux versions before 2.6.11, the capacity of a pipe was the same as the system page size (e.g., 4096 bytes</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;on x86). &nbsp;Since Linux 2.6.11, the pipe capacity is 65536 bytes.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp;PIPE_BUF</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;POSIX.1-2001 says that write(2)s of less than PIPE_BUF bytes must be atomic: the output data is written to &nbsp;the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;pipe as a contiguous sequence. &nbsp;Writes of more than PIPE_BUF bytes may be non-atomic: the kernel may interleave</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the data with data written by other processes. &nbsp;POSIX.1-2001 requires PIPE_BUF to be at least 512 &nbsp;bytes. &nbsp; (On</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Linux, &nbsp;PIPE_BUF &nbsp;is &nbsp;4096 bytes.) &nbsp;The precise semantics depend on whether the file descriptor is non-blocking</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;(O_NONBLOCK), whether there are multiple writers to the pipe, and on n, the number of bytes to be written:</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;O_NONBLOCK disabled, n &lt;= PIPE_BUF</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; All n bytes are written atomically; write(2) may block if there is not room for n bytes &nbsp;to &nbsp;be &nbsp;written</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; immediately</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;O_NONBLOCK enabled, n &lt;= PIPE_BUF</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If &nbsp;there is room to write n bytes to the pipe, then write(2) succeeds immediately, writing all n bytes;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherwise write(2) fails, with errno set to EAGAIN.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;O_NONBLOCK disabled, n &gt; PIPE_BUF</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The write is non-atomic: the data given to write(2) may be interleaved with write(2)s by other &nbsp;process;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the write(2) blocks until n bytes have been written.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;O_NONBLOCK enabled, n &gt; PIPE_BUF</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If the pipe is full, then write(2) fails, with errno set to EAGAIN. &nbsp;Otherwise, from 1 to n bytes may be</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; written (i.e., a "partial write" may occur; the caller should check the return value &nbsp;from &nbsp;write(2) &nbsp;to</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; see &nbsp;how many bytes were actually written), and these bytes may be interleaved with writes by other pro-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cesses.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp;Open File Status Flags</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The only open file status flags that can be meaningfully applied to a pipe or FIFO are O_NONBLOCK and &nbsp;O_ASYNC.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Setting the O_ASYNC flag for the read end of a pipe causes a signal (SIGIO by default) to be generated when new</font></div></div><div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;input becomes available on the pipe (see fcntl(2) for details). &nbsp;On Linux, O_ASYNC is supported for &nbsp;pipes &nbsp;and</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;FIFOs only since kernel 2.6.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp;Portability notes</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;On &nbsp;some &nbsp;systems &nbsp;(but not Linux), pipes are bidirectional: data can be transmitted in both directions between</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the pipe ends. &nbsp;According to POSIX.1-2001, pipes only need to be unidirectional. &nbsp;Portable applications &nbsp;should</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;avoid reliance on bidirectional pipe semantics.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SEE ALSO</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;dup(2), fcntl(2), open(2), pipe(2), poll(2), select(2), socketpair(2), stat(2), mkfifo(3), epoll(7), fifo(7)</font></div></div><p></p></pre></div><div><br></div><div>man 7 fifo</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;fifo - first-in first-out special file, named pipe</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;A FIFO special file (a named pipe) is similar to a pipe, except that it is accessed as part of the file system.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;It can be opened by multiple processes for reading or writing. When processes are exchanging data via the FIFO,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the kernel passes all data internally without writing it to the file system. Thus, the FIFO special file has no</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;contents on the file system, the file system entry merely serves as a reference point &nbsp;so &nbsp;that &nbsp;processes &nbsp;can</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;access the pipe using a name in the file system.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The kernel maintains exactly one pipe object for each FIFO special file that is opened by at least one process.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The FIFO must be opened on both ends (reading and writing) before data can be &nbsp;passed. &nbsp;Normally, &nbsp;opening &nbsp;the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;FIFO blocks until the other end is opened also.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;A process can open a FIFO in non-blocking mode. In this case, opening for read only will succeed even if no-one</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;has opened on the write side yet; opening for write only will fail with &nbsp;ENXIO &nbsp;(no &nbsp;such &nbsp;device &nbsp;or &nbsp;address)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;unless the other end has already been opened.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Under &nbsp;Linux, &nbsp;opening &nbsp;a &nbsp;FIFO &nbsp;for &nbsp;read and write will succeed both in blocking and non-blocking mode. POSIX</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;leaves this behaviour undefined. This can be used to open a FIFO for writing while there are no readers &nbsp;avail-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;able. &nbsp;A process that uses both ends of the connection in order to communicate with itself should be very care-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;ful to avoid deadlocks.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >NOTES</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;When a process tries to write to a FIFO that is not opened for read on the other side, the process &nbsp;is &nbsp;sent &nbsp;a</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;SIGPIPE signal.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;FIFO special files can be created by mkfifo(3), and are specially indicated in ls -l.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SEE ALSO</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;mkfifo(1), open(2), pipe(2), sigaction(2), signal(2), socketpair(2), mkfifo(3), pipe(7)</font></div></pre></div></div><div><br></div><div>pipe, mkfifo, open, read, write<br><br><wbr></div></div>
	</div>
</div>
</body>
</html>