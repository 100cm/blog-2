<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">struct vs array</h2>
	<h5 id="">2012-08-08 12:54:40&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020127873942553/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>C里面array是一个比较特殊的类型, 例如char a[10]= "abcdef"; 在编译时, a会替换成存储实际内容的内存首地址. 所以没有地方存储变量a.</div><div><div>因此使用a和&amp;a 都可以打印a的地址.</div><div>如 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat d.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >char a[10] = "abc";</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; fprintf(stdout,"addr a:%p, addr &amp;a:%p\n", a, &amp;a);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><div><font size="2"  >结果 : </font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./d.c -o d &amp;&amp; ./d</font></div><div><font size="2"  >addr a:0x6008c4, addr &amp;a:0x6008c4</font></div><p></p></pre></div><div><br></div><div>struct 定义的变量, 变量就是变量, 它不是一个指针. 这点和array不同. 例如 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat d.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >struct fish {</font></div><div><font size="2"  >&nbsp; int a;</font></div><div><font size="2"  >&nbsp; float c;</font></div><div><font size="2"  >&nbsp; char b[10];</font></div><div><font size="2"  >};</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; struct fish f1 = {1, 9.9, "abcd"};</font></div><div><font size="2"  >&nbsp; fprintf(stdout,"addr f1:%p, addr &amp;f1:%p\n", f1, &amp;f1);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div></div><div><font size="2"  >报错, 也就是说f1 是个变量, 要取地址需要使用&amp;, 这点和其他的变量相同 :&nbsp;</font></div><div><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./d.c -o d &amp;&amp; ./d</font></div><div><font size="2"  >cc1: warnings being treated as errors</font></div><div><font size="2"  >./d.c: In function ‘main’:</font></div><div><font size="2"  >./d.c:11: warning: format ‘%p’ expects type ‘void *’, but argument 3 has type ‘struct fish’</font></div></div><p></p></pre></div><div>修改后 :</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat d.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >struct fish {</font></div><div><font size="2"  >&nbsp; int a;</font></div><div><font size="2"  >&nbsp; float c;</font></div><div><font size="2"  >&nbsp; char b[10];</font></div><div><font size="2"  >};</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int i;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; struct fish f1 = {1, 9.9, "abcd"};</font></div><div><font size="2"  >&nbsp; i = 10;</font></div><div><font size="2"  >&nbsp; fprintf(stdout,"addr &amp;i:%p, addr &amp;f1:%p\n", &amp;i, &amp;f1);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./d.c -o d &amp;&amp; ./d</font></div><div><font size="2"  >addr &amp;i:0x600934, addr &amp;f1:0x7fffdd6bec90</font></div><p></p></pre></div><div><br></div><div>虽然使用%p 打印的 a或者&amp;a 内容是一致的, 但是a 和 &amp;a 是有区别的. 可以通过测试来看一看.</div><div>a[1] 等同于 *(a+1) , 这里 a+1 用到了指针的地址运算, 即a的地址加上1个数组中的元素占用的空间. 如int a[], 一个元素占用4字节. char a[]中一个元素占用1字节. 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat d.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >char a[10] = "abc";</font></div><div><font size="2"  >int b[10] = {1,2,3,4,5};</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; fprintf(stdout,"addr a:%p, addr a[1]:%p, addr a+1:%p\n", a, &amp;(a[1]), &amp;(*(a+1)));  // </font><span style="font-size: small; line-height: 19px;"  >&amp;(*(a+1)) 替换成 (a+1) 是一样的</span></div><div><font size="2"  >&nbsp; fprintf(stdout,"addr b:%p, addr b[1]:%p, addr b+1:%p\n", b, &amp;(b[1]), &amp;(*(b+1)));  // </font><span style="font-size: small; line-height: 19px;"  >&amp;(*(b+1)) 替换成 (b+1) 是一样的</span></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><div><font size="2"  >结果 : </font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./d.c -o d &amp;&amp; ./d</font></div><div><font size="2"  >addr a:0x600940, addr a[1]:0x600941, addr a+1:0x600941</font></div><div><font size="2"  >addr b:0x600960, addr b[1]:0x600964, addr b+1:0x600964</font></div><p></p></pre></div><div><br></div><div>既然 数组名 a 是指针, 那&amp;a 是什么呢? 能不能像a这样做指针的地址运算呢?</div><div>可以, 但是已经和a+1 得到的结果不一样了, 那么(&amp;a)+1 会是什么意思? 结果是什么呢?</div><div>&amp;a 表示存储a这个数组的首内存地址, 所以(&amp;a) +1 则表示下一个和a数组占用一样大小空间的数组的内存首地址.</div><div>换句话说a表示的是char类型的指针 , 而&amp;a 表示的是char a[10]这个数组类型的指针 .&nbsp;</div><div>因为C是强类型语言, 所以加减结果必然与类型有关.&nbsp;</div><div>来看个例子 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  ><span style="line-height: 19px;"  >[root@db-172-16-3-150 zzz]# cat d.c<br>#include &lt;stdio.h&gt;<br><br>char a[10] = "abc";<br>int b[10] = {1,2,3,4,5};<br><br>int main() {<br>  fprintf(stdout,"sizeof(a):%lu, sizeof(b):%lu\n", sizeof(a), sizeof(b));<br>  fprintf(stdout,"addr a:%p, addr a[1]:%p, addr (&amp;a)+1:%p\n", a, &amp;(a[1]), ((&amp;a)+1));<br>  fprintf(stdout,"addr b:%p, addr b[1]:%p, addr (&amp;b)+1:%p\n", b, &amp;(b[1]), ((&amp;b)+1));<br>  return 0;<br>}</span></font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./d.c -o d &amp;&amp; ./d</font></div><div><font size="2"  >sizeof(a):10, sizeof(b):40</font></div><div><font size="2"  >addr a:0x6009a0, addr a[1]:0x6009a1, addr (&amp;a)+1:0x6009aa  // 结果表明 </font><span style="font-size: small; line-height: 19px;"  >0x6009aa - </span><span style="font-size: small; line-height: 19px;"  >0x6009a0 刚好等于10字节, a[10]的大小.</span></div><div><font size="2"  >addr b:0x6009c0, addr b[1]:0x6009c4, addr (&amp;b)+1:0x6009e8  </font><font size="2"  style="line-height: 19px;"  >// 结果表明 </font><span style="line-height: 19px; font-size: small;"  >0x6009e8 - </span><span style="line-height: 19px; font-size: small;"  >0x6009c0 刚好等于40字节, b[10]的大小.</span></div><p></p></pre></div><div><br></div><div>前面我们看到array可以用[0],[1]来取数组中的元素. 那么struct用什么来取呢? 用点. 不能用[]这种方式.</div><div>来看个例子 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./d.c -o d &amp;&amp; ./d</font></div><div><font size="2"  >a[0]:a, a[1]:b</font></div><div><font size="2"  >b[0]:1, b[1]:2</font></div><div><font size="2"  >f1.age:20, f1.weight:60.500000, f1.name:linux</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat d.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >char a[10] = "abc";</font></div><div><font size="2"  >int b[10] = {1,2,3,4,5};</font></div><div><font size="2"  >struct fish {</font></div><div><font size="2"  >&nbsp; int age;</font></div><div><font size="2"  >&nbsp; float weight;</font></div><div><font size="2"  >&nbsp; char name[10];</font></div><div><font size="2"  >};</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; struct fish f1 = {20, 60.5, "linux"};</font></div><div><font size="2"  >&nbsp; fprintf(stdout,"a[0]:%c, a[1]:%c\n", a[0], *(a+1));</font></div><div><font size="2"  >&nbsp; fprintf(stdout,"b[0]:%i, b[1]:%i\n", b[0], *(b+1));</font></div><div><font size="2"  >&nbsp; fprintf(stdout,"f1.age:%i, f1.weight:%f, f1.name:%s\n", f1.age, f1.weight, f1.name);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><div><font size="2"  >结果 : </font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./d.c -o d &amp;&amp; ./d</font></div><div><font size="2"  >a[0]:a, a[1]:b</font></div><div><font size="2"  >b[0]:1, b[1]:2</font></div><div><font size="2"  >f1.age:20, f1.weight:60.500000, f1.name:linux</font></div><p></p></pre></div><div>但是需要注意的是, struct中, 使用(.点)来引用元素的时候和array使用[]来应用元素的区别.</div><div>数组中 , a[1] = *(a+1) 是指的内容(char). 而不是指针(pointer).</div><div>struct 中 f1.? 真实反映这个元素的内容 (int, char, 或char []) &nbsp;例如 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat d.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >struct fish {</font></div><div><font size="2"  >&nbsp; int age;</font></div><div><font size="2"  >&nbsp; float weight;</font></div><div><font size="2"  >&nbsp; char name[10];</font></div><div><font size="2"  >};</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; struct fish f1 = {20, 60.5, "linux"};</font></div><div><font size="2"  >&nbsp; fprintf(stdout,"f1.age:%i, f1.weight:%f, f1.name:%s ,f1.name[1]:%c, (f1.name)[1]:%c, *((f1.name)+1):%c\n", f1.age, f1.weight, f1.name, f1.name[1], (f1.name)[1], *((f1.name)+1));</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><div><font size="2"  >结果 :&nbsp;</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./d.c -o d &amp;&amp; ./d</font></div><div><font size="2"  >f1.age:20, f1.weight:60.500000, f1.name:linux ,f1.name[1]:i, (f1.name)[1]:i, *((f1.name)+1):i</font></div><p></p></pre></div><div>所以&nbsp;f1.name[1], &nbsp;(f1.name)[1], &nbsp;*((f1.name)+1) 这三种写法是一样的.</div><div><br></div><div><div style="line-height: 22px;"  >在初始化完变量后, &nbsp;struct 和 array 一样, 里面的元素都是连续存储的 .&nbsp;</div><div style="line-height: 22px;"  >例如 :&nbsp;</div></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat d.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >char a[] = "abcdef";</font></div><div><font size="2"  >struct fish {</font></div><div><font size="2"  >&nbsp; int age;</font></div><div><font size="2"  >&nbsp; float weight;</font></div><div><font size="2"  >&nbsp; char name[10];</font></div><div><font size="2"  >};</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; struct fish f1 = {20, 60.5, "linux"};</font></div><div><font size="2"  >&nbsp; fprintf(stdout,"sizeof(char):%lu, sizeof(int):%lu, sizeof(float):%lu, sizeof(char [10]):%lu\n", sizeof(char), sizeof(int), sizeof(float), sizeof(char [10]));</font></div><div><font size="2"  >&nbsp; fprintf(stdout,"sizeof(f1.age):%lu, sizeof(f1.weight):%lu, sizeof(f1.name):%lu\n", sizeof(f1.age), sizeof(f1.weight), sizeof(f1.name));</font></div><div><font size="2"  >&nbsp; fprintf(stdout,"sizeof(a):%lu, addr a:%p, addr a[0]:%p, addr a[1]:%p, addr a[2]:%p\n", sizeof(a), a, a, a+1, a+2);</font></div><div><font size="2"  >&nbsp; fprintf(stdout,"sizeof(f1):%lu, addr &amp;f:%p, addr f1.age:%p, addr f1.weight:%p, addr f1.name:%p\n", sizeof(f1), &amp;f1, &amp;(f1.age), &amp;(f1.weight), &amp;(f1.name));</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >结果 :&nbsp;</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./d.c -o d &amp;&amp; ./d</font></div><div><font size="2"  >sizeof(char):1, sizeof(int):4, sizeof(float):4, sizeof(char [10]):10</font></div><div><font size="2"  >sizeof(f1.age):4, sizeof(f1.weight):4, sizeof(f1.name):10</font></div><div><font size="2"  >sizeof(a):7, addr a:0x600aac, addr a[0]:0x600aac, addr a[1]:0x600aad, addr a[2]:0x600aae</font></div><div><font size="2"  >sizeof(f1):20, addr &amp;f:0x7fff0c25ec30, addr f1.age:0x7fff0c25ec30, addr f1.weight:0x7fff0c25ec34, addr f1.name:0x7fff0c25ec38</font></div><p></p></pre></div><div><div><div><br></div></div>在赋值方面, array 和 struct 也有所不同. 例如</div></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat d.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >char a[] = "abcdef";</font></div><div><font size="2"  >struct fish {</font></div><div><font size="2"  >&nbsp; int age;</font></div><div><font size="2"  >&nbsp; float weight;</font></div><div><font size="2"  >&nbsp; char name[10];</font></div><div><font size="2"  >&nbsp; char * nick;</font></div><div><font size="2"  >};</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; struct fish f1 = {20, 60.5, "linux", "unix"};</font></div><div><font size="2"  >&nbsp; // 结构可以通过拷贝来赋值 , 注意每个元素都会拷贝一份, 对于指针类型的元素, &nbsp;拷贝的则是指针(所以f2 和f1 的nick 将指向同一个区域.)</font></div><div><font size="2"  >&nbsp; struct fish f2 = f1;</font></div><div><font size="2"  >&nbsp; char b[10];</font></div><div><font size="2"  >&nbsp; *(b) = a[0];</font></div><div><font size="2"  >&nbsp; *(b+1) = a[1];</font></div><div><font size="2"  >&nbsp; *(b+2) = *(a+2);</font></div><div><font size="2"  >&nbsp; *(b+3) = a[3];</font></div><div><font size="2"  >&nbsp; b[4] = a[4];</font></div><div><font size="2"  >&nbsp; b[5] = a[5];</font></div><div><font size="2"  >&nbsp; // 数组不能简单的用等于来直接拷贝. 以下三种赋值都是错误的.</font></div><div><font size="2"  >  // 再一次说明了array b这个b已经在编译时被替换为地址, 而struct fish f2它是个变量名, 才能够通过此方式赋值.</font></div><div><font size="2"  >&nbsp; // b = a;</font></div><div><font size="2"  >&nbsp; // *b = *a;</font></div><div><font size="2"  >&nbsp; // *b = a;</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "a:%s, b:%s\n", a, b);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "addr f1:%p, addr f2:%p\n", &amp;f1, &amp;f2);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "&amp;(f1.age):%p, &amp;(f1.weight):%p, &amp;(f1.name):%p, &amp;(f1.nick):%p, f1.name:%p, f1.nick:%p\n", &amp;(f1.age), &amp;(f1.weight), &amp;(f1.name), &amp;(f1.nick), f1.name, f1.nick);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "&amp;(f2.age):%p, &amp;(f2.weight):%p, &amp;(f2.name):%p, &amp;(f2.nick):%p, f2.name:%p, f2.nick:%p\n", &amp;(f2.age), &amp;(f2.weight), &amp;(f2.name), &amp;(f2.nick), f2.name, f2.nick);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div>结果 :&nbsp;<div>f1.nick和f2.nick 打印%p 结果一致, 说明f1.nick和f2.nick指向同一个字符串.</div><div><div><img title="struct vs array - 德哥@Digoal - The Heart,The World."  alt="struct vs array - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img0.ph.126.net/xmt2kVUJk8uQ5K7xAXcUmA==/6597232494377833220.jpg"  ></div>&nbsp;<br><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./d.c -o d &amp;&amp; ./d</font></div><div><font size="2"  >a:abcdef, b:abcdef</font></div><div><font size="2"  >addr f1:0x7fff78ff9af0, addr f2:0x7fff78ff9ad0</font></div><div><font size="2"  >&amp;(f1.age):0x7fff78ff9af0, &amp;(f1.weight):0x7fff78ff9af4, &amp;(f1.name):0x7fff78ff9af8, &amp;(f1.nick):0x7fff78ff9b08, f1.name:0x7fff78ff9af8, f1.nick:0x400748</font></div><div><font size="2"  >&amp;(f2.age):0x7fff78ff9ad0, &amp;(f2.weight):0x7fff78ff9ad4, &amp;(f2.name):0x7fff78ff9ad8, &amp;(f2.nick):0x7fff78ff9ae8, f2.name:0x7fff78ff9ad8, f2.nick:0x400748</font></div><p></p></pre></div></div></div>
	</div>
</div>
</body>
</html>