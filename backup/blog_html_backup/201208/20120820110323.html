<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">pipe q&a</h2>
	<h5 id="">2012-08-20 11:03:23&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201272011241192/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>Q: Is a pipe a file?</div><div>A: It's up to the operating system how it creates pipes, but pipes created with the pipe() function are not normally files.</div><div><br></div><div>Q: So pipes might be files?</div><div>A: It is possible to create pipes based on files, which are normally called named pipes or FIFO (first-in/first-out) files.</div><div><br></div><div>Q: Why would anyone want a pipe that uses a file?</div><div>A: Pipes based on files have names. That means they are useful if two processes need to talk to each other and they are not parent and child processes. As long as both processes know the name of the pipe, they can talk with it.</div><div><br></div><div>Q: Great! So how do I use named pipes?</div><div>A: Using the mkfifo() system call. For more information, see &nbsp;<a target="_blank" rel="nofollow" href="http://tinyurl.com/cdf6ve5"  >http://tinyurl.com/cdf6ve5</a>.</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201271713259671/"  >http://blog.163.com/digoal@126/blog/static/163877040201271713259671/</a></div><div><br></div><div>Q: If most pipes are not files, what are they?</div><div>A: Usually, they are just pieces of memory. Data is written at one point and read at another. In LINUX pipe capicity is 64KB, pipe buffer is 4096. (see man 7 pipe).</div><div>Since Linux 2.6.11, the pipe capacity is 65536 bytes.</div><div>(On Linux, &nbsp;PIPE_BUF &nbsp;is &nbsp;4096 bytes.)</div><div><br></div><div>Q: What happens if I try to read from a pipe and there's nothing in there?</div><div>A: Your program will wait until something is there.</div><div><br></div><div>Q: How does the parent know when the child is finished?</div><div>A: When the child process dies, the pipe is closed and the fgets() command receives an end-of-file, which means the fgets() function returns 0, and the loop ends.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;sys/wait.h&gt;</font></div><div><font size="2"  >#include &lt;sys/types.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void error(char * msg) {</font></div><div><font size="2"  >&nbsp; fprintf(stderr, "%s: %s\n", msg, strerror(errno));</font></div><div><font size="2"  >&nbsp; exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void open_url(char *url)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; char launch[255];</font></div><div><font size="2"  >&nbsp; sprintf(launch, "cmd /c start %s", url);</font></div><div><font size="2"  >&nbsp; system(launch);</font></div><div><font size="2"  >&nbsp; sprintf(launch, "x-www-browser '%s' &amp;", url);</font></div><div><font size="2"  >&nbsp; system(launch);</font></div><div><font size="2"  >&nbsp; sprintf(launch, "open '%s'", url);</font></div><div><font size="2"  >&nbsp; system(launch);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main(int argc, char *argv[])</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; char *phrase = argv[1];</font></div><div><font size="2"  >&nbsp; char *vars[] = {"RSS_FEED=http://www.cnn.com/rss/celebs.xml", NULL};</font></div><div><font size="2"  >&nbsp; int fd[2];</font></div><div><font size="2"  >&nbsp; if (pipe(fd) == -1) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("Can't create the pipe");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; pid_t pid = fork();</font></div><div><font size="2"  >&nbsp; if (pid == -1) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("Can't fork process");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; if (!pid) {</font></div><div><font size="2"  >&nbsp; &nbsp; dup2(fd[1], 1);</font></div><div><font size="2"  >&nbsp; &nbsp; close(fd[0]);</font></div><div><font size="2"  >&nbsp; &nbsp; if (execle("/usr/bin/python", "/usr/bin/python", "./rssgossip.py", "-u", phrase, NULL, vars) == -1) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; error("Can't run script");</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; dup2(fd[0], 0);</font></div><div><font size="2"  >&nbsp; close(fd[1]);</font></div><div><font size="2"  >&nbsp; char line[255];</font></div><div><font size="2"  >&nbsp; while ( fgets(line, 255, stdin) ) {</font></div><div><font size="2"  >&nbsp; &nbsp; if (line[0] == '\t')</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; open_url(line + 1);</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div><br></div><div>Q: Can parents speak to children?</div><div>A: Absolutely. There is no reason why you can't connect your pipes the other way around, so that the parent sends data to the child process.</div><div><br></div><div>Q: Can you have a pipe that works in both directions at once? That way, my parent and child processes could have a two-way conversation.</div><div>A: No, you can't do that. Pipes always work in only one direction. But you can create two pipes: one from the parent to the child, and one from the child to the parent. (or use mkfifo, shared pipe, can read write parallel with some processes)</div><div><br></div><div>【参考】</div><div>fgets</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;fgetc, fgets, getc, getchar, gets, ungetc - input of characters and strings</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;stdio.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int fgetc(FILE *stream);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;char *fgets(char *s, int size, FILE *stream);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int getc(FILE *stream);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int getchar(void);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;char *gets(char *s);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int ungetc(int c, FILE *stream);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;fgetc() &nbsp;reads &nbsp;the next character from stream and returns it as an unsigned char cast to an int, or EOF on end</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;of file or error.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;getc() is equivalent to fgetc() except that it may be implemented as a macro which evaluates stream &nbsp;more &nbsp;than</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;once.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;getchar() is equivalent to getc(stdin).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;it replaces with ’\0’. &nbsp;No check for buffer overrun is performed (see BUGS below).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;fgets() reads in at most one less than size characters from stream and stores them into the buffer &nbsp;pointed &nbsp;to</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;by s. &nbsp;Reading stops after an EOF or a newline. &nbsp;If a newline is read, it is stored into the buffer. &nbsp;A ’\0’ is</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;stored after the last character in the buffer.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;ungetc() pushes c back to stream, cast to unsigned char, where it is available for subsequent read &nbsp;operations.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Pushed-back characters will be returned in reverse order; only one pushback is guaranteed.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Calls to the functions described here can be mixed with each other and with calls to other input functions from</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the stdio library for the same input stream.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;For non-locking counterparts, see unlocked_stdio(3).</font></div></div><div><div><font size="2"  >RETURN VALUE</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;fgetc(), getc() and getchar() return the character read as an unsigned char cast to an int or &nbsp;EOF &nbsp;on &nbsp;end &nbsp;of</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;file or error.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;<font style="background-color: rgb(0, 0, 0);"  color="#99cc00"  >gets() &nbsp;and &nbsp;fgets() return s on success, and NULL on error or when end of file occurs while no characters have</font></font></div><div><font size="2"  style="background-color: rgb(0, 0, 0);"  color="#99cc00"  >&nbsp; &nbsp; &nbsp; &nbsp;been read.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;ungetc() returns c on success, or EOF on error.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >CONFORMING TO</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;C89, C99. &nbsp;LSB deprecates gets().</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >BUGS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Never use gets(). &nbsp;Because it is impossible to tell without knowing the data in &nbsp;advance &nbsp;how &nbsp;many &nbsp;characters</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;gets() &nbsp;will &nbsp;read, &nbsp;and &nbsp;because &nbsp;gets() &nbsp;will &nbsp;continue to store characters past the end of the buffer, it is</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;extremely dangerous to use. &nbsp;It has been used to break computer security. &nbsp;Use fgets() instead.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;It is not advisable to mix calls to input functions from the stdio library with low-level calls to &nbsp;read() &nbsp;for</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the &nbsp;file descriptor associated with the input stream; the results will be undefined and very probably not what</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;you want.</font></div></div><p></p></pre></div><div><br></div><div><br></div><wbr></div>
	</div>
</div>
</body>
</html>