<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">wake-up signal SIGALRM from alarm() or setitimer().  SIG_DFL & SIG_IGN</h2>
	<h5 id="">2012-08-21 9:28:06&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201272183535173/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>SIGALRM信号, 一般可以由alarm或者setitmer来发出。 可以用于定多长时间触发一个事件.</div><div>例如在等待用户输入时, 超过多少秒就触发这个信号. 在触发后, 用户输入被中断, 跳转到信号处理函数, 信号处理函数结束后, 接着用户输入的下一个语句执行, 用户输入不再执行. 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat a.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;signal.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >#define TIMEOUT 5</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void error(char * msg) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "%s: %s\n", msg, strerror(errno));</font></div><div><font size="2"  >&nbsp; exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void alrm_handler(int sig) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "sig:%i, Sorry, TIME IS UP. Please enter your name within %i second.\n", sig, TIMEOUT);</font></div><div><font size="2"  >&nbsp; alarm(TIMEOUT);</font></div><div><font size="2"  >&nbsp; //exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int reg_handler(int sig, void (*handler)(int)) {</font></div><div><font size="2"  >&nbsp; struct sigaction action;</font></div><div><font size="2"  >&nbsp; action.sa_handler = handler;</font></div><div><font size="2"  >&nbsp; sigemptyset(&amp;action.sa_mask);</font></div><div><font size="2"  >&nbsp; action.sa_flags = 0;</font></div><div><font size="2"  >&nbsp; return sigaction(sig, &amp;action, NULL);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; char fname[80];</font></div><div><font size="2"  >&nbsp; char lname[80];</font></div><div><font size="2"  >&nbsp; alarm(TIMEOUT);</font></div><div><font size="2"  >&nbsp; if( reg_handler(SIGALRM, alrm_handler) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("reg_handler error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "please enter your first name: ");</font></div><div><font size="2"  >&nbsp; fgets(fname, 80, stdin);</font></div><div><font size="2"  >&nbsp; // 第一次超时后, 从下面开始执行.</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "please enter your last name: ");</font></div><div><font size="2"  >&nbsp; fgets(lname, 80, stdin);</font></div><div><font size="2"  >&nbsp; // 第二次超时后, 从下面开始执行.</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "Hello, %s.%s\n", lname, fname);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>执行 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o a</font></div></div><div><div><font size="2"  >[root@db-172-16-3-150 zzz]# ./a</font></div><div><font size="2"  >please enter your first name: sig:14, Sorry, TIME IS UP. Please enter your name within 5 second.&nbsp;</font></div><div><font size="2"  >please enter your last name: sig:14, Sorry, TIME IS UP. Please enter your name within 5 second.</font></div><div><font size="2"  >Hello, ?</font></div></div><p></p></pre></div><div><div>注意这个程序有问题, 因为每隔5秒就会触发这个信号.</div></div><div>应该改成 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat a.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;signal.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >#define TIMEOUT 5</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void error(char * msg) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "%s: %s\n", msg, strerror(errno));</font></div><div><font size="2"  >&nbsp; exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void alrm_handler(int sig) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "sig:%i, Sorry, TIME IS UP. Please enter your name within %i second.\n", sig, TIMEOUT);</font></div><div><font size="2"  >&nbsp; // 一般在信号处理函数中使用exit,&nbsp;<span style="line-height: 22px;"  >这么做的话程序就直接退出了.&nbsp;</span>当然你可以选择不用. 例如定时执行其他任务的, 就不需要exit.&nbsp;</font></div><div><font size="2"  >&nbsp; exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int reg_handler(int sig, void (*handler)(int)) {</font></div><div><font size="2"  >&nbsp; struct sigaction action;</font></div><div><font size="2"  >&nbsp; action.sa_handler = handler;</font></div><div><font size="2"  >&nbsp; sigemptyset(&amp;action.sa_mask);</font></div><div><font size="2"  >&nbsp; action.sa_flags = 0;</font></div><div><font size="2"  >&nbsp; return sigaction(sig, &amp;action, NULL);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; char fname[80];</font></div><div><font size="2"  >&nbsp; char lname[80];</font></div><div><font size="2"  >&nbsp; if( reg_handler(SIGALRM, alrm_handler) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("reg_handler error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; alarm(TIMEOUT);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "please enter your first name: ");</font></div><div><font size="2"  >&nbsp; fscanf(stdin, "%80s", fname);</font></div><div><font size="2"  >&nbsp; // 时间在这里剩余2秒时, 重新调用alarm(TIMEOUT) 又会把计时器调整为5秒, &nbsp;覆盖前面的剩余时间.&nbsp;</font></div><div><font size="2"  >&nbsp; alarm(TIMEOUT);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "please enter your last name: ");</font></div><div><font size="2"  >&nbsp; fscanf(stdin, "%80s", lname);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "Hello, %s.%s\n", lname, fname);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div><br></div><div>在程序中要忽略某些信号或者要还原信号处理函数怎么办呢?</div><div><div><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >sa_handler specifies the action to be associated with signum and may be SIG_DFL for the default action, SIG_IGN</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;to ignore this signal, or a pointer to a signal handling function. &nbsp;This function receives the signal number as</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;its only argument.</font></div><p></p></pre></div></div><div style="line-height: 22px;"  ><br></div><div>如果在程序中要忽略对信号的响应. 使用如下方法 :&nbsp;</div><div><span style="line-height: 22px;"  >reg_handler(SIGALRM, SIG_IGN), 表示遇到SIGALRM信号不作任何响应.</span></div><div><span style="line-height: 22px;"  >例如在以上代码中添加</span></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; if( reg_handler(SIGINT, SIG_IGN) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("reg_handler error");</font></div><div><font size="2"  >&nbsp; }</font></div><p></p></pre></div><div style="line-height: 22px;"  >则在程序执行过程中使用 "kill -INT 进程号", 或者"键入CTRL+C" 都无响应.</div></div><div><br></div><div>如果在程序中要还原原来的signal handler, 使用如下 :&nbsp;</div><div><span style="line-height: 22px;"  >reg_handler(SIGINT, SIG_DFL);</span></div><div><br></div><div>注意,&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;sigaction - examine and change a signal action</font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;signal.h&gt;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The sigaction() system call is used to change the action taken by a process on receipt of a specific signal.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;signum specifies the signal and can be any valid signal except SIGKILL and SIGSTOP.</font></div><p></p></pre></div><div>因为SIGKILL和SIGSTOP信号不能调用sigaction注册handler function. 所以也就不存在忽略这两个信号的可能了.</div><div><br></div><div>下面的例子, 问问题, 如果5秒内未答出则超时, 并raise(SIGINT) , 调用end_game结束程序. 或者直接ctrl+c 发出SIGINT信号调用end_game结束程序 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat a.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;time.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;signal.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >#define TIMEOUT 5</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int score = 0;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void end_game(int sig) {</font></div><div><font size="2"  >&nbsp; printf("\nsig:%i, Final score: %i\n", sig, score);</font></div><div><font size="2"  >&nbsp; exit(0);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int catch_signal (int sig, void (*handler)(int)) {</font></div><div><font size="2"  >&nbsp; struct sigaction action;</font></div><div><font size="2"  >&nbsp; action.sa_handler = handler;</font></div><div><font size="2"  >&nbsp; sigemptyset(&amp;action.sa_mask);</font></div><div><font size="2"  >&nbsp; action.sa_flags = 0;</font></div><div><font size="2"  >&nbsp; return sigaction (sig, &amp;action, NULL);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void times_up(int sig) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "\nsig:%i, TIME'S UP!", sig);</font></div><div><font size="2"  >&nbsp; raise(SIGINT);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void error(char *msg) {</font></div><div><font size="2"  >&nbsp; fprintf(stderr, "%s: %s\n", msg, strerror(errno));</font></div><div><font size="2"  >&nbsp; exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; catch_signal(SIGALRM, times_up);</font></div><div><font size="2"  >&nbsp; catch_signal(SIGINT, end_game);</font></div><div><font size="2"  >&nbsp; srandom (time (0));</font></div><div><font size="2"  >&nbsp; while(1) {</font></div><div><font size="2"  >&nbsp; &nbsp; int a = random() % 11;</font></div><div><font size="2"  >&nbsp; &nbsp; int b = random() % 11;</font></div><div><font size="2"  >&nbsp; &nbsp; char txt[4];</font></div><div><font size="2"  >&nbsp; &nbsp; alarm(TIMEOUT);</font></div><div><font size="2"  >&nbsp; &nbsp; printf("\nWhat is %i times %i? ", a, b);</font></div><div><font size="2"  >&nbsp; &nbsp; fgets(txt, 4, stdin);</font></div><div><font size="2"  >&nbsp; &nbsp; int answer = atoi(txt);</font></div><div><font size="2"  >&nbsp; &nbsp; if (answer == a * b)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; score++;</font></div><div><font size="2"  >&nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; printf("\nWrong! Score: %i\n", score);</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div><br></div><div>其他 :</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >Q: Are signals always received in the same order they are sent?</font></div><div><font size="2"  >A: Not if they are sent very close together.&nbsp;</font></div><div><font size="2"  >The operating system might choose to reorder the signals if it thinks one is more important than the others.</font></div><div><font size="2"  >Q: Is that always true?</font></div><div><font size="2"  >A: It depends on the platform.&nbsp;</font></div><div><font size="2"  >On most versions of Cygwin, for example, the signals will always be sent and received in the same order.&nbsp;</font></div><div><font size="2"  >But in general, you shouldn’t rely on it.</font></div><div><font size="2"  >Q: If I send the same signal twice, will it be received twice by the process?</font></div><div><font size="2"  >A: Again, it depends.&nbsp;</font></div><div><font size="2"  >On Linux and the Mac, if the same signal is repeated very quickly, the kernel might choose to only send the signal once to the process.&nbsp;</font></div><div><font size="2"  >On Cygwin, it will always send both signals.&nbsp;</font></div><div><font size="2"  >But again, you should not assume that just because you sent the same signal twice, it will be received twice</font></div><p></p></pre></div><div><br></div><div>【参考】</div><div>setitimer :&nbsp;</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201272041953707/"  >http://blog.163.com/digoal@126/blog/static/163877040201272041953707/</a> </div><div><br></div><wbr></div>
	</div>
</div>
</body>
</html>