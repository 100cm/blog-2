<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Interprocess communication - 1 data stream</h2>
	<h5 id="">2012-08-20 9:41:37&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020127208324853/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">当进程间可以共享数据, 并且可以等待其他进程是否执行完毕时, 程序将变得更加强大.<div>显然共享数据和等待都是内部进程通信的范畴, 这里主要讲一下 data stream.</div><div>每个进程都有一个descriptor table, 这个表包含了file descriptor(a number) 和 data stream的映射关系. 如图 :&nbsp;</div><div><div><img title="Interprocess communication - 1 data stream - 德哥@Digoal - The Heart,The World."  alt="Interprocess communication - 1 data stream - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img7.ph.126.net/BCoLbyzWqDvh-ULcFTsYtA==/2283043536117025387.jpg"  ></div><pre class="prettyprint"  ><p><font size="2"  >&nbsp; &nbsp; A file descriptor is a number that represents a data stream.</font></p></pre></div><div>&nbsp; &nbsp; 默认会有3条映射关系, 0, 1 , 2 分别代表stdin, stdout, stderr.</div><div>&nbsp; &nbsp; 这里的映射关系可以通过dup2 系统函数来修改, 例如要把Database connection 这个data stream放到1对应的data stream上. 执行 dup2(3,1) .</div><div>&nbsp; &nbsp; 当使用open打开一个文件的时候, 会在descriptor table里面寻找有没有空的slot, 找到数值最小的空闲slot, 然后在这个file descriptor上建立一条映射. 这个descriptor table最大可以存储255条映射.</div><div>&nbsp; &nbsp; 在命令行中使用&gt; &lt;进行重定向时 , 例如 :&nbsp;</div><div>&nbsp; &nbsp; &nbsp; 1&gt;? 表示标准输出重定向到?, &nbsp; &nbsp;</div><div>&nbsp; &nbsp; &nbsp; 2&gt;?表示标准错误重定向到?. &nbsp;</div><div>&nbsp; &nbsp; &nbsp; 还可以使用&amp;1,&amp;2.&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;例如2&gt;? 1&gt;&amp;2 表示标准错误重定向到?, 并且标准输出重定向到标准错误.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 ~]# ls -al 1&gt;./ls.log 2&gt;&amp;1</font></div><div><font size="2"  >[root@db-172-16-3-150 ~]# cat ls.log</font></div><div><font size="2"  >total 15216</font></div><div><font size="2"  >drwxr-x--- 16 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; 4096 Aug 20 08:15 .</font></div><div><font size="2"  >drwxr-xr-x 31 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; 4096 Jun 14 12:42 ..</font></div><div><font size="2"  >-rw------- &nbsp;1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; 1812 Oct 21 &nbsp;2011 anaconda-ks.cfg</font></div><div><font size="2"  >-rw------- &nbsp;1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp;25321 Aug 19 21:32 .bash_history</font></div><div><font size="2"  >-rw-r--r-- &nbsp;1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 24 Jan &nbsp;6 &nbsp;2007 .bash_logout</font></div><div><font size="2"  >-rw-r--r-- &nbsp;1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;224 Dec 30 &nbsp;2011 .bash_profile</font></div><div><font size="2"  >-rw-r--r-- &nbsp;1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;176 Jan &nbsp;6 &nbsp;2007 .bashrc</font></div><p></p></pre></div><div><br></div><div>&nbsp; &nbsp; 接下来这个程序使用fopen创建一个文件数据流, 并使用dup2将这个数据流放置到 file descriptor= 1 (也就是stdout) 的条目上. 然后往stdout和这个FILE data stream分别写入一条消息. 看看是不是都会写入同一个文件.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat c.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >// 打印错误消息的函数</font></div><div><font size="2"  >void error(char * msg) {</font></div><div><font size="2"  >&nbsp; fprintf(stderr, "%s: %s\n", msg, strerror(errno));</font></div><div><font size="2"  >&nbsp; exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; // 新建一个FILE data stream.</font></div><div><font size="2"  >&nbsp; FILE * my_file = fopen("/tmp/my_file.log", "a+");</font></div><div><font size="2"  >&nbsp; if ( my_file == NULL ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("open my_file error.");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; // fileno()获取file descriptor.</font></div><div><font size="2"  >&nbsp; int fd = fileno(my_file);</font></div><div><font size="2"  >&nbsp; // 使用dup2 将my_file的 file descriptor对应的data stream 拷贝到1对应的data stream位置. 替换原来的1对应的stdin</font></div><div><font size="2"  >&nbsp; if( dup2(fd, 1) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("dup2 fd to 1 error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; // 分别打印到stdout 和 my_file data stream.</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this message will write to /tmp/my_file.log by stdout data stream.\n");</font></div><div><font size="2"  >&nbsp; fprintf(my_file, "this message will write to /tmp/my_file.log by my_file FILE data stream.\n");</font></div><div><font size="2"  >&nbsp; // 同步数据到硬盘.</font></div><div><font size="2"  >&nbsp; if ( fdatasync(fd) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("fdatasync(fd) error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; // 关闭my_file数据流.</font></div><div><font size="2"  >&nbsp; if ( fclose(my_file) == EOF ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("fclose(my_file) error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>编译 :&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./c.c -o c</font></p></pre></div><div>执行 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# ./c</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat /tmp/my_file.log&nbsp;</font></div><div><font size="2"  >this message will write to /tmp/my_file.log by my_file FILE data stream.</font></div><div><font size="2"  >this message will write to /tmp/my_file.log by stdout data stream.</font></div><p></p></pre></div><div>使用fprintf写入 stdout和my_file 都写到了<span style="line-height: 22px;"  >/tmp/my_file.log&nbsp;</span></div><div><span style="line-height: 22px;"  ><br></span></div><div><span style="line-height: 22px;"  >下面穿插一个 fork 和 waitpid 的使用场景.</span></div><div><span style="line-height: 22px;"  >为什么主进程要等待子进程执行完毕呢?&nbsp;</span></div><div><span style="line-height: 22px;"  >来看个例子 :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat c.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;sys/wait.h&gt;</font></div><div><font size="2"  >#include &lt;sys/types.h&gt;</font></div><div><font size="2"  >// 要fork的子进程个数</font></div><div><font size="2"  >#define MAX_PROCESS 200</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >// 错误输出函数</font></div><div><font size="2"  >void error(char * msg) {</font></div><div><font size="2"  >&nbsp; fprintf(stderr, "%s: %s\n", msg, strerror(errno));</font></div><div><font size="2"  >&nbsp; exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; // 创建一个FILE data stream</font></div><div><font size="2"  >&nbsp; FILE * my_file = fopen("/tmp/my_file.log", "a+");</font></div><div><font size="2"  >&nbsp; if ( my_file == NULL ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("open my_file error.");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; int fd = fileno(my_file);</font></div><div><font size="2"  >&nbsp; if( dup2(fd, 1) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("dup2 fd to 1 error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; pid_t p[MAX_PROCESS];</font></div><div><font size="2"  >&nbsp; int i;</font></div><div><font size="2"  >&nbsp; for (i=0; i&lt;MAX_PROCESS; i++) {</font></div><div><font size="2"  >&nbsp; &nbsp; p[i] = fork();</font></div><div><font size="2"  >&nbsp; &nbsp; // 子进程执行以下</font></div><div><font size="2"  >&nbsp; &nbsp; if ( p[i] == 0 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; // sleep(100) 模拟子进程执行过程要100秒.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; sleep(100);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(stdout, "%i, this message will write to /tmp/my_file.log by stdout data stream.\n", i);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(my_file, "%i, this message will write to /tmp/my_file.log by my_file FILE data stream.\n", i);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; if ( fdatasync(fd) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("fdatasync(fd) error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; if ( fclose(my_file) == EOF ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("fclose(my_file) error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>执行 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./c.c -o c</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# ./c</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat /tmp/my_file.log&nbsp;</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]#&nbsp;</font></div><p></p></pre></div><div>没有任何内容, 因为子进程还在执行, 并没有往/tmp/my_file.log写入任何信息.</div><div>等待100秒后再次查看这个文件的内容就有了.</div><div>像这种场景, 如果主进程等待子进程执行结束则不会发生误解.&nbsp;</div><div>修改代码如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat c.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;sys/wait.h&gt;</font></div><div><font size="2"  >#include &lt;sys/types.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >#define MAX_PROCESS 200</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void error(char * msg) {</font></div><div><font size="2"  >&nbsp; fprintf(stderr, "%s: %s\n", msg, strerror(errno));</font></div><div><font size="2"  >&nbsp; exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; FILE * my_file = fopen("/tmp/my_file.log", "a+");</font></div><div><font size="2"  >&nbsp; if ( my_file == NULL ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("open my_file error.");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; int fd = fileno(my_file);</font></div><div><font size="2"  >&nbsp; if( dup2(fd, 1) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("dup2 fd to 1 error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; pid_t p[MAX_PROCESS];</font></div><div><font size="2"  >&nbsp; // 存储子进程返回的状态, 注意这不仅仅包含返回值, 还有其他信息. 只是用了int类型来存储, 其实前8个bit位存储的才是返回值 .</font></div><div><font size="2"  >&nbsp; // 推荐使用WEXITSTATUS()来获取这个返回值.</font></div><div><font size="2"  >&nbsp; int p_stat[MAX_PROCESS];</font></div><div><font size="2"  >&nbsp; int i;</font></div><div><font size="2"  >&nbsp; for (i=0; i&lt;MAX_PROCESS; i++) {</font></div><div><font size="2"  >&nbsp; &nbsp; p[i] = fork();</font></div><div><font size="2"  >&nbsp; &nbsp; if ( p[i] == 0 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; sleep(100);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(stdout, "%i, this message will write to /tmp/my_file.log by stdout data stream.\n", i);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(my_file, "%i, this message will write to /tmp/my_file.log by my_file FILE data stream.\n", i);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; // 主进程将等待所有子进程结束. 才继续.</font></div><div><font size="2"  >&nbsp; for (i=0; i&lt;MAX_PROCESS; i++) {</font></div><div><font size="2"  >&nbsp; &nbsp; if ( waitpid(p[i], &amp;p_stat[i], 0) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; error("waitpid error");</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; if (WIFEXITED(p_stat[i])) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; printf("exited, status=%d\n", WEXITSTATUS(p_stat[i]));</font></div><div><font size="2"  >&nbsp; &nbsp; } else if (WIFSIGNALED(p_stat[i])) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; printf("killed by signal %d\n", WTERMSIG(p_stat[i]));</font></div><div><font size="2"  >&nbsp; &nbsp; } else if (WIFSTOPPED(p_stat[i])) {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; printf("stopped by signal %d\n", WSTOPSIG(p_stat[i]));</font></div><div><font size="2"  >&nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; //</font></div><div><font size="2"  >&nbsp; if ( fdatasync(fd) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("fdatasync(fd) error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; if ( fclose(my_file) == EOF ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("fclose(my_file) error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>如果waitpid等待的进程号不是子进程的进程号会怎么样呢?</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat c.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;sys/wait.h&gt;</font></div><div><font size="2"  >#include &lt;sys/types.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >// 错误输出函数</font></div><div><font size="2"  >void error(char * msg) {</font></div><div><font size="2"  >&nbsp; fprintf(stderr, "%s: %s\n", msg, strerror(errno));</font></div><div><font size="2"  >&nbsp; exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; int p_stat;</font></div><div><font size="2"  >&nbsp; waitpid((pid_t) 1, &amp;p_stat, 0);</font></div><div><font size="2"  >&nbsp; if (WIFEXITED(p_stat)) {</font></div><div><font size="2"  >&nbsp; &nbsp; printf("exited, status=%d\n", WEXITSTATUS(p_stat));</font></div><div><font size="2"  >&nbsp; } else if (WIFSIGNALED(p_stat)) {</font></div><div><font size="2"  >&nbsp; &nbsp; printf("killed by signal %d\n", WTERMSIG(p_stat));</font></div><div><font size="2"  >&nbsp; } else if (WIFSTOPPED(p_stat)) {</font></div><div><font size="2"  >&nbsp; &nbsp; printf("stopped by signal %d\n", WSTOPSIG(p_stat));</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><span style="line-height: 19px;"  >结果 : </span></font></div><div><span style="font-size: small;"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./c.c -o c &amp;&amp; ./c</span></div><div><font size="2"  >killed by signal 52</font></div><p></p></pre></div><div><br></div><div>【参考】</div><div>dup, dup2 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;dup, dup2 - duplicate a file descriptor</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;unistd.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int dup(int oldfd);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int dup2(int oldfd, int newfd);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;dup() and dup2() create a copy of the file descriptor oldfd.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;After &nbsp;a &nbsp;successful return from dup() or dup2(), the old and new file descriptors may be used interchangeably.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;They refer to the same open file description (see open(2)) and thus share file offset and &nbsp;file &nbsp;status &nbsp;flags;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;for &nbsp;example, &nbsp;if &nbsp;the &nbsp;file offset is modified by using lseek(2) on one of the descriptors, the offset is also</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;changed for the other.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The two descriptors do not share file descriptor &nbsp;flags &nbsp;(the &nbsp;close-on-exec &nbsp;flag). &nbsp; The &nbsp;close-on-exec &nbsp;flag</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;(FD_CLOEXEC; see fcntl(2)) for the duplicate descriptor is off.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;dup() uses the lowest-numbered unused descriptor for the new descriptor.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;dup2() makes newfd be the copy of oldfd, closing newfd first if necessary.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >RETURN VALUE</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;dup() &nbsp;and &nbsp;dup2() return the new descriptor, or -1 if an error occurred (in which case, errno is set appropri-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;ately).</font></div><p></p></pre></div><div>wait, waitpid</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;wait, waitpid - wait for process to change state</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;sys/types.h&gt;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;sys/wait.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;pid_t wait(int *status);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;pid_t waitpid(pid_t pid, int *status, int options);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;All &nbsp;of &nbsp;these &nbsp;system &nbsp;calls &nbsp;are used to wait for state changes in a child of the calling process, and obtain</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;information about the child whose state has changed. &nbsp;A state change is considered to be: the child terminated;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the &nbsp;child &nbsp;was &nbsp;stopped by a signal; or the child was resumed by a signal. &nbsp;In the case of a terminated child,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;performing a wait allows the system to release the resources associated with the child; if a wait is &nbsp;not &nbsp;per-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;formed, then terminated the child remains in a "zombie" state (see NOTES below).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;If a child has already changed state, then these calls return immediately. &nbsp;Otherwise they block until either a</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;child changes state or a signal handler interrupts the call (assuming that system calls are &nbsp;not &nbsp;automatically</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;restarted &nbsp;using &nbsp;the SA_RESTART flag of sigaction(2)). &nbsp;In the remainder of this page, a child whose state has</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;changed and which has not yet been waited upon by one of these system calls is termed waitable.</font></div><p></p></pre></div><div>fopen</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;fopen, fdopen, freopen - stream open functions</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;stdio.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;FILE *fopen(const char *path, const char *mode);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;FILE *fdopen(int fildes, const char *mode);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;FILE *freopen(const char *path, const char *mode, FILE *stream);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The &nbsp;fopen() &nbsp;function &nbsp;opens the file whose name is the string pointed to by path and associates a stream with</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;it.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The argument mode points to a string beginning with one of the following sequences (Additional &nbsp;characters &nbsp;may</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;follow these sequences.):</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;r &nbsp; &nbsp; &nbsp;Open text file for reading. &nbsp;The stream is positioned at the beginning of the file.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;r+ &nbsp; &nbsp; Open for reading and writing. &nbsp;The stream is positioned at the beginning of the file.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;w &nbsp; &nbsp; &nbsp;Truncate file to zero length or create text file for writing. &nbsp;The stream is positioned at the beginning</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of the file.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;w+ &nbsp; &nbsp; Open for reading and writing. &nbsp;The file is created if it does not exist, otherwise it is truncated. &nbsp;The</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream is positioned at the beginning of the file.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;a &nbsp; &nbsp; &nbsp;Open &nbsp;for &nbsp;appending (writing at end of file). &nbsp;The file is created if it does not exist. &nbsp;The stream is</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; positioned at the end of the file.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;a+ &nbsp; &nbsp; Open for reading and appending (writing at end of file). &nbsp;The file is created if it does not exist. &nbsp;The</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initial &nbsp;file position for reading is at the beginning of the file, but output is always appended to the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end of the file.</font></div><p></p></pre></div><div>fclose</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;fclose - close a stream</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;stdio.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int fclose(FILE *fp);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The fclose() function will flush the stream pointed to by fp (writing any buffered output data using fflush(3))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;and close the underlying file descriptor.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >RETURN VALUE</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Upon successful completion 0 is returned. &nbsp;Otherwise, EOF is returned and the global variable errno is &nbsp;set &nbsp;to</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;indicate &nbsp;the &nbsp;error. &nbsp; In &nbsp;either &nbsp;case &nbsp;any further access (including another call to fclose()) to the stream</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;results in undefined behaviour.</font></div><p></p></pre></div><div>fsync, fdatasync</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;fsync, fdatasync - synchronize a file’s in-core state with storage device</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;unistd.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int fsync(int fd);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int fdatasync(int fd);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;fsync() &nbsp;transfers &nbsp;("flushes") &nbsp;all &nbsp;modified in-core data of (i.e., modified buffer cache pages for) the file</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;referred to by the file descriptor fd to the disk device (or other permanent storage device) &nbsp;where &nbsp;that &nbsp;file</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;resides. &nbsp; The call blocks until the device reports that the transfer has completed. &nbsp;It also flushes &nbsp;metadata</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;information associated with the file (see stat(2)).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Calling fsync() does not necessarily ensure that the entry in &nbsp;the &nbsp;directory &nbsp;containing &nbsp;the &nbsp;file &nbsp;has &nbsp;also</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;reached disk. &nbsp;For that an explicit fsync() on a file descriptor for the directory is also needed.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;fdatasync() is similar to fsync(), but does not flush modified metadata unless that metadata is needed in order</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;to allow a subsequent data retrieval to be correctly handled. &nbsp;For example, changes &nbsp;to &nbsp;st_atime &nbsp;or &nbsp;st_mtime</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;(respectively, &nbsp;time &nbsp;of &nbsp;last &nbsp;access &nbsp;and time of last modification; see stat(2)) do not not require flushing</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;because they are not necessary for a subsequent data read to be handled correctly. &nbsp;On the other hand, a change</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;to the file size (st_size, as made by say ftruncate(2)), would require a metadata flush.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The aim of fdatasync(2) is to reduce disk activity for applications that do not require all metadata to be syn-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;chronised with the disk.</font></div><p></p></pre></div><div>exit</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;_exit, _Exit - terminate the current process</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;unistd.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;void _exit(int status);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;stdlib.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;void _Exit(int status);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The &nbsp;function &nbsp;_exit() terminates the calling process "immediately". Any open file descriptors belonging to the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;process are closed; any children of the process are inherited by process 1, init, and the process’s &nbsp;parent &nbsp;is</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;sent a SIGCHLD signal.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The value status is returned to the parent process as the process’s exit status, and can be collected using one</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;of the wait() family of calls.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The function _Exit() is equivalent to _exit().</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >RETURN VALUE</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;These functions do not return.</font></div><p></p></pre></div><div>fileno</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;clearerr, feof, ferror, fileno - check and reset stream status</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;stdio.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;void clearerr(FILE *stream);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int feof(FILE *stream);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int ferror(FILE *stream);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int fileno(FILE *stream);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The function clearerr() clears the end-of-file and error indicators for the stream pointed to by stream.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The &nbsp;function feof() tests the end-of-file indicator for the stream pointed to by stream, returning non-zero if</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;it is set. &nbsp;The end-of-file indicator can only be cleared by the function clearerr().</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The function ferror() tests the error indicator for the stream pointed to by stream, returning non-zero &nbsp;if &nbsp;it</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;is set. &nbsp;The error indicator can only be reset by the clearerr() function.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The function fileno() examines the argument stream and returns its integer descriptor.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;For non-locking counterparts, see unlocked_stdio(3).</font></div><p></p></pre></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br><div><br><wbr></div></div></div>
	</div>
</div>
</body>
</html>