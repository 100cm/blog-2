<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Interprocess communication - 2 signal handler</h2>
	<h5 id="">2012-08-20 22:06:36&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020127204526579/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">内核通过信号来控制程序. 程序接收到信号后, 停止所有事务, 调用handler funciton来响应对应的信号.<div>如图 :&nbsp;</div><div><div><img title="Interprocess communication - 2 signal handler - 德哥@Digoal - The Heart,The World."  alt="Interprocess communication - 2 signal handler - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img0.ph.126.net/glR02aoIJV8LSxJImQYGlw==/2626161532728203040.jpg"  ></div>&nbsp;</div><div>进程有自己的signal mappings table :&nbsp;</div><div><div><img title="Interprocess communication - 2 signal handler - 德哥@Digoal - The Heart,The World."  alt="Interprocess communication - 2 signal handler - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img7.ph.126.net/HohmFa1pJUw9mQWEh-Jclw==/6597139035889755427.jpg"  ></div>&nbsp;</div><div>正因为有了signal mappings table, 所以可以创建自己的handler function , 响应各种信号.</div><div>1. 首先要创建handler函数.</div><div>2. 然后创建一个sigaction结构体, 记录handler function, mask(在执行handler function时不响应其他信号的掩码)等, sa_flag. 具体参考man sigaction.</div><div>结构体如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >struct sigaction {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; void (*sa_handler)(int);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; void (*sa_sigaction)(int, siginfo_t *, void *);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sigset_t sa_mask;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int sa_flags;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; void (*sa_restorer)(void);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div><div>因此自定义的handler函数需要符合 返回值void, 参数int 的要求.</div><div><br></div><div>3. 使用sigaction函数注册第二步创建的结构体以及信号到signal mappings table.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</font></div><div><div><font size="2"  >RETURN VALUE</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;sigaction() returns 0 on success and -1 on error.</font></div></div><p></p></pre></div><div><br></div><div>oldact不关心的话直接使用NULL替代. (If &nbsp;act is non-null, the new action for signal signum is installed from act. &nbsp;If oldact is non-null, the previous action is saved in oldact.)</div><div><br></div><div>例如 :&nbsp;</div><div>写一个 handler function 并注册 SIGINT信号 . 使用 Ctrl+C<span style="line-height: 22px;"  >或者kill -INT 向进程</span>发送SIGINT信号.&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat d.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;signal.h&gt;</font></div><div><font size="2"  >#include &lt;sys/time.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >// 错误输出函数</font></div><div><font size="2"  >void error(char * msg) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "%s: %s\n", msg, strerror(errno));</font></div><div><font size="2"  >&nbsp; exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  ><span style="line-height: 19px;"  >// 自定义的sigint函数.</span></font></div><div><font size="2"  >void sigint (int sig) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "sig:%i, signal sigint received.\n", sig);</font></div><div><font size="2"  >&nbsp; exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >// 注册signal table的函数.</font></div><div><font size="2"  >int reg_signal(int sig, void (*handler)(int) ) {</font></div><div><font size="2"  >&nbsp; struct sigaction action;</font></div><div><font size="2"  >&nbsp; action.sa_handler = handler;</font></div><div><font size="2"  >&nbsp;&nbsp;// 以下表示在handler function执行过程中同样接收其他信号.</font></div><div><font size="2"  >  sigemptyset(&amp;action.sa_mask);</font></div><div><font size="2"  >&nbsp;&nbsp;// 不设置任何sa_flags</font></div><div><font size="2"  >  action.sa_flags = 0;</font></div><div><font size="2"  >  // 注册signal table.</font></div><div><font size="2"  >&nbsp; return sigaction(sig, &amp;action, NULL);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; char name[80];&nbsp;</font></div><div><font size="2"  >&nbsp;&nbsp;// 注册一个处理的SIGINT信号的自定义函数.</font></div><div><font size="2"  >  if( reg_signal(SIGINT, sigint) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("reg_signal error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "please enter your name:");</font></div><div><font size="2"  >&nbsp; fgets(name, 80, stdin);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "hello, %s\n", name);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>执行如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./d.c -o d</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# ./d</font></div><div><font size="2"  >please enter your name:</font></div></div><div><font size="2"  >此时键盘按键ctrl+c, 发出一个SIGINT信号, 结果如下 :&nbsp;</font></div><div><font size="2"  >sig:2, signal sigint received.</font></div><p></p></pre></div><div>当然也可以使用 "kill -INT 进程号". 如kill -INT 2999 , 这里不进行测试.</div><div><br></div><div>signal handler 函数体内如果没有exit()的话, 那么handler函数执行完后, 进程将会接着收到信号开始的那刻继续往后处理. 如果handler函数体内有exit()则会直接退出进程.</div><div>另外就是初始化sigaction 结构体的时候, 有一个设置sa_mask的地方, 如果这里没有设置, 那么signal handler函数处理过程中可以接收其他的信号, 也就是说也可以被打断. 例如下面的例子写了一个无限循环的signal handler过程.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat d.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;signal.h&gt;</font></div><div><font size="2"  >#include &lt;sys/time.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void error(char * msg) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "%s: %s\n", msg, strerror(errno));</font></div><div><font size="2"  >&nbsp; exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void sig_handler (int sig) {</font></div><div><font size="2"  >&nbsp; sleep(1);</font></div><div><font size="2"  >&nbsp; switch(sig) {</font></div><div><font size="2"  >&nbsp; &nbsp; case SIGALRM:</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(stdout, "sig:%i, signal sigalrm received.\n", sig);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; raise(SIGINT);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >&nbsp; &nbsp; case SIGINT:</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(stdout, "sig:%i, signal sigint received.\n", sig); &nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; raise(SIGALRM);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; // fprintf(stdout, "if exit(1) not commeted, this line will printed.");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >&nbsp; &nbsp; default:</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; fprintf(stdout, "sig:%i, this handler cann't handler the singal.\n", sig);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp;&nbsp;fprintf(stdout, "sig:%i outside the switch code.\n", sig);</font></div><div><font size="2"  >&nbsp; // 这里要注意, 如果把exit(1)的注释去掉就会有意想不到的结果. 这个无限循环将被打破.&nbsp;</font></div><div><font size="2"  >&nbsp; //exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int reg_signal(int sig, void (*handler)(int) ) {</font></div><div><font size="2"  >&nbsp; struct sigaction action;</font></div><div><font size="2"  >&nbsp; action.sa_handler = handler;</font></div><div><font size="2"  >&nbsp; sigemptyset(&amp;action.sa_mask);</font></div><div><font size="2"  >&nbsp; action.sa_flags = 0;</font></div><div><font size="2"  >&nbsp; return sigaction(sig, &amp;action, NULL);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; char name[80];&nbsp;</font></div><div><font size="2"  >&nbsp; if( reg_signal(SIGINT, sig_handler) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("reg_signal error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; if( reg_signal(SIGALRM, sig_handler) == -1 ) {</font></div><div><font size="2"  >&nbsp; &nbsp; error("reg_signal error");</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "please enter your name:");</font></div><div><font size="2"  >&nbsp; fgets(name, 80, stdin);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "hello, %s\n", name);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>执行结果 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# ./d</font></div><div><font size="2"  >please enter your name: 键入CTRL+C</font></div><div><span style="line-height: 22px;"  ><font size="2"  >// 1 second elapsed</font></span></div><div><font size="2"  >sig:2, signal sigint received.</font></div><div><font size="2"  >// 1 second elapsed</font></div><div><font size="2"  >sig:14, signal sigalrm received.</font></div><div><font size="2"  >sig:14, outside the switch code.</font></div><div><font size="2"  >sig:2, outside the switch code.</font></div><div><span style="line-height: 22px;"  ><font size="2"  >// 1 second elapsed</font></span></div><div><font size="2"  >sig:2, signal sigint received.</font></div><div><span style="line-height: 22px;"  ><font size="2"  >// 1 second elapsed</font></span></div><div><font size="2"  >sig:14, signal sigalrm received.</font></div><div><font size="2"  >sig:14, outside the switch code.</font></div><div><font size="2"  >sig:2, outside the switch code.</font></div><div><span style="line-height: 22px;"  ><font size="2"  >// 1 second elapsed</font></span></div><div><font size="2"  >sig:2, signal sigint received.</font></div><p></p></pre></div><div>持续循环</div><div>// 从上面的结果看出, kernel在处理多个信号同时触发时.</div><div>// 同时这里还使用了计时器, 考虑到内核的效率问题, 内核给一个进程只分配一个计时器. 如果给一个进程可以有多个计时器的话, 内核管理计时器会非常复杂, 内核变得很慢.</div><div><br></div><div>如果使用kill -ALRM 进程号 会是什么情况呢?</div><div>结果如下 :&nbsp;</div><div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >[root@db-172-16-3-150 zzz]# ./d</font></div><div style="line-height: 22px;"  ><font size="2"  >please enter your name: 另一个会话输入kill -ALRM ./d进程号</font></div><div style="line-height: 22px;"  ><font size="2"  ><span style="line-height: 22px;"  >// 1 second elapsed</span> </font></div><div><div><font size="2"  >sig:14, signal sigalrm received.</font></div><div><font size="2"  ><span style="line-height: 22px;"  >// 1 second elapsed</span> </font></div><div><font size="2"  >sig:2, signal sigint received.</font></div><div><font size="2"  >sig:2, outside the switch code.</font></div><div><font size="2"  >sig:14, outside the switch code.</font></div><div><font size="2"  ><span style="line-height: 22px;"  >// 1 second elapsed</span> </font></div><div><font size="2"  >sig:14, signal sigalrm received.</font></div><div><font size="2"  ><span style="line-height: 22px;"  >// 1 second elapsed</span> </font></div><div><font size="2"  >sig:2, signal sigint received.</font></div><div><font size="2"  >sig:2, outside the switch code.</font></div><div><font size="2"  >sig:14, outside the switch code.</font></div><div><font size="2"  ><span style="line-height: 22px;"  >// 1 second elapsed</span> </font></div><div><font size="2"  >sig:14, signal sigalrm received.</font></div></div><p></p></pre></div><div><div>如此循环.</div></div></div><div>从两次发出的信号得到的结果来看, 内核没有对哪个信号有优先处理的权力.</div><div><br></div><div>将sig_handler函数中的exit(1)注释去掉, 重新编译测试 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# ./d</font></div><div><font size="2"  >please enter your name: 键入CTRL+C</font></div><div><font size="2"  ><span style="line-height: 22px;"  >// 1 second elapsed</span> </font></div><div><font size="2"  >sig:2, signal sigint received.</font></div><div><font size="2"  ><span style="line-height: 22px;"  >// 1 second elapsed</span> </font></div><div><font size="2"  >sig:14, signal sigalrm received.</font></div><div><font size="2"  >sig:14, outside the switch code.</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]# ./d</font></div><div><font size="2"  >please enter your name:另一个SESSION<span style="line-height: 22px;"  >键入kill -ALRM ./d进程号</span></font></div><div><span style="line-height: 22px;"  ><font size="2"  >// 1 second elapsed</font></span></div><div><font size="2"  >sig:14, signal sigalrm received.</font></div><div><font size="2"  ><span style="line-height: 22px;"  >// 1 second elapsed</span> </font></div><div><font size="2"  >sig:2, signal sigint received.</font></div><div><font size="2"  >sig:2, outside the switch code.</font></div><p></p></pre></div><div>从这个结果返回去推算前面没有注释exit(1)的执行结果, 其实信号是一个一个来处理的, 不是并行处理的. 别看前面是3个输出一起出来的. 其实是在一个信号结束后另一个信号才触发的. 如下</div><div><pre class="prettyprint"  style="line-height: 22px;"  ><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >[root@db-172-16-3-150 zzz]# ./d</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >please enter your name: 另一个会话输入kill -ALRM ./d进程号</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  ><span style="line-height: 22px;"  >// 1 second elapsed</span><br></font></div><div style="line-height: 22px;"  ><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >sig:14, signal sigalrm received.</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  ><span style="line-height: 22px;"  >// 1 second elapsed</span><br></font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >sig:2, signal sigint received.</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >sig:2, outside the switch code.</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >// sig:2 sig_handler处理结束</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >sig:14, outside the switch code.</font></div><div style="line-height: 22px;"  ><span style="font-size: small; line-height: 19px;"  >// sig:14 sig_handler处理结束</span><br></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  ><span style="line-height: 22px;"  >// 1 second elapsed</span><br></font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >sig:14, signal sigalrm received.</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  ><span style="line-height: 22px;"  >// 1 second elapsed</span><br></font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >sig:2, signal sigint received.</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >sig:2, outside the switch code.</font></div><div style="line-height: 22px;"  ><span style="font-size: small; line-height: 19px;"  >// sig:2 sig_handler处理结束</span><br></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >sig:14, outside the switch code.</font></div><div style="line-height: 22px;"  ><span style="font-size: small; line-height: 19px;"  >// sig:14 sig_handler处理结束</span><br></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  ><span style="line-height: 22px;"  >// 1 second elapsed</span><br></font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >sig:14, signal sigalrm received.</font></div></div></pre></div><div><br></div><div><br></div><div>常用信号如下 :&nbsp;</div><div><div><img title="Interprocess communication - 2 signal handler - 德哥@Digoal - The Heart,The World."  alt="Interprocess communication - 2 signal handler - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img0.ph.126.net/epm8rQBj-AwdOfRZOiEh0A==/6597148931494416020.jpg"  ></div>&nbsp;</div><div><br></div><div><br></div><div><br></div><div><br></div><div>【注意】</div><div>1. 有两个信号不能自定义handler function , 那就是 SIGSTOP 和 SIGKILL .&nbsp;</div><div><br></div><div><br></div><div><br></div><div><br></div><div>【参考】</div><div>man 7 signal</div><div><a rel="nofollow" href="http://en.wikipedia.org/wiki/Interrupts"  >http://en.wikipedia.org/wiki/Interrupts</a> </div><div><a rel="nofollow" href="http://en.wikipedia.org/wiki/Signal_handler"  >http://en.wikipedia.org/wiki/Signal_handler</a> </div><div><br></div><div><br><br><wbr></div></div>
	</div>
</div>
</body>
</html>