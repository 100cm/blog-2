<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">function's argument is function's local variable, build in stack memory, released when function exit. its value copyed from out variables.</h2>
	<h5 id="">2012-08-08 18:14:01&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012785379974/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">C的函数, 如果它有参数. 参数是怎么传递的.<wbr><div>有这么几点必须明白:</div><div>1. 参数传递时, 函数体内部将在内存stack区域新建作用在这个函数内部的本地变量.</div><div>如 void test1 (char * a) , 这里 a 是函数的本地变量.&nbsp;</div><div>2. 传递的是值, 而不是变量.</div><div>如 test1(b), 函数体里面的 a 是拷贝了b这个变量的值, 而不是b这个变量.</div><div><br></div><div>来做个测试就会明白 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >[root@digoal zzz]# cat a.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >typedef struct fish {</font></div><div><font size="2"  >&nbsp; int age;</font></div><div><font size="2"  >&nbsp; char name[10];</font></div><div><font size="2"  >} fish;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >char * gt1 = "abcdefg";</font></div><div><font size="2"  >char gt2[10] = "abcdefg";</font></div><div><font size="2"  >int gt3 = 100;</font></div><div><font size="2"  >fish gt4 = {20, "linux"};</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void test1 (char * t1) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "&amp;t1:%p, t1:%p, &amp;gt1:%p, gt1:%p\n", &amp;t1, t1, &amp;gt1, gt1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void test2 (char t2[]) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "&amp;t2:%p, t2:%p, &amp;gt2:%p, gt2:%p\n", &amp;t2, t2, &amp;gt2, gt2);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void test3 (int t3) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "&amp;t3:%p, &amp;gt3:%p\n", &amp;t3, &amp;gt3);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void test4 (struct fish t4) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "&amp;t4:%p, &amp;gt4:%p\n", &amp;t4, &amp;gt4);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; test1(gt1);</font></div><div><font size="2"  >&nbsp; test2(gt2);</font></div><div><font size="2"  >&nbsp; test3(gt3);</font></div><div><font size="2"  >&nbsp; test4(gt4);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div></div><div><font size="2"  >结果 :&nbsp;</font></div><div><div><font size="2"  >[root@digoal zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o a &amp;&amp; ./a</font></div><div><font size="2"  >&amp;t1:0x7fff08f00b10, t1:0x400748, &amp;gt1:0x7fff08f00ad0, gt1:0x400748 &nbsp;// 字符串在这里是常量放在constants内存区域, 所以地址比较小. 而变量放在stack区域, 所以地址比较大 .&nbsp;</font></div><div><font size="2"  >&amp;t2:0x7fff08f00b10, t2:0x7fff08f00aec, &amp;gt2:0x7fff08f00aec, gt2:0x7fff08f00aec &nbsp; // 这里要特别注意, 函数体内存储的是个指针变量, 不是数组, 这个指针指向了外部的数组 .&nbsp;</font></div><div><font size="2"  >&amp;t3:0x7fff08f00b1c, &amp;gt3:0x7fff08f00ae8</font></div><div><font size="2"  >&amp;t4:0x7fff08f00b00, &amp;gt4:0x7fff08f00ad8</font></div></div><div><font size="2"  >// 这里我分别测试了指针变量,数组,int型以及结构体 .&nbsp;</font></div><p></p></pre></div><div>结果表明 :&nbsp;</div><div>1. 指针变量作为参数类型时, 传递的是指针存储的地址值. 而指针变量的地址是不一样的, 因为在函数体内的t1的地址与gt1地址不一致.</div><div>2. 数组作为参数类型时(这里要注意, 数组作为参数变量, 这个变量在函数体内部是指针, 也就是失去了数组的特性),&nbsp;</div><div>&nbsp; &nbsp; 传递的是外部数组gt2的地址, 所以地址 (t2 = &amp;gt2 = gt2), &nbsp;(因为数组变量名在编译时替换成地址). 参数变量的地址与参数变量存储的地址不一致. 也说明了参数变量虽然是数组. 但是显然它在函数体内其实是指针. 如果是数组的话, &amp;t2 应该等于 t2.</div><div>3. int作为参数类型时, 传递的是值. 可以看到&amp;t3 不等于 &amp;gt3</div><div>4. 结构体作为参数类型时, 传递的也是值.&nbsp;<span style="line-height: 22px;"  >可以看到&amp;t4 不等于 &amp;gt4 .&nbsp;</span></div><div><span style="line-height: 22px;"  >5. &amp;t1 = &amp;t2 又是为什么呢, 前面说了 函数体内部的变量都放在stack里面, 当函数调用结束就会释放掉, 所以test1 执行完再执行test2 是有可能申请到同一片stack里面的地址的.</span></div><div><span style="line-height: 22px;"  ><br></span></div><div><span style="line-height: 22px;"  >另外要说的是 , 由于是拷贝, 所以我们要特别注意变量存储的是什么东西. 如参数类型是指针, 拷贝过去就是这个指针存储的地址. 所以他们会指向同一个地方。</span></div><div>所以如果结构体中如果有使用数组存储的, 或者指针存储的元素, 他们拷贝的内容是大不一样的.</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@digoal zzz]# cat a.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >typedef struct fish {</font></div><div><font size="2"  >&nbsp; int age;</font></div><div><font size="2"  >&nbsp; char name[10];</font></div><div><font size="2"  >&nbsp; char * nick;</font></div><div><font size="2"  >} fish;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >fish gt4 = {20, "linux", "world"};</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void test4 (struct fish t4) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "&amp;(t4.name):%p, &amp;(gt4.name):%p, t4.name:%p, gt4.name:%p\n", &amp;(t4.name), &amp;(gt4.name), t4.name, gt4.name);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "&amp;(t4.nick):%p, &amp;(gt4.nick):%p, t4.nick:%p, gt4.nick:%p\n", &amp;(t4.nick), &amp;(gt4.nick), t4.nick, gt4.nick);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; test4(gt4);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><div><font size="2"  >结果</font></div><div><font size="2"  >[root@digoal zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o a &amp;&amp; ./a</font></div><div><font size="2"  >&amp;(t4.name):0x7fffed837484, &amp;(gt4.name):0x7fffed8374a4, t4.name:0x7fffed837484, gt4.name:0x7fffed8374a4</font></div><div><font size="2"  >&amp;(t4.nick):0x7fffed837490, &amp;(gt4.nick):0x7fffed8374b0, t4.nick:0x4006e8, gt4.nick:0x4006e8</font></div><p></p></pre></div><div>来解释一下 :&nbsp;</div><div>1.&nbsp;<span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >&amp;(t4.name):0x7fffed837484, &amp;(gt4.name):0x7fffed8374a4 这两个指存放name这个元素的地址. 它们不相等, 是因为函数函数传参是新建本地变量与值拷贝的过程. 所以t4和gt4是放在两块内存区域的, 因此t4和gt4的name它们的存放地当然不一样.</span></div><div><span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >2. </span><span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >t4.name:0x7fffed837484, gt4.name:0x7fffed8374a4 这两个不一样, 因为t4在函数内部是一个全新的结构体变量, 所以t4.name 存储的是数组本身, 而没有退化成指针, 所以拷贝的是数组的内容. 因此可以看出&amp;(t4.name) = t4.name ; &amp;(gt4.name) = gt4.name. 因为数组即地址(多次提到).</span></div><div><span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >3. </span><span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >&amp;(t4.nick):0x7fffed837490, &amp;(gt4.nick):0x7fffed8374b0 这两个不相等 . 和第一条的解释一样.</span></div><div><span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >4. </span><span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >t4.nick:0x4006e8, gt4.nick:0x4006e8 这两个指的是nick这个指针存放的内容转成地址打印出来, 当然是相同的.</span></div><div><span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  ><br></span></div><div><span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >最后, 脑子里有一副内存的图就比较好理解了.</span></div><div><span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  ><br></span></div></div>
	</div>
</div>
</body>
</html>