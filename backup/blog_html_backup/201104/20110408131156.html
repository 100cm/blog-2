<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">About consistent read in PostgreSQL and Oracle</h2>
	<h5 id="">2011-04-08 13:11:56&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402011389384640/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">昨天一位同事问到一个数据库一致性读的问题，如下<br>假设有一个帐户表：<br>tbl_user_account (id int,user_id int,currency_id int,amount int);<br>数据量10亿. 假设SESSION A开始时,sum(amount)=1000亿<br>&nbsp; 所有SESSION隔离级别&nbsp; :&nbsp; ISOLATION LEVEL READ COMMITTED<br>SESSION A : (a long running transaction)<br>select sum(amount) from tbl_user_account ;&nbsp; <br><br>SESSION B : <br>update tbl_user_account set amount=amount+100 where user_id=10000;<br>commit;<br><br>SESSION C : <br>vacuum tbl_user_account;<br><br>long time past.....<br><br>SESSION A : <br>SQL run success.<br>&nbsp; 第一个问题是，结果返回肯定是10亿,而不是10亿+100; 原因很简单,根据TUPLE头部上的XMIN,XMAX，SESSION A看不到SESSION B更新的TUPLE，它看到的是老的TUPLE。<br>&nbsp; 第二个问题是，SESSION C 是否可以清理掉被更新的user_id=10000的老的那条TUPLE呢？答案是不可以。因为VACUUM时会判断当前活动的事务号和TUPLE上的XMIN,XMAX。只要SESSION A没有结束，那么小于等于SESSION A的年龄的TUPLE都不会被VACUUM掉。<br>&nbsp; 假设SESSION A执行时间实在太长了。何时会导致SESSION A执行失败？<br>&nbsp; 不过这种情况基本上不会发生,因为还有freeze相关的参数会强制FREEZE这个表，假设执行SESSION A时的年龄 = 5000W (vacuum_freeze_min_age) 基本上已经是极限大的年龄，那么整个数据库集群还允许SESSION A持续执行直到数据库分配出去接近19.5亿的事务，这个几乎是不可能达到的一个数字 。打个比方，一天分配2亿的事务（平均每秒约3000的事务量）,则允许SESSION A可以执行9天多。<br>&nbsp; 1. 当 age ( pg_class.relfrozenxid ) &gt; 20亿 - 100W 时 , 数据库系统将自动关闭 。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR :  database is not accepting commands to avoid wraparound data loss in database "mydb" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HINT :  Stop the postmaster and use a standalone backend to VACUUM in "mydb" .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在此之前 20亿 - 1000W ，系统将发出警告 .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WARNING :  database "mydb" must be vacuumed within 177009986 transactions <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HINT :  To avoid a database shutdown, execute a database-wide VACUUM in "mydb" .&nbsp; <br>&nbsp; 2. 当设置了 statement_timeout , 超过这个值将阻止执行 , ERROR :&nbsp; canceling statement due to statement timeout 。<br><br>实例:<br>digoal=&gt; select t1.sm+t2.sm+t3.sm+t4.sm+t5.sm+t6.sm from (select sum(id) sm from tbl_user) t1,(select sum(id) sm from tbl_user) t2,(select sum(id) sm from tbl_user) t3,(select sum(id) sm from tbl_user) t4,(select sum(id) sm from tbl_user) t5,(select sum(id) sm from tbl_user) t6;<br>&nbsp;&nbsp;&nbsp; ?column?&nbsp;&nbsp;&nbsp;&nbsp; <br>-----------------<br>&nbsp;189000681003096<br>(1 row)<br><br>Time: 21544.620 ms<br>SESSION A : <br>digoal=&gt; select t1.sm+t2.sm+t3.sm+t4.sm+t5.sm+t6.sm from (select sum(id) sm from tbl_user) t1,(select sum(id) sm from tbl_user) t2,(select sum(id) sm from tbl_user) t3,(select sum(id) sm from tbl_user) t4,(select sum(id) sm from tbl_user) t5,(select sum(id) sm from tbl_user) t6;<br>&nbsp;&nbsp;&nbsp; ?column?&nbsp;&nbsp;&nbsp;&nbsp; <br>-----------------<br>&nbsp;189000681003096<br>(1 row)<br><br>Time: 22062.166 ms<br><br>SESSION B : start before session a return result<br>digoal=&gt; update tbl_user set id=7000011 where id&gt;=7000000;<br>UPDATE 1000001<br>Time: 4775.486 ms<br>digoal=&gt; vacuum freeze verbose tbl_user;<br>INFO:&nbsp; vacuuming "digoal.tbl_user"<br>INFO:&nbsp; index "idx_user" now contains 9999987 row versions in 35108 pages<br>DETAIL:&nbsp; 0 index row versions were removed.<br>5446 index pages have been deleted, 5446 are currently reusable.<br>CPU 0.06s/0.03u sec elapsed 0.09 sec.<br>INFO:&nbsp; "tbl_user": found 0 removable, 10000101 nonremovable row versions in 48674 out of 48674 pages<br>DETAIL:&nbsp; 1000001 dead row versions cannot be removed yet.<br>There were 1000099 unused item pointers.<br>0 pages are entirely empty.<br>CPU 0.11s/0.69u sec elapsed 2.08 sec.<br>VACUUM<br>Time: 3090.838 ms<br>digoal=&gt; select age(relfrozenxid) from pg_class where relname='tbl_user';<br>&nbsp;age <br>-----<br>&nbsp;&nbsp; 1<br>(1 row)<br><br>Time: 0.481 ms<br><br>SESSION B : start after session a return result<br>digoal=&gt; vacuum freeze verbose tbl_user;<br>INFO:&nbsp; vacuuming "digoal.tbl_user"<br>INFO:&nbsp; scanned index "idx_user" to remove 999887 row versions<br>DETAIL:&nbsp; CPU 0.11s/1.06u sec elapsed 1.17 sec.<br>INFO:&nbsp; "tbl_user": removed 999887 row versions in 4425 pages<br>DETAIL:&nbsp; CPU 0.00s/0.02u sec elapsed 0.02 sec.<br>INFO:&nbsp; index "idx_user" now contains 9000100 row versions in 35108 pages<br>DETAIL:&nbsp; 999887 index row versions were removed.<br>8901 index pages have been deleted, 5460 are currently reusable.<br>CPU 0.00s/0.00u sec elapsed 0.00 sec.<br>INFO:&nbsp; "tbl_user": found 1000001 removable, 9000100 nonremovable row versions in 48674 out of 48674 pages<br>DETAIL:&nbsp; 0 dead row versions cannot be removed yet.<br>There were 1000099 unused item pointers.<br>0 pages are entirely empty.<br>CPU 0.11s/1.66u sec elapsed 1.78 sec.<br>VACUUM<br>Time: 1789.878 ms<br>digoal=&gt; select age(relfrozenxid) from pg_class where relname='tbl_user';<br>&nbsp;age <br>-----<br>&nbsp;&nbsp; 0<br>(1 row)<br><br>结果与预期符合。<br><br>Oracle在测试中达到同样的效果，Oracle使用UNDO区域来保存老的镜像数据。<br>但是 假设SESSION A执行时间实在太长了。何时会导致SESSION A执行失败？<br>这个在ORACLE中，如果UNDO表空间不是足够大的话，SESSION A将会执行不下去，报SNAPSHOT TOO OLD的错误。</div>
	</div>
</div>
</body>
</html>