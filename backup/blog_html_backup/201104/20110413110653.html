<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL bgwriter process introduction</h2>
	<h5 id="">2011-04-13 11:06:53&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201131311653113/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">bgwriter 的全称 background writer process .<br>bgwriter的功能分为两类，<br>第一类，<br>写dirty shared buffers , <span>可以减少因缺少空闲buffer而导致的"backend process请求读入新的page时需要写dirty shared buffers"发生。</span>PostgreSQL提供参数调整bgwriter的写频度和写的量的多少。<br>bgwriter的一项工作是用来减轻 backend process 负载的。这样的话backend process可以不用担心申请不到shared buffer而需要亲自来写dirty shared buffers到磁盘从而腾出free shared buffer 。<br>第二类，<br>bgwriter 同时还需要应付所有的checkpoint请求（主动的或被动的）。<br>主动的checkpoint : 每隔一段时间或达到一定的系统设置的阀值之后,bgwriter会主动的开始一次checkpoint,<br>被动的checkpoint : 其他进程请求checkpoint , bgwriter会接收到checkpoint请求的信号,(这些都是通过一个共享的内存区域和checkpoint的FLAG来控制的)<br>在Oracle中checkpoint是由专门的进程来负责,ckpt.而PostgreSQL目前是由bgwriter来兼职做这个事情。<br>从Oracle的进展来看，随着新版本的发布，实例里面也包含越来越多的系统进程，换句话说功能越来越细分，并且新版本往往比以前更加耗内存。<br><br>bgwriter进程的启动与停止，很好理解，如下 :<br>&nbsp;* The bgwriter is started by the postmaster as soon as the startup subprocess<br>&nbsp;* finishes, or as soon as recovery begins if we are doing archive recovery.<br>&nbsp;* It remains alive until the postmaster commands it to terminate.<br>&nbsp;* Normal termination is by SIGUSR2, which instructs the bgwriter to execute<br>&nbsp;* a shutdown checkpoint and then exit(0).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (All backends must be stopped<br>&nbsp;* before SIGUSR2 is issued!)&nbsp; Emergency termination is by SIGQUIT; like any<br>&nbsp;* backend, the bgwriter will simply abort and exit on SIGQUIT.<br><br>bgwriter异常退出的话，数据库将干啥 :<br>&nbsp;* If the bgwriter exits unexpectedly, the postmaster treats that the same<br>&nbsp;* as a backend crash: shared memory may be corrupted, so remaining backends<br>&nbsp;* should be killed by SIGQUIT and then a recovery cycle started.&nbsp; (Even if<br>&nbsp;* shared memory isn't corrupted, we have lost information about which<br>&nbsp;* files need to be fsync'd for the next checkpoint, and so a system<br>&nbsp;* restart needs to be forced.)<br><br>前面有提到一个共享内存区域，用于bgwriter和backend process通信的区域。其中包含如下数据结构 :<br><br>typedef struct<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bgwriter_pid;&nbsp;&nbsp; /* PID of bgwriter (0 if not started) */<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slock_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ckpt_lck;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* protects all the ckpt_* fields */<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ckpt_started;&nbsp;&nbsp; /* advances when checkpoint starts */<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ckpt_done;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* advances when checkpoint done */<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ckpt_failed;&nbsp;&nbsp;&nbsp; /* advances when checkpoint fails */<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ckpt_flags;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* checkpoint flags, as defined in xlog.h */<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_backend_writes;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* counts non-bgwriter buffer writes */<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_requests;&nbsp;&nbsp; /* current # of requests */<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_requests;&nbsp;&nbsp; /* allocated array size */<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BgWriterRequest requests[1];&nbsp;&nbsp;&nbsp; /* VARIABLE LENGTH ARRAY */<br>} BgWriterShmemStruct;<br><br><br>bgwriter是如何处理checkpoint请求的?<br>&nbsp;* The ckpt counters allow backends to watch for completion of a checkpoint<br>&nbsp;* request they send.&nbsp; Here's how it works:<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * At start of a checkpoint, bgwriter reads (and clears) the request flags<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and increments ckpt_started, while holding ckpt_lck.<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * On completion of a checkpoint, bgwriter sets ckpt_done to<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equal ckpt_started.<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * On failure of a checkpoint, bgwriter increments ckpt_failed<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and sets ckpt_done to equal ckpt_started.<br>这里有三个非常重要的字段 : ckpt_started , ckpt_done , ckpt_failed . <br>这三个计数类似于sequence的cycle.是可以循环的，因此比较的时候使用取模后的值。<br><br>backend是如何请求和跟踪checkpoint的?<br>&nbsp;* The algorithm for backends is:<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. Record current values of ckpt_failed and ckpt_started, and<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set request flags, while holding ckpt_lck.<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. Send signal to request checkpoint.<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. Sleep until ckpt_started changes.&nbsp; Now you know a checkpoint has<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begun since you started this algorithm (although *not* that it was<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; specifically initiated by your signal), and that it is using your flags.<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4. Record new value of ckpt_started.<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5. Sleep until ckpt_done &gt;= saved value of ckpt_started.&nbsp; (Use modulo<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arithmetic here in case counters wrap around.)&nbsp; Now you know a<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; checkpoint has started and completed, but not whether it was<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; successful.<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6. If ckpt_failed is different from the originally saved value,<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume request failed; otherwise it was definitely successful.<br>&nbsp;*<br>&nbsp;* ckpt_flags holds the OR of the checkpoint request flags sent by all<br>&nbsp;* requesting backends since the last checkpoint start.&nbsp; The flags are<br>&nbsp;* chosen so that OR'ing is the correct way to combine multiple requests.<br>&nbsp;*<br>&nbsp;* num_backend_writes is used to count the number of buffer writes performed<br>&nbsp;* by non-bgwriter processes.&nbsp; This counter should be wide enough that it<br>&nbsp;* can't overflow during a single bgwriter cycle.<br>&nbsp;*<br>&nbsp;* The requests array holds fsync requests sent by backends and not yet<br>&nbsp;* absorbed by the bgwriter.<br>&nbsp;*<br>&nbsp;* Unlike the checkpoint fields, num_backend_writes and the requests<br>&nbsp;* fields are protected by BgWriterCommLock.<br><br>注意到前面提到的ckpt_flags , 在xlog.c中有以下介绍 :<br>&nbsp;* flags is a bitwise OR of the following :<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHECKPOINT_IS_SHUTDOWN: checkpoint is for database shutdown.<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHECKPOINT_END_OF_RECOVERY: checkpoint is for end of WAL recovery.<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHECKPOINT_IMMEDIATE: finish the checkpoint ASAP,<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ignoring checkpoint_completion_target parameter.<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHECKPOINT_FORCE: force a checkpoint even if no XLOG activity has occured<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; since the last one (implied by CHECKPOINT_IS_SHUTDOWN or<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHECKPOINT_END_OF_RECOVERY).<br>&nbsp;*<br>&nbsp;* Note: flags contains other bits, of interest here only for logging purposes.<br>&nbsp;* In particular note that this routine is synchronous and does not pay<br>&nbsp;* attention to CHECKPOINT_WAIT.<br><br>由于没有办法很方便的能看到FLAG，只能简单的测试一下bgwriter在checkpoint的时候确实是在做事情的：<br>digoal=&gt; create table tbl_test (id int);<br>CREATE TABLE<br>digoal=&gt; insert into tbl_user_info_single select generate_series(1,5000000),'zhou','digoal','sky-mobi',28;<br>INSERT 0 5000000<br>digoal=&gt; checkpoint;<br>ERROR:&nbsp; must be superuser to do CHECKPOINT<br>digoal=&gt; \c digoal postgres<br>You are now connected to database "digoal" as user "postgres".<br>digoal=# checkpoint;<br>CHECKPOINT<br><br>checkpoint的时候top的输出 :<br>&nbsp; PID USER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR&nbsp; NI&nbsp; VIRT&nbsp; RES&nbsp; SHR S %CPU %MEM&nbsp;&nbsp;&nbsp; TIME+&nbsp; COMMAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>17625 postgres&nbsp; 15&nbsp;&nbsp; 0 2328m 2.1g 2.1g S&nbsp; 5.0 15.3&nbsp;&nbsp; 0:07.41 postgres: writer process<br><br>参考 :<br>bgwriter.c<br>xlog.c</div>
	</div>
</div>
</body>
</html>