<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Compare PostgreSQL and Oracle dead lock detect and transaction</h2>
	<h5 id="">2011-04-08 14:36:07&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020113811711716/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><br>Oracle 和 PostgreSQL的死锁检测和处理有较大区别。<br>主要差别在于 : <br>1. 死锁被检测到的属于哪个SESSION？Oracle随机检出，从实验来看应该是第一个启动的死锁事务。而PostgreSQL是死锁发生时的最后一个事务，与ORACLE相反（从PG的deadlock_timeout参数可以看出PostgreSQL的死锁检测不是随机的，而是可预见的。This is the amount of time, in milliseconds, to wait on a lock         before checking to see if there is a deadlock condition.）。<br>2. 死锁被检测到之后的处理上的差别，oracle允许单个事务中的部分SQL执行成功,部分SQL执行失败(其实这是非常严重的缺陷)。而PostgreSQL不允许事务中的部分SQL语句执行成功，要么全部成功，要么全部失败。<br>如图:<br>PostgreSQL 模拟死锁场景和检测结果，<br><div><img title="Compare PostgreSQL and Oracle dead lock detect and transaction - 德哥@Digoal - The Heart,The World."  alt="Compare PostgreSQL and Oracle dead lock detect and transaction - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img617.ph.126.net/TGoV34X4NxxJDFLix22XnQ==/1657606137850824582.jpg"  ></div>&nbsp;<br>Oracle 模拟死锁场景和检测结果，<br><div><img title="Compare PostgreSQL and Oracle dead lock detect and transaction - 德哥@Digoal - The Heart,The World."  alt="Compare PostgreSQL and Oracle dead lock detect and transaction - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img624.ph.126.net/EvjkCxdvwsg3YgHBDlDY3A==/3010374875922210524.jpg"  ></div>&nbsp;<br><br><br>PostgreSQL参数 : <br>deadlock_timeout = 1s<br>死锁检查会消耗部分数据库资源,如果数据库压力比较大的话可以考虑调大这个值。<br>SESSION A :<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; begin;<br>BEGIN<br>Time: 0.122 ms<br>digoal=&gt; update tbl_test set id=id+1 where id=100;<br>UPDATE 1<br>Time: 0.379 ms</font></p></pre><br>SESSION B :<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; begin;<br>BEGIN<br>Time: 0.126 ms<br>digoal=&gt; update tbl_test2 set id=id+1 where id=100;<br>UPDATE 1<br>Time: 0.437 ms</font></p></pre><br>SESSION C :<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; begin;<br>BEGIN<br>digoal=&gt; update tbl_test1 set id=id+1 where id=100;<br>UPDATE 1</font></p></pre><br>SESSION A :<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; update tbl_test2 set id=id+2 where id=100;</font></p></pre><br>SESSION B :<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; update tbl_test1 set id=id+3 where id=100;</font></p></pre><br>SESSION C :<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; update tbl_test set id=id+4 where id=100;<br>ERROR:&nbsp; deadlock detected<br>DETAIL:&nbsp; Process 11953 waits for ShareLock on transaction 4232; blocked by process 2873.<br>Process 2873 waits for ShareLock on transaction 4233; blocked by process 6616.<br>Process 6616 waits for ShareLock on transaction 4234; blocked by process 11953.<br>HINT:&nbsp; See server log for query details.</font></p></pre><br>SESSION B :<br><pre class="prettyprint"  ><p><font size="2"  >UPDATE 1<br>Time: 7839.728 ms</font></p></pre><br>SESSION A :<br><pre class="prettyprint"  ><p><font size="2"  >UPDATE 0<br>Time: 40903.601 ms<br>digoal=&gt; commit;<br>COMMIT<br>Time: 0.099 ms</font></p></pre><br>SESSION C :<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; commit;<br>ROLLBACK<br>Time: 0.196 ms</font></p></pre>注意到在PostgreSQL中，整个SESSION C回滚了。<div>这个和psql的默认配置有关 :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ON_ERROR_ROLLBACK</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;When on, if a statement in a transaction block generates an error, the error is ignored and the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;transaction continues. When interactive, such errors are only ignored in interactive sessions, and not</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;when reading script files. When off (the default), a statement in a transaction block that generates an</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;error aborts the entire transaction. The on_error_rollback-on mode works by issuing an implicit</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SAVEPOINT for you, just before each command that is in a transaction block, and rolls back to the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;savepoint on error.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ON_ERROR_STOP</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;By default, command processing continues after an error. When this variable is set, it will instead</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stop immediately. In interactive mode, psql will return to the command prompt; otherwise, psql will</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit, returning error code 3 to distinguish this case from fatal error conditions, which are reported</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;using error code 1. In either case, any currently running scripts (the top-level script, if any, and</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;any other scripts which it may have in invoked) will be terminated immediately. If the top-level</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;command string contained multiple SQL commands, processing will stop with the current command.</font></div><p></p></pre></div><div>如果开启ON_ERROR_ROLLBACK, 会在每一句SQL前设置隐形的savepoint, 可以继续下面的SQL, 而不用全部回滚, 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# \set ON_ERROR_ROLLBACK on</font></div><div><font size="2"  >postgres=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >postgres=# insert into t values (1);</font></div><div><font size="2"  >ERROR: &nbsp;relation "t" does not exist</font></div><div><font size="2"  >LINE 1: insert into t values (1);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"  >postgres=# \dt</font></div><div><font size="2"  >No relations found.</font></div><div><font size="2"  >postgres=# create table t (id int);</font></div><div><font size="2"  >CREATE TABLE</font></div><div><font size="2"  >postgres=# insert into t values (1);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >postgres=# insert into t values ('a');</font></div><div><font size="2"  >ERROR: &nbsp;invalid input syntax for integer: "a"</font></div><div><font size="2"  >LINE 1: insert into t values ('a');</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"  >postgres=# commit;</font></div><div><font size="2"  >COMMIT</font></div><div><font size="2"  >postgres=# select * from t;</font></div><div><font size="2"  >&nbsp;id&nbsp;</font></div><div><font size="2"  >----</font></div><div><font size="2"  >&nbsp; 1</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >postgres=# \set ON_ERROR_ROLLBACK off</font></div><div><font size="2"  >postgres=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >postgres=# insert into t values (1);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >postgres=# insert into t values ('a');</font></div><div><font size="2"  >ERROR: &nbsp;invalid input syntax for integer: "a"</font></div><div><font size="2"  >LINE 1: insert into t values ('a');</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"  >postgres=# commit;</font></div><div><font size="2"  >ROLLBACK</font></div><div><font size="2"  >postgres=# select * from t;</font></div><div><font size="2"  >&nbsp;id&nbsp;</font></div><div><font size="2"  >----</font></div><div><font size="2"  >&nbsp; 1</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div>Oracle :<br>SESSION A:<br><pre class="prettyprint"  ><p><font size="2"  >SQL&gt; update tbl_test set id=id+1 where id=100;<br>1 row updated.<br>Elapsed: 00:00:00.00</font></p></pre><br>SESSION B:<br><pre class="prettyprint"  ><p><font size="2"  >SQL&gt;&nbsp; update tbl_test2 set id=id+1 where id=100;<br>1 row updated.<br>Elapsed: 00:00:00.01</font></p></pre><br>SESSION C:<br><pre class="prettyprint"  ><p><font size="2"  >SQL&gt;&nbsp; update tbl_test1 set id=id+1 where id=100;<br>1 row updated.<br>Elapsed: 00:00:00.00</font></p></pre><br>SESSION A:<br><pre class="prettyprint"  ><p><font size="2"  >SQL&gt;&nbsp; update tbl_test2 set id=id+2 where id=100;</font></p></pre><br>SESSION B:<br><pre class="prettyprint"  ><p><font size="2"  >SQL&gt;&nbsp; update tbl_test1 set id=id+3 where id=100;<br>0 rows updated.<br>Elapsed: 00:00:39.50</font></p></pre><br>SESSION C:<br><pre class="prettyprint"  ><p><font size="2"  >SQL&gt;&nbsp; update tbl_test set id=id+4 where id=100;<br>0 rows updated.<br>Elapsed: 00:00:17.34</font></p></pre><br>SESSION A:<br><pre class="prettyprint"  ><p><font size="2"  >SQL&gt; &nbsp;update tbl_test2 set id=id+2 where id=100<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br>ERROR at line 1:<br>ORA-00060: deadlock detected while waiting for resource<br>Elapsed: 00:00:18.05</font></p></pre><br>SESSION A:<br><pre class="prettyprint"  ><p><font size="2"  >SQL&gt; commit;<br>Commit complete.<br>Elapsed: 00:00:00.01</font></p></pre><br>SESSION B:<br><pre class="prettyprint"  ><p><font size="2"  >SQL&gt; commit;<br>Commit complete.<br>Elapsed: 00:00:00.00</font></p></pre><br>SESSION C:<br><pre class="prettyprint"  ><p><font size="2"  >SQL&gt; commit;<br>Commit complete.<br>Elapsed: 00:00:00.01</font></p></pre>显然，ORACLE的SESSION A检测到了死锁，并且COMMIT后SESSION A部分SQL执行成功。<br><pre class="prettyprint"  ><p><font size="2"  >SQL&gt; select * from tbl_test where id&gt;=100;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID<br>----------<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 101<br>Elapsed: 00:00:00.00</font></p></pre><br>Oracle 允许事务中部分SQL执行成功, 可能会带来一些比较麻烦的问题, 如下.<br>举个简单的例子:充值。<br>A花了100元购买100个斯凯币。<br><pre class="prettyprint"  ><p><font size="2"  >update tbl_account_rmb set amount=amount-100 where id='A';<br>success<br>update tbl_account_kb set amount=amount+100 where id='A';<br>deadlock,failed.<br>commit;</font></p></pre>此时A的100元花出去了，但是KB没有充值到账。<br></div></div>
	</div>
</div>
</body>
</html>