<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL datafile backup and recovery case</h2>
	<h5 id="">2012-05-03 22:06:35&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012431063591/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">&nbsp;2DAY DBA的一个例子讲解, PPT实在写不下了. 移到这里<wbr><div><div>-- 备份</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# select * from pg_start_backup('basebackup');</font></div><div><font size="2"  >&nbsp;pg_start_backup&nbsp;</font></div><div><font size="2"  >-----------------</font></div><div><font size="2"  >&nbsp;11/28000020</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>-- 创建备份目录, 修改目录权限</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-33-&gt; mkdir pg_root_bak</font></div><div><font size="2"  >postgres@db-172-16-3-33-&gt; chmod 700 pg_root_bak</font></div><div><font size="2"  >postgres@db-172-16-3-33-&gt; cd pg_root</font></div><p></p></pre></div><div>-- 备份</div><div><pre class="prettyprint"  ><p>postgres@db-172-16-3-33-&gt; cp -r backup_label base global pg_clog pg_hba.conf pg_ident.conf pg_multixact pg_notify pg_serial pg_stat_tmp pg_subtrans pg_twophase PG_VERSION postgresql.conf postmaster.opts recovery.done ../pg_root_bak/</p></pre></div><div>-- 查看是否有表空间需要备份</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-33-&gt; cd pg_tblspc/</font></div><div><font size="2"  >postgres@db-172-16-3-33-&gt; ll</font></div><div><font size="2"  >total 0</font></div><div><font size="2"  >postgres@db-172-16-3-33-&gt; cd ../pg_root_bak</font></div><p></p></pre></div><div>-- 创建表空间目录, pg_xlog目录</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-33-&gt; mkdir pg_tblspc</font></div><div><font size="2"  >postgres@db-172-16-3-33-&gt; chmod 700 pg_tblspc</font></div><div><font size="2"  >postgres@db-172-16-3-33-&gt; mkdir pg_xlog</font></div><div><font size="2"  >postgres@db-172-16-3-33-&gt; chmod 700 pg_xlog</font></div><p></p></pre></div><div><br></div><div>-- 备份完成执行pg_stop_backup()</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-33-&gt; psql -h 127.0.0.1</font></div><div><font size="2"  >postgres=# select * from pg_stop_backup();</font></div><div><font size="2"  >NOTICE: &nbsp;pg_stop_backup complete, all required WAL segments have been archived</font></div><div><font size="2"  >&nbsp;pg_stop_backup&nbsp;</font></div><div><font size="2"  >----------------</font></div><div><font size="2"  >&nbsp;11/280000D8</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>-- 创建检查点, 切换xlog文件, 以便还原时能找到需要的归档文件.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# checkpoint;</font></div><div><font size="2"  >CHECKPOINT</font></div><div><font size="2"  >postgres=# select * from pg_switch_xlog();</font></div><div><font size="2"  >&nbsp;pg_switch_xlog&nbsp;</font></div><div><font size="2"  >----------------</font></div><div><font size="2"  >&nbsp;11/2C0000D0</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>-- 创建记录restore point 的表</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# \c digoal&nbsp;</font></div><div><font size="2"  >You are now connected to database "digoal" as user "postgres".</font></div><div><font size="2"  >digoal=# create table restore_point(id serial, target text, crt_time timestamp without time zone);</font></div><div><font size="2"  >NOTICE: &nbsp;CREATE TABLE will create implicit sequence "restore_point_id_seq" for serial column "restore_point.id"</font></div><div><font size="2"  >CREATE TABLE</font></div><p></p></pre></div><div><br></div><div>-- 在事务中执行pg_create_restore_point('target1'), 创建还原点target1,并将信息记录到测试表中.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >digoal=# insert into restore_point (target,crt_time) values ('target1',now());</font></div><div><font size="2"  >digoal=# insert into restore_point (target,crt_time) select pg_create_restore_point('target1'),now();</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >digoal=# end;</font></div><div><font size="2"  >COMMIT</font></div><p></p></pre></div><div>-- 在事务中执行pg_create_restore_point('target2'), 创建还原点target2,并将信息记录到测试表中.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >digoal=# insert into restore_point (target,crt_time) values ('target2',now());</font></div><div><font size="2"  >digoal=# insert into restore_point (target,crt_time) select pg_create_restore_point('target2'),now();</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >digoal=# end;</font></div><div><font size="2"  >COMMIT</font></div><div><font size="2"  >digoal=# select * from restore_point;</font></div><div><font size="2"  >&nbsp;id | &nbsp; target &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >----+-------------+----------------------------</font></div><div><font size="2"  >&nbsp; 1 | target1 &nbsp; &nbsp; | 2012-05-03 21:15:15.075396</font></div><div><font size="2"  >&nbsp; 2 | 11/340203F8 | 2012-05-03 21:15:15.075396</font></div><div><font size="2"  >&nbsp; 3 | target2 &nbsp; &nbsp; | 2012-05-03 21:16:40.807265</font></div><div><font size="2"  >&nbsp; 4 | 11/34020618 | 2012-05-03 21:16:40.807265</font></div><p></p></pre></div><div><br></div><div>-- 新建检查点, 切换xlog, 确保这些日志已归档, 以便可以恢复到指定target name</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# checkpoint;</font></div><div><font size="2"  >CHECKPOINT</font></div><div><font size="2"  >postgres=# select * from pg_switch_xlog();</font></div><div><font size="2"  >&nbsp;pg_switch_xlog&nbsp;</font></div><div><font size="2"  >----------------</font></div><div><font size="2"  >&nbsp;11/38000128</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div>-- 关闭数据库</div><div><pre class="prettyprint"  ><p><font size="2"  >postgres@db-172-16-3-33-&gt; pg_ctl stop -m fast</font></p></pre></div><div>-- 将数据目录移走, 把前面备份的数据目录拷贝为$PGDATA</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-33-&gt; cd $PGDATA/..</font></div><div><font size="2"  >postgres@db-172-16-3-33-&gt; mv pg_root pg_root_old</font></div><div><font size="2"  >postgres@db-172-16-3-33-&gt; cp -r pg_root_bak pg_root</font></div><p></p></pre></div><div>-- 修改或新建recovery.conf文件, 准备还原到target1这个还原点.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-33-&gt; cd pg_root</font></div><div><font size="2"  >mv recovery.done recovery.conf</font></div><div><font size="2"  >vi recovery.conf</font></div><div><font size="2"  >restore_command = 'cp /pgdata/digoal/1921/data01/pg_arch/%f %p' &nbsp; &nbsp; &nbsp; &nbsp; # e.g. 'cp /mnt/server/archivedir/%f %p'</font></div><div><font size="2"  >recovery_target_name = 'target1' &nbsp;# e.g. 'daily backup 2011-01-26'</font></div><div><font size="2"  >recovery_target_timeline = 'latest'</font></div><div><font size="2"  >pause_at_recovery_target = true</font></div><div><font size="2"  >standby_mode = on</font></div><p></p></pre></div><div>-- 由于需要查看是否恢复到了我想要到的时间点, 所以需要开启hot_standby选项.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >vi postgresql.conf</font></div><div><font size="2"  >hot_standby = on</font></div><p></p></pre></div><div><br></div><div>-- 开始恢复</div><div><pre class="prettyprint"  ><p><font size="2"  >pg_ctl start</font></p></pre></div><div>-- 连接到hot_standby查看是否恢复到了所指定的时间点.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-33-&gt; psql -h 127.0.0.1 digoal postgres</font></div><div><font size="2"  >digoal=# select * from restore_point;</font></div><div><font size="2"  >&nbsp;id | target | crt_time&nbsp;</font></div><div><font size="2"  >----+--------+----------</font></div><div><font size="2"  >(0 rows)</font></div><p></p></pre></div><div>-- 使用recovery_target_name作为目标时, 其实也是将还原点转换成xid, 还原到最临近的一个点, 而不包含执行pg_create_restore_point的事务.</div><div>-- 把目标修改为target2, 继续还原.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-33-&gt; pg_ctl stop -m fast</font></div><div><font size="2"  >waiting for server to shut down.... done</font></div><div><font size="2"  >server stopped</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >vi $PGDATA/recovery.conf</font></div><p></p></pre></div><div>修改</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >recovery_target_name = 'target2'</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=# select * from restore_point;</font></div><div><font size="2"  >&nbsp;id | &nbsp; target &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >----+-------------+----------------------------</font></div><div><font size="2"  >&nbsp; 1 | target1 &nbsp; &nbsp; | 2012-05-03 21:15:15.075396</font></div><div><font size="2"  >&nbsp; 2 | 11/340203F8 | 2012-05-03 21:15:15.075396</font></div><div><font size="2"  >(2 rows)</font></div><p></p></pre></div><div>-- 使用recovery_target_name作为目标时, 其实也是将还原点转换成xid, 还原到最临近的一个点, 而不包含执行pg_create_restore_point的事务.</div><div>-- 接下来指定时间来恢复, 指定时间也会将时间转换成xid作为目标来恢复.</div><div><pre class="prettyprint"  ><p><font size="2"  >postgres@db-172-16-3-33-&gt; pg_ctl stop -m fast</font></p></pre></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  ># 注释recovery_target_name = 'target2'</font></div><div><font size="2"  >recovery_target_time = '2012-05-03 21:26:40.807265+8'</font></div><div><font size="2"  >recovery_target_inclusive = true</font></div><p></p></pre></div><div><br></div><div>-- 启动数据库开始恢复</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-33-&gt; pg_ctl start</font></div><div><font size="2"  >digoal=# select * from restore_point;</font></div><div><font size="2"  >&nbsp;id | &nbsp; target &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >----+-------------+----------------------------</font></div><div><font size="2"  >&nbsp; 1 | target1 &nbsp; &nbsp; | 2012-05-03 21:15:15.075396</font></div><div><font size="2"  >&nbsp; 2 | 11/340203F8 | 2012-05-03 21:15:15.075396</font></div><div><font size="2"  >&nbsp; 3 | target2 &nbsp; &nbsp; | 2012-05-03 21:16:40.807265</font></div><div><font size="2"  >&nbsp; 4 | 11/34020618 | 2012-05-03 21:16:40.807265</font></div><p></p></pre></div><div><br></div><div>-- 推荐使用target_name或target_xid比较精确.</div><div>-- 到目前为止数据库都是处于恢复模式</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-33-&gt; pg_controldata&nbsp;</font></div><div><font size="2"  >pg_control version number: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;903</font></div><div><font size="2"  >Catalog version number: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 201105231</font></div><div><font size="2"  >Database system identifier: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5717347709989993843</font></div><div><font size="2"  >Database cluster state: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in archive recovery</font></div><div><font size="2"  >pg_control last modified: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Thu 03 May 2012 09:46:42 PM CST</font></div><div><font size="2"  >Latest checkpoint location: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11/34000020</font></div><div><font size="2"  >Prior checkpoint location: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11/34000020</font></div><div><font size="2"  >Latest checkpoint's REDO location: &nbsp; &nbsp;11/34000020</font></div><div><font size="2"  >Latest checkpoint's TimeLineID: &nbsp; &nbsp; &nbsp; 4</font></div><div><font size="2"  >Latest checkpoint's NextXID: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0/66037084</font></div><div><font size="2"  >Latest checkpoint's NextOID: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;32794</font></div><div><font size="2"  >Latest checkpoint's NextMultiXactId: &nbsp;1</font></div><div><font size="2"  >Latest checkpoint's NextMultiOffset: &nbsp;0</font></div><div><font size="2"  >Latest checkpoint's oldestXID: &nbsp; &nbsp; &nbsp; &nbsp;1670</font></div><div><font size="2"  >Latest checkpoint's oldestXID's DB: &nbsp; 1</font></div><div><font size="2"  >Latest checkpoint's oldestActiveXID: &nbsp;0</font></div><div><font size="2"  >Time of latest checkpoint: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Thu 03 May 2012 09:01:43 PM CST</font></div><div><font size="2"  >Minimum recovery ending location: &nbsp; &nbsp; 11/340205B0</font></div><div><font size="2"  >Backup start location: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0/0</font></div><div><font size="2"  >Current wal_level setting: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hot_standby</font></div><div><font size="2"  >Current max_connections setting: &nbsp; &nbsp; &nbsp;1000</font></div><div><font size="2"  >Current max_prepared_xacts setting: &nbsp; 0</font></div><div><font size="2"  >Current max_locks_per_xact setting: &nbsp; 64</font></div><div><font size="2"  >Maximum data alignment: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8</font></div><div><font size="2"  >Database block size: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8192</font></div><div><font size="2"  >Blocks per segment of large relation: 131072</font></div><div><font size="2"  >WAL block size: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8192</font></div><div><font size="2"  >Bytes per WAL segment: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;67108864</font></div><div><font size="2"  >Maximum length of identifiers: &nbsp; &nbsp; &nbsp; &nbsp;64</font></div><div><font size="2"  >Maximum columns in an index: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;32</font></div><div><font size="2"  >Maximum size of a TOAST chunk: &nbsp; &nbsp; &nbsp; &nbsp;1996</font></div><div><font size="2"  >Date/time type storage: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 64-bit integers</font></div><div><font size="2"  >Float4 argument passing: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;by value</font></div><div><font size="2"  >Float8 argument passing: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;by value</font></div><p></p></pre></div><div>-- 激活数据库</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-33-&gt; psql -h 127.0.0.1 digoal postgres</font></div><div><font size="2"  >digoal=# select pg_xlog_replay_resume();</font></div><p></p></pre></div><div>-- 如果指定的恢复目标不能达到, 即把所有的归档文件都恢复后还是不能达到时, 数据库将无法使用<span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >pg_xlog_replay_resume</span>激活. 这时需要修改recovery.conf降低目标或者不使用目标来恢复.</div><div>-- 例如</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >#recovery_target_time = '2012-05-03 21:26:16.075397+8'</font></div><div><font size="2"  >#recovery_target_inclusive = true</font></div><div><font size="2"  >#pause_at_recovery_target = true</font></div><p></p></pre></div><div>-- 都注释掉.在重启数据库恢复, 将恢复到最后的一致状态.&nbsp;</div><div>-- 如果一直处于等待XLOG的状态, 可以把需要的XLOG拷贝到pg_xlog目录进行恢复</div><div>-- 或者使用pg_ctl promote激活数据库.</div><div>-- 激活后数据库进入新的时间线</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-33-&gt; pg_controldata&nbsp;</font></div><div><font size="2"  >pg_control version number: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;903</font></div><div><font size="2"  >Catalog version number: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 201105231</font></div><div><font size="2"  >Database system identifier: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5717347709989993843</font></div><div><font size="2"  >Database cluster state: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in production</font></div><div><font size="2"  >pg_control last modified: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Thu 03 May 2012 09:58:56 PM CST</font></div><div><font size="2"  >Latest checkpoint location: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11/3C000020</font></div><div><font size="2"  >Prior checkpoint location: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11/380000B0</font></div><div><font size="2"  >Latest checkpoint's REDO location: &nbsp; &nbsp;11/3C000020</font></div><div><font size="2"  >Latest checkpoint's TimeLineID: &nbsp; &nbsp; &nbsp; 5</font></div><div><font size="2"  >Latest checkpoint's NextXID: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0/66037089</font></div><div><font size="2"  >Latest checkpoint's NextOID: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;32803</font></div><div><font size="2"  >Latest checkpoint's NextMultiXactId: &nbsp;1</font></div><div><font size="2"  >Latest checkpoint's NextMultiOffset: &nbsp;0</font></div><div><font size="2"  >Latest checkpoint's oldestXID: &nbsp; &nbsp; &nbsp; &nbsp;1670</font></div><div><font size="2"  >Latest checkpoint's oldestXID's DB: &nbsp; 1</font></div><div><font size="2"  >Latest checkpoint's oldestActiveXID: &nbsp;0</font></div><div><font size="2"  >Time of latest checkpoint: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Thu 03 May 2012 09:58:55 PM CST</font></div><div><font size="2"  >Minimum recovery ending location: &nbsp; &nbsp; 0/0</font></div><div><font size="2"  >Backup start location: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0/0</font></div><div><font size="2"  >Current wal_level setting: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hot_standby</font></div><div><font size="2"  >Current max_connections setting: &nbsp; &nbsp; &nbsp;1000</font></div><div><font size="2"  >Current max_prepared_xacts setting: &nbsp; 0</font></div><div><font size="2"  >Current max_locks_per_xact setting: &nbsp; 64</font></div><div><font size="2"  >Maximum data alignment: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8</font></div><div><font size="2"  >Database block size: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8192</font></div><div><font size="2"  >Blocks per segment of large relation: 131072</font></div><div><font size="2"  >WAL block size: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8192</font></div><div><font size="2"  >Bytes per WAL segment: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;67108864</font></div><div><font size="2"  >Maximum length of identifiers: &nbsp; &nbsp; &nbsp; &nbsp;64</font></div><div><font size="2"  >Maximum columns in an index: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;32</font></div><div><font size="2"  >Maximum size of a TOAST chunk: &nbsp; &nbsp; &nbsp; &nbsp;1996</font></div><div><font size="2"  >Date/time type storage: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 64-bit integers</font></div><div><font size="2"  >Float4 argument passing: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;by value</font></div><div><font size="2"  >Float8 argument passing: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;by value</font></div><p></p></pre></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div></div></div>
	</div>
</div>
</body>
</html>