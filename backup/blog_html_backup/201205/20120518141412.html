<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.2 add a dedicated worker process to perform checkpoints</h2>
	<h5 id="">2012-05-18 14:14:12&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020124182555711/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>以下是一个PostgreSQL9.2的运行进程 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >19204 pg92 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 2231m &nbsp;14m &nbsp;13m S &nbsp;0.0 &nbsp;0.1 &nbsp; 0:00.01 postgres: writer process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >19206 pg92 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 2231m &nbsp;17m &nbsp;16m S &nbsp;0.0 &nbsp;0.1 &nbsp; 0:00.22 postgres: wal writer process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >19208 pg92 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 &nbsp;110m 1544 &nbsp;864 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.09 postgres: stats collector process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >19202 pg92 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 &nbsp;108m 1364 &nbsp;796 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.00 postgres: logger process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >19205 pg92 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 2231m &nbsp;60m &nbsp;59m S &nbsp;0.0 &nbsp;0.3 &nbsp; 0:00.08 <font color="#ff0000"  >postgres: checkpointer process</font> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >19207 pg92 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 2232m 2548 1268 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.03 postgres: autovacuum launcher process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >19197 pg92 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 2230m &nbsp;66m &nbsp;65m S &nbsp;0.0 &nbsp;0.3 &nbsp; 0:00.09 /opt/pgsql92/bin/postgres</font></div><p></p></pre></div><div>显然比以前的版本多了一个进程名字叫做checkpointer process.</div><div>同时在代码中也可以看出来，</div><div>新增的代码文件src/backend/postmaster/checkpointer.c 截取.</div><div><br></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*-------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* checkpointer.c</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* The checkpointer is new as of Postgres 9.2. &nbsp;It handles all checkpoints.</font></div><div><font size="2"  >&nbsp;* Checkpoints are automatically dispatched after a certain amount of time has</font></div><div><font size="2"  >&nbsp;* elapsed since the last one, and it can be signaled to perform requested</font></div><div><font size="2"  >&nbsp;* checkpoints as well. &nbsp;(The GUC parameter that mandates a checkpoint every</font></div><div><font size="2"  >&nbsp;* so many WAL segments is implemented by having backends signal when they</font></div><div><font size="2"  >&nbsp;* fill WAL segments; the checkpointer itself doesn't watch for the</font></div><div><font size="2"  >&nbsp;* condition.)</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* The checkpointer is started by the postmaster as soon as the startup</font></div><div><font size="2"  >&nbsp;* subprocess finishes, or as soon as recovery begins if we are doing archive</font></div><div><font size="2"  >&nbsp;* recovery. &nbsp;It remains alive until the postmaster commands it to terminate.</font></div><div><font size="2"  >&nbsp;* Normal termination is by SIGUSR2, which instructs the checkpointer to</font></div><div><font size="2"  >&nbsp;* execute a shutdown checkpoint and then exit(0). &nbsp;(All backends must be</font></div><div><font size="2"  >&nbsp;* stopped before SIGUSR2 is issued!) &nbsp;Emergency termination is by SIGQUIT;</font></div><div><font size="2"  >&nbsp;* like any backend, the checkpointer will simply abort and exit on SIGQUIT.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* If the checkpointer exits unexpectedly, the postmaster treats that the same</font></div><div><font size="2"  >&nbsp;* as a backend crash: shared memory may be corrupted, so remaining backends</font></div><div><font size="2"  >&nbsp;* should be killed by SIGQUIT and then a recovery cycle started. &nbsp;(Even if</font></div><div><font size="2"  >&nbsp;* shared memory isn't corrupted, we have lost information about which</font></div><div><font size="2"  >&nbsp;* files need to be fsync'd for the next checkpoint, and so a system</font></div><div><font size="2"  >&nbsp;* restart needs to be forced.)</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Portions Copyright (c) 1996-2012, PostgreSQL Global Development Group</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* IDENTIFICATION</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;src/backend/postmaster/checkpointer.c</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;*-------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;*/</font></div><p></p></pre></div><div><br></div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >/*----------</font></div><div><font size="2"  >&nbsp;* Shared memory area for communication between checkpointer and backends</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* The ckpt counters allow backends to watch for completion of a checkpoint</font></div><div><font size="2"  >&nbsp;* request they send. &nbsp;Here's how it works:</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;* At start of a checkpoint, checkpointer reads (and clears) the request</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;flags and increments ckpt_started, while holding ckpt_lck.</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;* On completion of a checkpoint, checkpointer sets ckpt_done to</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;equal ckpt_started.</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;* On failure of a checkpoint, checkpointer increments ckpt_failed</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;and sets ckpt_done to equal ckpt_started.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* The algorithm for backends is:</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;1. Record current values of ckpt_failed and ckpt_started, and</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; set request flags, while holding ckpt_lck.</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;2. Send signal to request checkpoint.</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;3. Sleep until ckpt_started changes. &nbsp;Now you know a checkpoint has</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; begun since you started this algorithm (although *not* that it was</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; specifically initiated by your signal), and that it is using your flags.</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;4. Record new value of ckpt_started.</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;5. Sleep until ckpt_done &gt;= saved value of ckpt_started. &nbsp;(Use modulo</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; arithmetic here in case counters wrap around.) &nbsp;Now you know a</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; checkpoint has started and completed, but not whether it was</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; successful.</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;6. If ckpt_failed is different from the originally saved value,</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; assume request failed; otherwise it was definitely successful.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* ckpt_flags holds the OR of the checkpoint request flags sent by all</font></div><div><font size="2"  >&nbsp;* requesting backends since the last checkpoint start. &nbsp;The flags are</font></div><div><font size="2"  >&nbsp;* chosen so that OR'ing is the correct way to combine multiple requests.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* num_backend_writes is used to count the number of buffer writes performed</font></div><div><font size="2"  >&nbsp;* by user backend processes. &nbsp;This counter should be wide enough that it</font></div><div><font size="2"  >&nbsp;* can't overflow during a single processing cycle. &nbsp;num_backend_fsync</font></div><div><font size="2"  >&nbsp;* counts the subset of those writes that also had to do their own fsync,</font></div><div><font size="2"  >&nbsp;* because the checkpointer failed to absorb their request.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* The requests array holds fsync requests sent by backends and not yet</font></div><div><font size="2"  >&nbsp;* absorbed by the checkpointer.</font></div></div><div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Unlike the checkpoint fields, num_backend_writes, num_backend_fsync, and</font></div><div><font size="2"  >&nbsp;* the requests fields are protected by CheckpointerCommLock.</font></div><div><font size="2"  >&nbsp;*----------</font></div><div><font size="2"  >&nbsp;*/</font></div></div><p></p></pre></div><div>当然，并不是说checkpointer进程独立出来了，就不会发生backend process 处理checkpoint的动作了. 当checkpointer处理不过来的时候backend process还是会发生checkpoint的。</div><div><br></div><wbr></div>
	</div>
</div>
</body>
</html>