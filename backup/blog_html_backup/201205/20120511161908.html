<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Why pg_dump backup a database in consistent status</h2>
	<h5 id="">2012-05-11 16:19:08&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201241134721101/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">今天一位群里的朋友在问怎么做一致的逻辑备份, 比如在hot_standby上使用pg_dump备份数据库时，是不是要先把recovery停掉再进行备份?<div>回答，不需要停止其他读写，使用pg_dump备份是一致的备份。</div><div>为什么呢?</div><div>因为pg_dump备份时使用的是serializable隔离级别, 如在hot_standby上面备份将使用repeatable read隔离级别.(目前hot_standby数据库不支持serializable隔离级别). 使用这两种隔离级别进行备份，整个事务从开始时就是看到的一个数据库的snapshot。</div><div>pg_dump代码中开头就有一段介绍如下:</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;pg_dump will read the system catalogs in a database and dump out a</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;script that reproduces the schema in terms of SQL that is understood</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;by PostgreSQL</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;Note that pg_dump runs in a transaction-snapshot mode transaction,</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;so it sees a consistent snapshot of the database including system</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;catalogs. However, it relies in part on various specialized backend</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;functions like pg_get_indexdef(), and those things tend to run on</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;SnapshotNow time, ie they look at the currently committed state. &nbsp;So</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;it is possible to get 'cache lookup failed' error if someone</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;performs DDL changes while a dump is happening. The window for this</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;sort of thing is from the acquisition of the transaction snapshot to</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;getSchemaData() (when pg_dump acquires AccessShareLock on every</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;table it intends to dump). It isn't very large, but it can happen.</font></div><p></p></pre></div><div>另外代码中还有一段关于启动事务的如下,</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Start transaction-snapshot mode transaction to dump consistent data.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; do_sql_command(g_conn, "BEGIN");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (g_fout-&gt;remoteVersion &gt;= 90100)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (serializable_deferrable)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_sql_command(g_conn,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"SET TRANSACTION ISOLATION LEVEL SERIALIZABLE, "</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"READ ONLY, DEFERRABLE");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_sql_command(g_conn,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"SET TRANSACTION ISOLATION LEVEL REPEATABLE READ");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_sql_command(g_conn, "SET TRANSACTION ISOLATION LEVEL SERIALIZABLE");</font></div><p></p></pre></div><div>接下来我们测试一下:</div><div>1. SESSION A:</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-33-&gt; pg_dump -f ./digoal.dmp -F p -v -C -E UTF8 -h 127.0.0.1 -U postgres digoal</font></div><div><font size="2"  >pg_dump: reading schemas</font></div><div><font size="2"  >pg_dump: reading user-defined tables</font></div><div><font size="2"  >pg_dump: reading extensions</font></div><div><font size="2"  >pg_dump: reading user-defined functions</font></div><div><font size="2"  >pg_dump: reading user-defined types</font></div><div><font size="2"  >pg_dump: reading procedural languages</font></div><div><font size="2"  >pg_dump: reading user-defined aggregate functions</font></div><div><font size="2"  >pg_dump: reading user-defined operators</font></div><div><font size="2"  >pg_dump: reading user-defined operator classes</font></div><div><font size="2"  >pg_dump: reading user-defined operator families</font></div><div><font size="2"  >pg_dump: reading user-defined text search parsers</font></div><div><font size="2"  >pg_dump: reading user-defined text search templates</font></div><div><font size="2"  >pg_dump: reading user-defined text search dictionaries</font></div><div><font size="2"  >pg_dump: reading user-defined text search configurations</font></div><div><font size="2"  >pg_dump: reading user-defined foreign-data wrappers</font></div><div><font size="2"  >pg_dump: reading user-defined foreign servers</font></div><div><font size="2"  >pg_dump: reading default privileges</font></div><div><font size="2"  >pg_dump: reading user-defined collations</font></div><div><font size="2"  >pg_dump: reading user-defined conversions</font></div><div><font size="2"  >pg_dump: reading type casts</font></div><div><font size="2"  >pg_dump: reading table inheritance information</font></div><div><font size="2"  >pg_dump: reading rewrite rules</font></div><div><font size="2"  >pg_dump: finding extension members</font></div><div><font size="2"  >pg_dump: finding inheritance relationships</font></div><div><font size="2"  >pg_dump: reading column info for interesting tables</font></div><div><font size="2"  >pg_dump: finding the columns and types of table "restore_point"</font></div><div><font size="2"  >pg_dump: finding default expressions of table "restore_point"</font></div><div><font size="2"  >pg_dump: finding the columns and types of table "t1"</font></div><div><font size="2"  >pg_dump: finding the columns and types of table "t2"</font></div><div><font size="2"  >pg_dump: finding the columns and types of table "t3"</font></div><div><font size="2"  >pg_dump: finding the columns and types of table "a1"</font></div><div><font size="2"  >pg_dump: finding the columns and types of table "a2"</font></div><div><font size="2"  >pg_dump: flagging inherited columns in subtables</font></div><div><font size="2"  >pg_dump: reading indexes</font></div><div><font size="2"  >pg_dump: reading indexes for table "t1"</font></div><div><font size="2"  >pg_dump: reading indexes for table "t2"</font></div><div><font size="2"  >pg_dump: reading constraints</font></div><div><font size="2"  >pg_dump: reading triggers</font></div><div><font size="2"  >pg_dump: reading large objects</font></div><div><font size="2"  >pg_dump: reading dependency data</font></div><div><font size="2"  >pg_dump: saving encoding = UTF8</font></div><div><font size="2"  >pg_dump: saving standard_conforming_strings = on</font></div><div><font size="2"  >pg_dump: saving database definition</font></div><div><font size="2"  >pg_dump: creating DATABASE digoal</font></div><div><font size="2"  >pg_dump: connecting to new database "digoal"</font></div><div><font size="2"  >pg_dump: creating SCHEMA public</font></div><div><font size="2"  >pg_dump: creating COMMENT SCHEMA public</font></div><div><font size="2"  >pg_dump: creating EXTENSION plpgsql</font></div><div><font size="2"  >pg_dump: creating COMMENT EXTENSION plpgsql</font></div><div><font size="2"  >pg_dump: creating TABLE a1</font></div><div><font size="2"  >pg_dump: creating TABLE a2</font></div><div><font size="2"  >pg_dump: creating TABLE restore_point</font></div><div><font size="2"  >pg_dump: creating SEQUENCE restore_point_id_seq</font></div><div><font size="2"  >pg_dump: creating SEQUENCE OWNED BY restore_point_id_seq</font></div><div><font size="2"  >pg_dump: executing SEQUENCE SET restore_point_id_seq</font></div><div><font size="2"  >pg_dump: creating TABLE t1</font></div><div><font size="2"  >pg_dump: creating TABLE t2</font></div><div><font size="2"  >pg_dump: creating TABLE t3</font></div><div><font size="2"  >pg_dump: creating DEFAULT id</font></div><div><font size="2"  >pg_dump: restoring data for table "a1"</font></div><div><font size="2"  >pg_dump: dumping contents of table a1</font></div><p></p></pre></div><div>到这个点的时候,pg_dump还未结束,在SESSION B执行:</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >digoal=# drop table t2;</font></div><div><font size="2"  >DROP TABLE</font></div><p></p></pre></div><div>处于waiting状态. 这个要等到SESSION A的备份完成.</div><div>或者在SESSION B执行:</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >digoal=# truncate table t2;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >也处于waiting状态. 这个也要等到SESSION A的备份完成.</span> </div><div><span style="line-height: 22px;"  >但是执行创建新表是可以的, 给已有表创建索引也是可以的. 但是删除已有表的索引需要等待.</span></div><div><span style="line-height: 22px;"  >既然会堵塞对已有表的一些DDL操作, 那么会不会堵塞对表的DML操作呢?</span></div><div><span style="line-height: 22px;"  >在备份过程中我在SESSION B执行如下 :&nbsp;</span></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; delete from t1 where id=10000000;</font></div><div><font size="2"  >DELETE 1</font></div><div><font size="2"  >digoal=&gt; delete from t2 where id=10000000;</font></div><div><font size="2"  >DELETE 1</font></div><div><font size="2"  >digoal=&gt; delete from t2 where id=1000000;</font></div><div><font size="2"  >DELETE 1</font></div><div><font size="2"  >digoal=&gt; delete from t1 where id=1000000;</font></div><div><font size="2"  >DELETE 1</font></div><p></p></pre></div><div style="line-height: 22px;"  >-- 可以执行DML，也就是说pg_dump不会堵塞对表的DML操作。</div><div style="line-height: 22px;"  ><br></div></div><div><span style="line-height: 22px;"  >那么从备份开始到备份结束是不是处于同一个事务中呢, 我们看一下备份这个进程的事务开始时间和QUERY开始时间.</span></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select usename,datname,current_query,xact_start,query_start from pg_stat_activity;</font></div><div><font size="2"  >&nbsp;usename &nbsp;| datname | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_query &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xact_start &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;query_start &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >----------+---------+------------------------------------------------------------------------------------+--------------------------</font></div><div><font size="2"  >-----+-------------------------------</font></div><div><font size="2"  >&nbsp;postgres | digoal &nbsp;| select usename,datname,current_query,xact_start,query_start from pg_stat_activity; | 2012-05-11 15:39:44.92349</font></div><div><font size="2"  >3+08 | 2012-05-11 15:39:44.923493+08</font></div><div><font size="2"  >&nbsp;postgres | digoal &nbsp;| COPY public.a1 (id) TO stdout; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2012-05-11 15:39:43.59293</font></div><div><font size="2"  >4+08 | 2012-05-11 15:39:43.687405+08</font></div><div><font size="2"  >(2 rows)</font></div><p></p></pre></div><div style="line-height: 22px;"  >-- 结束前再执行查询看看xact_start时间未变化, 说明pg_dump备份是在一个事务中完成的.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select usename,datname,current_query,xact_start,query_start from pg_stat_activity;</font></div><div><font size="2"  >&nbsp;usename &nbsp;| datname | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_query &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xact_start &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;query_start &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >----------+---------+------------------------------------------------------------------------------------+--------------------------</font></div><div><font size="2"  >-----+-------------------------------</font></div><div><font size="2"  >&nbsp;postgres | digoal &nbsp;| select usename,datname,current_query,xact_start,query_start from pg_stat_activity; | 2012-05-11 15:39:52.60046</font></div><div><font size="2"  >3+08 | 2012-05-11 15:39:52.600463+08</font></div><div><font size="2"  >&nbsp;postgres | digoal &nbsp;| COPY public.t3 (id) TO stdout; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2012-05-11 15:39:43.59293</font></div><div><font size="2"  >4+08 | 2012-05-11 15:39:51.891716+08</font></div><div><font size="2"  >(2 rows)</font></div><p></p></pre></div><div style="line-height: 22px;"  >备份结束后，我们看一下备份的数据是不是一致的，换句话说，我执行的那几个DML操作，删除了4条记录，这4条记录在备份开始时是存在的，如果是一致的备份，这个4条记录应该在备份的记录里面存在。</div><div style="line-height: 22px;"  >我在<span style="line-height: 22px;"  >digoal.dmp这个文件里面找到了这4条记录，再一次验证pg_dump的备份是一致的。</span></div><div style="line-height: 22px;"  ><br></div><div style="line-height: 22px;"  ><br></div></div><div><span style="line-height: 22px;"  >【小结】</span></div><div><span style="line-height: 22px;"  >1. 使用pg_dump备份的时候，这个过程产生的垃圾数据不可以被VACUUM掉，所以一个很长时间的pg_dump操作会带来更多的垃圾数据.换句话说表的膨胀。</span></div><div><span style="line-height: 22px;"  ><br></span></div><div><span style="line-height: 22px;"  ><br></span></div><div><span style="line-height: 22px;"  ><br></span></div><div><br></div><div><br><br><wbr></div></div>
	</div>
</div>
</body>
</html>