<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.2 PL/pgSQL improve</h2>
	<h5 id="">2012-05-21 21:52:47&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020124219556542/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 9.2 &nbsp;对PL/pgSQL做出了如下改进 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1. Allow the PL/pgSQL OPEN cursor command to supply parameters by name (Yeb Havinga, Kevin Grittner, Tom Lane)</font></div><div><font size="2"  >2. Add a GET STACKED DIAGNOSTICS PL/pgSQL command to retrieve exception info (Pavel Stehule, Shigeru Hanada, David Wheeler)</font></div><div><font size="2"  >3. Speed up PL/pgSQL array assignment by caching type information (Pavel Stehule)</font></div><div><font size="2"  >4. Improve performance and memory consumption of the PL/pgSQL ELSIF clauses (Tom Lane)</font></div><div><font size="2"  >5. Output the function signature, not just the name, in PL/pgSQL error messages (Pavel Stehule, Abhijit Menon-Sen, Tom Lane)</font></div><p></p></pre></div><div>接下来分别测试一下使用 :&nbsp;</div><div>1. OPEN打开游标时支持使用参数名字 , 以前的版本则只支持参数值传递. 支持参数名的方法使得游标的调用更加灵活.</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >DECLARE</font></div><div><font size="2"  >&nbsp; &nbsp; curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >OPEN curs3(42); &nbsp;-- 老的版本只支持这种传递.</font></div><div><font size="2"  >OPEN curs3(key := 42); &nbsp;-- PostgreSQL9.2支持参数名.</font></div><p></p></pre></div><div><font size="2"  >PostgreSQL 9.2 运行结果 :&nbsp;</font></div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >pg92@db-172-16-3-150-&gt; psql digoal postgres</font></div><div><font size="2"  >psql (9.2beta1)</font></div><div><font size="2"  >Type "help" for help.</font></div></div><div><div><font size="2"  >digoal=# CREATE OR REPLACE function f_92test () returns void as $$</font></div><div><font size="2"  >digoal$# DECLARE</font></div><div><font size="2"  >digoal$# &nbsp; &nbsp; curs3 CURSOR (key integer) FOR SELECT * FROM t1 WHERE id = key;</font></div><div><font size="2"  >digoal$# BEGIN</font></div><div><font size="2"  >digoal$# -- OPEN curs3(42);</font></div><div><font size="2"  >digoal$# OPEN curs3(key := 42);</font></div><div><font size="2"  >digoal$# CLOSE curs3;</font></div><div><font size="2"  >digoal$# RETURN;</font></div><div><font size="2"  >digoal$# END;</font></div><div><font size="2"  >digoal$# $$ language plpgsql;</font></div><div><font size="2"  >CREATE FUNCTION</font></div><div><font size="2"  >digoal=# select * from f_92test();</font></div><div><font size="2"  >&nbsp;f_92test&nbsp;</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp;</font></div><div><font size="2"  >(1 row)</font></div></div><p></p></pre></div><div>PostgreSQL 9.1 运行结果 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >pgdba2000@db-172-16-3-33-&gt; psql test test</font></div><div><font size="2"  >psql (9.1.3)</font></div><div><font size="2"  >Type "help" for help.</font></div></div><div><div><font size="2"  >test=&gt; CREATE OR REPLACE function f_92test () returns void as $$</font></div><div><font size="2"  >test$&gt; DECLARE</font></div><div><font size="2"  >test$&gt; &nbsp; &nbsp; curs3 CURSOR (key integer) FOR SELECT * FROM t1 WHERE id = key;</font></div><div><font size="2"  >test$&gt; BEGIN</font></div><div><font size="2"  >test$&gt; -- OPEN curs3(42);</font></div><div><font size="2"  >test$&gt; OPEN curs3(key := 42);</font></div><div><font size="2"  >test$&gt; CLOSE curs3;</font></div><div><font size="2"  >test$&gt; RETURN;</font></div><div><font size="2"  >test$&gt; END;</font></div><div><font size="2"  >test$&gt; $$ language plpgsql;</font></div><div><font size="2"  >ERROR: &nbsp;syntax error at or near ":="</font></div><div><font size="2"  >LINE 6: OPEN curs3(key := 42);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div></div><p></p></pre></div><div><br></div><div>2. PostgreSQL 增加了获取PL/pgSQL错误信息的语法GET STACKED DIAGNOSTICS.</div><div>通过GET STACKED DIAGNOSTICS可以在函数执行异常时在EXCEPTION中捕获错误信息如 : 错误代码, 错误主信息, 错误详细信息, 错误提示信息, 发生错误的行信息.</div><div>例子 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-150-&gt; psql digoal postgres</font></div><div><font size="2"  >psql (9.2beta1)</font></div><div><font size="2"  >Type "help" for help.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=# CREATE OR REPLACE FUNCTION f_test () returns void as $$</font></div><div><font size="2"  >digoal$# declare</font></div><div><font size="2"  >digoal$# v1 text;</font></div><div><font size="2"  >digoal$# v2 text;</font></div><div><font size="2"  >digoal$# v3 text;</font></div><div><font size="2"  >digoal$# v4 text;</font></div><div><font size="2"  >digoal$# v5 text;</font></div><div><font size="2"  >digoal$# begin</font></div><div><font size="2"  >digoal$# select 1; &nbsp;-- 这行,第9行有问题.</font></div><div><font size="2"  >digoal$# exception</font></div><div><font size="2"  >digoal$# when others then</font></div><div><font size="2"  >digoal$# GET STACKED DIAGNOSTICS</font></div><div><font size="2"  >digoal$# &nbsp; v1 := RETURNED_SQLSTATE,</font></div><div><font size="2"  >digoal$# &nbsp; v2 := MESSAGE_TEXT,</font></div><div><font size="2"  >digoal$# &nbsp; v3 := PG_EXCEPTION_DETAIL,</font></div><div><font size="2"  >digoal$# &nbsp; v4 := PG_EXCEPTION_HINT,</font></div><div><font size="2"  >digoal$# &nbsp; v5 := PG_EXCEPTION_CONTEXT;</font></div><div><font size="2"  >digoal$# raise notice 'v1: %,</font></div><div><font size="2"  >digoal$# v2: %,</font></div><div><font size="2"  >digoal$# v3: %,</font></div><div><font size="2"  >digoal$# v4: %,</font></div><div><font size="2"  >digoal$# v5: %.',v1,v2,v3,v4,v5;</font></div><div><font size="2"  >digoal$# end;</font></div><div><font size="2"  >digoal$# $$ language plpgsql;</font></div><div><font size="2"  >CREATE FUNCTION</font></div><div><font size="2"  >digoal=# select * from f_test();</font></div><div><font size="2"  >NOTICE: &nbsp;v1: 42601,</font></div><div><font size="2"  >v2: query has no destination for result data,</font></div><div><font size="2"  >v3: ,</font></div><div><font size="2"  >v4: If you want to discard the results of a SELECT, use PERFORM instead.,</font></div><div><font size="2"  >v5: PL/pgSQL function f_test() line 9 at SQL statement.</font></div><div><font size="2"  >&nbsp;f_test&nbsp;</font></div><div><font size="2"  >--------</font></div><div><font size="2"  >&nbsp;</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div>3. PostgreSQL 9.2通过缓存类型信息加速PL/pgSQL array类型的指派.</div><div><br></div><div>4. 对ELSIF子句有性能提升.</div><div>这个可以使用pgbench来测试一下提升有多少?</div><div>-- 测试函数, 大量使用ELSIF子句.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >CREATE OR REPLACE function f_elsif(i_int int) returns int as $$</font></div><div><font size="2"  >declare</font></div><div><font size="2"  >begin</font></div><div><font size="2"  >if i_int = 0 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 1 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 2 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 3 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 4 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 5 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 6 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 7 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 8 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 9 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 10 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 11 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 12 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 13 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 14 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 15 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 16 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 17 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 18 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 19 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 20 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 21 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 22 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 23 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 24 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 25 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 26 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 27 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 28 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 29 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 30 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 31 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 32 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 33 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 34 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 35 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 36 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 37 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 38 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 39 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 40 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 41 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 42 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 43 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 44 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 45 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 46 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 47 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 48 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 49 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 50 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >elsif i_int = 51 then</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >else&nbsp;</font></div><div><font size="2"  >&nbsp; return i_int;</font></div><div><font size="2"  >end if;</font></div><div><font size="2"  >end;</font></div><div><font size="2"  >$$ language plpgsql;</font></div><p></p></pre></div><div>PostgreSQL 9.2 测试结果 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-33-&gt; pgbench -M prepared -c 8 -j 8 -f ./elsif.sql -n -r -T 60 -h 127.0.0.1 -U postgres digoal</font></div><div><font size="2"  >transaction type: Custom query</font></div><div><font size="2"  >scaling factor: 1</font></div><div><font size="2"  >query mode: prepared</font></div><div><font size="2"  >number of clients: 8</font></div><div><font size="2"  >number of threads: 8</font></div><div><font size="2"  >duration: 60 s</font></div><div><font size="2"  >number of transactions actually processed: 538752</font></div><div><font size="2"  >tps = 8978.986300 (including connections establishing)</font></div><div><font size="2"  >tps = 8979.976151 (excluding connections establishing)</font></div><div><font size="2"  >statement latencies in milliseconds:</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 0.889331 &nbsp; &nbsp; &nbsp; &nbsp;select * from f_elsif(10000);</font></div><p></p></pre></div><div><br></div><div>PostgreSQL 9.1 测试结果 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pgdba2000@db-172-16-3-33-&gt; pgbench -M prepared -c 8 -j 8 -f ./elsif.sql -n -r -T 60 -h 127.0.0.1 -U test test</font></div><div><font size="2"  >Password:&nbsp;</font></div><div><font size="2"  >transaction type: Custom query</font></div><div><font size="2"  >scaling factor: 1</font></div><div><font size="2"  >query mode: prepared</font></div><div><font size="2"  >number of clients: 8</font></div><div><font size="2"  >number of threads: 8</font></div><div><font size="2"  >duration: 60 s</font></div><div><font size="2"  >number of transactions actually processed: 536916</font></div><div><font size="2"  >tps = 8948.449964 (including connections establishing)</font></div><div><font size="2"  >tps = 8949.431980 (excluding connections establishing)</font></div><div><font size="2"  >statement latencies in milliseconds:</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 0.892056 &nbsp; &nbsp; &nbsp; &nbsp;select * from f_elsif(10000);</font></div><p></p></pre></div><div>差别不明显, 可能更复杂的场景会有比较明显的差别.</div><div><br></div><div>5. PostgreSQL 9.2 在错误输出中输出函数名以及函数的参数信息, 以前函数调用错误时只输出函数的名称而没有参数, 所以当存在同名的函数时无法判断是哪个函数造成的错误.</div><div>例如 :&nbsp;</div><div>PostgreSQL 9.1</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >pgdba2000@db-172-16-3-33-&gt; psql test test</font></div><div><font size="2"  >psql (9.1.3)</font></div><div><font size="2"  >Type "help" for help.</font></div></div><div><div><font size="2"  >test=&gt; create or replace function f_test() returns void as $$</font></div><div><font size="2"  >test$&gt; declare</font></div><div><font size="2"  >test$&gt; begin</font></div><div><font size="2"  >test$&gt; select 1;</font></div><div><font size="2"  >test$&gt; return; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >test$&gt; end;</font></div><div><font size="2"  >test$&gt; $$ language plpgsql;</font></div><div><font size="2"  >CREATE FUNCTION</font></div><div><font size="2"  >test=&gt; select * from f_test();</font></div><div><font size="2"  >ERROR: &nbsp;query has no destination for result data</font></div><div><font size="2"  >HINT: &nbsp;If you want to discard the results of a SELECT, use PERFORM instead.</font></div><div><font size="2"  >CONTEXT: &nbsp;PL/pgSQL function "f_test" line 4 at SQL statement</font></div></div><div><font size="2"  >-- 错误输出中只包含了函数名f_test, 并不知道是几个参数的f_test函数.</font></div><p></p></pre></div><div><br></div><div>PostgreSQL 9.2</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >pg92@db-172-16-3-33-&gt; psql digoal postgres</font></div><div><font size="2"  >psql (9.2beta1)</font></div><div><font size="2"  >Type "help" for help.</font></div></div><div><div><font size="2"  >digoal=# create or replace function f_test() returns void as $$</font></div><div><font size="2"  >declare</font></div><div><font size="2"  >begin</font></div><div><font size="2"  >select 1;</font></div><div><font size="2"  >return; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >end;</font></div><div><font size="2"  >$$ language plpgsql;</font></div><div><font size="2"  >CREATE FUNCTION</font></div><div><font size="2"  >digoal=# select * from f_test();</font></div><div><font size="2"  >ERROR: &nbsp;query has no destination for result data</font></div><div><font size="2"  >HINT: &nbsp;If you want to discard the results of a SELECT, use PERFORM instead.</font></div><div><font size="2"  >CONTEXT: &nbsp;PL/pgSQL function f_test() line 4 at SQL statement</font></div></div><div><font size="2"  >-- 错误输出中包含了函数名和参数结构, 这里是f_test(), 也就是无参数的f_test函数. 所以可以清晰的定位到出错的函数是哪个函数.</font></div><p></p></pre></div><div>【参考】</div><div><a rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/plpgsql.html"  >http://www.postgresql.org/docs/9.2/static/plpgsql.html</a> </div><wbr></div>
	</div>
</div>
</body>
</html>