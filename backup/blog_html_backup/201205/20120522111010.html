<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.2 Allow sorting to be performed by inlined and faster, non-SQL-callable comparison functions</h2>
	<h5 id="">2012-05-22 11:10:10&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012422103715865/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 9.2 beta1 release notes中提到</div><div>Allow sorting to be performed by inlined and faster, non-SQL-callable comparison functions (Peter Geoghegan, Robert Haas, Tom Lane)</div><div>没有细说, 但是通过查看源码看出了一点端倪, 以前的版本在对两个值进行比较时, 重复调用相应的SQL函数进行的比较, 如cmp(x,y) 返回int类型.</div><div>&lt;0 表示x&lt;y. =0 表示x=y, &gt;0表示x&gt;y. 进行排序. (调用的比较函数必须是btree 支持的操作符支持的函数, 可以在pg_amproc中查询得到)</div><div>由于调用的SQL函数, 所以带来了一些overheard.</div><div>PostgreSQL 9.2 加入了SortSupport接口, 允许inlined的执行排序和值的比较操作.&nbsp;</div><div>通过下面的测试, PostgreSQL 9.2这种类型的操作性能提升36%.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*-------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* sortsupport.h</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;Framework for accelerated sorting.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Traditionally, PostgreSQL has implemented sorting by repeatedly invoking</font></div><div><font size="2"  >&nbsp;* an SQL-callable comparison function "cmp(x, y) returns int" on pairs of</font></div><div><font size="2"  >&nbsp;* values to be compared, where the comparison function is the BTORDER_PROC</font></div><div><font size="2"  >&nbsp;* pg_amproc support function of the appropriate btree index opclass.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* This file defines alternative APIs that allow sorting to be performed with</font></div><div><font size="2"  >&nbsp;* reduced overhead. &nbsp;To support lower-overhead sorting, a btree opclass may</font></div><div><font size="2"  >&nbsp;* provide a BTSORTSUPPORT_PROC pg_amproc entry, which must take a single</font></div><div><font size="2"  >&nbsp;* argument of type internal and return void. &nbsp;The argument is actually a</font></div><div><font size="2"  >&nbsp;* pointer to a SortSupportData struct, which is defined below.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* If provided, the BTSORTSUPPORT function will be called during sort setup,</font></div><div><font size="2"  >&nbsp;* and it must initialize the provided struct with pointers to function(s)</font></div><div><font size="2"  >&nbsp;* that can be called to perform sorting. &nbsp;This API is defined to allow</font></div><div><font size="2"  >&nbsp;* multiple acceleration mechanisms to be supported, but no opclass is</font></div><div><font size="2"  >&nbsp;* required to provide all of them. &nbsp;The BTSORTSUPPORT function should</font></div><div><font size="2"  >&nbsp;* simply not set any function pointers for mechanisms it doesn't support.</font></div><div><font size="2"  >&nbsp;* (However, all opclasses that provide BTSORTSUPPORT are required to provide</font></div><div><font size="2"  >&nbsp;* the comparator function.)</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* All sort support functions will be passed the address of the</font></div><div><font size="2"  >&nbsp;* SortSupportData struct when called, so they can use it to store</font></div><div><font size="2"  >&nbsp;* additional private data as needed. &nbsp;In particular, for collation-aware</font></div><div><font size="2"  >&nbsp;* datatypes, the ssup_collation field is set before calling BTSORTSUPPORT</font></div><div><font size="2"  >&nbsp;* and is available to all support functions. &nbsp;Additional opclass-dependent</font></div><div><font size="2"  >&nbsp;* data can be stored using the ssup_extra field. &nbsp;Any such data</font></div><div><font size="2"  >&nbsp;* should be allocated in the ssup_cxt memory context.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Note: since pg_amproc functions are indexed by (lefttype, righttype)</font></div><div><font size="2"  >&nbsp;* it is possible to associate a BTSORTSUPPORT function with a cross-type</font></div><div><font size="2"  >&nbsp;* comparison. &nbsp;This could sensibly be used to provide a fast comparator</font></div><div><font size="2"  >&nbsp;* function for such cases, but probably not any other acceleration method.</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >SortSupportData</span>数据结构 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >typedef struct SortSupportData</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* These fields are initialized before calling the BTSORTSUPPORT function</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* and should not be changed later.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext ssup_cxt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Context containing sort info */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssup_collation; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Collation to use, or InvalidOid */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Additional sorting parameters; but unlike ssup_collation, these can</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* be changed after BTSORTSUPPORT is called, so don't use them in</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* selecting sort support functions.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ssup_reverse; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* descending-order sort? */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ssup_nulls_first; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* sort nulls first? */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* These fields are workspace for callers, and should not be touched by</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* opclass-specific functions.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber &nbsp; &nbsp; &nbsp;ssup_attno; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* column number to sort */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ssup_extra is zeroed before calling the BTSORTSUPPORT function, and</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* is not touched subsequently by callers.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; void &nbsp; &nbsp; &nbsp; *ssup_extra; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Workspace for opclass functions */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Function pointers are zeroed before calling the BTSORTSUPPORT function,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* and must be set by it for any acceleration methods it wants to supply.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The comparator pointer must be set, others are optional.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Comparator function has the same API as the traditional btree</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* comparison function, ie, return &lt;0, 0, or &gt;0 according as x is less</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* than, equal to, or greater than y. &nbsp;Note that x and y are guaranteed</font></div></div><div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* not null, and there is no way to return null either. &nbsp;Do not return</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* INT_MIN, as callers are allowed to negate the result before using it.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*comparator) (Datum x, Datum y, SortSupport ssup);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Additional sort-acceleration functions might be added here later.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >} SortSupportData;</font></div></div><p></p></pre></div><div><span style="line-height: 22px;"  >以下截取PostgreSQL 9.2的src/backend/access/nbtree/nbtcompare.c中的部分, 添加了</span></div><div><span style="line-height: 22px;"  >btint2fastcmp(Datum x, Datum y, SortSupport ssup)</span></div><div><span style="line-height: 22px;"  >和</span></div><div><span style="line-height: 22px;"  >btint2sortsupport(PG_FUNCTION_ARGS)</span></div><div><pre class="prettyprint"  ><div><font size="2"  ><span style="line-height: 22px;"  >-- PostgreSQL 9.2以前版本中没有fastcmp和sortsupport相关的代码, 只有</span><span style="line-height: 22px;"  >btint2cmp这个.</span></font></div><div><div><font size="2"  >Datum</font></div><div><font size="2"  >btint2cmp(PG_FUNCTION_ARGS)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = PG_GETARG_INT16(0);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = PG_GETARG_INT16(1);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32((int32) a - (int32) b);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >static int</font></div><div><font size="2"  >btint2fastcmp(Datum x, Datum y, SortSupport ssup)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = DatumGetInt16(x);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = DatumGetInt16(y);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; return (int) a - (int) b;</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Datum</font></div><div><font size="2"  >btint2sortsupport(PG_FUNCTION_ARGS)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; SortSupport &nbsp; &nbsp; ssup = (SortSupport) PG_GETARG_POINTER(0);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;comparator = btint2fastcmp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_VOID();</font></div><div><font size="2"  >}</font></div></div><p></p></pre></div><div>接下来分别针对PostgreSQL 9.1和PostgreSQL 9.2 测试以下int类型的排序和compare的性能，以体现9.2的性能提升.</div><div><div style="line-height: 22px;"  ><div style="line-height: 22px;"  >-- 新建测试表, 测试数据</div></div><div><div><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><div style="line-height: 22px;"  ><font size="2"  >create table t1 (id int,info text);</font></div><div style="line-height: 22px;"  ><font size="2"  >insert into t1 select generate_series(1,1000000),'digoal'||generate_series(1,1000000);</font></div><div style="line-height: 22px;"  ><font size="2"  >create index idx_t1_id on t1(id);</font></div></div><div><div style="line-height: 22px;"  ><font size="2"  >analyze t1;</font></div></div><p></p></pre></div></div><div><div style="line-height: 22px;"  >-- &nbsp;pgbench文件</div><div style="line-height: 22px;"  >vi ssup.sql</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >\setrandom id 1 1000000</font></div><div><font size="2"  >select * from t1 where id&gt;:id order by id limit 1;</font></div><p></p></pre></div></div></div><div><br></div><div>一、PostgreSQL 9.1</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >test=&gt; select * from pgfadvise_willneed('t1');</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;relpath &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| os_page_size | rel_os_pages | os_pages_free&nbsp;</font></div><div><font size="2"  >----------------------------------------------+--------------+--------------+---------------</font></div><div><font size="2"  >&nbsp;pg_tblspc/16386/PG_9.1_201105231/16387/24644 | &nbsp; &nbsp; &nbsp; &nbsp; 4096 | &nbsp; &nbsp; &nbsp; &nbsp;12548 | &nbsp; &nbsp; &nbsp; &nbsp;616865</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >test=&gt; select * from pgfadvise_willneed('idx_t1_id');</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;relpath &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| os_page_size | rel_os_pages | os_pages_free&nbsp;</font></div><div><font size="2"  >----------------------------------------------+--------------+--------------+---------------</font></div><div><font size="2"  >&nbsp;pg_tblspc/16386/PG_9.1_201105231/16387/24650 | &nbsp; &nbsp; &nbsp; &nbsp; 4096 | &nbsp; &nbsp; &nbsp; &nbsp; 5490 | &nbsp; &nbsp; &nbsp; &nbsp;616803</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>-- pgbench测试结果 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pgdba2000@db-172-16-3-33-&gt; pgbench -M prepared -c 8 -j 8 -f ./ssup.sql -n -r -T 60 -h 127.0.0.1 -U test test</font></div><div><font size="2"  >transaction type: Custom query</font></div><div><font size="2"  >scaling factor: 1</font></div><div><font size="2"  >query mode: prepared</font></div><div><font size="2"  >number of clients: 8</font></div><div><font size="2"  >number of threads: 8</font></div><div><font size="2"  >duration: 60 s</font></div><div><font size="2"  >number of transactions actually processed: 5034661</font></div><div><font size="2"  >tps = 83900.899617 (including connections establishing)</font></div><div><font size="2"  >tps = 83909.443190 (excluding connections establishing)</font></div><div><font size="2"  >statement latencies in milliseconds:</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 0.001803 &nbsp; &nbsp; &nbsp; &nbsp;\setrandom id 1 1000000</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 0.091438 &nbsp; &nbsp; &nbsp; &nbsp;select * from t1 where id&gt;:id order by id limit 1;</font></div><p></p></pre></div><div><br></div><div>二、PostgreSQL 9.2</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from pgfadvise_willneed('t1');</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;relpath &nbsp; &nbsp; &nbsp;| os_page_size | rel_os_pages | os_pages_free&nbsp;</font></div><div><font size="2"  >------------------+--------------+--------------+---------------</font></div><div><font size="2"  >&nbsp;base/16384/16999 | &nbsp; &nbsp; &nbsp; &nbsp; 4096 | &nbsp; &nbsp; &nbsp; &nbsp;12548 | &nbsp; &nbsp; &nbsp; &nbsp;612161</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >digoal=# select * from pgfadvise_willneed('idx_t1_id');</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;relpath &nbsp; &nbsp; &nbsp;| os_page_size | rel_os_pages | os_pages_free&nbsp;</font></div><div><font size="2"  >------------------+--------------+--------------+---------------</font></div><div><font size="2"  >&nbsp;base/16384/17005 | &nbsp; &nbsp; &nbsp; &nbsp; 4096 | &nbsp; &nbsp; &nbsp; &nbsp; 5490 | &nbsp; &nbsp; &nbsp; &nbsp;612161</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>-- pgbench测试结果 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-33-&gt; pgbench -M prepared -c 8 -j 8 -f ./ssup.sql -n -r -T 60 -h 127.0.0.1 -U postgres digoal</font></div><div><font size="2"  >transaction type: Custom query</font></div><div><font size="2"  >scaling factor: 1</font></div><div><font size="2"  >query mode: prepared</font></div><div><font size="2"  >number of clients: 8</font></div><div><font size="2"  >number of threads: 8</font></div><div><font size="2"  >duration: 60 s</font></div><div><font size="2"  >number of transactions actually processed: 6857931</font></div><div><font size="2"  >tps = 114287.381261 (including connections establishing)</font></div><div><font size="2"  >tps = 114302.459815 (excluding connections establishing)</font></div><div><font size="2"  >statement latencies in milliseconds:</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 0.001504 &nbsp; &nbsp; &nbsp; &nbsp;\setrandom id 1 1000000</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 0.066795 &nbsp; &nbsp; &nbsp; &nbsp;select * from t1 where id&gt;:id order by id limit 1;</font></div><p></p></pre></div><div>PostgreSQL 9.2 性能提升 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select (114287.0-83900.0)/83900.0;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ?column? &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >------------------------</font></div><div><font size="2"  >&nbsp;0.36218116805721096544</font></div><p></p></pre></div><div><br></div><div>【参考】</div><div>src/include/utils/sortsupport.h</div><div>src/backend/utils/sort/sortsupport.c</div><div>src/backend/access/nbtree/nbtcompare.c</div><div>src/backend/commands/analyze.c</div><div>src/backend/utils/sort/qsort_tuple.c</div><div>src/backend/utils/sort/tuplesort.c</div><div>src/backend/utils/adt/date.c</div><div>src/backend/utils/adt/array_typanalyze.c</div><div>src/backend/utils/adt/array_selfuncs.c</div><div>src/backend/utils/adt/timestamp.c</div><div>src/backend/utils/adt/float.c</div><div>src/backend/executor/nodeMergeAppend.c</div><div>src/backend/executor/nodeMergejoin.c</div></div>
	</div>
</div>
</body>
</html>