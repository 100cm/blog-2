<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.2 add array elements statistics</h2>
	<h5 id="">2012-05-18 13:53:21&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020124180182088/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">PostgreSQL 9.2 在统计信息中增加了 array类型中 element的统计信息，以提供给优化器参考。<wbr><div>例如@&gt;, &amp;&amp;, 和&lt;@ 操作符的使用更加优化。</div><div>以下是PostgreSQL &nbsp;9.1 的pg_stats包含的列信息</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# \d pg_stats</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; View "pg_catalog.pg_stats"</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; Column &nbsp; &nbsp; &nbsp; | &nbsp; Type &nbsp; | Modifiers&nbsp;</font></div><div><font size="2"  >-------------------+----------+-----------</font></div><div><font size="2"  >&nbsp;schemaname &nbsp; &nbsp; &nbsp; &nbsp;| name &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;tablename &nbsp; &nbsp; &nbsp; &nbsp; | name &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;attname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | name &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;inherited &nbsp; &nbsp; &nbsp; &nbsp; | boolean &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;null_frac &nbsp; &nbsp; &nbsp; &nbsp; | real &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;avg_width &nbsp; &nbsp; &nbsp; &nbsp; | integer &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;n_distinct &nbsp; &nbsp; &nbsp; &nbsp;| real &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;most_common_vals &nbsp;| anyarray |&nbsp;</font></div><div><font size="2"  >&nbsp;most_common_freqs | real[] &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;histogram_bounds &nbsp;| anyarray |&nbsp;</font></div><div><font size="2"  >&nbsp;correlation &nbsp; &nbsp; &nbsp; | real &nbsp; &nbsp; |&nbsp;</font></div><p></p></pre></div><div><br></div><div>以下是PostgreSQL 9.2 的pg_stats包含的列信息, 可以看到增加了最后3列, 就是存放array类型的统计信息.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# \d pg_stats</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; View "pg_catalog.pg_stats"</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Column &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; Type &nbsp; | Modifiers&nbsp;</font></div><div><font size="2"  >------------------------+----------+-----------</font></div><div><font size="2"  >&nbsp;schemaname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | name &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;tablename &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| name &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;attname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| name &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;inherited &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| boolean &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;null_frac &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| real &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;avg_width &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| integer &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;n_distinct &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | real &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;most_common_vals &nbsp; &nbsp; &nbsp; | anyarray |&nbsp;</font></div><div><font size="2"  >&nbsp;most_common_freqs &nbsp; &nbsp; &nbsp;| real[] &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;histogram_bounds &nbsp; &nbsp; &nbsp; | anyarray |&nbsp;</font></div><div><font size="2"  >&nbsp;correlation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| real &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;most_common_elems &nbsp; &nbsp; &nbsp;| anyarray |&nbsp;</font></div><div><font size="2"  >&nbsp;most_common_elem_freqs | real[] &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;elem_count_histogram &nbsp; | real[] &nbsp; |&nbsp;</font></div><p></p></pre></div><div><br></div><div>创建测试表</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# create table array_gist_test (id int,class text[]);</font></div><div><font size="2"  >CREATE TABLE</font></div><p></p></pre></div><div>插入测试数据</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# insert into array_gist_test values (1,array['digoal','francs','david','hank','dage']);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >digoal=# insert into array_gist_test values (2,array['test1']);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >digoal=# insert into array_gist_test values (3,array['test2']);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >digoal=# insert into array_gist_test select generate_series(4,100000),array['test4'];</font></div><div><font size="2"  >INSERT 0 99997</font></div><p></p></pre></div><div>创建gin索引</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# create index idx_array_test on array_gist_test using gin (class);</font></div><div><font size="2"  >CREATE INDEX</font></div><p></p></pre></div><div><br></div><div><div style="line-height: 22px;"  >为了便于比较，在测试前都把数据刷出OS缓存，并重启数据库.</div><div><div><pre class="prettyprint"  ><p><font size="2"  >echo 3 &gt; /proc/sys/vm/drop_caches</font></p></pre></div><div style="line-height: 22px;"  ><br></div></div></div><div>以下是PostgreSQL 9.1中的执行计划测试</div><div><div style="line-height: 22px;"  >查询包含'test4'的数据</div></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# explain analyze select * from array_gist_test where class @&gt; array['test4'];</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >-------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Bitmap Heap Scan on array_gist_test &nbsp;(cost=3.77..100.03 rows=100 width=37) (actual time=31.899..91.692 rows=99997 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;Recheck Cond: (class @&gt; '{test4}'::text[])</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_array_test &nbsp;(cost=0.00..3.75 rows=100 width=0) (actual time=31.574..31.574 rows=99997 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (class @&gt; '{test4}'::text[])</font></div><div><font size="2"  >&nbsp;Total runtime: 101.623 ms</font></div><div><font size="2"  >(5 rows)</font></div><p></p></pre></div><div>查询包含'test3'的数据</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# explain analyze select * from array_gist_test where class @&gt; array['test3'];</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >-------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Bitmap Heap Scan on array_gist_test &nbsp;(cost=3.77..100.03 rows=100 width=37) (actual time=0.014..0.014 rows=0 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;Recheck Cond: (class @&gt; '{test3}'::text[])</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_array_test &nbsp;(cost=0.00..3.75 rows=100 width=0) (actual time=0.012..0.012 rows=0 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (class @&gt; '{test3}'::text[])</font></div><div><font size="2"  >&nbsp;Total runtime: 0.055 ms</font></div><div><font size="2"  >(5 rows)</font></div><p></p></pre></div><div>注意看, 在PostgreSQL9.1中test3和test4查询都走了bitmap index scan计划, 同时执行计划中的cost是一样的. 因为PostgreSQL 9.1没有收集array级的统计信息, 当然也没有办法依靠这个来计算成本.</div><div><br></div><div><br></div><div>以下是PostgreSQL 9.2中的执行计划测试</div><div><span style="line-height: 22px;"  >查询包含'test4'的数据</span> </div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# explain analyze select * from array_gist_test where class @&gt; array['test4'];</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >-----------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Seq Scan on array_gist_test &nbsp;(cost=0.00..2084.00 rows=100000 width=37) (actual time=7.175..88.462 rows=99997 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;Filter: (class @&gt; '{test4}'::text[])</font></div><div><font size="2"  >&nbsp; &nbsp;Rows Removed by Filter: 3</font></div><div><font size="2"  >&nbsp;Total runtime: 106.384 ms</font></div><div><font size="2"  >(4 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >查询包含'test3'的数据</span> </div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# explain analyze select * from array_gist_test where class @&gt; array['test3'];</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >-------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Bitmap Heap Scan on array_gist_test &nbsp;(cost=6.88..398.12 rows=500 width=37) (actual time=0.074..0.074 rows=0 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;Recheck Cond: (class @&gt; '{test3}'::text[])</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_array_test &nbsp;(cost=0.00..6.75 rows=500 width=0) (actual time=0.071..0.071 rows=0 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (class @&gt; '{test3}'::text[])</font></div><div><font size="2"  >&nbsp;Total runtime: 0.134 ms</font></div><div><font size="2"  >(5 rows)</font></div><p></p></pre></div><div style="line-height: 22px;"  >注意到, 查询条件是test4时, 数据库选择了seq_scan的执行计划. 但是执行时间上超过了PostgreSQL 9.1用到的bitmap scan计划.</div><div style="line-height: 22px;"  >查询条件是test3时走的是bitmap index scan.&nbsp;</div><div style="line-height: 22px;"  >那么为什么9.2和9.1的查询时间不一样呢?</div><div style="line-height: 22px;"  >1. 走索引不需要从TUPLE中取出class字段的值进行过滤.需要消耗掉CPU的时间.</div><div style="line-height: 22px;"  >2. 走索引会多一些IO的操作, 但是这些IO可能落在（HDS）存储的CACHE里面了, 所以在本例中看不出来, 因此IO在整个过程中的时间占比就显得比较小, 而从TUPLE中取出class字段过滤的动作在时间上占比更突出.</div><div style="line-height: 22px;"  >3. 走索引的过滤比走全表的过滤简单，需要的CPU运算少.</div><div style="line-height: 22px;"  ><br></div><div style="line-height: 22px;"  >接下来我强制9.2在查询条件是test4时不使用seq_scan</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# set enable_seqscan=off;</font></div><div><font size="2"  >SET</font></div><div><font size="2"  >digoal=# explain analyze select * from array_gist_test where class @&gt; array['test4'];</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Bitmap Heap Scan on array_gist_test &nbsp;(cost=851.00..2935.00 rows=100000 width=37) (actual time=43.921..69.214 rows=99997 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;Recheck Cond: (class @&gt; '{test4}'::text[])</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_array_test &nbsp;(cost=0.00..826.00 rows=100000 width=0) (actual time=43.719..43.719 rows=99997 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (class @&gt; '{test4}'::text[])</font></div><div><font size="2"  >&nbsp;Total runtime: 77.961 ms</font></div><div><font size="2"  >(5 rows)</font></div><p></p></pre></div><div style="line-height: 22px;"  >注意看, 这时PostgreSQL 9.2在查询条件为test4时也走了bitmap index scan, 而且COST可以看出比seq_scan要大, 而且此时的COST和前面test3条件时的COST也不一样, 因为9.2有了array列的统计信息, 所以可以拿来做成本计算.</div><div style="line-height: 22px;"  ><br></div><div style="line-height: 22px;"  >解读pg_stats中的array类型的统计信息</div><div style="line-height: 22px;"  >例如一个pg_stats中array_gist_test.class列的统计信息如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from pg_stats where tablename='array_gist_test' and attname='class';</font></div><div><font size="2"  >-[ RECORD 1 ]----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >schemaname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | public</font></div><div><font size="2"  >tablename &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| array_gist_test</font></div><div><font size="2"  >attname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| class</font></div><div><font size="2"  >inherited &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| f</font></div><div><font size="2"  >null_frac &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 0</font></div><div><font size="2"  >avg_width &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 33</font></div><div><font size="2"  >n_distinct &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 5</font></div><div><font size="2"  >most_common_vals &nbsp; &nbsp; &nbsp; | {"{test7}","{test8}","{test5}","{test6}","{test4}"}</font></div><div><font size="2"  >most_common_freqs &nbsp; &nbsp; &nbsp;| {0.202267,0.2015,0.1997,0.1995,0.197033}</font></div><div><font size="2"  >histogram_bounds &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >correlation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 1</font></div><div><font size="2"  >most_common_elems &nbsp; &nbsp; &nbsp;| {test4,test5,test6,test7,test8}</font></div><div><font size="2"  >most_common_elem_freqs | {0.197033,0.1997,0.1995,0.202267,0.2015,0.197033,0.202267,0}</font></div><div><font size="2"  >elem_count_histogram &nbsp; | {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}</font></div><p></p></pre></div><div style="line-height: 22px;"  >most_common_elems中表示出现最频繁的几个元素.</div><div style="line-height: 22px;"  >most_common_elem_freqs的除掉最后3个剩余的则分别对应common_elems的元素的占比。</div><div style="line-height: 22px;"  >例如第一个test4元素统计出来出现的频率是0.197033</div><div style="line-height: 22px;"  >我们可以来计算一下看看和实际是否相符.</div><div style="line-height: 22px;"  >首先查看这个表有多少条记录.</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select reltuples from pg_class where relname='array_gist_test';</font></div><div><font size="2"  >-[ RECORD 1 ]-----</font></div><div><font size="2"  >reltuples | 499988</font></div><p></p></pre></div><div>然后根据这个记录数乘以频率就等于这个记录有多少条.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select 0.197033*499988;</font></div><div><font size="2"  >-[ RECORD 1 ]----------</font></div><div><font size="2"  >?column? | 98514.135604</font></div><p></p></pre></div></div><div>看看真实的test4有多少条.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select count(*) from array_gist_test where class @&gt; array['test4'];</font></div><div><font size="2"  >-[ RECORD 1 ]</font></div><div><font size="2"  >count | 99997</font></div><p></p></pre></div><div>与统计到的数据基本一致.</div><div>前面5个值加起来刚好等于1, 最后一位是0.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select 0.197033+0.1997+0.1995+0.202267+0.2015;</font></div><div><font size="2"  >-[ RECORD 1 ]------</font></div><div><font size="2"  >?column? | 1.000000</font></div><p></p></pre></div><div>好了，那么剩余的最后3个值<span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >0.197033,0.202267,0</span>分别是什么意思呢?</div><div>0.197033是指前面所有频率值的最小值。</div><div>0.202267是指前面所有频率值的最大值。</div><div>0表示除去这些comm_elems之外的elems占的比例.</div><div>我们可以来看看到底是不是0.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select class,count(*) from array_gist_test group by class order by count(*);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; class &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| count&nbsp;</font></div><div><font size="2"  >---------------------------------+-------</font></div><div><font size="2"  >&nbsp;{test2} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; 1</font></div><div><font size="2"  >&nbsp;{test1} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; 1</font></div><div><font size="2"  >&nbsp;{digoal,francs,david,hank,dage} | &nbsp; &nbsp; 1</font></div><div><font size="2"  >&nbsp;{test7} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 99997</font></div><div><font size="2"  >&nbsp;{test8} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 99997</font></div><div><font size="2"  >&nbsp;{test4} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 99997</font></div><div><font size="2"  >&nbsp;{test6} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 99997</font></div><div><font size="2"  >&nbsp;{test5} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 99997</font></div><p></p></pre></div><div>从结果上可以看出, 其他elems为 : &nbsp;test1, test2, digoal,&nbsp;<span style="line-height: 22px;"  >francs, david, hank, dage总共出现在3行中. 占比</span><span style="line-height: 22px;"  >0.000006, 如下.</span></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select count(*) from array_gist_test ;</font></div><div><font size="2"  >&nbsp;count &nbsp;</font></div><div><font size="2"  >--------</font></div><div><font size="2"  >&nbsp;499988</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >digoal=# select 3/499988.0;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ?column? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >----------------------------</font></div><div><font size="2"  >&nbsp;0.000006000144003456082946</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>为什么most_common_elem_freqs的最后一位不是0.000006呢, 原因是在analyze时根本就没有取到这3行.&nbsp;</div></div><div>重置一个比较大的<span style="line-height: 22px;"  >set default_statistics_target=10000. 重新分析就能看到更全面的数据了.</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# set default_statistics_target=10000;</font></div><div><font size="2"  >digoal=# analyze array_gist_test ;</font></div><div><font size="2"  >digoal=# select * from pg_stats where tablename='array_gist_test' and attname='class';</font></div><div><div><font size="2"  >most_common_elems &nbsp; &nbsp; &nbsp;| {dage,david,digoal,francs,hank,test1,test2,test4,test5,test6,test7,test8}</font></div><div><font size="2"  >most_common_elem_freqs | {2.00005e-06,2.00005e-06,2.00005e-06,2.00005e-06,2.00005e-06,2.00005e-06,2.00005e-06,0.199999,0.199999,0.199999,0.199999,0.199999,2.00005e-06,0.199999,0}</font></div></div><p></p></pre></div><div><br></div><div>最后解释一下elem_count_histogram的意思，A histogram of the counts of distinct non-null element values within the values of the column, followed by the average number of distinct non-null elements.就说和<span style="line-height: 22px;"  >default_statistics_target有关系，比如默认是100，那</span><span style="line-height: 22px;"  >elem_count_histogram就有101个值, 前100个值表示分成均等的100份后，每份中class列包含的distinct non-null element的个数。最后一位是平均的distinct non-null elements的值. 不过个人感觉这个统计没有什么实质的意义. 应该再配合其他的统计信息使用.</span></div><div><br></div><div style="line-height: 22px;"  ><br></div></div></div>
	</div>
</div>
</body>
</html>