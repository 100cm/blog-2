<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.3 Improve concurrency of hash indexes</h2>
	<h5 id="">2013-05-06 16:12:24&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013464347839/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>Improve concurrency of hash indexes (Robert Haas)</div><div>9.3的又一个亮点 : 性能提升3.36倍.</div><div>在hash索引访问方法中, 减少重量级锁的使用, 详见参考部分.</div><div><br></div><div>[测试]</div><div>postgresql.conf</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >shared_buffers = 1024MB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # min 128kB</font></div><div><font size="2"   >maintenance_work_mem = 512MB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# min 1MB</font></div><div><font size="2"   >wal_level = minimal &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # minimal, archive, or hot_standby</font></div><div><font size="2"   >synchronous_commit = on &nbsp; &nbsp; &nbsp; &nbsp; # synchronization level;</font></div><div><font size="2"   >wal_sync_method = fdatasync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # the default is the first option</font></div><div><font size="2"   >commit_delay = 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # range 0-100000, in microseconds</font></div><div><font size="2"   >commit_siblings = 5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # range 1-1000</font></div><div><font size="2"   >checkpoint_segments = 32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# in logfile segments, min 1, 16MB each</font></div><div><font size="2"   >autovacuum = off</font></div><p></p></pre></div><div>-- 测试表, 测试数据 , hash索引</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create table hash_idx_test(id int primary key, info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# insert into hash_idx_test select generate_series(1,1000000), md5(random()::text);</font></div></div><div><font size="2"   >INSERT 0 1000000</font></div><div><div><font size="2"   >postgres=# create index idx_1 on hash_idx_test using hash(info);</font></div><div><font size="2"   >CREATE INDEX</font></div></div><p></p></pre></div><div><br></div><div>-- 测试脚本, 更新hash索引值.</div><div><div>vi up.sql</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >\setrandom id 1 1000000</font></div><div><font size="2"   >update hash_idx_test set info=md5(random()::text) where id=:id;</font></div><p></p></pre></div></div><div>[测试结果]</div><div><span style="line-height: 22px;"   >PostgreSQL 9.3 :&nbsp;</span></div><div><span style="line-height: 22px;"   ><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg93@db-172-16-3-33-&gt; pgbench -M prepared -f ./up.sql -n -r -h $PGDATA -U postgres -c 32 -j 4 -T 60 postgres</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 32</font></div><div><font size="2"   >number of threads: 4</font></div><div><font size="2"   >duration: 60 s</font></div><div><font size="2"   >number of transactions actually processed: 771818</font></div><div><font size="2"   >tps = 12852.268715 (including connections establishing)</font></div><div><font size="2"   >tps = 12861.817834 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.001732 &nbsp; &nbsp; &nbsp; &nbsp;\setrandom id 1 1000000</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 2.482609 &nbsp; &nbsp; &nbsp; &nbsp;update hash_idx_test set info=md5(random()::text) where id=:id;</font></div></pre></div><div>PostgreSQL 9.2 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg92@db-172-16-3-33-&gt; pgbench -M prepared -f ./up.sql -n -r -h $PGDATA -U postgres -c 32 -j 4 -T 60 postgres</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 32</font></div><div><font size="2"   >number of threads: 4</font></div><div><font size="2"   >duration: 60 s</font></div><div><font size="2"   >number of transactions actually processed: 229621</font></div><div><font size="2"   >tps = 3824.023476 (including connections establishing)</font></div><div><font size="2"   >tps = 3826.975575 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.001834 &nbsp; &nbsp; &nbsp; &nbsp;\setrandom id 1 1000000</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 8.353279 &nbsp; &nbsp; &nbsp; &nbsp;update hash_idx_test set info=md5(random()::text) where id=:id;</font></div><p></p></pre></div></span></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=76837c1507cb5a5a0048046233568447729e66dd"   >http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=76837c1507cb5a5a0048046233568447729e66dd</a></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Reduce use of heavyweight locking inside hash AM.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Avoid using LockPage(rel, 0, lockmode) to protect against changes to</font></div><div><font size="2"   >the bucket mapping. &nbsp;Instead, an exclusive buffer content lock is now</font></div><div><font size="2"   >viewed as sufficient permission to modify the metapage, and a shared</font></div><div><font size="2"   >buffer content lock is used when such modifications need to be</font></div><div><font size="2"   >prevented. &nbsp;This more relaxed locking regimen makes it possible that,</font></div><div><font size="2"   >when we're busy getting a heavyweight bucket on the bucket we intend</font></div><div><font size="2"   >to search or insert into, a bucket split might occur underneath us.</font></div><div><font size="2"   >To compenate for that possibility, we use a loop-and-retry system:</font></div><div><font size="2"   >release the metapage content lock, acquire the heavyweight lock on the</font></div><div><font size="2"   >target bucket, and then reacquire the metapage content lock and check</font></div><div><font size="2"   >that the bucket mapping has not changed. &nbsp; Normally it hasn't, and</font></div><div><font size="2"   >we're done. &nbsp;But if by chance it has, we simply unlock the metapage,</font></div><div><font size="2"   >release the heavyweight lock we acquired previously, lock the new</font></div><div><font size="2"   >bucket, and loop around again. &nbsp;Even in the worst case we cannot loop</font></div><div><font size="2"   >very many times here, since we don't split the same bucket again until</font></div><div><font size="2"   >we've split all the other buckets, and 2^N gets big pretty fast.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >This results in greatly improved concurrency, because we're</font></div><div><font size="2"   >effectively replacing two lwlock acquire-and-release cycles in</font></div><div><font size="2"   >exclusive mode (on one of the lock manager locks) with a single</font></div><div><font size="2"   >acquire-and-release cycle in shared mode (on the metapage buffer</font></div><div><font size="2"   >content lock). &nbsp;Testing shows that it's still not quite as good as</font></div><div><font size="2"   >btree; for that, we'd probably have to find some way of getting rid</font></div><div><font size="2"   >of the heavyweight bucket locks as well, which does not appear</font></div><div><font size="2"   >straightforward.</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>