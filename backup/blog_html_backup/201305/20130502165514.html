<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Postgres-XC customized aggregate introduction</h2>
	<h5 id="">2013-05-02 16:55:14&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020134222140958/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>Postgres-XC聚合与PostgreSQL的聚合有一定的区别, 因为Postgres-XC的数据存储在datanode, 聚合时数据可能分布在多个datanode上.</div><div>Postgres-XC支持传统的聚合方法, 聚合操作可以将数据从所有的数据节点传到coordinator节点后, 在coordinator节点进行聚合. 但是这种方法对于数据量较大的情况效率明显偏低.&nbsp;</div><div>Postgres-XC还支持另一种聚合方式, 就是数据在各自的datanode执行, 形成结果后, 将datanode聚合的结果传输到coordinator节点再次聚合.</div><div>如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sfunc( internal-state, next-data-values ) ---&gt; next-internal-state &nbsp;# 这个过程是在datanode节点完成的. input 是该datanode节点上的所有行(一次1行的进行调用).</font></div><div><font size="2"   >cfunc( internal-state, internal-state ) ---&gt; next-internal-state &nbsp;<span style="line-height: 22px;"   ># 这个过程是在coordinator节点完成的. input是datanode节点的最终结果.</span></font></div><div><font size="2"   >ffunc( internal-state ) ---&gt; aggregate-value # 这个过程是在coordinator节点完成的. input是cfunc的结果.</font></div><p></p></pre></div><div>语法如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE AGGREGATE name ( input_data_type [ , ... ] ) (</font></div><div><font size="2"   >&nbsp; &nbsp; SFUNC = sfunc,</font></div><div><font size="2"   >&nbsp; &nbsp; STYPE = state_data_type</font></div><div><font size="2"   >&nbsp; &nbsp; [ , CFUNC = cfunc ]</font></div><div><font size="2"   >&nbsp; &nbsp; [ , FINALFUNC = ffunc ]</font></div><div><font size="2"   >&nbsp; &nbsp; [ , INITCOND = initial_condition ]</font></div><div><font size="2"   >&nbsp; &nbsp; [ , INITCOLLECT = initial_collection_condition ]</font></div><div><font size="2"   >&nbsp; &nbsp; [ , SORTOP = sort_operator ]</font></div><div><font size="2"   >)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >or the old syntax</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CREATE AGGREGATE name (</font></div><div><font size="2"   >&nbsp; &nbsp; BASETYPE = base_type,</font></div><div><font size="2"   >&nbsp; &nbsp; SFUNC = sfunc,</font></div><div><font size="2"   >&nbsp; &nbsp; STYPE = state_data_type</font></div><div><font size="2"   >&nbsp; &nbsp; [ , FINALFUNC = ffunc ]</font></div><div><font size="2"   >&nbsp; &nbsp; [ , INITCOND = initial_condition ]</font></div><div><font size="2"   >&nbsp; &nbsp; [ , SORTOP = sort_operator ]</font></div><div><font size="2"   >)</font></div><p></p></pre></div><div>sfunc和stype是必须的. 如果没有定义cfunc那么这个聚合就只支持传统的聚合方法.&nbsp;</div><div>如果定义了cfunc, 那么这个聚合支持传统的聚合方法, 同时还支持分布式聚合方法.</div><div>例如 :&nbsp;</div><div># 创建sfunc</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create or replace function d_sum(int,int) returns int as $$</font></div><div><font size="2"   >select $1+$2;</font></div><div><font size="2"   >$$ language sql strict;</font></div><p></p></pre></div><div># 创建聚合</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create AGGREGATE d_sum(int) &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >(</font></div><div><font size="2"   >sfunc=d_sum,</font></div><div><font size="2"   >stype=int,</font></div><div><font size="2"   >cfunc=d_sum,</font></div><div><font size="2"   >initcond='0',</font></div><div><font size="2"   >initcollect='0'</font></div><div><font size="2"   >);</font></div><p></p></pre></div><div># 创建测试表</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table t1(id int, info text) distribute by (id) to group gp0;</font></div><div><font size="2"   >digoal=# insert into t1 select generate_series(1,10),'test';</font></div><div><font size="2"   >digoal=# insert into t1 values (null,'test');</font></div><p></p></pre></div><div># 比较d_sum和sum的聚合结果</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# select d_sum(id) from t1;</font></div><div><font size="2"   >&nbsp;d_sum&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp; 55</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=# select sum(id) from t1;</font></div><div><font size="2"   >&nbsp;sum&nbsp;</font></div><div><font size="2"   >-----</font></div><div><font size="2"   >&nbsp; 55</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div># 比较sum和d_sum的执行计划</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select d_sum(id) from t1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >---</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=250.00..250.01 rows=1 width=4) (actual time=1.657..1.657 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: d_sum((d_sum(t1.id)))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Materialize &nbsp;(cost=0.00..0.00 rows=0 width=0) (actual time=0.703..0.743 rows=5 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: (d_sum(t1.id))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Data Node Scan on "__REMOTE_GROUP_QUERY__" &nbsp;(cost=0.00..0.00 rows=1000 width=4) (actual time=0.702..0.740 rows=5 loops=</font></div><div><font size="2"   >1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: d_sum(t1.id)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Node/s: datanode_1, datanode_2, datanode_3, datanode_4, datanode_5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Remote query: SELECT d_sum(group_1.id) &nbsp;FROM (SELECT id, info FROM ONLY t1 WHERE true) group_1 &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;Total runtime: 1.689 ms</font></div><div><font size="2"   >(9 rows)</font></div><p></p></pre></div><div>d_sum, sum两者都是有了分布式聚合.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select sum(id) from t1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >---</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=2.50..2.51 rows=1 width=4) (actual time=0.674..0.674 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: pg_catalog.sum((sum(t1.id)))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Materialize &nbsp;(cost=0.00..0.00 rows=0 width=0) (actual time=0.507..0.659 rows=5 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: (sum(t1.id))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Data Node Scan on "__REMOTE_GROUP_QUERY__" &nbsp;(cost=0.00..0.00 rows=1000 width=4) (actual time=0.507..0.655 rows=5 loops=</font></div><div><font size="2"   >1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: sum(t1.id)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Node/s: datanode_1, datanode_2, datanode_3, datanode_4, datanode_5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Remote query: SELECT sum(group_1.id) &nbsp;FROM (SELECT id, info FROM ONLY t1 WHERE true) group_1 &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;Total runtime: 0.705 ms</font></div><div><font size="2"   >(9 rows)</font></div></pre></div></div><div>假如没有cfunc, 再次比较d_sum和sum的执行计划 :&nbsp;</div><div># 在没有cfunc的情况下, 数据必须从所有的datanode汇总到coordinator节点后执行sfunc聚合.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# drop AGGREGATE d_sum(int);</font></div><div><font size="2"   >DROP AGGREGATE</font></div><div><font size="2"   >digoal=# create AGGREGATE d_sum(int)&nbsp;</font></div><div><font size="2"   >(</font></div><div><font size="2"   >sfunc=d_sum,</font></div><div><font size="2"   >stype=int,</font></div><div><font size="2"   >initcond='0'</font></div><div><font size="2"   >);</font></div><div><font size="2"   >CREATE AGGREGATE</font></div><div><font size="2"   >digoal=# select d_sum(id) from t1;</font></div><div><font size="2"   >&nbsp;d_sum&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp; 55</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select d_sum(id) from t1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=250.00..250.01 rows=1 width=4) (actual time=1.981..1.981 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: d_sum(id)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Data Node Scan on t1 &nbsp;(cost=0.00..0.00 rows=1000 width=4) (actual time=0.567..0.610 rows=11 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Node/s: datanode_1, datanode_2, datanode_3, datanode_4, datanode_5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Remote query: SELECT id, info FROM ONLY t1 WHERE true</font></div><div><font size="2"   >&nbsp;Total runtime: 2.015 ms</font></div><div><font size="2"   >(7 rows)</font></div></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >聚合数据处理流程简介 :&nbsp;</span></div><div><span style="line-height: 22px;"   >1.数据汇总聚合方法数据处理流程 : &nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Two phased aggregation - is used when the entire aggregation takes place on the Coordinator node.&nbsp;</font></div><div><font size="2"   >In first phase called transition phase, Postgres-XC creates a temporary variable of data type stype to hold the current internal state of the aggregate.&nbsp;</font></div><div><font size="2"   >At each input row, the aggregate argument value(s) are calculated and the state transition function is invoked with the current state value and the new argument value(s) to calculate a new internal state value.&nbsp;</font></div><div><font size="2"   >After all the rows have been processed, in the second phase or finalization phase the final function is invoked once to calculate the aggregate's return value.&nbsp;</font></div><div><font size="2"   >If there is no final function then the ending state value is returned as-is.</font></div></pre></div><div><span style="line-height: 22px;"   >2.分布式聚合方法数据处理流程 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Three phased aggregation - is used when the process of aggregation is divided between Coordinator and Datanodes.&nbsp;</font></div><div><font size="2"   >In this mode, each Postgres-XC Datanode involved in the query carries out the first phase named transition phase.&nbsp;</font></div><div><font size="2"   >This phase is similar to the first phase in the two phased aggregation mode discussed above, except that, every Datanode applies this phase on the rows available at the Datanode.&nbsp;</font></div><div><font size="2"   >The result of transition phase is then transferred to the Coordinator node. Second phase called collection phase takes place on the Coordinator.&nbsp;</font></div><div><font size="2"   >Postgres-XC Coordinator node creates a temporary variable of data type stype to hold the current internal state of the collection phase.&nbsp;</font></div><div><font size="2"   >For every input from the Datanode (result of transition phase on that node), the collection function is invoked with the current collection state value and the new transition value (obtained from the Datanode) to calculate a new internal collection state value.&nbsp;</font></div><div><font size="2"   >After all the transition values from data nodes have been processed, in the third or finalization phase the final function is invoked once to calculate the aggregate's return value.&nbsp;</font></div><div><font size="2"   >If there is no final function then the ending collection state value is returned as-is.</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >聚合中的数据类型简介 :&nbsp;</span></div><div><div>sfunc( internal-state, next-data-values ) ---&gt; next-internal-state</div><div>cfunc( internal-state, internal-state ) ---&gt; next-internal-state</div><div>ffunc( internal-state ) ---&gt; aggregate-value</div></div><div>聚合语法中的 input_data_type 对应&nbsp;next-data-values</div><div><span style="line-height: 22px;"   >聚合语法中的</span><span style="line-height: 22px;"   >&nbsp;</span>state_data_type 对应&nbsp;internal-state</div><div><span style="line-height: 22px;"   >聚合最终输出类型有两种</span><span style="line-height: 22px;"   >aggregate-value 或者&nbsp;</span><span style="line-height: 22px;"   >internal-state.&nbsp;</span></div><div><span style="line-height: 22px;"   >1. 当定义了finalfunc时是finalfunc的返回类型.</span></div><div><span style="line-height: 22px;"   >2. 当没有定义finalfunc时, 输出类型是cfunc或者sfunc的返回类型, 也就是internal-state类型, 既stype.</span></div><div><span style="line-height: 22px;"   >从流程来分析, sfunc的第一个参数的数据类型以及返回数据类型都必须和stype定义的类型相同.</span></div><div>sfunc的第二个参数必须和聚合的input类型相同.&nbsp;</div><div>cfunc的两个参数以及返回类型都必须和stype定义的类型相同.</div><div>ffunc的输入参数必须和stype定义的类型相同.</div><div>所以整个聚合涉及了3个数据类型:&nbsp;</div><div>1.聚合的输入类型,&nbsp;</div><div>2.stype , (同时initcond, initcollect类型=stype);</div><div>3.以及 finalfunc的返回类型.</div><div><br></div><div><span style="line-height: 22px;"   >聚合对空值的处理简介 :&nbsp;</span></div><div><span style="line-height: 22px;"   >与sfunc,cfunc,finalfunc的定义有关, 是否strict. 是则忽略null值, 不进行调用.&nbsp;</span></div><div><span style="line-height: 22px;"   >不是strict则需要函数自己处理null值. 所以要特别小心.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >An aggregate function can provide an initial condition, that is, an initial value for the internal transition or collection state value. This is specified and stored in the database as a value of type text, but it must be a valid external representation of a constant of the state value data type. If it is not supplied then the state value starts out null.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >If the collection function is declared "strict", then it cannot be called with null inputs. With such a collection function, aggregate execution behaves as follows. Null state transition results are ignored (the function is not called and the previous collection state value is retained). If the initial state value is null, then at the first non-null state transition result replaces the collection state value, and the collection function is invoked at subsequent rows with all-nonnull transition values. This is handy for implementing aggregates like max.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >If the state transition function is declared "strict", then it cannot be called with null inputs. With such a transition function, aggregate execution behaves as follows. Rows with any null input values are ignored (the function is not called and the previous state value is retained). If the initial state value is null, then at the first row with all-nonnull input values, the first argument value replaces the state value, and the transition function is invoked at subsequent rows with all-nonnull input values. This is handy for implementing aggregates like max. Note that this behavior is only available when state_data_type is the same as the first input_data_type. When these types are different, you must supply a nonnull initial condition or use a nonstrict transition function.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >If the state transition and/or collection function is not strict, then it will be called unconditionally at each input row, and must deal with null inputs and null transition/collection values for itself. This allows the aggregate author to have full control over the aggregate's handling of null values.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >If the final function is declared "strict", then it will not be called when the ending state value is null; instead a null result will be returned automatically. (Of course this is just the normal behavior of strict functions.) In any case the final function has the option of returning a null value. For example, the final function for avg returns null when it sees there were zero input rows.</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >例如count, id有一条为null :&nbsp;</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select count(id) from t1;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp; 10</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=# select count(*) from t1;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp; 11</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >假如把d_sum(int,int)函数改成called on null input.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >这种情况下, 即使row取到的是空值也会调用func. 因此null+val=null, 最后得到的就是null了.</span></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><pre class="prettyprint"   style="line-height: 22px;"   ><p style="line-height: 22px;"   ></p><div style="line-height: 22px;"   ><font size="2"   style="line-height: 19px;"   >digoal=# alter function d_sum(int,int) called on null input;</font></div><div style="line-height: 22px;"   ><font size="2"   style="line-height: 19px;"   >ALTER FUNCTION</font></div><div style="line-height: 22px;"   ><font size="2"   style="line-height: 19px;"   >digoal=# select d_sum(id) from t1;</font></div><div style="line-height: 22px;"   ><font size="2"   style="line-height: 19px;"   >&nbsp;d_sum&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   style="line-height: 19px;"   >-------</font></div><div style="line-height: 22px;"   ><font size="2"   style="line-height: 19px;"   >&nbsp; &nbsp; &nbsp;&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   style="line-height: 19px;"   >(1 row)</font></div></pre></div></div></div></div></div><div>聚合的优化, 使用btree.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sort_operator</font></div><div><font size="2"   >The associated sort operator for a MIN- or MAX-like aggregate. This is just an operator name (possibly schema-qualified). The operator is assumed to have the same input data types as the aggregate (which must be a single-argument aggregate).</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Aggregates that behave like MIN or MAX can sometimes be optimized by looking into an index instead of scanning every input row. If this aggregate can be so optimized, indicate it by specifying a sort operator. The basic requirement is that the aggregate must yield the first element in the sort ordering induced by the operator; in other words:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SELECT agg(col) FROM tab;</font></div><div><font size="2"   >must be equivalent to:</font></div><div><font size="2"   >SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Further assumptions are that the aggregate ignores null inputs, and that it delivers a null result if and only if there were no non-null inputs. Ordinarily, a data type's &lt; operator is the proper sort operator for MIN, and &gt; is the proper sort operator for MAX. Note that the optimization will never actually take effect unless the specified operator is the "less than" or "greater than" strategy member of a B-tree index operator class.</font></div><p></p></pre></div><div><br></div><div>定义类似count(*)这样的无参数聚合:</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# select * from pg_aggregate where aggfnoid::text ~ 'count';</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;aggfnoid &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp;aggtransfn &nbsp; &nbsp; &nbsp; | &nbsp; aggcollectfn &nbsp; | aggfinalfn | aggsortop | aggtranstype | agginitval | agginitcollect&nbsp;</font></div><div><font size="2"   >------------------+-----------------------+------------------+------------+-----------+--------------+------------+----------------</font></div><div><font size="2"   >&nbsp;pg_catalog.count | int8inc_any &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | int8_sum_to_int8 | - &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 20 | 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 0</font></div><div><font size="2"   >&nbsp;pg_catalog.count | int8inc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | int8_sum_to_int8 | - &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 20 | 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 0</font></div></div><div><div><font size="2"   >digoal=# \df+ int8inc_any</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of functions</font></div><div><font size="2"   >&nbsp; &nbsp;Schema &nbsp; | &nbsp; &nbsp;Name &nbsp; &nbsp; | Result data type | Argument data types | &nbsp;Type &nbsp;| Volatility | &nbsp;Owner &nbsp; | Language | Source code | &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; Description &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------+-------------+------------------+---------------------+--------+------------+----------+----------+-------------+------</font></div><div><font size="2"   >------------------------------</font></div><div><font size="2"   >&nbsp;pg_catalog | int8inc_any | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | bigint, "any" &nbsp; &nbsp; &nbsp; | normal | immutable &nbsp;| postgres | internal | int8inc_any | incre</font></div><div><font size="2"   >ment, ignores second argument</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# \df+ int8inc</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List of functions</font></div><div><font size="2"   >&nbsp; &nbsp;Schema &nbsp; | &nbsp;Name &nbsp; | Result data type | Argument data types | &nbsp;Type &nbsp;| Volatility | &nbsp;Owner &nbsp; | Language | Source code | Descripti</font></div><div><font size="2"   >on&nbsp;</font></div><div><font size="2"   >------------+---------+------------------+---------------------+--------+------------+----------+----------+-------------+----------</font></div><div><font size="2"   >---</font></div><div><font size="2"   >&nbsp;pg_catalog | int8inc | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| normal | immutable &nbsp;| postgres | internal | int8inc &nbsp; &nbsp; | increment</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >digoal=# select proisstrict from pg_proc where proname='int8inc';<br> proisstrict <br>-------------<br> t<br>(1 row)<br>digoal=# select proisstrict from pg_proc where proname='int8inc_any';<br> proisstrict <br>-------------<br> t<br>(1 row)<br></font></div><p></p></pre></div><div>以上count实际上分了两种, 一种是count(列名字), 一种是count(*). int8inc_any用于count(列名), int8inc用于count(*).</div><div>举例 :&nbsp;</div><div>-- 创建sfunc</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create or replace function d_count(int8) returns int8 as $$ &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >select $1+1;&nbsp;</font></div><div><font size="2"   >$$ language sql strict;</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >-- 创建cfunc</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create or replace function d_count(int8,int8) returns int8 as $$</font></div><div><font size="2"   >select $1+$2;</font></div><div><font size="2"   >$$ language sql strict;</font></div><p></p></pre></div><div>-- 创建聚合</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create aggregate d_count(*) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >sfunc=d_count,</font></div><div><font size="2"   >stype=int8,</font></div><div><font size="2"   >cfunc=d_count,</font></div><div><font size="2"   >initcond='0',</font></div><div><font size="2"   >initcollect='0'</font></div><div><font size="2"   >);</font></div></div><div><div><font size="2"   >digoal=# select d_count(*) from t1;</font></div><div><font size="2"   >&nbsp;d_count&nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 11</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select d_count(*) from t1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >---</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=250.00..250.01 rows=1 width=0) (actual time=1.308..1.308 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: sj.d_count(*)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Materialize &nbsp;(cost=0.00..0.00 rows=0 width=0) (actual time=0.712..0.725 rows=5 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: (d_count(*))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Data Node Scan on "__REMOTE_GROUP_QUERY__" &nbsp;(cost=0.00..0.00 rows=1000 width=0) (actual time=0.712..0.721 rows=5 loops=</font></div><div><font size="2"   >1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: d_count(*)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Node/s: datanode_1, datanode_2, datanode_3, datanode_4, datanode_5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Remote query: SELECT d_count(*) &nbsp;FROM (SELECT id, info FROM ONLY t1 WHERE true) group_1 &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;Total runtime: 1.339 ms</font></div><div><font size="2"   >(9 rows)</font></div></div><p></p></pre></div><div><br></div><div>注意, 为什么d_count(id)得到的结果不是10呢? 因为我没有定义d_count("any"), 只定义了d_count(*) :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select d_count(id) from t1; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp;d_count&nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;2</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;3</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;4</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;9</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 10</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;6</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;7</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;8</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 11</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >(11 rows)</font></div><p></p></pre></div><div>因为这里的d_count是普通函数, 而不是聚合.&nbsp;</div><div>实际上调用的是d_count(int8)函数.</div><div>将sfunc,cfunc改名后就更能看出来了.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# alter function d_count(int8) rename to s_d_count;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><div><font size="2"   >Time: 18.591 ms</font></div><div><font size="2"   >digoal=# alter function d_count(int8,int8) rename to c_d_count;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><div><font size="2"   >Time: 4.049 ms</font></div></div><div><div><font size="2"   >digoal=# create aggregate d_count(*) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >sfunc=s_d_count,</font></div><div><font size="2"   >stype=int8,</font></div><div><font size="2"   >cfunc=c_d_count,</font></div><div><font size="2"   >initcond='0',</font></div><div><font size="2"   >initcollect='0'</font></div><div><font size="2"   >);</font></div><div><font size="2"   >CREATE AGGREGATE</font></div><div><font size="2"   >Time: 21.752 ms</font></div><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select d_count(*) from t1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >---</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=250.00..250.01 rows=1 width=0) (actual time=1.732..1.732 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: sj.d_count(*)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Materialize &nbsp;(cost=0.00..0.00 rows=0 width=0) (actual time=0.986..1.008 rows=5 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: (d_count(*))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Data Node Scan on "__REMOTE_GROUP_QUERY__" &nbsp;(cost=0.00..0.00 rows=1000 width=0) (actual time=0.985..1.002 rows=5 loops=</font></div><div><font size="2"   >1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: d_count(*)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Node/s: datanode_1, datanode_2, datanode_3, datanode_4, datanode_5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Remote query: SELECT d_count(*) &nbsp;FROM (SELECT id, info FROM ONLY t1 WHERE true) group_1 &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;Total runtime: 1.766 ms</font></div><div><font size="2"   >(9 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Time: 3.088 ms</font></div><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select d_count(id) from t1;</font></div><div><font size="2"   >ERROR: &nbsp;function d_count(integer) does not exist</font></div><div><font size="2"   >LINE 1: explain (analyze,verbose,buffers) select d_count(id) from t1...</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div><font size="2"   >HINT: &nbsp;No function matches the given name and argument types. You might need to add explicit type casts.</font></div></div><p></p></pre></div><div>定义类似count(*)和count(列名)的函数还有一个count(列名)是怎么定义的呢, 如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create or replace function s_d_count(int8,"anyelement") returns int8 as $$</font></div><div><font size="2"   >select $1+1;</font></div><div><font size="2"   >$$ language sql strict;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><div><font size="2"   >Time: 4.715 ms</font></div><div><font size="2"   >digoal=# create aggregate d_count("anyelement") &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >sfunc=s_d_count,</font></div><div><font size="2"   >stype=int8,</font></div><div><font size="2"   >cfunc=c_d_count,</font></div><div><font size="2"   >initcond='0',</font></div><div><font size="2"   >initcollect='0'</font></div><div><font size="2"   >);</font></div><div><font size="2"   >CREATE AGGREGATE</font></div><div><font size="2"   >Time: 69.536 ms</font></div><div><font size="2"   >digoal=# select d_count(id) from t1;</font></div><div><font size="2"   >&nbsp;d_count&nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 10</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 3.694 ms</font></div><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select d_count(id) from t1;<br>                                                              QUERY PLAN                                                            <br>   <br>------------------------------------------------------------------------------------------------------------------------------------<br>---<br> Aggregate  (cost=250.00..250.01 rows=1 width=4) (actual time=1.913..1.913 rows=1 loops=1)<br>   Output: d_count((d_count(t1.id)))<br>   -&gt;  Materialize  (cost=0.00..0.00 rows=0 width=0) (actual time=0.893..0.923 rows=5 loops=1)<br>         Output: (d_count(t1.id))<br>         -&gt;  Data Node Scan on "__REMOTE_GROUP_QUERY__"  (cost=0.00..0.00 rows=1000 width=4) (actual time=0.892..0.917 rows=5 loops=<br>1)<br>               Output: d_count(t1.id)<br>               Node/s: datanode_1, datanode_2, datanode_3, datanode_4, datanode_5<br>               Remote query: SELECT d_count(group_1.id)  FROM (SELECT id, info FROM ONLY t1 WHERE true) group_1   <br> Total runtime: 1.947 ms<br>(9 rows)</font></div><p></p></pre></div><div>第二个d_count聚合复用了前面定义的c_d_count(int8,int8).</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from pg_aggregate where aggfnoid::text ~ 'd_count';</font></div><div><font size="2"   >&nbsp; aggfnoid &nbsp;| &nbsp;aggtransfn &nbsp;| aggcollectfn | aggfinalfn | aggsortop | aggtranstype | agginitval | agginitcollect&nbsp;</font></div><div><font size="2"   >------------+--------------+--------------+------------+-----------+--------------+------------+----------------</font></div><div><font size="2"   >&nbsp;sj.d_count | sj.s_d_count | c_d_count &nbsp; &nbsp;| - &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 20 | 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 0</font></div><div><font size="2"   >&nbsp;sj.d_count | sj.s_d_count | c_d_count &nbsp; &nbsp;| - &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 20 | 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 0</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   >Time: 2.811 ms</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >[注意]</span></div><div><span style="line-height: 22px;"   >1. 如果你定义的聚合既支持分布式聚合同时又支持传统的数据汇总聚合, Postgres-XC会根据成本选择合适的聚合方法, 所以在这种情况下, 必须确保两种聚合方法得到的聚合结果是一致的. 否则就出大问题了.</span></div><div><span style="line-height: 22px;"   >2. 聚合最好不要与函数名重复. 否则会难以排错.&nbsp;</span></div><div><br></div>[参考]<br>1.&nbsp;<wbr><a rel="nofollow" href="http://postgres-xc.sourceforge.net/docs/1_0_3/xaggr.html"   >http://postgres-xc.sourceforge.net/docs/1_0_3/xaggr.html</a><div>2.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://postgres-xc.sourceforge.net/docs/1_0_3/sql-createaggregate.html"   >http://postgres-xc.sourceforge.net/docs/1_0_3/sql-createaggregate.html</a></div><div>3.&nbsp;<a style="line-height: 22px;" href="http://blog.163.com/digoal@126/blog/static/16387704020121118112533410/"   >http://blog.163.com/digoal@126/blog/static/16387704020121118112533410/</a></div></div>
	</div>
</div>
</body>
</html>