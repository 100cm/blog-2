<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL WHY modify numeric scale must rewrite table</h2>
	<h5 id="">2013-08-23 15:44:14&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201372331934738/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">前段时间写过一篇关于如何从typmod取出numeric长度和精度的文章, 本文也有牵涉, 所以有兴趣的朋友可以先预读此文 :&nbsp;<div><a href="http://blog.163.com/digoal@126/blog/static/163877040201371763839672/"   >http://blog.163.com/digoal@126/blog/static/163877040201371763839672/</a></div><div>本文要讲的是今天群里一位朋友提到的, PostgreSQL在修改numeric类型精度的时候, 很慢的问题.</div><div>很慢的原因是修改精度的时候底层的数据变更了, 需要重建表. 所以如果数据量很大的表, 改精度是会很慢的.</div><div>首先来做个实验, 为什么要rewrite表的原因后面具体给出.</div><div>测试表</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create table t(id numeric(10,2));</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# insert into t select generate_series(1,10000);</font></div><div><font size="2"   >INSERT 0 10000</font></div></div><div><div><font size="2"   >digoal=# select pg_relation_filepath('t'::regclass);</font></div><div><font size="2"   >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;base/16384/17542</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div><div>当扩展长度时, 没有rewrite table.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# alter table t alter column id type numeric(11,2);</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=# select pg_relation_filepath('t'::regclass);</font></div><div><font size="2"   >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;base/16384/17542</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>当降低长度时,发生了rewrite.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# alter table t alter column id type numeric(9,2);</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=# select pg_relation_filepath('t'::regclass);</font></div><div><font size="2"   >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;base/16384/17545</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# alter table t alter column id type numeric(8,2);</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=# select pg_relation_filepath('t'::regclass);</font></div><div><font size="2"   >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;base/16384/17548</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div></div><div><div>当修改了精度时, 也需要rewrite table.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# alter table t alter column id type numeric(19,3);</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=# select pg_relation_filepath('t'::regclass);</font></div><div><font size="2"   >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;base/16384/17551</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div>降低精度和扩展精度一样, 都会rewrite table.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# alter table t alter column id type numeric(19,2);</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=# select pg_relation_filepath('t'::regclass);</font></div><div><font size="2"   >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;base/16384/17554</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>在oracle中的测试如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >SQL&gt; create table t(id numeric(10,2));</font></div><div><font size="2"   >Table created.</font></div></div><div><div><font size="2"   >SQL&gt; insert into t select rownum from dual connect by level &lt;=10000;</font></div><div><font size="2"   >10000 rows created.</font></div></div><div><div><font size="2"   >SQL&gt; set pagesize 1000 linesize 190</font></div><div><font size="2"   >SQL&gt; select * from dba_extents where segment_name='T';</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >OWNER &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SEGMENT_NAME &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PARTITION_NAME SEGMENT_TYPE</font></div><div><font size="2"   >------------------------------ --------------------------------------------------------------------------------- ------------------------------ ------------------</font></div><div><font size="2"   >TABLESPACE_NAME &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXTENT_ID &nbsp; &nbsp;FILE_ID &nbsp; BLOCK_ID &nbsp; &nbsp; &nbsp;BYTES &nbsp; &nbsp; BLOCKS RELATIVE_FNO</font></div><div><font size="2"   >------------------------------ ---------- ---------- ---------- ---------- ---------- ------------</font></div><div><font size="2"   >SYS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TTABLE</font></div><div><font size="2"   >SYSTEM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp;61513 &nbsp; &nbsp; &nbsp;65536 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SYS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TTABLE</font></div><div><font size="2"   >SYSTEM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp;61521 &nbsp; &nbsp; &nbsp;65536 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SYS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TTABLE</font></div><div><font size="2"   >SYSTEM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp;61529 &nbsp; &nbsp; &nbsp;65536 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div></div><p></p></pre></div><div><div>扩展精度不会带来rewrite table.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; alter table t modify id numeric(12,3);</font></div><div><font size="2"   >Table altered.</font></div><div><font size="2"   >SQL&gt; select * from dba_extents where segment_name='T';</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >OWNER &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SEGMENT_NAME &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PARTITION_NAME SEGMENT_TYPE</font></div><div><font size="2"   >------------------------------ --------------------------------------------------------------------------------- ------------------------------ ------------------</font></div><div><font size="2"   >TABLESPACE_NAME &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXTENT_ID &nbsp; &nbsp;FILE_ID &nbsp; BLOCK_ID &nbsp; &nbsp; &nbsp;BYTES &nbsp; &nbsp; BLOCKS RELATIVE_FNO</font></div><div><font size="2"   >------------------------------ ---------- ---------- ---------- ---------- ---------- ------------</font></div><div><font size="2"   >SYS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TTABLE</font></div><div><font size="2"   >SYSTEM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp;61513 &nbsp; &nbsp; &nbsp;65536 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SYS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TTABLE</font></div><div><font size="2"   >SYSTEM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp;61521 &nbsp; &nbsp; &nbsp;65536 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SYS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TTABLE</font></div><div><font size="2"   >SYSTEM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp;61529 &nbsp; &nbsp; &nbsp;65536 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><p></p></pre></div></div><div><div>在不增加长度的情况下, 不允许扩展长度.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; alter table t modify id numeric(12,4);</font></div><div><font size="2"   >alter table t modify id numeric(12,4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >ERROR at line 1:</font></div><div><font size="2"   >ORA-01440: column to be modified must be empty to decrease precision or scale</font></div><p></p></pre></div></div><div>长度和精度同时扩展, 不会rewrite table.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >SQL&gt; alter table t modify id numeric(13,4);</font></div><div><font size="2"   >Table altered.</font></div></div><div><div><font size="2"   >SQL&gt; select * from dba_extents where segment_name='T';</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >OWNER &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SEGMENT_NAME &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PARTITION_NAME SEGMENT_TYPE</font></div><div><font size="2"   >------------------------------ --------------------------------------------------------------------------------- ------------------------------ ------------------</font></div><div><font size="2"   >TABLESPACE_NAME &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXTENT_ID &nbsp; &nbsp;FILE_ID &nbsp; BLOCK_ID &nbsp; &nbsp; &nbsp;BYTES &nbsp; &nbsp; BLOCKS RELATIVE_FNO</font></div><div><font size="2"   >------------------------------ ---------- ---------- ---------- ---------- ---------- ------------</font></div><div><font size="2"   >SYS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TTABLE</font></div><div><font size="2"   >SYSTEM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp;61513 &nbsp; &nbsp; &nbsp;65536 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SYS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TTABLE</font></div><div><font size="2"   >SYSTEM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp;61521 &nbsp; &nbsp; &nbsp;65536 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SYS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TTABLE</font></div><div><font size="2"   >SYSTEM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp;61529 &nbsp; &nbsp; &nbsp;65536 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div></div><p></p></pre></div><div><br></div><div>PostgreSQL中为什么修改scale, 也就是精度会导致rewrite table 呢?</div><div>来看看物理存储(cstring), 4个有效小数位, 末尾会存储00</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select numeric_out(100.12::numeric(10,4));</font></div><div><font size="2"   >&nbsp;numeric_out&nbsp;</font></div><div><font size="2"   >-------------</font></div><div><font size="2"   >&nbsp;100.1200</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>3个有效位, 末尾多一个0</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select numeric_out(100.12::numeric(10,3));</font></div><div><font size="2"   >&nbsp;numeric_out&nbsp;</font></div><div><font size="2"   >-------------</font></div><div><font size="2"   >&nbsp;100.120</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>5个有效位, 末尾多3个0</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select numeric_out(100.12::numeric(10,5));</font></div><div><font size="2"   >&nbsp;numeric_out&nbsp;</font></div><div><font size="2"   >-------------</font></div><div><font size="2"   >&nbsp;100.12000</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>当扩展长度时, 存储的数字和前面一样, 因为只存储了有效数字.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select numeric_out(100.12::numeric(20,5));</font></div><div><font size="2"   >&nbsp;numeric_out&nbsp;</font></div><div><font size="2"   >-------------</font></div><div><font size="2"   >&nbsp;100.12000</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div><br></div><div>下面通过物理存储来得到面向用户的输出, 首先我们如果要输出numeric(10,2)这样的数据. 先得到typmod.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select numerictypmodin(_cstring '{10,2}');</font></div><div><font size="2"   >&nbsp;numerictypmodin&nbsp;</font></div><div><font size="2"   >-----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 655366</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>然后使用numeric_in得到面向用户的输出.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# select numeric_in('100.1200',1700,655366);</font></div><div><font size="2"   >&nbsp;numeric_in&nbsp;</font></div><div><font size="2"   >------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;100.12</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=# select numeric_in('100.1550',1700,655366);</font></div><div><font size="2"   >&nbsp;numeric_in&nbsp;</font></div><div><font size="2"   >------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;100.16</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div>在物理存储和typmod不匹配的情况下, 输出的值和物理存储不一致.</div><div>因此PostgreSQL这套数字物理存储, 就决定了在修改精度时必须要rewrite table.</div><div><br></div><div>如果通过修改catalog来达到修改长度的目的, 可以这么做.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# \d t1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Table "public.t1"</font></div><div><font size="2"   >&nbsp;Column | &nbsp; &nbsp; Type &nbsp; &nbsp; &nbsp;| Modifiers&nbsp;</font></div><div><font size="2"   >--------+---------------+-----------</font></div><div><font size="2"   >&nbsp;id &nbsp; &nbsp; | numeric(10,3) |&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select * from t1;</font></div><div><font size="2"   >&nbsp; &nbsp;id &nbsp; &nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;123.556</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >假设我们要缩小精度到numeric(10,2). </font></div><div><div><font size="2"   >digoal=# select numerictypmodin(_cstring '{10,2}');</font></div><div><font size="2"   >&nbsp;numerictypmodin&nbsp;</font></div><div><font size="2"   >-----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 655366</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=# select * from pg_attribute where attrelid ='t1'::regclass and attname='id';</font></div><div><font size="2"   >-[ RECORD 1 ]-+-------</font></div><div><font size="2"   >attrelid &nbsp; &nbsp; &nbsp;| 16481</font></div><div><font size="2"   >attname &nbsp; &nbsp; &nbsp; | id</font></div><div><font size="2"   >atttypid &nbsp; &nbsp; &nbsp;| 1700</font></div><div><font size="2"   >attstattarget | -1</font></div><div><font size="2"   >attlen &nbsp; &nbsp; &nbsp; &nbsp;| -1</font></div><div><font size="2"   >attnum &nbsp; &nbsp; &nbsp; &nbsp;| 1</font></div><div><font size="2"   >attndims &nbsp; &nbsp; &nbsp;| 0</font></div><div><font size="2"   >attcacheoff &nbsp; | -1</font></div><div><font size="2"   >atttypmod &nbsp; &nbsp; | 655367</font></div><div><font size="2"   >attbyval &nbsp; &nbsp; &nbsp;| f</font></div><div><font size="2"   >attstorage &nbsp; &nbsp;| m</font></div><div><font size="2"   >attalign &nbsp; &nbsp; &nbsp;| i</font></div><div><font size="2"   >attnotnull &nbsp; &nbsp;| f</font></div><div><font size="2"   >atthasdef &nbsp; &nbsp; | f</font></div><div><font size="2"   >attisdropped &nbsp;| f</font></div><div><font size="2"   >attislocal &nbsp; &nbsp;| t</font></div><div><font size="2"   >attinhcount &nbsp; | 0</font></div><div><font size="2"   >attcollation &nbsp;| 0</font></div><div><font size="2"   >attacl &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >attoptions &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >attfdwoptions |&nbsp;</font></div><div><font size="2"   >调整catalog后, 精度修改了.</font></div><div><font size="2"   >digoal=# update pg_attribute set atttypmod=655366 where attrelid ='t1'::regclass and attname='id';</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   >digoal=# select * from t1;</font></div><div><font size="2"   >-[ RECORD 1 ]</font></div><div><font size="2"   >id | 123.556</font></div></div><div><div><font size="2"   >digoal=# \d t1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Table "public.t1"</font></div><div><font size="2"   >&nbsp;Column | &nbsp; &nbsp; Type &nbsp; &nbsp; &nbsp;| Modifiers&nbsp;</font></div><div><font size="2"   >--------+---------------+-----------</font></div><div><font size="2"   >&nbsp;id &nbsp; &nbsp; | numeric(10,2) |&nbsp;</font></div><div><font size="2"   ><span style="line-height: 19px;"   >因为是通过修改catalog达到调整精度的目的, 所以原值不变, 从numeric的物理存储结构来看已经包含了typmod的存储, 见本文末尾, 所以原始值输出的时候numeric_in, 得到的值是123.556, 而不是123.56.</span></font></div><div><font size="2"   >digoal=# insert into t1 values (123.5555);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# select * from t1;</font></div><div><font size="2"   >-[ RECORD 1 ]</font></div><div><font size="2"   >id | 123.556</font></div><div><font size="2"   >-[ RECORD 2 ]</font></div><div><font size="2"   >id | 123.56</font></div></div><p></p></pre></div><div><br></div><div>但是对于扩长度是很有效的, 不会破坏逻辑规则(如上面缩小精度带来的输出原始值123.556的问题), 同时规避了rewrite table的问题.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select numerictypmodin(_cstring '{10,4}');</font></div><div><font size="2"   >-[ RECORD 1 ]---+-------</font></div><div><font size="2"   >numerictypmodin | 655368</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# update pg_attribute set atttypmod=655368 where attrelid ='t1'::regclass and attname='id';</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   >digoal=# \d t1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Table "public.t1"</font></div><div><font size="2"   >&nbsp;Column | &nbsp; &nbsp; Type &nbsp; &nbsp; &nbsp;| Modifiers&nbsp;</font></div><div><font size="2"   >--------+---------------+-----------</font></div><div><font size="2"   >&nbsp;id &nbsp; &nbsp; | numeric(10,4) |&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select * from t1;</font></div><div><font size="2"   >-[ RECORD 1 ]</font></div><div><font size="2"   >id | 123.556</font></div><div><font size="2"   >-[ RECORD 2 ]</font></div><div><font size="2"   >id | 123.56</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# insert into t1 values (123.55555);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# select * from t1;</font></div><div><font size="2"   >-[ RECORD 1 ]</font></div><div><font size="2"   >id | 123.556</font></div><div><font size="2"   >-[ RECORD 2 ]</font></div><div><font size="2"   >id | 123.56</font></div><div><font size="2"   >-[ RECORD 3 ]</font></div><div><font size="2"   >id | 123.5556</font></div><p></p></pre></div><div><br></div><div>[小结]</div><div>1. 在精度调整方面, PostgreSQL目前还是需要改进的, 因为扩展精度不会造成数据变更. 所以可以不rewrite table.&nbsp;</div><div>当然如果对PG熟悉的话, 可以通过调整catalog定义来绕过rewrite table, 对普通用户不太实用.&nbsp;</div><div>2. oracle不允许表有数据的情况下降低精度, 原因是降低精度会带来数据的变更,&nbsp;</div><div><span style="line-height: 22px;"   >例如 :&nbsp;</span></div><div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >digoal=# select numeric_in('100.1550',1700,655366);</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;numeric_in&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >------------</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;100.16</font></div><div style="line-height: 22px;"   ><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div style="line-height: 22px;"   >显然数据已经不一样了.</div><div style="line-height: 22px;"   >但是PostgreSQL允许你降低精度,并且没有提示, 这个确实有待改进,</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table t1 (id numeric(10,5));</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# insert &nbsp;into t1 values (123.5555);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# select * from t1;</font></div><div><font size="2"   >&nbsp; &nbsp; id &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------</font></div><div><font size="2"   >&nbsp;123.55550</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=# alter table t1 alter column id type numeric(10,3);</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=# select * from t1;</font></div><div><font size="2"   >&nbsp; &nbsp;id &nbsp; &nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;123.556</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>修改精度后, 数据实际上变更了.</div><div style="line-height: 22px;"   >3. 另一方面, oracle扩展精度时, 底层存储的数据并未修改, 在输出时输出也未包含末尾的0, 也就是说oracle没有严格按照字段定义的有效位数来输出.&nbsp;<span style="line-height: 22px;"   >这也要批评一下oracle了.&nbsp;</span></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201371763839672/"   >http://blog.163.com/digoal@126/blog/static/163877040201371763839672/</a></div><div>2.&nbsp;src/backend/utils/adt/numeric.c</div><div>物理存储.<br><div><pre class="prettyprint"   ><p></p><div><font size="2"   >struct NumericShort</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n_header; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Sign + display scale + weight */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; NumericDigit n_data[1]; &nbsp; &nbsp; &nbsp; &nbsp; /* Digits */</font></div><div><font size="2"   >};</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >struct NumericLong</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n_sign_dscale; &nbsp;/* Sign + display scale */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n_weight; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Weight of 1st digit &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; NumericDigit n_data[1]; &nbsp; &nbsp; &nbsp; &nbsp; /* Digits */</font></div><div><font size="2"   >};</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >union NumericChoice</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n_header; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Header word */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct NumericLong n_long; &nbsp; &nbsp; &nbsp;/* Long form (4-byte header) */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct NumericShort n_short; &nbsp; &nbsp;/* Short form (2-byte header) */</font></div><div><font size="2"   >};</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >struct NumericData</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vl_len_; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* varlena header (do not touch directly!) */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; union NumericChoice choice; /* choice of format */</font></div><div><font size="2"   >};</font></div><p></p></pre></div><wbr></div></div>
	</div>
</div>
</body>
</html>