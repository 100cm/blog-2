<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL pending patch: Auto-tuning checkpoint_segments</h2>
	<h5 id="">2013-08-27 11:43:41&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020137277357661/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>这个补丁源自VMware的vPostgreSQL对checkpoint的改造. 根据数据库checkpoint之间产生pg_xlog的速率来自动预估和调整下一次checkpoint什么时候开始(历经多少个pg_xlog).</div><div>这样做的好处是在数据库负载较低的情况下(或者说产生pg_xlog较少), 自动适当减少checkpoint之间的pg_xlog数. 提高checkpoint频率, 亦可减少数据库在异常DOWN机需要recovery时所需的pg_xlog数. 当数据库负载很高<span style="line-height: 22px;"   >(或者说产生pg_xlog较多)时, 自动增加</span><span style="line-height: 22px;"   >checkpoint之间的pg_xlog数, 以减少checkpoint对DML带来的影响, 获得更好的DML性能.</span></div><div>注意, 这个补丁并不能消除checkpoint带来的性能影响.&nbsp;</div><div>打补丁 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 postgresql-1b1d3d9]# wget http://www.postgresql.org/message-id/attachment/29918/redesign-checkpoint-segments-1.patch</font></div><div><font size="2"   >[root@db-172-16-3-33 postgresql-1b1d3d9]# patch -p1 &lt; redesign-checkpoint-segments-1.patch&nbsp;</font></div><div><div><font size="2"   >patching file doc/src/sgml/config.sgml</font></div><div><font size="2"   >patching file doc/src/sgml/perform.sgml</font></div><div><font size="2"   >patching file doc/src/sgml/wal.sgml</font></div><div><font size="2"   >patching file src/backend/access/transam/xlog.c</font></div><div><font size="2"   >patching file src/backend/postmaster/checkpointer.c</font></div><div><font size="2"   >patching file src/backend/utils/misc/guc.c</font></div><div><font size="2"   >patching file src/include/access/xlog.h</font></div></div><div><span style="line-height: 22px;"   ><font size="2"   >[root@db-172-16-3-33 postgresql-1b1d3d9]# gmake</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   >[root@db-172-16-3-33 postgresql-1b1d3d9]# gmake install</font></span></div><p></p></pre></div><div><span style="line-height: 22px;"   >该补丁新增了两个配置项</span><span style="line-height: 22px;"   >checkpoint_wal_size</span><span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >,&nbsp;</span><span style="line-height: 22px;"   >min_recycle_wal_size</span><span style="line-height: 22px;"   >&nbsp;;&nbsp;</span><span style="line-height: 22px;"   >删除了1个配置项</span><span style="line-height: 22px;"   >checkpoint_segments</span><span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >root@db-172-16-3-33-&gt; su - pg94</font></div><div><font size="2"   >pg94@db-172-16-3-33-&gt; cd $PGDATA</font></div><div><font size="2"   >pg94@db-172-16-3-33-&gt; vi postgresql.conf&nbsp;</font></div><div><div><font size="2"   >checkpoint_wal_size = 2048MB</font></div><div><font size="2"   >min_recycle_wal_size = 256MB</font></div><div><font size="2"   >#checkpoint_segments = 32 # 这个参数已从guc中去除, 注释掉即可.</font></div></div><p></p></pre></div><div>重启数据库生效 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 22px;"   >pg94@db-172-16-3-33-&gt;&nbsp;</span>pg_ctl start</font></div><div><div><font size="2"   >pg94@db-172-16-3-33-&gt; psql</font></div><div><font size="2"   >psql (9.4devel)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >digoal=# show checkpoint_wal_size;</font></div><div><font size="2"   >&nbsp;checkpoint_wal_size&nbsp;</font></div><div><font size="2"   >---------------------</font></div><div><font size="2"   >&nbsp;2GB</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=# show min_recycle_wal_size;</font></div><div><font size="2"   >&nbsp;min_recycle_wal_size&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;256MB</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div>新增测试表和函数.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table test (id int primary key, info text, crt_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >create or replace function f_id_add(i_id int) returns void as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; update test set crt_time=clock_timestamp() where id=i_id;</font></div><div><font size="2"   >&nbsp; if not found then</font></div><div><font size="2"   >&nbsp; &nbsp; insert into test values (i_id,md5(random()::text),clock_timestamp());</font></div><div><font size="2"   >&nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; return;</font></div><div><font size="2"   >exception when others then</font></div><div><font size="2"   >&nbsp; return;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql strict;</font></div><p></p></pre></div><div>使用pgbench测试 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >root@db-172-16-3-33-&gt; vi test.sql</font></div><div><font size="2"   >\setrandom id 1 5000000</font></div><div><font size="2"   >select * from f_id_add(:id);</font></div><p></p></pre></div><div>参数 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgresql.conf</font></div><div><div><font size="2"   >checkpoint_wal_size = 2048MB</font></div><div><font size="2"   >min_recycle_wal_size = 256MB</font></div><div><font size="2"   >#checkpoint_segments = 32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # in logfile segments, min 1, 16MB each</font></div><div><font size="2"   >#checkpoint_timeout = 5min &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# range 30s-1h</font></div><div><font size="2"   >#checkpoint_completion_target = 0.5 &nbsp; &nbsp; # checkpoint target duration, 0.0 - 1.0</font></div><div><font size="2"   >#checkpoint_warning = 30s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 0 disables</font></div></div><p></p></pre></div><div><br></div><div>测试结果 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >root@db-172-16-3-33-&gt; pgbench -M prepared -f ./test.sql -n -r -P 1 -c 6 -j 6 -T 600</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >checkpoint发生时, 如果datafile的底层存储io能力较差的话, 波动难免, &nbsp;:&nbsp;</font></div><div><font size="2"   >progress: 293.0 s, 38436.2 tps, 0.156 ms lat</font></div><div><font size="2"   >progress: 294.0 s, 39080.4 tps, 0.154 ms lat</font></div><div><font size="2"   >progress: 295.3 s, 19002.0 tps, 0.316 ms lat</font></div><div><font size="2"   >progress: 296.0 s, 8902.0 tps, 0.674 ms lat</font></div><div><font size="2"   >progress: 297.0 s, 7351.9 tps, 0.816 ms lat</font></div><div><font size="2"   >progress: 298.0 s, 9077.9 tps, 0.661 ms lat</font></div><div><font size="2"   >progress: 299.1 s, 10286.2 tps, 0.583 ms lat</font></div><div><font size="2"   >progress: 300.0 s, 8173.6 tps, 0.734 ms lat</font></div><div><font size="2"   >progress: 301.0 s, 16850.9 tps, 0.356 ms lat</font></div><div><font size="2"   >progress: 302.0 s, 22523.4 tps, 0.266 ms lat</font></div><div><font size="2"   >progress: 303.0 s, 30896.1 tps, 0.194 ms lat</font></div><div><font size="2"   >progress: 304.0 s, 29802.8 tps, 0.201 ms lat</font></div><div><font size="2"   >progress: 305.0 s, 38459.6 tps, 0.156 ms lat</font></div><div><font size="2"   >progress: 306.1 s, 33927.1 tps, 0.177 ms lat</font></div><div><font size="2"   >progress: 307.0 s, 43309.6 tps, 0.139 ms lat</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >2013-08-27 10:49:22.227 CST,,,22727,,521c1286.58c7,1,,2013-08-27 10:44:22 CST,,0,LOG,00000,"checkpoint starting: time",,,,,,,,"LogCheckpointStart, xlog.c:7903",""</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >progress: 444.0 s, 38184.4 tps, 0.157 ms lat</font></div><div><font size="2"   >progress: 447.1 s, 7540.3 tps, 0.796 ms lat</font></div><div><font size="2"   >progress: 447.1 s, 12500.0 tps, 0.480 ms lat</font></div><div><font size="2"   >progress: 447.1 s, 22900.8 tps, 0.262 ms lat</font></div><div><font size="2"   >progress: 450.0 s, 2810.3 tps, 2.135 ms lat</font></div><div><font size="2"   >progress: 450.0 s, 17505.5 tps, 0.343 ms lat</font></div><div><font size="2"   >progress: 450.0 s, 23676.0 tps, 0.253 ms lat</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >2013-08-27 10:51:57.849 CST,,,22727,,521c1286.58c7,2,,2013-08-27 10:44:22 CST,,0,LOG,00000,"checkpoint complete: wrote 69119 buffers (52.7%); 0 transaction log file(s) added, 0 removed, 128 recycled; write=149.741 s, sync=5.796 s, total=155.621 s; sync files=7, longest=4.219 s, average=0.828 s; distance=3126259 KB, estimate=3126259 KB",,,,,,,,"LogCheckpointEnd, xlog.c:8004",""</font></div><div><font size="2"   >注意输出<span style="line-height: 22px;"   >distance=3126259 KB, estimate=3126259 KB. 这个就是用来评估下一个checkpoint什么时候发生的.</span></font></div><p></p></pre></div><div><br></div></div><div>下面换一台io能力稍好的服务器, 测试600秒后的补丁前后结果对比如下 :&nbsp;</div><div><div><img title="PostgreSQL pending patch: Auto-tuning checkpoint_segments - 德哥@Digoal - PostgreSQL"   alt="PostgreSQL pending patch: Auto-tuning checkpoint_segments - 德哥@Digoal - PostgreSQL"   style="margin:0 10px 0 0;"   src="http://img1.ph.126.net/sUafODO3He96eHyNQQC-7w==/3270457754501349634.png"   ></div>补丁前的checkpoint日志, 发生了3次checkpoint.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2013-08-27 11:06:10.325 CST,,,4705,,521c1676.1261,1,,2013-08-27 11:01:10 CST,,0,LOG,00000,"checkpoint starting: time",,,,,,,,"LogCheckpointStart, xlog.c:7798",""</font></div><div><font size="2"   >2013-08-27 11:07:36.522 CST,,,4705,,521c1676.1261,2,,2013-08-27 11:01:10 CST,,0,LOG,00000,"checkpoint complete: wrote 50740 buffers (38.7%); 0 transaction log file(s) added, 0 removed, 128 recycled; write=84.490 s, sync=1.609 s, total=86.197 s; sync files=35, longest=0.922 s, average=0.036 s",,,,,,,,"LogCheckpointEnd, xlog.c:7893",""</font></div><div><font size="2"   >2013-08-27 11:09:43.106 CST,,,4705,,521c1676.1261,3,,2013-08-27 11:01:10 CST,,0,LOG,00000,"checkpoint starting: xlog",,,,,,,,"LogCheckpointStart, xlog.c:7798",""</font></div><div><font size="2"   >2013-08-27 11:10:56.760 CST,,,4705,,521c1676.1261,4,,2013-08-27 11:01:10 CST,,0,LOG,00000,"checkpoint complete: wrote 65608 buffers (50.1%); 0 transaction log file(s) added, 0 removed, 101 recycled; write=73.145 s, sync=0.363 s, total=73.653 s; sync files=7, longest=0.203 s, average=0.051 s",,,,,,,,"LogCheckpointEnd, xlog.c:7893",""</font></div><div><font size="2"   >2013-08-27 11:14:43.760 CST,,,4705,,521c1676.1261,5,,2013-08-27 11:01:10 CST,,0,LOG,00000,"checkpoint starting: time",,,,,,,,"LogCheckpointStart, xlog.c:7798",""</font></div><div><font size="2"   >2013-08-27 11:17:14.193 CST,,,4705,,521c1676.1261,6,,2013-08-27 11:01:10 CST,,0,LOG,00000,"checkpoint complete: wrote 68764 buffers (52.5%); 0 transaction log file(s) added, 0 removed, 120 recycled; write=149.304 s, sync=1.106 s, total=150.432 s; sync files=7, longest=0.832 s, average=0.158 s",,,,,,,,"LogCheckpointEnd, xlog.c:7893",""</font></div><p></p></pre></div><div>补丁后的checkpoint日志, 发生了11次checkpoint.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2013-08-27 11:20:06.437 CST,,,6132,,521c1aa9.17f4,1,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint starting: xlog",,,,,,,,"LogCheckpointStart, xlog.c:7903",""</font></div><div><font size="2"   >2013-08-27 11:20:12.818 CST,,,6132,,521c1aa9.17f4,2,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint complete: wrote 66872 buffers (51.0%); 0 transaction log file(s) added, 82 removed, 0 recycled; write=2.964 s, sync=2.681 s, total=6.381 s; sync files=5, longest=2.092 s, average=0.536 s; distance=833934 KB, estimate=833934 KB",,,,,,,,"LogCheckpointEnd, xlog.c:8004",""</font></div><div><font size="2"   >2013-08-27 11:20:49.690 CST,,,6132,,521c1aa9.17f4,3,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint starting: xlog",,,,,,,,"LogCheckpointStart, xlog.c:7903",""</font></div><div><font size="2"   >2013-08-27 11:20:56.190 CST,,,6132,,521c1aa9.17f4,4,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint complete: wrote 70099 buffers (53.5%); 0 transaction log file(s) added, 33 removed, 13 recycled; write=4.944 s, sync=1.354 s, total=6.500 s; sync files=7, longest=0.985 s, average=0.193 s; distance=835582 KB, estimate=835582 KB",,,,,,,,"LogCheckpointEnd, xlog.c:8004",""</font></div><div><font size="2"   >2013-08-27 11:21:36.730 CST,,,6132,,521c1aa9.17f4,5,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint starting: xlog",,,,,,,,"LogCheckpointStart, xlog.c:7903",""</font></div><div><font size="2"   >2013-08-27 11:21:44.500 CST,,,6132,,521c1aa9.17f4,6,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint complete: wrote 68691 buffers (52.4%); 0 transaction log file(s) added, 2 removed, 50 recycled; write=5.125 s, sync=2.470 s, total=7.770 s; sync files=7, longest=1.957 s, average=0.352 s; distance=835583 KB, estimate=835583 KB",,,,,,,,"LogCheckpointEnd, xlog.c:8004",""</font></div><div><font size="2"   >2013-08-27 11:22:25.581 CST,,,6132,,521c1aa9.17f4,7,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint starting: xlog",,,,,,,,"LogCheckpointStart, xlog.c:7903",""</font></div><div><font size="2"   >2013-08-27 11:22:33.452 CST,,,6132,,521c1aa9.17f4,8,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint complete: wrote 67728 buffers (51.7%); 0 transaction log file(s) added, 1 removed, 50 recycled; write=5.074 s, sync=2.781 s, total=7.871 s; sync files=7, longest=1.996 s, average=0.397 s; distance=835583 KB, estimate=835583 KB",,,,,,,,"LogCheckpointEnd, xlog.c:8004",""</font></div><div><font size="2"   >2013-08-27 11:23:15.781 CST,,,6132,,521c1aa9.17f4,9,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint starting: xlog",,,,,,,,"LogCheckpointStart, xlog.c:7903",""</font></div><div><font size="2"   >2013-08-27 11:23:24.129 CST,,,6132,,521c1aa9.17f4,10,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint complete: wrote 66744 buffers (50.9%); 0 transaction log file(s) added, 1 removed, 50 recycled; write=5.240 s, sync=3.066 s, total=8.348 s; sync files=7, longest=2.218 s, average=0.438 s; distance=835584 KB, estimate=835584 KB",,,,,,,,"LogCheckpointEnd, xlog.c:8004",""</font></div><div><font size="2"   >2013-08-27 11:24:07.960 CST,,,6132,,521c1aa9.17f4,11,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint starting: xlog",,,,,,,,"LogCheckpointStart, xlog.c:7903",""</font></div><div><font size="2"   >2013-08-27 11:24:14.338 CST,,,6132,,521c1aa9.17f4,12,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint complete: wrote 64735 buffers (49.4%); 0 transaction log file(s) added, 5 removed, 48 recycled; write=2.964 s, sync=3.318 s, total=6.378 s; sync files=3, longest=2.109 s, average=1.106 s; distance=835583 KB, estimate=835584 KB",,,,,,,,"LogCheckpointEnd, xlog.c:8004",""</font></div><div><font size="2"   >2013-08-27 11:24:52.754 CST,,,6132,,521c1aa9.17f4,13,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint starting: xlog",,,,,,,,"LogCheckpointStart, xlog.c:7903",""</font></div><div><font size="2"   >2013-08-27 11:25:00.157 CST,,,6132,,521c1aa9.17f4,14,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint complete: wrote 69847 buffers (53.3%); 0 transaction log file(s) added, 0 removed, 49 recycled; write=5.169 s, sync=2.194 s, total=7.402 s; sync files=7, longest=1.759 s, average=0.313 s; distance=835584 KB, estimate=835584 KB",,,,,,,,"LogCheckpointEnd, xlog.c:8004",""</font></div><div><font size="2"   >2013-08-27 11:25:44.914 CST,,,6132,,521c1aa9.17f4,15,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint starting: xlog",,,,,,,,"LogCheckpointStart, xlog.c:7903",""</font></div><div><font size="2"   >2013-08-27 11:25:53.026 CST,,,6132,,521c1aa9.17f4,16,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint complete: wrote 65797 buffers (50.2%); 0 transaction log file(s) added, 0 removed, 50 recycled; write=5.191 s, sync=2.899 s, total=8.112 s; sync files=7, longest=2.213 s, average=0.414 s; distance=835583 KB, estimate=835584 KB",,,,,,,,"LogCheckpointEnd, xlog.c:8004",""</font></div><div><font size="2"   >2013-08-27 11:26:39.403 CST,,,6132,,521c1aa9.17f4,17,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint starting: xlog",,,,,,,,"LogCheckpointStart, xlog.c:7903",""</font></div><div><font size="2"   >2013-08-27 11:26:48.015 CST,,,6132,,521c1aa9.17f4,18,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint complete: wrote 63964 buffers (48.8%); 0 transaction log file(s) added, 0 removed, 51 recycled; write=5.300 s, sync=3.277 s, total=8.611 s; sync files=7, longest=2.581 s, average=0.468 s; distance=835584 KB, estimate=835584 KB",,,,,,,,"LogCheckpointEnd, xlog.c:8004",""</font></div><div><font size="2"   >2013-08-27 11:27:34.453 CST,,,6132,,521c1aa9.17f4,19,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint starting: xlog",,,,,,,,"LogCheckpointStart, xlog.c:7903",""</font></div><div><font size="2"   >2013-08-27 11:27:42.637 CST,,,6132,,521c1aa9.17f4,20,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint complete: wrote 62490 buffers (47.7%); 0 transaction log file(s) added, 0 removed, 51 recycled; write=5.133 s, sync=3.022 s, total=8.183 s; sync files=7, longest=2.306 s, average=0.431 s; distance=835583 KB, estimate=835584 KB",,,,,,,,"LogCheckpointEnd, xlog.c:8004",""</font></div><div><font size="2"   >2013-08-27 11:28:29.155 CST,,,6132,,521c1aa9.17f4,21,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint starting: xlog",,,,,,,,"LogCheckpointStart, xlog.c:7903",""</font></div><div><font size="2"   >2013-08-27 11:28:37.248 CST,,,6132,,521c1aa9.17f4,22,,2013-08-27 11:19:05 CST,,0,LOG,00000,"checkpoint complete: wrote 61235 buffers (46.7%); 0 transaction log file(s) added, 2 removed, 50 recycled; write=5.106 s, sync=2.964 s, total=8.093 s; sync files=7, longest=2.695 s, average=0.423 s; distance=835584 KB, estimate=835584 KB",,,,,,,,"LogCheckpointEnd, xlog.c:8004",""</font></div><p></p></pre></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >[参考]</span></div><div>1.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://www.postgresql.org/message-id/flat/51B0EC83.60700@vmware.com#51B0EC83.60700@vmware.com"   >http://www.postgresql.org/message-id/flat/51B0EC83.60700@vmware.com#51B0EC83.60700@vmware.com</a></div><div>2.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://www.postgresql.org/message-id/flat/CAM3SWZQcyNxvPaskr-pxm8DeqH7_qevW7uqbhPCsg1FpSxKpoQ@mail.gmail.com#CAM3SWZQcyNxvPaskr-pxm8DeqH7_qevW7uqbhPCsg1FpSxKpoQ@mail.gmail.com"   >http://www.postgresql.org/message-id/flat/CAM3SWZQcyNxvPaskr-pxm8DeqH7_qevW7uqbhPCsg1FpSxKpoQ@mail.gmail.com#CAM3SWZQcyNxvPaskr-pxm8DeqH7_qevW7uqbhPCsg1FpSxKpoQ@mail.gmail.com</a></div><div>3.&nbsp;src/backend/utils/misc/guc.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {"min_recycle_wal_size", PGC_SIGHUP, WAL_CHECKPOINTS,</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gettext_noop("Sets the minimum size to shrink the WAL to."),</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL,</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUC_UNIT_KB</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;min_recycle_wal_size,</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 81920, 32768, INT_MAX,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL, NULL, NULL</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; },</font></div><div><font size="2"   >&nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {"checkpoint_wal_size", PGC_SIGHUP, WAL_CHECKPOINTS,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gettext_noop("Sets the maximum WAL size that triggers a checkpoint."),</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUC_UNIT_KB</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;checkpoint_wal_size,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 262144, 32768, INT_MAX,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL, assign_checkpoint_wal_size, NULL</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; },</font></div><p></p></pre></div><div>4. checkpoint segments 评估.</div><div>新增两个参数的介绍 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &lt;variablelist&gt;</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp;&lt;varlistentry id="guc-checkpoint-wal-size" xreflabel="checkpoint_wal_size"&gt;</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &lt;term&gt;&lt;varname&gt;checkpoint_wal_size&lt;/varname&gt; (&lt;type&gt;integer&lt;/type&gt;)&lt;/term&gt;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &lt;indexterm&gt;</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp;&lt;primary&gt;&lt;varname&gt;checkpoint_wal_size&lt;/&gt; configuration parameter&lt;/primary&gt;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &lt;/indexterm&gt;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &lt;listitem&gt;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;para&gt;</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp; Maximum size to let the WAL grow to between automatic WAL</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp; checkpoints. This is a soft limit; WAL size can exceed</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp; &lt;varname&gt;checkpoint_wal_size&lt;/&gt; under special circumstances, like</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp; under heavy load, a failing &lt;varname&gt;archive_command&lt;/&gt;, or a high</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp; &lt;varname&gt;wal_keep_segments&lt;/&gt; setting. The default is 256 MB.</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp; Increasing this parameter can increase the amount of time needed for</font></div><div><font size="2"   >! &nbsp; &nbsp; &nbsp; &nbsp; crash recovery.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This parameter can only be set in the &lt;filename&gt;postgresql.conf&lt;/&gt;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file or on the server command line.</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp;&lt;varlistentry id="guc-min-recycle-wal-size" xreflabel="min_recycle_wal_size"&gt;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &lt;term&gt;&lt;varname&gt;min_recycle_wal_size&lt;/varname&gt; (&lt;type&gt;integer&lt;/type&gt;)&lt;/term&gt;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &lt;indexterm&gt;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;&lt;primary&gt;&lt;varname&gt;min_recycle_wal_size&lt;/&gt; configuration parameter&lt;/primary&gt;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &lt;/indexterm&gt;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &lt;listitem&gt;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;&lt;para&gt;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; As long as WAL disk usage stays below this setting, old WAL files are</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; always recycled for future use at a checkpoint, rather than removed.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; This can be used to ensure that enough WAL space is reserved to</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; handle spikes in WAL usage, for example when running large batch</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; jobs. The default is 80 MB.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; This parameter can only be set in the &lt;filename&gt;postgresql.conf&lt;/&gt;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; file or on the server command line.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;&lt;/para&gt;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &lt;/listitem&gt;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp;&lt;/varlistentry&gt;</font></div><div><font size="2"   >+&nbsp;</font></div></div><p></p></pre></div><div>老的checkpoint remove算法.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >! &nbsp; &nbsp;There will always be at least one WAL segment file, and will normally</font></div><div><font size="2"   >! &nbsp; &nbsp;not be more than (2 + &lt;varname&gt;checkpoint_completion_target&lt;/varname&gt;) * &lt;varname&gt;checkpoint_segments&lt;/varname&gt; + 1</font></div><div><font size="2"   >! &nbsp; &nbsp;or &lt;varname&gt;checkpoint_segments&lt;/&gt; + &lt;xref linkend="guc-wal-keep-segments"&gt; + 1</font></div><div><font size="2"   >! &nbsp; &nbsp;files. &nbsp;Each segment file is normally 16 MB (though this size can be</font></div><div><font size="2"   >! &nbsp; &nbsp;altered when building the server). &nbsp;You can use this to estimate space</font></div><div><font size="2"   >! &nbsp; &nbsp;requirements for &lt;acronym&gt;WAL&lt;/acronym&gt;.</font></div><div><font size="2"   >! &nbsp; &nbsp;Ordinarily, when old log segment files are no longer needed, they</font></div><div><font size="2"   >! &nbsp; &nbsp;are recycled (that is, renamed to become future segments in the numbered</font></div><div><font size="2"   >! &nbsp; &nbsp;sequence). If, due to a short-term peak of log output rate, there</font></div><div><font size="2"   >! &nbsp; &nbsp;are more than 3 * &lt;varname&gt;checkpoint_segments&lt;/varname&gt; + 1</font></div><div><font size="2"   >! &nbsp; &nbsp;segment files, the unneeded segment files will be deleted instead</font></div><div><font size="2"   >! &nbsp; &nbsp;of recycled until the system gets back under this limit.</font></div><div><font size="2"   >&nbsp; &nbsp; &lt;/para&gt;</font></div><p></p></pre></div><div>新的checkpoint recycle use或者remove算法.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >! &nbsp; &nbsp;The number of WAL segment files in &lt;filename&gt;pg_xlog&lt;/&gt; directory depends on</font></div><div><font size="2"   >! &nbsp; &nbsp;&lt;varname&gt;checkpoint_wal_size&lt;/&gt;, &lt;varname&gt;wal_recycle_min_size&lt;/&gt; and the</font></div><div><font size="2"   >! &nbsp; &nbsp;amount of WAL generated in previous checkpoint cycles. When old log</font></div><div><font size="2"   >! &nbsp; &nbsp;segment files are no longer needed, they are removed or recycled (that is,</font></div><div><font size="2"   >! &nbsp; &nbsp;renamed to become future segments in the numbered sequence). If, due to a</font></div><div><font size="2"   >! &nbsp; &nbsp;short-term peak of log output rate, &lt;varname&gt;checkpoint_wal_size&lt;/&gt; is</font></div><div><font size="2"   >! &nbsp; &nbsp;exceeded, the unneeded segment files will be removed until the system</font></div><div><font size="2"   >! &nbsp; &nbsp;gets back under this limit. Below that limit, the system recycles enough</font></div><div><font size="2"   >! &nbsp; &nbsp;WAL files to cover the estimated need until the next checkpoint, and</font></div><div><font size="2"   >! &nbsp; &nbsp;removes the rest. The estimate is based on a moving average of the number</font></div><div><font size="2"   >! &nbsp; &nbsp;of WAL files used in previous checkpoint cycles. The moving average</font></div><div><font size="2"   >! &nbsp; &nbsp;is increased immediately if the actual usage exceeds the estimate, so it</font></div><div><font size="2"   >! &nbsp; &nbsp;accommodates peak usage rather average usage to some extent.</font></div><div><font size="2"   >! &nbsp; &nbsp;&lt;varname&gt;wal_recycle_min_size&lt;/&gt; puts a minimum on the amount of WAL files</font></div><div><font size="2"   >! &nbsp; &nbsp;recycled for future usage; that much WAL is always recycled for future use,</font></div><div><font size="2"   >! &nbsp; &nbsp;even if the system is idle and the WAL usage estimate suggests that little</font></div><div><font size="2"   >! &nbsp; &nbsp;WAL is needed.</font></div><div><font size="2"   >! &nbsp; &lt;/para&gt;</font></div><div><font size="2"   >!&nbsp;</font></div><div><font size="2"   >! &nbsp; &lt;para&gt;</font></div><div><font size="2"   >! &nbsp; &nbsp;Independently of &lt;varname&gt;checkpoint_wal_size&lt;/varname&gt;,</font></div><div><font size="2"   >! &nbsp; &nbsp;&lt;xref linkend="guc-wal-keep-segments"&gt; + 1 most recent WAL files are</font></div><div><font size="2"   >! &nbsp; &nbsp;kept at all times. Also, if WAL archiving is used, old segments can not be</font></div><div><font size="2"   >! &nbsp; &nbsp;removed or recycled until they are archived. If WAL archiving cannot keep up</font></div><div><font size="2"   >! &nbsp; &nbsp;with the pace that WAL is generated, or if &lt;varname&gt;archive_command&lt;/varname&gt;</font></div><div><font size="2"   >! &nbsp; &nbsp;fails repeatedly, old WAL files will accumulate in &lt;filename&gt;pg_xlog&lt;/&gt;</font></div><div><font size="2"   >! &nbsp; &nbsp;until the situation is resolved.</font></div><p></p></pre></div><div>不管是补丁前还是补丁后, 在特殊情况下都可能超出<span style="line-height: 22px;"   >checkpoint_wal_size或者</span><span style="line-height: 22px;"   >checkpoint_segments限制的大小.</span></div><div><span style="line-height: 22px;"   >计算distance.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >+ &nbsp;* Calculate CheckPointSegments based on checkpoint_wal_size and</font></div><div><font size="2"   >+ &nbsp;* checkpoint_completion_target.</font></div><div><font size="2"   >+ &nbsp;*/</font></div><div><font size="2"   >+ static void</font></div><div><font size="2"   >+ CalculateCheckpointSegments(void)</font></div><div><font size="2"   >+ {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;target;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /*-------</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* Calculate the distance at which to trigger a checkpoint, to avoid</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* exceeding checkpoint_wal_size. This is based on two assumptions:</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* a) we keep WAL for two checkpoint cycles, back to the "prev" checkpoint.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* b) during checkpoint, we consume checkpoint_completion_target *</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp;number of segments consumed between checkpoints.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*-------</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; target = (double ) checkpoint_wal_size / (double) (XLOG_SEG_SIZE / 1024);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; target = target / (2.0 + CheckPointCompletionTarget);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* round down */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; CheckPointSegments = (int) target;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (CheckPointSegments &lt; 1)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CheckPointSegments = 1;</font></div><div><font size="2"   >+ }</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ void</font></div><div><font size="2"   >+ assign_checkpoint_wal_size(int newval, void *extra)</font></div><div><font size="2"   >+ {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; checkpoint_wal_size = newval;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; CalculateCheckpointSegments();</font></div><div><font size="2"   >+ }</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ void</font></div><div><font size="2"   >+ assign_checkpoint_completion_target(double newval, void *extra)</font></div><div><div><font size="2"   >+ {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; CheckPointCompletionTarget = newval;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; CalculateCheckpointSegments();</font></div><div><font size="2"   >+ }</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ /*</font></div><div><font size="2"   >+ &nbsp;* At a checkpoint, how many WAL segments to recycle as preallocated future</font></div><div><font size="2"   >+ &nbsp;* XLOG segments? Returns the highest segment that should be preallocated.</font></div><div><font size="2"   >+ &nbsp;*/</font></div><div><font size="2"   >+ static XLogSegNo</font></div><div><font size="2"   >+ XLOGfileslop(XLogRecPtr PriorRedoPtr)</font></div><div><font size="2"   >+ {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nsegments;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; XLogSegNo &nbsp; &nbsp; &nbsp; minSegNo;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; XLogSegNo &nbsp; &nbsp; &nbsp; maxSegNo;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;distance;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; XLogSegNo &nbsp; &nbsp; &nbsp; recycleSegNo;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* Calculate the segment numbers that min_recycle_wal_size and</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* checkpoint_wal_size correspond to. Always recycle enough segments</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* to meet the minimum, and remove enough segments to stay below the</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* maximum.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; nsegments = (double) min_recycle_wal_size / (double) (XLOG_SEG_SIZE / 1024);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; minSegNo = PriorRedoPtr / XLOG_SEG_SIZE + (int) nsegments;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; nsegments = (double) checkpoint_wal_size / (double) (XLOG_SEG_SIZE / 1024);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; maxSegNo = &nbsp;PriorRedoPtr / XLOG_SEG_SIZE + (int) nsegments;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* Between those limits, recycle enough segments to get us through to the</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* estimated end of next checkpoint.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* To estimate where the next checkpoint will finish, assume that the</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* system runs steadily consuming CheckPointDistanceEstimate</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* bytes between every checkpoint.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*</font></div></div><div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* The reason this calculation is done from the prior checkpoint, not the</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* one that just finished, is that this behaves better if some checkpoint</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* cycles are abnormally short, like if you perform a manual checkpoint</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* right after a timed one. The manual checkpoint will make almost a full</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* cycle's worth of WAL segments available for recycling, because the</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* segments from the prior's prior, fully-sized checkpoint cycle are no</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* longer needed. However, the next checkpoint will make only few segments</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* available for recycling, the ones generated between the timed</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* checkpoint and the manual one right after that. If at the manual</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* checkpoint we only retained enough segments to get us to the next timed</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* one, and removed the rest, then at the next checkpoint we would not</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* have enough segments around for recycling, to get us to the checkpoint</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* after that. Basing the calculations on the distance from the prior redo</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* pointer largely fixes that problem.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; distance = (2.0 + CheckPointCompletionTarget) * CheckPointDistanceEstimate;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* add 10% for good measure. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; distance *= 1.10;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; recycleSegNo = (XLogSegNo) ceil(((double) PriorRedoPtr + distance) / XLOG_SEG_SIZE);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (recycleSegNo &lt; minSegNo)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recycleSegNo = minSegNo;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (recycleSegNo &gt; maxSegNo)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recycleSegNo = maxSegNo;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; return recycleSegNo;</font></div><div><font size="2"   >+ }</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ /*</font></div></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>