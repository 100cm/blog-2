<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL VS MySQL's Storage EngineSss..</h2>
	<h5 id="">2011-01-11 8:20:39&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201101182039610/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><br>初次接触MySQL,简单的和PostgreSQL做一个对比,主要是存储引擎这块。(个人认为虽然MySQL支持存储引擎的热插拔，并且存储引擎五花八门，MySQL的说法是适应不同的应用场景，非常抱歉的是现在的应用都是比较综合型的，MySQL的大多数引擎已经不能适合现在的应用,而PostgreSQL应对现在的高并发业务非常适合，对比如下)<br>参考《High Performance MySQL》一书，书是2008年6月份出版的(因此可能以下的对比拿到现在会有些出入).<br>首先简单的介绍一下MySQL的架构,如图:<br><div><img title="PostgreSQL VS MySQLs Storage EngineSss.. - 德哥@Digoal - The Heart,The World." alt="PostgreSQL VS MySQLs Storage EngineSss.. - 德哥@Digoal - The Heart,The World." style="margin: 0pt 10px 0pt 0pt;" src="http://img161.ph.126.net/Vyn5SS9q4NK3aeL5cLDktA==/2152439146907931097.jpg"></div>&nbsp;<br>第一层主要负责处理连接请求，认证，安全。<br>第二层主要功能包括SQL解析，分析，优化器，查询缓存，以及所有的内建函数（如：date,times,math,encryption等），任何与跨存储引擎的功能都在这一层如存储过程，触发器，视图等。<br>第三层存储引擎层，负责数据存取，每个存储引擎有各自的特性，就好似UNIX操作系统的各种文件系统。Server 通过存储引擎API与存储引擎交互，API包括一些底层功能，如开始一个事务。存储引擎不干解析SQL的事情，引擎之间也不能相互通信（必须通过Server交换）。只负责相应Server端请求。这里有个例外，因为目前MySQL Server不处理FK关系，而InnoDB是支持FK的,因此在InnoDB中是存储引擎负责解析FK定义的。<br>存储引擎过多，一个是造成维护的麻烦，开发也会更加复杂，如事务型和非事务型表在同一个事务中的处理，还有引擎间表的互转移，权限和FK丢失等等一系列问题。<br>下面简单介绍一下MySQL的存储引擎,<br>查看存储引擎:<br>mysql&gt; SHOW TABLE STATUS LIKE 'user' \G<br>*************************** 1. row ***************************<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name: user<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Engine: MyISAM<br>&nbsp;&nbsp;&nbsp;&nbsp; Row_format: Dynamic<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rows: 6<br>&nbsp;Avg_row_length: 59<br>&nbsp;&nbsp;&nbsp; Data_length: 356<br>Max_data_length: 4294967295<br>&nbsp;&nbsp; Index_length: 2048<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data_free: 0<br>&nbsp;Auto_increment: NULL<br>&nbsp;&nbsp;&nbsp; Create_time: 2002-01-24 18:07:17<br>&nbsp;&nbsp;&nbsp; Update_time: 2002-01-24 21:56:29<br>&nbsp;&nbsp;&nbsp;&nbsp; Check_time: NULL<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Collation: utf8_bin<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Checksum: NULL<br>&nbsp;Create_options:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Comment: Users and global privileges<br>1 row in set (0.00 sec)<br><br>1. MyISAM : <br>在MySQL 5.5GA以前,MyISAM一直作为MySQL的默认引擎,拥有支持全文索引，压缩，空间函数等特性，缺点是不支持行锁和事务,因此并发能力极差(insert和select不冲突,其他的写都是排他锁)。<br>存储:<br>索引和数据分别存在.MYD和.MYI,文件具有平台无关性，如x86的文件放到PowerPC下使用。<br>MyISAM可以存储变长记录和固定长度记录，表的定义决定MySQL使用何种方式存放记录，MyISAM可以存放的最大记录数受到文件系统剩余空间<br>和单个文件大小上限的限制。在建表时可以使用MAX_ROWS 和AVG_ROW_LENGTH指定最大记录数和平均记录的SIZE。在MySQL5.0版本中，默认MyISAM表的限制是256TB，pointer占用6 bytes,早期版本默认pointers占用4bytes,因此表的现在是4GB.pointer最大可以占用8bytes<br>CREATE TABLE mytable (<br>&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp; INTEGER&nbsp; NOT NULL PRIMARY KEY,<br>&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp; CHAR(18) NOT NULL<br>) MAX_ROWS = 1000000000 AVG_ROW_LENGTH = 32;<br>mysql&gt; SHOW TABLE STATUS LIKE 'mytable' \G<br>*************************** 1. row ***************************<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name: mytable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Engine: MyISAM<br>&nbsp;&nbsp;&nbsp;&nbsp; Row_format: Fixed<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rows: 0<br>&nbsp;Avg_row_length: 0<br>&nbsp;&nbsp;&nbsp; Data_length: 0<br>Max_data_length: 98784247807<br>&nbsp;&nbsp; Index_length: 1024<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data_free: 0<br>&nbsp;Auto_increment: NULL<br>&nbsp;&nbsp;&nbsp; Create_time: 2002-02-24 17:36:57<br>&nbsp;&nbsp;&nbsp; Update_time: 2002-02-24 17:36:57<br>&nbsp;&nbsp;&nbsp;&nbsp; Check_time: NULL<br>&nbsp;Create_options: max_rows=1000000000 avg_row_length=32<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Comment:<br>1 row in set (0.05 sec)<br>特征:<br>reader获得shared lock.writer获得exclusive锁，因此并发性极差。（insert和select 锁不冲突,这要再冲突的话MyISAM估计活不到现在）<br>自动修复 或 手工修复数据表<br>check table , repair table或者使用myisamchk 在数据库关闭时修复。（数据容易被破坏,要不整这玩意干啥）<br>支持BLOB,TEXT前500字符的索引，（据说是为了防止索引过大,所以整了个前500字符的限制，搞个函数索引不就完了么，整这限制干啥）<br>delay_key_write : 即索引的更新在内存中暂缓，降低IO开销，听起来不错，可惜的是如果出现故障，索引要完全重建。<br>compressed MyISAM table :&nbsp; 使用myisampack可以将myisam表压缩，以行为单位压缩，支持索引，遗憾的是压缩表是只读的。<br><br>2. MyISAM Merge引擎<br>类似视图，把多个MyISAM表合并成一个表对外。<br><br>3. InnoDB引擎<br>InnoDB是一个支持事务的引擎。使用MVCC来满足高并发的场景需求。<br>一个比较致命的问题是InnoDB的表建立在Clustered Index之上.因此所有的索引都会包含PK的内容，PK必须使用精简列来减少索引的空间占用。<br>任何改变InnoDB表结构的操作都将导致表和所有索引的重建。<br>InnoDB支持预加载数据，内存哈希索引，插入缓存等特性来提高性能。<br><br>4. 内存存储引擎<br>之前也被称为heap表，内存表重启后数据将丢失，常用于lookup和mapping表的场景。支持HASH索引。<br>缺点是不支持事务，使用表级锁，只支持定长的字段类型等。<br>MySQL在临时表的处理方面，如果没有超出参数指定值的话都将使用内存表来处理，超过将自动转换为MyISAM来处理。<br><br>5. 归档引擎<br>只支持insert和 select,不支持索引，支持行级压缩，支持插入缓存。由于不支持索引，所以在查询方面性能不行，但是MySQL提供了复制，并且可以在SLAVE端使用不同的引擎。这就使得SLAVE端可以选用支持索引的引擎来加快扫描速度。<br><br>6. CSV引擎<br>类似外部表，支持CSV格式的文件，不支持索引。<br><br>7. Federated引擎<br>用于操控远程数据库记录，在统计，JOIN等其他方面使用不是太好。一般用于PK来取数据，或INSERT来插入记录。类似DBLINK，但是功能较弱<br><br>8. 黑洞引擎<br>类似/dev/null，往里面写东西 啥都不干。一般用作数据复制的MASTER，由于MASTER啥都不干，没有IO，提高写入效率。<br><br>9. NDB Cluster引擎<br>一个shared nothing的存储引擎，包含数据节点，管理节点，SQL实例节点。每个数据节点存放部分数据，并且数据节点之间相互有对方的数据，确保数据至少有两份在不同的节点上。管理节点监控和配置SQL集群。由于SQL实例和数据节点之间通信频繁，低的延时对NDB 集群非常重要。<br><br>10. Falcon引擎<br>支持MVCC的事务引擎<br><br>11. solidDB引擎<br>支持MVCC的事务引擎,使用集群索引，支持FK,支持在线备份，<br><br>12. PBXT引擎<br>一般用作高并发的写场景，支持MVCC，支持事务，支持FK。使用非集群索引。<br><br>13. Maria存储引擎<br>开发中<br><br>PostgreSQL包含了几乎所有MySQL这些存储引擎的优点，支持MVCC,支持事务，支持所有事务隔离级别，支持全文索引，支持自动压缩，支持行锁，支持FK,支持CSV快速导入导出，支持外部表（GreenPlum）,支持列存储(GreenPlum),支持资源控制(GreenPlum),支持shared nothing(Plproxy或PGXC,pg-grid,pgpool等都可以做),支持复制（支持master-master ,master-slave），支持写规则（比MYSQL黑洞引擎更加灵活），支持继承（比merge引擎更加灵活）,使用非集群索引，支持手工修正数据表存储顺序(类似瞬态cluster索引)，支持并行运算(GreenPlum)。等等<br>还有一些其他更加优异的优点:<br>如：<br>支持MMAP，将IO请求高的PAGE放入内存区域。更强大的是可以记录下状态，下次开启数据库直接将之加载至内存.<br>支持部分索引，索引变小，维护开销降低<br>支持在线备份，支持PITR<br>支持日志级复制，表级复制，流复制等等<br>支持非常强大的数据库DBLINK，甚至异构平台，如到oracle , mysql的 dblink</div>
	</div>
</div>
</body>
</html>