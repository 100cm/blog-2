<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.1's unlogged table use caveat</h2>
	<h5 id="">2011-06-14 13:08:41&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201151402832128/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">首先要强调一下，慎用 unlogged table。<div>unlogged table是PostgreSQL 9.1 引入的新特性。unlogged表有如下特征 :&nbsp;</div><div>1. unlogged表不记录WAL，同时在unlogged上面创建的索引也是unlogged的。</div><div>2. unlogged表在不干净的关闭数据库或者数据库crash之后，数据库启动时会自动truncate unlogged的表</div><div>从测试结果来看，unlogged表的数据在最后一次checkpoint到crash之间的数据还在占用磁盘空间.需要vacuum来回收.</div><div>原文引用 :&nbsp;</div><div><span style="font-family: verdana, sans-serif; font-size: 12px; line-height: 18px;"   >However, they are not crash-safe: an unlogged table is automatically truncated after a crash or unclean shutdown.</span></div><div><font face="verdana, sans-serif"   ><span style="font-size: 12px; line-height: 18px;"   >具体可查看源码 :&nbsp;</span></font></div><div><font face="verdana, sans-serif"   ><span style="font-size: 12px; line-height: 21px;"   >src/backend/storage/file/reinit.c</span></font></div><div><font face="verdana, sans-serif"   ><span style="font-size: 12px; line-height: 21px;"   ><div>/*</div><div>&nbsp;* Reset unlogged relations from before the last restart.</div><div>&nbsp;*</div><div>&nbsp;* If op includes UNLOGGED_RELATION_CLEANUP, we remove all forks of any</div><div>&nbsp;* relation with an "init" fork, except for the "init" fork itself.</div><div>&nbsp;*</div><div>&nbsp;* If op includes UNLOGGED_RELATION_INIT, we copy the "init" fork to the main</div><div>&nbsp;* fork.</div><div>&nbsp;*/</div></span></font></div><div><span style="font-family: verdana, sans-serif; font-size: 12px; line-height: 18px;"   ><br></span></div><div><span style="font-family: verdana, sans-serif; font-size: 12px; line-height: 18px;"   ><br></span></div><div>3. unlogged表的数据不会被复制到standby数据库.</div><div>4. 写此文时，gist index不支持unlogged表.<br><wbr><div><br></div><div>语法:</div><div><div>CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] table_name ( [</div><div>&nbsp; { column_name data_type [ COLLATE collation ] [ column_constraint [ ... ] ]</div><div>&nbsp; &nbsp; | table_constraint</div><div>&nbsp; &nbsp; | LIKE parent_table [ like_option ... ] }</div><div>&nbsp; &nbsp; [, ... ]</div><div>] )</div></div><div><br></div><div>下面分别来测试一下unlogged表的这些特性。</div></div><div>1.&nbsp;unlogged表不记录WAL，同时在unlogged上面创建的索引也是unlogged的。</div><div><div>digoal=&gt; create table tbl_user_log (id int,firstname text,lastname text,corp text);</div><div>CREATE TABLE</div><div>digoal=&gt; create unlogged table tbl_user_unlogged (id int,firstname text,lastname text,corp text);</div><div>CREATE TABLE</div></div><div><div>digoal=&gt; select pg_current_xlog_location();</div><div>&nbsp;pg_current_xlog_location&nbsp;</div><div>--------------------------</div><div>&nbsp;0/1544AD30</div><div>(1 row)</div><div>digoal=&gt; insert into tbl_user_log select generate_series(1,4000000),'zhou','digoal','sky-mobi';</div><div>INSERT 0 4000000</div><div>digoal=&gt; select pg_current_xlog_location();</div><div>&nbsp;pg_current_xlog_location&nbsp;</div><div>--------------------------</div><div>&nbsp;0/2A4C4268</div><div>(1 row)</div><div>digoal=&gt; insert into tbl_user_unlogged select generate_series(1,4000000),'zhou','digoal','sky-mobi';</div><div>INSERT 0 4000000</div><div>digoal=&gt; select pg_current_xlog_location();</div><div>&nbsp;pg_current_xlog_location&nbsp;</div><div>--------------------------</div><div>&nbsp;0/2A4C42E8</div><div>(1 row)</div></div><div><br></div><div>2. unlogged表在不干净的关闭数据库或者数据库crash之后，数据库启动时会自动truncate unlogged的表.</div><div><div>digoal=&gt; \c digoal postgres</div><div>You are now connected to database "digoal" as user "postgres".</div><div>digoal=# checkpoint;</div><div>select count(*) from tbl_user_log;</div><div>CHECKPOINT</div></div><div><div>digoal=# select count(*) from digoal.tbl_user_log;</div><div>&nbsp; count &nbsp;</div><div>---------</div><div>&nbsp;4000000</div><div>(1 row)</div><div><br></div><div>digoal=# select count(*) from digoal.tbl_user_unlogged;</div><div>&nbsp; count &nbsp;</div><div>---------</div><div>&nbsp;4000000</div><div>(1 row)</div></div><div><br></div><div># 不干净的关闭数据库</div><div><div>postgres@db5-&gt; pg_ctl stop -m immediate</div><div>waiting for server to shut down.... done</div><div>server stopped</div></div><div><div>postgres@db5-&gt; pg_ctl start</div><div>server starting</div><div>postgres@db5-&gt; psql -h 127.0.0.1 digoal digoal</div><div>psql (9.1beta2)</div><div>Type "help" for help.</div><div># 数据没有被truncate,原因是前面有一次checkpoint.</div><div>digoal=&gt; select count(*) from digoal.tbl_user_unlogged;</div><div>&nbsp; count &nbsp;</div><div>---------</div><div>&nbsp;4000000</div><div>(1 row)</div></div><div><div>digoal=&gt; select count(*) from digoal.tbl_user_log;</div><div>&nbsp; count &nbsp;</div><div>---------</div><div>&nbsp;4000000</div><div>(1 row)</div></div><div><br></div><div># 在来一次不做checkpoint之后的测试.</div><div><div>digoal=&gt; insert into tbl_user_log select generate_series(1,1000000),'zhou','digoal','sky-mobi';</div><div>INSERT 0 1000000</div><div>digoal=&gt; insert into tbl_user_unlogged select generate_series(1,1000000),'zhou','digoal','sky-mobi';</div><div>INSERT 0 1000000</div><div>digoal=&gt; select count(*) from tbl_user_unlogged ;</div><div>&nbsp; count &nbsp;</div><div>---------</div><div>&nbsp;5000000</div><div>(1 row)</div><div><br></div><div>digoal=&gt; select count(*) from tbl_user_log ;</div><div>&nbsp; count &nbsp;</div><div>---------</div><div>&nbsp;5000000</div><div>(1 row)</div><div><br></div><div>digoal=&gt; \q</div><div>postgres@db5-&gt; pg_ctl stop -m immediate</div><div>waiting for server to shut down.... done</div><div>server stopped</div><div>postgres@db5-&gt; pg_ctl start</div><div>server starting</div><div>postgres@db5-&gt; psql -h 127.0.0.1</div><div>psql: FATAL: &nbsp;the database system is starting up</div><div>postgres@db5-&gt; psql -h 127.0.0.1 digoal digoal</div><div>psql (9.1beta2)</div><div>Type "help" for help.</div><div># unlogged表这次插入的100W数据没有被恢复.</div><div>digoal=&gt; select count(*) from tbl_user_unlogged ;</div><div>&nbsp; count &nbsp;</div><div>---------</div><div>&nbsp;4000000</div><div>(1 row)</div><div><br></div><div>digoal=&gt; select count(*) from tbl_user_log ;</div><div>&nbsp; count &nbsp;</div><div>---------</div><div>&nbsp;5000000</div><div>(1 row)</div></div><div># 使用pageinspect查看unlogged表在crash 重启后的RAW数据 ， 发现数据全部归零了.</div><div>digoal=# select * from get_raw_page('digoal.tbl_user_unlogged',0);</div><div><br></div><div># vacuum一个unlogged表,</div><div><div>digoal=&gt; vacuum FREEZE VERBOSE &nbsp;tbl_user_unlogged ;</div><div>WARNING: &nbsp;relation "tbl_user_unlogged" page 0 is uninitialized --- fixing</div><div>WARNING: &nbsp;relation "tbl_user_unlogged" page 1 is uninitialized --- fixing</div><div>WARNING: &nbsp;relation "tbl_user_unlogged" page 2 is uninitialized --- fixing</div><div>WARNING: &nbsp;relation "tbl_user_unlogged" page 3 is uninitialized --- fixing</div><div>WARNING: &nbsp;relation "tbl_user_unlogged" page 4 is uninitialized --- fixing</div><div>WARNING: &nbsp;relation "tbl_user_unlogged" page 5 is uninitialized --- fixing</div></div><div>..........................</div><div><div>INFO: &nbsp;"tbl_user_unlogged": found 0 removable, 0 nonremovable row versions in 7353 out of 7353 pages</div><div>DETAIL: &nbsp;0 dead row versions cannot be removed yet.</div><div>There were 0 unused item pointers.</div><div>7353 pages are entirely empty.</div><div>CPU 0.00s/0.00u sec elapsed 10.50 sec.</div><div>INFO: &nbsp;"tbl_user_unlogged": truncated 7353 to 0 pages</div><div>DETAIL: &nbsp;CPU 0.05s/0.02u sec elapsed 0.08 sec.</div><div>INFO: &nbsp;vacuuming "pg_toast.pg_toast_16395"</div><div>INFO: &nbsp;index "pg_toast_16395_index" now contains 0 row versions in 1 pages</div><div>DETAIL: &nbsp;0 index row versions were removed.</div><div>0 index pages have been deleted, 0 are currently reusable.</div><div>CPU 0.00s/0.00u sec elapsed 0.00 sec.</div><div>INFO: &nbsp;"pg_toast_16395": found 0 removable, 0 nonremovable row versions in 0 out of 0 pages</div><div>DETAIL: &nbsp;0 dead row versions cannot be removed yet.</div><div>There were 0 unused item pointers.</div><div>0 pages are entirely empty.</div><div>CPU 0.00s/0.00u sec elapsed 0.00 sec.</div></div><div><br></div><div><div>digoal=# &nbsp; select pg_relation_size('digoal.tbl_user_unlogged');</div><div>&nbsp;pg_relation_size&nbsp;</div><div>------------------</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0</div><div>(1 row)</div></div><div><br></div><div>3. unlogged表的数据不会被复制到standby数据库.</div><div># 以下是在primary库上面的输出结果:</div><div><div>digoal=&gt; select pg_relation_size('tbl_user_log');</div><div>&nbsp;pg_relation_size&nbsp;</div><div>------------------</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 301178880</div><div>(1 row)</div><div><br></div><div>digoal=&gt; select pg_relation_size('tbl_user_unlogged');</div><div>&nbsp;pg_relation_size&nbsp;</div><div>------------------</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 361414656</div><div>(1 row)</div></div><div><div>digoal=&gt; vacuum full tbl_user_unlogged;</div><div>VACUUM</div><div>digoal=&gt; select pg_relation_size('tbl_user_unlogged');</div><div>&nbsp;pg_relation_size&nbsp;</div><div>------------------</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 240943104</div><div>(1 row)</div></div><div><br></div><div># 以下是在standby库上面的输出结果:</div><div><div>digoal=&gt; select pg_relation_size('tbl_user_log');</div><div>&nbsp;pg_relation_size&nbsp;</div><div>------------------</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 301178880</div><div>(1 row)</div><div><br></div><div>digoal=&gt; select pg_relation_size('tbl_user_unlogged');</div><div>&nbsp;pg_relation_size&nbsp;</div><div>------------------</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0</div><div>(1 row)</div></div><div><br></div><div>4. 写此文时，gist index不支持unlogged表.</div><div><div>digoal=&gt; create unlogged table tbl_point (id int,p point);</div><div>CREATE TABLE</div></div><div><div>digoal=&gt; create INDEX idx_p on tbl_point using gist(p);</div><div>ERROR: &nbsp;unlogged GiST indexes are not supported</div></div><div><br></div><div>综上测试，unlogged表还是需要谨慎使用的</div></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">francs - 2011-06-14 13:18:00</h5>
				<div><P>看来使用 unlogged 表风险很大啊！ 估计在大批量加载数据的时候可能用到。</P></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 francs - 2011-06-14 13:18:00</h5>
				<div style="width:600px;">是的，加载的末端最好加一句checkpoint.<br><br></div>
			</div>
	</div>
</div>
</body>
</html>