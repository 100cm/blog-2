<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL How to deal TUPLE LOCK : 2 - "one|more transactions waiting one|more transactions release tuple lock"</h2>
	<h5 id="">2013-02-01 22:17:38&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020131172754749/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>接上一篇 :&nbsp;</div><div>《PostgreSQL How to deal TUPLE LOCK : 1 - "One transaction lock single or multiple tuples | rows"》</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020130312271679/"   >http://blog.163.com/digoal@126/blog/static/16387704020130312271679/</a></div><div>本文基于以下版本进行讲解(已经修复了multixact的问题).</div><div><a target="_blank" rel="nofollow" href="http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=b78647a0e6f7b110273e98601f26d3d1db0ad931"   >http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=b78647a0e6f7b110273e98601f26d3d1db0ad931</a></div><div>在这个补丁前, 关于MultiXact情形下key share锁升级为share锁的问题, 我们看看会发生什么?</div><div>SESSION A :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table test (id int);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# insert into test values (1),(2);</font></div><div><font size="2"   >INSERT 0 2</font></div><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# select * from test for no key update;</font></div><div><font size="2"   >&nbsp;id&nbsp;</font></div><div><font size="2"   >----</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >&nbsp; 2</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >SESSION B :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# select * from test for key share;</font></div><div><font size="2"   >&nbsp;id&nbsp;</font></div><div><font size="2"   >----</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >&nbsp; 2</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   >-- 接下来BUG发生了, 居然能够上升到share锁, "no key update和share是冲突的, 不应该上升".</font></div><div><font size="2"   >-- 问题出在哪里呢? 因为此时tuple lock的信息不是存储在infomask里面的, 而是存储在pg_multixact里面, 所以问题一定是出在multixact的锁的处理上.</font></div><div><font size="2"   >digoal=# select * from test for share;</font></div><div><font size="2"   >&nbsp;id&nbsp;</font></div><div><font size="2"   >----</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >&nbsp; 2</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >补丁请参见 :&nbsp;</span></div><div><a target="_blank" rel="nofollow" href="http://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=b78647a0e6f7b110273e98601f26d3d1db0ad931;hp=77a3082fc546774808b76f58173caec3852ebf62"   >http://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=b78647a0e6f7b110273e98601f26d3d1db0ad931;hp=77a3082fc546774808b76f58173caec3852ebf62</a></div><div><span style="line-height: 22px;"   >打补丁后, 看看情况如何?</span></div><div><span style="line-height: 22px;"   >SESSION B 执行&nbsp;</span><span style="line-height: 19px; font-family: monospace; font-size: small; white-space: pre;"   >digoal=# select * from test for share;时等待锁. 没有发生锁升级的情况.</span></div><div>说明这个补丁已经修复了前面提到的BUG.</div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >进入主题 :&nbsp;</span></div><div><div style="line-height: 22px;"   >【二】、</div><div style="line-height: 22px;"   >上一篇BLOG讲的是单事务锁单行或多行的情形, 不存在并发.</div><div style="line-height: 22px;"   >这一篇要讲多个事务锁单行或多行的情形, 主要解释一下几个问题。</div><div style="line-height: 22px;"   >1. 多个事务锁锁单行, 这些锁信息依靠tuple head的t_infomask以及t_infomask2来存储是不够用的.</div><div style="line-height: 22px;"   >那么这些锁信息存储在哪里呢?</div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   >2. 当多个事务请求锁同一条tuple时, 是如何处理的?&nbsp;<span style="line-height: 22px;"   >锁请求顺序如何?</span></div></div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >【1】. 单条记录同时被多个事务共享锁, 这些锁信息依靠tuple head的t_infomask以及t_infomask2来存储是不够用的.</span></div><div><div style="line-height: 22px;"   >那么这些锁信息存储在哪里呢?</div><div style="line-height: 22px;"   >当多个事务共享锁单条记录时, 该记录的tuple head中的t_infomask&nbsp;HEAP_XMAX_IS_MULTI 比特位将会被设置.</div><div style="line-height: 22px;"   >同时HeapTupleFields.t_xmax 将改为MultiXactId, 而非TransactionId.</div><div style="line-height: 22px;"   >这些锁信息存储在以下数据结构 :&nbsp;</div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >每个MultiXactId中包含多个member(member数组).</span></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >00068 typedef struct xl_multixact_create</font></div><div style="line-height: 22px;"   ><font size="2"   >00069 {</font></div><div style="line-height: 22px;"   ><font size="2"   >00070 &nbsp; &nbsp; MultiXactId mid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* new MultiXact's ID */</font></div><div style="line-height: 22px;"   ><font size="2"   >00071 &nbsp; &nbsp; MultiXactOffset moff; &nbsp; &nbsp; &nbsp; /* its starting offset in members file */</font></div><div style="line-height: 22px;"   ><font size="2"   >00072 &nbsp; &nbsp; int32 &nbsp; &nbsp; &nbsp; nmembers; &nbsp; &nbsp; &nbsp; /* number of member XIDs */</font></div><div style="line-height: 22px;"   ><font size="2"   >00073 &nbsp; &nbsp; MultiXactMember members[FLEXIBLE_ARRAY_MEMBER];</font></div><div style="line-height: 22px;"   ><font size="2"   >00074 } xl_multixact_create;</font></div><p></p></pre></div><div style="line-height: 22px;"   >member的数据结构如下, 包含事务ID以及状态信息 :&nbsp;</div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >00052 typedef struct MultiXactMember</font></div><div style="line-height: 22px;"   ><font size="2"   >00053 {</font></div><div style="line-height: 22px;"   ><font size="2"   >00054 &nbsp; &nbsp; TransactionId &nbsp; xid;</font></div><div style="line-height: 22px;"   ><font size="2"   >00055 &nbsp; &nbsp; MultiXactStatus status;</font></div><div style="line-height: 22px;"   ><font size="2"   >00056 } MultiXactMember;</font></div><p></p></pre></div></div></div><div style="line-height: 22px;"   >状态信息是个枚举类型, 如下, 用来存储锁信息 :&nbsp;</div><div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >00032 /*</font></div><div style="line-height: 22px;"   ><font size="2"   >00033 &nbsp;* Possible multixact lock modes ("status"). &nbsp;The first four modes are for</font></div><div style="line-height: 22px;"   ><font size="2"   >00034 &nbsp;* tuple locks (FOR KEY SHARE, FOR SHARE, FOR NO KEY UPDATE, FOR UPDATE); the</font></div><div style="line-height: 22px;"   ><font size="2"   >00035 &nbsp;* next two are used for update and delete modes.</font></div><div style="line-height: 22px;"   ><font size="2"   >00036 &nbsp;*/</font></div><div style="line-height: 22px;"   ><font size="2"   >00037 typedef enum</font></div><div style="line-height: 22px;"   ><font size="2"   >00038 {</font></div><div style="line-height: 22px;"   ><font size="2"   >00039 &nbsp; &nbsp; MultiXactStatusForKeyShare = 0x00,</font></div><div style="line-height: 22px;"   ><font size="2"   >00040 &nbsp; &nbsp; MultiXactStatusForShare = 0x01,</font></div><div style="line-height: 22px;"   ><font size="2"   >00041 &nbsp; &nbsp; MultiXactStatusForNoKeyUpdate = 0x02,</font></div><div style="line-height: 22px;"   ><font size="2"   >00042 &nbsp; &nbsp; MultiXactStatusForUpdate = 0x03,</font></div><div style="line-height: 22px;"   ><font size="2"   >00043 &nbsp; &nbsp; /* an update that doesn't touch "key" columns */</font></div><div style="line-height: 22px;"   ><font size="2"   >00044 &nbsp; &nbsp; MultiXactStatusNoKeyUpdate = 0x04,</font></div><div style="line-height: 22px;"   ><font size="2"   >00045 &nbsp; &nbsp; /* other updates, and delete */</font></div><div style="line-height: 22px;"   ><font size="2"   >00046 &nbsp; &nbsp; MultiXactStatusUpdate = 0x05</font></div><div style="line-height: 22px;"   ><font size="2"   >00047 } MultiXactStatus;</font></div><p></p></pre></div><div style="line-height: 22px;"   >看起来好像有2个是重复的, 如下 :&nbsp;</div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   ><span style="line-height: 22px;"   >MultiXactStatusForNoKeyUpdate = 0x02 以及&nbsp;</span><span style="line-height: 22px;"   >MultiXactStatusNoKeyUpdate = 0x04 ;&nbsp;</span></font></div><div style="line-height: 22px;"   ><font size="2"   ><span style="line-height: 22px;"   >MultiXactStatusForUpdate = 0x03 以及&nbsp;</span><span style="line-height: 22px;"   >MultiXactStatusUpdate = 0x05 ;&nbsp;</span></font></div><p></p></pre></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >其实没有重复, 因为一种是显锁(select for ...), 一种是隐锁(update).</span></div><div style="line-height: 22px;"   >来看个例子区分一下 :&nbsp;</div><div style="line-height: 22px;"   >先使用A和B会话, 设置TUPLE的头信息中的t_infomask.<span style="line-height: 22px;"   >HEAP_XMAX_IS_MULTI</span><span style="line-height: 22px;"   >&nbsp;.</span></div><div style="line-height: 22px;"   >SESSION A :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# select * from test for key share;</font></div><div><font size="2"   >&nbsp;id&nbsp;</font></div><div><font size="2"   >----</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >&nbsp; 2</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div><br></div><div style="line-height: 22px;"   >SESSION B :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# select * from test for key share;</font></div><div><font size="2"   >&nbsp;id&nbsp;</font></div><div><font size="2"   >----</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >&nbsp; 2</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div><br></div><div style="line-height: 22px;"   >SESSION C :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# select * from test for no key update;</font></div><div><font size="2"   >&nbsp;id&nbsp;</font></div><div><font size="2"   >----</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >&nbsp; 2</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div><br></div><div>SESSION D :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from pgrowlocks('test');</font></div><div><font size="2"   >&nbsp;locked_row | locker | multi | &nbsp; &nbsp; &nbsp; xids &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp;pids &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------+--------+-------+------------------+-----------------------------------------------+---------------------</font></div><div><font size="2"   >&nbsp;(0,1) &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 25 | t &nbsp; &nbsp; | {1774,1775,1776} | {"Key Share","Key Share","For No Key Update"} | {10099,10102,12822}</font></div><div><font size="2"   >&nbsp;(0,2) &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 25 | t &nbsp; &nbsp; | {1774,1775,1776} | {"Key Share","Key Share","For No Key Update"} | {10099,10102,12822}</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>注意这里SESSION C获得的是显锁, For No Key Update.</div><div>再来看看隐锁 :&nbsp;</div><div><span style="line-height: 22px;"   >先使用A和B会话, 设置TUPLE的头信息中的t_infomask.</span><span style="line-height: 22px;"   >HEAP_XMAX_IS_MULTI</span><span style="line-height: 22px;"   >&nbsp;.</span></div><div>SESSION A :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# select * from test for key share;</font></div><div><font size="2"   >&nbsp;id | info&nbsp;</font></div><div><font size="2"   >----+------</font></div><div><font size="2"   >&nbsp; 1 |&nbsp;</font></div><div><font size="2"   >&nbsp; 2 |&nbsp;</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div><br></div><div>SESSION B :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from test for key share;</font></div><div><font size="2"   >&nbsp;id | info&nbsp;</font></div><div><font size="2"   >----+------</font></div><div><font size="2"   >&nbsp; 1 |&nbsp;</font></div><div><font size="2"   >&nbsp; 2 |&nbsp;</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div><br></div><div>SESSION C :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select pg_backend_pid();</font></div><div><font size="2"   >&nbsp;pg_backend_pid&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 12822</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >SESSION C GDB :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><font size="2"   >gdb</font></span></div><div><font size="2"   >(gdb) attach 12822</font></div><div><font size="2"   >(gdb) b MultiXactIdWait</font></div><div><font size="2"   >Breakpoint 1 at 0x48b1f0: file heapam.c, line 5403.</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >SESSION C :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# update test set info='test' where id=1;</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >SESSION C GDB :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Breakpoint 1, MultiXactIdWait (multi=26, status=MultiXactStatusNoKeyUpdate, remaining=0x7ffff88ddb94, infomask=4496)</font></div><div><font size="2"   >&nbsp; &nbsp; at heapam.c:5403</font></div><div><font size="2"   >5403 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Do_MultiXactIdWait(multi, status, remaining, infomask, false);</font></div><div><font size="2"   >(gdb) p status</font></div><div><font size="2"   >$1 = MultiXactStatusNoKeyUpdate</font></div><div><font size="2"   >(gdb) c</font></div><div><font size="2"   >Continuing.</font></div><p></p></pre></div><div>在gdb中打印<span style="line-height: 22px;"   >status, 显然等待的是</span><span style="line-height: 22px;"   >MultiXactStatusNoKeyUpdate锁, 而不是</span><span style="line-height: 22px;"   >MultiXactStatusForNoKeyUpdate</span><span style="line-height: 22px;"   >&nbsp;. 这就是显锁和隐锁的区别.</span></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >SESSION D :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from pgrowlocks('test');</font></div><div><font size="2"   >&nbsp;locked_row | locker | multi | &nbsp; &nbsp; &nbsp; xids &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp;pids &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------+--------+-------+------------------+-------------------------------------------+---------------------</font></div><div><font size="2"   >&nbsp;(0,1) &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 27 | t &nbsp; &nbsp; | {1781,1782,1783} | {"Key Share","Key Share","No Key Update"} | {10099,10102,12822}</font></div><div><font size="2"   >&nbsp;(0,2) &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 26 | t &nbsp; &nbsp; | {1781,1782} &nbsp; &nbsp; &nbsp;| {"Key Share","Key Share"} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | {10099,10102}</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >注意这里SESSION C获得的是隐锁, No Key Update. 与之前的例子用select ... for no key update的到的不一样.</span></div><div><br></div><div><span style="line-height: 22px;"   >【2】. 当多个事务请求锁同一条tuple时, 是如何处理的?&nbsp;</span><span style="line-height: 22px;"   >锁请求顺序如何?</span></div><div>为什么要关心多个事务对同一条TUPLE请求锁呢, 来看一个场景.</div><div>假设按顺序<span style="line-height: 22px;"   >在不同的会话中</span><span style="line-height: 22px;"   >执行以下SQL.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SESSION A :&nbsp;</font></div><div><font size="2"   >select * from test for share;</font></div><div><font size="2"   ><br></font></div><div><div style="line-height: 22px;"   ><font size="2"   >SESSION B :&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >select * from test for share;</font></div></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div><font size="2"   >SESSION C :&nbsp;</font></div><div><span style="line-height: 22px;"   ><font size="2"   >select * from test for update;</font></span></div><div><font size="2"   >-- 这里等待是毋庸置疑的.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SESSION D :&nbsp;</font></div><div><span style="line-height: 22px;"   ><font size="2"   >select * from test for share;</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   >-- 这里需要等待吗?</font></span></div><div><font size="2"   >-- 如果SESSION D不需要等待锁, 那么持续不断的涌现出类似SESSION D这样的SQL, SESSION C就杯具了, 一直需要等待下去.</font></div><div><font size="2"   >-- 当然这种事情不会发生. 因为C会先获得锁, D继续等待. 原因看后面的介绍.</font></div><div></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >下面使用gdb来跟踪一下以上场景, 看看SESSION D要不要等待. &nbsp;:&nbsp;</span></div><div><div style="line-height: 22px;"   >SESSION A :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# select pg_backend_pid();</font></div><div><font size="2"   >&nbsp;pg_backend_pid&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10099</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# select * from test for share;</font></div><div><font size="2"   >&nbsp;id | info&nbsp;</font></div><div><font size="2"   >----+------</font></div><div><font size="2"   >&nbsp; 2 |&nbsp;</font></div><div><font size="2"   >&nbsp; 1 | test</font></div><div><font size="2"   >(2 rows)</font></div></div><p></p></pre></div><div style="line-height: 22px;"   ><br style="line-height: 22px;"   ></div><div><div style="line-height: 22px;"   >SESSION B :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><div><font size="2"   >digoal=# select pg_backend_pid();</font></div><div><font size="2"   >&nbsp;pg_backend_pid&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10102</font></div><div><font size="2"   >(1 row)</font></div></div></div><div><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# select * from test for share;</font></div><div><font size="2"   >&nbsp;id | info&nbsp;</font></div><div><font size="2"   >----+------</font></div><div><font size="2"   >&nbsp; 2 |&nbsp;</font></div><div><font size="2"   >&nbsp; 1 | test</font></div><div><font size="2"   >(2 rows)</font></div></div><p></p></pre></div></div><div><br></div><div>SESSION C GDB :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-150 ~]# gdb</font></div><div><font size="2"   >(gdb) attach 12822</font></div><div><font size="2"   >Attaching to process 12822</font></div></div><div><font size="2"   >(gdb) b LockTuple</font></div><div><font size="2"   >Breakpoint 1 at 0x65d240: file lmgr.c, line 388.</font></div><div><div><font size="2"   >(gdb) c</font></div><div><font size="2"   >Continuing.</font></div></div><p></p></pre></div><div style="line-height: 22px;"   ><br style="line-height: 22px;"   ></div><div style="line-height: 22px;"   >SESSION C :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# select pg_backend_pid();</font></div><div><font size="2"   >&nbsp;pg_backend_pid&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 12822</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# select * from test for update;</font></div></div><p></p></pre></div><div><br></div><div><div style="line-height: 22px;"   >SESSION C GDB :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Breakpoint 1, LockTuple (relation=0x2b7faf660578, tid=0x7ffff88ddce4, lockmode=8) at lmgr.c:388</font></div><div><font size="2"   >388 &nbsp; &nbsp; {</font></div><div><font size="2"   >(gdb) n</font></div><div><font size="2"   >391 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_TUPLE(tag,</font></div><div><font size="2"   >(gdb) p tag</font></div><div><font size="2"   >$1 = {locktag_field1 = 8, locktag_field2 = 0, locktag_field3 = 2, locktag_field4 = 0, locktag_type = 0 '\000',&nbsp;</font></div><div><font size="2"   >&nbsp; locktag_lockmethodid = 0 '\000'}</font></div><div><font size="2"   >(gdb) n</font></div><div><font size="2"   >388 &nbsp; &nbsp; {</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >391 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_TUPLE(tag,</font></div><div><font size="2"   >(gdb) p tag</font></div><div><font size="2"   >$2 = {locktag_field1 = 8, locktag_field2 = 0, locktag_field3 = 2, locktag_field4 = 0, locktag_type = 0 '\000',&nbsp;</font></div><div><font size="2"   >&nbsp; locktag_lockmethodid = 0 '\000'}</font></div><div><font size="2"   >(gdb) n</font></div><div><font size="2"   >397 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (void) LockAcquire(&amp;tag, lockmode, false, false);</font></div><div><font size="2"   >(gdb) p lockmode</font></div><div><font size="2"   >$3 = 8</font></div><div><font size="2"   >(gdb) p tag</font></div><div><font size="2"   >$4 = {locktag_field1 = 16384, locktag_field2 = 16742, locktag_field3 = 0, locktag_field4 = 0, locktag_type = 0 '\000',&nbsp;</font></div><div><font size="2"   >&nbsp; locktag_lockmethodid = 0 '\000'}</font></div><div><font size="2"   >(gdb) n</font></div><div><font size="2"   >391 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_TUPLE(tag,</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >397 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (void) LockAcquire(&amp;tag, lockmode, false, false);</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >398 &nbsp; &nbsp; }</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >heap_lock_tuple (relation=0x2b7faf660578, tuple=0x7ffff88ddce0, cid=0, mode=LockTupleExclusive, nowait=0 '\000',&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; follow_updates=1 '\001', buffer=0x7ffff88ddd18, hufd=0x7ffff88ddd00) at heapam.c:4011</font></div><div><font size="2"   >4011 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (mode == LockTupleKeyShare)</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >4085 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (mode == LockTupleShare)</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >4106 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (mode == LockTupleNoKeyExclusive)</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >4192 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (infomask &amp; HEAP_XMAX_IS_MULTI)</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >4194 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MultiXactStatus status = get_mxact_status_for_lock(mode, false);</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >4197 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (status &gt;= MultiXactStatusNoKeyUpdate)</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >4201 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (nowait)</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >4211 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MultiXactIdWait((MultiXactId) xwait, status, NULL, infomask);</font></div><div><font size="2"   >(gdb) p xwait</font></div><div><font size="2"   >$5 = 28</font></div><p></p></pre></div></div><div>-- 因为SESSION A和SESSION B共享锁住了2行, 所以锁信息在pg_multixact中, 因此这里跟踪到的是<span style="line-height: 22px;"   >MultiXactIdWait.</span></div><div><span style="line-height: 22px;"   >-- 如果是单事务锁, 这里应该跟踪到</span>XactLockTableWait.</div><div>(gdb) n</div><div>... 等待锁.</div><div><br></div><div>SESSION X :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from pgrowlocks('test');</font></div><div><font size="2"   >&nbsp;locked_row | locker | multi | &nbsp; &nbsp;xids &nbsp; &nbsp; | &nbsp; &nbsp; modes &nbsp; &nbsp; | &nbsp; &nbsp; pids &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------+--------+-------+-------------+---------------+---------------</font></div><div><font size="2"   >&nbsp;(0,2) &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 28 | t &nbsp; &nbsp; | {1785,1786} | {Share,Share} | {10099,10102}</font></div><div><font size="2"   >&nbsp;(0,3) &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 28 | t &nbsp; &nbsp; | {1785,1786} | {Share,Share} | {10099,10102}</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select * from heap_page_items(get_raw_page('test', 0));</font></div><div><font size="2"   >&nbsp;lp | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 | t_ctid | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"   >----+--------+----------+--------+--------+--------+----------+--------+-------------+------------+--------+--------+-------</font></div><div><font size="2"   >&nbsp; 1 | &nbsp; 8160 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 28 | &nbsp; &nbsp; &nbsp;2 | &nbsp; &nbsp; 27 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (0,3) &nbsp;| &nbsp; &nbsp; &nbsp; 16385 | &nbsp; &nbsp; &nbsp; 4416 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; 2 | &nbsp; 8128 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 28 | &nbsp; &nbsp; &nbsp;2 | &nbsp; &nbsp; 28 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (0,2) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 4560 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; 3 | &nbsp; 8088 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 33 | &nbsp; 1783 | &nbsp; &nbsp; 28 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (0,3) &nbsp;| &nbsp; &nbsp; &nbsp; 32770 | &nbsp; &nbsp; &nbsp;12754 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >(3 rows)</font></div><p></p></pre></div><div>gdb跟踪到的xwait就是这里的t_max : 28.</div><div style="line-height: 22px;"   ><br style="line-height: 22px;"   ></div><div style="line-height: 22px;"   >SESSION D :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select pg_backend_pid();</font></div><div><font size="2"   >&nbsp;pg_backend_pid&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 14886</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div><br></div><div><span style="line-height: 22px;"   >SESSION D GDB :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >(gdb) attach 14886</font></div><div><font size="2"   >Attaching to program: /home/pgdev/pgsql9.3/bin/postgres, process 14886</font></div><div><div><font size="2"   >(gdb) b LockTuple</font></div><div><font size="2"   >Note: breakpoint 1 also set at pc 0x65d240.</font></div><div><font size="2"   >Breakpoint 2 at 0x65d240: file lmgr.c, line 388.</font></div></div><div><div><font size="2"   >(gdb) c</font></div><div><font size="2"   >Continuing.</font></div></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >SESSION D :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# select * from test for share;</font></div><p></p></pre></div><div><br></div><div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >SESSION D GDB :&nbsp;</span></div></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >Breakpoint 1, LockTuple (relation=0x2b7faf643e30, tid=0x7ffff88ddce4, lockmode=2) at lmgr.c:388</font></div><div><font size="2"   >388 &nbsp; &nbsp; {</font></div></div><div><div><font size="2"   >(gdb) n</font></div><div><font size="2"   >391 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_TUPLE(tag,</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >388 &nbsp; &nbsp; {</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >391 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_TUPLE(tag,</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >397 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (void) LockAcquire(&amp;tag, lockmode, false, false);</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >391 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_TUPLE(tag,</font></div><div><font size="2"   >(gdb)&nbsp;</font></div><div><font size="2"   >397 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (void) LockAcquire(&amp;tag, lockmode, false, false);</font></div><div><font size="2"   >(gdb)&nbsp;</font></div></div><p></p></pre></div><div>等待, 未跟踪到<span style="line-height: 22px;"   >MultiXactIdWait.&nbsp;</span></div><div><span style="line-height: 22px;"   >那这里其实是进入了</span>LockAcquireExtended函数的<span style="line-height: 22px;"   >这个逻辑</span></div><div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div><font size="2"   >00900 &nbsp; &nbsp; /*</font></div><div><font size="2"   >00901 &nbsp; &nbsp; &nbsp;* If lock requested conflicts with locks requested by waiters, must join</font></div><div><font size="2"   >00902 &nbsp; &nbsp; &nbsp;* wait queue. &nbsp;Otherwise, check for conflict with already-held locks.</font></div><div><font size="2"   >00903 &nbsp; &nbsp; &nbsp;* (That's last because most complex check.)</font></div><div><font size="2"   >00904 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >00905 &nbsp; &nbsp; if (lockMethodTable-&gt;conflictTab[lockmode] &amp; lock-&gt;waitMask)</font></div><div><font size="2"   >00906 &nbsp; &nbsp; &nbsp; &nbsp; status = STATUS_FOUND;</font></div><div><font size="2"   >00907 &nbsp; &nbsp; else</font></div><div><font size="2"   >00908 &nbsp; &nbsp; &nbsp; &nbsp; status = LockCheckConflicts(lockMethodTable, lockmode,</font></div><div><font size="2"   >00909 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock, proclock, MyProc);</font></div><p></p></pre></div><div style="line-height: 22px;"   >另一种方法是使用开发参数进行跟踪 :&nbsp;</div><div style="line-height: 22px;"   >SESSION C :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# \set VERBOSITY verbose</font></div><div><font size="2"   >digoal=# set trace_locks = on;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# set trace_userlocks = on;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# set client_min_messages=debug5;</font></div><div><font size="2"   >DEBUG: &nbsp;00000: CommitTransactionCommand</font></div><div><font size="2"   >LOCATION: &nbsp;finish_xact_command, postgres.c:2409</font></div><div><font size="2"   >DEBUG: &nbsp;00000: CommitTransaction</font></div><div><font size="2"   >LOCATION: &nbsp;ShowTransactionState, xact.c:4388</font></div><div><font size="2"   >DEBUG: &nbsp;00000: name: unnamed; blockState: &nbsp; &nbsp; &nbsp; STARTED; state: INPROGR, xid/subid/cid: 0/1/0, nestlvl: 1, children:&nbsp;</font></div><div><font size="2"   >LOCATION: &nbsp;ShowTransactionStateRec, xact.c:4426</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll: lockmethod=1</font></div><div><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:1941</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll done</font></div><div><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:2164</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll: lockmethod=2</font></div><div><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:1941</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll done</font></div><div><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:2164</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >DEBUG: &nbsp;00000: StartTransactionCommand</font></div><div><font size="2"   >LOCATION: &nbsp;start_xact_command, postgres.c:2385</font></div><div><font size="2"   >DEBUG: &nbsp;00000: StartTransaction</font></div><div><font size="2"   >LOCATION: &nbsp;ShowTransactionState, xact.c:4388</font></div><div><font size="2"   >DEBUG: &nbsp;00000: name: unnamed; blockState: &nbsp; &nbsp; &nbsp; DEFAULT; state: INPROGR, xid/subid/cid: 0/1/0, nestlvl: 1, children:&nbsp;</font></div><div><font size="2"   >LOCATION: &nbsp;ShowTransactionStateRec, xact.c:4426</font></div><div><font size="2"   >DEBUG: &nbsp;00000: ProcessUtility</font></div><div><font size="2"   >LOCATION: &nbsp;PortalRunUtility, pquery.c:1154</font></div><div><font size="2"   >DEBUG: &nbsp;00000: CommitTransactionCommand</font></div><div><font size="2"   >LOCATION: &nbsp;finish_xact_command, postgres.c:2409</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select * from test for update;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >DEBUG: &nbsp;00000: StartTransactionCommand</font></div><div><font size="2"   >LOCATION: &nbsp;start_xact_command, postgres.c:2385</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [16384,16742] RowShareLock</font></div><div><font size="2"   >LINE 1: select * from test for update;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:729</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [16384,16742] AccessShareLock</font></div><div><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:729</font></div><div><font size="2"   >LOG: &nbsp;00000: LockRelease: lock [16384,16742] AccessShareLock</font></div><div><font size="2"   >LOCATION: &nbsp;LockRelease, lock.c:1751</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [16384,16745] AccessShareLock</font></div><div><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:729</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [16384,16742] RowShareLock</font></div><div><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:729</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [16384,16742] AccessExclusiveLock</font></div><div><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:729</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: new: lock(0x2b7faf13b898) id(16384,16742,0,2,3,1) grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0 wait(0) type(AccessExclusiveLock)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:318</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: new: proclock(0x2b7faf1c12c8) lock(0x2b7faf13b898) method(1) proc(0x2b7faf3da6a0) hold(0)</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:330</font></div><div><font size="2"   >LOG: &nbsp;00000: LockCheckConflicts: no conflict: proclock(0x2b7faf1c12c8) lock(0x2b7faf13b898) method(1) proc(0x2b7faf3da6a0) hold(0)</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:330</font></div><div><font size="2"   >-- 先检测与已经存在的请求锁的队列中的锁是否有冲突. 有冲突则加入等待队列. 没有冲突则与已经HOLD的锁检测冲突性.如果发现冲突则加入队列中.</font></div><div><font size="2"   >-- 这就能解释本文的第二个问题了.</font></div><div><pre style="font-family: monospace, fixed; font-size: 9pt; border: 1px solid rgb(196, 207, 229); background-color: rgb(251, 252, 253); padding: 4px 6px; margin: 4px 8px 4px 2px; overflow: auto; word-wrap: break-word; line-height: 15px;"   >00900     <span style="color: rgb(128, 0, 0);"   >/*</span><br><a style="color: rgb(61, 87, 140);" name="l00901" rel="nofollow"   ></a>00901 <span style="color: rgb(128, 0, 0);"   >     * If lock requested conflicts with locks requested by waiters, must join</span><br><a style="color: rgb(61, 87, 140);" name="l00902" rel="nofollow"   ></a>00902 <span style="color: rgb(128, 0, 0);"   >     * wait queue.  Otherwise, check for conflict with already-held locks.</span><br><a style="color: rgb(61, 87, 140);" name="l00903" rel="nofollow"   ></a>00903 <span style="color: rgb(128, 0, 0);"   >     * (That's last because most complex check.)</span><br><a style="color: rgb(61, 87, 140);" name="l00904" rel="nofollow"   ></a>00904 <span style="color: rgb(128, 0, 0);"   >     */</span></pre></div><div><font size="2"   >LOG: &nbsp;00000: GrantLock: lock(0x2b7faf13b898) id(16384,16742,0,2,3,1) grantMask(100) req(0,0,0,0,0,0,0)=1 grant(0,0,0,0,0,0,0)=1 wait(0) type(AccessExclusiveLock)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:318</font></div><p></p></pre></div><div><p style="line-height: 22px;"   ></p><div>SESSION D :&nbsp;<br><pre class="prettyprint"   ><p style="line-height: 22px;"   ></p><div style="line-height: 22px;"   ><font size="2"   >digoal=# set trace_locks = on;</font></div><div style="line-height: 22px;"   ><font size="2"   >SET</font></div><div style="line-height: 22px;"   ><font size="2"   >digoal=# set trace_userlocks = on;</font></div><div style="line-height: 22px;"   ><font size="2"   >SET</font></div><div style="line-height: 22px;"   ><font size="2"   >digoal=# \set VERBOSITY verbose</font></div><div style="line-height: 22px;"   ><font size="2"   >digoal=# set client_min_messages=debug5;</font></div><div style="line-height: 22px;"   ><font size="2"   >DEBUG: &nbsp;00000: CommitTransactionCommand</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;finish_xact_command, postgres.c:2409</font></div><div style="line-height: 22px;"   ><font size="2"   >DEBUG: &nbsp;00000: CommitTransaction</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;ShowTransactionState, xact.c:4388</font></div><div style="line-height: 22px;"   ><font size="2"   >DEBUG: &nbsp;00000: name: unnamed; blockState: &nbsp; &nbsp; &nbsp; STARTED; state: INPROGR, xid/subid/cid: 0/1/0, nestlvl: 1, children:&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;ShowTransactionStateRec, xact.c:4426</font></div><div style="line-height: 22px;"   ><font size="2"   >LOG: &nbsp;00000: LockReleaseAll: lockmethod=1</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:1941</font></div><div style="line-height: 22px;"   ><font size="2"   >LOG: &nbsp;00000: LockReleaseAll done</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:2164</font></div><div style="line-height: 22px;"   ><font size="2"   >LOG: &nbsp;00000: LockReleaseAll: lockmethod=2</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:1941</font></div><div style="line-height: 22px;"   ><font size="2"   >LOG: &nbsp;00000: LockReleaseAll done</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:2164</font></div><div style="line-height: 22px;"   ><font size="2"   >SET</font></div><div style="line-height: 22px;"   ><font size="2"   >digoal=# begin;</font></div><div style="line-height: 22px;"   ><font size="2"   >DEBUG: &nbsp;00000: StartTransactionCommand</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;start_xact_command, postgres.c:2385</font></div><div style="line-height: 22px;"   ><font size="2"   >DEBUG: &nbsp;00000: StartTransaction</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;ShowTransactionState, xact.c:4388</font></div><div style="line-height: 22px;"   ><font size="2"   >DEBUG: &nbsp;00000: name: unnamed; blockState: &nbsp; &nbsp; &nbsp; DEFAULT; state: INPROGR, xid/subid/cid: 0/1/0, nestlvl: 1, children:&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;ShowTransactionStateRec, xact.c:4426</font></div><div style="line-height: 22px;"   ><font size="2"   >DEBUG: &nbsp;00000: ProcessUtility</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;PortalRunUtility, pquery.c:1154</font></div><div style="line-height: 22px;"   ><font size="2"   >DEBUG: &nbsp;00000: CommitTransactionCommand</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;finish_xact_command, postgres.c:2409</font></div><div style="line-height: 22px;"   ><font size="2"   >BEGIN</font></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div style="line-height: 22px;"   ><font size="2"   >digoal=# select * from test for share;</font></div><div style="line-height: 22px;"   ><font size="2"   >DEBUG: &nbsp;00000: StartTransactionCommand</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;start_xact_command, postgres.c:2385</font></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div style="line-height: 22px;"   ><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [16384,16742] RowShareLock</font></div><div style="line-height: 22px;"   ><font size="2"   >LINE 1: select * from test for share;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:729</font></div><div style="line-height: 22px;"   ><font size="2"   ><u>对应代码:</u></font></div><div style="line-height: 22px;"   ><font size="2"   ><u>00725 #ifdef LOCK_DEBUG<br>00726     if (LOCK_DEBUG_ENABLED(locktag))<br>00727         elog(LOG, "LockAcquire: lock [%u,%u] %s",<br>00728              locktag-&gt;locktag_field1, locktag-&gt;locktag_field2,<br>00729              lockMethodTable-&gt;lockModeNames[lockmode]);<br>00730 #endif</u></font></div><div style="line-height: 22px;"   ><font size="2"   ><u>这里的16384是dbid, 16742是relid, 代码如下 : </u></font></div><div style="line-height: 22px;"   ><div><u><font size="2"   >00240 #define SET_LOCKTAG_TUPLE(locktag,dboid,reloid,blocknum,offnum) \</font></u></div><div><u><font size="2"   >00241 &nbsp; &nbsp; ((locktag).locktag_field1 = (dboid), \</font></u></div><div><u><font size="2"   >00242 &nbsp; &nbsp; &nbsp;(locktag).locktag_field2 = (reloid), \</font></u></div><div><u><font size="2"   >00243 &nbsp; &nbsp; &nbsp;(locktag).locktag_field3 = (blocknum), \</font></u></div><div><u><font size="2"   >00244 &nbsp; &nbsp; &nbsp;(locktag).locktag_field4 = (offnum), \</font></u></div><div><u><font size="2"   >00245 &nbsp; &nbsp; &nbsp;(locktag).locktag_type = LOCKTAG_TUPLE, \</font></u></div><div><u><font size="2"   >00246 &nbsp; &nbsp; &nbsp;(locktag).locktag_lockmethodid = DEFAULT_LOCKMETHOD)</font></u></div></div><div style="line-height: 22px;"   ><u style="line-height: 20px;"   ><font size="2"   >验证如下 :</font></u></div><div style="line-height: 22px;"   ><font size="2"   ><u>pgdev@db-172-16-3-150-&gt; psql<br>psql (9.3devel)<br>Type "help" for help.<br>digoal=# select oid,datname from pg_database where oid=16384;<br>  oid  | datname <br>-------+---------<br> 16384 | digoal<br>(1 row)<br>digoal=# \c digoal<br>You are now connected to database "digoal" as user "postgres".<br>digoal=# select relname,relkind from pg_class where oid=16742;<br> relname | relkind <br>---------+---------<br> test    | r<br>(1 row)</u></font></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div style="line-height: 22px;"   ><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [16384,16742] AccessShareLock</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:729</font></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div style="line-height: 22px;"   ><font size="2"   >LOG: &nbsp;00000: LockRelease: lock [16384,16742] AccessShareLock</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;LockRelease, lock.c:1751</font></div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   ><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [16384,16745] AccessShareLock</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:729</font></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div style="line-height: 22px;"   ><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [16384,16742] RowShareLock</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:729</font></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div style="line-height: 22px;"   ><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [16384,16742] RowShareLock</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:729</font></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div><font size="2"   ><span style="line-height: 19px;"   >LOG:  00000: LockAcquire: found: lock(0x2b7faf13b898) id(16384,16742,0,2,3,1) grantMask(100) req(0,0,0,0,0,0,0)=1 grant(0,0,0,0,0,0,0)=1 wait(0) type(RowShareLock)<br>LOCATION:  LOCK_PRINT, lock.c:318</span></font></div><div style="line-height: 22px;"   ><font size="2"   ><u>代码如下 : </u></font></div><div><font size="2"   ><u>00298 inline static void<br>00299 LOCK_PRINT(const char *where, const LOCK *lock, LOCKMODE type)<br>00300 {<br>00301     if (LOCK_DEBUG_ENABLED(&amp;lock-&gt;tag))<br>00302         elog(LOG,<br>00303              "%s: lock(%p) id(%u,%u,%u,%u,%u,%u) grantMask(%x) "<br>00304              "req(%d,%d,%d,%d,%d,%d,%d)=%d "<br>00305              "grant(%d,%d,%d,%d,%d,%d,%d)=%d wait(%d) type(%s)",<br>00306              where, lock,<br>00307              lock-&gt;tag.locktag_field1, lock-&gt;tag.locktag_field2,<br>00308              lock-&gt;tag.locktag_field3, lock-&gt;tag.locktag_field4,<br>00309              lock-&gt;tag.locktag_type, lock-&gt;tag.locktag_lockmethodid,<br>00310              lock-&gt;grantMask,<br>00311              lock-&gt;requested[1], lock-&gt;requested[2], lock-&gt;requested[3],<br>00312              lock-&gt;requested[4], lock-&gt;requested[5], lock-&gt;requested[6],<br>00313              lock-&gt;requested[7], lock-&gt;nRequested,<br>00314              lock-&gt;granted[1], lock-&gt;granted[2], lock-&gt;granted[3],<br>00315              lock-&gt;granted[4], lock-&gt;granted[5], lock-&gt;granted[6],<br>00316              lock-&gt;granted[7], lock-&gt;nGranted,<br>00317              lock-&gt;waitProcs.size,<br>00318              LockMethods[LOCK_LOCKMETHOD(*lock)]-&gt;lockModeNames[type]);<br>00319 }</u></font></div><div><font size="2"   ><u>tag枚举列表如下</u></font></div><div><font size="2"   ><u>00158 /*<br>00159  * LOCKTAG is the key information needed to look up a LOCK item in the<br>00160  * lock hashtable.  A LOCKTAG value uniquely identifies a lockable object.<br>00161  *<br>00162  * The LockTagType enum defines the different kinds of objects we can lock.<br>00163  * We can handle up to 256 different LockTagTypes.<br>00164  */<br>00165 typedef enum LockTagType<br>00166 {<br>00167     LOCKTAG_RELATION,           /* whole relation */<br>00168     /* ID info for a relation is DB OID + REL OID; DB OID = 0 if shared */<br>00169     LOCKTAG_RELATION_EXTEND,    /* the right to extend a relation */<br>00170     /* same ID info as RELATION */<br>00171     LOCKTAG_PAGE,               /* one page of a relation */<br>00172     /* ID info for a page is RELATION info + BlockNumber */<br>00173     LOCKTAG_TUPLE,              /* one physical tuple */<br>00174     /* ID info for a tuple is PAGE info + OffsetNumber */<br>00175     LOCKTAG_TRANSACTION,        /* transaction (for waiting for xact done) */<br>00176     /* ID info for a transaction is its TransactionId */<br>00177     LOCKTAG_VIRTUALTRANSACTION, /* virtual transaction (ditto) */<br>00178     /* ID info for a virtual transaction is its VirtualTransactionId */<br>00179     LOCKTAG_OBJECT,             /* non-relation database object */<br>00180     /* ID info for an object is DB OID + CLASS OID + OBJECT OID + SUBID */<br>00181 <br>00182     /*<br>00183      * Note: object ID has same representation as in pg_depend and<br>00184      * pg_description, but notice that we are constraining SUBID to 16 bits.<br>00185      * Also, we use DB OID = 0 for shared objects such as tablespaces.<br>00186      */<br>00187     LOCKTAG_USERLOCK,           /* reserved for old contrib/userlock code */<br>00188     LOCKTAG_ADVISORY            /* advisory user locks */<br>00189 } LockTagType;</u></font></div><div><font size="2"   ><u>LOCK数据结构如下 : </u></font></div><div><font size="2"   ><u>00281 /*<br>00282  * Per-locked-object lock information:<br>00283  *<br>00284  * tag -- uniquely identifies the object being locked<br>00285  * grantMask -- bitmask for all lock types currently granted on this object.<br>00286  * waitMask -- bitmask for all lock types currently awaited on this object.<br>00287  * procLocks -- list of PROCLOCK objects for this lock.<br>00288  * waitProcs -- queue of processes waiting for this lock.<br>00289  * requested -- count of each lock type currently requested on the lock<br>00290  *      (includes requests already granted!!).<br>00291  * nRequested -- total requested locks of all types.<br>00292  * granted -- count of each lock type currently granted on the lock.<br>00293  * nGranted -- total granted locks of all types.<br>00294  *<br>00295  * Note: these counts count 1 for each backend.  Internally to a backend,<br>00296  * there may be multiple grabs on a particular lock, but this is not reflected<br>00297  * into shared memory.<br>00298  */<br>00299 typedef struct LOCK<br>00300 {<br>00301     /* hash key */<br>00302     LOCKTAG     tag;            /* unique identifier of lockable object */<br>00303 <br>00304     /* data */<br>00305     LOCKMASK    grantMask;      /* bitmask for lock types already granted */<br>00306     LOCKMASK    waitMask;       /* bitmask for lock types awaited */<br>00307     SHM_QUEUE   procLocks;      /* list of PROCLOCK objects assoc. with lock */<br>00308     PROC_QUEUE  waitProcs;      /* list of PGPROC objects waiting on lock */<br>00309     int         requested[MAX_LOCKMODES];       /* counts of requested locks */<br>00310     int         nRequested;     /* total of requested[] array */<br>00311     int         granted[MAX_LOCKMODES]; /* counts of granted locks */<br>00312     int         nGranted;       /* total of granted[] array */<br>00313 } LOCK;</u></font></div><div><u><font size="2"   style="line-height: 22px;"   >解释 </font><font size="2"   ><span style="line-height: 19px;"   >id(16384,16742,0,2,3,1)</span></font></u></div><div><font size="2"   ><u>00193 /*<br>00194  * The LOCKTAG struct is defined with malice aforethought to fit into 16<br>00195  * bytes with no padding.  Note that this would need adjustment if we were<br>00196  * to widen Oid, BlockNumber, or TransactionId to more than 32 bits.<br>00197  *<br>00198  * We include lockmethodid in the locktag so that a single hash table in<br>00199  * shared memory can store locks of different lockmethods.<br>00200  */<br>00201 typedef struct LOCKTAG<br>00202 {<br>00203     uint32      locktag_field1; /* a 32-bit ID field */<br>00204     uint32      locktag_field2; /* a 32-bit ID field */<br>00205     uint32      locktag_field3; /* a 32-bit ID field */<br>00206     uint16      locktag_field4; /* a 16-bit ID field */<br>00207     uint8       locktag_type;   /* see enum LockTagType */<br>00208     uint8       locktag_lockmethodid;   /* lockmethod indicator */<br>00209 } LOCKTAG;<br>00132 /* These identify the known lock methods */<br>00133 #define DEFAULT_LOCKMETHOD  1<br>00134 #define USER_LOCKMETHOD     2<br><br>本例是行锁, 所以设置tag的值对应以下宏 : <br>00240 #define SET_LOCKTAG_TUPLE(locktag,dboid,reloid,blocknum,offnum) \<br>00241     ((locktag).locktag_field1 = (dboid), \<br>00242      (locktag).locktag_field2 = (reloid), \<br>00243      (locktag).locktag_field3 = (blocknum), \<br>00244      (locktag).locktag_field4 = (offnum), \<br>00245      (locktag).locktag_type = LOCKTAG_TUPLE, \<br>00246      (locktag).locktag_lockmethodid = DEFAULT_LOCKMETHOD)<br>因此 id(16384,16742,0,2,3,1)<br>16384 : lock-&gt;tag.locktag_field1 = dboid<br>16742 : lock-&gt;tag.locktag_field2 = reloid<br>0 : lock-&gt;tag.locktag_field3 = blocknum<br>2 : lock-&gt;tag.locktag_field4 = offnum<br>3 : lock-&gt;tag.locktag_type = LOCKTAG_TUPLE (见LockTagType枚举)<br>1 : lock-&gt;tag.locktag_lockmethodid = DEFAULT_LOCKMETHOD (见DEFAULT_LOCKMETHOD定义)</u></font></div><div><font size="2"   ><span style="line-height: 19px;"   ><u>offnum对应CTID : </u></span></font></div><div><font size="2"   ><u>digoal=# select ctid,* from test;<br> ctid  | id | info <br>-------+----+------<br> (0,2) |  2 | <br> (0,3) |  1 | test<br>(2 rows)</u></font></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div><font size="2"   ><span style="line-height: 19px;"   >LOG:  00000: LockAcquire: new: proclock(0x2b7faf1c1160) lock(0x2b7faf13b898) method(1) proc(0x2b7faf3da0e0) hold(0)<br>LOCATION:  PROCLOCK_PRINT, lock.c:330<br><br>LOG:  00000: LockCheckConflicts: conflicting: proclock(0x2b7faf1c1160) lock(0x2b7faf13b898) method(1) proc(0x2b7faf3da0e0) hold(0)<br>LOCATION:  PROCLOCK_PRINT, lock.c:330<br><br>LOG:  00000: WaitOnLock: sleeping on lock: lock(0x2b7faf13b898) id(16384,16742,0,2,3,1) grantMask(100) req(0,1,0,0,0,0,0)=2 grant(0,0,0,0,0,0,0)=1 wait(0) type(RowShareLock)<br>LOCATION:  LOCK_PRINT, lock.c:318</span></font></div><p style="line-height: 22px;"   ></p></pre></div><p style="line-height: 22px;"   ></p></div></div><div><span style="line-height: 22px;"   >【小结】</span></div><div><span style="line-height: 22px;"   >1.&nbsp;</span></div><div><span style="line-height: 22px;"   >单条记录同时被多个事务共享锁时, 锁信息存储在pg_multixact中.&nbsp;</span></div><div>记录的头信息中t_infomask HEAP_XMAX_IS_MULTI 比特位将会被设置。</div><div>记录的头信息中t_xmax代表的是MultiXactId.</div><div>2.&nbsp;</div><div>当多个事务并发请求锁同一条tuple时, 先请求锁的会话如果与已经存在的锁发生冲突, 将会产生一个锁队列, 后来的会话请求锁时需要先检测锁队列是否冲突再检测与已经HOLD住的锁是否冲突. 因此不会造成多个共享锁持续占用TUPLE而独占锁一直都请求不到锁的情况。</div><div><br></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >【参考】</span></div></div></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   >1. src/backend/access/heap/README.tuplock</div><div style="line-height: 22px;"   >2. src/include/access/htup_details.h</div><div style="line-height: 22px;"   >3. src/include/access/multixact.h</div><div style="line-height: 22px;"   >4. src/backend/access/transam/multixact.c</div><div style="line-height: 22px;"   >5. src/include/access/heapam.h</div><div style="line-height: 22px;"   >6. src/backend/access/heap/heapam.c</div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >7. src/backend/utils/adt/lockfuncs.c</span></div><div style="line-height: 22px;"   >8. src/backend/storage/lmgr/lock.c</div><div style="line-height: 22px;"   >9. src/backend/storage/lmgr/lmgr.c</div><div style="line-height: 22px;"   >10.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/pgrowlocks.html"   >http://www.postgresql.org/docs/devel/static/pgrowlocks.html</a></div><div style="line-height: 22px;"   >11.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/pageinspect.html"   >http://www.postgresql.org/docs/devel/static/pageinspect.html</a></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >12.&nbsp;</span><a style="line-height: 22px;" target="_blank" rel="nofollow" href="https://github.com/postgres/postgres/commit/0ac5ad5134f2769ccbaefec73844f8504c4d6182"   >https://github.com/postgres/postgres/commit/0ac5ad5134f2769ccbaefec73844f8504c4d6182</a></div><div style="line-height: 22px;"   >13.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020130249109133/"   >http://blog.163.com/digoal@126/blog/static/16387704020130249109133/</a></div><div style="line-height: 22px;"   >14.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020130305109687/"   >http://blog.163.com/digoal@126/blog/static/16387704020130305109687/</a></div><div style="line-height: 22px;"   >15.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201210134586363/"   >http://blog.163.com/digoal@126/blog/static/163877040201210134586363/</a></div><div style="line-height: 22px;"   >16.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402011515105557166/"   >http://blog.163.com/digoal@126/blog/static/1638770402011515105557166/</a></div><div style="line-height: 22px;"   >17.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020130312271679/"   >http://blog.163.com/digoal@126/blog/static/16387704020130312271679/</a></div></div></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL How to deal TUPLE LOCK : 2 - one|more transactions waiting one|more transactions release tuple lock - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>