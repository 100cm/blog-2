<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL Distributed|Sharded Databases Consistent PITR Thinking</h2>
	<h5 id="">2013-02-06 10:10:13&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020131532522284/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>前言, 建议先了解一下PostgreSQL 的PITR再看本文.</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201303082942271/"   >http://blog.163.com/digoal@126/blog/static/163877040201303082942271/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020131410250983/"   >http://blog.163.com/digoal@126/blog/static/16387704020131410250983/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402013141100160/"   >http://blog.163.com/digoal@126/blog/static/1638770402013141100160/</a></div><div><br></div><wbr>最近几天收到一位网友wsxsl的EMAIL, 在他们的应用场景中有跨库事务的需求。<div><span style="line-height: 22px;"   >数据库做了sharding后, 就可能会引入跨库的事务. 当然也有不跨库的事务。</span><br><div><span style="line-height: 22px;"   >有跨库的事务必然会同时要求数据库可以实现全局一致的还原。</span></div><div>shard 后数据库的一致性还原可以这么来理解(首先需要对事务进行分解, 分为跨库事务和 非跨库事务也就是本地事务) :&nbsp;</div><div>1. 对于跨库事务必须确保它在各个shard节点中的操作都提交或者都回滚.(all committed, or all abort.)</div><div>2. 对于单个shard节点, 必须确保一致性. (本地事务操作的原子性(all committed or all abort), 同时确保时序性(不能出现后提交的事务已恢复但是先提交的事务未恢复).)</div><div>以上两点, 第二点PostgreSQL自身的PITR就可以满足这个需求.</div><div>第一点, 则是需要处理的重点.</div><div><span style="line-height: 22px;"   >在谈第一点之前, 来看一个图, 跨库事务可能存在的交错现象 :&nbsp;</span></div><div><div><img title="PostgreSQL Distributed|Sharded Databases Consistent PITR Thinking - 德哥@Digoal - The Heart,The World."   alt="PostgreSQL Distributed|Sharded Databases Consistent PITR Thinking - 德哥@Digoal - The Heart,The World."   style="margin:0 10px 0 0;"   src="http://img9.ph.126.net/7XQLtFUp1iKu8wPvHuTgzw==/2697937651789471979.jpg"   ></div>解释一下上图 :&nbsp;</div><div>【1】</div><div>1. ABCDE是五个节点, 其中A为产生全局ID的节点, BCDE为数据节点.</div><div>2. 每个节点有各自的时间轴.</div><div>3. 格子里面的数字代表全局事务ID(跨库事务), 以及在各自的时间轴上的事务提交位置(其实就是各节点PG_XLOG中的位置).</div><div>4. 全局事务ID对应的本地事务ID为节点号_id , 例如全局事务1在B节点的本地事务ID为B1. 图中未标出, 后面讲解需要用到.</div><div>5. 灰色格子代表该事务是回滚掉的. 白色格子代表该事务是提交掉的.</div><div>6. 同一个时间轴上, 两个事务之间可能还有非跨库事务(本地事务), 这些在图中没有画出, 因为不影响全局一致性还原. 但是大家要知道一下.</div><div>注意跨库事务1, 在B节点是第一个提交的. 但是在C节点, 它是在跨库事务2的后面提交的 .&nbsp;</div><div>如果以跨库事务1为PITR的目标, 以PostgreSQL recovery.conf中配置recovery_target_xid为例, 如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 22px;"   >recovery_target_xid=B1,&nbsp;</span>recovery_target_inclusive=true</font></div><div><font size="2"   ><span style="line-height: 22px;"   >recovery_target_xid=C1</span><span style="line-height: 22px;"   >,&nbsp;</span><span style="line-height: 22px;"   >recovery_target_inclusive=true</span></font></div><div><font size="2"   ><span style="line-height: 22px;"   >recovery_target_xid=D1</span><span style="line-height: 22px;"   >,&nbsp;</span><span style="line-height: 22px;"   >recovery_target_inclusive=true</span></font></div><div><font size="2"   ><span style="line-height: 22px;"   >recovery_target_xid=E1</span><span style="line-height: 22px;"   >,&nbsp;</span><span style="line-height: 22px;"   >recovery_target_inclusive=true</span></font></div><p></p></pre></div><div><span style="line-height: 22px;"   >恢复后的全局事务状态 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><font size="2"   >B : B1 committed</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   >C : C2,C1 committed</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   >D : D1 committed</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   >E : E2,E1 committed</font></span></div><p></p></pre></div><div><span style="line-height: 22px;"   >整体来看, 全局事务2出现了不一致的现象, 在B,D节点未提交, 但是在C,E节点已提交.</span></div><div><span style="line-height: 22px;"   >【2】</span></div><div><span style="line-height: 22px;"   >还有一种情况是, 跨库事务可能出现在部分节点, 例如 :&nbsp;</span></div><div><span style="line-height: 22px;"   >跨库事务7 发生在2个节点 : B7, D7;&nbsp;</span></div><div><span style="line-height: 22px;"   >跨库事务8 发生在2个节点 :</span><span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >E8, C8;</span></div><div><span style="line-height: 22px;"   >那么这两个跨库事务则不可能存在交叉. 因为他们没有发生在同一个shard节点上的事务.</span></div><div>【3】</div><div>1. 对于上图, 6号和7号跨库事务显然是可以作为PITR的还原目标的, 因为不会出现跨库事务交错.</div><div>2. 5号事务其实也可以作为PITR的还原目标, 为什么呢? 因为4号事务是回滚的. 所以也不会有影响.</div><div><br></div><div>综上所述, 全局一致性还原的重点在如何找到合适的还原点。下面列举几种方法 :&nbsp;</div><div>【方法1】</div><div>计算现成的一致性还原点, 必要的要素 :&nbsp;</div><div>1. 唯一的全局事务ID, 这个可以使用统一的shard算法, 也就是说全局事务ID的产生节点也可以做成分布式的, 不会成为瓶颈.&nbsp;</div><div>算法举例 :&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201302245232286/"   >http://blog.163.com/digoal@126/blog/static/163877040201302245232286/</a></div><div>2. 全局事务ID对应的shard节点上的xid, 以及shard节点上该XID COMMIT或ABORT的时间 (是shard节点的时间, 这个时间必须取PG_XLOG中存储的时间). 请参见本文末尾的参考部分.&nbsp;</div><div><br></div><div><div>例如在B,C,D,E节点执行如下SQL, 创建记录GID的信息表.</div><div>还原点可以从这个表里面分析出来.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create type xstatus as enum ('commit', 'abort');</font></div><div><font size="2"   >CREATE TYPE</font></div><div><font size="2"   >postgres=# create table gid&nbsp;</font></div><div><font size="2"   >postgres-# (gid int8 primary key, -- 跨库事务ID, 由统一的算法产生. 参考前面的算法举例</font></div><div><font size="2"   >postgres(# gxstatus xstatus, -- 跨库事务状态, 业务APP负责写入</font></div><div><font size="2"   >postgres(# nodes text[], -- 跨库事务涉及的节点<span style="line-height: 22px;"   >, 业务APP负责写入</span></font></div><div><font size="2"   >postgres(# lxid int[], -- 跨库事务节点上对应的本地事务ID,&nbsp;<span style="line-height: 22px;"   >业务APP负责写入</span></font></div><div><font size="2"   >postgres(# lxcompletetime timestamptz[], -- 跨库事务节点上对应的本地事务完成时记录在XLogRecord上的时间. 从XLOG中解析, 需更新记录.</font></div><div><font size="2"   >postgres(# lxstatus xstatus[] -- 跨库事务节点上对应的本地事务的状态,&nbsp;<span style="line-height: 22px;"   >业务APP负责写入</span></font></div><div><font size="2"   >postgres(# );</font></div><div><font size="2"   >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "gid_pkey" for table "gid"</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div></div><div>为什么要在数据节点创建这个表呢?</div><div><div style="line-height: 22px;"   >因为全局ID信息如果丢失（假设因为业务APPs Crash）, 分两种情况.</div><div style="line-height: 22px;"   >1. 该全局ID对应的跨库事务状态是abort的. 也就是数据节点事务全部abort;&nbsp;</div><div style="line-height: 22px;"   >&nbsp; &nbsp; 这种情况这个全局ID的信息丢失对一致性还原不会造成影响.</div><div style="line-height: 22px;"   >2.&nbsp;<span style="line-height: 22px;"   >该全局ID对应的跨库事务状态是commit的.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >&nbsp; &nbsp; 这在情况下, 如果该全局ID的信息丢失, 会影响最终的全局一致性还原点解析, 导致数据库逻辑上全局不一致.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >所以解决办法是将全局ID数据的写入合并到业务的二阶事务中, 这样能够保证业务的处理和全局ID数据的处理的原子性.</span></div></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >放到数据节点一来省了服务器, 二来减少了交互, 第三由于分布了也降低了全局ID处理产生瓶颈的概率.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >如果跨库事务ID的存储也是分布式的, 那么计算全局一致性还原点时, 需要在所有数据中分析.</span></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   >全局一致性还原点算法 :&nbsp;</div><div style="line-height: 22px;"   >1. nodes没有与其他任何记录的nodes相交的记录, 该gid可以作为一致性还原点.</div><div style="line-height: 22px;"   >&nbsp; &nbsp; 可能性几乎为0</div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   >2. nodes与其他记录有相交时的算法, 仅对比相交的node. :&nbsp;</div><div style="line-height: 22px;"   >2.1.&nbsp;<span style="line-height: 22px;"   >lxcompletetime[]转换成gtime_range,&nbsp;</span><span style="line-height: 22px;"   >gtime_range不与其他任何gtime_range相交.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >2.2. 如果有相交, 则</span><span style="line-height: 22px;"   >lxcompletetime[]每个对应元素</span><span style="line-height: 22px;"   >必须完全相等.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >2.3. 过滤abort的记录, 重新执行2.1和2.2.</span></div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   >对于一个跨库事务频繁执行的业务, 第二种方法能找到的一致性还原点也几乎为0. 所以需要修复算法 :&nbsp;</div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >修复算法 :&nbsp;</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >业务层必须记录事务的undo和redo. 还原到有跨库事务交叉的点时，使用undo或redo修复有交叉的事务。</span></div></div></div><div><br></div><div>【方法2】</div><div>主动创建一致性还原点&nbsp;<span style="line-height: 22px;"   >&nbsp;:&nbsp;</span></div><div><div>1. 发出指令禁止新发起跨库事务的操作请求, 并<span style="line-height: 22px;"   >等待所有的跨库事务完结.</span></div><div>2. 等待<span style="line-height: 22px;"   >所有的跨库事务完结后</span>.</div><div>3. 在所有数据库节点上创建同名的还原点(recovery_target_name). 注意多次创建的还原点的名字不要重复.&nbsp;</div><div>4. 释放冻结,允许<span style="line-height: 22px;"   >新发起跨库事务的操作请求</span><span style="line-height: 22px;"   >(barrier).</span></div><div>具体的实现方法可以参考PostgreS-XC的做法.</div><div>使用这种方法对数据库有轻微的堵塞, 堵塞跨库事务的操作. 所以最好加个超时机制. 如果全局不能在一个时间段内达到堵塞状态, 则放弃堵塞.</div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >举例 :&nbsp;</span></div><div>跨库事务, 以两个节点为例 :&nbsp;</div><div>所有的跨库事务必须先获得所有涉及节点的一个共享锁, 否则不进行下去.&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >NODE A :&nbsp;</font></div><div><font size="2"   >begin;</font></div><div><font size="2"   >select 1 from barrier where id=1 for share nowait;</font></div><div><font size="2"   >... 业务SQL.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >NODE B :&nbsp;</font></div><div><div style="line-height: 22px;"   ><font size="2"   >begin;</font></div><div style="line-height: 22px;"   ><font size="2"   >select 1 from barrier where id=1 for share nowait;</font></div><div style="line-height: 22px;"   ><font size="2"   >... 业务SQL.</font></div></div><p></p></pre></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >插入还原点(所有的sharding节点都必须先获得排他锁, 以此来拒绝新发起的跨库事务, 确保数据逻辑状态一致) :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><font size="2"   >NODE A :&nbsp;</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   >begin;</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   >select 1 from barrier where id=1 for update;</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   ><br></font></span></div><div><span style="line-height: 22px;"   ><font size="2"   >NODE B :&nbsp;</font></span></div><div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >begin;</font></span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >select 1 from barrier where id=1 for update;</font></span></div></div><div style="line-height: 22px;"   ><font size="2"   >只有当NODE A,B都获得独占锁后方可插入还原点.</font></div><div style="line-height: 22px;"   ><font size="2"   >注意控制超时, 不能for update太久, 否则堵塞影响时间就太长了.</font></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div style="line-height: 22px;"   ><font size="2"   >NODE A, B :&nbsp;</font></div><div><font size="2"   >select * from pg_create_restore_point('node A,B 相同的唯一值');</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >NODE A, B :&nbsp;</font></div><div><font size="2"   >释放<span style="line-height: 22px;"   >barrier where id=1 for update.</span></font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >【方法3,&nbsp;</span><span style="line-height: 22px;"   >Postgres-XC的做法</span><span style="line-height: 22px;"   >】</span></div><div><span style="line-height: 22px;"   >与上面类似.参考 :&nbsp;</span></div><div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://postgres-xc.sourceforge.net/docs/1_0/barriers.html"   >http://postgres-xc.sourceforge.net/docs/1_0/barriers.html</a></div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://postgres-xc.sourceforge.net/docs/1_0/sql-createbarrier.html"   >http://postgres-xc.sourceforge.net/docs/1_0/sql-createbarrier.html</a></div></div><div><div style="line-height: 22px;"   >src/backend/pgxc/barrier/barrier.c</div><div style="line-height: 22px;"   >src/include/pgxc/barrier.h</div></div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   ><span style="line-height: 28px;"   >【参考】</span></div><div>1.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020111141103578/"   >http://blog.163.com/digoal@126/blog/static/16387704020111141103578/</a></div><div><div style="line-height: 22px;"   >2.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201303082942271/"   >http://blog.163.com/digoal@126/blog/static/163877040201303082942271/</a></div><div style="line-height: 22px;"   >3.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020131410250983/"   >http://blog.163.com/digoal@126/blog/static/16387704020131410250983/</a></div><div style="line-height: 22px;"   >4.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402013141100160/"   >http://blog.163.com/digoal@126/blog/static/1638770402013141100160/</a></div></div><div style="line-height: 22px;"   >5.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201302245232286/"   >http://blog.163.com/digoal@126/blog/static/163877040201302245232286/</a></div><div>6.&nbsp;<a target="_blank" rel="nofollow" href="http://postgres-xc.sourceforge.net/"   >http://postgres-xc.sourceforge.net/</a></div><div>7.&nbsp;<a target="_blank" rel="nofollow" href="http://postgres-xc.sourceforge.net/docs/1_0/barriers.html"   >http://postgres-xc.sourceforge.net/docs/1_0/barriers.html</a></div><div>8.&nbsp;<a target="_blank" rel="nofollow" href="http://postgres-xc.sourceforge.net/docs/1_0/sql-createbarrier.html"   >http://postgres-xc.sourceforge.net/docs/1_0/sql-createbarrier.html</a></div><div>9. src/backend/pgxc/barrier/barrier.c</div><div>10.&nbsp;src/include/pgxc/barrier.h</div><div>11. src/backend/storage/lmgr/README</div><div>12.&nbsp;<span style="line-height: 22px;"   >src/backend/storage/lmgr/</span>README.barrier</div><div>13.&nbsp;src/include/storage/barrier.h</div><div>14.&nbsp;</div><div><span style="line-height: 22px;"   >XLogRecord中的COMMIT/ABORT的时间信息相关代码 :&nbsp;</span></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   >src/backend/utils/adt/timestamp.c</div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >01262 /*</font></div><div style="line-height: 22px;"   ><font size="2"   >01263 &nbsp;* GetCurrentTimestamp -- get the current operating system time</font></div><div style="line-height: 22px;"   ><font size="2"   >01264 &nbsp;*</font></div><div style="line-height: 22px;"   ><font size="2"   >01265 &nbsp;* Result is in the form of a TimestampTz value, and is expressed to the</font></div><div style="line-height: 22px;"   ><font size="2"   >01266 &nbsp;* full precision of the gettimeofday() syscall</font></div><div style="line-height: 22px;"   ><font size="2"   >01267 &nbsp;*/</font></div><div style="line-height: 22px;"   ><font size="2"   >01268 TimestampTz</font></div><div style="line-height: 22px;"   ><font size="2"   >01269 GetCurrentTimestamp(void)</font></div><div style="line-height: 22px;"   ><font size="2"   >01270 {</font></div><div style="line-height: 22px;"   ><font size="2"   >01271 &nbsp; &nbsp; TimestampTz result;</font></div><div style="line-height: 22px;"   ><font size="2"   >01272 &nbsp; &nbsp; struct timeval tp;</font></div><div style="line-height: 22px;"   ><font size="2"   >01273&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >01274 &nbsp; &nbsp; gettimeofday(&amp;tp, NULL);</font></div><div style="line-height: 22px;"   ><font size="2"   >01275&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >01276 &nbsp; &nbsp; result = (TimestampTz) tp.tv_sec -</font></div><div style="line-height: 22px;"   ><font size="2"   >01277 &nbsp; &nbsp; &nbsp; &nbsp; ((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);</font></div><div style="line-height: 22px;"   ><font size="2"   >01278&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >01279 #ifdef HAVE_INT64_TIMESTAMP</font></div><div style="line-height: 22px;"   ><font size="2"   >01280 &nbsp; &nbsp; result = (result * USECS_PER_SEC) + tp.tv_usec;</font></div><div style="line-height: 22px;"   ><font size="2"   >01281 #else</font></div><div style="line-height: 22px;"   ><font size="2"   >01282 &nbsp; &nbsp; result = result + (tp.tv_usec / 1000000.0);</font></div><div style="line-height: 22px;"   ><font size="2"   >01283 #endif</font></div><div style="line-height: 22px;"   ><font size="2"   >01284&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >01285 &nbsp; &nbsp; return result;</font></div><div style="line-height: 22px;"   ><font size="2"   >01286 }</font></div><p></p></pre></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >src/backend/access/transam/xact.c</span></div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >/*</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* xactStartTimestamp is the value of transaction_timestamp().</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* stmtStartTimestamp is the value of statement_timestamp().</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* xactStopTimestamp is the time at which we log a commit or abort WAL record.</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* These do not change as we enter and exit subtransactions, so we don't</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* keep them inside the TransactionState stack.</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 22px;"   ><font size="2"   >static TimestampTz xactStartTimestamp;</font></div><div style="line-height: 22px;"   ><font size="2"   >static TimestampTz stmtStartTimestamp;</font></div><div style="line-height: 22px;"   ><font size="2"   >static TimestampTz xactStopTimestamp;</font></div><div style="line-height: 22px;"   ><font size="2"   ><br style="line-height: 22px;"   ></font></div><div style="line-height: 22px;"   ><font size="2"   >/*</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;transaction states - transaction state from server perspective</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 22px;"   ><font size="2"   >typedef enum TransState</font></div><div style="line-height: 22px;"   ><font size="2"   >{</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRANS_DEFAULT, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* idle */</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRANS_START, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* transaction starting */</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRANS_INPROGRESS, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* inside a valid transaction */</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRANS_COMMIT, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* commit in progress */</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRANS_ABORT, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* abort in progress */</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRANS_PREPARE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* prepare in progress */</font></div><div style="line-height: 22px;"   ><font size="2"   >} TransState;</font></div><div style="line-height: 22px;"   ><font size="2"   ><br style="line-height: 22px;"   ></font></div><div style="line-height: 22px;"   ><font size="2"   >/*</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;GetCurrentTransactionStopTimestamp</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* We return current time if the transaction stop time hasn't been set</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* (which can happen if we decide we don't need to log an XLOG record).</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 22px;"   ><font size="2"   >TimestampTz</font></div><div style="line-height: 22px;"   ><font size="2"   >GetCurrentTransactionStopTimestamp(void)</font></div><div style="line-height: 22px;"   ><font size="2"   >{</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (xactStopTimestamp != 0)</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return xactStopTimestamp;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return GetCurrentTimestamp();</font></div><div style="line-height: 22px;"   ><font size="2"   >}</font></div><div style="line-height: 22px;"   ><font size="2"   ><br style="line-height: 22px;"   ></font></div><div style="line-height: 22px;"   ><font size="2"   >/*</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;SetCurrentTransactionStopTimestamp</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 22px;"   ><font size="2"   >static inline void</font></div><div style="line-height: 22px;"   ><font size="2"   >SetCurrentTransactionStopTimestamp(void)</font></div><div style="line-height: 22px;"   ><font size="2"   >{</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; xactStopTimestamp = GetCurrentTimestamp();</font></div><div style="line-height: 22px;"   ><font size="2"   >}</font></div><div style="line-height: 22px;"   ><font size="2"   ><br style="line-height: 22px;"   ></font></div><div style="line-height: 22px;"   ><font size="2"   >/*</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;RecordTransactionCommit</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* Returns latest XID among xact and its children, or InvalidTransactionId</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* if the xact has no XID. &nbsp; &nbsp; &nbsp;(We compute that here just because it's easier.)</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 22px;"   ><font size="2"   >static TransactionId</font></div><div style="line-height: 22px;"   ><font size="2"   >RecordTransactionCommit(void)</font></div><div style="line-height: 22px;"   ><font size="2"   >....</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; xlrec.xact_time = xactStopTimestamp;</font></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div style="line-height: 22px;"   ><font size="2"   >/*</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;RecordTransactionAbort</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* Returns latest XID among xact and its children, or InvalidTransactionId</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;* if the xact has no XID. &nbsp; &nbsp; &nbsp;(We compute that here just because it's easier.)</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 22px;"   ><font size="2"   >static TransactionId</font></div><div style="line-height: 22px;"   ><font size="2"   >RecordTransactionAbort(bool isSubXact)</font></div><div style="line-height: 22px;"   ><font size="2"   >....</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Write the ABORT record */</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (isSubXact)</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.xact_time = GetCurrentTimestamp();</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetCurrentTransactionStopTimestamp();</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.xact_time = xactStopTimestamp;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div></div><div><br></div></div></div></div>
	</div>
</div>
</body>
</html>