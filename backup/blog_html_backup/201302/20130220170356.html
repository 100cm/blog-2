<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL memory barrier defined but not used yet</h2>
	<h5 id="">2013-02-20 17:03:56&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020131483350188/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>PostgreSQL 9.2 添加了memory barrier的支持, 但是目前尚未被任何函数使用. 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp;* Add memory barrier support (Robert Haas)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;This is currently unused.</font></div><p></p></pre></div></div><wbr><div>包括memory barrier, read barrier, write barrier.</div><div>barrier在各种CPU架构下的指令名称不一样, 以下截取i386和x86的部分定义.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; 53 /*</font></div><div><font size="2"  >&nbsp; 54 &nbsp;* icc defines __GNUC__, but doesn't support gcc's inline asm syntax</font></div><div><font size="2"  >&nbsp; 55 &nbsp;*/</font></div><div><font size="2"  >&nbsp; 56 #define pg_memory_barrier() &nbsp; &nbsp; _mm_mfence()</font></div><div><font size="2"  >&nbsp; 57 #define pg_compiler_barrier() &nbsp; __memory_barrier()</font></div><div><font size="2"  >&nbsp; 58 #elif defined(__GNUC__)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; 60 /* This works on any architecture, since it's only talking to GCC itself. */</font></div><div><font size="2"  >&nbsp; 61 #define pg_compiler_barrier() &nbsp; __asm__ __volatile__("" : : : "memory")</font></div><div><font size="2"  >&nbsp; 62&nbsp;</font></div><div><font size="2"  >&nbsp; 63 #if defined(__i386__)</font></div><div><font size="2"  >&nbsp; 64&nbsp;</font></div><div><font size="2"  >&nbsp; 65 /*</font></div><div><font size="2"  >&nbsp; 66 &nbsp;* i386 does not allow loads to be reordered with other loads, or stores to be</font></div><div><font size="2"  >&nbsp; 67 &nbsp;* reordered with other stores, but a load can be performed before a subsequent</font></div><div><font size="2"  >&nbsp; 68 &nbsp;* store.</font></div><div><font size="2"  >&nbsp; 69 &nbsp;*</font></div><div><font size="2"  >&nbsp; 70 &nbsp;* "lock; addl" has worked for longer than "mfence".</font></div><div><font size="2"  >&nbsp; 71 &nbsp;*/</font></div><div><font size="2"  >&nbsp; 72 #define pg_memory_barrier() &nbsp; &nbsp; \</font></div><div><font size="2"  >&nbsp; 73 &nbsp; &nbsp; __asm__ __volatile__ ("lock; addl $0,0(%%esp)" : : : "memory")</font></div><div><font size="2"  >&nbsp; 74 #define pg_read_barrier() &nbsp; &nbsp; &nbsp; pg_compiler_barrier()</font></div><div><font size="2"  >&nbsp; 75 #define pg_write_barrier() &nbsp; &nbsp; &nbsp;pg_compiler_barrier()</font></div><div><font size="2"  >&nbsp; 76 #elif defined(__x86_64__) &nbsp; &nbsp; &nbsp; /* 64 bit x86 */</font></div><div><font size="2"  >&nbsp; 77&nbsp;</font></div><div><font size="2"  >&nbsp; 78 /*</font></div><div><font size="2"  >&nbsp; 79 &nbsp;* x86_64 has similar ordering characteristics to i386.</font></div><div><font size="2"  >&nbsp; 80 &nbsp;*</font></div><div><font size="2"  >&nbsp; 81 &nbsp;* Technically, some x86-ish chips support uncached memory access and/or</font></div><div><font size="2"  >&nbsp; 82 &nbsp;* special instructions that are weakly ordered. &nbsp;In those cases we'd need</font></div><div><font size="2"  >&nbsp; 83 &nbsp;* the read and write barriers to be lfence and sfence. &nbsp;But since we don't</font></div><div><font size="2"  >&nbsp; 84 &nbsp;* do those things, a compiler barrier should be enough.</font></div><div><font size="2"  >&nbsp; 85 &nbsp;*/</font></div><div><font size="2"  >&nbsp; 86 #define pg_memory_barrier() &nbsp; &nbsp; \</font></div><div><font size="2"  >&nbsp; 87 &nbsp; &nbsp; __asm__ __volatile__ ("lock; addl $0,0(%%rsp)" : : : "memory")</font></div><div><font size="2"  >&nbsp; 88 #define pg_read_barrier() &nbsp; &nbsp; &nbsp; pg_compiler_barrier()</font></div><div><font size="2"  >&nbsp; 89 #define pg_write_barrier() &nbsp; &nbsp; &nbsp;pg_compiler_barrier()</font></div><div><font size="2"  >&nbsp; 90 #elif defined(__ia64__) || defined(__ia64)</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >memory barrier的引入主要是要解决CPU的store buffer和invalidate queue引入以及多CPU协作可能带来的程序BUG(CPU全局共享内存状态不一致)问题, 后面会引用一些例子.</span></div><div>在PostgreSQL 多核编程中可能就要用到.</div><div>《Memory Barriers: a Hardware View for Software Hackers》这篇文章对CPU的store buffer以及invalidate queue的起源以及带来的问题做了比较详细的阐述, 有兴趣的朋友可以阅读一下. 下面截取一部分书中的内容 :&nbsp;</div><div>2006年的CPU每纳秒可以处理10个指令, 但是从主内存中获取一个数据项需要耗费十几个纳秒. 由于速度差异太大, 因此CPU CACHE产生了, 用来解决这个速度的差异问题. 每个CPU可能有几MB的CACHE. 如下图 :&nbsp;</div><div><div><img title="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img3.ph.126.net/mR_hoZBA5beqZKFN2xURiA==/190840034227790383.jpg"  ></div><div><span style="line-height: 22px;"  >CPU往往有多级CACHE, 假设最接近CPU的CACHE访问速度为1个时钟周期.&nbsp;</span></div></div><div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >It is standard practice to use multiple levels of cache,&nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  >with&nbsp;<span style="line-height: 22px;"  >a small level-one cache close to the CPU with single-cycle access time,&nbsp;</span></font></div><div style="line-height: 22px;"  ><font size="2"  ><span style="line-height: 22px;"  >and a larger level-two cache with a longer access&nbsp;</span><span style="line-height: 22px;"  >time, perhaps roughly ten clock cycles.&nbsp;</span></font></div><div style="line-height: 22px;"  ><font size="2"  >Higher-performance&nbsp;<span style="line-height: 22px;"  >CPUs often have three or even four levels of cache.</span></font></div><p></p></pre></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >在CPU CACHE或者主内存中, 数据流被分成了2的N次方的粒度, 范围是16到256字节. 这个粒度也称为cache lines.</span></div><div style="line-height: 22px;"  >当CPU初次访问一个数据项的时候, CPU CACHE中没有这个数据, 需要到主内存中获取, 这个场景称为cache miss(或者startup, warmup cache miss). 这个时候CPU不得不等待数据从主内存读入CPU CACHE(约100多个时钟周期).</div><div style="line-height: 22px;"  >当经过一段时间后, CPU CACHE可能被填满, 所以新的数据将不能写入cache. 这个场景称为capacity miss.&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >large caches are implemented as hardware hash tables with fixed-size hash buckets (or “sets”, as CPU designers callthem) and no chaining.</font></p></pre></div><div>大的CPU CACHE将被拆分成多个固定大小的HASH BUCKETS. 如下图.</div><div>下图中CPU CACHE被分成了2路, 每路16个bucket, 每个bucket存储256个字节.&nbsp;</div><div><div style="line-height: 22px;"  ><img title="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img8.ph.126.net/Vvs2PbiVNqUhNmtSJlwztw==/2504564342789382648.jpg"  ></div><div style="line-height: 22px;"  >由于每个BUCKET存储256字节的数据, HASH算法非常简单, 只要取倒数第三个十六进制位即可.</div><div style="line-height: 22px;"  >例如0x43210E00到<span style="line-height: 22px;"  >0x43210EFF</span><span style="line-height: 22px;"  >的数据在哪个BUCKET呢? 取倒数第三个十六进制位是0xE. 所以在way1 或者way 0的0xE</span><span style="line-height: 22px;"  >这个BUCKET找.</span></div><div><span style="line-height: 22px;"  >上图中空白部分表示这个BUCKET没有数据填充, 所以当有数据从主内存读取时可以写入到对应的空白BUCKET. 当读取的内容来自主内存地址</span>0x1233E00时, 由于两路的bucket都被占用了, 必须清理出1个BUCKET, 来存放.&nbsp;<span style="line-height: 22px;"  >例如清理掉way1的0xE这个BUCKET, 当下次访问0X43210E00的数据时, 因为已经填充了0x1233E00的数据, 所以此时称为associativity miss.</span></div><div>以上谈到的都是从主内存加载数据到CPU CACHE的情况, 下面来说说写或者修改CPU CACHE的情况.</div><div>在多CPU的环境中, 每个CPU有自己的CPU CAHCE, 所以当A CPU需要写某个地址的数据时, 需求先确保其他CPU的CACHE中没有这个地址的数据. 如果其他CPU CACHE中有这个地址的数据, 那么需要将这些CPU CACHE对应的数据清除(invalidate), 然后A CPU才可以修改A CPU CACHE中这个地址的数据. 其他CPU访问由于A CPU的写需求导致被清理掉的CACHE数据时, 这些数据已经不存在, 所以被称为communication miss.</div><div><span style="line-height: 22px;"  >由于多个CPU可能存储相同的数据在各自的CACHE中, 所以需要一个可靠的协议来保证不会出现数据紊乱(数据不一致或数据丢失). 这个就是cache-coherency protocols.</span></div><div><span style="line-height: 22px;"  >这个协议非常复制, 可能存在几十种交互状态, 这里只提4种状态. MESI(</span>modified,&nbsp;exclusive,&nbsp;shared,&nbsp;invalid<span style="line-height: 22px;"  >)</span></div><div><span style="line-height: 22px;"  ><div>Caches using this proto-col therefore maintain a two-bit state “tag” on each&nbsp;<span style="line-height: 22px;"  >cache line in addition to that lines physical address and data.</span></div></span></div><div style="line-height: 22px;"  >1. modified状态表示这个cache line存储了最新的数据(比主内存中的数据更新,换句话说这个数据在cache中被修改了), 同时其他CPU的cache中没有这部分数据. 同时这个数据如果要被修改, 不需要通知其他CPU, 因为其他CPU的CACHE中没有这部分数据. 最后当这个cache line需要被重用时, 必须先将数据flush到主内存.</div><div style="line-height: 22px;"  >2. exclusive与modified类似, 不同的是这个数据还没有被CPU修改. 所以<span style="line-height: 22px;"  >当这个cache line需要被重用时, 不需要将数据flush到主内存.</span></div><div style="line-height: 22px;"  >3. shared 状态表示该cache line可能在至少1个其他CPU的CACHE中, 所以不能在不通知其他CPU的情况下直接修改该cache line.</div><div style="line-height: 22px;"  >另外就是, 如果需要用到这个cache line, 那么可以直接丢弃这个cache line中的内容, 不需要flush到内存.</div><div style="line-height: 22px;"  >4. invalid 表示该cache line没有存储任何数据, 如果有新的数据需要写入cache, 那么写入invalid状态的cache line是最快捷的, 因为写入其他状态的cache line都需要排挤出它的内容, 导致cache miss.</div><div>CPU通过消息传递来变更这些状态. 如果多个CPU在单一的共享总线上, 那么需要用到以下消息就可以了 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >Read:&nbsp;</font></div><div><font size="2"  >&nbsp; The “read” message contains the physical address of the cache line to be read.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Read Response:&nbsp;</font></div><div><font size="2"  >&nbsp; The “read response” message contains the data requested by an earlier “read”message.&nbsp;</font></div><div><font size="2"  >&nbsp; This “read response” message might be supplied either by memory or by one of the other caches.&nbsp;</font></div><div><font size="2"  >&nbsp; For example, if one of the caches has the desired data in “modified” state, that cache must supply the “read response” message.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Invalidate:&nbsp;</font></div><div><font size="2"  >&nbsp; The “invalidate” message contains the physical address of the cache line to be invalidated.&nbsp;</font></div><div><font size="2"  >&nbsp; All other caches must remove the corresponding data from their caches and respond.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Invalidate Acknowledge:&nbsp;</font></div><div><font size="2"  >&nbsp; A CPU receiving an “invalidate” message must respond with an “invalidate acknowledge” message after removing the specified data from its cache.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Read Invalidate:&nbsp;</font></div><div><font size="2"  >&nbsp; The “read invalidate” message contains the physical address of the cache line to be read,&nbsp;</font></div><div><font size="2"  >&nbsp; while at the same time directing other caches to remove the data.&nbsp;</font></div><div><font size="2"  >&nbsp; Hence, it is a combination of a “read” and an “invalidate”, as indicated by its name.&nbsp;</font></div><div><font size="2"  >&nbsp; A “read invalidate” message requires both a “read response” and a set of “invalidate acknowledge” messages in reply.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Writeback:</font></div><div><font size="2"  >&nbsp; The “writeback” message contains both the address and the data to be written back to memory&nbsp;</font></div><div><font size="2"  >&nbsp; (and perhaps “snooped” into other CPUs ’ caches along the way).&nbsp;</font></div><div><font size="2"  >&nbsp; This message permits caches to eject lines in the “modified” state as needed to make room for other data.</font></div><p></p></pre></div><div>下图标示了4种状态的转变对应的消息 :&nbsp;</div><div>MESI State Diagram</div><div><div><img title="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img3.ph.126.net/MxbJQ54zjdQpzwRdWlDL4A==/6597150031007230533.jpg"  ></div>&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >M -&gt; E Transition (a): A cache line is written back to memory, but the CPU retains it in its cache and</font></div><div><font size="2"  >further retains the right to modify it. This transition requires a “writeback” message.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >E -&gt; M Transition (b): The CPU writes to the cache line that it already had exclusive access to.&nbsp;</font></div><div><font size="2"  >This transition does not require any messages to be sent or received.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >M -&gt; I Transition (c): The CPU receives a “read invalidate” message for a cache line that it has modified.&nbsp;</font></div><div><font size="2"  >The CPU must invalidate its local copy, then respond with both a “read response” and an</font></div><div><font size="2"  >“invalidate acknowledge” message, both sending the data to the requesting CPU and indicating</font></div><div><font size="2"  >that it no longer has a local copy.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >I -&gt; M Transition (d): The CPU does an atomic read-modify-write operation on a data item that was not present in its cache.&nbsp;</font></div><div><font size="2"  >It transmits a “read invalidate”, receiving the data via a “read response”.&nbsp;</font></div><div><font size="2"  >The CPU can complete the transition once it has also received a full set of “invalidate acknowledge” responses .</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >S -&gt; M Transition (e): The CPU does an atomic read-modify-write operation on a data item that was</font></div><div><font size="2"  >previously read-only in its cache. It must transmit “invalidate” messages ,</font></div><div><font size="2"  >and must wait for a full set of “invalidate acknowledge” responses before completing the transition.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >M -&gt; S Transition (f): Some other CPU reads the cache line, and it is supplied from this CPU’s cache,</font></div><div><font size="2"  >which retains a read-only copy, possibly also writing it back to memory.&nbsp;</font></div><div><font size="2"  >This transition is initiated by the reception of a “read” message,</font></div><div><font size="2"  >and this CPU responds with a “read response” message containing the requested data.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >E -&gt; S Transition (g): Some other CPU reads a data item in this cache line, and it is supplied either from</font></div><div><font size="2"  >this CPU’s cache or from memory. In either case, this CPU retains a read-only copy.&nbsp;</font></div><div><font size="2"  >This transition is initiated by the reception of a “read” message,&nbsp;</font></div><div><font size="2"  >and this CPU responds with a “read response” message containing the requested data.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >S -&gt; E Transition (h): This CPU realizes that it will soon need to write to some data item in this cache</font></div><div><font size="2"  >line, and thus transmits an “invalidate” message.</font></div><div><font size="2"  >The CPU cannot complete the transition until</font></div><div><font size="2"  >it receives a full set of “invalidate acknowledge” responses .&nbsp;</font></div><div><font size="2"  >Alter natively, all other CPUs eject this cache line from their caches via “writeback”</font></div><div><font size="2"  >messages (presumably to make room for other cache lines ),&nbsp;</font></div><div><font size="2"  >so that this CPU is the last CPU caching it.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >E -&gt; I Transition (i): Some other CPU does an atomic read-modify-write operation on a data item in a</font></div><div><font size="2"  >cache line held only in this CPU’s cache, so this</font></div><div><font size="2"  >CPU invalidates it from its cache. This transition is initiated by the reception of a “read invalidate” message,&nbsp;</font></div><div><font size="2"  >and this CPU responds with both a “read response” and an “invalidate acknowledge” message.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >I -&gt; E Transition (j): This CPU does a store to a data item in a cache line that was not in its cache,</font></div><div><font size="2"  >and thus transmits a “read invalidate” message.</font></div><div><font size="2"  >The CPU cannot complete the transition until it</font></div><div><font size="2"  >receives the “read response” and a full set of “invalidate acknowledge” messages .&nbsp;</font></div><div><font size="2"  >The cache line will presumably transition to “modified” state via transition (b) as soon as the actual store completes .</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >I -&gt; S Transition (k): This CPU loads a data item in a cache line that was not in its cache.&nbsp;</font></div><div><font size="2"  >The CPU transmits a “read” message, and completes</font></div><div><font size="2"  >the transition up on receiving the corresponding</font></div><div><font size="2"  >“read response”.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >S -&gt; I Transition (l): Some other CPU does a store to a</font></div><div><font size="2"  >data item in this cache line, but holds this cache</font></div><div><font size="2"  >line in read-only state due to its being held in</font></div><div><font size="2"  >other CPUs ’ caches (such as the current CPU’s cache).&nbsp;</font></div><div><font size="2"  >This transition is initiated by the reception of an “invalidate” message, and this CPU</font></div><div><font size="2"  >responds with an “invalidate acknowledge” message.</font></div></div><div></div><p></p></pre></div></div><div>下图是一个4个CPU的系统, 假设对地址为0和8的内存进行操作, 同时假设CPU CACHE只能存下1份数据(不能同时存下地址0和8的数据).&nbsp;</div><div>第一列是操作顺序, 第二列是操作的CPU, 第三列是操作内容, 第四列是CPU CACHE LINE的四个状态, 第五列是内存的状态(有效或者无效, 当CPU CACHE LINE是M状态时, 对应的内存数据无效).</div><div><div><img title="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img1.ph.126.net/wOmUM51h4dPIqYiR4B4H5Q==/6597761359471045021.jpg"  ></div>&nbsp;</div><div><span style="line-height: 22px;"  >RMW是read-modify-write的缩写.</span></div><div>对应的操作流程如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >0- Initially, the CPU cache lines in which the data would reside are in the “invalid” state,&nbsp;</font></div><div><font size="2"  >and the data is valid in memory.&nbsp;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >1- When CPU 0 loads the data at address 0, it enters the “shared” state in CPU 0’s cache,&nbsp;</font></div><div><font size="2"  >and is still valid in memory.&nbsp;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >2- CPU 3 also loads the data at address 0, so that it is in the “shared” state in both CPUs ’ caches ,&nbsp;</font></div><div><font size="2"  >and is still valid in memory.&nbsp;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >3- Next CPU 0 loads some other cache line (at address 8),&nbsp;</font></div><div><font size="2"  >which forces the data at address 0 out of its cache via an invalidation,&nbsp;</font></div><div><font size="2"  >replacing it with the data at address 8.&nbsp;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >4- CPU 2 now does a load from address 0,&nbsp;</font></div><div><font size="2"  >but this CPU realizes that it will so on need to store to it,&nbsp;</font></div><div><font size="2"  >and so it uses a “read invalidate” message in order to gain an exclusive copy,&nbsp;</font></div><div><font size="2"  >invalidating it from CPU 3’s cache (though the copy in memory remains up to date).&nbsp;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >5- Next CPU 2 does its anticipated store, changing the state to “modified”.&nbsp;</font></div><div><font size="2"  >The copy of the data in memory is now out of date.&nbsp;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >6- CPU 1 does an atomic increment,&nbsp;</font></div><div><font size="2"  >using a “read invalidate” to snoop the data from CPU 2’s cache and invalidate it,&nbsp;</font></div><div><font size="2"  >so that the copy in CPU 1’s cache is in the “modified” state</font></div><div><font size="2"  >(and the copy in memory remains out of date).&nbsp;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >7- Finally, CPU 1 reads the cache line at address 8,&nbsp;</font></div><div><font size="2"  >which uses a “writeback” message to push address 0’s data back out to memory.</font></div><p></p></pre></div><div>下面要讲讲首次CPU cache的存储或改写(store)带来的等待问题 :&nbsp;</div><div>需要等待的写CACHE line指的是cache line从I或者s的状态变成M.不管是从 I -&gt; M 还是 S -&gt; M.</div><div>都需要通知其他CPU, 发出invalidate信息. 等到所有的CPU都响应了invalidate Acknowledge后才可以修改该cache line.</div><div>如图 :&nbsp;</div><div><div><img title="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img4.ph.126.net/6vHBh80bQxr5I_AEOdG50w==/6597673398540823964.jpg"  ></div>从发出invalidate指令到写数据到cache line这个过程, CPU 0 需要等待.</div><div>为了解决这个等待的问题, 在CACHE和CPU之间加入了Store buffers区域. 以上操作CPU 0 不需要等待invalidate acknowledge, 可以直接先将数据写入store buffer区域.</div><div>如图 :&nbsp;</div><div><div><img title="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img2.ph.126.net/Bn0AaYqRM1pjJHE7jsKB8A==/6598168178773107602.jpg"  ></div>从图中来看, 写先经过Store Buffers, 最终写入cache.</div><div>读的话是直接从cache中读取的, 所以这里就存在一个问题了, 因为Store Buffers中的数据可能还没有写入cache, 因此可能读到的是老的cache, 而非修改后的数据. 例如一下代码 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1 a = 1;</font></div><div><font size="2"  >2 b = a + 1;</font></div><div><font size="2"  >3 assert(b == 2);</font></div><p></p></pre></div><div>执行过程以及本地内存顺序(或本地一致性)问题如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1. CPU 0 starts executing the a=1.</font></div><div><font size="2"  >2. CPU 0 looks “a” up in the cache, and finds that it is missing.</font></div><div><font size="2"  >3. CPU 0 therefore sends a “read invalidate” message in order to get exclusive ownership of the cache line containing “a”.</font></div><div><font size="2"  >4. CPU 0 records the store to “a” in its store buffer .</font></div><div><font size="2"  >5. CPU 1 receives the “read invalidate” message,&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;and responds by transmitting the cache line and removing that cache line from its cache.</font></div><div><font size="2"  >6. CPU 0 starts executing the b=a+1.</font></div><div><font size="2"  >7. CPU 0 receives the cache line from CPU 1, which still has a value of zero for “a”.</font></div><div><font size="2"  >-- 此时CPU 0 CACHE中 a=0, store buffer中 a=1;</font></div><div><font size="2"  >8. CPU 0 loads “a” from its cache, finding the value zero.</font></div><div><font size="2"  >-- 注意CPU 0执行 b=a+1时, 从CPU 0 CACHE中LOAD a的值, 所以取了0.</font></div><div><font size="2"  >9. CPU 0 applies the entry from its store queue to the newly arrived cache line,</font></div><div><font size="2"  >&nbsp; &nbsp;setting the value of “a” in its cache to one.</font></div><div><font size="2"  >-- CPU 0 将store buffer中的数据写入cache line. 但是已经晚了, b=a+1已经等于1了.</font></div><div><font size="2"  >10. CPU 0 adds one to the value zero loaded for “a” above,</font></div><div><font size="2"  >&nbsp; &nbsp; and stores it into the cache line containing “b”&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; (which we will assume is already owned by CPU 0).</font></div><div><font size="2"  >11. CPU 0 executes assert(b==2), which fails .</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >这个问题是通过Store Forwarding来解决的, 如下图 :&nbsp;</span></div><div><div><img title="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img5.ph.126.net/6GyFWKiUcdfHax0sCbOQ6w==/6597898798424524255.jpg"  ></div>当CPU执行LOAD指令时, 使用Store forwarding, CPU读取数据会从store buffer和cache line中读取.</div><div>所以不会发生前面遇到的从CACHE中LOAD了老数据的问题.</div><div>但是又带来了其他的问题 :&nbsp;</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1 void foo(void)</font></div><div><font size="2"  >2 {</font></div><div><font size="2"  >3 a = 1;</font></div><div><font size="2"  >4 b = 1;</font></div><div><font size="2"  >5 }</font></div><div><font size="2"  >6</font></div><div><font size="2"  >7 void bar(void)</font></div><div><font size="2"  >8 {</font></div><div><font size="2"  >9 while (b == 0) continue;</font></div><div><font size="2"  >10 assert(a == 1);</font></div><div><font size="2"  >11 }</font></div><p></p></pre></div><div>假设 :&nbsp;</div><div>1. a, b初始值为0,&nbsp;</div><div>2. CPU 0执行foo(), CPU 1执行bar(),</div><div>3. a在CPU 1的CACHE LINE中. b在CPU 0<span style="line-height: 22px;"  >的CACHE LINE中</span></div><div>执行过程<span style="line-height: 22px;"  >以及全局内存顺序(或全局一致性)问题如下 :&nbsp;</span></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1. CPU 0 executes a=1. The cache line is not in CPU 0’s cache,&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;so CPU 0 places the new value of “a” in its store buffer and transmits a “read invalidate” message.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >2. CPU 1 executes while (b==0) continue, but the cache line containing “b” is not in its cache.&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;It therefore transmits a “read” message.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >3. CPU 0 executes b=1. It already owns this cache line&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;(in other words , the cache line is already in either the “modified” or the “exclusive” state),</font></div><div><font size="2"  >&nbsp; &nbsp;so it stores the new value of “b” in its cache line.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >4. CPU 0 receives the “read” message, and transmits the cache line containing the now-updated value of “b” to CPU 1,&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;also marking the line as “shared” in its own cache.</font></div><div><font size="2"  > </font></div><div><font size="2"  >5. CPU 1 receives the cache line containing “b” and installs it in its cache.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >6. CPU 1 can now finish executing while (b==0) continue,&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;and since it finds that the value of “b” is 1, it proceeds to the next statement.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >7. CPU 1 executes the assert(a==1), and,&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;since CPU 1 is working with the old value of “a”,&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;this assertion fails .</font></div><div><font size="2"  >-- 此时CPU 0 已经将a的值改为1了, 但是CPU 1显然还不知道, 因为还没有收到read invalidate消息. 所以出现了问题.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >8. CPU 1 receives the “read invalidate” message,</font></div><div><font size="2"  >&nbsp; &nbsp;and transmits the cache line containing “a” to CPU 0 and invalidates this cache line from its own cache.&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;But it is too late.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >9. CPU 0 receives the cache line containing “a” and applies the buffered store just in time to&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;fall victim to CPU 1’s failed assertion.</font></div><p></p></pre></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >硬件无法直接解决这个问题, 需要用到CPU的memory barrier指令, 如下 :&nbsp;</span></div></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1 void foo(void)</font></div><div><font size="2"  >2 {</font></div><div><font size="2"  >3 a = 1;</font></div><div><font size="2"  >4 smp_mb();</font></div><div><font size="2"  >5 b = 1;</font></div><div><font size="2"  >6 }</font></div><div><font size="2"  >7</font></div><div><font size="2"  >8 void bar(void)</font></div><div><font size="2"  >9 {</font></div><div><font size="2"  >10 while (b == 0) continue;</font></div><div><font size="2"  >11 assert(a == 1);</font></div><div><font size="2"  >12 }</font></div><p></p></pre></div><div>smp_mb()的作用是, 当CPU需要写数据到cache line时, 必须先确保在这个写操作以前的store buffers中的数据已经全部flush.</div><div>有两种方法达到这个目的 :&nbsp;</div><div>1. &nbsp;CPU等store buffer清空.</div><div>2. &nbsp;CPU 不等待store buffer清空, 而是使用store buffer来保持后续的cache line写操作, 直到store buffers中前面的部分全部flush. 所以前面的store buffer必须有个标示.</div><div>下面以方法2为例描述以下上面代码的操作流程 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1. CPU 0 executes a=1. The cache line is not in CPU 0’s cache, so CPU 0 places the new value</font></div><div><font size="2"  >&nbsp; &nbsp;of “a” in its store buffer and transmits a “read invalidate” message.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >2. CPU 1 executes while (b==0) continue, but the cache line containing “b” is not in its cache.&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;It therefore transmits a “read” message.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >3. CPU 0 executes smp_mb(), and marks all current store buffer entries (namely, the a=1 ).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >4. CPU 0 executes b=1. It already owns this cache line&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;(in other words , the cache line is already in either the “modified” or the “exclusive” state),</font></div><div><font size="2"  >&nbsp; &nbsp;but there is a marked entry in the store buffer .</font></div><div><font size="2"  >&nbsp; &nbsp;Therefore, rather than store the new value of “b” in the cache line,&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;it instead places it in the store buffer (but in an unmarked entry).</font></div><div><font size="2"  >-- 注意由于b=1在smp_mb()后面, 所以CPU 0 必须先清理掉store buffer的内容, 才能写cache line.&nbsp;</font></div><div><font size="2"  >-- 或则使用方法2, 对store buffer中的内容作标记, 然后继续使用store buffer存储b的内容(不做标记), 而不是写cache line.</font></div><div><font size="2"  >-- 所以此时b 在CPU 0 cache中=0, 在store buffer中=1.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >5. CPU 0 receives the “read” message, and transmits the cache line containing the original value of “b” to CPU 1.&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;It also marks its own copy of this cache line as “shared”.</font></div><div><font size="2"  >-- 注意读的是cache line中的b=0. 而不是store buffer中的b=1. 为什么没有使用Store forward呢?</font></div><div><font size="2"  >-- 和smp_mb()有关, b=1在store buffer中未被标记, 所以被略过.</font></div><div><font size="2"  >-- 同时由于CPU 1请求了b的数据, 所以CPU 0 需要将cache line中b的数据标记为shared状态.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >6. CPU 1 receives the cache line containing “b” and installs it in its cache.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >7. CPU 1 can now finish executing while (b==0) continue,&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;but since it finds that the value of “b” is still 0, it repeats the while statement.</font></div><div><font size="2"  >&nbsp; &nbsp;The new value of “b” is safely hidden in CPU 0’s store buffer .</font></div><div><font size="2"  >-- CPU 0 的store buffer中b=1被隐藏了.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >8. CPU 1 receives the “read invalidate” message,</font></div><div><font size="2"  >&nbsp; &nbsp;and transmits the cache line containing “a” to</font></div><div><font size="2"  >&nbsp; &nbsp;CPU 0 and invalidates this cache line from its own cache.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >9. CPU 0 receives the cache line containing “a” and applies the buffered store,&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;placing this line into the “modified” state.</font></div><div><font size="2"  >-- 由于store buffer中a被标记, 接收到read response后需要将标记了的a写入cache line.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >10. Since the store to “a” was the only entry in the</font></div><div><font size="2"  >&nbsp; &nbsp; store buffer that was marked by the smp_mb(),</font></div><div><font size="2"  >&nbsp; &nbsp; CPU 0 can also store the new value of “b” ―</font></div><div><font size="2"  >&nbsp; &nbsp; except for the fact that the cache line containing</font></div><div><font size="2"  >&nbsp; &nbsp; “b” is now in “shared” state.</font></div><div><font size="2"  >-- 因为store buffer中被标记的数据已经全部flush了, 所以未被标记的b也可以写入cache line,&nbsp;</font></div><div><font size="2"  >-- 除非cache line中已经存在b的数据并且被标记为shared了. (shared的数据须先通知其他CPU, invalidate ack后才能写入)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >11. CPU 0 therefore sends an “invalidate” message to CPU 1.</font></div><div><font size="2"  >-- 这里就是为了将store buffer中的b写入cache line(已经含有状态为shared 的b 数据项), 所以需要发出invalidate消息.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >12. CPU 1 receives the “invalidate” message, invalidates the cache line containing “b” from its</font></div><div><font size="2"  >&nbsp; &nbsp; cache, and sends an “acknowledgement” message to CPU 0.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >13. CPU 1 executes while (b==0) continue, but the</font></div><div><font size="2"  >&nbsp; &nbsp; cache line containing “b” is not in its cache. It</font></div><div><font size="2"  >&nbsp; &nbsp; therefore transmits a “read” message to CPU 0.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >14. CPU 0 receives the “acknowledgement” message,</font></div><div><font size="2"  >&nbsp; &nbsp; and puts the cache line containing “b” into the</font></div><div><font size="2"  >&nbsp; &nbsp; “exclusive” state. CPU 0 now stores the new</font></div><div><font size="2"  >&nbsp; &nbsp; value of “b” into the cache line.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >15. CPU 0 receives the “read” message, and transmits the cache line containing the new value of</font></div><div><font size="2"  >&nbsp; &nbsp; “b” to CPU 1. It also marks its own copy of this</font></div><div><font size="2"  >&nbsp; &nbsp; cache line as “shared”.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >16. CPU 1 receives the cache line containing “b” and</font></div><div><font size="2"  >&nbsp; &nbsp; installs it in its cache.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >17. CPU 1 can now finish executing while (b==0) continue, and since it finds that the value of</font></div><div><font size="2"  >&nbsp; &nbsp; “b” is 1, it proceeds to the next statement.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >18. CPU 1 executes the assert (a==1), but the</font></div><div><font size="2"  >&nbsp; &nbsp; cache line containing “a” is no longer in its cache.</font></div><div><font size="2"  >&nbsp; &nbsp; Once it gets this cache from CPU 0, it will be working with the up-to-date value of “a”, and</font></div><div><font size="2"  >&nbsp; &nbsp; the assertion therefore passes .</font></div><p></p></pre></div><div>使用smp_mb()确保这个指令的前面的store指令生效后面的指令才会生效. 不会出现紊乱现象.</div><div>就如上例, 不会出现b=1已经生效了但是a=1还没有生效.</div><div><br></div><div>接下来要引入invalidate queue. 原因是 :&nbsp;</div><div>1. 因为store buffer的容量是有限的, 所以如果每次store的操作都是cache miss或者cache line的状态是shared的话, 那么当store buffer满了后还是需要等待其他CPU的invalidate ack的. 这样很快CPU又会陷入等待中.</div><div>2. 当使用了memory barrier后, barrier后面的store指令必须等待前面的store指令完成(也就是前面提到的方法1, 需要等待invalidate ack, 然后flush).</div><div>要解决这个性能问题, 主要是让invalidate message更快的响应, 因此引入了invalidate queue.</div><div>其中一种方法是每个CPU对应各自的invalidate message queue. 解决两个问题.</div><div>1. invalidate操作要将cache line真正清空后才能返回invalidate ack message. 所以对于一个CACHE繁忙的CPU这个操作延时是比较大的.</div><div>2. 另外, 短时间内收到大量的invalidate操作对执行invalidate操作的CPU来说也是比较大的挑战, 可能使得该CPU无法跟上其他CPU的节奏.</div><div>使用了invalidate message queue后,</div><div>1. 在CPU收到invalide message后, 将这个消息以及cache line的HASH值记录到QUEUE中.</div><div>2. 返回invalidate ack message. 所以这里就非常快捷了, 因为不需要等待invalidate cache line操作完成.</div><div>3. 由于invalidate queue中对应的cache line以及标记为invalidate了, 所以后续相关的操作就需要等待invalidate操作完成了.</div><div>如图 :&nbsp;</div><div><div><img title="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img9.ph.126.net/OrQ3sJX6srikGwbrkooo9w==/6597796543843144369.jpg"  ></div>&nbsp;</div><div>但是Invalidate queue的引入打破了memory barrier的功能, 带来如下问题 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1 void foo(void)</font></div><div><font size="2"  >2 {</font></div><div><font size="2"  >3 a = 1;</font></div><div><font size="2"  >4 smp_mb();</font></div><div><font size="2"  >5 b = 1;</font></div><div><font size="2"  >6 }</font></div><div><font size="2"  >7</font></div><div><font size="2"  >8 void bar(void)</font></div><div><font size="2"  >9 {</font></div><div><font size="2"  >10 while (b == 0) continue;</font></div><div><font size="2"  >11 assert(a == 1);</font></div><div><font size="2"  >12 }</font></div><p></p></pre></div><div>假设 :&nbsp;</div><div>1. a, b初始值为0</div><div>2. a 在CPU 0和CPU 1的cache line中, 标记为shared状态.</div><div>3. b 在CPU 0<span style="line-height: 22px;"  >的cache line中, 标记为exclusive或modified状态.</span></div><div>4. CPU 0执行foo(), CPU 1执行bar().</div><div>执行过程以及暴露出的内存全局一致性问题如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1. CPU 0 executes a=1. The corresponding cache line is read-only in CPU 0’s cache,&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;so CPU 0 places the new value of “a” in its store buffer and transmits an “invalidate” message&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;in order to flush the corresponding cache line from CPU 1’s cache.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >2. CPU 1 executes while (b==0) continue, but the</font></div><div><font size="2"  >&nbsp; &nbsp;cache line containing “b” is not in its cache.&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;It therefore transmits a “read” message.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >3. CPU 1 receives CPU 0’s “invalidate” message,</font></div><div><font size="2"  >&nbsp; &nbsp;queues it, and immediately responds to it.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >4. CPU 0 receives the response from CPU 1, and is</font></div><div><font size="2"  >&nbsp; &nbsp;therefore free to proceed past the smp_mb() on</font></div><div><font size="2"  >&nbsp; &nbsp;line 4 above, moving the value of “a” from its</font></div><div><font size="2"  >&nbsp; &nbsp;store buffer to its cache line.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >5. CPU 0 executes b=1. It already owns this cache</font></div><div><font size="2"  >&nbsp; &nbsp;line (in other words , the cache line is already in</font></div><div><font size="2"  >&nbsp; &nbsp;either the “modified” or the “exclusive” state),</font></div><div><font size="2"  >&nbsp; &nbsp;so it stores the new value of “b” in its cache line.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >6. CPU 0 receives the “read” message, and transmits the cache line containing the now-updated</font></div><div><font size="2"  >&nbsp; &nbsp;value of “b” to CPU 1, also marking the line as</font></div><div><font size="2"  >&nbsp; &nbsp;“shared” in its own cache.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >7. CPU 1 receives the cache line containing “b” and</font></div><div><font size="2"  >&nbsp; &nbsp;installs it in its cache.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >8. CPU 1 can now finish executing while (b==0) continue,&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;and since it finds that the value of</font></div><div><font size="2"  >&nbsp; &nbsp;“b” is 1, it proceeds to the next statement.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >9. CPU 1 executes the assert(a==1), and, since</font></div><div><font size="2"  >&nbsp; &nbsp;the old value of “a” is still in CPU 1’s cache,</font></div><div><font size="2"  >&nbsp; &nbsp;this assertion fails .</font></div><div><font size="2"  >-- 由于使用了invalidate queue, 实际上a=0的数据还在CPU 1的cache line中.</font></div><div><font size="2"  >-- 所以LOAD时, 出现了问题.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >10. Despite the assertion failure, CPU 1 processes</font></div><div><font size="2"  >&nbsp; &nbsp; the queued “invalidate” message, and (tardily)</font></div><div><font size="2"  >&nbsp; &nbsp; invalidates the cache line containing “a” from its own cache.</font></div><p></p></pre></div><div>要解决这个问题还是要用到barrier. 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1 void foo(void)</font></div><div><font size="2"  >2 {</font></div><div><font size="2"  >3 a = 1;</font></div><div><font size="2"  >4 smp_mb();</font></div><div><font size="2"  >5 b = 1;</font></div><div><font size="2"  >6 }</font></div><div><font size="2"  >7</font></div><div><font size="2"  >8 void bar(void)</font></div><div><font size="2"  >9 {</font></div><div><font size="2"  >10 while (b == 0) continue;</font></div><div><font size="2"  >11 smp_mb();</font></div><div><font size="2"  >12 assert(a == 1);</font></div><div><font size="2"  >13 }</font></div><p></p></pre></div><div>假设的场景与上例一致, 执行过程如下 :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1. CPU 0 executes a=1. The corresponding cache</font></div><div><font size="2"  >line is read-only in CPU 0’s cache, so CPU 0</font></div><div><font size="2"  >places the new value of “a” in its store buffer and</font></div><div><font size="2"  >transmits an “invalidate” message in order to</font></div><div><font size="2"  >flush the corresponding cache line from CPU 1’s</font></div><div><font size="2"  >cache.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >2. CPU 1 executes while (b==0) continue, but the</font></div><div><font size="2"  >cache line containing “b” is not in its cache. It</font></div><div><font size="2"  >therefore transmits a “read” message.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >3. CPU 1 receives CPU 0’s “invalidate” message,</font></div><div><font size="2"  >queues it, and immediately responds to it.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >4. CPU 0 receives the response from CPU 1, and is</font></div><div><font size="2"  >therefore free to proceed past the smp_mb() on</font></div><div><font size="2"  >line 4 above, moving the value of “a” from its</font></div><div><font size="2"  >store buffer to its cache line.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >5. CPU 0 executes b=1. It already owns this cache</font></div><div><font size="2"  >line (in other words , the cache line is already in</font></div><div><font size="2"  >either the “modified” or the “exclusive” state),</font></div><div><font size="2"  >so it stores the new value of “b” in its cache line.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >6. CPU 0 receives the “read” message, and transmits&nbsp;</font></div><div><font size="2"  >the cache line containing the now-updated</font></div><div><font size="2"  >value of “b” to CPU 1, also marking the line as</font></div><div><font size="2"  >“shared” in its own cache.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >7. CPU 1 receives the cache line containing “b” and</font></div><div><font size="2"  >installs it in its cache.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >8. CPU 1 can now finish executing while (b==0) continue,&nbsp;</font></div><div><font size="2"  >and since it finds that the value of “b”</font></div><div><font size="2"  >is 1, it proceeds to the next statement, which is</font></div><div><font size="2"  >now a memory barrier .</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >9. CPU 1 must now stall until it processes all pre-existing messages in its invalidation queue.</font></div><div><font size="2"  >-- memory barrier在CPU 1这里起到的作用是等待处理完所有的invalidate queue messages. 因为CPU 1 没有用到store buffer.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >10. CPU 1 now processes the queued “invalidate”</font></div><div><font size="2"  >message, and invalidates the cache line containing “a” from its own cache.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >11. CPU 1 executes the assert(a==1), and, since</font></div><div><font size="2"  >the cache line containing “a” is no longer in</font></div><div><font size="2"  >CPU 1’s cache, it transmits a “read” message.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >12. CPU 0 responds to this “read” message with the</font></div><div><font size="2"  >cache line containing the new value of “a”.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >13. CPU 1 receives this cache line, which contains a</font></div><div><font size="2"  >value of 1 for “a”, so that the assertion does not trigger .</font></div><p></p></pre></div><div>从上面的例子可以知道, memory barrier不仅仅解决了store buffer带来的全局内存顺序问题, 同时也可以解决invalidate queue带来的全局内存顺序问题.</div></div><div>但是在上面提到的例子中, foo()函数不会使用到invalidate queue, 而bar()函数不会使用到store buffer.</div><div>从而某些CPU提供了更弱的(影响更小的)barrier指令, read barrier和write barrier指令. 分别用来解决invalidate queue和 store buffer带来的全局内存(一致性)顺序问题.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; The effect of this is that a read memory barrier orders only loads on the CPU that executes it,&nbsp;</font></div><div><font size="2"  >so that all loads preceding the read memory barrier will appear to have completed before&nbsp;</font></div><div><font size="2"  >any load following the read memory barrier .&nbsp;</font></div><div><font size="2"  >&nbsp; Similarly, a write memory barrier orders only stores , again on the CPU that executes it,&nbsp;</font></div><div><font size="2"  >and again so that all stores preceding the write memory barrier will appear to&nbsp;</font></div><div><font size="2"  >have completed before any store following the write memory barrier .&nbsp;</font></div><div><font size="2"  >&nbsp; A full-fledged memory barrier orders both</font></div><div><font size="2"  >loads and stores , but again only on the CPU execut-ing the memory barrier .</font></div><p></p></pre></div><div>因此以上代码可以修改如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1 void foo(void)</font></div><div><font size="2"  >2 {</font></div><div><font size="2"  >3 a = 1;</font></div><div><font size="2"  >4 smp_wmb();</font></div><div><font size="2"  >5 b = 1;</font></div><div><font size="2"  >6 }</font></div><div><font size="2"  >7</font></div><div><font size="2"  >8 void bar(void)</font></div><div><font size="2"  >9 {</font></div><div><font size="2"  >10 while (b == 0) continue;</font></div><div><font size="2"  >11 smp_rmb();</font></div><div><font size="2"  >12 assert(a == 1);</font></div><div><font size="2"  >13 }</font></div><p></p></pre></div><div><br></div><div>【词汇】</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1. CPU CACHE</font></div><div><font size="2"  >2. cache line</font></div><div><font size="2"  >3. MESI</font></div><div><font size="2"  >4. store buffer</font></div><div><font size="2"  >5. store buffer forward</font></div><div><font size="2"  >6. invalidate queue</font></div><div><font size="2"  >7. memory barrier</font></div><div><font size="2"  >8. read barrier</font></div><div><font size="2"  >9. write barrier</font></div><div><font size="2"  >10. compiler barrier</font></div><p></p></pre></div>&nbsp;</div></div>【参考】<div>1. Linux Kernel<br><div>&nbsp; &nbsp; Documentation/memory-barriers.txt</div><div>2.&nbsp;src/include/storage/barrier.h</div><div>3.&nbsp;src/backend/storage/lmgr/README.barrier</div><div>4. PostgreSQL backend work process</div><div>5.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Memory_barrier"  >http://en.wikipedia.org/wiki/Memory_barrier</a></div><div>6.&nbsp;<a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Memory_ordering"  >http://en.wikipedia.org/wiki/Memory_ordering</a></div><div>7.&nbsp;<a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Out-of-order_execution"  >http://en.wikipedia.org/wiki/Out-of-order_execution</a></div><div>8.&nbsp;<a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Memory_model_(programming)"  >http://en.wikipedia.org/wiki/Memory_model_(programming)</a></div><div>9.&nbsp;<a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Shared_memory"  >http://en.wikipedia.org/wiki/Shared_memory</a></div><div>10.&nbsp;<a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Consistency_model"  >http://en.wikipedia.org/wiki/Consistency_model</a></div><div>11.&nbsp;<a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Java_Memory_Model"  >http://en.wikipedia.org/wiki/Java_Memory_Model</a></div><div>12.&nbsp;<a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/C11_(C_standard_revision)"  >http://en.wikipedia.org/wiki/C11_(C_standard_revision)</a></div><div>13.&nbsp;<a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/CPU_cache"  >http://en.wikipedia.org/wiki/CPU_cache</a></div><div>14.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://blogs.sourceallies.com/2012/03/parallel-programming-with-barrier-synchronization/"  >http://blogs.sourceallies.com/2012/03/parallel-programming-with-barrier-synchronization/</a></div><div>15.&nbsp;<a target="_blank" rel="nofollow" href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf"  >http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf</a><br>16.&nbsp;<wbr><a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Lock_(computer_science)"  >http://en.wikipedia.org/wiki/Lock_(computer_science)</a></div></div><div>17.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Spinlock"  >http://en.wikipedia.org/wiki/Spinlock</a></div><div>18.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/xfunc-c.html"  >http://www.postgresql.org/docs/9.2/static/xfunc-c.html</a></div><div>19.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/dynamic-trace.html"  >http://www.postgresql.org/docs/9.2/static/dynamic-trace.html</a></div><div>20.&nbsp;src/include/storage/lwlock.h</div><div>21.&nbsp;src/include/storage/spin.h</div><div>22.&nbsp;<a target="_blank" rel="nofollow" href="http://sstompkins.wordpress.com/2011/04/12/why-memory-barrier%EF%BC%9F/"  >http://sstompkins.wordpress.com/2011/04/12/why-memory-barrier%EF%BC%9F/</a></div><div>23. Intel? 64 and IA-32 Architectures Software Developer’s Manual</div><div>&nbsp; &nbsp; &nbsp;&nbsp;<a target="_blank" rel="nofollow" href="http://download.intel.com/products/processor/manual/325462.pdf"  >http://download.intel.com/products/processor/manual/325462.pdf</a></div><div><img title="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL memory barrier defined but not used yet - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img9.ph.126.net/s8lZFhm0SYdjwTtvfpD6Gw==/6597596432726885959.jpg"  ></div>24.&nbsp;<div><span style="line-height: 22px;"  >《Handling Memory Ordering in Multithreaded Applications with Oracle Solaris Studio 12 Update 2》</span><div>Part 1, Compiler Barriers</div><span style="line-height: 22px;"  >Part 2, Memory Barriers and Memory Fences</span>&nbsp;<div><br></div></div></div>
	</div>
</div>
</body>
</html>