<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap EXP: PostgreSQL IN-BUILD mark Class 4 - buffer</h2>
	<h5 id="">2013-10-16 17:30:07&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013916488761/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>本文开始讲PostgreSQL内建探针的另一个分类, buffer.</div><div>buffer分类探针中包含:&nbsp;</div><div>1. buffer读开始, 结束;&nbsp;</div><div>2. shared buffer flush开始, 结束(结束点指将数据交付到内核, 并非磁盘, 所以如果要计算flush时间的话, 这个探针不合适)(在FlushBuffer函数中触发)(包含了所有的shared buffer flushed out)</div><div>3. dirty&nbsp;<span style="line-height: 28px;"   >shared buffer flush开始, 结束(在</span>BufferAlloc函数中触发, 所以和shared buffer大小有关, 如果很频繁, 说明shared buffer太小,至于要flush掉dirty的buffer才能分配出空间给其他进程使用. 或者要提高bgwriter的唤醒频率<span style="line-height: 28px;"   >)</span></div><div><span style="line-height: 28px;"   >实际上是调用了FlushBuffer函数.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* OK, do the I/O */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_START(forkNum, blockNum,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;smgr-&gt;smgr_rnode.node.spcNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smgr-&gt;smgr_rnode.node.dbNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smgr-&gt;smgr_rnode.node.relNode);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FlushBuffer(buf, NULL);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(buf-&gt;content_lock);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_DONE(forkNum, blockNum,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;smgr-&gt;smgr_rnode.node.spcNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smgr-&gt;smgr_rnode.node.dbNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smgr-&gt;smgr_rnode.node.relNode);</font></div><p></p></pre></div><div>4. dirty wal buffer flush开始, 结束. (如果太过频繁, 说明需要加大wal_buffers参数的值)</div><div><br></div><div>从这些buffer探针中, 可以得到哪些信息呢?</div><div>1. 读buffer开始, 变量包含 forkNUM() , blockid, 表空间oid, 数据库oid, relation的relfilenode(pg_class.relfilenode); backend_id(表示写入local buffer)或-1(表示写入shared buffer). 用true,false区分扩展文件请求和普通读请求.</div><div>2.&nbsp;<span style="line-height: 28px;"   >读buffer完成, 变量和读开始一样, 但是多了一个bool变量(found), 判断是否从shared pool中读取(即命中shared buffer).</span></div><div>found变量:&nbsp;</div><div><pre class="prettyprint"   ><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (found)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgBufferUsage.local_blks_hit++;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgBufferUsage.local_blks_read++;</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (found)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgBufferUsage.shared_blks_hit++;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgBufferUsage.shared_blks_read++;</font></div></div><p></p></pre></div><div><div><span style="line-height: 28px;"   >3.&nbsp;</span><span style="line-height: 28px;"   >shared buffer flush开始, 结束; 探针中可以得到</span><span style="line-height: 28px;"   >&nbsp;</span>forkNUM() , blockid, 表空间oid, 数据库oid, relation的relfilenode(pg_class.relfilenode);</div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >每flush一个块都会触发.</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >4.&nbsp;</span><span style="line-height: 28px;"   >dirty&nbsp;</span><span style="line-height: 28px;"   >shared buffer flush开始, 结束; 同上(</span><span style="line-height: 28px;"   >shared buffer flush</span><span style="line-height: 28px;"   >).</span></div></div><div><br></div><div><span style="line-height: 28px;"   >接下来</span><span style="line-height: 28px;"   >简单的介绍一下</span><span style="line-height: 28px;"   >buffer相关探针中的变量类型 :</span></div><div>1. ForkNumber</div><div>枚举类型, 用于表示该物理存储的类别, 例如是主存储, 还是fsm或者vm, 或者init(nologging表特有).</div><div>(nologging init参考</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201382341433512/"   >http://blog.163.com/digoal@126/blog/static/163877040201382341433512/</a>&nbsp;)</div><div>src/include/storage/relfilenode.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* The physical storage of a relation consists of one or more forks. The</font></div><div><font size="2"   >&nbsp;* main fork is always created, but in addition to that there can be</font></div><div><font size="2"   >&nbsp;* additional forks for storing various metadata. ForkNumber is used when</font></div><div><font size="2"   >&nbsp;* we need to refer to a specific fork in a relation.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef enum ForkNumber</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; InvalidForkNumber = -1,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; MAIN_FORKNUM = 0,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FSM_FORKNUM,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; VISIBILITYMAP_FORKNUM,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; INIT_FORKNUM</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* NOTE: if you add a new fork, change MAX_FORKNUM below and update the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* forkNames array in src/common/relpath.c</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >} ForkNumber;</font></div><p></p></pre></div><div>2.&nbsp;<span style="line-height: 28px;"   >BlockNumber</span></div><div>数据文件中的block id.</div><div>src/include/storage/block.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* BlockNumber:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* each data file (heap or index) is divided into postgres disk blocks</font></div><div><font size="2"   >&nbsp;* (which may be thought of as the unit of i/o -- a postgres buffer</font></div><div><font size="2"   >&nbsp;* contains exactly one disk block). &nbsp;the blocks are numbered</font></div><div><font size="2"   >&nbsp;* sequentially, 0 to 0xFFFFFFFE.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* InvalidBlockNumber is the same thing as P_NEW in buf.h.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* the access methods, the buffer manager and the storage manager are</font></div><div><font size="2"   >&nbsp;* more or less the only pieces of code that should be accessing disk</font></div><div><font size="2"   >&nbsp;* blocks directly.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef uint32 BlockNumber;</font></div><p></p></pre></div><div>3. 数据库, 表空间, 以及relation 的oid.</div><div>其实就是pg_database.oid, pg_tablespace.oid, pg_class.relfilenode.</div><div><br></div><div>探针详细介绍 :&nbsp;</div><div><table border="1"   style="margin: 2ex 0px 2ex 2ex; -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border-spacing: 0px; border-collapse: collapse; background-color: rgb(224, 236, 239); border: 2px solid rgb(167, 198, 223); color: rgb(0, 0, 0); font-family: verdana, sans-serif; font-size: 13.333333969116211px; line-height: normal;"   ><tbody><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >buffer-read-start</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when a buffer read is started. arg0 and arg1 contain the fork and block numbers of the page (but arg1 will be -1 if this is a relation extension request). arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or InvalidBackendId (-1) for a shared buffer. arg6 is true for a relation extension request, false for normal read.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >buffer-read-done</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when a buffer read is complete. arg0 and arg1 contain the fork and block numbers of the page (if this is a relation extension request, arg1 now contains the block number of the newly added block). arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or InvalidBackendId (-1) for a shared buffer. arg6 is true for a relation extension request, false for normal read. arg7 is true if the buffer was found in the pool, false if not.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >buffer-flush-start</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(ForkNumber, BlockNumber, Oid, Oid, Oid)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires before issuing any write request for a shared buffer. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >buffer-flush-done</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(ForkNumber, BlockNumber, Oid, Oid, Oid)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when a write request is complete. (Note that this just reflects the time to pass the data to the kernel; it's typically not actually been written to disk yet.) The arguments are the same as for buffer-flush-start.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >buffer-write-dirty-start</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >(ForkNumber, BlockNumber, Oid, Oid, Oid)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >Probe that fires when a server process begins to write a dirty buffer. (If this happens often, it implies that&nbsp;<a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/runtime-config-resource.html#GUC-SHARED-BUFFERS"   >shared_buffers</a>&nbsp;is too small or the bgwriter control parameters need adjustment.) arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >buffer-write-dirty-done</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(ForkNumber, BlockNumber, Oid, Oid, Oid)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when a dirty-buffer write is complete. The arguments are the same as for buffer-write-dirty-start.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >wal-buffer-write-dirty-start</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >()</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when a server process begins to write a dirty WAL buffer because no more WAL buffer space is available. (If this happens often, it implies that&nbsp;<a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/runtime-config-wal.html#GUC-WAL-BUFFERS"   >wal_buffers</a>&nbsp;is too small.)</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >wal-buffer-write-dirty-done</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >()</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when a dirty WAL buffer write is complete.</td></tr></table></div><div><br></div><div>buffer相关的探针一般可以用于收集哪些信息呢?</div><div>1. buffer 读取的时间消耗, 数据量, 命中率等. 可以结合其他probe例如query probe, 得到单个sql的buffer &nbsp;读的详细信息.</div><div>2. dirty buffer flush在整个buffer flush中的占比. 也可以结合其他probe&nbsp;<span style="line-height: 28px;"   >例如query probe一起使用.</span></div><div>3. dirty wal buffer的频度信息.</div><div>例子 :&nbsp;</div><div>统计单SQL的buffer读, 分别统计命中shared buffer和未命中shared buffer.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >stap -e '</font></div><div><font size="2"   >global var;</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__start") {</font></div><div><font size="2"   >&nbsp; var[pid(),0]=0</font></div><div><font size="2"   >&nbsp; var[pid(),1]=0</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("buffer__read__done") {</font></div><div><font size="2"   >&nbsp; if ($arg8)</font></div><div><font size="2"   >&nbsp; &nbsp; var[pid(),1]++</font></div><div><font size="2"   >&nbsp; if (! $arg8)</font></div><div><font size="2"   >&nbsp; &nbsp; var[pid(),0]++</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__done") {</font></div><div><font size="2"   >&nbsp; printf("query: %s\n", user_string($arg1))</font></div><div><font size="2"   >&nbsp; printf("shared buffer hit: %d\n", var[pid(),1])</font></div><div><font size="2"   >&nbsp; printf("shared buffer nonhit: %d\n", var[pid(),0])</font></div><div><font size="2"   >}'</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >SQL :&nbsp;</span></div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain (analyze,verbose,costs,buffers,timing) select count(*) from test where id&lt;100;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >-</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=92.21..92.22 rows=1 width=0) (actual time=9.951..9.952 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: count(*)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=102 dirtied=54</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using test_pkey on public.test &nbsp;(cost=0.43..91.99 rows=89 width=0) (actual time=0.065..9.917 rows=96 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (test.id &lt; 100)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heap Fetches: 98</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=102 dirtied=54</font></div><div><font size="2"   >&nbsp;Total runtime: 10.026 ms</font></div><div><font size="2"   >(9 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# explain (analyze,verbose,costs,buffers,timing) select count(*) from test where id&lt;1000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >-----</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=910.33..910.34 rows=1 width=0) (actual time=79.756..79.756 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: count(*)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=980 dirtied=554</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using test_pkey on public.test &nbsp;(cost=0.43..908.09 rows=896 width=0) (actual time=0.032..79.419 rows=944 loop</font></div><div><font size="2"   >s=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (test.id &lt; 1000)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heap Fetches: 972</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=980 dirtied=554</font></div><div><font size="2"   >&nbsp;Total runtime: 79.809 ms</font></div><div><font size="2"   >(9 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# explain (analyze,verbose,costs,buffers,timing) select count(*) from test ;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=106075.99..106076.00 rows=1 width=0) (actual time=5286.628..5286.628 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: count(*)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=47319 dirtied=28389</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.test &nbsp;(cost=0.00..94324.59 rows=4700559 width=0) (actual time=0.113..4606.995 rows=4676559 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, info, crt_time</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=47319 dirtied=28389</font></div><div><font size="2"   >&nbsp;Total runtime: 5286.727 ms</font></div><div><font size="2"   >(7 rows)</font></div><p></p></pre></div><div>stap 输出 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >query: explain (analyze,verbose,costs,buffers,timing) select count(*) from test where id&lt;100;</font></div><div><font size="2"   >shared buffer hit: 202</font></div><div><font size="2"   >shared buffer nonhit: 1</font></div><div><font size="2"   >query: explain (analyze,verbose,costs,buffers,timing) select count(*) from test where id&lt;1000;</font></div><div><font size="2"   >shared buffer hit: 984</font></div><div><font size="2"   >shared buffer nonhit: 0</font></div><div><font size="2"   >query: explain (analyze,verbose,costs,buffers,timing) select count(*) from test ;</font></div><div><font size="2"   >shared buffer hit: 47321</font></div><div><font size="2"   >shared buffer nonhit: 0</font></div><p></p></pre></div><div><br></div><div>[其他]</div><div>1. 其实很多统计信息在一些系统表中就可以看到, 例如表的buffer hit信息在statio表就可以查看到, 如下 .</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# select pg_stat_reset();</font></div><div><font size="2"   >&nbsp;pg_stat_reset&nbsp;</font></div><div><font size="2"   >---------------</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=# select * from pg_statio_all_tables where relid='t1'::regclass;</font></div><div><font size="2"   >-[ RECORD 1 ]---+-------</font></div><div><font size="2"   >relid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 24726</font></div><div><font size="2"   >schemaname &nbsp; &nbsp; &nbsp;| public</font></div><div><font size="2"   >relname &nbsp; &nbsp; &nbsp; &nbsp; | t1</font></div><div><font size="2"   >heap_blks_read &nbsp;| 0</font></div><div><font size="2"   >heap_blks_hit &nbsp; | 0</font></div><div><font size="2"   >idx_blks_read &nbsp; |&nbsp;</font></div><div><font size="2"   >idx_blks_hit &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >toast_blks_read | 0</font></div><div><font size="2"   >toast_blks_hit &nbsp;| 0</font></div><div><font size="2"   >tidx_blks_read &nbsp;| 0</font></div><div><font size="2"   >tidx_blks_hit &nbsp; | 0</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# explain (analyze,verbose,costs,buffers,timing) select count(*) from t1 ;</font></div><div><font size="2"   >-[ RECORD 1 ]--------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >QUERY PLAN | Aggregate &nbsp;(cost=21.50..21.51 rows=1 width=0) (actual time=0.320..0.320 rows=1 loops=1)</font></div><div><font size="2"   >-[ RECORD 2 ]--------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >QUERY PLAN | &nbsp; Output: count(*)</font></div><div><font size="2"   >-[ RECORD 3 ]--------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >QUERY PLAN | &nbsp; Buffers: shared hit=9</font></div><div><font size="2"   >-[ RECORD 4 ]--------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >QUERY PLAN | &nbsp; -&gt; &nbsp;Seq Scan on public.t1 &nbsp;(cost=0.00..19.00 rows=1000 width=0) (actual time=0.010..0.175 rows=1000 loops=1)</font></div><div><font size="2"   >-[ RECORD 5 ]--------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >QUERY PLAN | &nbsp; &nbsp; &nbsp; &nbsp; Output: id, info</font></div><div><font size="2"   >-[ RECORD 6 ]--------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >QUERY PLAN | &nbsp; &nbsp; &nbsp; &nbsp; Buffers: shared hit=9</font></div><div><font size="2"   >-[ RECORD 7 ]--------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >QUERY PLAN | Total runtime: 0.353 ms</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select * from pg_statio_all_tables where relid='t1'::regclass;</font></div><div><font size="2"   >-[ RECORD 1 ]---+-------</font></div><div><font size="2"   >relid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 24726</font></div><div><font size="2"   >schemaname &nbsp; &nbsp; &nbsp;| public</font></div><div><font size="2"   >relname &nbsp; &nbsp; &nbsp; &nbsp; | t1</font></div><div><font size="2"   >heap_blks_read &nbsp;| 0</font></div><div><font size="2"   >heap_blks_hit &nbsp; | 9</font></div><div><font size="2"   >idx_blks_read &nbsp; |&nbsp;</font></div><div><font size="2"   >idx_blks_hit &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >toast_blks_read | 0</font></div><div><font size="2"   >toast_blks_hit &nbsp;| 0</font></div><div><font size="2"   >tidx_blks_read &nbsp;| 0</font></div><div><font size="2"   >tidx_blks_hit &nbsp; | 0</font></div></div><p></p></pre></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/dynamic-trace.html"   >http://www.postgresql.org/docs/9.3/static/dynamic-trace.html</a></div>2.&nbsp;<div>src/backend/storage/buffer/bufmgr.c</div><div>src/backend/access/transam/xlog.c</div><div>src/include/storage/relfilenode.h</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* RelFileNode must provide all that we need to know to physically access</font></div><div><font size="2"   >&nbsp;* a relation, with the exception of the backend ID, which can be provided</font></div><div><font size="2"   >&nbsp;* separately. Note, however, that a "physical" relation is comprised of</font></div><div><font size="2"   >&nbsp;* multiple files on the filesystem, as each fork is stored as a separate</font></div><div><font size="2"   >&nbsp;* file, and each fork can be divided into multiple segments. See md.c.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* spcNode identifies the tablespace of the relation. &nbsp;It corresponds to</font></div><div><font size="2"   >&nbsp;* pg_tablespace.oid.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* dbNode identifies the database of the relation. &nbsp; &nbsp; &nbsp;It is zero for</font></div><div><font size="2"   >&nbsp;* "shared" relations (those common to all databases of a cluster).</font></div><div><font size="2"   >&nbsp;* Nonzero dbNode values correspond to pg_database.oid.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* relNode identifies the specific relation. &nbsp;relNode corresponds to</font></div><div><font size="2"   >&nbsp;* pg_class.relfilenode (NOT pg_class.oid, because we need to be able</font></div><div><font size="2"   >&nbsp;* to assign new physical files to relations in some situations).</font></div><div><font size="2"   >&nbsp;* Notice that relNode is only unique within a particular database.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: spcNode must be GLOBALTABLESPACE_OID if and only if dbNode is</font></div><div><font size="2"   >&nbsp;* zero. &nbsp;We support shared relations only in the "global" tablespace.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: in pg_class we allow reltablespace == 0 to denote that the</font></div><div><font size="2"   >&nbsp;* relation is stored in its database's "default" tablespace (as</font></div><div><font size="2"   >&nbsp;* identified by pg_database.dattablespace). &nbsp;However this shorthand</font></div><div><font size="2"   >&nbsp;* is NOT allowed in RelFileNode structs --- the real tablespace ID</font></div><div><font size="2"   >&nbsp;* must be supplied when setting spcNode.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: in pg_class, relfilenode can be zero to denote that the relation</font></div><div><font size="2"   >&nbsp;* is a "mapped" relation, whose current true filenode number is available</font></div><div><font size="2"   >&nbsp;* from relmapper.c. &nbsp;Again, this case is NOT allowed in RelFileNodes.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: various places use RelFileNode in hashtable keys. &nbsp; &nbsp; &nbsp;Therefore,</font></div><div><font size="2"   >&nbsp;* there *must not* be any unused padding bytes in this struct. &nbsp;That</font></div><div><font size="2"   >&nbsp;* should be safe as long as all the fields are of type Oid.</font></div><div><font size="2"   >&nbsp;*/</font></div></div><div><div><font size="2"   >typedef struct RelFileNode</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spcNode; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* tablespace */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbNode; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* database */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relNode; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* relation */</font></div><div><font size="2"   >} RelFileNode;</font></div></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>