<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap EXP: PostgreSQL IN-BUILD mark Class 6 - lock</h2>
	<h5 id="">2013-10-17 13:00:09&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201391674922879/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>本文要讲的是PostgreSQL内建的锁类别的探针.</div><div>PostgreSQL锁类别探针分为轻量锁, 重量锁, 以及死锁的探针.</div><div>轻量锁探针 :&nbsp;</div><div><div>&nbsp; &nbsp; &nbsp; &nbsp; probe lwlock__acquire(LWLockId, LWLockMode); 当得到轻量锁时触发, 变量含义参见本文参考部分6,7,8.&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; probe lwlock__release(LWLockId); 当释放轻量锁时触发.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; probe lwlock__wait__start(LWLockId, LWLockMode); 当等待轻量锁开始时触发.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; probe lwlock__wait__done(LWLockId, LWLockMode); 当等待轻量锁结束时触发.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; probe lwlock__condacquire(LWLockId, LWLockMode); 当得到轻量锁时触发, 注意本探针放在nowait轻量锁请求函数中, 所以不会有等待的过程, 只有获得成功或者失败. 请区别于<span style="line-height: 28px;"   >lwlock__acquire.</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; probe lwlock__condacquire__fail(LWLockId, LWLockMode);&nbsp;<span style="line-height: 28px;"   >当得到轻量锁失败时触发.</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; probe lwlock__wait__until__free(LWLockId, LWLockMode); 在LWLockAcquireOrWait 函数中, 这个函数用法比较特殊, 当获取锁成功时返回true; 当不能立刻获取到锁时, 等待锁释放, 返回false, 但是不获取锁. 该函数目前仅被WALWriteLock使用.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; probe lwlock__wait__until__free__fail(LWLockId, LWLockMode); 函数同上, 失败时触发.</div><div>重量锁探针 :&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; probe lock__wait__start(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE);&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 当重量锁请求等待开始时触发, 前5个变量对应LOCKTAG的前5个field, LOCKMODE可参考本文末尾8.&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; probe lock__wait__done(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE);</div></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 等待结束时触发.</div><div>死锁探针 :&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; probe deadlock__found();</div><div><br></div><div>探针的详细介绍 :&nbsp;</div><div><table border="1"   style="margin: 2ex 0px 2ex 2ex; -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border-spacing: 0px; border-collapse: collapse; background-color: rgb(224, 236, 239); border: 2px solid rgb(167, 198, 223); color: rgb(0, 0, 0); font-family: verdana, sans-serif; font-size: 13.333333969116211px; line-height: normal;"   ><tbody><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >lwlock-acquire</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(LWLockId, LWLockMode)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when an LWLock has been acquired. arg0 is the LWLock's ID. arg1 is the requested lock mode, either exclusive or shared.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >lwlock-release</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(LWLockId)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when an LWLock has been released (but note that any released waiters have not yet been awakened). arg0 is the LWLock's ID.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >lwlock-wait-start</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(LWLockId, LWLockMode)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when an LWLock was not immediately available and a server process has begun to wait for the lock to become available. arg0 is the LWLock's ID. arg1 is the requested lock mode, either exclusive or shared.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >lwlock-wait-done</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(LWLockId, LWLockMode)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when a server process has been released from its wait for an LWLock (it does not actually have the lock yet). arg0 is the LWLock's ID. arg1 is the requested lock mode, either exclusive or shared.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >lwlock-condacquire</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(LWLockId, LWLockMode)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when an LWLock was successfully acquired when the caller specified no waiting. arg0 is the LWLock's ID. arg1 is the requested lock mode, either exclusive or shared.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >lwlock-condacquire-fail</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(LWLockId, LWLockMode)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when an LWLock was not successfully acquired when the caller specified no waiting. arg0 is the LWLock's ID. arg1 is the requested lock mode, either exclusive or shared.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >lock-wait-start</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >Probe that fires when a request for a heavyweight lock (lmgr lock) has begun to wait because the lock is not available. arg0 through arg3 are the tag fields identifying the object being locked. arg4 indicates the type of object being locked. arg5 indicates the lock type being requested.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >lock-wait-done</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when a request for a heavyweight lock (lmgr lock) has finished waiting (i.e., has acquired the lock). The arguments are the same as for lock-wait-start.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >deadlock-found</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >()</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when a deadlock is found by the deadlock detector.</td></tr></table></div><div><br></div><div>[举例]</div><div>1. 跟踪轻量锁等待次数.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >stap -e '</font></div><div><font size="2"   >global var1</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("lwlock__wait__done") {</font></div><div><font size="2"   >&nbsp; var1[$arg1, $arg2]++</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe timer.s($1) {</font></div><div><font size="2"   >&nbsp; println("*******************")</font></div><div><font size="2"   >&nbsp; foreach(v=[x,y] in var1+)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; printf("lockid:%d, lockmode:%d, wait_count:%d\n", x,y,v)</font></div><div><font size="2"   >&nbsp; delete var1</font></div><div><font size="2"   >}' 5</font></div><p></p></pre></div><div>SQL :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# \sf f_test(int)</font></div><div><font size="2"   >CREATE OR REPLACE FUNCTION public.f_test(i_id integer)</font></div><div><font size="2"   >&nbsp;RETURNS void</font></div><div><font size="2"   >&nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp;STRICT</font></div><div><font size="2"   >AS $function$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; update test set info=md5(random()::text), crt_time=clock_timestamp() where id=i_id;</font></div><div><font size="2"   >&nbsp; if not found then</font></div><div><font size="2"   >&nbsp; &nbsp; insert into test(id,info,crt_time) values(i_id,md5(random()::text),clock_timestamp());</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; return;</font></div><div><font size="2"   >&nbsp; exception when others then</font></div><div><font size="2"   >&nbsp; &nbsp; return;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$function$</font></div><div><font size="2"   >digoal=# \d test</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Table "public.test"</font></div><div><font size="2"   >&nbsp; Column &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Modifiers&nbsp;</font></div><div><font size="2"   >----------+-----------------------------+-----------</font></div><div><font size="2"   >&nbsp;id &nbsp; &nbsp; &nbsp; | integer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;info &nbsp; &nbsp; | text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;crt_time | timestamp without time zone |&nbsp;</font></div><div><font size="2"   >Indexes:</font></div><div><font size="2"   >&nbsp; &nbsp; "test_pkey" PRIMARY KEY, btree (id)</font></div><p></p></pre></div><div>stap输出 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >*******************</font></div><div><font size="2"   >lockid:30604, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:6150, lockmode:0, wait_count:1</font></div><div><font size="2"   >lockid:137242, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:33180, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:37820, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:55818, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:152122, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:3, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:18220, lockmode:0, wait_count:1</font></div><div><font size="2"   >lockid:34, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:38, lockmode:0, wait_count:1</font></div><div><font size="2"   >lockid:63456, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:23704, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:52826, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:49032, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:45, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:45348, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:2364, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:40, lockmode:0, wait_count:1</font></div><div><font size="2"   >lockid:45918, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:150650, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:56324, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:32554, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:38, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:20636, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:6534, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:39126, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:42, lockmode:0, wait_count:1</font></div><div><font size="2"   >lockid:1640, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:46, lockmode:0, wait_count:1</font></div><div><font size="2"   >lockid:39, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:53778, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:35, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:33450, lockmode:1, wait_count:1</font></div><div><font size="2"   >lockid:33, lockmode:1, wait_count:2</font></div><div><font size="2"   >lockid:46, lockmode:1, wait_count:2</font></div><div><font size="2"   >lockid:48, lockmode:0, wait_count:2</font></div><div><font size="2"   >lockid:43, lockmode:0, wait_count:2</font></div><div><font size="2"   >lockid:96, lockmode:1, wait_count:2</font></div><div><font size="2"   >lockid:44, lockmode:1, wait_count:2</font></div><div><font size="2"   >lockid:37, lockmode:1, wait_count:2</font></div><div><font size="2"   >lockid:40, lockmode:1, wait_count:2</font></div><div><font size="2"   >lockid:13932, lockmode:1, wait_count:2</font></div><div><font size="2"   >lockid:48, lockmode:1, wait_count:4</font></div><div><font size="2"   >lockid:8, lockmode:0, wait_count:7</font></div><div><font size="2"   >lockid:13, lockmode:0, wait_count:88</font></div><div><font size="2"   >lockid:60, lockmode:0, wait_count:224</font></div><div><font size="2"   >lockid:54, lockmode:0, wait_count:235</font></div><div><font size="2"   >lockid:58, lockmode:0, wait_count:237</font></div><div><font size="2"   >lockid:49, lockmode:0, wait_count:240</font></div><div><font size="2"   >lockid:56, lockmode:0, wait_count:243</font></div><div><font size="2"   >lockid:57, lockmode:0, wait_count:249</font></div><div><font size="2"   >lockid:64, lockmode:0, wait_count:251</font></div><div><font size="2"   >lockid:63, lockmode:0, wait_count:261</font></div><div><font size="2"   >lockid:55, lockmode:0, wait_count:262</font></div><div><font size="2"   >lockid:59, lockmode:0, wait_count:263</font></div><div><font size="2"   >lockid:53, lockmode:0, wait_count:273</font></div><div><font size="2"   >lockid:52, lockmode:0, wait_count:275</font></div><div><font size="2"   >lockid:51, lockmode:0, wait_count:275</font></div><div><font size="2"   >lockid:62, lockmode:0, wait_count:276</font></div><div><font size="2"   >lockid:61, lockmode:0, wait_count:281</font></div><div><font size="2"   >lockid:50, lockmode:0, wait_count:287</font></div><div><font size="2"   >lockid:12, lockmode:0, wait_count:1514</font></div><div><font size="2"   >lockid:11, lockmode:1, wait_count:3385</font></div><div><font size="2"   >lockid:11, lockmode:0, wait_count:4103</font></div><div><font size="2"   >lockid:3, lockmode:0, wait_count:6376</font></div><div><font size="2"   >lockid:4, lockmode:1, wait_count:6980</font></div><div><font size="2"   >lockid:4, lockmode:0, wait_count:19500</font></div><div><font size="2"   >lockid:7, lockmode:0, wait_count:31472</font></div></div><div><font size="2"   >... 略</font></div><p></p></pre></div><div>2. 跟踪重量锁 :&nbsp;</div><div>stap :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 21px;"   >[root@db-172-16-3-150 postgresql-9.3.1]# stap -v -D MAXSKIPPED=10000000 -e '<br>global var1%[120000], var2%[120000]<br>probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("lock__wait__start") {<br>  var1[pid()] = gettimeofday_us()<br>}<br>probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("lock__wait__done") {<br>  p=pid()<br>  t=gettimeofday_us()<br>  if (p in var1)<br>    var2[$arg1, $arg2, $arg3, $arg4, $arg5, $arg6] &lt;&lt;&lt; (t - var1[p])<br>}<br>probe timer.s($1) {<br>  println("*******************")<br>  foreach([a,b,c,d,e,f] in var2 @sum - limit 5) <br>    printdln("**",a,b,c,d,e,f,@sum(var2[a,b,c,d,e,f])/1000,@count(var2[a,b,c,d,e,f]),@avg(var2[a,b,c,d,e,f])/1000)</span></font></div><div><font size="2"   ><span style="line-height: 21px;"   >  delete var2<br>}' 5</span></font></div><p></p></pre></div><div>测试SQL :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >pg93@db-172-16-3-150-&gt; cat test.sql</font></div><div><font size="2"   >\setrandom id 1 8</font></div><div><font size="2"   >select f_test(:id);</font></div><div><font size="2"   >pg93@db-172-16-3-150-&gt; pgbench -M prepared -n -r -f ./test.sql -c 64 -j 8 -T 1000</font></div></div><div><font size="2"   >64个链接, 将id现在在8个以内, 会产生大量的等待.</font></div><div><div><font size="2"   >digoal=# \sf f_test(int)</font></div><div><font size="2"   >CREATE OR REPLACE FUNCTION public.f_test(i_id integer)</font></div><div><font size="2"   >&nbsp;RETURNS void</font></div><div><font size="2"   >&nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp;STRICT</font></div><div><font size="2"   >AS $function$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; update test set info=md5(random()::text), crt_time=clock_timestamp() where id=i_id;</font></div><div><font size="2"   >&nbsp; if not found then</font></div><div><font size="2"   >&nbsp; &nbsp; insert into test(id,info,crt_time) values(i_id,md5(random()::text),clock_timestamp());</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; return;</font></div><div><font size="2"   >&nbsp; exception when others then</font></div><div><font size="2"   >&nbsp; &nbsp; return;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$function$</font></div></div><p></p></pre></div><div>stap输出 :&nbsp;</div><div>最后面3列为一共等待的时间, 一共等待的次数, 以及平均等待时间(ms).</div><div>3表示LOCKTAG_TUPLE, 参考本文末尾的定义</div><div>7表示ExclusiveLock, 参考本文末尾的定义</div><div><span style="line-height: 28px;"   >16384**24735**77940**116表示&nbsp;</span>dboid,&nbsp;reloid,&nbsp;blocknum,&nbsp;offnum</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# select oid from pg_database where datname='digoal';</font></div><div><font size="2"   >&nbsp; oid &nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;16384</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=# select oid from pg_class where relname='test';</font></div><div><font size="2"   >&nbsp; oid &nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;24735</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=# select max(ctid) from test;</font></div><div><font size="2"   >&nbsp; &nbsp; max &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------</font></div><div><font size="2"   >&nbsp;(80505,78)</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >*******************</font></div><div><font size="2"   >16384**24735**77940**116**3**7**304**38**8</font></div><div><font size="2"   >16384**24735**77921**83**3**7**295**32**9</font></div><div><font size="2"   >16384**24735**77979**32**3**7**271**41**6</font></div><div><font size="2"   >16384**24735**77906**29**3**7**235**37**6</font></div><div><font size="2"   >16384**24735**77921**138**3**7**233**44**5</font></div><div><font size="2"   >*******************</font></div><div><font size="2"   >129233058**0**0**0**4**5**1355**9**150</font></div><div><font size="2"   >129233135**0**0**0**4**5**1197**8**149</font></div><div><font size="2"   >129233044**0**0**0**4**5**749**6**124</font></div><div><font size="2"   >129233289**0**0**0**4**5**747**5**149</font></div><div><font size="2"   >16384**24735**78068**67**3**7**317**14**22</font></div><div><font size="2"   >*******************</font></div><div><font size="2"   >129363231**0**0**0**4**5**921**19**48</font></div><div><font size="2"   >16384**24735**78091**103**3**7**450**47**9</font></div><div><font size="2"   >16384**24735**78199**108**3**7**300**25**12</font></div><div><font size="2"   >16384**24735**78130**37**3**7**264**5**52</font></div><div><font size="2"   >16384**24735**78131**66**3**7**261**56**4</font></div><div><font size="2"   >*******************</font></div><div><font size="2"   >16384**24735**78277**36**3**7**350**38**9</font></div><div><font size="2"   >16384**24735**78290**20**3**7**301**35**8</font></div><div><font size="2"   >16384**24735**78206**114**3**7**268**43**6</font></div><div><font size="2"   >16384**24735**78277**93**3**7**254**30**8</font></div><div><font size="2"   >16384**24735**78290**79**3**7**253**31**8</font></div><div><font size="2"   >*******************</font></div><div><font size="2"   >16384**24735**78613**25**3**7**220**6**36</font></div><div><font size="2"   >16384**24735**78781**19**3**7**206**21**9</font></div><div><font size="2"   >16384**24735**78621**32**3**7**184**22**8</font></div><div><font size="2"   >16384**24735**78613**21**3**7**165**3**55</font></div><div><font size="2"   >16384**24735**78702**78**3**7**159**17**9</font></div><p></p></pre></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/dynamic-trace.html"   >http://www.postgresql.org/docs/9.3/static/dynamic-trace.html</a></div><div>2.&nbsp;</div><div>src/backend/storage/lmgr/lwlock.c</div><div>src/backend/storage/lmgr/lock.c</div><div>src/backend/storage/lmgr/deadlock.c</div><div>3.&nbsp;<span style="line-height: 28px;"   >探针信息 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/* TRACE_POSTGRESQL_LWLOCK_ACQUIRE ( int, int) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_ACQUIRE_ENABLED() __builtin_expect (lwlock__acquire_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_lwlock__acquire_semaphore lwlock__acquire_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_ACQUIRE_ENABLED() __builtin_expect (postgresql_lwlock__acquire_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_lwlock__acquire_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_ACQUIRE(arg1,arg2) \</font></div><div><font size="2"   >DTRACE_PROBE2(postgresql,lwlock__acquire,arg1,arg2)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* TRACE_POSTGRESQL_LWLOCK_RELEASE ( int) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_RELEASE_ENABLED() __builtin_expect (lwlock__release_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_lwlock__release_semaphore lwlock__release_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_RELEASE_ENABLED() __builtin_expect (postgresql_lwlock__release_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_lwlock__release_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_RELEASE(arg1) \</font></div><div><font size="2"   >DTRACE_PROBE1(postgresql,lwlock__release,arg1)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* TRACE_POSTGRESQL_LWLOCK_WAIT_START ( int, int) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_WAIT_START_ENABLED() __builtin_expect (lwlock__wait__start_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_lwlock__wait__start_semaphore lwlock__wait__start_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_WAIT_START_ENABLED() __builtin_expect (postgresql_lwlock__wait__start_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_lwlock__wait__start_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_WAIT_START(arg1,arg2) \</font></div><div><font size="2"   >DTRACE_PROBE2(postgresql,lwlock__wait__start,arg1,arg2)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/* TRACE_POSTGRESQL_LWLOCK_WAIT_DONE ( int, int) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_WAIT_DONE_ENABLED() __builtin_expect (lwlock__wait__done_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_lwlock__wait__done_semaphore lwlock__wait__done_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_WAIT_DONE_ENABLED() __builtin_expect (postgresql_lwlock__wait__done_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_lwlock__wait__done_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_WAIT_DONE(arg1,arg2) \</font></div><div><font size="2"   >DTRACE_PROBE2(postgresql,lwlock__wait__done,arg1,arg2)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE ( int, int) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_ENABLED() __builtin_expect (lwlock__condacquire_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_lwlock__condacquire_semaphore lwlock__condacquire_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_ENABLED() __builtin_expect (postgresql_lwlock__condacquire_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_lwlock__condacquire_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE(arg1,arg2) \</font></div><div><font size="2"   >DTRACE_PROBE2(postgresql,lwlock__condacquire,arg1,arg2)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL ( int, int) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL_ENABLED() __builtin_expect (lwlock__condacquire__fail_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_lwlock__condacquire__fail_semaphore lwlock__condacquire__fail_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL_ENABLED() __builtin_expect (postgresql_lwlock__condacquire__fail_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_lwlock__condacquire__fail_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL(arg1,arg2) \</font></div><div><font size="2"   >DTRACE_PROBE2(postgresql,lwlock__condacquire__fail,arg1,arg2)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/* TRACE_POSTGRESQL_LWLOCK_WAIT_UNTIL_FREE ( int, int) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_WAIT_UNTIL_FREE_ENABLED() __builtin_expect (lwlock__wait__until__free_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_lwlock__wait__until__free_semaphore lwlock__wait__until__free_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_WAIT_UNTIL_FREE_ENABLED() __builtin_expect (postgresql_lwlock__wait__until__free_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_lwlock__wait__until__free_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_WAIT_UNTIL_FREE(arg1,arg2) \</font></div><div><font size="2"   >DTRACE_PROBE2(postgresql,lwlock__wait__until__free,arg1,arg2)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* TRACE_POSTGRESQL_LWLOCK_WAIT_UNTIL_FREE_FAIL ( int, int) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_WAIT_UNTIL_FREE_FAIL_ENABLED() __builtin_expect (lwlock__wait__until__free__fail_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_lwlock__wait__until__free__fail_semaphore lwlock__wait__until__free__fail_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_WAIT_UNTIL_FREE_FAIL_ENABLED() __builtin_expect (postgresql_lwlock__wait__until__free__fail_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_lwlock__wait__until__free__fail_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LWLOCK_WAIT_UNTIL_FREE_FAIL(arg1,arg2) \</font></div><div><font size="2"   >DTRACE_PROBE2(postgresql,lwlock__wait__until__free__fail,arg1,arg2)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* TRACE_POSTGRESQL_LOCK_WAIT_START ( unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, int) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LOCK_WAIT_START_ENABLED() __builtin_expect (lock__wait__start_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_lock__wait__start_semaphore lock__wait__start_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LOCK_WAIT_START_ENABLED() __builtin_expect (postgresql_lock__wait__start_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_lock__wait__start_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LOCK_WAIT_START(arg1,arg2,arg3,arg4,arg5,arg6) \</font></div><div><font size="2"   >DTRACE_PROBE6(postgresql,lock__wait__start,arg1,arg2,arg3,arg4,arg5,arg6)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/* TRACE_POSTGRESQL_LOCK_WAIT_DONE ( unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, int) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LOCK_WAIT_DONE_ENABLED() __builtin_expect (lock__wait__done_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_lock__wait__done_semaphore lock__wait__done_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LOCK_WAIT_DONE_ENABLED() __builtin_expect (postgresql_lock__wait__done_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_lock__wait__done_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_LOCK_WAIT_DONE(arg1,arg2,arg3,arg4,arg5,arg6) \</font></div><div><font size="2"   >DTRACE_PROBE6(postgresql,lock__wait__done,arg1,arg2,arg3,arg4,arg5,arg6)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/* TRACE_POSTGRESQL_DEADLOCK_FOUND () */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_DEADLOCK_FOUND_ENABLED() __builtin_expect (deadlock__found_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_deadlock__found_semaphore deadlock__found_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_DEADLOCK_FOUND_ENABLED() __builtin_expect (postgresql_deadlock__found_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_deadlock__found_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_DEADLOCK_FOUND() \</font></div><div><font size="2"   >DTRACE_PROBE(postgresql,deadlock__found)</font></div></div><p></p></pre></div><div>4. 探针在源码中的信息:&nbsp;</div><div>轻量锁</div><div>src/backend/storage/lmgr/lwlock.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* LWLockAcquire - acquire a lightweight lock in the specified mode</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* If the lock is not available, sleep until it is.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Side effect: cancel/die interrupts are held off until lock release.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >LWLockAcquire(LWLockId lockid, LWLockMode mode)</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <u>TRACE_POSTGRESQL_LWLOCK_WAIT_START(lockid, mode);</u></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (;;)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* "false" means cannot accept cancel/die interrupt here. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGSemaphoreLock(&amp;proc-&gt;sem, false);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!proc-&gt;lwWaiting)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits++;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <u>TRACE_POSTGRESQL_LWLOCK_WAIT_DONE(lockid, mode);</u></font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* We are done updating shared state of the lock itself. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;lock-&gt;mutex);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; <u>TRACE_POSTGRESQL_LWLOCK_ACQUIRE(lockid, mode);</u></font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* LWLockConditionalAcquire - acquire a lightweight lock in the specified mode</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* If the lock is not available, return FALSE with no side-effects.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* If successful, cancel/die interrupts are held off until lock release.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >bool</font></div><div><font size="2"   >LWLockConditionalAcquire(LWLockId lockid, LWLockMode mode)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* We are done updating shared state of the lock itself. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;lock-&gt;mutex);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (mustwait)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Failed to get lock, so release interrupt holdoff */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RESUME_INTERRUPTS();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_LWDEBUG("LWLockConditionalAcquire", lockid, "failed");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <u>TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL(lockid, mode);</u></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Add lock to list of locks held by this backend */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; held_lwlocks[num_held_lwlocks++] = lockid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <u>TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE(lockid, mode);</u></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* LWLockAcquireOrWait - Acquire lock, or wait until it's free</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The semantics of this function are a bit funky. &nbsp; &nbsp; &nbsp;If the lock is currently</font></div><div><font size="2"   >&nbsp;* free, it is acquired in the given mode, and the function returns true. &nbsp;If</font></div><div><font size="2"   >&nbsp;* the lock isn't immediately free, the function waits until it is released</font></div><div><font size="2"   >&nbsp;* and returns false, but does not acquire the lock.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This is currently used for WALWriteLock: when a backend flushes the WAL,</font></div><div><font size="2"   >&nbsp;* holding WALWriteLock, it can flush the commit records of many other</font></div><div><font size="2"   >&nbsp;* backends as a side-effect. &nbsp;Those other backends need to wait until the</font></div><div><font size="2"   >&nbsp;* flush finishes, but don't need to acquire the lock anymore. &nbsp;They can just</font></div><div><font size="2"   >&nbsp;* wake up, observe that their records have already been flushed, and return.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >bool</font></div><div><font size="2"   >LWLockAcquireOrWait(LWLockId lockid, LWLockMode mode)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <u>TRACE_POSTGRESQL_LWLOCK_WAIT_START(lockid, mode);</u></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (;;)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* "false" means cannot accept cancel/die interrupt here. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGSemaphoreLock(&amp;proc-&gt;sem, false);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!proc-&gt;lwWaiting)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits++;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <u>TRACE_POSTGRESQL_LWLOCK_WAIT_DONE(lockid, mode);</u></font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Fix the process wait semaphore's count for any absorbed wakeups.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; while (extraWaits-- &gt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGSemaphoreUnlock(&amp;proc-&gt;sem);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (mustwait)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Failed to get lock, so release interrupt holdoff */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RESUME_INTERRUPTS();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_LWDEBUG("LWLockAcquireOrWait", lockid, "failed");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <u>TRACE_POSTGRESQL_LWLOCK_WAIT_UNTIL_FREE_FAIL(lockid, mode);</u></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Add lock to list of locks held by this backend */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; held_lwlocks[num_held_lwlocks++] = lockid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <u>TRACE_POSTGRESQL_LWLOCK_WAIT_UNTIL_FREE(lockid, mode);</u></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* LWLockRelease - release a previously acquired lock</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >LWLockRelease(LWLockId lockid)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* We are done updating shared state of the lock itself. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;lock-&gt;mutex);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; <u>TRACE_POSTGRESQL_LWLOCK_RELEASE(lockid);</u></font></div></div><p></p></pre></div><div><br></div><div>重量锁</div><div>src/backend/storage/lmgr/lock.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* LockAcquireExtended - allows us to specify additional options</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* reportMemoryError specifies whether a lock request that fills the</font></div><div><font size="2"   >&nbsp;* lock table should generate an ERROR or not. This allows a priority</font></div><div><font size="2"   >&nbsp;* caller to note that the lock table is full and then begin taking</font></div><div><font size="2"   >&nbsp;* extreme action to reduce the number of other lock holders before</font></div><div><font size="2"   >&nbsp;* retrying the action.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >LockAcquireResult</font></div><div><font size="2"   >LockAcquireExtended(const LOCKTAG *locktag,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool sessionLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool dontWait,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool reportMemoryError)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Sleep till someone wakes me up.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <u>TRACE_POSTGRESQL_LOCK_WAIT_START(locktag-&gt;locktag_field1,</u></font></div><div><font size="2"   ><u>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;locktag-&gt;locktag_field2,</u></font></div><div><font size="2"   ><u>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;locktag-&gt;locktag_field3,</u></font></div><div><font size="2"   ><u>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;locktag-&gt;locktag_field4,</u></font></div><div><font size="2"   ><u>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;locktag-&gt;locktag_type,</u></font></div><div><font size="2"   ><u>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lockmode);</u></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WaitOnLock(locallock, owner);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <u>TRACE_POSTGRESQL_LOCK_WAIT_DONE(locktag-&gt;locktag_field1,</u></font></div><div><font size="2"   ><u>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag-&gt;locktag_field2,</u></font></div><div><font size="2"   ><u>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag-&gt;locktag_field3,</u></font></div><div><font size="2"   ><u>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag-&gt;locktag_field4,</u></font></div><div><font size="2"   ><u>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag-&gt;locktag_type,</u></font></div><div><font size="2"   ><u>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode);</u></font></div></div><div><font size="2"   >...</font></div><p></p></pre></div><div><br></div><div>死锁</div><div>src/backend/storage/lmgr/deadlock.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* DeadLockCheck -- Checks for deadlocks for a given process</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This code looks for deadlocks involving the given process. &nbsp;If any</font></div><div><font size="2"   >&nbsp;* are found, it tries to rearrange lock wait queues to resolve the</font></div><div><font size="2"   >&nbsp;* deadlock. &nbsp;If resolution is impossible, return DS_HARD_DEADLOCK ---</font></div><div><font size="2"   >&nbsp;* the caller is then expected to abort the given proc's transaction.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Caller must already have locked all partitions of the lock tables.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* On failure, deadlock details are recorded in deadlockDetails[] for</font></div><div><font size="2"   >&nbsp;* subsequent printing by DeadLockReport(). &nbsp;That activity is separate</font></div><div><font size="2"   >&nbsp;* because (a) we don't want to do it while holding all those LWLocks,</font></div><div><font size="2"   >&nbsp;* and (b) we are typically invoked inside a signal handler.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >DeadLockState</font></div><div><font size="2"   >DeadLockCheck(PGPROC *proc)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Search for deadlocks and possible fixes */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (DeadLockCheckRecurse(proc))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Call FindLockCycle one more time, to record the correct</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* deadlockDetails[] for the basic state with no rearrangements.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSoftEdges;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <u>TRACE_POSTGRESQL_DEADLOCK_FOUND();</u></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nWaitOrders = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!FindLockCycle(proc, possibleConstraints, &amp;nSoftEdges))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, "deadlock seems to have disappeared");</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return DS_HARD_DEADLOCK; &nbsp; &nbsp; &nbsp; &nbsp;/* cannot find a non-deadlocked state */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><p></p></pre></div>5. LWLockID 类型定义<div>src/include/storage/lwlock.h</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* We have a number of predefined LWLocks, plus a bunch of LWLocks that are</font></div><div><font size="2"   >&nbsp;* dynamically assigned (e.g., for shared buffers). &nbsp;The LWLock structures</font></div><div><font size="2"   >&nbsp;* live in shared memory (since they contain shared data) and are identified</font></div><div><font size="2"   >&nbsp;* by values of this enumerated type. &nbsp;We abuse the notion of an enum somewhat</font></div><div><font size="2"   >&nbsp;* by allowing values not listed in the enum declaration to be assigned.</font></div><div><font size="2"   >&nbsp;* The extra value MaxDynamicLWLock is there to keep the compiler from</font></div><div><font size="2"   >&nbsp;* deciding that the enum can be represented as char or short ...</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* If you remove a lock, please replace it with a placeholder. This retains</font></div><div><font size="2"   >&nbsp;* the lock numbering, which is helpful for DTrace and other external</font></div><div><font size="2"   >&nbsp;* debugging scripts.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef enum LWLockId</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; BufFreelistLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ShmemIndexLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; OidGenLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XidGenLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ProcArrayLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SInvalReadLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SInvalWriteLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; WALInsertLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; WALWriteLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ControlFileLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckpointLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CLogControlLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SubtransControlLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; MultiXactGenLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; MultiXactOffsetControlLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; MultiXactMemberControlLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; RelCacheInitLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckpointerCommLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TwoPhaseStateLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TablespaceCreateLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; BtreeVacuumLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; AddinShmemInitLock,</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; AutovacuumLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; AutovacuumScheduleLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SyncScanLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; RelationMappingLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; AsyncCtlLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; AsyncQueueLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SerializableXactHashLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SerializableFinishedListLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SerializablePredicateLockListLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; OldSerXidLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SyncRepLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Individual lock IDs end here */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FirstBufMappingLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FirstLockMgrLock = FirstBufMappingLock + NUM_BUFFER_PARTITIONS,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FirstPredicateLockMgrLock = FirstLockMgrLock + NUM_LOCK_PARTITIONS,</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* must be last except for MaxDynamicLWLock: */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; NumFixedLWLocks = FirstPredicateLockMgrLock + NUM_PREDICATELOCK_PARTITIONS,</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; MaxDynamicLWLock = 1000000000</font></div><div><font size="2"   >} LWLockId;</font></div></div><p></p></pre></div><div>6.<span style="line-height: 28px;"   >&nbsp;</span><span style="line-height: 28px;"   >LWLockMode 类型定义</span></div><div>src/include/storage/lwlock.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >typedef enum LWLockMode</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LW_SHARED,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LW_WAIT_UNTIL_FREE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* A special mode used in PGPROC-&gt;lwlockMode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* when waiting for lock to become free. Not</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to be used as LWLockAcquire argument */</font></div><div><font size="2"   >} LWLockMode;</font></div><p></p></pre></div><div>7. LOCKTAG以及LockTagType 类型定义</div><div>src/include/storage/lock.h</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* LOCKTAG is the key information needed to look up a LOCK item in the</font></div><div><font size="2"   >&nbsp;* lock hashtable. &nbsp; &nbsp; &nbsp;A LOCKTAG value uniquely identifies a lockable object.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The LockTagType enum defines the different kinds of objects we can lock.</font></div><div><font size="2"   >&nbsp;* We can handle up to 256 different LockTagTypes.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef enum LockTagType</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_RELATION, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* whole relation */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* ID info for a relation is DB OID + REL OID; DB OID = 0 if shared */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_RELATION_EXTEND, &nbsp; &nbsp; &nbsp; &nbsp;/* the right to extend a relation */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* same ID info as RELATION */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_PAGE, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* one page of a relation */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* ID info for a page is RELATION info + BlockNumber */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_TUPLE, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* one physical tuple */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* ID info for a tuple is PAGE info + OffsetNumber */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_TRANSACTION, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* transaction (for waiting for xact done) */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* ID info for a transaction is its TransactionId */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_VIRTUALTRANSACTION, /* virtual transaction (ditto) */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* ID info for a virtual transaction is its VirtualTransactionId */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_OBJECT, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* non-relation database object */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* ID info for an object is DB OID + CLASS OID + OBJECT OID + SUBID */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: object ID has same representation as in pg_depend and</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* pg_description, but notice that we are constraining SUBID to 16 bits.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Also, we use DB OID = 0 for shared objects such as tablespaces.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_USERLOCK, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* reserved for old contrib/userlock code */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_ADVISORY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* advisory user locks */</font></div><div><font size="2"   >} LockTagType;</font></div></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* The LOCKTAG struct is defined with malice aforethought to fit into 16</font></div><div><font size="2"   >&nbsp;* bytes with no padding. &nbsp;Note that this would need adjustment if we were</font></div><div><font size="2"   >&nbsp;* to widen Oid, BlockNumber, or TransactionId to more than 32 bits.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We include lockmethodid in the locktag so that a single hash table in</font></div><div><font size="2"   >&nbsp;* shared memory can store locks of different lockmethods.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef struct LOCKTAG</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;locktag_field1; /* a 32-bit ID field */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;locktag_field2; /* a 32-bit ID field */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;locktag_field3; /* a 32-bit ID field */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;locktag_field4; /* a 16-bit ID field */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag_type; &nbsp; /* see enum LockTagType */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag_lockmethodid; &nbsp; /* lockmethod indicator */</font></div><div><font size="2"   >} LOCKTAG;</font></div></div><p></p></pre></div><div>8. LOCKMODE 类型定义以及值定义.</div><div>src/include/storage/lock.h</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* LOCKMODE is an integer (1..N) indicating a lock type. &nbsp;LOCKMASK is a bit</font></div><div><font size="2"   >&nbsp;* mask indicating a set of held or requested lock types (the bit 1&lt;&lt;mode</font></div><div><font size="2"   >&nbsp;* corresponds to a particular lock mode).</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef int LOCKMASK;</font></div><div><font size="2"   >typedef int LOCKMODE;</font></div></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* These are the valid values of type LOCKMODE for all the standard lock</font></div><div><font size="2"   >&nbsp;* methods (both DEFAULT and USER).</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* NoLock is not a lock mode, but a flag value meaning "don't get a lock" */</font></div><div><font size="2"   >#define NoLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define AccessShareLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* SELECT */</font></div><div><font size="2"   >#define RowShareLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* SELECT FOR UPDATE/FOR SHARE */</font></div><div><font size="2"   >#define RowExclusiveLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* INSERT, UPDATE, DELETE */</font></div><div><font size="2"   >#define ShareUpdateExclusiveLock 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* VACUUM (non-FULL),ANALYZE, CREATE</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* INDEX CONCURRENTLY */</font></div><div><font size="2"   >#define ShareLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* CREATE INDEX (WITHOUT CONCURRENTLY) */</font></div><div><font size="2"   >#define ShareRowExclusiveLock &nbsp; 6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* like EXCLUSIVE MODE, but allows ROW</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* SHARE */</font></div><div><font size="2"   >#define ExclusiveLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* blocks ROW SHARE/SELECT...FOR</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* UPDATE */</font></div><div><font size="2"   >#define AccessExclusiveLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* ALTER TABLE, DROP TABLE, VACUUM</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* FULL, and unqualified LOCK TABLE */</font></div></div><p></p></pre></div><div>9. 重量锁请求的rf by函数 :&nbsp;</div><div><pre class="prettyprint"   ><p><font size="2"   >Referenced by ConditionalLockPage(), ConditionalLockRelation(), ConditionalLockRelationOid(), ConditionalLockTuple(), ConditionalXactLockTableWait(), LockDatabaseObject(), LockPage(), LockRelation(), LockRelationForExtension(), LockRelationIdForSession(), LockRelationOid(), LockSharedObject(), LockSharedObjectForSession(), LockTuple(), pg_advisory_lock_int4(), pg_advisory_lock_int8(), pg_advisory_lock_shared_int4(), pg_advisory_lock_shared_int8(), pg_advisory_xact_lock_int4(), pg_advisory_xact_lock_int8(), pg_advisory_xact_lock_shared_int4(), pg_advisory_xact_lock_shared_int8(), pg_try_advisory_lock_int4(), pg_try_advisory_lock_int8(), pg_try_advisory_lock_shared_int4(), pg_try_advisory_lock_shared_int8(), pg_try_advisory_xact_lock_int4(), pg_try_advisory_xact_lock_int8(), pg_try_advisory_xact_lock_shared_int4(), pg_try_advisory_xact_lock_shared_int8(), VirtualXactLock(), XactLockTableInsert(), and XactLockTableWait().</font></p></pre></div><div>本例中锁类型为TUPLE时是LockTuple函数调用参数的一个锁. 所以通过宏<span style="line-height: 28px;"   >SET_LOCKTAG_TUPLE可以解释这个探针中前5个变量的值的含义为(dbid, relid, blocknum, tupleoffset_inblock).</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp;LockTuple(Relation relation, ItemPointer tid, LOCKMODE lockmode)</font></div><div><font size="2"   >&nbsp; 388 {</font></div><div><font size="2"   >&nbsp; 389 &nbsp; &nbsp; LOCKTAG &nbsp; &nbsp; tag;</font></div><div><font size="2"   >&nbsp; 390&nbsp;</font></div><div><font size="2"   >&nbsp; 391 &nbsp; &nbsp; SET_LOCKTAG_TUPLE(tag,</font></div><div><font size="2"   >&nbsp; 392 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,</font></div><div><font size="2"   >&nbsp; 393 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.relId,</font></div><div><font size="2"   >&nbsp; 394 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetBlockNumber(tid),</font></div><div><font size="2"   >&nbsp; 395 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetOffsetNumber(tid));</font></div><div><font size="2"   >&nbsp; 396&nbsp;</font></div><div><font size="2"   >&nbsp; 397 &nbsp; &nbsp; (void) LockAcquire(&amp;tag, lockmode, false, false);</font></div><div><font size="2"   >&nbsp; 398 }</font></div><p></p></pre></div><div>10. 重量锁TAG设置宏定义请参考如下头文件 :&nbsp;</div><div>src/include/storage/lock.h</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* These macros define how we map logical IDs of lockable objects into</font></div><div><font size="2"   >&nbsp;* the physical fields of LOCKTAG. &nbsp; &nbsp; &nbsp;Use these to set up LOCKTAG values,</font></div><div><font size="2"   >&nbsp;* rather than accessing the fields directly. &nbsp;Note multiple eval of target!</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define SET_LOCKTAG_RELATION(locktag,dboid,reloid) \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ((locktag).locktag_field1 = (dboid), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field2 = (reloid), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field3 = 0, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field4 = 0, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_type = LOCKTAG_RELATION, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_lockmethodid = DEFAULT_LOCKMETHOD)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define SET_LOCKTAG_RELATION_EXTEND(locktag,dboid,reloid) \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ((locktag).locktag_field1 = (dboid), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field2 = (reloid), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field3 = 0, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field4 = 0, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_type = LOCKTAG_RELATION_EXTEND, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_lockmethodid = DEFAULT_LOCKMETHOD)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define SET_LOCKTAG_PAGE(locktag,dboid,reloid,blocknum) \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ((locktag).locktag_field1 = (dboid), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field2 = (reloid), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field3 = (blocknum), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field4 = 0, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_type = LOCKTAG_PAGE, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_lockmethodid = DEFAULT_LOCKMETHOD)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define SET_LOCKTAG_TUPLE(locktag,dboid,reloid,blocknum,offnum) \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ((locktag).locktag_field1 = (dboid), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field2 = (reloid), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field3 = (blocknum), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field4 = (offnum), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_type = LOCKTAG_TUPLE, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_lockmethodid = DEFAULT_LOCKMETHOD)</font></div></div><div><div><font size="2"   >#define SET_LOCKTAG_TRANSACTION(locktag,xid) \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ((locktag).locktag_field1 = (xid), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field2 = 0, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field3 = 0, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field4 = 0, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_type = LOCKTAG_TRANSACTION, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_lockmethodid = DEFAULT_LOCKMETHOD)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define SET_LOCKTAG_VIRTUALTRANSACTION(locktag,vxid) \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ((locktag).locktag_field1 = (vxid).backendId, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field2 = (vxid).localTransactionId, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field3 = 0, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field4 = 0, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_type = LOCKTAG_VIRTUALTRANSACTION, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_lockmethodid = DEFAULT_LOCKMETHOD)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define SET_LOCKTAG_OBJECT(locktag,dboid,classoid,objoid,objsubid) \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ((locktag).locktag_field1 = (dboid), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field2 = (classoid), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field3 = (objoid), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field4 = (objsubid), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_type = LOCKTAG_OBJECT, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_lockmethodid = DEFAULT_LOCKMETHOD)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define SET_LOCKTAG_ADVISORY(locktag,id1,id2,id3,id4) \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ((locktag).locktag_field1 = (id1), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field2 = (id2), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field3 = (id3), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field4 = (id4), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_type = LOCKTAG_ADVISORY, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_lockmethodid = USER_LOCKMETHOD)</font></div></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>