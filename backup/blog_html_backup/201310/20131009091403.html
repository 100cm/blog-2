<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap Statement types</h2>
	<h5 id="">2013-10-09 9:14:03&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013997490563/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>本文要讲的是systemtap中的语句类型, 例如在循环中使用的break, continue, 在handler中使用的next, 函数中使用的return, 等.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Statement types</font></div><div><font size="2"   >Statements enable procedural control flow within functions and probe handlers.&nbsp;</font></div><div><font size="2"   >The total number of statements executed in response to any single probe event is limited to MAXACTION, which defaults to 1000.</font></div><p></p></pre></div><div>前面讲systemtap安全性的时候提到过, 一个事件的handler中能执行多少条语句是有限制的, 做这样的限制主要因为大多数事件是同步事件, handler执行时间太长会对性能造成严重影响.</div><div>handler中能执行多少条语句是MAXACTION决定的, 默认是1000. 使用stap -D参数控制.</div><div>详见 :&nbsp;</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201381021752228/"   >http://blog.163.com/digoal@126/blog/static/163877040201381021752228/</a></div><div><br></div><div><span style="line-height: 28px;"   >6.1 break and continue</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Use break or continue to exit or iterate the innermost nesting loop statement, such as within a while, for, or foreach statement.&nbsp;</font></div><div><font size="2"   >The syntax and semantics are the same as those used in C.</font></div><p></p></pre></div><div>退出或者继续循环的用法类似C.</div><div>举例 :&nbsp;</div><div>break结束当前循环.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global a;&nbsp;</font></div><div><font size="2"   >probe begin&nbsp;</font></div><div><font size="2"   >{for(i=0; i&lt;15; i++)&nbsp;</font></div><div><font size="2"   >&nbsp; {if (i%2 == 1) break;&nbsp;<span style="line-height: 28px;"   >a[i]="digoal".sprint(i)};&nbsp;</span></font></div><div><span style="line-height: 28px;"   ><font size="2"   >foreach(x in a)&nbsp;</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >&nbsp; println(a[x]);&nbsp;</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >exit()}'</font></span></div><div><font size="2"   >输出 :&nbsp;</font></div><div><font size="2"   >digoal0</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >continue继续当前循环, 但不执行continue后面的语句.</span></div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div><div style="line-height: 28px;"   ><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global a;&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >probe begin&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >{for(i=0; i&lt;15; i++)&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; {if (i%2 == 1) continue;&nbsp;<span style="line-height: 28px;"   >a[i]="digoal".sprint(i)};&nbsp;</span></font></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >foreach(x in a)&nbsp;</font></span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >&nbsp; println(a[x]);&nbsp;</font></span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >exit()}'</font></span></div></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >输出 :&nbsp;</font></span></div><div><font size="2"   >digoal0</font></div><div><font size="2"   >digoal2</font></div><div><font size="2"   >digoal4</font></div><div><font size="2"   >digoal6</font></div><div><font size="2"   >digoal8</font></div><div><font size="2"   >digoal10</font></div><div><font size="2"   >digoal12</font></div><div><font size="2"   >digoal14</font></div><p></p></pre></div></div></div><div><br></div><div>6.2 try/catch</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Use try/catch to handle most kinds of run-time errors within the script instead of aborting the probe handler in progress.&nbsp;</font></div><div><font size="2"   >The semantics are similar to C++ in that try/catch blocks may be nested.&nbsp;</font></div><div><font size="2"   >The error string may be captured by optionally naming a variable which is to receive it.</font></div><p></p></pre></div><div>一般情况下, 如果handler执行到出错的语句, 将退出整个stap.&nbsp;</div><div>stap中允许的错误次数和一个安全参数(MAXERRORS)有关. 默认为0,&nbsp;<span style="line-height: 28px;"   >which means that the first error&nbsp;</span><span style="line-height: 28px;"   >will exit the script.</span></div><div>详见 :&nbsp;</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201381021752228/"   >http://blog.163.com/digoal@126/blog/static/163877040201381021752228/</a></div><div><span style="line-height: 28px;"   >使用try和catch可以捕获错误, 在catch中处理异常, 然后继续执行.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >try {&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp;/* do something */</font></div><div><font size="2"   >&nbsp; &nbsp;/* trigger error like kread(0), or divide by zero, or error("foo") */</font></div><div><font size="2"   >} catch (msg) { /* omit (msg) entirely if not interested */</font></div><div><font size="2"   >&nbsp; &nbsp;/* println("caught error ", msg) */</font></div><div><font size="2"   >&nbsp; &nbsp;/* handle error */</font></div><div><font size="2"   >}</font></div><div><font size="2"   >/* execution continues */</font></div><p></p></pre></div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'probe begin {</font></div><div><font size="2"   >try {a="hello"; error("emulate error.")}</font></div><div><font size="2"   >catch(a) {println("Error msg: ", a)}</font></div><div><font size="2"   >println("continue")</font></div><div><font size="2"   >exit()</font></div><div><font size="2"   >}'</font></div><div><font size="2"   >Error msg: emulate error.</font></div><div><font size="2"   >continue</font></div><p></p></pre></div><div>catch的错误消息并不是前面的变量a, 而是错误消息的标准输出. 如果是其他错误, 则是其他错误的信息.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'probe begin {</font></div><div><font size="2"   >try {a=1; a=a/0}</font></div><div><font size="2"   >catch(msg) {println("Error msg: ", msg)}</font></div><div><font size="2"   >println("continue")</font></div><div><font size="2"   >exit()</font></div><div><font size="2"   >}'</font></div><div><font size="2"   >Error msg: division by 0</font></div><div><font size="2"   >continue</font></div><p></p></pre></div><div>另外要注意的是, 尽量不要使用重名变量, 例如上面这个例子的msg, 如果替换成a会报错.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'probe begin {</font></div><div><font size="2"   >try {a=1; a=a/0}</font></div><div><font size="2"   >catch(a) {println("Error msg: ", a)} &nbsp; &nbsp;</font></div><div><font size="2"   >println("continue")</font></div><div><font size="2"   >exit()</font></div><div><font size="2"   >}'</font></div><div><font size="2"   >semantic error: type mismatch (string vs. long): identifier 'a' at &lt;input&gt;:3:7</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: catch(a) {println("Error msg: ", a)}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >semantic error: type was first inferred here (long): identifier 'a' at :2:6</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: try {a=1; a=a/0}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div><p></p></pre></div><div><br></div><div>6.3 delete</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >delete removes an ARRAY element.</font></div><div><font size="2"   >The value will no longer be available, and subsequent iterations will not report the element.&nbsp;</font></div><div><font size="2"   >It is not an error to delete an element that does not exist.&nbsp;</font></div><p></p></pre></div><div>delete可以用于删除数组的元素或者整个数组. 删除一个不存在的元素不会报错, 但是删除一个不存在的数组会报错.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'probe begin {delete a; exit()}'</font></div><div><font size="2"   >semantic error: unresolved array in delete statement: identifier 'a' at &lt;input&gt;:1:21</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: probe begin {delete a; exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div><p></p></pre></div><div>删除一个未初始化的数组报错</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global a; probe begin {delete a; exit()}'</font></div><div><font size="2"   >semantic error: unresolved type : identifier 'a' at &lt;input&gt;:1:31</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global a; probe begin {delete a; exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >semantic error: unresolved type : identifier 'a' at :1:8</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global a; probe begin {delete a; exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div><p></p></pre></div><div>删除一个已初始化的数组不会报错, 以下两个命令都不会报错.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global a; probe begin {a[1]="digoal"; delete a; exit()}'</font></div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global a; probe begin {a[1]="digoal"; delete a[1]; delete a; exit()}'</font></div><p></p></pre></div><div>如果数组有多个索引, 那么必须填写完全的索引值.</div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 28px;"   ><font size="2"   >The following statement removes from ARRAY the element specified by the index tuple.&nbsp;</font></span></div><div><font size="2"   >delete ARRAY[INDEX1, INDEX2, ...]</font></div><div><font size="2"   >The following syntax removes all elements from ARRAY:</font></div><div><font size="2"   >delete ARRAY</font></div><p></p></pre></div><div>举例 :&nbsp;</div><div>如下a[1,2,3]这个元素要删除的话必须使用delete a[1,2,3], 而不能使用a[1]来删除.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global a; probe begin {a[1,2,3]="digoal"; delete a[1]; delete a; exit()}'</font></div><div><font size="2"   >semantic error: inconsistent arity (3 vs 1): identifier 'a' at &lt;input&gt;:1:50</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global a; probe begin {a[1,2,3]="digoal"; delete a[1]; delete a; exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >semantic error: arity 3 first inferred here: identifier 'a' at :1:24</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global a; probe begin {a[1,2,3]="digoal"; delete a[1]; delete a; exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div><p></p></pre></div><div>一下可以正常执行 :&nbsp;</div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global a; probe begin {a[1,2,3]="digoal"; delete a[1,2,3]; delete a; exit()}'</font></div></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >数组的索引可以想象成K-V中的key (同时还有主键的意思), 数组元素的值就是k-v中的value.</span></div></div><div><span style="line-height: 28px;"   >删除数组的元素, 并不只是把这个元素初始化, 同时也会抹去这个索引. 例如一下a[1,2,3]也被抹去了 :&nbsp;</span></div><div><span style="line-height: 28px;"   ><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global a; probe begin {a[1,2,3]=100; a[1,2,2]=101; delete a[1,2,3]; foreach([x,y,z] in a) println(a[x,y,z]); exit()}'</font></div><div><font size="2"   >101</font></div><p></p></pre></div><div>如果只是清除它的值(int归0), 应该输出0 和 101;</div><div>在下一篇将数组结构的时候, 会了解到在stap中数组不是动态分配空间的, 而是提前分配空间的(类似 hash 表), 所以这里说的清除并不是清除占用的内存空间, 仅仅是初始化了 . 即使delete a, 也不会回收a占用的空间.</div></span></div><div><br></div><div><span style="line-height: 28px;"   >delete还可以用于</span><span style="line-height: 28px;"   >标量变量, 统计变量存储的值.</span></div><div><span style="line-height: 28px;"   >标量的值清除后, 整型为0, 字符串为null (""), 统计类型则回到初始空的状态.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >The following statement removes the value of SCALAR.&nbsp;</font></div><div><font size="2"   >Integers and strings are cleared to zero and null ("") respectively, while statistics are reset to their initial empty state.</font></div><div><font size="2"   >delete SCALAR</font></div><p></p></pre></div><div>举例 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'probe begin {a=10; b="digoal"; delete a; delete b; println(a); println(b); exit()}'</font></div><div><font size="2"   >0</font></div><p></p></pre></div><div>统计类型, 清除后为空, 所以delete s1后输出@max等会报错.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 00001 -e 'global s1; probe begin {for(i=0; i&lt;100; i++) s1 &lt;&lt;&lt; i; printf("%d,%d,%d,%d,%d\n", @count(s1), @max(s1), @min(s1), @avg(s1), @sum(s1)); delete s1; printf("%d,%d,%d,%d,%d\n", @count(s1), @max(s1), @min(s1), @avg(s1), @sum(s1));exit()}'</font></div><div><font size="2"   >Pass 5: starting run.</font></div><div><font size="2"   >ERROR: empty aggregate near identifier '@max' at &lt;input&gt;:1:186</font></div><div><font size="2"   >100,99,0,49,4950</font></div><div><font size="2"   >WARNING: Number of errors: 1, skipped probes: 0</font></div><div><font size="2"   >WARNING: /usr/bin/staprun exited with status: 1</font></div><div><font size="2"   >Pass 5: run completed in 0usr/20sys/304real ms.</font></div><div><font size="2"   >Pass 5: run failed. &nbsp;Try again with another '--vp 00001' option.</font></div><p></p></pre></div><div><br></div><div>6.4 EXP (expression)</div><pre class="prettyprint"   ><p></p><div><font size="2"   >An expression executes a string- or integer-valued expression and discards the value.</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >表达式, 如</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >1+1</font></div><div><font size="2"   >a+b</font></div><p></p></pre></div><div><br></div><div>6.5 for 循环</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >General syntax:</font></div><div><font size="2"   >for (EXP1; EXP2; EXP3) STMT</font></div><div><font size="2"   >The for statement is similar to the for statement in C.&nbsp;</font></div><div><font size="2"   >The for expression executes EXP1 as initialization.&nbsp;</font></div><div><font size="2"   >While EXP2 is non-zero, it executes STMT, then the iteration expression EXP3.</font></div><p></p></pre></div><div><br></div><div>6.6 foreach&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >General syntax:</font></div><div><font size="2"   >foreach (VAR in ARRAY) STMT</font></div><div><font size="2"   >The foreach statement loops over each element of a named global array, assigning the current key to VAR.&nbsp;</font></div><div><font size="2"   >The array must not be modified within the statement.&nbsp;</font></div><p></p></pre></div><div>每次循环将指派数组的索引给VAR变量. 例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin { arr1["i1"]=1; arr1["i2"]=2; foreach(x in arr1) printf("index: %s, value:%d \n", x, arr1[x]); exit()}'</font></div><div><font size="2"   >index: i1, value:1&nbsp;</font></div><div><font size="2"   >index: i2, value:2</font></div><p></p></pre></div><div><span style="line-height: 28px;"   ># 为了减少handler执行时间, 在foreach循环中, 数组元素不允许被修改.</span></div><div>例如:&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global a,i; probe kernel.function("icmp_echo") {a[i++]=1;} probe end {foreach (x in a) {a[x]=2; println(a[x])}}'</font></div><div><font size="2"   >semantic error: variable 'a' modified during 'foreach' iteration: identifier 'a' at &lt;input&gt;:1:89</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global a,i; probe kernel.function("icmp_echo") {a[i++]=1;} probe end {foreach (x in a) {a[x]=2; println(a[x])}}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div><p></p></pre></div><div><br></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >If you add a single plus (+) or minus (-) operator after the VAR or the ARRAY identifier,&nbsp;</font></div><div><font size="2"   >the iteration order will be sorted by the ascending or descending index or value.</font></div><div><span style="line-height: 28px;"   ><font size="2"   >Use a sorting suffix on at most one VAR or ARRAY identifier.</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   ><br></font></span></div><div><div style="line-height: 28px; font-family: Arial, Helvetica, sans-serif; white-space: normal;"   ><span style="line-height: 28px;"   ><font size="2"   >The following statement behaves the same as the first example, except it is used when an array is indexed with a tuple of keys.&nbsp;</font></span></div><div style="line-height: 28px; font-family: Arial, Helvetica, sans-serif; white-space: normal;"   ><font size="2"   >foreach ([VAR1, VAR2, ...] in ARRAY) STMT</font></div></div><p></p></pre></div><div>在VAR或者ARRAY后加上符号加或减可以对索引值或者元素值进行排序.&nbsp;</div><div>注意不能同时对索引和元素进行排序. 如: foreach (x+ in arr1+) 是错误的.&nbsp;<span style="line-height: 28px;"   >foreach([x-,y+] in arr1)</span><span style="line-height: 28px;"   >&nbsp;也是错误的.</span></div><div>例子 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin { arr1["i1", "x2"]=1; arr1["i2", "x1"]=2; foreach([x-,y] in arr1) printf("index: %s,%s, value:%d \n", x, y, arr1[x,y]); exit()}'</font></div><div><font size="2"   >index: i2,x1, value:2&nbsp;</font></div><div><font size="2"   >index: i1,x2, value:1&nbsp;</font></div></div><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin { arr1["i1", "x2"]=1; arr1["i2", "x1"]=2; foreach([x,y-] in arr1) printf("index: %s,%s, value:%d \n", x, y, arr1[x,y]); exit()}'</font></div><div><font size="2"   >index: i1,x2, value:1&nbsp;</font></div><div><font size="2"   >index: i2,x1, value:2&nbsp;</font></div></div><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin { arr1["i1", "x2"]=1; arr1["i2", "x1"]=2; foreach([x,y] in arr1-) printf("index: %s,%s, value:%d \n", x, y, arr1[x,y]); exit()}'</font></div><div><font size="2"   >index: i2,x1, value:2&nbsp;</font></div><div><font size="2"   >index: i1,x2, value:1&nbsp;</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >错误例子 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin { arr1["i1", "x2"]=1; arr1["i2", "x1"]=2; foreach([x,y-] in arr1-) printf("index: %s,%s, value:%d \n", x, y, arr1[x,y]); exit()}'</font></div><div><font size="2"   >parse error: multiple sort directives</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; saw: operator '-' at &lt;input&gt;:1:90</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;source: global arr1; probe begin { arr1["i1", "x2"]=1; arr1["i2", "x1"]=2; foreach([x,y-] in arr1-) printf("index: %s,%s, value:%d \n", x, y, arr1[x,y]); exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >1 parse error.</font></div><div><font size="2"   >Pass 1: parse failed. &nbsp;Try again with another '--vp 1' option.</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin { arr1["i1", "x2"]=1; arr1["i2", "x1"]=2; foreach([x-,y+] in arr1) printf("index: %s,%s, value:%d \n", x, y, arr1[x,y]); exit()}'</font></div><div><font size="2"   >parse error: multiple sort directives</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; saw: operator '+' at &lt;input&gt;:1:81</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;source: global arr1; probe begin { arr1["i1", "x2"]=1; arr1["i2", "x1"]=2; foreach([x-,y+] in arr1) printf("index: %s,%s, value:%d \n", x, y, arr1[x,y]); exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div><font size="2"   >1 parse error.</font></div><div><font size="2"   >Pass 1: parse failed. &nbsp;Try again with another '--vp 1' option.</font></div></div><p></p></pre></div><div>合并赋值的用法, 可以同时取出索引和元素值.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >You can combine the first and second syntax to capture both the full tuple and the keys at the same time as follows.</font></div><div><font size="2"   >foreach (VAR = [VAR1, VAR2, ...] in ARRAY) STMT</font></div><p></p></pre></div><div>例子 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin { arr1["i1", "x2"]=1; arr1["i2", "x1"]=2; foreach(var=[x,y] in arr1-) printf("index: %s,%s, value:%d \n", x, y, var); exit()}'</font></div><div><font size="2"   >index: i2,x1, value:2&nbsp;</font></div><div><font size="2"   >index: i1,x2, value:1&nbsp;</font></div><p></p></pre></div><div><br></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >The following statement is the same as the first example, except that the limit keyword limits the number of loop iterations to EXP times.&nbsp;</font></div><div><font size="2"   >EXP is evaluated once at the beginning of the loop.</font></div><div><font size="2"   >foreach (VAR in ARRAY limit EXP) STMT</font></div><p></p></pre></div><div>使用limit, 限制元素个数的输出, EXP只执行一次, 在循环开始前执行.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin {v1=0; arr1["i1", "x2"]=1; arr1["i2", "x1"]=2; foreach(var=[x,y] in arr1- limit v1+1) printf("index: %s,%s, value:%d \n", x, y, var); exit()}'</font></div><div><font size="2"   >index: i2,x1, value:2&nbsp;</font></div><p></p></pre></div><div>例如输出元素的最大值.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin { arr1["i1", "x2"]=1; arr1["i2", "x1"]=2; foreach(var=[x,y] in arr1- limit 1) printf("index: %s,%s, value:%d \n", x, y, var); exit()}'</font></div><div><font size="2"   >index: i2,x1, value:2&nbsp;</font></div><p></p></pre></div><div><br></div><div>6.7 if</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >General syntax:</font></div><div><font size="2"   >if (EXP) STMT1 [ else STMT2 ]</font></div><div><font size="2"   >The if statement compares an integer-valued EXP to zero.&nbsp;</font></div><div><font size="2"   >It executes the first STMT if non-zero, or the second STMT if zero.</font></div><div><font size="2"   >The if command has the same syntax and semantics as used in C.</font></div><p></p></pre></div><div>EXP非零真, 0假.</div><div><br></div><div>6.8 next</div><pre class="prettyprint"   ><p></p><div><font size="2"   >The next statement returns immediately from the enclosing probe handler.</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >next用于退出当前正在处理的handler, 例如 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'probe begin{print("hello\n"); next; print(" world\n")}'</font></div><div><font size="2"   >hello</font></div><p></p></pre></div><div>因为begin只会触发一次, 所以next后就无任何反应了.</div><div>对于可能多次触发的探针, 例子 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'probe kernel.function("icmp_echo") {printf("hello\n"); next; printf(" world\n")}'</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >在另一个窗口开一个ping</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 soft_bak]# ping 127.0.0.1</font></div><div><font size="2"   >PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.</font></div><div><font size="2"   >64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.037 ms</font></div><div><font size="2"   >64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.023 ms</font></div><div><font size="2"   >64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.028 ms</font></div><div><font size="2"   >64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.021 ms</font></div><p></p></pre></div><div>stap输出 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >hello</font></div><div><font size="2"   >hello</font></div><div><font size="2"   >hello</font></div><div><font size="2"   >hello</font></div><p></p></pre></div></div><div><br></div><div>6.9 ; (null statement)</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >General syntax:</font></div><div><font size="2"   >statement1</font></div><div><font size="2"   >;</font></div><div><font size="2"   >statement2</font></div><div><font size="2"   >The semicolon represents the null statement, or do nothing.&nbsp;</font></div><div><font size="2"   >It is useful as an optional separator between statements to improve syntax error detection and to handle certain grammar ambiguities.</font></div><p></p></pre></div><div>分号表示空语句, 一般用于将两个语句隔开, 减少误解析的可能性.</div><div><br></div><div>6.10 return</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >General syntax:</font></div><div><font size="2"   >return EXP</font></div><div><font size="2"   >The return statement returns the EXP value from the enclosing function.&nbsp;</font></div><div><font size="2"   >If the value of the function is not returned, then a return statement is not needed, and the function will have a special unknown type with no return value.</font></div><p></p></pre></div><div>函数的返回值使用return EXP语法 .</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'function add(x,y) {return x+y} probe begin {printf("%d\n", add($1,$2)); exit()}' 10 9</font></div><div><font size="2"   >19</font></div><p></p></pre></div><div>如果函数中没有return, 那么将返回unknown类型例如.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'function add(x,y) {} probe begin {printf("%d\n", add($1,$2)); exit()}' 10 9</font></div><div><font size="2"   >WARNING: side-effect-free function 'add': identifier 'add' at &lt;input&gt;:1:10</font></div><div><font size="2"   >&nbsp;source: function add(x,y) {} probe begin {printf("%d\n", add($1,$2)); exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >0</font></div><p></p></pre></div><div><br></div><div>6.11 { } (statement block)</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >This is the statement block with zero or more statements enclosed within brackets.&nbsp;</font></div><div><font size="2"   >The following is the general syntax:</font></div><div><font size="2"   >{ STMT1 STMT2 ... }</font></div><div><font size="2"   >The statement block executes each statement in sequence in the block.&nbsp;</font></div><div><font size="2"   >Separators or terminators are generally not necessary between statements.&nbsp;</font></div><div><font size="2"   >The statement block uses the same syntax and semantics as in C.</font></div><p></p></pre></div><div>语句块使用语法 :&nbsp;</div><div><span style="line-height: 28px;"   >{ STMT1 STMT2 ... }</span></div><div><span style="line-height: 28px;"   >例如在条件判断中要使用多个语句的话, 需要用到语句块.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'probe begin {if ($1&gt;100) {printf("hello "); printf("%d\n",$1);}; exit();}' 101</font></div><div><font size="2"   >hello 101</font></div><p></p></pre></div><div><br></div><div>6.12 while</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >General syntax:</font></div><div><font size="2"   >while (EXP) STMT</font></div><div><font size="2"   >The while statement uses the same syntax and semantics as in C.&nbsp;</font></div><div><font size="2"   >In the statement above, while the integer-valued EXP evaluates to non-zero, the parser will execute STMT.</font></div><p></p></pre></div></div><div>while循环 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'probe begin {while(i&lt;10) {println(i); i++}; exit()}'</font></div><div><font size="2"   >0</font></div><div><font size="2"   >1</font></div><div><font size="2"   >2</font></div><div><font size="2"   >3</font></div><div><font size="2"   >4</font></div><div><font size="2"   >5</font></div><div><font size="2"   >6</font></div><div><font size="2"   >7</font></div><div><font size="2"   >8</font></div><div><font size="2"   >9</font></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" rel="nofollow" href="https://sourceware.org/systemtap/langref/Statement_types.html"   >https://sourceware.org/systemtap/langref/Statement_types.html</a></div><div>2.&nbsp;<a style="line-height: 28px;" rel="nofollow" href="https://sourceware.org/systemtap/langref/SystemTap_overview.html#sub:SystemTap-safety"   >https://sourceware.org/systemtap/langref/SystemTap_overview.html#sub:SystemTap-safety</a></div><div>3.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/163877040201381021752228/"   >http://blog.163.com/digoal@126/blog/static/163877040201381021752228/</a></div></div>
	</div>
</div>
</body>
</html>