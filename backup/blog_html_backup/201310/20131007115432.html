<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap Syscall probes</h2>
	<h5 id="">2013-10-07 11:54:32&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201397112435514/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><pre class="prettyprint"   ><p></p><div><font size="2"   >The syscall.* aliases define several hundred probes. They use the following syntax:</font></div><div><font size="2"   >syscall.NAME</font></div><div><font size="2"   >syscall.NAME.return</font></div><div><font size="2"   >Generally, two probes are defined for each normal system call as listed in the syscalls(2) manual page: one for entry and one for return. System calls that never return do not have a corresponding .return probe.</font></div><div><font size="2"   >系统调用探针, 与mark或trace探针不同, 系统调用探针需要安装debuginfo包.</font></div><div><font size="2"   >系统调用探针一般定义了入口和返回两个别名. 分别代表探针在函数入口和函数返回的代码位置.&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Each probe alias defines a variety of variables. Look at the tapset source code to find the most reliable source of variable definitions. Generally, each variable listed in the standard manual page is available as a script-level variable.&nbsp;</font></div><div><font size="2"   >For example, syscall.open exposes file name, flags, and mode.&nbsp;</font></div><div><font size="2"   >syscall探针的定义在tapset中可以找到, 如</font></div><div><div style="line-height: 23px;"   ><font size="2"   >/usr/share/systemtap/tapset/syscalls.stp</font></div><div style="line-height: 23px;"   ><font size="2"   >/usr/share/systemtap/tapset/syscalls2.stp</font></div><div style="line-height: 23px;"   ><font size="2"   >/usr/share/systemtap/tapset/syscalls_cfg_trunc.stp</font></div></div><div style="line-height: 23px;"   ><font size="2"   >本文例子中用到的chmod探针源码</font></div><div><div><font size="2"   ># chmod ______________________________________________________</font></div><div><font size="2"   ># long sys_chmod(const char __user * filename, mode_t mode)</font></div><div><font size="2"   >probe syscall.chmod = kernel.function("sys_chmod").call</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "chmod"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; path = user_string($filename)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; mode = $mode</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%s, %#o", user_string_quoted($filename), mode)</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe syscall.chmod.return = kernel.function("sys_chmod").return</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "chmod"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; retstr = return_str(1, $return)</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   >从这个syscall的定义我们也就知道为什么syscall探针需要debuginfo包了, 因为它实际上是DWARF-based探针的别名.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >In addition, a standard suite of variables is available at most aliases, as follows:</font></div><div><font size="2"   >argstr: A pretty-printed form of the entire argument list, without parentheses.</font></div><div><font size="2"   >name: The name of the system call.</font></div><div><font size="2"   >retstr: For return probes, a pretty-printed form of the system call result.</font></div><div><font size="2"   >syscall定义中一般有这些变量, argstr, name, retstr. 分别代表已经转换好的可读变量, 系统调用的名字, 返回值.</font></div><div><font size="2"   >例如chmod中定义的本地变量如下 :&nbsp;</font></div><div><div style="line-height: 23px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "chmod"</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; path = user_string($filename)</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; mode = $mode</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%s, %#o", user_string_quoted($filename), mode)</font></div></div><div style="line-height: 23px;"   ><font size="2"   >chmod.return定义的本地变量如下 :&nbsp;</font></div><div style="line-height: 23px;"   ><div style="line-height: 23px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "chmod"</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; retstr = return_str(1, $return)</font></div><div style="line-height: 23px;"   ><font size="2"   ><br></font></div></div><div><font size="2"   >Not all probe aliases obey all of these general guidelines. Please report exceptions that you encounter as a bug.</font></div><p></p></pre></div><div>举例 :&nbsp;</div><div>列出当前系统支持的系统调用探针 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -l 'syscall.**'|less</font></div><div><font size="2"   >syscall.accept</font></div><div><font size="2"   >syscall.accept.return</font></div><div><font size="2"   >syscall.access</font></div><div><font size="2"   >syscall.access.return</font></div><div><font size="2"   >syscall.acct</font></div><div><font size="2"   >syscall.acct.return</font></div><div><font size="2"   >syscall.add_key</font></div><div><font size="2"   >syscall.add_key.return</font></div><div><font size="2"   >syscall.adjtimex</font></div><div><font size="2"   >syscall.adjtimex.return</font></div><div><font size="2"   >syscall.alarm</font></div><div><font size="2"   >syscall.alarm.return</font></div><div><font size="2"   >syscall.arch_prctl</font></div><div><font size="2"   >syscall.arch_prctl.return</font></div><div><font size="2"   >syscall.bdflush</font></div><div><font size="2"   >syscall.bdflush.return</font></div><div><font size="2"   >syscall.bind</font></div><div><font size="2"   >syscall.bind.return</font></div><div><font size="2"   >syscall.brk</font></div></div><div><font size="2"   >... 略</font></div><p></p></pre></div><div>syscall.chmod探针使用举例 :&nbsp;</div><div>例如要给以下文件修改权限 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# ll</font></div><div><font size="2"   >total 84900</font></div><div><font size="2"   >-rw------- &nbsp;1 root root &nbsp; &nbsp; 1849 Oct 21 &nbsp;2011 anaconda-ks.cfg</font></div><p></p></pre></div><div>开启探针 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'probe syscall.chmod { printf ("%s\n%s\n%s\n", name, $$vars, argstr) }'</font></div><div></div><p></p></pre><div><span style="line-height: 23px;"   >修改权限 :&nbsp;</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# chmod 777 anaconda-ks.cfg&nbsp;</font></div><div></div><p></p></pre><div><span style="line-height: 23px;"   >探针handler输出, $$vars输出了在syscall.chmod中定义的本地变量, 而argstr则输出了已经转换好的可读信息(</span>sprintf("%s, %#o", user_string_quoted($filename), mode)<span style="line-height: 23px;"   >) :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >chmod</font></div><div><font size="2"   >filename=0x140110b0 mode=0x1ff</font></div><div><font size="2"   >"anaconda-ks.cfg", 0777</font></div><p></p></pre></div></div><div>如果我们单独输出$filename$$, 显然mode没有正确转换, 因为它使用了<span style="line-height: 23px;"   >user_string_quoted来转换</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'probe syscall.chmod { printf ("%s\n%s\n", $filename$$, $mode$$) }'</font></div><div><font size="2"   >"anaconda-ks.cfg"</font></div><div><font size="2"   >511</font></div><p></p></pre></div><div>user_string_quoted这个函数的解释参考</div><div><a rel="nofollow" href="https://sourceware.org/systemtap/tapsets/API-user-string-quoted.html"   >https://sourceware.org/systemtap/tapsets/API-user-string-quoted.html</a></div><div><br></div><div>从源码中我们也能看到chmod.return中没有定义argstr本地变量, 所以会有如下告警 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'probe syscall.chmod.return { printf ("%s\n%s\n%s\n%s\n", name, $$vars, argstr, retstr) }'</font></div><div><font size="2"   >WARNING: never-assigned local variable 'argstr' (alternatives: _dwarf_tvar_tid _dwarf_tvar_$vars_3_tmp name retstr _dwarf_tvar_$vars_3 _dwarf_tvar_$vars_3_ctr): identifier 'argstr' at &lt;input&gt;:1:72</font></div><div><font size="2"   >&nbsp;source: probe syscall.chmod.return { printf ("%s\n%s\n%s\n%s\n", name, $$vars, argstr, retstr) }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >chmod</font></div><div><font size="2"   >filename=0x58d80b0 mode=0x1ff</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >0</font></div><p></p></pre></div><div><br></div><div><div>在未安装debuginfo包的系统中使用syscall探针报错如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-40 ~]# stap -e 'probe syscall.chmod.return { printf ("%s\n%s\n%s\n%s\n", name, $$vars, argstr, retstr) }'</font></div><div><font size="2"   >semantic error: while resolving probe point: identifier 'kernel' at /usr/share/systemtap/tapset/syscalls.stp:300:30</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: probe syscall.chmod.return = kernel.function("sys_chmod").return</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >semantic error: missing x86_64 kernel/module debuginfo under '/lib/modules/2.6.18-274.el5/build'</font></div><div><font size="2"   >semantic error: while resolving probe point: identifier 'syscall' at &lt;input&gt;:1:7</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: probe syscall.chmod.return { printf ("%s\n%s\n%s\n%s\n", name, $$vars, argstr, retstr) }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >semantic error: no match</font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div><div><font size="2"   >Missing separate debuginfos, use: debuginfo-install kernel-2.6.18-274.el5.x86_64</font></div><p></p></pre></div></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 23px;" target="_blank" rel="nofollow" href="https://sourceware.org/systemtap/langref/Probe_points.html"   >https://sourceware.org/systemtap/langref/Probe_points.html</a></div><div>2. man syscalls</div><div>3. stap -l 'syscall.**'</div><div>4.&nbsp;/usr/share/systemtap/tapset/syscalls.stp</div><div>/usr/share/systemtap/tapset/syscalls2.stp</div><div>/usr/share/systemtap/tapset/syscalls_cfg_trunc.stp</div></div>
	</div>
</div>
</body>
</html>