<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap: PostgreSQL probe, USE @var("varname") or $varname get all local and global variables</h2>
	<h5 id="">2013-10-18 11:12:56&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013918103315822/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>在stap脚本中, 从探针处获取变量的值方法比较多, 可以获取的变量值包括本地变量, 全局变量, 甚至其他代码中的全局变量等.</div><div>具体的获取变量的用法可参考 :&nbsp;</div><div><a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/16387704020138113455697/"   >http://blog.163.com/digoal@126/blog/static/16387704020138113455697/</a></div><div><span style="line-height: 28px;"   >使用@var("varname")这种方法, 可以查看的变量值包括PostgreSQL探针所在函数内的本地变量, 全局变量, 甚至Linux内核中的全局变量等.</span></div><div>在PostgreSQL探针中,&nbsp;<span style="line-height: 28px;"   >@var("varname"), $varname</span><span style="line-height: 28px;"   >使用起来非常方便, 适合没有定义参数的探针, 或者定义了参数但是因为各种原因无法获取正常获取值的(如BUG:&nbsp;</span><a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/163877040201391622459221/"   >http://blog.163.com/digoal@126/blog/static/163877040201391622459221/</a><span style="line-height: 28px;"   >)</span></div><div>使用举例, 获取全局变量的值 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-150 ~]# stap -D MAXSTRINGLEN=100000 --vp 10000 -e 'probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("checkpoint__done") {printf("ckpt_bufs_written:%d, ckpt_segs_added:%d, ckpt_segs_removed:%d, ckpt_segs_recycled:%d, NBuffers:%d\n", @var("CheckpointStats")-&gt;ckpt_bufs_written, @var("CheckpointStats")-&gt;ckpt_segs_added, @var("CheckpointStats")-&gt;ckpt_segs_removed, @var("CheckpointStats")-&gt;ckpt_segs_recycled, @var("NBuffers"))}'</font></div><div><font size="2"   >Pass 1: parsed user script and 96 library script(s) using 151984virt/25256res/2116shr/23892data kb, in 240usr/20sys/251real ms.</font></div><div><font size="2"   >ckpt_bufs_written:0, ckpt_segs_added:0, ckpt_segs_removed:0, ckpt_segs_recycled:0, NBuffers:262144</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-150 ~]# stap -D MAXSTRINGLEN=100000 --vp 10000 -e 'probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("chepoint__done") {printf("%s\n", @var("CheckpointStats")$$)}'</font></div><div><font size="2"   >Pass 1: parsed user script and 96 library script(s) using 152044virt/25248res/2116shr/23952data kb, in 240usr/20sys/252real ms.</font></div><div><font size="2"   >{.ckpt_start_t=435378988941962, .ckpt_write_t=435378988942012, .ckpt_sync_t=435378988946510, .ckpt_sync_end_t=435378988946514, .ckpt_end_t=435378988947800, .ckpt_bufs_written=0, .ckpt_segs_added=0, .ckpt_segs_removed=0, .ckpt_segs_recycled=0, .ckpt_sync_rels=0, .ckpt_longest_sync=0, .ckpt_agg_sync_time=0}</font></div></div><p></p></pre></div></div><div><span style="line-height: 28px;"   >使用举例, 获取本地变量的值 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-150 ~]# stap -D MAXSTRINGLEN=100000 --vp 10000 -e 'probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("chepoint__done") {printf("%s\n", $$locals$$)}'</font></div><div><font size="2"   >Pass 1: parsed user script and 96 library script(s) using 152048virt/25248res/2116shr/23956data kb, in 240usr/20sys/251real ms.</font></div><div><font size="2"   >shutdown=? checkPoint={.redo=28883378856, .ThisTimeLineID=1, .PrevTimeLineID=1, .fullPageWrites='\001', .nextXidEpoch=0, .nextXid=130667542, .nextOid=57491, .nextMulti=1, .nextMultiOffset=0, .oldestXid=1800, .oldestXidDB=1, .oldestMulti=1, .oldestMultiDB=1, .time=1382063813, .oldestActiveXid=130667542} recptr=28883379016 Insert={.PrevRecord=28883378912, .curridx=0, .currpage=0x7fc1b2ae4000, .currpos="", .RedoRecPtr=28883378856, .forcePageWrites='\000', .fullPageWrites='\001', .exclusiveBackup='\000', .nonExclusiveBackups=0, .lastBackupStart=0} rdata={.data="¨b?1", .len=72, .buffer=0, .buffer_std='\001', .next=0x0} freespace=? _logSegNo=? vxids={.backendId=?, .localTransactionId=?} nvxids=0 __func__="CreateCheckPoint"</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-150 ~]# stap -D MAXSTRINGLEN=100000 --vp 10000 -e 'probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("chepoint__done") {printf("%s\n", @var("Insert")$$)}'</font></div><div><font size="2"   >Pass 1: parsed user script and 96 library script(s) using 152048virt/25248res/2116shr/23956data kb, in 240usr/10sys/251real ms.</font></div><div><font size="2"   >{.PrevRecord=28883379392, .curridx=0, .currpage=0x7fc1b2ae4000, .currpos="", .RedoRecPtr=28883379336, .forcePageWrites='\000', .fullPageWrites='\001', .exclusiveBackup='\000', .nonExclusiveBackups=0, .lastBackupStart=0}</font></div></div><p></p></pre></div><div>也可以使用$varname的形式获取</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-150 ~]# stap -D MAXSTRINGLEN=100000 --vp 10000 -e 'probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("chepoint__done") {printf("%s\n", $Insert$$)}'</font></div><div><font size="2"   >Pass 1: parsed user script and 96 library script(s) using 152040virt/25244res/2116shr/23948data kb, in 240usr/10sys/252real ms.</font></div><div><font size="2"   >{.PrevRecord=28883381312, .curridx=0, .currpage=0x7fc1b2ae4000, .currpos="", .RedoRecPtr=28883381256, .forcePageWrites='\000', .fullPageWrites='\001', .exclusiveBackup='\000', .nonExclusiveBackups=0, .lastBackupStart=0}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-150 ~]# stap -D MAXSTRINGLEN=100000 --vp 10000 -e 'probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("checkpoint__done") {printf("%s\n", $NBuffers$$)}'</font></div><div><font size="2"   >Pass 1: parsed user script and 96 library script(s) using 152044virt/25244res/2116shr/23952data kb, in 240usr/10sys/252real ms.</font></div><div><font size="2"   >262144</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >[root@db-172-16-3-150 ~]# stap -D MAXSTRINGLEN=100000 --vp 10000 -e 'probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("chepoint__done") {printf("%s\n", $CheckpointStats$$)}'</font></div><div><font size="2"   >Pass 1: parsed user script and 96 library script(s) using 152048virt/25248res/2116shr/23956data kb, in 230usr/10sys/252real ms.</font></div><div><font size="2"   >{.ckpt_start_t=435381006985866, .ckpt_write_t=435381006985916, .ckpt_sync_t=435381006990623, .ckpt_sync_end_t=435381006990626, .ckpt_end_t=435381006991807, .ckpt_bufs_written=0, .ckpt_segs_added=0, .ckpt_segs_removed=0, .ckpt_segs_recycled=0, .ckpt_sync_rels=0, .ckpt_longest_sync=0, .ckpt_agg_sync_time=0}</font></div></div><p></p></pre></div><div>对于没有参数的预定义探针, 要获取所在函数的本地变量或者参数值 :&nbsp;</div><div>例如<span style="line-height: 28px;"   >query__plan__start探针 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >src/backend/tcop/postgres.c</font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Generate a plan for a single already-rewritten query.</font></div><div><font size="2"   >&nbsp;* This is a thin wrapper around planner() and takes the same parameters.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >PlannedStmt *</font></div><div><font size="2"   >pg_plan_query(Query *querytree, int cursorOptions, ParamListInfo boundParams)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *plan;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Utility commands have no plans. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (querytree-&gt;commandType == CMD_UTILITY)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Planner must have a snapshot in case it calls user-defined functions. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(ActiveSnapshotSet());</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_PLAN_START();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >[root@db-172-16-3-150 ~]# stap -D MAXSTRINGLEN=100000 --vp 10000 -e '</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start") {</font></div><div><font size="2"   >&nbsp; printf("%s\n", $querytree$$)</font></div><div><font size="2"   >}'</font></div><div><font size="2"   >Pass 1: parsed user script and 96 library script(s) using 152044virt/25244res/2116shr/23952data kb, in 240usr/10sys/252real ms.</font></div><div><font size="2"   >{.type=700, .commandType=1, .querySource=0, .queryId=0, .canSetTag='\001', .utilityStmt=0x0, .resultRelation=0, .hasAggs='\000', .hasWindowFuncs='\000', .hasSubLinks='\000', .hasDistinctOn='\000', .hasRecursive='\000', .hasModifyingCTE='\000', .hasForUpdate='\000', .cteList=0x0, .rtable=0x1e079d8, .jointree=0x1e13578, .targetList=0x1e0aa38, .returningList=0x0, .groupClause=0x0, .havingQual=0x0, .windowClause=0x0, .distinctClause=0x0, .sortClause=0x1e134f8, .limitOffset=0x0, .limitCount=0x0, .rowMarks=0x0, .setOperations=0x0, .constraintDeps=0x0}</font></div><p></p></pre></div><div><br></div><div>[参考]</div>1.&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020138113455697/"   >http://blog.163.com/digoal@126/blog/static/16387704020138113455697/</a><div>2.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/163877040201391622459221/"   >http://blog.163.com/digoal@126/blog/static/163877040201391622459221/</a></div><div>3.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/163877040201391883345365/"   >http://blog.163.com/digoal@126/blog/static/163877040201391883345365/</a></div><div><span style="line-height: 28px;"   >4. man stapprobes</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp; &nbsp;CONTEXT VARIABLES</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Many of the source-level context variables, such as function parameters, locals, globals visible in the &nbsp;compi-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;lation &nbsp;unit, may be visible to probe handlers. &nbsp;They may refer to these variables by prefixing their name with</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;"$" within the scripts. &nbsp;In addition, a special syntax allows limited traversal of &nbsp;structures, &nbsp;pointers, &nbsp;and</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;arrays. &nbsp;More syntax allows pretty-printing of individual variables or their groups. &nbsp;See also @cast.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;$var &nbsp; refers to an in-scope variable "var". &nbsp;If it’s an integer-like type, it will be cast to a 64-bit int for</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; systemtap script use. &nbsp;String-like pointers (char *) may be copied to systemtap string values using &nbsp;the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kernel_string or user_string functions.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;@var("varname")</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; an alternative syntax for $varname</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;@var("varname@src/file.c")</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refers &nbsp;to &nbsp;the global (either file local or external) variable varname defined when the file src/file.c</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; was compiled. The CU in which the variable is resolved is the first CU in the module of the probe &nbsp;point</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which &nbsp;matches &nbsp;the &nbsp;given &nbsp;file &nbsp;name &nbsp;at &nbsp;the &nbsp;end &nbsp;and &nbsp;has &nbsp;the &nbsp;shortest file name path (e.g. given</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @var("foo@bar/baz.c") and CUs with file name paths src/sub/module/bar/baz.c and src/bar/baz.c the second</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CU will be chosen to resolve the (file) global variable foo</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;$var-&gt;field traversal via a structure’s or a pointer’s field. &nbsp;This</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; generalized &nbsp;indirection &nbsp;operator &nbsp;may be repeated to follow more levels. &nbsp;Note that the . &nbsp;operator is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not used for plain structure members, only -&gt; for both purposes. &nbsp;(This is because "." is &nbsp;reserved &nbsp;for</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string concatenation.)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;$return</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is available in return probes only for functions that are declared with a return value.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;$var[N]</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexes into an array. &nbsp;The index given with a literal number or even an arbitrary numeric expression.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;A number of operators exist for such basic context variable expressions:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;$$vars expands to a character string that is equivalent to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf("parm1=%x ... parmN=%x var1=%x ... varN=%x",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parm1, ..., parmN, var1, ..., varN)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;for &nbsp;each &nbsp;variable &nbsp;in scope at the probe point. &nbsp;Some values may be printed as =? &nbsp;if their run-time location</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;cannot be found.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;$$locals</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expands to a subset of $$vars for only local variables.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;$$parms</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expands to a subset of $$vars for only function parameters.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;$$return</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is available in return probes only. &nbsp;It expands to a string that is equivalent &nbsp;to &nbsp;sprintf("return=%x",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $return) if the probed function has a return value, or else an empty string.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;&amp; $EXPR</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expands to the address of the given context variable expression, if it is addressable.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;@defined($EXPR)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expands &nbsp;to 1 or 0 iff the given context variable expression is resolvable, for use in conditionals such</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; as</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @defined($foo-&gt;bar) ? $foo-&gt;bar : 0</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;$EXPR$ expands to a string with all of $EXPR’s members, equivalent to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf("{.a=%i, .b=%u, .c={...}, .d=[...]}",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$EXPR-&gt;a, $EXPR-&gt;b)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;$EXPR$$</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expands to a string with all of $var’s members and submembers, equivalent to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf("{.a=%i, .b=%u, .c={.x=%p, .y=%c}, .d=[%i, ...]}",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $EXPR-&gt;a, $EXPR-&gt;b, $EXPR-&gt;c-&gt;x, $EXPR-&gt;c-&gt;y, $EXPR-&gt;d[0])</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;For ".return" probes, context variables other than the "$return" value itself are only available for the &nbsp;func-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;tion call parameters. &nbsp;The expressions evaluate to the entry-time values of those variables, since that is when</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;a snapshot is taken. &nbsp;Other local variables are not generally accessible, since by the time a &nbsp;".return" &nbsp;probe</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;hits, the probed function will have already returned.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Arbitrary &nbsp;entry-time &nbsp;expressions can also be saved for ".return" probes using the @entry(expr) operator. &nbsp;For</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;example, one can compute the elapsed time of a function:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; probe kernel.function("do_filp_open").return {</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println( get_timeofday_us() - @entry(get_timeofday_us()) )</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>