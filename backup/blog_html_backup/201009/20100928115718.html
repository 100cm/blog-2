<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Using Mview over tables having FKs - Consideration</h2>
	<h5 id="">2010-09-28 11:57:18&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201082811414052/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">主外键在数据库的应用当中比较常见，它就像一把双刃剑，用得好的话会给你的系统带来坚固的约束关系。用得不好或者滥用的话会给维护和排错带来非常大的麻烦。<div>最近刚好接到一起数据复制的需求，主库和MV库面向的应用类型差不多，MV库上面连接的应用需要访问主库的一张表，现状是有专门的人员负责对这份数据进行写入，比较繁琐，所以考虑使用MV的方式来进行数据的共享。</div><div>其中要求同步的是一张表，但是这张表在备库有被其他表的FK关联到，经过调查，相关联的几个表在主库也是存在的，并且具有同样的约束条件。</div><div>考虑到主外键的约束关系如果单独同步可能导致违反约束，所以的话有主外键约束的表必须放在一个事务进行同步。</div><div>经过了解，实际上这几个表的数据都是从主库来的，并且可以放在一起同步。总算可以继续做下去。</div><div>那么在MV节点需要对这几个关联到的约束进行属性调整：</div><div>1. 初始约束校验，后续约束校验。</div><div>2. 开启允许延缓检查属性。</div><div>3. 调整为事务结束校验。</div><div>（从非延缓到延缓需要重建约束）</div><div>联机文档原文:</div><div><p><span>DEFERRABLE Cla<a id="sthref2935" name="sthref2935" rel="nofollow"  ></a><a id="sthref2936" name="sthref2936" rel="nofollow"  ></a>use<a id="sthref2937" name="sthref2937" rel="nofollow"  ></a><a id="sthref2938" name="sthref2938" rel="nofollow"  ></a><a id="sthref2939" name="sthref2939" rel="nofollow"  ></a>&nbsp;</span>The <code>DEFERRABLE</code> and <code>NOT</code>  <code>DEFERRABLE</code> parameters indicate whether or not, in subsequent  transactions, constraint checking can be deferred until the end of the  transaction using the <code>SET</code> <code>CONSTRAINT</code>(<code>S</code>)  statement. If you omit this clause, then the default is <code>NOT</code>  <code>DEFERRABLE</code>.</p> <ul> <li> <p>Specify <code>NOT</code> <code>DEFERRABLE</code> to indicate that in  subsequent transactions you cannot use the <code>SET</code>  <code>CONSTRAINT</code>[<code>S</code>] clause to defer checking of this  constraint until the transaction is committed. The checking of a  <code>NOT</code> <code>DEFERRABLE</code> constraint can never be deferred to the  end of the transaction.</p> <p>If you declare a new constraint <code>NOT</code> <code>DEFERRABLE</code>,  then it must be valid at the time the <code>CREATE</code> <code>TABLE</code> or  <code>ALTER</code> <code>TABLE</code> statement is committed or the statement  will fail.</p></li> <li> <p>Specify <code>DEFERRABLE</code> to indicate that in subsequent transactions  you can use the <code>SET</code> <code>CONSTRAINT</code>[<code>S</code>] clause  to defer checking of this constraint until after the transaction is committed.  This setting in effect lets you disable the constraint temporarily while making  changes to the database that might violate the constraint until all the changes  are complete.</p></li></ul> <p>You cannot alter the deferrability of a constraint. That is, whether you  specify either of these parameters, or make the constraint <code>NOT</code>  <code>DEFERRABLE</code> implicitly by specifying neither of them, you cannot  specify this clause in an <code>ALTER</code> <code>TABLE</code> statement. You  must drop the constraint and re-create it.</p><p></p><p><span>INITIALLY Clause&nbsp;</span>The <code>INITIALLY</code>  clause establishes the default checking behavior for constraints that are  <code>DEFERRABLE</code>. The <code>INITIALLY</code> setting can be overridden by  a <code>SET</code> <code>CONSTRAINT</code>(<code>S</code>) statement in a  subsequent transaction.</p> <ul> <li> <p><span><a id="sthref2942" name="sthref2942" rel="nofollow"  ></a><a id="sthref2943" name="sthref2943" rel="nofollow"  ></a></span>Specify <code>INITIALLY</code> <code>IMMEDIATE</code>  to indicate that Oracle should check this constraint at the end of each  subsequent SQL statement. If you do not specify <code>INITIALLY</code> at all,  then the default is <code>INITIALLY</code> <code>IMMEDIATE</code>.</p> <p>If you declare a new constraint <code>INITIALLY</code>  <code>IMMEDIATE</code>, then it must be valid at the time the  <code>CREATE</code> <code>TABLE</code> or <code>ALTER</code> <code>TABLE</code>  statement is committed or the statement will fail.</p></li> <li> <p><span><a id="sthref2944" name="sthref2944" rel="nofollow"  ></a></span>Specify  <code>INITIALLY</code> <code>DEFERRED</code> to indicate that Oracle should  check this constraint at the end of subsequent transactions.</p></li></ul> <p>This clause is not valid if you have declared the constraint to be  <code>NOT</code> <code>DEFERRABLE</code>, because a <code>NOT</code>  <code>DEFERRABLE</code> constraint is automatically <code>INITIALLY</code>  <code>IMMEDIATE</code> and cannot ever be <code>INITIALLY</code>  <code>DEFERRED</code>.</p><p></p><p><span>ENABLE Clause&nbsp;</span>Specify <code>ENABLE</code> if you  want the constraint to be applied to the data in the table.</p> <p>If you enable a unique or primary key constraint, and if no index exists on  the key, then Oracle Database creates a unique index. Unless you specify  <code>KEEP INDEX</code> when subsequently disabling the constraint, this index  is dropped and the database rebuilds the index every time the constraint is  reenabled.</p> <p>You can also avoid rebuilding the index and eliminate redundant indexes by  creating new primary key and unique constraints initially disabled. Then create  (or use existing) nonunique indexes to enforce the constraint. Oracle does not  drop a nonunique index when the constraint is disabled, so subsequent  <code>ENABLE</code> operations are facilitated.</p> <ul> <li> <p><span><a id="sthref2946" name="sthref2946" rel="nofollow"  ></a></span><code>ENABLE</code> <code>VALIDATE</code> specifies  that all old and new data also complies with the constraint. An enabled  validated constraint guarantees that all data is and will continue to be  valid.</p> <p>If any row in the table violates the integrity constraint, the constraint  remains disabled and Oracle returns an error. If all rows comply with the  constraint, Oracle enables the constraint. Subsequently, if new data violates  the constraint, Oracle does not execute the statement and returns an error  indicating the integrity constraint violation.</p> <p>If you place a primary key constraint in <code>ENABLE</code>  <code>VALIDATE</code> mode, the validation process will verify that the primary  key columns contain no nulls. To avoid this overhead, mark each column in the  primary key <code>NOT</code> <code>NULL</code> before entering data into the  column and before enabling the primary key constraint of the table.</p></li> <li> <p><span><a id="sthref2947" name="sthref2947" rel="nofollow"  ></a></span><code>ENABLE</code> <code>NOVALIDATE</code> ensures  that all new DML operations on the constrained data comply with the constraint.  This clause does not ensure that existing data in the table complies with the  constraint and therefore does not require a table lock.</p></li></ul> <p>If you specify neither <code>VALIDATE</code> nor <code>NOVALIDATE</code>, the  default is <code>VALIDATE</code>.</p> <p>If you change the state of any single constraint from <code>ENABLE</code>  <code>NOVALIDATE</code> to <code>ENABLE</code> <code>VALIDATE</code>, the  operation can be performed in parallel, and does not block reads, writes, or  other DDL operations.</p><a id="sthref2948" name="sthref2948" rel="nofollow"  ></a> <p><span>Restriction on the ENABLE Clause&nbsp;</span>You cannot  enable a foreign key that references a disabled unique or primary key.</p><p>MV的操作就不用说了，把关联的MV放到一个刷新组搞定。</p></div></div>
	</div>
</div>
</body>
</html>