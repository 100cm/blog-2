<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">【转接】Pg::Snapshot USAGE</h2>
	<h5 id="">2010-09-30 11:23:41&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402010830112341992/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><P>上面那篇PostgreSQL MVIEW的USAGE:</P>
<P>As database superuser (often postgres, but check for your system), do the following:<BR><BR><BIG style="TEXT-DECORATION: underline;"><BIG><SPAN style="FONT-WEIGHT: bold;">INSTALLATION</SPAN></BIG></BIG><BR><BR>1.&nbsp; Load PL/Perlu into your database.&nbsp; See the createlang documents for details on how to do this;<BR><BR>2.&nbsp; Make shure that DBI is installed on your Perl system and that the DBD of the database you choose is also installed;<BR><BR>3. Edit the <SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">Makefile.sh</SPAN> file and change the KEY variable to a better "secret" value and the <SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">BASE_SCHEMA</SPAN> variable to where the base(internal)&nbsp;Pg::Snapshot tables should be placed. Also remember to setup the remaining variables like SUPERUSER.<BR><BR>4.&nbsp; On the PostgreSQL::Snapshots root, execute:<BR><FONT face=NSimsun><CODE>&nbsp;&nbsp;&nbsp; <SPAN style="FONT-WEIGHT: bold;"># ./Makefile.sh</SPAN></CODE><BR><BR></FONT>5. Load the database driver:<BR>&nbsp;&nbsp; &nbsp;- On PostgreSQL:<BR><FONT face=NSimsun><CODE>&nbsp;&nbsp; &nbsp;<SPAN style="FONT-WEIGHT: bold;"># psql -d &lt;database&gt; -h &lt;host&gt; -U &lt;user&gt; -f ./drivers/pg/snapshot.sql</SPAN></CODE><BR></FONT>&nbsp;&nbsp; &nbsp;- On Oracle, inside SQL+:<BR><FONT face=NSimsun><CODE>&nbsp;&nbsp; &nbsp;<SPAN style="FONT-WEIGHT: bold;">SQL&gt; @./drivers/oracle/snapshot.sql</SPAN></CODE><BR><BR></FONT>6.&nbsp; Load the pgsnapshots.sql file:<BR><FONT face=NSimsun><CODE>&nbsp;&nbsp; &nbsp;<SPAN style="FONT-WEIGHT: bold;"># psql -d &lt;database&gt; -h &lt;host&gt; -U &lt;user&gt; -f pgsnapshots.sql</SPAN></CODE><BR><BR></FONT>7. Allow the access from your workstation(or remote server) to one or more master tables on the current database:<BR>&nbsp;&nbsp; &nbsp;- Inside psql, conected as POSTGRES user:<BR><FONT face=NSimsun><CODE>&nbsp; &nbsp;&nbsp;<SPAN style="FONT-WEIGHT: bold;">db=# select snapshot_do('&lt;key&gt;', 'ALLOW', '&lt;masterschema&gt;', '&lt;mastername&gt;', '&lt;ip&gt;');</SPAN></CODE><BR></FONT>&nbsp;&nbsp; &nbsp;- or inside SQL+, conected as SYS user:<BR><FONT face=NSimsun><CODE>&nbsp; &nbsp; <SPAN style="FONT-WEIGHT: bold;">SQL&gt; begin</SPAN><BR style="FONT-WEIGHT: bold;"><SPAN style="FONT-WEIGHT: bold;">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; snapshot_do('</SPAN><SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">&lt;key&gt;</SPAN><SPAN style="FONT-WEIGHT: bold;">', 'ALLOW', '</SPAN><SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">&lt;masterschema&gt;</SPAN><SPAN style="FONT-WEIGHT: bold;">', '</SPAN><SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">&lt;mastername&gt;</SPAN><SPAN style="FONT-WEIGHT: bold;">', '</SPAN><SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">&lt;ip&gt;</SPAN><SPAN style="FONT-WEIGHT: bold;">');</SPAN><BR style="FONT-WEIGHT: bold;"><SPAN style="FONT-WEIGHT: bold;">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;</SPAN><BR style="FONT-WEIGHT: bold;"><SPAN style="FONT-WEIGHT: bold;">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /</SPAN></CODE><BR></FONT>&nbsp;&nbsp; &nbsp;Where:<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">&lt;key&gt;</SPAN> is the "secret" value placed on the KEY variable inside the Makefile.sh file.<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">&lt;masterschema&gt;</SPAN> is the schema name of the master table you wish to allow access to<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">&lt;mastername&gt;</SPAN> is the name of the master table you wish to allow access to<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">&lt;ip&gt;</SPAN> is the IP address of your workstation/server to whom you wish to give access<BR><BR>8.&nbsp; Use the underlying methods aka functions as needed.<BR><BR><BIG style="TEXT-DECORATION: underline;"><BIG><SPAN style="FONT-WEIGHT: bold;">AVAILABLE FUNCTIONS</SPAN></BIG></BIG><BR><BR><BIG><SPAN style="FONT-WEIGHT: bold;">1. create_dblink (implementation of "CREATE DBLINK")</SPAN></BIG><BR>&nbsp;&nbsp; &nbsp;This function creates a link between databases. It takes the name of the DBLINK to be created and the necessary parameters do establish the remote connection.<BR>&nbsp;&nbsp; &nbsp;<BR>&nbsp;&nbsp; &nbsp;<SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">Syntax</SPAN><SPAN style="FONT-STYLE: italic;">:</SPAN><BR>&nbsp;&nbsp; &nbsp;<SPAN style="COLOR: rgb(0,0,153); FONT-WEIGHT: bold;">create_dblink(dblinkname text, datasource text, username text, password text, attributes text)</SPAN><BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">dblinkname</SPAN>: name of the DBLINK to be created<BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">datasource</SPAN>: Perl:DBI CONNECTION string to the remote database<BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">username</SPAN>: NAME of the remote database user<BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">password</SPAN>: PASSWORD of the remote database user<BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">attributes</SPAN>: connection ATTRIBUTES, like AutoCommit, RaiseErrors, etc.<BR><BR><BIG><SPAN style="FONT-WEIGHT: bold;">2. drop_dblink (implementation of "DROP DBLINK")</SPAN></BIG><BR>&nbsp;&nbsp; &nbsp;This function removes a link between databases taking only the DBLink name as a parameter.<BR>&nbsp;&nbsp; &nbsp;<BR>&nbsp;&nbsp; &nbsp;<SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">Syntax</SPAN>:<BR>&nbsp;&nbsp; &nbsp;<SPAN style="COLOR: rgb(0,0,153); FONT-WEIGHT: bold;">drop_dblink(dblinkname text)</SPAN><BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">dblinkname</SPAN>: name of the DBLINK to be removed<BR><BR><BIG style="FONT-WEIGHT: bold;">3. create_snapshot (implementation of "CREATE SNAPSHOT" or "CREATE MATERIALIZED VIEW")</BIG><BR>&nbsp;&nbsp; &nbsp;This function creates a materialized view or snapshot based on a query. The query can be referencing a database link or not.<BR>&nbsp;&nbsp; &nbsp;<BR>&nbsp;&nbsp; &nbsp;<SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">Syntax</SPAN>:<BR>&nbsp;&nbsp; &nbsp;<SPAN style="COLOR: rgb(0,0,153); FONT-WEIGHT: bold;">create_snapshot(schemaname text, snapshotname text, query text, dblink text, refresh_method text, prebuilt_table text)</SPAN><BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">schemaname</SPAN>: name of the schema where the snapshot will be created<BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">snapshotname</SPAN>: name of the snapshot to be created<BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">query</SPAN>: SQL query that will be executed at the remote database and which result will fill the snapshot<BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">dblink</SPAN>: optional parameter that take the name of the DBLink to be used. If the value is NULL, the query will be executed by the local database.<BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">refresh_method</SPAN>: can be "COMPLETE", "FAST" or "FORCE".<BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">prebuilt_table</SPAN>: name of the prebuilt table, on the same schema of the snapshot, over which the snapshot will be created (existing&nbsp;data&nbsp;are&nbsp;preserved).&nbsp;This is an optional parameter.<BR><BR>&nbsp;&nbsp;<SPAN style="COLOR: rgb(255,0,0); FONT-WEIGHT: bold;"> &nbsp;IMPORTANT: the table will not be filled by this function.</SPAN><BR><BR><BIG><SPAN style="FONT-WEIGHT: bold;">4. drop_snapshot (implementation of "DROP SNAPSHOT" or "DROP MATERIALIZED VIEW")</SPAN></BIG><BR>&nbsp;&nbsp; &nbsp;This function removes a materialized view or snapshot taking the schema name and the snapshot name as parameters.<BR>&nbsp;&nbsp; &nbsp;<BR>&nbsp;&nbsp; &nbsp;<SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">Syntax</SPAN>:<BR>&nbsp;&nbsp; &nbsp;<SPAN style="COLOR: rgb(0,0,153); FONT-WEIGHT: bold;">drop_snapshot (schemaname text, snapshotname text)</SPAN><BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">schemaname</SPAN>: name of the schema where the snapshot resides<BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">snapshotname</SPAN>: name of the snapshot to be removed<BR><BR><BIG><SPAN style="FONT-WEIGHT: bold;">5. create_snapshot_log (implementation of "CREATE MATERIALIZED VIEW LOG" or "CREATE SNAPSHOT LOG")</SPAN></BIG><BR>&nbsp;&nbsp; &nbsp;This function creates a log table bound to a master table. This log table allows the creation of fast refreshing snapshot(FAST REFRESH).<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">Syntax</SPAN>:<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: rgb(0,0,153); FONT-WEIGHT: bold;">create_snapshot_log (schemaname text, mastername text, withwhat text)</SPAN><BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="TEXT-DECORATION: underline;">schemaname</SPAN>: name of the schema where the master table resides<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="TEXT-DECORATION: underline;">mastername</SPAN>: name of the master table<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="TEXT-DECORATION: underline;">withwhat</SPAN>: use the this clause to indicate whether the snapshot log should record the primary key, the rowid, or both the primary key and rowid when rows in the master are updated. This clause also specifies whether the snapshot records filter columns, which are non-primary-key columns referenced by subquery snapshots. The syntax is:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) "PRIMARY KEY": indicate that the primary key of all rows updated in the master table should be recorded in the snapshot log;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) "OID": indicate that the OID of all rows updated in the master table should be recorded in the snapshot log;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3) "(&lt;filter-columns&gt;)" : a parenthesis-delimited comma-separated list that specifies the filter columns to be recorded in the snapshot log. For fast-refreshable primary-key snapshots defined with subqueries, all filter columns referenced by the defining subquery must be recorded in the snapshot log;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4) Any combination of the above in any order.<BR><BR><BIG><SPAN style="FONT-WEIGHT: bold;">6. drop_snapshot_log (implementation of "DROP MATERIALIZED VIEW LOG" or "DROP SNAPSHOT LOG")</SPAN></BIG><BR>&nbsp;&nbsp;&nbsp;&nbsp;This function removes a log table previously bound to a master table.<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">Syntax</SPAN>:<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: rgb(0,0,153); FONT-WEIGHT: bold;">drop_snapshot_log (schemaname text, mastername text)</SPAN><BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="TEXT-DECORATION: underline;">schemaname</SPAN>: name of the schema where the master table resides<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="TEXT-DECORATION: underline;">mastername</SPAN>: name of the master table<BR><BR><BIG><SPAN style="FONT-WEIGHT: bold;">5. refresh_snapshot (implementation of "DBMS_SNAPSHOTS.REFRESH")</SPAN></BIG><BR>&nbsp;&nbsp; &nbsp;This function refreshes the data on a materialized view or snapshot taking the schema and snapshot names as parameters.<BR>&nbsp;&nbsp; &nbsp;<BR>&nbsp;&nbsp; &nbsp;<SPAN style="FONT-STYLE: italic; FONT-WEIGHT: bold;">Syntax</SPAN>:<BR>&nbsp;&nbsp; &nbsp;<SPAN style="COLOR: rgb(0,0,153); FONT-WEIGHT: bold;">refresh_snapshot (schemaname text, snapshotname text)</SPAN><BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">schemaname</SPAN>: name of the schema where the snapshot resides<BR>&nbsp;&nbsp; &nbsp;<SPAN style="TEXT-DECORATION: underline;">snapshotname</SPAN>: name of the snapshot to be refreshed<BR></P></div>
	</div>
</div>
</body>
</html>