<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL prepared statement: SPI_prepare, prepare|execute COMMAND, PL/pgsql STYLE: custom & generic plan cache</h2>
	<h5 id="">2012-12-24 21:54:33&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012112452432251/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>prepare statement的目的是让同样的SQL(无参数)或者类似的SQL(有参数)仅需要一次parse analyse, 因此减少了parse analyse的次数.&nbsp;</div><div>同时使用 prepare statement 还有一个功效是cache plan, 也就是说plan的次数也可以减少 .&nbsp;</div><div>本文介绍一下PostgreSQL的几种prepare statement的方法, 仅供参考.</div><div>首先是SPI, 如SPI_prepare, 语法如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >SPIPlanPtr SPI_prepare(const char * command, int nargs, Oid * argtypes)</font></div><div><div><font size="2"  >const char * command</font></div><div><font size="2"  >command string</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int nargs</font></div><div><font size="2"  >number of input parameters ($1, $2, etc.)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Oid * argtypes</font></div><div><font size="2"  >pointer to an array containing the OIDs of the data types of the parameters</font></div></div><p></p></pre></div><div>注意SPI_prepare返回结果类型为SPIPlanPtr(一个指针), 用于存储plan的数据.</div><div>作为SPI_execute_plan或者SPI_execute_plan_with_paramlist 的参数传入 :&nbsp;</div><div>因为SPI_prepare可以带参数(nargs,argtypes), 也可以不带参数. SPI_execute_plan建立generic plan 对带参数和不带参数的处理方式略有不同, 见下面的解释.</div><div>1, 无参数的情况.</div><div><div><pre class="prettyprint"  ><p><font size="2"  >If no parameters are defined, a generic plan will be created at the first use of SPI_execute_plan, and used for all subsequent executions as well.&nbsp;</font></p></pre></div><div>2, 有参数的情况.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >If there are parameters, the first few uses of SPI_execute_plan will generate custom plans that are specific to the supplied parameter values.&nbsp;</font></div><div><font size="2"  >After enough uses of the same prepared statement, SPI_execute_plan will build a generic plan, and if that is not too much more expensive than the custom plans, it will start using the generic plan instead of re-planning each time.</font></div><p></p></pre></div><div>另外就是使用如果使用prepared 游标, SPI_prepare_cursor, 可以指定flag. 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >If this default behavior is unsuitable, you can alter it by passing the CURSOR_OPT_GENERIC_PLAN or CURSOR_OPT_CUSTOM_PLAN flag to SPI_prepare_cursor, to force use of generic or custom plans respectively.</font></p></pre></div></div><div>这些flag来自src/include/nodes/parsenodes.h&nbsp;</div><div><div><pre class="prettyprint"  ><div><font size="2"  >/* ----------------------</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Declare Cursor Statement</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Note: the "query" field of DeclareCursorStmt is only used in the raw grammar</font></div><div><font size="2"  >&nbsp;* output. &nbsp; &nbsp; &nbsp;After parse analysis it's set to null, and the Query points to the</font></div><div><font size="2"  >&nbsp;* DeclareCursorStmt, not vice versa.</font></div><div><font size="2"  >&nbsp;* ----------------------</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >#define CURSOR_OPT_BINARY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0001 &nbsp;/* BINARY */</font></div><div><font size="2"  >#define CURSOR_OPT_SCROLL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0002 &nbsp;/* SCROLL explicitly given */</font></div><div><font size="2"  >#define CURSOR_OPT_NO_SCROLL &nbsp; &nbsp;0x0004 &nbsp;/* NO SCROLL explicitly given */</font></div><div><font size="2"  >#define CURSOR_OPT_INSENSITIVE &nbsp;0x0008 &nbsp;/* INSENSITIVE */</font></div><div><font size="2"  >#define CURSOR_OPT_HOLD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0010 &nbsp;/* WITH HOLD */</font></div><div><font size="2"  >/* these planner-control flags do not correspond to any SQL grammar: */</font></div><div><font size="2"  >#define CURSOR_OPT_FAST_PLAN &nbsp; &nbsp;0x0020 &nbsp;/* prefer fast-start plan */</font></div><div><font size="2"  >#define CURSOR_OPT_GENERIC_PLAN 0x0040 &nbsp;/* force use of generic plan */</font></div><div><font size="2"  >#define CURSOR_OPT_CUSTOM_PLAN &nbsp;0x0080 &nbsp;/* force use of custom plan */</font></div><p></p></pre></div></div><div>SPI_prepare_cursor 用法 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >SPIPlanPtr SPI_prepare_cursor(const char * command, int nargs,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid * argtypes, int cursorOptions)</font></div><p></p></pre></div><div>PL/pgsql cache plan 实际上都是调用的SPI. 所以处理cache plan也分两种情况 (带参数和不带参数).</div><div>例如如果以下SQL在PL/pgSQL中执行 :&nbsp;</div><div>1. select id,info from test where id=$1; 这属于带参数的SQL语句.</div><div><span style="line-height: 22px;"  >所以SPI_prepare这条SQL, 当第一次用SPI_execute_plan执行后不会马上建立generic plan. 而需要有足够多次使用到同一个prepare statement后才会建立generic plan.&nbsp;</span></div><div><div style="line-height: 22px;"  >2. select id,info from test where id=1; 这属于不带参数的SQL语句.&nbsp;</div><div style="line-height: 22px;"  >所以SPI_prepare这条SQL, 当第一次用SPI_execute_plan执行后将会建立generic plan.</div></div><div><br></div><div>选择使用generic plan还是重新plan(custom plan), 用到这个函数 :&nbsp;</div><div>src/backend/utils/cache/plancache.c</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >00840 /*</font></div><div><font size="2"  >00841 &nbsp;* choose_custom_plan: choose whether to use custom or generic plan</font></div><div><font size="2"  >00842 &nbsp;*</font></div><div><font size="2"  >00843 &nbsp;* This defines the policy followed by GetCachedPlan.</font></div><div><font size="2"  >00844 &nbsp;*/</font></div><div><font size="2"  >00845 static bool</font></div><div><font size="2"  >00846 choose_custom_plan(CachedPlanSource *plansource, ParamListInfo boundParams)</font></div><div><font size="2"  >00847 {</font></div><div><font size="2"  >00848 &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp;avg_custom_cost;</font></div><div><font size="2"  >00849&nbsp;</font></div><div><font size="2"  >00850 &nbsp; &nbsp; /* Never any point in a custom plan if there's no parameters */</font></div><div><font size="2"  >00851 &nbsp; &nbsp; if (boundParams == NULL)</font></div><div><font size="2"  >00852 &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"  >00853&nbsp;</font></div><div><font size="2"  >00854 &nbsp; &nbsp; /* See if caller wants to force the decision */</font></div><div><font size="2"  >00855 &nbsp; &nbsp; if (plansource-&gt;cursor_options &amp; CURSOR_OPT_GENERIC_PLAN)</font></div><div><font size="2"  >00856 &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"  >00857 &nbsp; &nbsp; if (plansource-&gt;cursor_options &amp; CURSOR_OPT_CUSTOM_PLAN)</font></div><div><font size="2"  >00858 &nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"  >00859&nbsp;</font></div><div><font size="2"  >00860 &nbsp; &nbsp; /* Generate custom plans until we have done at least 5 (arbitrary) */</font></div><div><font size="2"  >00861 &nbsp; &nbsp; if (plansource-&gt;num_custom_plans &lt; 5)</font></div><div><font size="2"  >00862 &nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"  >00863&nbsp;</font></div><div><font size="2"  >00864 &nbsp; &nbsp; avg_custom_cost = plansource-&gt;total_custom_cost / plansource-&gt;num_custom_plans;</font></div><div><font size="2"  >00865&nbsp;</font></div><div><font size="2"  >00866 &nbsp; &nbsp; /*</font></div><div><font size="2"  >00867 &nbsp; &nbsp; &nbsp;* Prefer generic plan if it's less than 10% more expensive than average</font></div><div><font size="2"  >00868 &nbsp; &nbsp; &nbsp;* custom plan. &nbsp;This threshold is a bit arbitrary; it'd be better if we</font></div><div><font size="2"  >00869 &nbsp; &nbsp; &nbsp;* had some means of comparing planning time to the estimated runtime cost</font></div><div><font size="2"  >00870 &nbsp; &nbsp; &nbsp;* differential.</font></div><div><font size="2"  >00871 &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >00872 &nbsp; &nbsp; &nbsp;* Note that if generic_cost is -1 (indicating we've not yet determined</font></div><div><font size="2"  >00873 &nbsp; &nbsp; &nbsp;* the generic plan cost), we'll always prefer generic at this point.</font></div><div><font size="2"  >00874 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >00875 &nbsp; &nbsp; if (plansource-&gt;generic_cost &lt; avg_custom_cost * 1.1)</font></div><div><font size="2"  >00876 &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"  >00877&nbsp;</font></div><div><font size="2"  >00878 &nbsp; &nbsp; return true;</font></div><div><font size="2"  >00879 }</font></div><p></p></pre></div><div>从函数内容来看,&nbsp;</div><div>首先无绑定参数的情况使用generic plan, 因此函数返回false.</div><div>然后判断cursor_option是否包含CURSOR_OPT_GENERIC_PLAN和CURSOR_OPT_CUSTOM_PLAN. 直接返回true或false</div><div>然后判断num_custom_plans, 如果大于等于5则使用generic plan. 小于5则返回true.</div><div>最后如果上面都没有返回, 那么进入cost的判断. 如果plansource-&gt;generic_cost &lt; avg_custom_cost * 1.1 则选择generic plan.</div><div>generic_cost , total_custom_cost 和 num_custom_plans都记录在CachedPlanSource这个数据结构里面. 因此custom plan不是每次都产生, 而是通过以上函数来选择的. 每使用一次custom plan都会更新<span style="line-height: 22px;"  >total_custom_cost 和 num_custom_plans的</span>数据, 用作下次判断的依据.</div><div><br></div><div>下面举例说明一下第二种情况, 也就是有参数的情况 :&nbsp;</div><div>首先生成测试数据 :&nbsp;</div><div>测试表 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; create table test(id int, info text);</font></div><div><font size="2"  >CREATE TABLE</font></div><p></p></pre></div><div>测试数据 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=&gt; insert into test select 1,repeat(random()::text,10) from generate_series(1,500000);</font></div><div><font size="2"  >INSERT 0 500000</font></div></div><div><div><font size="2"  >digoal=&gt; insert into test values (2,'test');</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >digoal=&gt; select id,count(*) from test group by id;</font></div><div><font size="2"  >&nbsp;id | count &nbsp;</font></div><div><font size="2"  >----+--------</font></div><div><font size="2"  >&nbsp; 1 | 500000</font></div><div><font size="2"  >&nbsp; 2 | &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"  >(2 rows)</font></div></div><p></p></pre></div><div>索引 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; create index idx_test_1 on test(id);</font></div><div><font size="2"  >CREATE INDEX</font></div><p></p></pre></div><div><br></div><div>接下来使用PL/pgsql 的cache plan情况测试 :&nbsp;</div><div>PL/pgSQL的cache plan用法细节参见<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/plpgsql-implementation.html"  >http://www.postgresql.org/docs/9.2/static/plpgsql-implementation.html</a></div><div>创建函数 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >CREATE OR REPLACE FUNCTION digoal.f_immutable(i_id integer)</font></div><div><font size="2"  >&nbsp;RETURNS bigint</font></div><div><font size="2"  >&nbsp;LANGUAGE plpgsql</font></div><div><font size="2"  >&nbsp;STRICT IMMUTABLE</font></div><div><font size="2"  >AS $function$</font></div><div><font size="2"  >declare</font></div><div><font size="2"  >&nbsp; result bigint;</font></div><div><font size="2"  >begin</font></div><div><font size="2"  >&nbsp; select count(*) into result from digoal.test where id=i_id;</font></div><div><font size="2"  >&nbsp; return result;</font></div><div><font size="2"  >end;</font></div><div><font size="2"  >$function$;</font></div><p></p></pre></div><div><br></div><div>测试 :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; \timing</font></div><div><font size="2"  >Timing is on.</font></div><p></p></pre></div><div>注意这些SQL的执行耗时. 很明显的区分索引扫描和全表扫描.</div><div>使用PL/pgsql 封装的 prepared statement 在第一次执行后SPI_execute_plan并没有马上产生 generic plan.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select * from f_immutable(1);</font></div><div><font size="2"  >&nbsp;f_immutable&nbsp;</font></div><div><font size="2"  >-------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; 500000</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 148.080 ms</font></div><p></p></pre></div><div>因此第二次执行<span style="line-height: 22px;"  >f_immutable(2) 依然进行了plan , &nbsp;也就是用了custom plan.&nbsp;</span></div><div><span style="line-height: 22px;"  >因为1走了全表扫描, 2走了索引扫描.</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select * from f_immutable(2);</font></div><div><font size="2"  >&nbsp;f_immutable&nbsp;</font></div><div><font size="2"  >-------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 0.736 ms</font></div><p></p></pre></div></div><div>执行计划如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; explain analyze select count(*) from test where id=1;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >--------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=20637.01..20637.02 rows=1 width=0) (actual time=245.336..245.336 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..19387.01 rows=500001 width=0) (actual time=0.012..166.642 rows=500000 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rows Removed by Filter: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 245.384 ms</font></div><div><font size="2"  >(5 rows)</font></div><div><font size="2"  >Time: 246.075 ms</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=&gt; explain analyze select count(*) from test where id=2;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=1.41..1.42 rows=1 width=0) (actual time=0.031..0.031 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using idx_test_1 on test &nbsp;(cost=0.00..1.40 rows=1 width=0) (actual time=0.023..0.024 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = 2)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heap Fetches: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 0.083 ms</font></div><div><font size="2"  >(5 rows)</font></div><div><font size="2"  >Time: 0.772 ms</font></div><p></p></pre></div><div><br></div><div>那么如SPI_prepare所述, 同一个prepare statement被SPI_execute_plan多次使用后, 将会生成generic plan.</div><div>所以接下来我多次(这里选择5次) 调用 select * from f_immutable(1);</div><div>根据前面提到的choose_custom_plan函数, 5次后将会进入<span style="line-height: 22px;"  >plansource-&gt;generic_cost &lt; avg_custom_cost * 1.1</span><span style="line-height: 22px;"  >&nbsp;的判断.</span></div><div><span style="line-height: 22px;"  >因为前面5次的cost都一样, 所以存储在</span><span style="line-height: 22px;"  >plansource里的custom cost相关数值得出的custom cost平均值与generic_cost没有相差10%. 所以会走generic plan. 那就可以解释为什么第六次的SQL:&nbsp;</span><span style="line-height: 22px;"  >select * from f_immutable(2); 未走索引了.</span></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; \timing</font></div><div><font size="2"  >Timing is on.</font></div><div><font size="2"  >digoal=&gt; select * from f_immutable(1);</font></div><div><font size="2"  >&nbsp;f_immutable&nbsp;</font></div><div><font size="2"  >-------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; 500000</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 242.742 ms</font></div><div><font size="2"  >digoal=&gt; select * from f_immutable(1);</font></div><div><font size="2"  >&nbsp;f_immutable&nbsp;</font></div><div><font size="2"  >-------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; 500000</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 179.910 ms</font></div><div><font size="2"  >digoal=&gt; select * from f_immutable(1);</font></div><div><font size="2"  >&nbsp;f_immutable&nbsp;</font></div><div><font size="2"  >-------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; 500000</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 180.052 ms</font></div><div><font size="2"  >digoal=&gt; select * from f_immutable(1);</font></div><div><font size="2"  >&nbsp;f_immutable&nbsp;</font></div><div><font size="2"  >-------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; 500000</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 180.027 ms</font></div><div><font size="2"  >digoal=&gt; select * from f_immutable(1);</font></div><div><font size="2"  >&nbsp;f_immutable&nbsp;</font></div><div><font size="2"  >-------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; 500000</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 179.758 ms</font></div><p></p></pre></div><div>经过以上5次调用<span style="line-height: 22px;"  >select * from f_immutable(1);后,&nbsp;</span></div><div>所以下面把参数改成2, 也不走索引扫描了. 执行时间139毫秒.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select * from f_immutable(2);</font></div><div><font size="2"  >&nbsp;f_immutable&nbsp;</font></div><div><font size="2"  >-------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 139.941 ms</font></div><div><font size="2"  >digoal=&gt; select * from f_immutable(2);</font></div><div><font size="2"  >&nbsp;f_immutable&nbsp;</font></div><div><font size="2"  >-------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 139.994 ms</font></div><p></p></pre></div></div><div>将函数的strict改成stable和volatile测试的结果与上面一致, 因为和函数的volatile无关.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; alter function f_immutable(int) strict volatile;</font></div><div><font size="2"  >ALTER FUNCTION</font></div><div><font size="2"  >Time: 0.490 ms</font></div><div><font size="2"  >digoal=&gt; alter function f_immutable(int) strict stable;</font></div><div><font size="2"  >ALTER FUNCTION</font></div><div><font size="2"  >Time: 0.451 ms</font></div><p></p></pre></div><div>测试结果略.</div><div><br></div><div>接下来使用prepare SQL COMMAND进行测试 :&nbsp;</div><div>结果和PL/pgsql一致.</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; \timing</font></div><div><font size="2"  >Timing is on.</font></div><div><font size="2"  >digoal=&gt; prepare p_test(int) as select count(*) from test where id=$1;</font></div><div><font size="2"  >PREPARE</font></div><div><font size="2"  >Time: 1.154 ms</font></div><div><font size="2"  >digoal=&gt; explain analyze execute p_test(1);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >--------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=20637.01..20637.02 rows=1 width=0) (actual time=298.463..298.463 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..19387.01 rows=500001 width=0) (actual time=0.034..220.116 rows=500000 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rows Removed by Filter: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 298.580 ms</font></div><div><font size="2"  >(5 rows)</font></div><div><font size="2"  >Time: 299.951 ms</font></div><div><font size="2"  >digoal=&gt; explain analyze execute p_test(1);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >--------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=20637.01..20637.02 rows=1 width=0) (actual time=243.990..243.990 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..19387.01 rows=500001 width=0) (actual time=0.012..166.291 rows=500000 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rows Removed by Filter: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 244.040 ms</font></div><div><font size="2"  >(5 rows)</font></div><div><font size="2"  >Time: 244.800 ms</font></div><div><font size="2"  >digoal=&gt; explain analyze execute p_test(1);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >--------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=20637.01..20637.02 rows=1 width=0) (actual time=244.184..244.184 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..19387.01 rows=500001 width=0) (actual time=0.012..166.416 rows=500000 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rows Removed by Filter: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 244.235 ms</font></div><div><font size="2"  >(5 rows)</font></div><div><font size="2"  >Time: 244.817 ms</font></div><div><font size="2"  >digoal=&gt; explain analyze execute p_test(1);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >--------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=20637.01..20637.02 rows=1 width=0) (actual time=244.380..244.380 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..19387.01 rows=500001 width=0) (actual time=0.012..166.055 rows=500000 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rows Removed by Filter: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 244.432 ms</font></div><div><font size="2"  >(5 rows)</font></div><div><font size="2"  >Time: 245.028 ms</font></div><div><font size="2"  >digoal=&gt; explain analyze execute p_test(1);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >--------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=20637.01..20637.02 rows=1 width=0) (actual time=244.029..244.029 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..19387.01 rows=500001 width=0) (actual time=0.011..166.128 rows=500000 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rows Removed by Filter: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 244.081 ms</font></div><div><font size="2"  >(5 rows)</font></div><div><font size="2"  >Time: 244.701 ms</font></div><p></p></pre></div><div>传入参数2, 使用了generic plan, 而没有执行custom plan.(<span style="line-height: 22px;"  >本来参数2应该走索引.</span>)</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; explain analyze execute p_test(2);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >-----------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=20637.01..20637.02 rows=1 width=0) (actual time=115.265..115.265 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..19387.01 rows=500001 width=0) (actual time=115.257..115.257 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (id = $1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rows Removed by Filter: 500000</font></div><div><font size="2"  >&nbsp;Total runtime: 115.317 ms</font></div><div><font size="2"  >(5 rows)</font></div><div><font size="2"  >Time: 116.046 ms</font></div><p></p></pre></div></div><div><br></div><div>下面把前5次的参数改成2, 主要说明choose_custom_plan的&nbsp;<span style="line-height: 22px;"  >plansource-&gt;generic_cost &lt; avg_custom_cost * 1.1 比较过程.</span></div><div><span style="line-height: 22px;"  >如下 :&nbsp;</span></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >ocz@db-172-16-3-150-&gt; psql digoal digoal</font></div><div><font size="2"  >psql (9.2.1)</font></div><div><font size="2"  >Type "help" for help.</font></div><div><font size="2"  >digoal=&gt; prepare p_test(int) as select count(*) from test where id=$1;</font></div><div><font size="2"  >PREPARE</font></div><div><font size="2"  >digoal=&gt; explain analyze execute p_test(2);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=1.41..1.42 rows=1 width=0) (actual time=0.083..0.084 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using idx_test_1 on test &nbsp;(cost=0.00..1.40 rows=1 width=0) (actual time=0.074..0.075 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = 2)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heap Fetches: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 0.200 ms</font></div><div><font size="2"  >(5 rows)</font></div><div><font size="2"  >digoal=&gt; explain analyze execute p_test(2);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=1.41..1.42 rows=1 width=0) (actual time=0.026..0.026 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using idx_test_1 on test &nbsp;(cost=0.00..1.40 rows=1 width=0) (actual time=0.021..0.022 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = 2)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heap Fetches: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 0.074 ms</font></div><div><font size="2"  >(5 rows)</font></div><div><font size="2"  >digoal=&gt; explain analyze execute p_test(2);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=1.41..1.42 rows=1 width=0) (actual time=0.021..0.021 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using idx_test_1 on test &nbsp;(cost=0.00..1.40 rows=1 width=0) (actual time=0.017..0.018 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = 2)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heap Fetches: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 0.065 ms</font></div><div><font size="2"  >(5 rows)</font></div><div><font size="2"  >digoal=&gt; explain analyze execute p_test(2);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=1.41..1.42 rows=1 width=0) (actual time=0.020..0.020 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using idx_test_1 on test &nbsp;(cost=0.00..1.40 rows=1 width=0) (actual time=0.016..0.016 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = 2)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heap Fetches: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 0.063 ms</font></div><div><font size="2"  >(5 rows)</font></div><div><font size="2"  >digoal=&gt; explain analyze execute p_test(2);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=1.41..1.42 rows=1 width=0) (actual time=0.020..0.020 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using idx_test_1 on test &nbsp;(cost=0.00..1.40 rows=1 width=0) (actual time=0.016..0.017 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = 2)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heap Fetches: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 0.061 ms</font></div><div><font size="2"  >(5 rows)</font></div><p></p></pre></div><div>第六次传入参数1, 走的是custom plan.&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; explain analyze execute p_test(1);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >--------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=20637.01..20637.02 rows=1 width=0) (actual time=343.385..343.385 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..19387.01 rows=500001 width=0) (actual time=0.053..253.714 rows=500000 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rows Removed by Filter: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 343.458 ms</font></div><div><font size="2"  >(5 rows)</font></div><p></p></pre></div></div><div>下面来解释一下原因 :&nbsp;</div><div>1. 第6次执行时,&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >num_custom_plans = 5</font></div><div><font size="2"  >total_custom_cost = 7.1 &nbsp; &nbsp; &nbsp;/* (1.42*5) */</font></div><p></p></pre></div><div>generic_cost等于多少呢? 还是-1(初始值) , 从后面使用gdb跟踪的结果可以看到.&nbsp;</div><div><span style="line-height: 22px;"  >因此choose_custom_plan的执行结果为true. 也就是选择custom plan, 因此需要额外的plan 优化选择过程.</span></div><div>到第7次执行时会变成20637. (generic plan好像是通过采样, 选择这一列上出现最频繁的值产生的执行计划)</div><div><br></div><div>GDB跟踪举例 :&nbsp;</div><div>首先确保编译PostgreSQL使用了enable-debug :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >ocz@db-172-16-3-150-&gt; pg_config --configure</font></div><div><font size="2"  >'--prefix=/home/ocz/pgsql9.2.1' '--with-pgport=9201' '--with-perl' '--with-python' '--with-tcl' '--with-openssl' '--with-pam' '--without-ldap' '--with-libxml' '--with-libxslt' '--enable-thread-safety' '--with-wal-blocksize=16' '--enable-debug' '--with-ossp-uuid' '--with-libs=/opt/uuid-1.6.2/lib'</font></div></div><div></div><p></p></pre><div>开始测试 :&nbsp;</div></div><div>终端1 :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; prepare p_test(int) as select count(*) from test where id=$1;</font></div><div><font size="2"  >PREPARE</font></div><div><font size="2"  >digoal=&gt; explain analyze execute p_test(2);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Aggregate &nbsp;(cost=1.41..1.42 rows=1 width=0) (actual time=0.113..0.113 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using idx_test_1 on test &nbsp;(cost=0.00..1.40 rows=1 width=0) (actual time=0.102..0.103 rows=1 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = 2)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heap Fetches: 1</font></div><div><font size="2"  >&nbsp;Total runtime: 0.269 ms</font></div><div><font size="2"  >(5 rows)</font></div><div><div style="line-height: 22px;"  ><font size="2"  >digoal=&gt; select pg_backend_pid();</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp;pg_backend_pid&nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  >----------------</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10921</font></div><div style="line-height: 22px;"  ><font size="2"  >(1 row)</font></div></div><p></p></pre></div><div><br></div></div><div>终端2 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >ocz@db-172-16-3-150-&gt; gdb</font></div><div><font size="2"  >GNU gdb (GDB) Red Hat Enterprise Linux (7.0.1-37.el5)</font></div><div><font size="2"  >Copyright (C) 2009 Free Software Foundation, Inc.</font></div><div><font size="2"  >License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</font></div><div><font size="2"  >This is free software: you are free to change and redistribute it.</font></div><div><font size="2"  >There is NO WARRANTY, to the extent permitted by law. &nbsp;Type "show copying"</font></div><div><font size="2"  >and "show warranty" for details.</font></div><div><font size="2"  >This GDB was configured as "x86_64-redhat-linux-gnu".</font></div><div><font size="2"  >For bug reporting instructions, please see:</font></div><div><font size="2"  >&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</font></div><div><font size="2"  >绑定进程号.</font></div><div><font size="2"  >(gdb) attach 10921</font></div><div><font size="2"  >Attaching to process 10921</font></div></div><div><font size="2"  >设置断点</font></div><div><div><font size="2"  >(gdb) break choose_custom_plan</font></div><div><font size="2"  >Breakpoint 1 at 0x6ee730: file plancache.c, line 850.</font></div><div><div style="line-height: 22px;"  ><font size="2"  >执行到断点位置</font></div><div style="line-height: 22px;"  ><font size="2"  >(gdb) continue</font></div><div style="line-height: 22px;"  ><font size="2"  >Continuing.</font></div></div></div><p></p></pre></div><div><div style="line-height: 22px;"  ><br></div><div>终端1 :&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; explain analyze execute p_test(2);</font></p></pre></div><div><span style="line-height: 22px;"  ><br></span></div><div><span style="line-height: 22px;"  >终端2 :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >到达断点,</font></div></div><div><div><font size="2"  >Breakpoint 1, choose_custom_plan (plansource=0x14477350, boundParams=0x144b1678) at plancache.c:850</font></div><div><font size="2"  >850 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (boundParams == NULL)</font></div><div><font size="2"  >进入单步模式</font></div><div><font size="2"  >(gdb) step</font></div><div><font size="2"  >854 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (plansource-&gt;cursor_options &amp; CURSOR_OPT_GENERIC_PLAN)</font></div><div><font size="2"  >(gdb)&nbsp;</font></div><div><font size="2"  >856 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (plansource-&gt;cursor_options &amp; CURSOR_OPT_CUSTOM_PLAN)</font></div><div><font size="2"  >(gdb)&nbsp;</font></div><div><font size="2"  >860 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (plansource-&gt;num_custom_plans &lt; 5)</font></div><div><font size="2"  >(gdb)&nbsp;</font></div><div><font size="2"  >choose_custom_plan (plansource=0x14477350, boundParams=0x144b1678) at plancache.c:878</font></div><div><font size="2"  >878 &nbsp; &nbsp; }</font></div><div><font size="2"  >到了<span style="line-height: 22px;"  >choose_custom_plan 后, 打印一下</span><span style="line-height: 22px;"  >plansource-&gt;total_custom_cost</span></font></div><div><font size="2"  >(gdb) print plansource-&gt;total_custom_cost</font></div><div><font size="2"  >$1 = 1.4174</font></div><div><font size="2"  >继续下一轮</font></div><div><font size="2"  >(gdb) continue</font></div><div><font size="2"  >Continuing.</font></div></div><p></p></pre></div></div><div><br></div><div><div style="line-height: 22px;"  >终端1 :&nbsp;</div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  ><font size="2"  >digoal=&gt; explain analyze execute p_test(2);</font></span></div></div><div style="line-height: 22px;"  ></div><p></p></pre></div></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >终端2 :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >Breakpoint 1, choose_custom_plan (plansource=0x14477350, boundParams=0x144b1678) at plancache.c:850</font></div><div><font size="2"  >850 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (boundParams == NULL)</font></div><div><font size="2"  >(gdb) step</font></div><div><font size="2"  >854 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (plansource-&gt;cursor_options &amp; CURSOR_OPT_GENERIC_PLAN)</font></div><div><font size="2"  >(gdb)&nbsp;</font></div><div><font size="2"  >856 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (plansource-&gt;cursor_options &amp; CURSOR_OPT_CUSTOM_PLAN)</font></div><div><font size="2"  >(gdb)&nbsp;</font></div><div><font size="2"  >860 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (plansource-&gt;num_custom_plans &lt; 5)</font></div><div><font size="2"  >(gdb)&nbsp;</font></div><div><font size="2"  >choose_custom_plan (plansource=0x14477350, boundParams=0x144b1678) at plancache.c:878</font></div><div><font size="2"  >878 &nbsp; &nbsp; }</font></div><div><font size="2"  >注意此时total_custom_cost增长了.</font></div><div><font size="2"  >(gdb) print plansource-&gt;total_custom_cost</font></div><div><font size="2"  >$2 = 2.8348</font></div><div><font size="2"  >此时还未生成generic plan, 所以generic_cost=-1</font></div><div><font size="2"  >(gdb) print plansource-&gt;generic_cost</font></div><div><font size="2"  >$3 = -1</font></div><div><font size="2"  >(gdb) continue</font></div><div><font size="2"  >Continuing.</font></div><p></p></pre></div><div><br></div><div><div style="line-height: 22px;"  ><div style="line-height: 22px;"  >终端1 :&nbsp;</div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; explain analyze execute p_test(2);</font></p></pre></div></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >略去中间几步, 下面是第6次和第7次执行SQL时跟踪到的结果, 说明第6次执行完后生成了generic plan.&nbsp;</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >终端2 :&nbsp;</span></div></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >Breakpoint 1, choose_custom_plan (plansource=0x143998c0, boundParams=0x1439aff8) at plancache.c:850</font></div><div><font size="2"  >850 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (boundParams == NULL)</font></div><div><font size="2"  >(gdb) step</font></div><div><font size="2"  >854 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (plansource-&gt;cursor_options &amp; CURSOR_OPT_GENERIC_PLAN)</font></div><div><font size="2"  >(gdb)&nbsp;</font></div><div><font size="2"  >856 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (plansource-&gt;cursor_options &amp; CURSOR_OPT_CUSTOM_PLAN)</font></div><div><font size="2"  >(gdb)&nbsp;</font></div><div><font size="2"  >860 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (plansource-&gt;num_custom_plans &lt; 5)</font></div><div><font size="2"  >(gdb)&nbsp;</font></div><div><font size="2"  >GetCachedPlan (plansource=0x143998c0, boundParams=0x1439aff8, useResOwner=1 '\001') at plancache.c:941</font></div><div><font size="2"  >941 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!customplan)</font></div><div><font size="2"  >(gdb) print plansource-&gt;generic_cost</font></div><div><font size="2"  >$4 = -1</font></div><div><font size="2"  >(gdb) print plansource-&gt;total_custom_cost</font></div><div><font size="2"  >$5 = 7.0869999999999997</font></div><div><font size="2"  >(gdb) print plansource-&gt;num_custom_plans</font></div><div><font size="2"  >$6 = 5</font></div><div><font size="2"  >(gdb) continue</font></div><div><font size="2"  >Continuing.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Breakpoint 1, choose_custom_plan (plansource=0x143998c0, boundParams=0x1439aff8) at plancache.c:850</font></div><div><font size="2"  >850 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (boundParams == NULL)</font></div><div><font size="2"  >(gdb) continue</font></div><div><font size="2"  >Continuing.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Breakpoint 1, choose_custom_plan (plansource=0x143998c0, boundParams=0x1439abe8) at plancache.c:850</font></div><div><font size="2"  >850 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (boundParams == NULL)</font></div><div><font size="2"  >(gdb) step</font></div><div><font size="2"  >854 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (plansource-&gt;cursor_options &amp; CURSOR_OPT_GENERIC_PLAN)</font></div><div><font size="2"  >(gdb)&nbsp;</font></div><div><font size="2"  >856 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (plansource-&gt;cursor_options &amp; CURSOR_OPT_CUSTOM_PLAN)</font></div><div><font size="2"  >(gdb)&nbsp;</font></div><div><font size="2"  >860 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (plansource-&gt;num_custom_plans &lt; 5)</font></div><div><font size="2"  >(gdb)&nbsp;</font></div><div><font size="2"  >GetCachedPlan (plansource=0x143998c0, boundParams=0x1439abe8, useResOwner=1 '\001') at plancache.c:941</font></div><div><font size="2"  >941 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!customplan)</font></div><div><font size="2"  >(gdb) print plansource-&gt;generic_cost</font></div><div><font size="2"  >$7 = 20637.024999999998</font></div><div><font size="2"  >(gdb) print plansource-&gt;total_custom_cost</font></div><div><font size="2"  >$8 = 8.5044000000000004</font></div><div><font size="2"  >(gdb) print plansource-&gt;num_custom_plans</font></div><div><font size="2"  >$9 = 6</font></div><p></p></pre></div><div><div>generic_cost = 20637.024999999998 对应id=1的执行计划得到的cost, 如下 :</div><div>digoal=&gt; explain analyze execute p_test(1);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>--------------------------------------------------------------------------------------------------------------------</div><div>&nbsp;Aggregate &nbsp;(cost=20637.01..20637.02 rows=1 width=0) (actual time=433.100..433.100 rows=1 loops=1)</div><div>&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..19387.01 rows=500001 width=0) (actual time=0.133..344.716 rows=500000 loops=1)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (id = 1)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rows Removed by Filter: 1</div></div><div>为什么id=1的执行计划作为generic plan了. 因为id=1的值在test表的出现频率最高.&nbsp;</div><div>通过pg_stats视图可以看到. 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=&gt; \d pg_stats</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; View "pg_catalog.pg_stats"</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Column &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; Type &nbsp; | Modifiers&nbsp;</font></div><div><font size="2"  >------------------------+----------+-----------</font></div><div><font size="2"  >&nbsp;schemaname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | name &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;tablename &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| name &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;attname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| name &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;inherited &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| boolean &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;null_frac &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| real &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;avg_width &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| integer &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;n_distinct &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | real &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;most_common_vals &nbsp; &nbsp; &nbsp; | anyarray |&nbsp;</font></div><div><font size="2"  >&nbsp;most_common_freqs &nbsp; &nbsp; &nbsp;| real[] &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;histogram_bounds &nbsp; &nbsp; &nbsp; | anyarray |&nbsp;</font></div><div><font size="2"  >&nbsp;correlation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| real &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;most_common_elems &nbsp; &nbsp; &nbsp;| anyarray |&nbsp;</font></div><div><font size="2"  >&nbsp;most_common_elem_freqs | real[] &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;elem_count_histogram &nbsp; | real[] &nbsp; |&nbsp;</font></div></div><div><div><font size="2"  >digoal=&gt; \x</font></div><div><font size="2"  >Expanded display is on.</font></div><div><font size="2"  >digoal=&gt; select * from pg_stats where schemaname='digoal' and tablename='test' and attname='id';</font></div><div><font size="2"  >-[ RECORD 1 ]----------+-------</font></div><div><font size="2"  >schemaname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | digoal</font></div><div><font size="2"  >tablename &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| test</font></div><div><font size="2"  >attname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| id</font></div><div><font size="2"  >inherited &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| f</font></div><div><font size="2"  >null_frac &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 0</font></div><div><font size="2"  >avg_width &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 4</font></div><div><font size="2"  >n_distinct &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1</font></div><div><font size="2"  >most_common_vals &nbsp; &nbsp; &nbsp; | {1}</font></div><div><font size="2"  >most_common_freqs &nbsp; &nbsp; &nbsp;| {1}</font></div><div><font size="2"  >histogram_bounds &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >correlation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 1</font></div><div><font size="2"  >most_common_elems &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"  >most_common_elem_freqs |&nbsp;</font></div><div><font size="2"  >elem_count_histogram &nbsp; |&nbsp;</font></div></div><p></p></pre></div><div>注意这两项 :&nbsp;</div><div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >most_common_vals &nbsp; &nbsp; &nbsp; | {1}</font></div><div style="line-height: 22px;"  ><font size="2"  >most_common_freqs &nbsp; &nbsp; &nbsp;| {1}</font></div><p></p></pre></div></div><div style="line-height: 22px;"  >采样出来它的出现频率是100%</div><div><br></div><div>【其他】</div><div>1. 使用SPI_prepare_cursor, 通过设置flag [CURSOR_OPT_GENERIC_PLAN or CURSOR_OPT_CUSTOM_PLAN] 可以强制指定使用custom plan还是generic plan.&nbsp;</div><div>2. generic plan的生命周期 :&nbsp;</div><div>The statement returned by SPI_prepare can be used only in the current invocation of the procedure, since SPI_finish frees memory allocated for such a statement.&nbsp;</div><div>But the statement can be saved for longer using the functions SPI_keepplan or SPI_saveplan. 一般不推荐使用SPI_saveplan, 因为数据会重复.</div><div><div style="line-height: 22px;"  >SPI_finish释放gplan :&nbsp;</div><div style="line-height: 22px;"  ><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >/*</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp;* ReleaseGenericPlan: release a CachedPlanSource's generic plan, if any.</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp;*/</font></div><div style="line-height: 22px;"  ><font size="2"  >static void</font></div><div style="line-height: 22px;"  ><font size="2"  >ReleaseGenericPlan(CachedPlanSource *plansource)</font></div><div style="line-height: 22px;"  ><font size="2"  >{</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* Be paranoid about the possibility that ReleaseCachedPlan fails */</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (plansource-&gt;gplan)</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CachedPlan *plan = plansource-&gt;gplan;</font></div><div style="line-height: 22px;"  ><font size="2"  ><br style="line-height: 22px;"  ></font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(plan-&gt;magic == CACHEDPLAN_MAGIC);</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;gplan = NULL;</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseCachedPlan(plan, false);</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div style="line-height: 22px;"  ><font size="2"  >}</font></div></pre></div></div></div><div>3. 最后补充以下, 数据分布非常倾斜, 就像本例id=1的有50000条, id=2的只有1条的情况. 当传入id=2的值时可以考虑强制custom plan.</div><div>当然如果经常要这样做, 不推荐使用prepare statement. 因为generic plan是通过出现最频繁的值产生的执行计划, 至少从gdb跟踪出来的是这样的.</div><div><br></div><div>【参考】</div>1.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/spi-spi-prepare.html"  >http://www.postgresql.org/docs/9.2/static/spi-spi-prepare.html</a><div><span style="line-height: 22px;"  >2.&nbsp;</span><a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/spi-spi-execute-plan.html"  >http://www.postgresql.org/docs/9.2/static/spi-spi-execute-plan.html</a><br><div>3.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/plpgsql-implementation.html"  >http://www.postgresql.org/docs/9.2/static/plpgsql-implementation.html</a></div><div>4.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/xfunc-volatility.html"  >http://www.postgresql.org/docs/9.2/static/xfunc-volatility.html</a></div><div>5.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/sql-prepare.html"  >http://www.postgresql.org/docs/9.2/static/sql-prepare.html</a></div><div>6.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/sql-execute.html"  >http://www.postgresql.org/docs/9.2/static/sql-execute.html</a></div><div>7.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/sql-deallocate.html"  >http://www.postgresql.org/docs/9.2/static/sql-deallocate.html</a></div><div>8.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/spi-spi-keepplan.html"  >http://www.postgresql.org/docs/9.2/static/spi-spi-keepplan.html</a></div><div>9.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/spi-spi-saveplan.html"  >http://www.postgresql.org/docs/9.2/static/spi-spi-saveplan.html</a></div><div><div style="line-height: 22px;"  >10.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020121015265329/"  >http://blog.163.com/digoal@126/blog/static/16387704020121015265329/</a></div><div style="line-height: 22px;"  >11.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020124219333824/"  >http://blog.163.com/digoal@126/blog/static/16387704020124219333824/</a></div><div style="line-height: 22px;"  >12.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020111168855258/"  >http://blog.163.com/digoal@126/blog/static/16387704020111168855258/</a></div><div style="line-height: 22px;"  >13.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020109286417600/"  >http://blog.163.com/digoal@126/blog/static/16387704020109286417600/</a></div></div><div>14.&nbsp;src/backend/executor/spi.c</div><div>15. src/include/executor/spi_priv.h</div>16.&nbsp;src/backend/utils/cache/plancache.c</div><div>17. src/backend/commands/prepare.c<br><div>18.&nbsp;src/include/utils/plancache.h</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >00024 /*</font></div><div><font size="2"  >00025 &nbsp;* CachedPlanSource (which might better have been called CachedQuery)</font></div><div><font size="2"  >00026 &nbsp;* represents a SQL query that we expect to use multiple times. &nbsp;It stores</font></div><div><font size="2"  >00027 &nbsp;* the query source text, the raw parse tree, and the analyzed-and-rewritten</font></div><div><font size="2"  >00028 &nbsp;* query tree, as well as adjunct data. &nbsp;Cache invalidation can happen as a</font></div><div><font size="2"  >00029 &nbsp;* result of DDL affecting objects used by the query. &nbsp;In that case we discard</font></div><div><font size="2"  >00030 &nbsp;* the analyzed-and-rewritten query tree, and rebuild it when next needed.</font></div><div><font size="2"  >00031 &nbsp;*</font></div><div><font size="2"  >00032 &nbsp;* An actual execution plan, represented by CachedPlan, is derived from the</font></div><div><font size="2"  >00033 &nbsp;* CachedPlanSource when we need to execute the query. &nbsp;The plan could be</font></div><div><font size="2"  >00034 &nbsp;* either generic (usable with any set of plan parameters) or custom (for a</font></div><div><font size="2"  >00035 &nbsp;* specific set of parameters). &nbsp;plancache.c contains the logic that decides</font></div><div><font size="2"  >00036 &nbsp;* which way to do it for any particular execution. &nbsp;If we are using a generic</font></div><div><font size="2"  >00037 &nbsp;* cached plan then it is meant to be re-used across multiple executions, so</font></div><div><font size="2"  >00038 &nbsp;* callers must always treat CachedPlans as read-only.</font></div><div><font size="2"  >00039 &nbsp;*</font></div><div><font size="2"  >00040 &nbsp;* Once successfully built and "saved", CachedPlanSources typically live</font></div><div><font size="2"  >00041 &nbsp;* for the life of the backend, although they can be dropped explicitly.</font></div><div><font size="2"  >00042 &nbsp;* CachedPlans are reference-counted and go away automatically when the last</font></div><div><font size="2"  >00043 &nbsp;* reference is dropped. &nbsp;A CachedPlan can outlive the CachedPlanSource it</font></div><div><font size="2"  >00044 &nbsp;* was created from.</font></div><div><font size="2"  >00045 &nbsp;*</font></div><div><font size="2"  >00046 &nbsp;* An "unsaved" CachedPlanSource can be used for generating plans, but it</font></div><div><font size="2"  >00047 &nbsp;* lives in transient storage and will not be updated in response to sinval</font></div><div><font size="2"  >00048 &nbsp;* events.</font></div><div><font size="2"  >00049 &nbsp;*</font></div><div><font size="2"  >00050 &nbsp;* CachedPlans made from saved CachedPlanSources are likewise in permanent</font></div><div><font size="2"  >00051 &nbsp;* storage, so to avoid memory leaks, the reference-counted references to them</font></div><div><font size="2"  >00052 &nbsp;* must be held in permanent data structures or ResourceOwners. &nbsp;CachedPlans</font></div><div><font size="2"  >00053 &nbsp;* made from unsaved CachedPlanSources are in children of the caller's</font></div><div><font size="2"  >00054 &nbsp;* memory context, so references to them should not be longer-lived than</font></div><div><font size="2"  >00055 &nbsp;* that context. &nbsp;(Reference counting is somewhat pro forma in that case,</font></div><div><font size="2"  >00056 &nbsp;* though it may be useful if the CachedPlan can be discarded early.)</font></div><div><font size="2"  >00057 &nbsp;*</font></div><div><font size="2"  >00058 &nbsp;* A CachedPlanSource has two associated memory contexts: one that holds the</font></div><div><font size="2"  >00059 &nbsp;* struct itself, the query source text and the raw parse tree, and another</font></div><div><font size="2"  >00060 &nbsp;* context that holds the rewritten query tree and associated data. &nbsp;This</font></div><div><font size="2"  >00061 &nbsp;* allows the query tree to be discarded easily when it is invalidated.</font></div><div><font size="2"  >00062 &nbsp;*</font></div><div><font size="2"  >00063 &nbsp;* Note: the string referenced by commandTag is not subsidiary storage;</font></div><div><font size="2"  >00064 &nbsp;* it is assumed to be a compile-time-constant string. &nbsp;As with portals,</font></div><div><font size="2"  >00065 &nbsp;* commandTag shall be NULL if and only if the original query string (before</font></div><div><font size="2"  >00066 &nbsp;* rewriting) was an empty string.</font></div><div><font size="2"  >00067 &nbsp;*/</font></div><div><font size="2"  >00068 typedef struct CachedPlanSource</font></div><div><font size="2"  >00069 {</font></div><div><font size="2"  >00070 &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; magic; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* should equal CACHEDPLANSOURCE_MAGIC */</font></div><div><font size="2"  >00071 &nbsp; &nbsp; Node &nbsp; &nbsp; &nbsp; *raw_parse_tree; /* output of raw_parser() */</font></div><div><font size="2"  >00072 &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *query_string; &nbsp; /* source text of query */</font></div><div><font size="2"  >00073 &nbsp; &nbsp; const char *commandTag; &nbsp; &nbsp; /* command tag (a constant!), or NULL */</font></div><div><font size="2"  >00074 &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp;*param_types; &nbsp; &nbsp;/* array of parameter type OIDs, or NULL */</font></div><div><font size="2"  >00075 &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; num_params; &nbsp; &nbsp; /* length of param_types array */</font></div><div><font size="2"  >00076 &nbsp; &nbsp; ParserSetupHook parserSetup; &nbsp; &nbsp;/* alternative parameter spec method */</font></div><div><font size="2"  >00077 &nbsp; &nbsp; void &nbsp; &nbsp; &nbsp; *parserSetupArg;</font></div><div><font size="2"  >00078 &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; cursor_options; /* cursor options used for planning */</font></div><div><font size="2"  >00079 &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;fixed_result; &nbsp; /* disallow change in result tupdesc? */</font></div><div><font size="2"  >00080 &nbsp; &nbsp; TupleDesc &nbsp; resultDesc; &nbsp; &nbsp; /* result type; NULL = doesn't return tuples */</font></div><div><font size="2"  >00081 &nbsp; &nbsp; struct OverrideSearchPath *search_path; &nbsp; &nbsp; /* saved search_path */</font></div><div><font size="2"  >00082 &nbsp; &nbsp; MemoryContext context; &nbsp; &nbsp; &nbsp;/* memory context holding all above */</font></div><div><font size="2"  >00083 &nbsp; &nbsp; /* These fields describe the current analyzed-and-rewritten query tree: */</font></div><div><font size="2"  >00084 &nbsp; &nbsp; List &nbsp; &nbsp; &nbsp; *query_list; &nbsp; &nbsp; /* list of Query nodes, or NIL if not valid */</font></div><div><font size="2"  >00085 &nbsp; &nbsp; List &nbsp; &nbsp; &nbsp; *relationOids; &nbsp; /* OIDs of relations the queries depend on */</font></div><div><font size="2"  >00086 &nbsp; &nbsp; List &nbsp; &nbsp; &nbsp; *invalItems; &nbsp; &nbsp; /* other dependencies, as PlanInvalItems */</font></div><div><font size="2"  >00087 &nbsp; &nbsp; MemoryContext query_context; &nbsp; &nbsp;/* context holding the above, or NULL */</font></div><div><font size="2"  >00088 &nbsp; &nbsp; /* If we have a generic plan, this is a reference-counted link to it: */</font></div><div><font size="2"  >00089 &nbsp; &nbsp; struct CachedPlan *gplan; &nbsp; /* generic plan, or NULL if not valid */</font></div><div><font size="2"  >00090 &nbsp; &nbsp; /* Some state flags: */</font></div><div><font size="2"  >00091 &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;is_complete; &nbsp; &nbsp;/* has CompleteCachedPlan been done? */</font></div><div><font size="2"  >00092 &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;is_saved; &nbsp; &nbsp; &nbsp; /* has CachedPlanSource been "saved"? */</font></div><div><font size="2"  >00093 &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;is_valid; &nbsp; &nbsp; &nbsp; /* is the query_list currently valid? */</font></div><div><font size="2"  >00094 &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; generation; &nbsp; &nbsp; /* increments each time we create a plan */</font></div><div><font size="2"  >00095 &nbsp; &nbsp; /* If CachedPlanSource has been saved, it is a member of a global list */</font></div><div><font size="2"  >00096 &nbsp; &nbsp; struct CachedPlanSource *next_saved; &nbsp; &nbsp; &nbsp; &nbsp;/* list link, if so */</font></div><div><font size="2"  >00097 &nbsp; &nbsp; /* State kept to help decide whether to use custom or generic plans: */</font></div><div><font size="2"  >00098 &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp;generic_cost; &nbsp; /* cost of generic plan, or -1 if not known */</font></div><div><font size="2"  >00099 &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp;total_custom_cost; &nbsp; &nbsp; &nbsp;/* total cost of custom plans so far */</font></div><div><font size="2"  >00100 &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; num_custom_plans; &nbsp; &nbsp; &nbsp; /* number of plans included in total */</font></div><div><font size="2"  >00101 } CachedPlanSource;</font></div><div><font size="2"  >00102&nbsp;generic plan 存储在以下数据结构中:</font></div><div><font size="2"  >00103 /*</font></div><div><font size="2"  >00104 &nbsp;* CachedPlan represents an execution plan derived from a CachedPlanSource.</font></div><div><font size="2"  >00105 &nbsp;* The reference count includes both the link from the parent CachedPlanSource</font></div><div><font size="2"  >00106 &nbsp;* (if any), and any active plan executions, so the plan can be discarded</font></div><div><font size="2"  >00107 &nbsp;* exactly when refcount goes to zero. &nbsp;Both the struct itself and the</font></div><div><font size="2"  >00108 &nbsp;* subsidiary data live in the context denoted by the context field.</font></div><div><font size="2"  >00109 &nbsp;* This makes it easy to free a no-longer-needed cached plan.</font></div><div><font size="2"  >00110 &nbsp;*/</font></div><div><font size="2"  >00111 typedef struct CachedPlan</font></div><div><font size="2"  >00112 {</font></div><div><font size="2"  >00113 &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; magic; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* should equal CACHEDPLAN_MAGIC */</font></div><div><font size="2"  >00114 &nbsp; &nbsp; List &nbsp; &nbsp; &nbsp; *stmt_list; &nbsp; &nbsp; &nbsp;/* list of statement nodes (PlannedStmts and</font></div><div><font size="2"  >00115 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* bare utility statements) */</font></div><div><font size="2"  >00116 &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;is_saved; &nbsp; &nbsp; &nbsp; /* is CachedPlan in a long-lived context? */</font></div><div><font size="2"  >00117 &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;is_valid; &nbsp; &nbsp; &nbsp; /* is the stmt_list currently valid? */</font></div><div><font size="2"  >00118 &nbsp; &nbsp; TransactionId saved_xmin; &nbsp; /* if valid, replan when TransactionXmin</font></div><div><font size="2"  >00119 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* changes from this value */</font></div><div><font size="2"  >00120 &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; generation; &nbsp; &nbsp; /* parent's generation number for this plan */</font></div><div><font size="2"  >00121 &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; refcount; &nbsp; &nbsp; &nbsp; /* count of live references to this struct */</font></div><div><font size="2"  >00122 &nbsp; &nbsp; MemoryContext context; &nbsp; &nbsp; &nbsp;/* context containing this CachedPlan */</font></div><div><font size="2"  >00123 } CachedPlan;</font></div><p></p></pre></div><br></div></div>
	</div>
</div>
</body>
</html>