<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">pay attention to function index used in PostgreSQL</h2>
	<h5 id="">2012-06-26 17:09:31&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201252641410920/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>今天一位同事又问到了这个问题, 函数索引. 这是一个老问题了.</div><div>PostgreSQL中函数有三种状态, 不稳定, 稳定, 非常稳定.</div><div>三种状态分别代表的意思如下 :&nbsp;</div><div><a style="line-height: 22px; " href="http://blog.163.com/digoal@126/blog/static/163877040201151011105494/"  >http://blog.163.com/digoal@126/blog/static/163877040201151011105494/</a><span style="line-height: 22px;"  >&nbsp;</span> </div><div>如果一个时间字段上要创建to_char(timestamp without time zone, text)的函数索引. 是没有办法创建的, 报错</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=&gt; create table t1 (crt_time timestamp);</font></div><div><font size="2"  >CREATE TABLE</font></div></div><div><div><font size="2"  >digoal=&gt; \set VERBOSITY verbose</font></div><div><font size="2"  >digoal=&gt; create index t1_1 on t1 (to_char(crt_time,'yyyy-mm-dd'));</font></div><div><font size="2"  >ERROR: &nbsp;42P17: functions in index expression must be marked IMMUTABLE</font></div><div><font size="2"  >LOCATION: &nbsp;ComputeIndexAttrs, indexcmds.c:909</font></div></div><p></p></pre></div><div><br></div><div>为什么呢?</div><div>&nbsp;看看to_char函数的稳定性状态 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select proname,provolatile,proargtypes from pg_proc where proname='to_char';</font></div><div><font size="2"  >&nbsp;proname | provolatile | proargtypes&nbsp;</font></div><div><font size="2"  >---------+-------------+-------------</font></div><div><font size="2"  >&nbsp;to_char | s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 20 25</font></div><div><font size="2"  >&nbsp;to_char | s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 23 25</font></div><div><font size="2"  >&nbsp;to_char | s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 700 25</font></div><div><font size="2"  >&nbsp;to_char | s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 701 25</font></div><div><font size="2"  >&nbsp;to_char | s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1114 25</font></div><div><font size="2"  >&nbsp;to_char | s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1184 25</font></div><div><font size="2"  >&nbsp;to_char | s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1186 25</font></div><div><font size="2"  >&nbsp;to_char | s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1700 25</font></div><div><font size="2"  >(8 rows)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=&gt; select oid,typname from pg_type where oid in (20,25,23,700,701,1114,1184,1186,1700);</font></div><div><font size="2"  >&nbsp;oid &nbsp;| &nbsp; typname &nbsp;&nbsp;</font></div><div><font size="2"  >------+-------------</font></div><div><font size="2"  >&nbsp; &nbsp;20 | int8</font></div><div><font size="2"  >&nbsp; &nbsp;23 | int4</font></div><div><font size="2"  >&nbsp; &nbsp;25 | text</font></div><div><font size="2"  >&nbsp; 700 | float4</font></div><div><font size="2"  >&nbsp; 701 | float8</font></div><div><font size="2"  >&nbsp;1114 | timestamp</font></div><div><font size="2"  >&nbsp;1184 | timestamptz</font></div><div><font size="2"  >&nbsp;1186 | interval</font></div><div><font size="2"  >&nbsp;1700 | numeric</font></div><div><font size="2"  >(9 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"  ><br></span></div><div>为什么函数索引一定要immutable的函数呢?</div><div>函数索引一旦建立后, 如果执行计划走索引扫描, PostgreSQL必须确保在任何情况下, 函数得到的结果和建立函数索引时得到的结果是一致的, 否则就会出现走索引检索到的和走全表扫描检索到的结果不一致. 这可是灾难性的BUG.</div><div>测试如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; create table test (id int,crt_time timestamp(0) with time zone);</font></div><div><font size="2"  >CREATE TABLE</font></div><p></p></pre></div><div>-- 正常情况下创建这个函数索引将报错</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; create index idx_test on test (to_char(crt_time,'yyyymmddhh24'));</font></div><div><font size="2"  >ERROR: &nbsp;42P17: functions in index expression must be marked IMMUTABLE</font></div><div><font size="2"  >LOCATION: &nbsp;ComputeIndexAttrs, indexcmds.c:909</font></div><p></p></pre></div><div>-- 手工修改了to_char(timestamp with time zone,text)的strict immutable.</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; \c digoal postgres</font></div><div><font size="2"  >You are now connected to database "digoal" as user "postgres".</font></div><div><font size="2"  >digoal=# alter function to_char(timestamp with time zone,text) strict immutable;</font></div><div><font size="2"  >ALTER FUNCTION</font></div><p></p></pre></div><div>-- 新建函数索引成功</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=# \c digoal digoal</font></div><div><font size="2"  >You are now connected to database "digoal" as user "digoal".</font></div></div><div><div><font size="2"  >digoal=&gt; create index idx_test on test (to_char(crt_time,'yyyymmddhh24'));</font></div><div><font size="2"  >CREATE INDEX</font></div></div><p></p></pre></div></div><div>-- 接下来查看当前的TimeZone</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; show TimeZone;</font></div><div><font size="2"  >&nbsp;TimeZone&nbsp;</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp;PRC</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>-- 插入一条测试数据</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; insert into test values (1,'2012-01-01 12:00:00');</font></div><div><font size="2"  >INSERT 0 1</font></div><p></p></pre></div><div>-- 在当前的TimeZone下查看<span style="line-height: 22px;"  >to_char(crt_time,'yyyymmddhh24') = 2012010112</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select to_char(crt_time,'yyyymmddhh24') from test;</font></div><div><font size="2"  >&nbsp; to_char &nbsp;&nbsp;</font></div><div><font size="2"  >------------</font></div><div><font size="2"  >&nbsp;2012010112</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>-- 把TimeZone改成了GMT</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; set TimeZone='GMT';</font></div><div><font size="2"  >SET</font></div><p></p></pre></div><div>-- 查看<span style="line-height: 22px;"  >to_char(crt_time,'yyyymmddhh24') = 2012010104</span></div><div><span style="line-height: 22px;"  >-- 同样的参数, 得到的结果不一致.&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select to_char(crt_time,'yyyymmddhh24') from test;</font></div><div><font size="2"  >&nbsp; to_char &nbsp;&nbsp;</font></div><div><font size="2"  >------------</font></div><div><font size="2"  >&nbsp;2012010104</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div></div><div><br></div><div>-- 接下来在执行计划是走索引时的查询结果. 因为建立索引时, 这个<span style="line-height: 22px;"  >to_char(crt_time,'yyyymmddhh24')是等于</span><span style="line-height: 22px;"  >2012010112的,&nbsp;</span></div><div><span style="line-height: 22px;"  >-- 所以走索引扫描将返回一条记录.</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; explain select * from test where to_char(crt_time,'yyyymmddhh24')='2012010112';</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Index Scan using idx_test on test &nbsp;(cost=0.00..8.43 rows=10 width=12)</font></div><div><font size="2"  >&nbsp; &nbsp;Index Cond: (to_char(crt_time, 'yyyymmddhh24'::text) = '2012010112'::text)</font></div><div><font size="2"  >(2 rows)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=&gt; select * from test where to_char(crt_time,'yyyymmddhh24')='2012010112';</font></div><div><font size="2"  >&nbsp;id | &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >----+------------------------</font></div><div><font size="2"  >&nbsp; 1 | 2012-01-01 04:00:00+00</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div>-- 接下来严重BUG发生了, 走全表扫描的话同样的SQL, 查询结果没了.</div><div>-- 因为走全表扫描的话, 这个值 <span style="line-height: 22px;"  >to_char(crt_time,'yyyymmddhh24')</span>&nbsp;将被重新运算, 结果是<span style="line-height: 22px;"  >2012010104</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; set enable_indexscan=off;</font></div><div><font size="2"  >SET</font></div><div><font size="2"  >digoal=&gt; set enable_bitmapscan=off;</font></div><div><font size="2"  >SET</font></div><div><font size="2"  >digoal=&gt; select * from test where to_char(crt_time,'yyyymmddhh24')='2012010112';</font></div><div><font size="2"  >&nbsp;id | crt_time&nbsp;</font></div><div><font size="2"  >----+----------</font></div><div><font size="2"  >(0 rows)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=&gt; explain analyze select * from test where to_char(crt_time,'yyyymmddhh24')='2012010112';</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >-------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Seq Scan on test &nbsp;(cost=0.00..39.10 rows=10 width=12) (actual time=0.031..0.031 rows=0 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;Filter: (to_char(crt_time, 'yyyymmddhh24'::text) = '2012010112'::text)</font></div><div><font size="2"  >&nbsp;Total runtime: 0.066 ms</font></div><div><font size="2"  >(3 rows)</font></div><p></p></pre></div><div><br></div><div>-- 查询<span style="line-height: 22px;"  >2012010104则有结果, 返回一条记录</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select * from test where to_char(crt_time,'yyyymmddhh24')='2012010104';</font></div><div><font size="2"  >&nbsp;id | &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >----+------------------------</font></div><div><font size="2"  >&nbsp; 1 | 2012-01-01 04:00:00+00</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div>-- 所以在使用函数索引时需要慎重, 创建函数是strict的选择也要慎重.</div><div>-- 如果一定要在时间类型上有类似的请求怎么办, 第一使用timestamp without time zone , 使用immutable的date_trunc函数代替to_char</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select proname,provolatile,proargtypes from pg_proc where proname='date_trunc';</font></div><div><font size="2"  >&nbsp; proname &nbsp; | provolatile | proargtypes&nbsp;</font></div><div><font size="2"  >------------+-------------+-------------</font></div><div><font size="2"  >&nbsp;date_trunc | s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 25 1184</font></div><div><font size="2"  >&nbsp;date_trunc | i &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 25 1186</font></div><div><font size="2"  >&nbsp;date_trunc | i &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 25 1114</font></div><div><font size="2"  >(3 rows)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=&gt; select oid,typname from pg_type where oid in (25,1184,1186,1114);</font></div><div><font size="2"  >&nbsp;oid &nbsp;| &nbsp; typname &nbsp;&nbsp;</font></div><div><font size="2"  >------+-------------</font></div><div><font size="2"  >&nbsp; &nbsp;25 | text</font></div><div><font size="2"  >&nbsp;1114 | timestamp</font></div><div><font size="2"  >&nbsp;1184 | timestamptz</font></div><div><font size="2"  >&nbsp;1186 | interval</font></div><div><font size="2"  >(4 rows)</font></div><p></p></pre></div><div><br></div><div><br></div>【其他】<div>1. Thinking PostgreSQL Function's Volatility Categories</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201151011105494/"  >http://blog.163.com/digoal@126/blog/static/163877040201151011105494/</a>&nbsp;<br>2. 还有几种用法<wbr></div><div>仅仅适用timestamp without time zone, 带时区的都会有以上类似的问题.</div><div>2.1 以下是个折中方案, 不必修改系统函数to_char的strict, 但是必须符合一定条件才可以冒这个险去使用它.</div><div><div>this is intended behaviour as to_char depends on the LC_MESSAGES setting</div><div>也就是说在使用环境中不会涉及LC_MESSAGES的变动(或者变动后不会影响to_char的结果.)时方可使用.</div></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >CREATE OR REPLACE FUNCTION my_to_char(some_time timestamp)&nbsp;</font></div><div><font size="2"  >&nbsp; RETURNS text</font></div><div><font size="2"  >AS</font></div><div><font size="2"  >$BODY$</font></div><div><font size="2"  >&nbsp; &nbsp; select to_char($1, 'yyyy-mm-dd');</font></div><div><font size="2"  >$BODY$</font></div><div><font size="2"  >LANGUAGE sql</font></div><div><font size="2"  >IMMUTABLE;</font></div><p></p></pre></div><div><br></div><div>2.2</div><div>cast(crt_time as date)</div></div><div>crt_time必须是不带时区的. 否则会有类似问题</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; set TimeZone='PRC';</font></div><div><font size="2"  >SET</font></div><div><font size="2"  >digoal=&gt; select cast (timestamp with time zone '2012-01-01 13:00:00+14' as date);</font></div><div><font size="2"  >&nbsp; &nbsp; date &nbsp; &nbsp;</font></div><div><font size="2"  >------------</font></div><div><font size="2"  >&nbsp;2012-01-01</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=&gt; set TimeZone='GMT';</font></div><div><font size="2"  >SET</font></div><div><font size="2"  >digoal=&gt; select cast (timestamp with time zone '2012-01-01 13:00:00+14' as date);</font></div><div><font size="2"  >&nbsp; &nbsp; date &nbsp; &nbsp;</font></div><div><font size="2"  >------------</font></div><div><font size="2"  >&nbsp;2011-12-31</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div>3. 还有一种方法是增加一列, 用来存储需要建立的函数索引to_char()的结果值. 这样就不需要使用函数索引了, 也不需要考虑函数的strict问题.</div>
	</div>
</div>
</body>
</html>