<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">pgsql_fdw "cache lookup failed for type 0" error when used in function</h2>
	<h5 id="">2012-06-21 20:29:37&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020125218171919/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>【2012-07-11 补充】</div><div>已解决</div><div><a rel="nofollow" href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=3539995&amp;group_id=565635&amp;atid=2294281"  >http://sourceforge.net/tracker/index.php?func=detail&amp;aid=3539995&amp;group_id=565635&amp;atid=2294281</a> </div><div><br></div><div>【原文】</div><div>今天准备使用pgsql_fdw同步两个数据库之间的数据, 同步的过程写在函数里面.</div><div>但是在同步时发现会报错,&nbsp;</div><div>下载并安装pgsql_fdw :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >https://github.com/dvarrazzo/interdbconnect/downloads</font></div><div><font size="2"  >mv pgsql_fdw $PG_SRC/contrib/</font></div><div><font size="2"  >cd $PG_SRC/contrib/pgsql_fdw</font></div><div><font size="2"  >. /home/postgres/.bash_profile</font></div><div><font size="2"  >USE_PGXS=1 make</font></div><div><font size="2"  >USE_PGXS=1 make install</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"  >外部表的创建如下 :&nbsp;</span> </div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# create extension pgsql_fdw;</font></div><div><font size="2"  >CREATE EXTENSION</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >CREATE SERVER srv_digoal FOREIGN DATA WRAPPER pgsql_fdw</font></div><div><font size="2"  >OPTIONS (host '172.16.3.33', port '5432', dbname 'digoal');</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >CREATE USER MAPPING FOR digoal SERVER srv_digoal</font></div><div><font size="2"  >OPTIONS (user 'rmt_digoal', password 'DIGOAL123');</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >grant usage on foreign server srv_digoal to digoal;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >\c digoal digoal</font></div><div><font size="2"  >CREATE FOREIGN TABLE bill_table_digoal</font></div><div><font size="2"  >(</font></div><div><font size="2"  >id numeric(20,0),</font></div><div><font size="2"  >cn_id character varying(20),</font></div><div><font size="2"  >cn_name character varying(100),</font></div><div><font size="2"  >cn_type numeric(1,0),</font></div><div><font size="2"  >requestor character varying(3),</font></div><div><font size="2"  >cn_desc character varying(1000),</font></div><div><font size="2"  >create_time timestamp(0) without time zone,</font></div><div><font size="2"  >cn_code character varying(100),</font></div><div><font size="2"  >check_type numeric(1,0),</font></div><div><font size="2"  >check_msg character varying(400)</font></div><div><font size="2"  >) server </font><span style="line-height: 21px; font-size: small;"  >srv_digoal</span><font size="2"  > options (nspname 'digoal', relname 'table_digoal');</font></div><p></p></pre></div><div><br></div><div>-- 创建临时工作表, 用于暂缓中间数据 :&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >create table work_table_table_digoal (like table_digoal including all);</font></p></pre></div></div><div><br></div><div>同步数据的函数如下, 当有新增数据或数据不相等时同步 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >create or replace function sync_table_digoal() returns int as $$</font></div><div><font size="2"  >declare</font></div><div><font size="2"  >v_src_count int;</font></div><div><font size="2"  >v_dst_count int;</font></div><div><font size="2"  >v_equal_count int;</font></div><div><font size="2"  >begin</font></div><div><font size="2"  >v_src_count := 0;</font></div><div><font size="2"  >v_dst_count := 0;</font></div><div><font size="2"  >v_equal_count := 0;</font></div><div><font size="2"  >truncate table ONLY work_table_table_digoal;</font></div><div><font size="2"  >insert into work_table_table_digoal&nbsp;</font></div><div><font size="2"  >&nbsp; (id,cn_id,cn_name,cn_type,requestor,cn_desc,create_time,cn_code,check_type,check_msg)&nbsp;</font></div><div><font size="2"  >&nbsp; select id,cn_id,cn_name,cn_type,requestor,cn_desc,create_time,cn_code,check_type,check_msg from ft_bill_table_digoal;</font></div><div><font size="2"  >select count(*) into v_src_count from work_table_table_digoal;</font></div><div><font size="2"  >select count(*) into v_dst_count from table_digoal;</font></div><div><font size="2"  >raise notice 'v_src_count:%, v_dst_count:%',v_src_count,v_dst_count;</font></div><div><font size="2"  >if ( v_src_count = v_dst_count and v_src_count &lt;&gt; 0 ) then</font></div><div><font size="2"  >&nbsp;&nbsp;-- 比较所有not null 字段</font></div><div><font size="2"  >  select count(*) into v_equal_count from work_table_table_digoal t1,table_digoal t2</font></div><div><font size="2"  >&nbsp; &nbsp; where t1.id=t2.id&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; and t1.cn_id = t2.cn_id</font></div><div><font size="2"  >&nbsp; &nbsp; and t1.cn_name = t2.cn_name</font></div><div><font size="2"  >&nbsp; &nbsp; and t1.cn_type = t2.cn_type</font></div><div><font size="2"  >&nbsp; &nbsp; and t1.requestor = t2.requestor</font></div><div><font size="2"  >&nbsp; &nbsp; and t1.cn_code = t2.cn_code</font></div><div><font size="2"  >&nbsp; &nbsp; and t1.check_type = t2.check_type;</font></div><div><font size="2"  >&nbsp; raise notice 'v_src_count:%, v_dst_count:%, v_equal_count:%',v_src_count,v_dst_count,v_equal_count;</font></div><div><font size="2"  >&nbsp; if ( v_equal_count &lt;&gt; v_src_count ) then</font></div><div><font size="2"  >&nbsp; &nbsp; truncate table ONLY table_digoal;</font></div><div><font size="2"  >&nbsp; &nbsp; insert into table_digoal&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; (id,cn_id,cn_name,cn_type,requestor,cn_desc,create_time,cn_code,check_type,check_msg)</font></div><div><font size="2"  >&nbsp; &nbsp; select id,cn_id,cn_name,cn_type,requestor,cn_desc,create_time,cn_code,check_type,check_msg from work_table_table_digoal;</font></div><div><font size="2"  >&nbsp; end if;</font></div><div><font size="2"  >elsif ( v_src_count &lt;&gt; v_dst_count and v_src_count &lt;&gt; 0 ) then</font></div><div><font size="2"  >&nbsp; truncate table ONLY table_digoal;</font></div><div><font size="2"  >&nbsp; insert into table_digoal&nbsp;</font></div><div><font size="2"  >&nbsp; (id,cn_id,cn_name,cn_type,requestor,cn_desc,create_time,cn_code,check_type,check_msg)</font></div><div><font size="2"  >&nbsp; select id,cn_id,cn_name,cn_type,requestor,cn_desc,create_time,cn_code,check_type,check_msg from work_table_table_digoal;</font></div><div><font size="2"  >elsif v_src_count = 0 then</font></div><div><font size="2"  >&nbsp;&nbsp;<span style="line-height: 19px;"  >raise notice 'ERROR: src no data.';</span></font></div><div><font size="2"  >  return 1;</font></div><div><font size="2"  >end if;</font></div><div><font size="2"  >return 0;</font></div><div><font size="2"  >exception when others then</font></div><div><font size="2"  >&nbsp; raise notice 'ERROR: ';</font></div><div><font size="2"  >&nbsp; raise notice 'v_src_count:%, v_dst_count:%, v_equal_count:%',v_src_count,v_dst_count,v_equal_count;</font></div><div><font size="2"  >&nbsp; return 1;</font></div><div><font size="2"  >end;</font></div><div><font size="2"  >$$ language plpgsql;</font></div><p></p></pre></div><div><br></div><div>调用这个函数进行同步时, 报错出现在</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >insert into work_table_table_digoal&nbsp;</font></div><div><font size="2"  >&nbsp; (id,cn_id,cn_name,cn_type,requestor,cn_desc,create_time,cn_code,check_type,check_msg)&nbsp;</font></div><div><font size="2"  >&nbsp; select id,cn_id,cn_name,cn_type,requestor,cn_desc,create_time,cn_code,check_type,check_msg from ft_bill_table_digoal;</font></div><p></p></pre></div><div>也就是使用外部表同步过来的报错.</div><div>这句SQL拿出来在psql环境中单独执行没有问题. 只是放在函数中就出问题. 后来我不使用pgsql_fdw, 而是通过dblink创建一个远程表的视图则不会报错了.</div><div>可能是个pgsql_fdw的BUG.<br><br></div><div>【nagios监控】</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >-- 同步脚本</font></div><div><font size="2"  >postgres@db-192-168-100-33-&gt; cat sync_digoal.sh</font></div><div><font size="2"  >#!/bin/bash</font></div><div><font size="2"  >. /home/postgres/.bash_profile</font></div><div><font size="2"  >echo -e "start sync digoal1;"</font></div><div><font size="2"  >date +%F\ %T</font></div><div><font size="2"  >psql -h 127.0.0.1 digoal digoal -c "select * from sync_digoal1()";</font></div><div><font size="2"  >date +%F\ %T</font></div><div><font size="2"  >echo -e "end sync digoal1;"</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >echo -e "start sync digoal2;"</font></div><div><font size="2"  >date +%F\ %T</font></div><div><font size="2"  >psql -h 127.0.0.1 digoal digoal -c "select * from sync_digoal2()";</font></div><div><font size="2"  >date +%F\ %T</font></div><div><font size="2"  >echo -e "end sync digoal2;"</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >-- 执行计划</font></div><div><font size="2"  >postgres@db-192-168-100-33-&gt; crontab -l</font></div><div><font size="2"  ># sync digoal_data from idc1</font></div><div><font size="2"  >*/3 * * * * /home/postgres/script/sync_digoal/sync_digoal.sh &gt;&gt;/tmp/sync_digoal.log 2&gt;&amp;1</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >-- nagios配置</font></div><div><font size="2"  >[root@db-192-168-100-33 tmp]# less /usr/local/nagios/etc/nrpe.cfg&nbsp;</font></div><div><font size="2"  >command[check_sync_digoal]=/usr/local/nagios/libexec/check_sync_digoal.sh</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >-- nagios监控脚本</font></div><div><font size="2"  >[root@db-192-168-100-33 tmp]# cat /usr/local/nagios/libexec/check_sync_digoal.sh</font></div><div><font size="2"  >#!/bin/bash</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >. /home/nagios/.bash_profile</font></div><div><font size="2"  ><br></font></div><div><font size="2"  ># FILE需和 postgresql crontab里面输出的文件一致</font></div><div><font size="2"  ># ALIVE_MINUTES=20 表示20分钟内$FILE被修改过, 心跳存在. 否则心跳停止(告警).</font></div><div><font size="2"  >FILE=/tmp/sync_digoal.log</font></div><div><font size="2"  >ALIVE_MINUTES=20</font></div><div><font size="2"  >ALIVE_CNT=0</font></div><div><font size="2"  ><br></font></div><div><font size="2"  ># 文件是否存在</font></div><div><font size="2"  >if [ -f $FILE ]; then</font></div><div><font size="2"  >&nbsp; ALIVE_CNT=`find $FILE -mmin -$ALIVE_MINUTES -print|wc -l`</font></div><div><font size="2"  >&nbsp; if [ $ALIVE_CNT -eq 1 ]; then</font></div><div><font size="2"  >&nbsp; &nbsp; ERR_CNT=`tail -n 100 $FILE|grep -c ERROR`</font></div><div><font size="2"  >&nbsp; &nbsp; if [ $ERR_CNT -ge 1 ]; then</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; tail -n 100 $FILE|grep ERROR</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; exit 2</font></div><div><font size="2"  >&nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; exit 0</font></div><div><font size="2"  >&nbsp; &nbsp; fi</font></div><div><font size="2"  >&nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; echo -e "keepalive timeout $ALIVE_MINUTES mintues with FILE: $FILE."</font></div><div><font size="2"  >&nbsp; &nbsp; exit 2</font></div><div><font size="2"  >&nbsp; fi</font></div><div><font size="2"  >else</font></div><div><font size="2"  >&nbsp; echo -e "File: $FILE not exist."</font></div><div><font size="2"  >&nbsp; exit 2</font></div><div><font size="2"  >fi</font></div><p></p></pre></div><div><br></div><div>【排错】</div><div>strace -s 1024 -p 执行该函数的backend pid</div><div>执行该函数</div><div>跟踪到 :&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >lsyscache.c\0L2440\0RgetTypeOutputInfo\0\0</font></p></pre></div><div>错误来自lsyscache.c里面的getTypeOutputInfo函数 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* getTypeOutputInfo</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Get info needed for printing values of a type</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >void</font></div><div><font size="2"  >getTypeOutputInfo(Oid type, Oid *typOutput, bool *typIsVarlena)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple &nbsp; &nbsp; &nbsp; typeTuple;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type pt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; typeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (!HeapTupleIsValid(typeTuple))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "cache lookup failed for type %u", type);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; pt = (Form_pg_type) GETSTRUCT(typeTuple);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (!pt-&gt;typisdefined)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_UNDEFINED_OBJECT),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("type %s is only a shell",</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; format_type_be(type))));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (!OidIsValid(pt-&gt;typoutput))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_UNDEFINED_FUNCTION),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("no output function available for type %s",</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; format_type_be(type))));</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; *typOutput = pt-&gt;typoutput;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; *typIsVarlena = (!pt-&gt;typbyval) &amp;&amp; (pt-&gt;typlen == -1);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ReleaseSysCache(typeTuple);</font></div><div><font size="2"  >}</font></div><p></p></pre></div>或者在psql中设置一个高级选项VERBOSITY =&nbsp;verbose也可以输出详细的错误信息.<div>例如 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# \set VERBOSITY verbose</font></div><div><div><font size="2"  >digoal=# select * from f_test();</font></div><div><font size="2"  >ERROR: &nbsp;XX000: cache lookup failed for type 0</font></div><div><font size="2"  >CONTEXT: &nbsp;SQL statement "SELECT 1 from foreign_table_test limit 1"</font></div><div><font size="2"  >PL/pgSQL function "f_test" line 3 at PERFORM</font></div><div><font size="2"  >LOCATION: &nbsp;getTypeOutputInfo, lsyscache.c:2440</font></div></div><p></p></pre></div><div>VERBOSITY可以设置三个选项, &nbsp;default, verbose, terse.</div>在pgsql_fdw模块中, 调用getTypeOutputInfo函数的地方,&nbsp;<div>pgsql_fdw.c :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >getTypeOutputInfo(types[i], &amp;out_func_oid, &amp;isvarlena);</font></div><div><font size="2"  >修改为 :&nbsp;</font></div><div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ( types[i] != 0 )</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getTypeOutputInfo(types[i], &amp;out_func_oid, &amp;isvarlena);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><p></p></pre></div><div>以及&nbsp;ruleutils.c :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; getTypeOutputInfo(constval-&gt;consttype,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;typoutput, &amp;typIsVarlena);</font></div></div><div><font size="2"  >修改为 :&nbsp;</font></div><div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if ( constval-&gt;consttype != 0 )</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; getTypeOutputInfo(constval-&gt;consttype,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;typoutput, &amp;typIsVarlena);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><p></p></pre></div><div><br></div><div>重新编译pgsql_fdw模块, 重启数据库.</div><div>重新执行函数 : 报错变为 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# select * from f_test();</font></div><div><font size="2"  >ERROR: &nbsp;XX000: cache lookup failed for function 0</font></div><div><font size="2"  >CONTEXT: &nbsp;SQL statement "SELECT 1 from test limit 1"</font></div><div><font size="2"  >PL/pgSQL function "f_test" line 3 at PERFORM</font></div><div><font size="2"  >LOCATION: &nbsp;fmgr_info_cxt_security, fmgr.c:216</font></div><p></p></pre></div><div>在pgsql_fdw 模块中调用<span style="line-height: 22px;"  >fmgr_info_cxt_security函数的没有, 但是调用了</span>fmgr_info, 简介调用到了<span style="line-height: 22px;"  >fmgr_info_cxt_security.</span></div><div><span style="line-height: 22px;"  >fmgr.c :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* This routine fills a FmgrInfo struct, given the OID</font></div><div><font size="2"  >&nbsp;* of the function to be called.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* The caller's CurrentMemoryContext is used as the fn_mcxt of the info</font></div><div><font size="2"  >&nbsp;* struct; this means that any subsidiary data attached to the info struct</font></div><div><font size="2"  >&nbsp;* (either by fmgr_info itself, or later on by a function call handler)</font></div><div><font size="2"  >&nbsp;* will be allocated in that context. &nbsp;The caller must ensure that this</font></div><div><font size="2"  >&nbsp;* context is at least as long-lived as the info struct itself. &nbsp;This is</font></div><div><font size="2"  >&nbsp;* not a problem in typical cases where the info struct is on the stack or</font></div><div><font size="2"  >&nbsp;* in freshly-palloc'd space. &nbsp;However, if one intends to store an info</font></div><div><font size="2"  >&nbsp;* struct in a long-lived table, it's better to use fmgr_info_cxt.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >void</font></div><div><font size="2"  >fmgr_info(Oid functionId, FmgrInfo *finfo)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fmgr_info_cxt(functionId, finfo, CurrentMemoryContext);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Fill a FmgrInfo struct, specifying a memory context in which its</font></div><div><font size="2"  >&nbsp;* subsidiary data should go.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >void</font></div><div><font size="2"  >fmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fmgr_info_cxt_security(functionId, finfo, mcxt, false);</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div><br></div><div>pgsql_fdw.c :&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >fmgr_info(out_func_oid, &amp;func);</font></p></pre></div><div><br></div><div>【补充】</div><div>1. 创建一个pgsql_fdw外部表的视图, 把上面的函数中的外部表改为视图, 错误依旧.</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >postgres=# create view v_test as select * from test;</font></div><div><font size="2"  >CREATE VIEW</font></div><div><font size="2"  >postgres=# select * from v_test;</font></div><div><font size="2"  >&nbsp;id | &nbsp;info &nbsp;</font></div><div><font size="2"  >----+--------</font></div><div><font size="2"  >&nbsp; 1 | DIGOAL</font></div><div><font size="2"  >(1 row)</font></div></div><div><div><font size="2"  >postgres=# CREATE OR REPLACE FUNCTION public.f_test()</font></div><div><font size="2"  >&nbsp;RETURNS integer</font></div><div><font size="2"  >&nbsp;LANGUAGE plpgsql</font></div><div><font size="2"  >AS $function$</font></div><div><font size="2"  >declare</font></div><div><font size="2"  >begin</font></div><div><font size="2"  >perform 1 from v_test limit 1;</font></div><div><font size="2"  >return 1;</font></div><div><font size="2"  >end;</font></div><div><font size="2"  >$function$;</font></div><div><font size="2"  >CREATE FUNCTION</font></div></div><div><div><font size="2"  >postgres=# select * from f_test();</font></div><div><font size="2"  >ERROR: &nbsp;cache lookup failed for type 0</font></div><div><font size="2"  >CONTEXT: &nbsp;SQL statement "SELECT 1 from v_test limit 1"</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; PL/pgSQL function "f_test" line 4 at PERFORM</font></div><div><font size="2"  >STATEMENT: &nbsp;select * from f_test();</font></div></div><p></p></pre></div><div><br></div><div>2. 在SQL函数中使用pgsql_fdw的外部表正常.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# create or replace function f_test1() returns int as $$</font></div><div><font size="2"  >postgres$# select id from test limit 1;</font></div><div><font size="2"  >postgres$# $$ language sql;</font></div><div><font size="2"  >CREATE FUNCTION</font></div><div><font size="2"  >postgres=# select * from f_test1();</font></div><div><font size="2"  >&nbsp;f_test1&nbsp;</font></div><div><font size="2"  >---------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div>3. 在plpgsql函数中使用oracle fdw的外部表没有异常.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >charge_sync=&gt; create or replace function f_test () returns int as $$</font></div><div><font size="2"  >charge_sync$&gt; declare</font></div><div><font size="2"  >charge_sync$&gt; begin</font></div><div><font size="2"  >charge_sync$&gt; perform 1 from ora_tbl limit 1;</font></div><div><font size="2"  >charge_sync$&gt; return 0;</font></div><div><font size="2"  >charge_sync$&gt; end;</font></div><div><font size="2"  >charge_sync$&gt; $$ language plpgsql;</font></div><div><font size="2"  >CREATE FUNCTION</font></div><div><font size="2"  >charge_sync=&gt; select * from f_test();</font></div><div><font size="2"  >&nbsp;f_test&nbsp;</font></div><div><font size="2"  >--------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; 0</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div>【参考】</div><div>pgsql_fdw.c</div><div>src/backend/utils/fmgr/fmgr.c</div><div>src/backend/utils/cache/lsyscache.c</div></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">francs - 2012-06-30 14:27:23</h5>
				<div><P>测试了下，在pgsql&nbsp;语言&nbsp;function 中用 excute 命令可以正常调用 pgsql_fdw 外部表 ，例如函数:</P>  <P>&nbsp;CREATE or replace FUNCTION&nbsp; func_sync_bill() RETURNS INTEGER&nbsp; AS $$<BR>&nbsp;&nbsp;&nbsp;&nbsp; BEGIN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXECUTE 'insert into test_tf (id,name) select id,name from ft_test';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end; <BR>&nbsp;&nbsp;&nbsp;&nbsp; END;<BR>&nbsp;$$ LANGUAGE 'plpgsql';&nbsp;&nbsp;&nbsp; </P></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 francs - 2012-06-30 14:27:23</h5>
				<div style="width:600px;">硬解析正常,软解析异常.</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 francs - 2012-06-30 14:27:23</h5>
				<div style="width:600px;">暂时还没有人来处理这个BUG<div>http://postgresql.1045698.n5.nabble.com/BUG-6708-pgsql-fdw-s-foreign-table-cann-t-used-in-plpgsql-function-td5714385.html&nbsp;<br><br></div></div>
			</div>
			<div id="">
				<h5 id="">francs - 2012-06-25 17:26:32</h5>
				<div>感觉是 catalog 系统表里缺少相关信息</div>
			</div>
	</div>
</div>
</body>
</html>