<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap examples, DISK IO - 7 Periodically Print I/O Block Time</h2>
	<h5 id="">2013-11-19 10:24:28&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013101993142404/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>例子来自ioblktime.stp 脚本, 该脚本用以统计每个块设备的io块请求情况, 请求次数, io操作耗费的时间以systemtap的统计变量进程存储, 可以得到块设备上io块请求的平均时间, 总时间, 最大, 最小时间, 次数, 柱状图等等.</div><div>因为内核支持合并块操作, 所以通过ioblock.request触发的块请求, 可能被合并掉, 因此通过对函数kernel.trace("block_bio_frontmerge"),&nbsp;kernel.trace("block_bio_backmerge")的事件跟踪, 可以得到块设备上精确的块操作统计情况.</div><div>脚本内容以及注解 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 network]# cd /usr/share/systemtap/testsuite/systemtap.examples/io</font></div><div><div><font size="2"   >[root@db-172-16-3-150 io]# cat ioblktime.stp</font></div><div><font size="2"   >#!/usr/bin/stap</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >global req_time, etimes</font></div><div><font size="2"   >// req_time数组, 索引为上下文变量bio的内存地址. 值为当前时间</font></div><div><font size="2"   >// etimes数组, 索引为设备名, R|W字符串. 存储的值为ioblock的整个操作耗时的统计变量.</font></div><div><font size="2"   >// 如果数组元素超过默认的2048可能会导致运行错误退出, 那么可使用stap -D <span style="line-height: 21px;"   >MAXMAPENTRIES=10240或者更大的值来规避这个错误,</span></font></div><div><font size="2"   ><span style="line-height: 21px;"   >// 或者指定数组的长度global req_time[100000] 或者是使用rotate数组global req_time%[10000]</span></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe ioblock.request</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; req_time[$bio] = gettimeofday_us()</font></div><div><font size="2"   >}</font></div><div><font size="2"   >// 当ioblock请求发生时, 记录下内存地址和当前时间</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe ioblock.end</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; t = gettimeofday_us() &nbsp;// 当前事件</font></div><div><font size="2"   >&nbsp; s = &nbsp;req_time[$bio] &nbsp;// 根据bio找到ioblock.request事件记录的请求开始时间.</font></div><div><font size="2"   >&nbsp; delete req_time[$bio] &nbsp;// 删除请求开始时间</font></div><div><font size="2"   >&nbsp; if (s) { &nbsp;// 当请求未被合并时, 记录此次io操作的耗时.</font></div><div><font size="2"   >&nbsp; &nbsp; etimes[devname, bio_rw_str(rw)] &lt;&lt;&lt; t - s</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   >// 当io操作结束时, 记录下io操作耗时, 存放至统计数组.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* for time being delete things that get merged with others */</font></div><div><font size="2"   >probe kernel.trace("block_bio_frontmerge"),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; kernel.trace("block_bio_backmerge")</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; delete req_time[$bio] &nbsp;// 发生io合并时, 删除请求开始事件.</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe timer.s(10), end {</font></div><div><font size="2"   >&nbsp; ansi_clear_screen() &nbsp;// 清屏</font></div><div><font size="2"   >&nbsp; printf("%10s %3s %10s %10s %10s\n",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"device", "rw", "total (us)", "count", "avg (us)") &nbsp;// 输出头信息</font></div><div><font size="2"   >&nbsp; foreach ([dev,rw] in etimes - limit 20) {</font></div><div><font size="2"   >&nbsp; &nbsp; printf("%10s %3s %10d %10d %10d\n", dev, rw,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;@sum(etimes[dev,rw]), @count(etimes[dev,rw]), @avg(etimes[dev,rw]))</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >// 输出实际的io操作次数排名前20位的信息. 包含设备名, 读写, 总耗时, 实际io操作次数, 平均每次io的耗时.</font></div><div><font size="2"   >&nbsp; delete etimes</font></div><div><font size="2"   >// 删除统计变量数组, 下10秒重新统计</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><br></div><div>执行输出举例 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 io]# stap ioblktime.stp</font></div><div><div><font size="2"   >&nbsp; &nbsp; device &nbsp;rw total (us) &nbsp; &nbsp; &nbsp;count &nbsp; avg (us)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;sdd &nbsp; W &nbsp; &nbsp;5831844 &nbsp; &nbsp; &nbsp; 2884 &nbsp; &nbsp; &nbsp; 2022</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; sdd1 &nbsp; W &nbsp; &nbsp; &nbsp;12091 &nbsp; &nbsp; &nbsp; 2868 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;sdb &nbsp; W &nbsp; &nbsp; &nbsp; 9210 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; 1151</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; sdb1 &nbsp; W &nbsp; &nbsp; &nbsp; &nbsp;279 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; 46</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;sda &nbsp; W &nbsp; &nbsp; &nbsp;43526 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp;10881</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;sde &nbsp; W &nbsp; &nbsp; &nbsp; &nbsp;580 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp;193</font></div></div><p></p></pre></div><div><br></div><div>本文用到的几个probe alias原型(包含对应的call原型).</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 io]# less /usr/share/systemtap/tapset/ioblock.stp</font></div><div><div><font size="2"   >/**</font></div><div><font size="2"   >&nbsp;* &nbsp;probe ioblock.request - Fires whenever making a generic block I/O request.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp;@name &nbsp; &nbsp; &nbsp;- name of the probe point</font></div><div><font size="2"   >&nbsp;* &nbsp;@devname &nbsp; - block device name</font></div><div><font size="2"   >&nbsp;* &nbsp;@ino &nbsp; &nbsp; &nbsp; - i-node number of the mapped file</font></div><div><font size="2"   >&nbsp;* &nbsp;@sector &nbsp; &nbsp;- beginning sector for the entire bio</font></div><div><font size="2"   >&nbsp;* &nbsp;@flags &nbsp; &nbsp; - see below</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_UPTODATE &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; ok after I/O completion</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_RW_BLOCK &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; RW_AHEAD set, and read/write would block</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_EOF &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; out-out-bounds error</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_SEG_VALID &nbsp; 3 &nbsp; &nbsp; &nbsp; nr_hw_seg valid&nbsp;</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_CLONED &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; doesn't own data</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_BOUNCED &nbsp; &nbsp; 5 &nbsp; &nbsp; &nbsp; bio is a bounce bio</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_USER_MAPPED 6 &nbsp; &nbsp; &nbsp; contains user pages</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_EOPNOTSUPP &nbsp;7 &nbsp; &nbsp; &nbsp; not supported</font></div><div><font size="2"   >&nbsp;* &nbsp;</font></div><div><font size="2"   >&nbsp;* &nbsp;@rw &nbsp; &nbsp; &nbsp; &nbsp;- binary trace for read/write request</font></div><div><font size="2"   >&nbsp;* &nbsp;@vcnt &nbsp; &nbsp; &nbsp;- bio vector count which represents number of array element (page, offset, length) which make up this I/O request</font></div><div><font size="2"   >&nbsp;* &nbsp;@idx &nbsp; &nbsp; &nbsp; - offset into the bio vector array</font></div><div><font size="2"   >&nbsp;* &nbsp;@phys_segments - number of segments in this bio after physical address coalescing is performed</font></div><div><font size="2"   >&nbsp;* &nbsp;@hw_segments - &nbsp; number of segments after physical and DMA remapping hardware coalescing is performed</font></div><div><font size="2"   >&nbsp;* &nbsp;@size &nbsp; &nbsp; &nbsp;- total size in bytes</font></div><div><font size="2"   >&nbsp;* &nbsp;@bdev &nbsp; &nbsp; &nbsp;- target block device</font></div><div><font size="2"   >&nbsp;* &nbsp;@bdev_contains - points to the device object which contains the partition (when bio structure represents a partition)</font></div><div><font size="2"   >&nbsp;* &nbsp;@p_start_sect - &nbsp;points to the start sector of the partition structure of the device</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Context:</font></div><div><font size="2"   >&nbsp;* &nbsp;The process makes block I/O request</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >probe ioblock.request = kernel.function ("generic_make_request")</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "ioblock.request"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; devname = __bio_devname($bio)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ino = __bio_ino($bio)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; sector = $bio-&gt;bi_sector</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; flags = $bio-&gt;bi_flags</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rw = $bio-&gt;bi_rw</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; vcnt = $bio-&gt;bi_vcnt</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; idx = $bio-&gt;bi_idx</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; phys_segments = $bio-&gt;bi_phys_segments</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; hw_segments = (@defined($bio-&gt;bi_hw_segments)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;? $bio-&gt;bi_hw_segments : 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; size = $bio-&gt;bi_size</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bdev = $bio-&gt;bi_bdev</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bdev_contains = $bio-&gt;bi_bdev-&gt;bd_contains</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; p_start_sect = __bio_start_sect($bio)</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/**</font></div><div><font size="2"   >&nbsp;* probe ioblock.end - Fires whenever a block I/O transfer is complete.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp;@name &nbsp; &nbsp; &nbsp;- name of the probe point</font></div><div><font size="2"   >&nbsp;* &nbsp;@devname &nbsp; - block device name</font></div><div><font size="2"   >&nbsp;* &nbsp;@ino &nbsp; &nbsp; &nbsp; - i-node number of the mapped file</font></div><div><font size="2"   >&nbsp;* &nbsp;@bytes_done - number of bytes transferred</font></div><div><font size="2"   >&nbsp;* &nbsp;@sector &nbsp; &nbsp;- beginning sector for the entire bio</font></div><div><font size="2"   >&nbsp;* &nbsp;@flags &nbsp; &nbsp; - see below</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_UPTODATE &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; ok after I/O completion</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_RW_BLOCK &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; RW_AHEAD set, and read/write would block</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_EOF &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; out-out-bounds error</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_SEG_VALID &nbsp; 3 &nbsp; &nbsp; &nbsp; nr_hw_seg valid</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_CLONED &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; doesn't own data</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_BOUNCED &nbsp; &nbsp; 5 &nbsp; &nbsp; &nbsp; bio is a bounce bio</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_USER_MAPPED 6 &nbsp; &nbsp; &nbsp; contains user pages</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;BIO_EOPNOTSUPP &nbsp;7 &nbsp; &nbsp; &nbsp; not supported</font></div><div><font size="2"   >&nbsp;* &nbsp;@error &nbsp; &nbsp; - 0 on success</font></div><div><font size="2"   >&nbsp;* &nbsp;@rw &nbsp; &nbsp; &nbsp; &nbsp;- binary trace for read/write request</font></div><div><font size="2"   >&nbsp;* &nbsp;@vcnt &nbsp; &nbsp; &nbsp;- bio vector count which represents number of array element (page, offset, length) which makes up this I/O request</font></div><div><font size="2"   >&nbsp;* &nbsp;@idx &nbsp; &nbsp; &nbsp; - offset into the bio vector array</font></div><div><font size="2"   >&nbsp;* &nbsp;@phys_segments - number of segments in this bio after physical address coalescing is performed.</font></div><div><font size="2"   >&nbsp;* &nbsp;@hw_segments - &nbsp; number of segments after physical and DMA remapping hardware coalescing is performed</font></div><div><font size="2"   >&nbsp;* &nbsp;@size &nbsp; &nbsp; &nbsp;- total size in bytes</font></div><div><font size="2"   >&nbsp;*</font></div></div><div><div><font size="2"   >&nbsp;* Context:</font></div><div><font size="2"   >&nbsp;* &nbsp;The process signals the transfer is done.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >probe ioblock.end = kernel.function("bio_endio")</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "ioblock.end"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; devname = __bio_devname($bio)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ino = __bio_ino($bio)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bytes_done = (@defined($bytes_done) ? $bytes_done : $bio-&gt;bi_size)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; error = $error</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; sector = $bio-&gt;bi_sector</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; flags = $bio-&gt;bi_flags</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rw = $bio-&gt;bi_rw</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; vcnt = $bio-&gt;bi_vcnt</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; idx = $bio-&gt;bi_idx</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; phys_segments = $bio-&gt;bi_phys_segments</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; hw_segments = (@defined($bio-&gt;bi_hw_segments)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;? $bio-&gt;bi_hw_segments : 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; size = $bio-&gt;bi_size</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >// 把ioblock.end的rw变量转换成R,W字符串</font></div><div><div><font size="2"   >/* returns 0 for read, 1 for write */</font></div><div><font size="2"   >function bio_rw_num:long(rw:long)</font></div><div><font size="2"   >%{ /* pure */</font></div><div><font size="2"   >&nbsp; &nbsp; long rw = (long)STAP_ARG_rw;</font></div><div><font size="2"   >&nbsp; &nbsp; STAP_RETVALUE = (rw &amp; REQ_WRITE);</font></div><div><font size="2"   >%}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* returns R for read, W for write */</font></div><div><font size="2"   >function bio_rw_str(rw:long)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; return bio_rw_num(rw) == BIO_READ ? "R" : "W"</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><br></div><div>这几个函数的源码位置信息:&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-150 io]# stap -L 'kernel.function ("generic_make_request")'</font></div><div><font size="2"   >kernel.function("generic_make_request@block/blk-core.c:1770") $bio:struct bio*</font></div><div><font size="2"   >[root@db-172-16-3-150 io]# stap -L 'kernel.function ("bio_endio")'</font></div><div><font size="2"   >kernel.function("bio_endio@fs/bio.c:1425") $bio:struct bio* $error:int</font></div></div><div><div><font size="2"   >[root@db-172-16-3-150 io]# stap -L 'kernel.trace("block_bio_backmerge")'</font></div><div><font size="2"   >kernel.trace("block_bio_backmerge") $q:struct request_queue* $bio:struct bio*</font></div><div><font size="2"   >[root@db-172-16-3-150 io]# stap -L 'kernel.trace("block_bio_frontmerge")'</font></div><div><font size="2"   >kernel.trace("block_bio_frontmerge") $q:struct request_queue* $bio:struct bio*</font></div></div><p></p></pre></div><div><br></div><div>源码 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/usr/src/debug/kernel-2.6.32-358.el6/linux-2.6.32-358.el6.x86_64/block/blk-core.c</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* We only want one -&gt;make_request_fn to be active at a time,</font></div><div><font size="2"   >&nbsp;* else stack usage with stacked devices could be a problem.</font></div><div><font size="2"   >&nbsp;* So use current-&gt;bio_{list,tail} to keep a list of requests</font></div><div><font size="2"   >&nbsp;* submited by a make_request_fn function.</font></div><div><font size="2"   >&nbsp;* current-&gt;bio_tail is also used as a flag to say if</font></div><div><font size="2"   >&nbsp;* generic_make_request is currently active in this task or not.</font></div><div><font size="2"   >&nbsp;* If it is NULL, then no make_request is active. &nbsp;If it is non-NULL,</font></div><div><font size="2"   >&nbsp;* then a make_request is active, and new requests should be added</font></div><div><font size="2"   >&nbsp;* at the tail</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void generic_make_request(struct bio *bio)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (current-&gt;bio_tail) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* make_request is active */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(current-&gt;bio_tail) = bio;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bio-&gt;bi_next = NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current-&gt;bio_tail = &amp;bio-&gt;bi_next;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* following loop may be a bit non-obvious, and so deserves some</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* explanation.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Before entering the loop, bio-&gt;bi_next is NULL (as all callers</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ensure that) so we have a list with a single bio.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We pretend that we have just taken it off a longer list, so</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we assign bio_list to the next (which is NULL) and bio_tail</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to &amp;bio_list, thus initialising the bio_list of new bios to be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* added. &nbsp;__generic_make_request may indeed add some more bios</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* through a recursive call to generic_make_request. &nbsp;If it</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* did, we find a non-NULL value in bio_list and re-enter the loop</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* from the top. &nbsp;In this case we really did just take the bio</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* of the top of the list (no pretending) and so fixup bio_list and</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* bio_tail or bi_next, and call into __generic_make_request again.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The loop was structured like this to make only one call to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* __generic_make_request (which is important as it is large and</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* inlined) and to keep the structure simple.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; BUG_ON(bio-&gt;bi_next);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; do {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current-&gt;bio_list = bio-&gt;bi_next;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (bio-&gt;bi_next == NULL)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current-&gt;bio_tail = &amp;current-&gt;bio_list;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bio-&gt;bi_next = NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; __generic_make_request(bio);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bio = current-&gt;bio_list;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; } while (bio);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; current-&gt;bio_tail = NULL; /* deactivate */</font></div><div><font size="2"   >}</font></div><div><font size="2"   >EXPORT_SYMBOL(generic_make_request);</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >/usr/src/debug/kernel-2.6.32-358.el6/linux-2.6.32-358.el6.x86_64/fs/bio.c</font></div><div><div><font size="2"   >/**</font></div><div><font size="2"   >&nbsp;* bio_endio - end I/O on a bio</font></div><div><font size="2"   >&nbsp;* @bio: &nbsp; &nbsp; &nbsp; &nbsp;bio</font></div><div><font size="2"   >&nbsp;* @error: &nbsp; &nbsp; &nbsp;error, if any</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Description:</font></div><div><font size="2"   >&nbsp;* &nbsp; bio_endio() will end I/O on the whole bio. bio_endio() is the</font></div><div><font size="2"   >&nbsp;* &nbsp; preferred way to end I/O on a bio, it takes care of clearing</font></div><div><font size="2"   >&nbsp;* &nbsp; BIO_UPTODATE on error. @error is 0 on success, and and one of the</font></div><div><font size="2"   >&nbsp;* &nbsp; established -Exxxx (-EIO, for instance) error values in case</font></div><div><font size="2"   >&nbsp;* &nbsp; something went wrong. Noone should call bi_end_io() directly on a</font></div><div><font size="2"   >&nbsp;* &nbsp; bio unless they own it and thus know that it has an end_io</font></div><div><font size="2"   >&nbsp;* &nbsp; function.</font></div><div><font size="2"   >&nbsp;**/</font></div><div><font size="2"   >void bio_endio(struct bio *bio, int error)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (error)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clear_bit(BIO_UPTODATE, &amp;bio-&gt;bi_flags);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else if (!test_bit(BIO_UPTODATE, &amp;bio-&gt;bi_flags))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error = -EIO;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (bio-&gt;bi_end_io)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bio-&gt;bi_end_io(bio, error);</font></div><div><font size="2"   >}</font></div><div><font size="2"   >EXPORT_SYMBOL(bio_endio);</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >/usr/src/debug/kernel-2.6.32-358.el6/linux-2.6.32-358.el6.x86_64/include/trace/events/block.h</font></div><div><div><font size="2"   >DECLARE_EVENT_CLASS(block_bio,<br><br>        TP_PROTO(struct request_queue *q, struct bio *bio),<br><br>        TP_ARGS(q, bio),<br><br>        TP_STRUCT__entry(<br>                __field( dev_t,         dev                     )<br>                __field( sector_t,      sector                  )<br>                __field( unsigned int,  nr_sector               )<br>                __array( char,          rwbs,   RWBS_LEN        )<br>                __array( char,          comm,   TASK_COMM_LEN   )<br>        ),<br><br>        TP_fast_assign(<br>                __entry-&gt;dev            = bio-&gt;bi_bdev-&gt;bd_dev;<br>                __entry-&gt;sector         = bio-&gt;bi_sector;<br>                __entry-&gt;nr_sector      = bio-&gt;bi_size &gt;&gt; 9;<br>                blk_fill_rwbs(__entry-&gt;rwbs, bio-&gt;bi_rw, bio-&gt;bi_size);<br>                memcpy(__entry-&gt;comm, current-&gt;comm, TASK_COMM_LEN);<br>        ),<br><br>        TP_printk("%d,%d %s %llu + %u [%s]",<br>                  MAJOR(__entry-&gt;dev), MINOR(__entry-&gt;dev), __entry-&gt;rwbs,<br>                  (unsigned long long)__entry-&gt;sector,<br>                  __entry-&gt;nr_sector, __entry-&gt;comm)<br>);</font></div><div><font size="2"   >DEFINE_EVENT(block_bio, block_bio_backmerge,</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TP_PROTO(struct request_queue *q, struct bio *bio),</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TP_ARGS(q, bio)</font></div><div><font size="2"   >);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >DEFINE_EVENT(block_bio, block_bio_frontmerge,</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TP_PROTO(struct request_queue *q, struct bio *bio),</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TP_ARGS(q, bio)</font></div><div><font size="2"   >);</font></div></div><p></p></pre></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide/mainsect-disk.html"   >https://sourceware.org/systemtap/SystemTap_Beginners_Guide/mainsect-disk.html</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://sourceware.org/systemtap/examples/"   >https://sourceware.org/systemtap/examples/</a></div><div>3. /usr/share/systemtap/testsuite/systemtap.examples</div><div>4. systemtap-testsuite</div><div>5. /usr/share/systemtap/testsuite/systemtap.examples/index.txt</div><div>6. /usr/share/systemtap/testsuite/systemtap.examples/keyword-index.txt</div><div>7. /usr/share/systemtap/tapset</div><div>8.&nbsp;<a style="line-height: 28px;" rel="nofollow" href="https://sourceware.org/systemtap/tapsets/API-ansi-clear-screen.html"   >https://sourceware.org/systemtap/tapsets/API-ansi-clear-screen.html</a></div><div><br></div><wbr></div>
	</div>
</div>
</body>
</html>