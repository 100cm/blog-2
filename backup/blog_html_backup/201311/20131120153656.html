<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap examples, Profiling - 4 Monitoring Polling Applications</h2>
	<h5 id="">2013-11-20 15:36:56&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201310201070658/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>例子来自<span style="line-height: 28px;"   >timeout.stp</span>&nbsp;脚本, 输出系统中指定的系统调用(poll, select, epoll, itimer, futex, nanosleep, signal)等待次数排行前20的进程以及各系统调用的等待次数的统计信息<span style="line-height: 28px;"   >.</span></div><div>脚本内容以及注解 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 network]# cd /usr/share/systemtap/testsuite/systemtap.examples/profiling</font></div><div><div><font size="2"   >[root@db-172-16-3-150 profiling]# cat timeout.stp</font></div><div><font size="2"   >#!/usr/bin/stap</font></div><div><font size="2"   ># Copyright (C) 2009 Red Hat, Inc.</font></div><div><font size="2"   ># Written by Ulrich Drepper &lt;drepper@redhat.com&gt;</font></div><div><font size="2"   ># Modified by William Cohen &lt;wcohen@redhat.com&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >global process, timeout_count, to</font></div><div><font size="2"   >global poll_timeout, epoll_timeout, select_timeout, itimer_timeout</font></div><div><font size="2"   >global nanosleep_timeout, futex_timeout, signal_timeout</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe syscall.poll, syscall.epoll_wait { &nbsp; &nbsp;// &nbsp;<span style="line-height: 28px;"   >epoll_wait</span><span style="line-height: 28px;"   >&nbsp;:&nbsp;</span><span style="line-height: 28px;"   >wait for an I/O event on an epoll file descriptor</span></font></div><div><font size="2"   >&nbsp; if (timeout) to[pid()]=timeout &nbsp; &nbsp;// 如果timeout大于0 , 说明有等待. 设置to[pid()]=timeout. &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; // &nbsp;后面会用到这个标记判断poll和epoll_wait系统调用是否发生超时.</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe syscall.poll.return { &nbsp; &nbsp;//&nbsp;wait for some event on a file descriptor</font></div><div><font size="2"   >&nbsp; p = pid()</font></div><div><font size="2"   >&nbsp; if ($return == 0 &amp;&amp; to[p] &gt; 0 ) { &nbsp;// 返回值=0并且poll, epoll_wait的系统调用等待时间大于0表示发生等待.</font></div><div><font size="2"   >&nbsp; &nbsp; poll_timeout[p]++ &nbsp; &nbsp;// 增加一次进程p的系统调用poll的超时计数</font></div><div><font size="2"   >&nbsp; &nbsp; timeout_count[p]++ &nbsp; &nbsp;<span style="line-height: 28px;"   >// 增加一次进程p的超时计数</span></font></div><div><font size="2"   >&nbsp; &nbsp; process[p] = execname() &nbsp;// 记录pid对应的命令名</font></div><div><font size="2"   >&nbsp; &nbsp; delete to[p] &nbsp;// 删除to[p],&nbsp;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe syscall.epoll_wait.return { &nbsp; &nbsp;//&nbsp;<span style="line-height: 28px;"   >&nbsp;</span><span style="line-height: 28px;"   >wait for an I/O event on an epoll file descriptor</span></font></div><div><font size="2"   >&nbsp; p = pid()</font></div><div><font size="2"   >&nbsp; if ($return == 0 &amp;&amp; to[p] &gt; 0 ) {</font></div><div><font size="2"   >&nbsp; &nbsp; epoll_timeout[p]++ &nbsp;&nbsp;<span style="line-height: 28px;"   >// 增加一次进程p的系统调用epoll的超时计数</span></font></div><div><font size="2"   >&nbsp; &nbsp; timeout_count[p]++ &nbsp; &nbsp;<span style="line-height: 28px;"   >// 增加一次进程p的超时计数</span></font></div><div><font size="2"   >&nbsp; &nbsp; process[p] = execname() &nbsp; &nbsp;<span style="line-height: 28px;"   >// 记录pid对应的命令名</span></font></div><div><font size="2"   >&nbsp; &nbsp; delete to[p] &nbsp;&nbsp;<span style="line-height: 28px;"   >// 删除to[p],&nbsp;</span></font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe syscall.select.return { &nbsp; &nbsp;// &nbsp;synchronous I/O multiplexing,&nbsp;<span style="line-height: 28px;"   >allow a program to monitor multiple file descriptors,&nbsp;</span></font></div><div><font size="2"   ><span style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// &nbsp;waiting until one or more of the</span><span style="line-height: 28px;"   >&nbsp;file descriptors become "ready" for some class of I/O operation</span></font></div><div><font size="2"   >&nbsp; if ($return == 0) { &nbsp; &nbsp; // select 系统调用返回0时, 说明调用正常.&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; p = pid()</font></div><div><font size="2"   >&nbsp; &nbsp; select_timeout[p]++</font></div><div><font size="2"   >&nbsp; &nbsp; timeout_count[p]++</font></div><div><font size="2"   >&nbsp; &nbsp; process[p] = execname()</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe syscall.futex.return { &nbsp; &nbsp;//&nbsp;Fast Userspace Locking system call,&nbsp;</font></div><div><font size="2"   >// &nbsp;The futex() system call provides a method for a program to wait for a value at a given address to change</font></div><div><font size="2"   >// &nbsp;method to wake up anyone waiting on a particular address (while the addresses for the same memory &nbsp;in &nbsp;separate</font></div><div><font size="2"   >// &nbsp;processes &nbsp;may &nbsp;not &nbsp;be equal, the kernel maps them internally so the same memory mapped in different locations</font></div><div><font size="2"   >// &nbsp;will correspond for futex() calls). &nbsp;It is typically used to implement the contended case of a lock &nbsp;in &nbsp;shared</font></div><div><font size="2"   >// &nbsp;memory, as described in futex(7).</font></div><div><font size="2"   >&nbsp; if (errno_str($return) == "ETIMEDOUT") { &nbsp; &nbsp;// &nbsp;futex系统调用返回值$return.&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; // &nbsp;使用<span style="line-height: 28px;"   >errno_str转换成字符串, 如果等于</span><span style="line-height: 28px;"   >ETIMEDOUT说明发生了等待.</span></font></div><div><font size="2"   ><span style="line-height: 28px;"   >&nbsp; &nbsp; // &nbsp;</span>Returns &nbsp;0 &nbsp;if the process was woken by a FUTEX_WAKE call. &nbsp;In case of timeout, the operation fails with</font></div><div><font size="2"   >&nbsp; &nbsp; // &nbsp;the error ETIMEDOUT.</font></div><div><font size="2"   >&nbsp; &nbsp; p = pid()</font></div><div><font size="2"   >&nbsp; &nbsp; futex_timeout[p]++</font></div><div><font size="2"   >&nbsp; &nbsp; timeout_count[p]++</font></div><div><font size="2"   >&nbsp; &nbsp; process[p] = execname()</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe syscall.nanosleep.return { &nbsp;//&nbsp;high-resolution sleep</font></div><div><font size="2"   >// &nbsp;nanosleep() &nbsp;suspends &nbsp;the execution of the calling thread until either at least the time specified in *req has</font></div><div><font size="2"   >// &nbsp;elapsed, or the delivery of a signal that triggers the invocation of a handler in the calling &nbsp;thread &nbsp;or &nbsp;that</font></div><div><font size="2"   >// &nbsp;terminates the process.</font></div><div><font size="2"   >&nbsp; if ($return == 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; p = pid()</font></div><div><font size="2"   >&nbsp; &nbsp; nanosleep_timeout[p]++ &nbsp; &nbsp;//&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; timeout_count[p]++</font></div><div><font size="2"   >&nbsp; &nbsp; process[p] = execname()</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe kernel.function("it_real_fn") { &nbsp; &nbsp;// &nbsp;The timer is automagically restarted, when interval != 0</font></div><div><font size="2"   >&nbsp; p = pid()</font></div><div><font size="2"   >&nbsp; itimer_timeout[p]++</font></div><div><font size="2"   >&nbsp; timeout_count[p]++</font></div><div><font size="2"   >&nbsp; process[p] = execname()</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe syscall.rt_sigtimedwait.return { &nbsp; //&nbsp;synchronously wait for queued signals.</font></div><div><font size="2"   >&nbsp; if (errno_str($return) == "EAGAIN") { &nbsp; &nbsp;<span style="line-height: 28px;"   >// &nbsp;</span><span style="line-height: 28px;"   >rt_sigtimedwait</span><span style="line-height: 28px;"   >系统调用返回值$return.&nbsp;</span></font></div><div><font size="2"   ><span style="line-height: 28px;"   >&nbsp; &nbsp; // &nbsp;使用</span><span style="line-height: 28px;"   >errno_str转换成字符串, 如果等于</span><span style="line-height: 28px;"   >EAGAIN</span><span style="line-height: 28px;"   >说明发生了等待.</span></font></div><div><font size="2"   ><span style="line-height: 28px;"   >&nbsp; &nbsp; // &nbsp;</span>EAGAIN No signal in set was delivered within the timeout period specified to sigtimedwait().</font></div><div><font size="2"   >&nbsp; &nbsp; p = pid()</font></div><div><font size="2"   >&nbsp; &nbsp; signal_timeout[p]++</font></div><div><font size="2"   >&nbsp; &nbsp; timeout_count[p]++</font></div><div><font size="2"   >&nbsp; &nbsp; process[p] = execname()</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe syscall.exit { &nbsp; &nbsp;// 当系统调用结束时, 清除计数</font></div><div><font size="2"   >&nbsp; p = pid()</font></div><div><font size="2"   >&nbsp; if (p in process) { &nbsp; // 当p在<span style="line-height: 28px;"   >process这个数组中时, 清除所有相关的计数.</span></font></div><div><font size="2"   >&nbsp; &nbsp; delete process[p]</font></div><div><font size="2"   >&nbsp; &nbsp; delete timeout_count[p]</font></div><div><font size="2"   >&nbsp; &nbsp; delete poll_timeout[p]</font></div><div><font size="2"   >&nbsp; &nbsp; delete epoll_timeout[p]</font></div><div><font size="2"   >&nbsp; &nbsp; delete select_timeout[p]</font></div><div><font size="2"   >&nbsp; &nbsp; delete itimer_timeout[p]</font></div><div><font size="2"   >&nbsp; &nbsp; delete futex_timeout[p]</font></div><div><font size="2"   >&nbsp; &nbsp; delete nanosleep_timeout[p]</font></div><div><font size="2"   >&nbsp; &nbsp; delete signal_timeout[p]</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe timer.s(1) {</font></div><div><font size="2"   >&nbsp; ansi_clear_screen() &nbsp; &nbsp;// &nbsp;清屏</font></div><div><font size="2"   >&nbsp; printf (" &nbsp;pid | &nbsp; poll &nbsp;select &nbsp; epoll &nbsp;itimer &nbsp; futex nanosle &nbsp;signal| process\n") &nbsp; &nbsp;// 输出头</font></div><div><font size="2"   >&nbsp; foreach (p in timeout_count- limit 20) { &nbsp; &nbsp;// &nbsp;<span style="line-height: 28px;"   >timeout_count用于排序, 输出等待次数前20位的进程</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;printf ("%5d |%7d %7d %7d %7d %7d %7d %7d| %-.38s\n", p,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; poll_timeout[p], select_timeout[p],</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; epoll_timeout[p], itimer_timeout[p],</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; futex_timeout[p], nanosleep_timeout[p],</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; signal_timeout[p], process[p])</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   >// 间隔1秒输出poll, select, epoll, itimer, futex, nanosleep, signal等系统调用在这1秒内的等待次数.</font></div><p></p></pre></div><div><br></div><div>执行输出举例 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 profiling]# stap timeout.stp</font></div><div><div><font size="2"   >&nbsp; pid | &nbsp; poll &nbsp;select &nbsp; epoll &nbsp;itimer &nbsp; futex nanosle &nbsp;signal| process</font></div><div><font size="2"   >&nbsp;7121 | &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0| postgres</font></div><div><font size="2"   >&nbsp;7120 | &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0| postgres</font></div><div><font size="2"   >&nbsp;1778 | &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0| avahi-daemon</font></div><div><font size="2"   >&nbsp;1372 | &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; 0| multipathd</font></div></div><p></p></pre></div><div><br></div><div>本文用到的probe alias原型 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/usr/share/systemtap/tapset/syscalls.stp</font></div><div><font size="2"   >/usr/share/systemtap/tapset/syscalls2.stp</font></div><div><div><font size="2"   ># epoll_wait _________________________________________________</font></div><div><font size="2"   >#</font></div><div><font size="2"   ># long sys_epoll_wait(int epfd, struct epoll_event __user *events,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int maxevents, int timeout)</font></div><div><font size="2"   ># long compat_sys_epoll_wait(int epfd,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct compat_epoll_event __user *events,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int maxevents, int timeout)</font></div><div><font size="2"   >#</font></div><div><font size="2"   >probe syscall.epoll_wait = kernel.function("compat_sys_epoll_wait").call ?,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;kernel.function("sys_epoll_wait").call ?</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "epoll_wait"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; epfd = $epfd</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; events_uaddr = $events</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; maxevents = $maxevents</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; timeout = $timeout</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%d, %p, %d, %d", $epfd, $events, $maxevents, $timeout)</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe syscall.epoll_wait.return = kernel.function("compat_sys_epoll_wait").return ?,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kernel.function("sys_epoll_wait").return ?</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "epoll_wait"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; retstr = return_str(1, $return)</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   ># futex ______________________________________________________</font></div><div><font size="2"   ># long sys_futex(u32 __user *uaddr,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int op,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int val,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct timespec __user *utime,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u32 __user *uaddr2,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int val3)</font></div><div><font size="2"   ># long compat_sys_futex(u32 __user *uaddr, int op, u32 val,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct compat_timespec __user *utime, u32 __user *uaddr2,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u32 val3)</font></div><div><font size="2"   >#</font></div><div><font size="2"   >probe syscall.futex = kernel.function("sys_futex").call ?</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "futex"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; futex_uaddr = $uaddr</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; op = $op</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; val = $val</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; utime_uaddr = $utime</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uaddr2_uaddr = $uaddr2</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; val3 = $val3</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if ($op == 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%p, %s, %d, %s", $uaddr, _futex_op_str($op),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $val, _struct_timespec_u($utime, 1))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%p, %s, %d", $uaddr, _futex_op_str($op),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $val)</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe syscall.futex.return = kernel.function("sys_futex").return ?</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "futex"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; retstr = return_str(1, $return)</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   ># exit _______________________________________________________</font></div><div><font size="2"   ># long sys_exit(int error_code)</font></div><div><font size="2"   >probe syscall.exit = kernel.function("do_exit").call</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "exit"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; status = $code</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprint($code)</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   ># poll _______________________________________________________</font></div><div><font size="2"   >#</font></div><div><font size="2"   ># long sys_poll(struct pollfd __user * ufds, unsigned int nfds, long timeout)</font></div><div><font size="2"   >#</font></div><div><font size="2"   >probe syscall.poll = kernel.function("sys_poll").call</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "poll"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ufds_uaddr = $ufds</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; nfds = $nfds</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; timeout = (@defined($timeout_msecs) ? $timeout_msecs : $timeout)  // 在sys_poll中timeout正表示milliseconds, 负表示无限</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%p, %d, %d", $ufds, $nfds,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (@defined($timeout_msecs) ? $timeout_msecs : $timeout))</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe syscall.poll.return = kernel.function("sys_poll").return</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "poll"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; retstr = return_str(1, $return)</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ># ppoll _______________________________________________________</font></div><div><font size="2"   >#</font></div><div><font size="2"   ># long sys_ppoll(struct pollfd __user *ufds, unsigned int nfds,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; struct timespec __user *tsp, const sigset_t __user *sigmask,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; size_t sigsetsize)</font></div><div><font size="2"   >#</font></div><div><font size="2"   >probe syscall.ppoll = kernel.function("sys_ppoll").call ?</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "ppoll"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%p, %d, %s, %p, %d",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ufds,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $nfds,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _struct_timespec_u($tsp, 1),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $sigmask,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $sigsetsize)</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe syscall.ppoll.return = kernel.function("sys_ppoll").return ?</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "ppoll"</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; retstr = return_str(1, $return)</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   ># select _____________________________________________________</font></div><div><font size="2"   ># long sys_select(int n,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd_set __user *inp,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd_set __user *outp,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd_set __user *exp,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct timeval __user *tvp)</font></div><div><font size="2"   >#</font></div><div><font size="2"   >probe syscall.select = kernel.function("sys_select").call</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "select"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; n = $n</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; readfds_uaddr = $inp</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; writefds_uaddr = $outp</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; exceptfds_uaddr = $exp</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; timeout_uaddr = $tvp</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%d, %p, %p, %p, %s", $n, $inp, $outp, $exp,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _struct_timeval_u($tvp, 1))</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe syscall.select.return = kernel.function("sys_select").return</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "select"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; retstr = return_str(1, $return)</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   ># rt_sigtimedwait ____________________________________________</font></div><div><font size="2"   >#</font></div><div><font size="2"   ># long sys_rt_sigtimedwait(const sigset_t __user *uthese,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;siginfo_t __user *uinfo,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const struct timespec __user *uts,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;size_t sigsetsize)</font></div><div><font size="2"   ># long compat_sys_rt_sigtimedwait (compat_sigset_t __user *uthese,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct compat_siginfo __user *uinfo,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct compat_timespec __user *uts, compat_size_t sigsetsize)</font></div><div><font size="2"   >#</font></div><div><font size="2"   >probe syscall.rt_sigtimedwait = kernel.function("compat_sys_rt_sigtimedwait").call ?,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kernel.function("sys_rt_sigtimedwait").call</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "rt_sigtimedwait"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uthese_uaddr = $uthese</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uinfo_uaddr = $uinfo</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uts_uaddr = $uts</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; sigsetsize = $sigsetsize</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%p, %p, %p, %d", $uthese, $uinfo, $uts, $sigsetsize)</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe syscall.rt_sigtimedwait.return = kernel.function("compat_sys_rt_sigtimedwait").return ?,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;kernel.function("sys_rt_sigtimedwait").return</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "rt_sigtimedwait"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; retstr = return_str(1, $return)</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   ># nanosleep __________________________________________________</font></div><div><font size="2"   >#</font></div><div><font size="2"   ># long sys_nanosleep(struct timespec __user *rqtp,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct timespec __user *rmtp)</font></div><div><font size="2"   ># long compat_sys_nanosleep(struct compat_timespec __user *rqtp,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct compat_timespec __user *rmtp)</font></div><div><font size="2"   >#</font></div><div><font size="2"   >probe syscall.nanosleep = kernel.function("sys_nanosleep").call</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "nanosleep"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; req_uaddr = $rqtp</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rem_uaddr = $rmtp</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%s, %p", _struct_timespec_u($rqtp, 1), $rmtp)</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe syscall.nanosleep.return = kernel.function("sys_nanosleep").return</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "nanosleep"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; retstr = return_str(1, $return)</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   ># ppoll _______________________________________________________</font></div><div><font size="2"   >#</font></div><div><font size="2"   ># long sys_ppoll(struct pollfd __user *ufds, unsigned int nfds,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; struct timespec __user *tsp, const sigset_t __user *sigmask,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; size_t sigsetsize)</font></div><div><font size="2"   >#</font></div><div><font size="2"   >probe syscall.ppoll = kernel.function("sys_ppoll").call ?</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "ppoll"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%p, %d, %s, %p, %d",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ufds,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $nfds,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _struct_timespec_u($tsp, 1),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $sigmask,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $sigsetsize)</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe syscall.ppoll.return = kernel.function("sys_ppoll").return ?</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "ppoll"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; retstr = return_str(1, $return)</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><font size="3"   >本文用到的内核函数以及上下文变量 :&nbsp;</font></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px; font-size: small;"   >[root@db-172-16-3-150 ~]# stap -L 'kernel.function("it_real_fn")'</span></div><div><div><font size="2"   >kernel.function("it_real_fn@kernel/itimer.c:121") $timer:struct hrtimer*</font></div></div><div><font size="2"   ><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_epoll_wait").call'</div><div>kernel.function("sys_epoll_wait@fs/eventpoll.c:1710").call $epfd:int $events:struct epoll_event* $maxevents:int $timeout:int</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_epoll_wait").return'</div><div>kernel.function("sys_epoll_wait@fs/eventpoll.c:1710").return $return:long int $epfd:int $events:struct epoll_event* $maxevents:int $timeout:int</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_futex").call'</div><div>kernel.function("sys_futex@kernel/futex.c:2692").call $uaddr:u32* $op:int $val:u32 $utime:struct timespec* $uaddr2:u32* $val3:u32 $ts:struct timespec $t:ktime_t</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_futex").return'</div><div>kernel.function("sys_futex@kernel/futex.c:2692").return $return:long int $uaddr:u32* $op:int $val:u32 $utime:struct timespec* $uaddr2:u32* $val3:u32 $ts:struct timespec $t:ktime_t</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("do_exit").call'</div><div>kernel.function("do_exit@kernel/exit.c:897").call $code:long int $tsk:struct task_struct*</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_poll").call'</div><div>kernel.function("sys_poll@fs/select.c:899").call $ufds:struct pollfd* $nfds:unsigned int $timeout_msecs:int $end_time:struct timespec</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_poll").return'</div><div>kernel.function("sys_poll@fs/select.c:899").return $return:long int $ufds:struct pollfd* $nfds:unsigned int $timeout_msecs:int $end_time:struct timespec</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_ppoll").call'</div><div>kernel.function("sys_ppoll@fs/select.c:935").call $ufds:struct pollfd* $nfds:unsigned int $tsp:struct timespec* $sigmask:sigset_t const* $sigsetsize:size_t $ksigmask:sigset_t $sigsaved:sigset_t $ts:struct timespec $end_time:struct timespec</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_ppoll").return'</div><div>kernel.function("sys_ppoll@fs/select.c:935").return $return:long int $ufds:struct pollfd* $nfds:unsigned int $tsp:struct timespec* $sigmask:sigset_t const* $sigsetsize:size_t $ksigmask:sigset_t $sigsaved:sigset_t $ts:struct timespec $end_time:struct timespec</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_select").call'</div><div>kernel.function("sys_select@fs/select.c:597").call $n:int $inp:fd_set* $outp:fd_set* $exp:fd_set* $tvp:struct timeval* $end_time:struct timespec $tv:struct timeval</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_select").return'</div><div>kernel.function("sys_select@fs/select.c:597").return $return:long int $n:int $inp:fd_set* $outp:fd_set* $exp:fd_set* $tvp:struct timeval* $end_time:struct timespec $tv:struct timeval</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_rt_sigtimedwait").return'</div><div>kernel.function("sys_rt_sigtimedwait@kernel/signal.c:2215").return $return:long int $uthese:sigset_t const* $uinfo:siginfo_t* $uts:struct timespec const* $sigsetsize:size_t $these:sigset_t $ts:struct timespec $info:siginfo_t</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_rt_sigtimedwait").call'</div><div>kernel.function("sys_rt_sigtimedwait@kernel/signal.c:2215").call $uthese:sigset_t const* $uinfo:siginfo_t* $uts:struct timespec const* $sigsetsize:size_t $these:sigset_t $ts:struct timespec $info:siginfo_t</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_nanosleep").call'</div><div>kernel.function("sys_nanosleep@kernel/hrtimer.c:1601").call $rqtp:struct timespec* $rmtp:struct timespec* $tu:struct timespec</div><div>[root@db-172-16-3-150 ~]# stap -L 'kernel.function("sys_nanosleep").return'</div><div>kernel.function("sys_nanosleep@kernel/hrtimer.c:1601").return $return:long int $rqtp:struct timespec* $rmtp:struct timespec* $tu:struct timespec</div></font></div><p></p></pre></div><div>系统调用源代码截取 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >syscall.poll</font></div><div><font size="2"   >/usr/src/debug/kernel-2.6.32-358.el6/linux-2.6.32-358.el6.x86_64/fs/select.c</font></div><div><div><font size="2"   >SYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, unsigned int, nfds,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int, timeout_msecs)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct timespec end_time, *to = NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int ret;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (timeout_msecs &gt;= 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to = &amp;end_time;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; poll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ret = do_sys_poll(ufds, nfds, to);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (ret == -EINTR) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct restart_block *restart_block;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart_block = &amp;current_thread_info()-&gt;restart_block;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart_block-&gt;fn = do_restart_poll;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart_block-&gt;poll.ufds = ufds;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart_block-&gt;poll.nfds = nfds;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (timeout_msecs &gt;= 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart_block-&gt;poll.tv_sec = end_time.tv_sec;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart_block-&gt;poll.tv_nsec = end_time.tv_nsec;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart_block-&gt;poll.has_timeout = 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart_block-&gt;poll.has_timeout = 0;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = -ERESTART_RESTARTBLOCK;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return ret;</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/usr/src/debug/kernel-2.6.32-358.el6/linux-2.6.32-358.el6.x86_64/kernel/itimer.c</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* The timer is automagically restarted, when interval != 0</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >enum hrtimer_restart it_real_fn(struct hrtimer *timer)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct signal_struct *sig =</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; container_of(timer, struct signal_struct, real_timer);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; trace_itimer_expire(ITIMER_REAL, sig-&gt;leader_pid, 0);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; kill_pid_info(SIGALRM, SEND_SIG_PRIV, sig-&gt;leader_pid);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return HRTIMER_NORESTART;</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide/mainsect-profiling.html"   >https://sourceware.org/systemtap/SystemTap_Beginners_Guide/mainsect-profiling.html</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://sourceware.org/systemtap/examples/"   >https://sourceware.org/systemtap/examples/</a></div><div>3. /usr/share/systemtap/testsuite/systemtap.examples</div><div>4. systemtap-testsuite</div><div>5. /usr/share/systemtap/testsuite/systemtap.examples/index.txt</div><div>6. /usr/share/systemtap/testsuite/systemtap.examples/keyword-index.txt</div><div>7. /usr/share/systemtap/tapset</div><div>8.&nbsp;</div><div>man syscalls</div><div>man poll</div><div>man ppoll</div><div>man select</div><div>man epoll_wait</div><div>man futex</div><div>man&nbsp;nanosleep</div><div>man&nbsp;rt_sigtimedwait</div><div>9.&nbsp;<a style="line-height: 28px;" rel="nofollow" href="https://sourceware.org/systemtap/tapsets/API-errno-str.html"   >https://sourceware.org/systemtap/tapsets/API-errno-str.html</a></div><div><br></div><wbr></div>
	</div>
</div>
</body>
</html>