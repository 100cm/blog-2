<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.4 add EXTENSION pg_prewarm like pgfincore</h2>
	<h5 id="">2013-12-23 13:37:02&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013112313221318/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 9.4 新增了一个扩展插件, pg_prewarm, 和pgfincore类似, 但是不完全类似.</div><div>因为pgfincore的目的是改变文件的posix属性, 从而改变数据在OS CACHE中的存活属性, 例如让数据在OS CACHE中呆就一点, 或者不呆在OS CACHE中.</div><div>而pg_prewarm做的是把数据读入OS CACHE或者数据库的shared buffer. 同时不会改变文件的posix属性.</div><div>所以pg_prewarm是拿来预热数据的, 而不是"持久化"到CACHE.</div><div>当内存不够的情况下, 已经在内存里面的数据会被排挤出去.</div><div><br></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create extension pg_prewarm;</font></div><div><font size="2"   >CREATE EXTENSION</font></div><p></p></pre></div><div>读入shared buffer.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# select * from pg_prewarm('t'::regclass,'buffer');</font></div><div><font size="2"   >&nbsp;pg_prewarm&nbsp;</font></div><div><font size="2"   >------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >调用ReadBufferExtended</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* ReadBufferExtended -- returns a buffer containing the requested</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;block of the requested relation. &nbsp;If the blknum</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;requested is P_NEW, extend the relation file and</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;allocate a new block. &nbsp;(Caller is responsible for</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ensuring that only one backend tries to extend a</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;relation at the same time!)</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Returns: the buffer number for the buffer containing</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the block read. &nbsp;The returned buffer has been pinned.</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Does not return on error --- elog's instead.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Assume when this function is called, that reln has been opened already.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* In RBM_NORMAL mode, the page is read from disk, and the page header is</font></div><div><font size="2"   >&nbsp;* validated. An error is thrown if the page header is not valid.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* RBM_ZERO_ON_ERROR is like the normal mode, but if the page header is not</font></div><div><font size="2"   >&nbsp;* valid, the page is zeroed instead of throwing an error. This is intended</font></div><div><font size="2"   >&nbsp;* for non-critical data, where the caller is prepared to repair errors.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* In RBM_ZERO mode, if the page isn't in buffer cache already, it's filled</font></div><div><font size="2"   >&nbsp;* with zeros instead of reading it from disk. &nbsp;Useful when the caller is</font></div><div><font size="2"   >&nbsp;* going to fill the page from scratch, since this saves I/O and avoids</font></div><div><font size="2"   >&nbsp;* unnecessary failure if the page-on-disk has corrupt page headers.</font></div><div><font size="2"   >&nbsp;* Caution: do not use this mode to read a page that is beyond the relation's</font></div><div><font size="2"   >&nbsp;* current physical EOF; that is likely to cause problems in md.c when</font></div><div><font size="2"   >&nbsp;* the page is modified and written out. P_NEW is OK, though.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* If strategy is not NULL, a nondefault buffer access strategy is used.</font></div><div><font size="2"   >&nbsp;* See buffer/README for details.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >Buffer</font></div><div><font size="2"   >ReadBufferExtended(Relation reln, ForkNumber forkNum, BlockNumber blockNum,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ReadBufferMode mode, BufferAccessStrategy strategy)</font></div></div><p></p></pre></div><div><br></div><div>异步读入os cache.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select * from pg_prewarm('t'::regclass,'prefetch');</font></div><div><font size="2"   >&nbsp;pg_prewarm&nbsp;</font></div><div><font size="2"   >------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >相当于调用PrefetchBuffer</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* PrefetchBuffer -- initiate asynchronous read of a block of a relation</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This is named by analogy to ReadBuffer but doesn't actually allocate a</font></div><div><font size="2"   >&nbsp;* buffer. &nbsp; &nbsp; &nbsp;Instead it tries to ensure that a future ReadBuffer for the given</font></div><div><font size="2"   >&nbsp;* block will not be delayed by the I/O. &nbsp;Prefetching is optional.</font></div><div><font size="2"   >&nbsp;* No-op if prefetching isn't compiled in.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >PrefetchBuffer(Relation reln, ForkNumber forkNum, BlockNumber blockNum)</font></div><div><font size="2"   >{</font></div></div><p></p></pre></div><div><br></div><div>同步读入os cache.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# select * from pg_prewarm('t'::regclass,'read');</font></div><div><font size="2"   >&nbsp;pg_prewarm&nbsp;</font></div><div><font size="2"   >------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >相当于调用smgrread</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;smgrread() -- read a particular block from a relation into the supplied</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;buffer.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This routine is called from the buffer manager in order to</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;instantiate pages in the shared buffer cache. &nbsp;All storage managers</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return pages in the format that POSTGRES expects.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >smgrread(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;char *buffer)</font></div></div><p></p></pre></div></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/pgprewarm.html"   >http://www.postgresql.org/docs/devel/static/pgprewarm.html</a></div><div>2.&nbsp;src/backend/storage/buffer/bufmgr.c</div><div>3.&nbsp;src/backend/storage/smgr/smgr.c</div></div>
	</div>
</div>
</body>
</html>