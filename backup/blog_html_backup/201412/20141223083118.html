<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL parallel mode and parallel contexts patch for parallel sequential scan or parallel sort and so on</h2>
	<h5 id="">2014-12-23 8:31:18&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402014112383118594/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div><span style="line-height: 28px;"   >Robert Haas 提交的&nbsp;</span>PostgreSQL 并行补丁, 基于此补丁, 未来可以支持顺序扫描, 排序等的并行处理.</div><div>有兴趣的朋友可以尝试一下这个补丁.</div><div><br></div><div>Attached is a patch that adds two new concepts: parallel mode, and</div><div>parallel contexts. &nbsp;The idea of this code is to provide a framework</div><div>for specific parallel things that you want to do, such as parallel</div><div>sequential scan or parallel sort. &nbsp;When you're in parallel mode,</div><div>certain operations - like DDL, and anything that would update the</div><div>command counter - are prohibited. &nbsp;But you gain the ability to create</div><div>a parallel context, which in turn can be used to fire up parallel</div><div>workers. &nbsp;And if you do that, then your snapshot, combo CID hash, and</div><div>GUC values will be copied to the worker, which is handy.</div><div><br></div><div>This patch is very much half-baked. &nbsp;Among the things that aren't right yet:</div><div><br></div><div>- There's no handling of heavyweight locking, so I'm quite sure it'll</div><div>be possible to cause undetected deadlocks if you work at it. &nbsp;There</div><div>are some existing threads on this topic and perhaps we can incorporate</div><div>one of those concepts into this patch, but this version does not.</div><div>- There's no provision for copying the parent's XID and sub-XIDs, if</div><div>any, to the background workers, which means that if you use this and</div><div>your transaction has written data, you will get wrong answers, because</div><div>TransactionIdIsCurrentTransactionId() will do the wrong thing.</div><div>- There's no really deep integration with the transaction system yet.</div><div>Previous discussions seem to point toward the need to do various types</div><div>of coordinated cleanup when the parallel phase is done, or when an</div><div>error happens. &nbsp;In particular, you probably don't want the abort</div><div>record to get written while there are still possibly backends that are</div><div>part of that transaction doing work; and you certainly don't want</div><div>files created by the current transaction to get removed while some</div><div>other backend is still writing them. &nbsp;The right way to work all of</div><div>this out needs some deep thought; agreeing on what the design should</div><div>be is probably harder than implement it.</div><div><br></div><div>Despite the above, I think this does a fairly good job laying out how</div><div>I believe parallelism can be made to work in PostgreSQL: copy a bunch</div><div>of state from the user backend to the parallel workers, compute for a</div><div>while, and then shut everything down. &nbsp;Meanwhile, while parallelism is</div><div>running, forbid changes to state that's already been synchronized, so</div><div>that things don't get out of step. &nbsp;I think the patch it shows how the</div><div>act of synchronizing state from the master to the workers can be made</div><div>quite modular and painless, even though it doesn't synchronize</div><div>everything relevant. &nbsp;I'd really appreciate any design thoughts anyone</div><div>may have on how to fix the problems mentioned above, how to fix any</div><div>other problems you foresee, or even just a list of reasons why you</div><div>think this will blow up.</div><div><br></div><div>What I think is that we're really pretty close to do real parallelism,</div><div>and that this is probably the last major piece of infrastructure that</div><div>we need in order to support parallel execution in a reasonable way.</div><div>That's a pretty bold statement, but I believe it to be true: despite</div><div>the limitations of the current version of this patch, I think we're</div><div>very close to being able to sit down and code up a parallel algorithm</div><div>in PostgreSQL and have that not be all that hard. &nbsp;Once we get the</div><div>first one, I expect a whole bunch more to come together far more</div><div>quickly than the first one did.</div><div><br></div><div>I would be remiss if I failed to mention that this patch includes work</div><div>by my colleagues Amit Kapila, Rushabh Lathia, and Jeevan Chalke, as</div><div>well as my former colleague Noah Misch; and that it would not have</div><div>been possible without the patient support of EnterpriseDB management.</div><div><br></div><div>Thanks,</div><div><br></div><div>--&nbsp;</div><div>Robert Haas</div><div>EnterpriseDB: http://www.enterprisedb.com</div><div>The Enterprise PostgreSQL Company</div></div><div><br></div><div>例子 :&nbsp;</div><div><div>Here is another new version, with lots of bugs fixed. &nbsp;The worker</div><div>shutdown sequence is now much more robust, although I think there may</div><div>still be a bug or two lurking, and I fixed a bunch of other things</div><div>too. &nbsp;There's now a function called parallel_count() in the</div><div>parallel_dummy extension contained herein, which does a parallel count</div><div>of a relation you choose:</div><div><br></div><div>rhaas=# select count(*) from pgbench_accounts;</div><div>&nbsp; count</div><div>---------</div><div>&nbsp;4000000</div><div>(1 row)</div><div><br></div><div>Time: 396.635 ms</div><div>rhaas=# select parallel_count('pgbench_accounts'::regclass, 0);</div><div>NOTICE: &nbsp;PID 2429 counted 4000000 tuples</div><div>&nbsp;parallel_count</div><div>----------------</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4000000</div><div>(1 row)</div><div><br></div><div>Time: 234.445 ms</div><div>rhaas=# select parallel_count('pgbench_accounts'::regclass, 4);</div><div>NOTICE: &nbsp;PID 2499 counted 583343 tuples</div><div>CONTEXT: &nbsp;parallel worker, pid 2499</div><div>NOTICE: &nbsp;PID 2500 counted 646478 tuples</div><div>CONTEXT: &nbsp;parallel worker, pid 2500</div><div>NOTICE: &nbsp;PID 2501 counted 599813 tuples</div><div>CONTEXT: &nbsp;parallel worker, pid 2501</div><div>NOTICE: &nbsp;PID 2502 counted 611389 tuples</div><div>CONTEXT: &nbsp;parallel worker, pid 2502</div><div>NOTICE: &nbsp;PID 2429 counted 1558977 tuples</div><div>&nbsp;parallel_count</div><div>----------------</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4000000</div><div>(1 row)</div><div><br></div><div>Time: 150.004 ms</div><div>rhaas=# select parallel_count('pgbench_accounts'::regclass, 8);</div><div>NOTICE: &nbsp;PID 2429 counted 1267566 tuples</div><div>NOTICE: &nbsp;PID 2504 counted 346236 tuples</div><div>CONTEXT: &nbsp;parallel worker, pid 2504</div><div>NOTICE: &nbsp;PID 2505 counted 345077 tuples</div><div>CONTEXT: &nbsp;parallel worker, pid 2505</div><div>NOTICE: &nbsp;PID 2506 counted 355325 tuples</div><div>CONTEXT: &nbsp;parallel worker, pid 2506</div><div>NOTICE: &nbsp;PID 2507 counted 350872 tuples</div><div>CONTEXT: &nbsp;parallel worker, pid 2507</div><div>NOTICE: &nbsp;PID 2508 counted 338855 tuples</div><div>CONTEXT: &nbsp;parallel worker, pid 2508</div><div>NOTICE: &nbsp;PID 2509 counted 336903 tuples</div><div>CONTEXT: &nbsp;parallel worker, pid 2509</div><div>NOTICE: &nbsp;PID 2511 counted 326716 tuples</div><div>CONTEXT: &nbsp;parallel worker, pid 2511</div><div>NOTICE: &nbsp;PID 2510 counted 332450 tuples</div><div>CONTEXT: &nbsp;parallel worker, pid 2510</div><div>&nbsp;parallel_count</div><div>----------------</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 4000000</div><div>(1 row)</div><div><br></div><div>Time: 166.347 ms</div><div><br></div><div>This example table (pgbench_accounts, scale 40, ~537 MB) is small</div><div>enough that parallelism doesn't really make sense; you can see from</div><div>the notice messages above that the master manages to count a quarter</div><div>of the table before the workers get themselves up and running. &nbsp;The</div><div>pointer is rather to show how the infrastructure works and that it can</div><div>be used to write code to do practically useful tasks in a surprisingly</div><div>small number of lines of code; parallel_count is only maybe ~100 lines</div><div>on top of the base patch.</div><div><br></div><div>--&nbsp;</div><div>Robert Haas</div><div>EnterpriseDB: http://www.enterprisedb.com</div><div>The Enterprise PostgreSQL Company</div></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/message-id/flat/CA+Tgmob8u=J-D-_5SCXOQ9-ZtK_xCHjwa3M29CxBhU3VPPnezw@mail.gmail.com#CA+Tgmob8u=J-D-_5SCXOQ9-ZtK_xCHjwa3M29CxBhU3VPPnezw@mail.gmail.com"   >http://www.postgresql.org/message-id/flat/CA+Tgmob8u=J-D-_5SCXOQ9-ZtK_xCHjwa3M29CxBhU3VPPnezw@mail.gmail.com#CA+Tgmob8u=J-D-_5SCXOQ9-ZtK_xCHjwa3M29CxBhU3VPPnezw@mail.gmail.com</a></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL parallel mode and parallel contexts patch for parallel sequential scan or parallel sort and so on - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>