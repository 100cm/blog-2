<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">pipework let's assign static IP to docker container simple.</h2>
	<h5 id="">2014-12-06 14:22:47&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201411602632460/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>pipework是Docker工程师写的一个脚本, 主要用来管理container的网络.&nbsp;</div><div>用法参考</div><div><a target="_blank" rel="nofollow" href="https://github.com/jpetazzo/pipework/blob/master/pipework"   >https://github.com/jpetazzo/pipework/blob/master/pipework</a></div><div><br></div><div>网友总结的5种定制docker网络的途径, pipework是其中之一 :&nbsp;</div><div><a target="_blank" rel="nofollow" href="http://www.infoworld.com/article/2835222/application-virtualization/5-ways-docker-is-fixing-its-networking-woes.html"   >http://www.infoworld.com/article/2835222/application-virtualization/5-ways-docker-is-fixing-its-networking-woes.html</a></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Docker's recent advances have made it the darling of startups and innovators throughout the IT world, but one pain point causes admins and developers alike to bite their nails: networking. Managing the interaction between Docker containers and networks has always been fraught with complications.</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >To some intrepid developers, that's a challenge and not an obstacle. Here are five of the most significant projects currently in the works to solve Docker networking issues, with the possibility that one or more of them might become part of Docker itself.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Weave</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Created by Zett.io, Weave "makes the network fit the application, not the other way round," as the company CEO puts it. With Weave, Docker containers are all part of a virtual network switch no matter where they're running. Services can be selectively exposed across the network to the outside world through firewalls and using encryption for wide-area connections.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The gist: Possibly the best place to start, since it solves most of the really immediate problems in a straightforward way. But other solutions might offer more depending on your ambitions.</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >Kubernetes</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Google's big first leap into the Docker world was an orchestration project, a way to tackle node balancing and many other valuable orchestration-related functions with Docker containers. It also provides, rather deliberately, some solutions to Docker's networking issues, though it goes only so far in that realm.</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >The gist: A good start as-is, but heavy lifting is still required to get the most out of it.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CoreOS, Flannel</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Given that CoreOS is a project meant to architect an entire Linux distribution around Docker, it makes sense for networking to be part of the package. A project named Flannel (previously Rudder) is at the heart of how CoreOS manages container networking, connecting all the containers in a cluster via their own private mesh network. Presto, no more clumsy port mapping!</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >The gist: Best with CoreOS; requires Kubernetes at least.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Pipework</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >A solution devised by one of Docker's engineers, Pipework allows containers to be connected "in arbitrarily complex scenarios." It was devised as an interim solution and will probably end up as one.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The gist: It's best as a curiosity or a technology concept in the long run; as its creator admits, "Docker will [eventually] allow complex scenarios, and Pipework should become obsolete."</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SocketPlane</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Right now SocketPlane's work consists of little more than a press announcement "to bring software defined networking to Docker." The idea is to use the same devops tools used to deploy Docker to manage virtualized networks for containers, and build what amounts to an OpenDaylight/Open vSwitch fabric for Docker. It all sounds promising, but we won't be able to see any product until at least the first quarter of 2015.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The gist: Don't hold your breath until it's out.</font></div></div><p></p></pre></div><div><br></div></div><div>下载pipework脚本 :&nbsp;</div><div><a target="_blank" rel="nofollow" href="https://github.com/jpetazzo/pipework"   >https://github.com/jpetazzo/pipework</a></div><div><br></div><div>vi pipework.sh</div><div><a target="_blank" rel="nofollow" href="https://raw.githubusercontent.com/jpetazzo/pipework/master/pipework"   >https://raw.githubusercontent.com/jpetazzo/pipework/master/pipework</a>&nbsp;内容写入</div><div><div>[root@db-172-16-3-221 ~]# chmod 500 pipework.sh&nbsp;</div><div>[root@db-172-16-3-221 ~]# ./pipework.sh&nbsp;</div><div>Syntax:</div><div>pipework &lt;hostinterface&gt; [-i containerinterface] &lt;guest&gt; &lt;ipaddr&gt;/&lt;subnet&gt;[@default_gateway] [macaddr][@vlan]</div><div>pipework &lt;hostinterface&gt; [-i containerinterface] &lt;guest&gt; dhcp [macaddr][@vlan]</div><div>pipework --wait [-i containerinterface]</div></div><div><br></div><div>pipework目前加入了openvswitch的支持. 所以如果你要直接使用openvswitch+docker的话, 用pipework来配置网络会很方便.</div><div>以前我们要使用netns来配置, 步骤很繁琐.</div><div><br></div><div>注意, pipework通过link名字来判断是bridge还是ovs switch.</div><div>br开头为网桥, ovs开头为openvswitch.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; case "$IFNAME" in</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; br*)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IFTYPE=bridge</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BRTYPE=linux</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ovs*)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ! $(which ovs-vsctl &gt;/dev/null)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo "Need OVS installed on the system to create an ovs bridge"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit 1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IFTYPE=bridge</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BRTYPE=openvswitch</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; *)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo "I do not know how to setup interface $IFNAME."</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit 1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; esac</font></div><p></p></pre></div><div>pipework会自动创建peer, 配置netns, 判断IP是否重复, 配置路由, 等, 配置好后最后还会删除netns, 所以我们用netns看不到.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># Give our ARP neighbors a nudge about the new interface</font></div><div><font size="2"   >if which arping &gt; /dev/null 2&gt;&amp;1</font></div><div><font size="2"   >then</font></div><div><font size="2"   >&nbsp; &nbsp; IPADDR=$(echo $IPADDR | cut -d/ -f1)</font></div><div><font size="2"   >&nbsp; &nbsp; ip netns exec $NSPID arping -c 1 -A -I $CONTAINER_IFNAME $IPADDR &gt; /dev/null 2&gt;&amp;1 || true</font></div><div><font size="2"   >else</font></div><div><font size="2"   >&nbsp; &nbsp; echo "Warning: arping not found; interface may not be immediately reachable"</font></div><div><font size="2"   >fi</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ># Remove NSPID to avoid `ip netns` catch it.</font></div><div><font size="2"   >[ -f /var/run/netns/$NSPID ] &amp;&amp; rm -f /var/run/netns/$NSPID</font></div><div><font size="2"   >exit 0</font></div><p></p></pre></div><div><br></div><div>测试如下 :&nbsp;</div><div>创建虚拟交换机</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@localhost ~]# ovs-vsctl add-br ovs0</font></div><div><font size="2"   >[root@localhost ~]# ip link set ovs0 up</font></div></div><div><font size="2"   >[root@localhost ~]# ip addr add 172.0.42.1/24 dev ovs0</font></div><div><div><font size="2"   >[root@localhost ~]# ovs-vsctl show</font></div><div><font size="2"   >f345b7e3-fcb0-4ef3-8295-36d3ef69ceef</font></div><div><font size="2"   >&nbsp; &nbsp; Bridge "ovs0"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Port "ovs0"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Interface "ovs0"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type: internal</font></div><div><font size="2"   >&nbsp; &nbsp; ovs_version: "2.3.0"</font></div></div><p></p></pre></div><div><br></div><div>创建容器, 不指定网络.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@localhost ~]# docker run --rm -t -i --net=none --name=testpipework centos:centos7 /bin/bash</font></div><div><font size="2"   >[root@7eb07fe4bbf8 /]# ip link</font></div><div><font size="2"   >1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</font></div><p></p></pre></div><div>使用pipework配置容器IP, 将手工完成的netns配置自动化完成了.</div><div><pre class="prettyprint"   ><p><font size="2"   >[root@localhost ~]# ./pipework.sh ovs0 testpipework 172.0.42.2/24</font></p></pre></div><div>可以在容器中看到新增的接口</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@7eb07fe4bbf8 /]# ip link</font></div><div><font size="2"   >1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</font></div><div><font size="2"   >56: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000</font></div><div><font size="2"   >&nbsp; &nbsp; link/ether 3e:15:74:c0:64:21 brd ff:ff:ff:ff:ff:ff</font></div></div><div><div><font size="2"   >网络已正常</font></div><div><font size="2"   >[root@7eb07fe4bbf8 /]# ping 172.0.42.1</font></div><div><font size="2"   >PING 172.0.42.1 (172.0.42.1) 56(84) bytes of data.</font></div><div><font size="2"   >64 bytes from 172.0.42.1: icmp_seq=1 ttl=64 time=0.369 ms</font></div><div><font size="2"   >64 bytes from 172.0.42.1: icmp_seq=2 ttl=64 time=0.055 ms</font></div><div><font size="2"   >^C</font></div><div><font size="2"   >--- 172.0.42.1 ping statistics ---</font></div><div><font size="2"   >2 packets transmitted, 2 received, 0% packet loss, time 1000ms</font></div><div><font size="2"   >rtt min/avg/max/mdev = 0.055/0.212/0.369/0.157 ms</font></div><div><font size="2"   >路由也加了</font></div><div><font size="2"   >[root@7eb07fe4bbf8 /]# ip route</font></div><div><font size="2"   >172.0.42.0/24 dev eth1 &nbsp;proto kernel &nbsp;scope link &nbsp;src 172.0.42.2</font></div></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020149115414214"   >http://blog.163.com/digoal@126/blog/static/16387704020149115414214</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://linuxcontainers.org/"   >https://linuxcontainers.org/</a></div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://goldmann.pl/blog/2014/01/30/assigning-ip-addresses-to-docker-containers-via-dhcp/"   >https://goldmann.pl/blog/2014/01/30/assigning-ip-addresses-to-docker-containers-via-dhcp/</a></div><div>4 .<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://blog.codeaholics.org/2013/giving-dockerlxc-containers-a-routable-ip-address/"   >http://blog.codeaholics.org/2013/giving-dockerlxc-containers-a-routable-ip-address/</a></div><div>5 .<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.infoworld.com/article/2835222/application-virtualization/5-ways-docker-is-fixing-its-networking-woes.html"   >http://www.infoworld.com/article/2835222/application-virtualization/5-ways-docker-is-fixing-its-networking-woes.html</a></div><div>6.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://github.com/jpetazzo/pipework"   >https://github.com/jpetazzo/pipework</a></div><div>7. pipework shell脚本</div><div>https://github.com/jpetazzo/pipework/blob/master/pipework</div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="pipework lets assign static IP to docker container simple. - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">hochikong - 2015-02-01 15:06:31</h5>
				<div>请教一下，我在操作时，显示Warning: arping not found; interface may not be immediately reachable。有什么影响吗</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 hochikong - 2015-02-01 15:06:31</h5>
				<div style="width:600px;">HI, arping不存在, 你装一下这个软件. iputils包</div>
			</div>
	</div>
</div>
</body>
</html>