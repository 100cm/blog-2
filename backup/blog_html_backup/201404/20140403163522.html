<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL function's volatile & relation_excluded_by_constraints@src/backend/optimizer/util/plancat.c</h2>
	<h5 id="">2014-04-03 16:35:22&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020143341744827/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>今天一位网友提到一个关于约束和查询优化的问题, 为什么使用函数时某些子表不会被过滤呢?</div><div>我们看一个例子 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create table test(id int, info text, crt_date date);</font></div><div><font size="2"   >CREATE TABLE</font></div></div><div><div><font size="2"   >digoal=# create table test1(like test including all) inherits (test);</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "id" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "info" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "crt_date" with inherited definition</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# create table test2(like test including all) inherits (test);</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "id" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "info" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "crt_date" with inherited definition</font></div><div><font size="2"   >CREATE TABLE</font></div></div><p></p></pre></div><div>给两个分表创建约束</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# alter table test1 add constraint ck check(crt_date&gt;'2013-01-01');</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=# alter table test2 add constraint ck check(crt_date&gt;'2015-01-01');</font></div><div><font size="2"   >ALTER TABLE</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >constraint_exclusion</span><span style="line-height: 28px;"   >&nbsp;</span>参数为partition. 允许检查约束.</div><pre class="prettyprint"   ><p></p><div><font size="2"   >constraint_exclusion = partition</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >使用current_date时, 显然没有过滤掉test2表的查询.</span></div><div>原因是current_date被转换成了<span style="line-height: 28px;"   >('now'::cstring)::date), 这里的::是类型转换, 用到cstring_in, date_in函数.</span></div><div>而这date_in函数是stable的, 只有cstring是immutable的.</div><div>在<span style="line-height: 28px;"   >relation_excluded_by_constraints@/opt/soft_bak/postgresql-9.3.3/src/backend/optimizer/util/plancat.c代码中, 已经说明只检查immutable函数.&nbsp;</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check for self-contradictory restriction clauses. &nbsp;We dare not make</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* deductions with non-immutable functions, but any immutable clauses that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* are self-contradictory allow us to conclude the scan is unnecessary.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: strip off RestrictInfo because predicate_refuted_by() isn't</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* expecting to see any in its predicate argument.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><p></p></pre></div></div><div><br></div><div><span style="line-height: 28px;"   >在这个查询中, 除了current_date这个函数, 还有一个函数&lt;号, 操作符对应的是函数, 是一个immutable函数.</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# select oprcode from pg_operator where oprname='&lt;' and oprleft=(select oid from pg_type where typname='date') and oprright=(select oid from pg_type where typname='date');</font></div><div><font size="2"   >&nbsp;oprcode&nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;date_lt</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >postgres=# select provolatile from pg_proc where proname='date_lt';</font></div><div><font size="2"   >&nbsp;provolatile&nbsp;</font></div><div><font size="2"   >-------------</font></div><div><font size="2"   >&nbsp;i</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   ><br></span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 28px;"   ><font size="2"   >digoal=# explain select * from test where crt_date&lt;current_date;</font></span></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Append &nbsp;(cost=0.00..183.45 rows=3115 width=40)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..0.00 rows=1 width=40)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_date &lt; ('now'::cstring)::date)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test1 &nbsp;(cost=0.00..91.73 rows=1557 width=40)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_date &lt; ('now'::cstring)::date)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test2 &nbsp;(cost=0.00..91.73 rows=1557 width=40)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_date &lt; ('now'::cstring)::date)</font></div><div><font size="2"   >(7 rows)</font></div></div><p></p></pre></div><div>这里的话, 因为直接给出的是常量, test2当然可以被过滤.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain select * from test where crt_date&lt;'2014-04-01';</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Append &nbsp;(cost=0.00..68.38 rows=1558 width=40)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..0.00 rows=1 width=40)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_date &lt; '2014-04-01'::date)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test1 &nbsp;(cost=0.00..68.38 rows=1557 width=40)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_date &lt; '2014-04-01'::date)</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div>涉及的几个函数的稳定性如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><div><font size="2"   >digoal=# select proname,provolatile from pg_proc where proname ~ '^date' and provolatile='i';</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;proname &nbsp; &nbsp; &nbsp; | provolatile&nbsp;</font></div><div><font size="2"   >---------------------+-------------</font></div><div><font size="2"   >&nbsp;date_eq &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | i</font></div><div><font size="2"   >&nbsp;date_le &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | i</font></div><div><font size="2"   >&nbsp;date_ge &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | i</font></div><div><font size="2"   >&nbsp;date_ne &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | i</font></div></div></div><div><div><font size="2"   >digoal=# \df+ *.*cstring*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List of functions</font></div><div><font size="2"   >&nbsp; &nbsp;Schema &nbsp; | &nbsp; &nbsp; Name &nbsp; &nbsp; | Result data type | Argument data types | &nbsp;Type &nbsp;| Security | Volatility | &nbsp;Owner &nbsp; | Language | Source&nbsp;</font></div><div><font size="2"   >code &nbsp;| Description&nbsp;</font></div><div><font size="2"   >------------+--------------+------------------+---------------------+--------+----------+------------+----------+----------+--------</font></div><div><font size="2"   >------+-------------</font></div><div><font size="2"   >&nbsp;pg_catalog | cstring_in &nbsp; | cstring &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| cstring &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | normal | invoker &nbsp;| immutable &nbsp;| postgres | internal | cstring</font></div><div><font size="2"   >_in &nbsp; | I/O</font></div><div><font size="2"   >&nbsp;pg_catalog | cstring_out &nbsp;| cstring &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| cstring &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | normal | invoker &nbsp;| immutable &nbsp;| postgres | internal | cstring</font></div><div><font size="2"   >_out &nbsp;| I/O</font></div></div><div><div><font size="2"   >digoal=# \df+ date_in</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of functions</font></div><div><font size="2"   >&nbsp; &nbsp;Schema &nbsp; | &nbsp;Name &nbsp; | Result data type | Argument data types | &nbsp;Type &nbsp;| Security | Volatility | &nbsp;Owner &nbsp; | Language | Source code&nbsp;</font></div><div><font size="2"   >| Description&nbsp;</font></div><div><font size="2"   >------------+---------+------------------+---------------------+--------+----------+------------+----------+----------+-------------</font></div><div><font size="2"   >+-------------</font></div><div><font size="2"   >&nbsp;pg_catalog | date_in | date &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | cstring &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | normal | invoker &nbsp;| stable &nbsp; &nbsp; | postgres | internal | date_in &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >| I/O</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div>如果我们手工修改函数的稳定性, 将改变执行计划, 例如把date_in改成immutable的.</div><div>(生产系统不建议这么改, 这里只为了说明问题, 生产系统的话你可以自定义一个immutable函数来返回current_date的值)</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# alter function date_in(cstring) immutable;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><p></p></pre></div><div>这个时候, immtable函数将在optimize阶段就替换成常量, 因此被<span style="line-height: 28px;"   >relation_excluded_by_constraints函数检测到. 过滤了test2表.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain select * from test where crt_date&lt; current_date;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Append &nbsp;(cost=0.00..68.38 rows=1558 width=40)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..0.00 rows=1 width=40)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_date &lt; '2014-04-03'::date)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test1 &nbsp;(cost=0.00..68.38 rows=1557 width=40)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_date &lt; '2014-04-03'::date)</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div></div><div>因此, 如果把&lt;号对应的函数变成stable, 那么test2无法被过滤了.</div><div><br></div><div>最近会针对数据库优化做一期培训视频, 届时请关注我的BLOG主页.</div><div>函数三态的总结 :&nbsp;</div><div><div>VOLATILE</div><div>volatile函数没有限制, 可以修改数据(如执行delete, insert , update).</div><div>使用同样的参数调用可能返回不同的值.</div><div>volatile函数不能被优化器选择作为优化条件.(例如减少调用, 函数索引, 索引过滤条件中都无法使用volatile函数)</div><div>在同一个查询中, 同样参数的情况下可能被多次执行(QUERY有多行返回/扫描的情况下).</div><div>snapshot为函数内的每个query开始时的snapshot. 因此对在函数执行过程中, 外部已提交的数据可见.</div><div><br></div><div>STABLE</div><div>stable和immutable函数, 函数内不允许修改数据.(如PGver&gt;=8.0 函数内不可执行非SELECT|PERFORM语句.)</div><div>使用同样的参数调用返回同样的结果, 在事务中有这个特性的也归属stable.</div><div>优化器可根据实际场景优化stable函数的调用次数, 同样的参数多次调用可减少成单次调用.</div><div>stable和immutable函数可用于优化器选择合适的索引扫描, 因为索引扫描仅评估被比较的表达式一次, 后多次与索引值进行比较.</div><div>stable和volatile函数都不能用于创建函数索引, 只有immutable函数可以用于创建函数索引.</div><div>stable和immutable函数, snapshot为外部调用函数的QUERY的snapshot, 函数内部始终保持这个snapshot, 外部会话带来的的数据变更不被反映到函数执行过程中.</div><div><br></div><div><div>IMMUTABLE</div><div>不允许修改数据, 使用同样的参数调用返回同样的结果. &nbsp;</div><div>优化器在处理immutable函数时, 先评估函数结果, 将结果替换为常量.</div><div><br></div><div>STABLE和IMMUTABLE的区别</div><div>优化器对stable和immutable区别对待, where子句中一样, 但是在select子句中stable函数不被优化.</div><div>在prepared statement中的使用区别:</div><div>immutable函数在plan时以常量替代, stable函数在execute阶段被执行.</div><div>因此immutable函数参数为常量时, 在prepared statement场景只执行一次, 而stable函数被多次执行.</div><div><br></div><div>函数稳定性通过查看pg_proc.provolatile得到</div><div><br></div></div></div>[参考]<wbr><div>1.&nbsp;relation_excluded_by_constraints@/opt/soft_bak/postgresql-9.3.3/src/backend/optimizer/util/plancat.c</div><div>2. 使用stap或gdb跟踪<span style="line-height: 28px;"   >relation_excluded_by_constraints</span></div><div><span style="line-height: 28px;"   ><div><pre class="prettyprint"   ><p></p><div><font size="2"   >stap -e 'probe process("/home/pg93/pgsql9.3.3/bin/postgres").function("relation_excluded_by_constraints@/opt/soft_bak/postgresql-9.3.3/src/backend/optimizer/util/plancat.c") {</font></div><div><font size="2"   >printf ("%s, %s\n", pp(), $$vars$$)</font></div><div><font size="2"   >}'</font></div><p></p></pre></div><div><br></div></span></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL functions volatile  relation_excluded_by_constraints@/opt/soft_bak/postgresql-9.3.3/src/backend/optimizer/util/plancat.c - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">一生有你 - 2014-05-26 19:50:40</h5>
				<div>也可以不改 date_in 属性，自己定义一个 immutable 函数，返回current_date，也能达到剪枝的目的<div><div>postgres=&gt; create function curdate() returns date as</div><div>postgres-&gt; $$</div><div>postgres$&gt; begin</div><div>postgres$&gt; return current_date;</div><div>postgres$&gt; end;</div><div>postgres$&gt; $$ language plpgsql immutable;</div><div>CREATE FUNCTION</div><div>postgres=&gt; &nbsp;explain select * from test where crt_date&lt; curdate();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN</div><div>---------------------------------------------------------------</div><div>&nbsp;Append &nbsp;(cost=0.00..24.50 rows=388 width=40)</div><div>&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test &nbsp;(cost=0.00..0.00 rows=1 width=40)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_date &lt; '2014-05-26'::date)</div><div>&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test1 &nbsp;(cost=0.00..24.50 rows=387 width=40)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_date &lt; '2014-05-26'::date)</div></div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 一生有你 - 2014-05-26 19:50:40</h5>
				<div style="width:600px;">是的都行.</div>
			</div>
	</div>
</div>
</body>
</html>