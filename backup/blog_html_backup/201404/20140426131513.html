<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL index scan enlarge heap page scans when index and column correlation small.</h2>
	<h5 id="">2014-04-26 13:15:13&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020143260315126/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><span style="line-height: 28px;"   >今天在讲解PostgreSQL 性能优化的 成本因子校准时发现一个奇异的问题, 索引扫描带来了巨大的heap page scan数目.</span></div><div>视频如下 :&nbsp;</div><div><a target="_blank" rel="nofollow" href="http://www.tudou.com/programs/view/yQ0SzBqx_4w/"   >http://www.tudou.com/programs/view/yQ0SzBqx_4w/</a></div><div>如果数据库的单个数据块很大的话, 这种情况带来的负面影响也将被放大. 例如32k的block_size显然比8k的block_size扫描开销更大.</div><div><br></div><div>本文将讲解一下索引扫描引发的heap page scan放大的原因, 以及告诫大家注意这样的事情发生.</div><div>测试环境的成本因子如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >shared_buffers = 8192MB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # min 128kB</font></div><div><div><font size="2"   >#seq_page_cost = 1.0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# measured on an arbitrary scale</font></div><div><font size="2"   >random_page_cost = 1.0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# same scale as above</font></div><div><font size="2"   >#cpu_tuple_cost = 0.01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# same scale as above</font></div><div><font size="2"   >cpu_index_tuple_cost = 0.005 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# same scale as above</font></div><div><font size="2"   >#cpu_operator_cost = 0.0025 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # same scale as above</font></div><div><font size="2"   >effective_cache_size = 96GB</font></div></div><p></p></pre></div><div><br></div><div>我们先创建一个测试表, 插入一些测试数据, 创建一个索引 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table test_indexscan(id int, info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=&gt; insert into test_indexscan select generate_series(1,5000000),md5(random()::text);</font></div><div><font size="2"   >INSERT 0 5000000</font></div><div><font size="2"   >digoal=&gt; create index idx_test_indexscan_id on test_indexscan (id);</font></div><div><font size="2"   >CREATE INDEX</font></div><p></p></pre></div><div><div>我们查看这个表和索引占用了多少数据块.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select relpages from pg_class where relname='test_indexscan';</font></div><div><font size="2"   >&nbsp;relpages&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp; 10396</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=&gt; select relpages from pg_class where relname='idx_test_indexscan_id';</font></div><div><font size="2"   >&nbsp;relpages&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;3402</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div>接下来分析以下查询, 我们看到走索引扫描, 并且扫描的数据块是13547个. (10209 +3338).</div><div>扫描的数据块和实际表占用的数据块和索引块相当.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; explain (analyze,verbose,costs,buffers,timing) select * from test_indexscan where id&gt;90000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >-----------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_test_indexscan_id on digoal.test_indexscan &nbsp;(cost=0.43..99518.57 rows=4912065 width=37) (actual time=0.180..21</font></div><div><font size="2"   >72.949 rows=4910000 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (test_indexscan.id &gt; 90000)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=10209 read=3338</font></div><div><font size="2"   >&nbsp;Total runtime: 2674.637 ms</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div>这里使用索引扫描为什么没有带来heap page扫描的放大呢? 原因和值的顺序与物理存储顺序一致.</div><div>如下, 那么索引扫描的时候没有发生块的跳跃 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; select correlation from pg_stats where tablename='test_indexscan' and attname='id';</font></div><div><font size="2"   >&nbsp;correlation&nbsp;</font></div><div><font size="2"   >-------------</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=&gt; select ctid,id from test_indexscan limit 10;</font></div><div><font size="2"   >&nbsp; ctid &nbsp;| &nbsp; id &nbsp; &nbsp;</font></div><div><font size="2"   >--------+---------</font></div><div><font size="2"   >&nbsp;(0,1) &nbsp;| 1</font></div><div><font size="2"   >&nbsp;(0,2) &nbsp;| 2</font></div><div><font size="2"   >&nbsp;(0,3) &nbsp;| 3</font></div><div><font size="2"   >&nbsp;(0,4) &nbsp;| 4</font></div><div><font size="2"   >&nbsp;(0,5) &nbsp;| 5</font></div><div><font size="2"   >&nbsp;(0,6) &nbsp;| 6</font></div><div><font size="2"   >&nbsp;(0,7) &nbsp;| 7</font></div><div><font size="2"   >&nbsp;(0,8) &nbsp;| 8</font></div><div><font size="2"   >&nbsp;(0,9) &nbsp;| 9</font></div><div><font size="2"   >&nbsp;(0,10) | 10</font></div><div><font size="2"   >(10 rows)</font></div></div><p></p></pre></div><div><br></div><div>接下来我们插入随机数据, 使得索引扫描时发生heap page的跳跃.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; truncate test_indexscan ;</font></div><div><font size="2"   >TRUNCATE TABLE</font></div><div><font size="2"   >digoal=&gt; insert into test_indexscan select (random()*5000000)::int,md5(random()::text) from generate_series(1,100000);</font></div><div><font size="2"   >INSERT 0 100000</font></div><p></p></pre></div><div>查询当前的ID列的顺性, 非常小, 说明这个值非常的离散.</div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select correlation from pg_stats where tablename='test_indexscan' and attname='id';</font></div><div><font size="2"   >&nbsp;correlation&nbsp;</font></div><div><font size="2"   >-------------</font></div><div><font size="2"   >&nbsp; 0.00986802</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>从数据分布结果中也能看到这点.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select ctid,id from test_indexscan limit 10;</font></div><div><font size="2"   >&nbsp; ctid &nbsp;| &nbsp; id &nbsp; &nbsp;</font></div><div><font size="2"   >--------+---------</font></div><div><font size="2"   >&nbsp;(0,1) &nbsp;| 4217216</font></div><div><font size="2"   >&nbsp;(0,2) &nbsp;| 2127868</font></div><div><font size="2"   >&nbsp;(0,3) &nbsp;| 2072952</font></div><div><font size="2"   >&nbsp;(0,4) &nbsp;| &nbsp; 62641</font></div><div><font size="2"   >&nbsp;(0,5) &nbsp;| 4927312</font></div><div><font size="2"   >&nbsp;(0,6) &nbsp;| 3000894</font></div><div><font size="2"   >&nbsp;(0,7) &nbsp;| 2799439</font></div><div><font size="2"   >&nbsp;(0,8) &nbsp;| 4165217</font></div><div><font size="2"   >&nbsp;(0,9) &nbsp;| 2446438</font></div><div><font size="2"   >&nbsp;(0,10) | 2835211</font></div><div><font size="2"   >(10 rows)</font></div><p></p></pre></div><div>按以下顺序扫描, 显然会出现大量的数据块的跳跃.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select id,ctid from test_indexscan order by id limit 10;</font></div><div><font size="2"   >&nbsp;id &nbsp;| &nbsp; ctid &nbsp; &nbsp;</font></div><div><font size="2"   >-----+-----------</font></div><div><font size="2"   >&nbsp; 56 | (192,318)</font></div><div><font size="2"   >&nbsp; 73 | (119,163)</font></div><div><font size="2"   >&nbsp;218 | (189,2)</font></div><div><font size="2"   >&nbsp;235 | (7,209)</font></div><div><font size="2"   >&nbsp;260 | (41,427)</font></div><div><font size="2"   >&nbsp;340 | (37,371)</font></div><div><font size="2"   >&nbsp;548 | (118,363)</font></div><div><font size="2"   >&nbsp;607 | (143,174)</font></div><div><font size="2"   >&nbsp;690 | (161,38)</font></div><div><font size="2"   >&nbsp;714 | (1,21)</font></div><div><font size="2"   >(10 rows)</font></div><p></p></pre></div><div><div>当前这个表和索引占用的数据块如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select relpages from pg_class where relname='test_indexscan';</font></div><div><font size="2"   >&nbsp;relpages&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 208</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=&gt; select relpages from pg_class where relname='idx_test_indexscan_id';</font></div><div><font size="2"   >&nbsp;relpages&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;86</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div>接下来我们执行这个SQL, 发现走索引扫描了, 但是显然shared hit变得非常的大, 原因就是每扫描一个索引条目, 对应到heap page number都是跳跃的. 造成了heap page扫描的放大. 具体放大多少行呢, 和差出来的行差不多.</div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >digoal=&gt; explain (analyze,verbose,costs,buffers,timing) select * from test_indexscan where id&gt;90000;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;Index Scan using idx_test_indexscan_id on digoal.test_indexscan &nbsp;(cost=0.29..2035.38 rows=99719 width=37) (actual time=0.027..87.45</font></div><div style="line-height: 28px;"   ><font size="2"   >6 rows=98229 loops=1)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp;Output: id, info</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp;Index Cond: (test_indexscan.id &gt; 90000)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=97837</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;Total runtime: 97.370 ms</font></div><div style="line-height: 28px;"   ><font size="2"   >(5 rows)</font></div><p></p></pre></div></div><div style="line-height: 28px;"   >heap page scan放大评估和索引扫描了多少条目有关, 但至少有98229个条目 :&nbsp;</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >digoal=&gt; select count(*) from test_indexscan where id&gt;90000;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;count&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >-------</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;98229</font></div><div style="line-height: 28px;"   ><font size="2"   >(1 row)</font></div><p></p></pre></div><div style="line-height: 28px;"   >如果纯随机扫描, 那么将要扫描<span style="line-height: 28px;"   >98229次heap page. 也就不难理解这里的</span><span style="line-height: 28px;"   >Buffers: shared hit=97837.</span></div><div style="line-height: 28px;"   >但是实际上, PostgreSQL的优化器似乎没有关注这些开销, 因为我们看到的成本只有2035.38 &nbsp;(这里和random_page_cost以及effective_cache_size 大于整个表和索引的空间有关)</div><div style="line-height: 28px;"   ><br></div><div style="line-height: 28px;"   >接下来把random_page_cost设置为2和1, 两个cost相减, 看看到底优化器评估了多少个块扫描.</div></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; set random_page_cost=2;</font></div><div><font size="2"   >SET</font></div></div><div><div><font size="2"   >digoal=&gt; set enable_seqscan=off;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=&gt; explain (analyze,verbose,costs,buffers,timing) select * from test_indexscan where id&gt;90000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_test_indexscan_id on digoal.test_indexscan &nbsp;(cost=0.29..2305.73 rows=98255 width=37) (actual time=0.045..81.76</font></div><div><font size="2"   >8 rows=98229 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (test_indexscan.id &gt; 90000)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=97837</font></div><div><font size="2"   >&nbsp;Total runtime: 92.186 ms</font></div><div><font size="2"   >(5 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=&gt; set random_page_cost=1;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=&gt; explain (analyze,verbose,costs,buffers,timing) select * from test_indexscan where id&gt;90000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_test_indexscan_id on digoal.test_indexscan &nbsp;(cost=0.29..2012.75 rows=98255 width=37) (actual time=0.028..80.05</font></div><div><font size="2"   >5 rows=98229 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (test_indexscan.id &gt; 90000)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=97837</font></div><div><font size="2"   >&nbsp;Total runtime: 90.549 ms</font></div><div><font size="2"   >(5 rows)</font></div></div><p></p></pre></div><div><div>相减得到293, 即优化器认为index scan需要扫描293个数据块.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select 2305-2012;</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 293</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div style="line-height: 28px;"   ><br></div><div>接下来我把enable_indexscan关闭, 让优化器选择bitmap scan.</div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >digoal=&gt; set enable_indexscan=off;</font></span></div><div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=&gt; explain (analyze,verbose,costs,buffers,timing) select * from test_indexscan where id&gt;90000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Bitmap Heap Scan on digoal.test_indexscan &nbsp;(cost=846.77..2282.96 rows=98255 width=37) (actual time=15.291..35.911 rows=98229 loops=</font></div><div><font size="2"   >1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp;Recheck Cond: (test_indexscan.id &gt; 90000)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=292</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_test_indexscan_id &nbsp;(cost=0.00..822.21 rows=98255 width=0) (actual time=15.202..15.202 rows=98229 loo</font></div><div><font size="2"   >ps=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (test_indexscan.id &gt; 90000)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=84</font></div><div><font size="2"   >&nbsp;Total runtime: 45.838 ms</font></div><div><font size="2"   >(8 rows)</font></div></div><p></p></pre></div><div>从bitmap scan的结果可以看到, 实际扫描的块为292个, 相比index scan少扫描了9.7万多数据块. 并且实际的执行时间也是bitmap scan要快很多.</div><div><br></div><div>本例PostgreSQL在计算index scan的random page的成本时, <span style="line-height: 28px;"   >评估得到的index scan成本小于bitmap index scan的成本, 然而实际上当</span><span style="line-height: 28px;"   >correlation</span><span style="line-height: 28px;"   >&nbsp;很小时, index scan会扫描更多次的heap page, 成本远远大于bitmap scan</span><span style="line-height: 28px;"   >.&nbsp;</span></div><div><span style="line-height: 28px;"   >本例发生这样的情况, 具体的原因和我们的成本因子设置有关系, 因为错误的设置了random_page_cost以及表和索引的大小小于effective_cache_size, PostgreSQL在使用这样的成本因子计算成本时, 出现了bitmap scan大于index scan成本的结果.</span></div><div><span style="line-height: 28px;"   >所以设置正确的成本因子非常重要, 这也是我们需要校准成本因子的原因.</span></div><div>例子 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[postgres@digoal pgdata]$ psql</font></div><div><font size="2"   >psql (9.3.4)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >-- 默认的成本因子</font></div><div><font size="2"   >digoal=# show seq_page_cost;</font></div><div><font size="2"   >&nbsp;seq_page_cost&nbsp;</font></div><div><font size="2"   >---------------</font></div><div><font size="2"   >&nbsp;1</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# show random_page_cost;</font></div><div><font size="2"   >&nbsp;random_page_cost&nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >&nbsp;4</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# show cpu_tuple_cost;</font></div><div><font size="2"   >&nbsp;cpu_tuple_cost&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp;0.01</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# show cpu_index_tuple_cost;</font></div><div><font size="2"   >&nbsp;cpu_index_tuple_cost&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;0.005</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# show cpu_operator_cost;</font></div><div><font size="2"   >&nbsp;cpu_operator_cost&nbsp;</font></div><div><font size="2"   >-------------------</font></div><div><font size="2"   >&nbsp;0.0025</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# show effective_cache_size;</font></div><div><font size="2"   >&nbsp;effective_cache_size&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;128MB</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >-- 表和索引的大小</font></div><div><font size="2"   >digoal=# \dt+ tbl_cost_align&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp; &nbsp; &nbsp;Name &nbsp; &nbsp; &nbsp;| Type &nbsp;| &nbsp;Owner &nbsp; | &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+----------------+-------+----------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | tbl_cost_align | table | postgres | 219 MB |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# \di+ tbl_cost_align_id&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp; &nbsp; &nbsp; Name &nbsp; &nbsp; &nbsp; &nbsp;| Type &nbsp;| &nbsp;Owner &nbsp; | &nbsp; &nbsp; Table &nbsp; &nbsp; &nbsp;| Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+-------------------+-------+----------+----------------+-------+-------------</font></div><div><font size="2"   >&nbsp;public | tbl_cost_align_id | index | postgres | tbl_cost_align | 64 MB |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >-- 把random_page_cost校准为10, 这个在一般的硬件环境中都适用.</font></div><div><font size="2"   >digoal=# set random_page_cost=10;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >-- 默认选择了全表扫描</font></div><div><font size="2"   >digoal=# explain (analyze,costs,buffers,timing,verbose) select * from tbl_cost_align where id&gt;2000000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on public.tbl_cost_align &nbsp;(cost=0.00..65538.00 rows=2996963 width=45) (actual time=0.050..1477.028 rows=2997015 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info, crt_time</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (tbl_cost_align.id &gt; 2000000)</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Filter: 2985</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=28038</font></div><div><font size="2"   >&nbsp;Total runtime: 2011.742 ms</font></div><div><font size="2"   >(6 rows)</font></div><div><font size="2"   >-- 关闭全表扫描后, 选择了bitmap scan</font></div><div><font size="2"   >digoal=# set enable_seqscan=off;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain (analyze,costs,buffers,timing,verbose) select * from tbl_cost_align where id&gt;2000000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp;Bitmap Heap Scan on public.tbl_cost_align &nbsp;(cost=105426.89..170926.93 rows=2996963 width=45) (actual time=1221.104..2911.889 rows=2</font></div><div><font size="2"   >997015 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info, crt_time</font></div><div><font size="2"   >&nbsp; &nbsp;Recheck Cond: (tbl_cost_align.id &gt; 2000000)</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Index Recheck: 2105</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=36229</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on tbl_cost_align_id &nbsp;(cost=0.00..104677.65 rows=2996963 width=0) (actual time=1214.865..1214.865 rows=2997</font></div><div><font size="2"   >015 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (tbl_cost_align.id &gt; 2000000)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=8191</font></div><div><font size="2"   >&nbsp;Total runtime: 3585.699 ms</font></div><div><font size="2"   >(9 rows)</font></div><div><font size="2"   >-- 关闭bitmap scan后选择了index scan, index scan的cost远远大于评估到的bitmap scan. 因为我们使用了正确的成本因子.</font></div><div><font size="2"   >digoal=# set enable_bitmapscan=off;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain (analyze,costs,buffers,timing,verbose) select * from tbl_cost_align where id&gt;2000000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >----------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using tbl_cost_align_id on public.tbl_cost_align &nbsp;(cost=0.43..16601388.04 rows=2996963 width=45) (actual time=0.064..566</font></div><div><font size="2"   >2.361 rows=2997015 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info, crt_time</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (tbl_cost_align.id &gt; 2000000)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=3005084</font></div><div><font size="2"   >&nbsp;Total runtime: 6173.067 ms</font></div><div><font size="2"   >(5 rows)</font></div><div><font size="2"   >-- 当错误的设置了random_page_cost=1=seq_page_cost时, 执行计划会有所改变(改变出现在effective_cache_size大于表和索引的大小时).</font></div><div><font size="2"   >-- the wrong plan cost occur when i set random_page_cost to 1, and effective_cache_size big then index size and table size in this case.</font></div><div><font size="2"   ><span style="line-height: 21px;"   >-- 重新进入psql, 所有因子重回默认值.</span></font></div><div><font size="2"   >digoal=# set random_page_cost=1;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain (analyze,costs,buffers,timing,verbose) select * from tbl_cost_align where id&gt;2000000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on public.tbl_cost_align &nbsp;(cost=0.00..65538.00 rows=2996963 width=45) (actual time=0.040..1692.712 rows=2997015 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info, crt_time</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (tbl_cost_align.id &gt; 2000000)</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Filter: 2985</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=28038</font></div><div><font size="2"   >&nbsp;Total runtime: 2249.313 ms</font></div><div><font size="2"   >(6 rows)</font></div><div><font size="2"   >-- 目前看来还正确</font></div><div><font size="2"   >digoal=# set enable_seqscan=off;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain (analyze,costs,buffers,timing,verbose) select * from tbl_cost_align where id&gt;2000000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp;Bitmap Heap Scan on public.tbl_cost_align &nbsp;(cost=31446.89..96946.93 rows=2996963 width=45) (actual time=1224.445..2454.797 rows=299</font></div><div><font size="2"   >7015 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info, crt_time</font></div><div><font size="2"   >&nbsp; &nbsp;Recheck Cond: (tbl_cost_align.id &gt; 2000000)</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Index Recheck: 2105</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=36229</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on tbl_cost_align_id &nbsp;(cost=0.00..30697.65 rows=2996963 width=0) (actual time=1220.404..1220.404 rows=29970</font></div><div><font size="2"   >15 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (tbl_cost_align.id &gt; 2000000)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=8191</font></div><div><font size="2"   >&nbsp;Total runtime: 2955.816 ms</font></div><div><font size="2"   >(9 rows)</font></div><div><font size="2"   >-- 当effective_cache_size还是小于表和索引时, 执行计划依旧正确</font></div><div><font size="2"   >digoal=# set effective_cache_size='280MB';</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain (analyze,costs,buffers,timing,verbose) select * from tbl_cost_align where id&gt;2000000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >-------------</font></div><div><font size="2"   >&nbsp;Bitmap Heap Scan on public.tbl_cost_align &nbsp;(cost=31446.89..96946.93 rows=2996963 width=45) (actual time=963.845..2060.463 rows=2997</font></div><div><font size="2"   >015 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info, crt_time</font></div><div><font size="2"   >&nbsp; &nbsp;Recheck Cond: (tbl_cost_align.id &gt; 2000000)</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Index Recheck: 2105</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=36229</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on tbl_cost_align_id &nbsp;(cost=0.00..30697.65 rows=2996963 width=0) (actual time=959.673..959.673 rows=2997015</font></div><div><font size="2"   >&nbsp;loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (tbl_cost_align.id &gt; 2000000)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=8191</font></div><div><font size="2"   >&nbsp;Total runtime: 2515.649 ms</font></div><div><font size="2"   >(9 rows)</font></div><div><font size="2"   >-- 当effective_cache_size大于表和索引的大小时, index scan的成本低于bitmap scan的成本了.</font></div><div><font size="2"   >-- When effective_cache_size large then table and index's size. then use index scan first than bitmap scan.</font></div><div><font size="2"   >digoal=# set effective_cache_size='283MB';</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain (analyze,costs,buffers,timing,verbose) select * from tbl_cost_align where id&gt;2000000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >-------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using tbl_cost_align_id on public.tbl_cost_align &nbsp;(cost=0.43..92030.24 rows=2996963 width=45) (actual time=0.045..5238.3</font></div><div><font size="2"   >61 rows=2997015 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info, crt_time</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (tbl_cost_align.id &gt; 2000000)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=3005084</font></div><div><font size="2"   >&nbsp;Total runtime: 5689.583 ms</font></div><div><font size="2"   >(5 rows)</font></div><div><font size="2"   >-- 如果这个时候再把random_page_cost调回正常值10, 则执行计划回归正常.</font></div><div><font size="2"   >digoal=# set random_page_cost=10;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain (analyze,costs,buffers,timing,verbose) select * from tbl_cost_align where id&gt;2000000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >---------------</font></div><div><font size="2"   >&nbsp;Bitmap Heap Scan on public.tbl_cost_align &nbsp;(cost=105426.89..170926.93 rows=2996963 width=45) (actual time=918.225..2195.414 rows=29</font></div><div><font size="2"   >97015 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info, crt_time</font></div><div><font size="2"   >&nbsp; &nbsp;Recheck Cond: (tbl_cost_align.id &gt; 2000000)</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Index Recheck: 2105</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=36229</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on tbl_cost_align_id &nbsp;(cost=0.00..104677.65 rows=2996963 width=0) (actual time=913.935..913.935 rows=299701</font></div><div><font size="2"   >5 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (tbl_cost_align.id &gt; 2000000)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=8191</font></div><div><font size="2"   >&nbsp;Total runtime: 2698.429 ms</font></div><div><font size="2"   >(9 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# set enable_seqscan=on;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain (analyze,costs,buffers,timing,verbose) select * from tbl_cost_align where id&gt;2000000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on public.tbl_cost_align &nbsp;(cost=0.00..65538.00 rows=2996963 width=45) (actual time=0.020..1522.791 rows=2997015 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info, crt_time</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (tbl_cost_align.id &gt; 2000000)</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Filter: 2985</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=28038</font></div><div><font size="2"   >&nbsp;Total runtime: 2104.057 ms</font></div><div><font size="2"   >(6 rows)</font></div><p></p></pre></div><div>本例说明了成本因子的重要性. 千万不能随意设置, 即使完全内存命中, random_page_cost也应该大于seq_page_cost.</div></div><div>我在前一篇BLOG中测试了这样的场景, 完全内存命中的场景可以设置 random_page_cost=1.6; seq_page_cost=1;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020143238354292/"   >http://blog.163.com/digoal@126/blog/static/16387704020143238354292/</a></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.tudou.com/programs/view/yQ0SzBqx_4w/"   >http://www.tudou.com/programs/view/yQ0SzBqx_4w/</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/message-id/flat/13668.1398541533@sss.pgh.pa.us#13668.1398541533@sss.pgh.pa.us"   >http://www.postgresql.org/message-id/flat/13668.1398541533@sss.pgh.pa.us#13668.1398541533@sss.pgh.pa.us</a></div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020143238354292/"   >http://blog.163.com/digoal@126/blog/static/16387704020143238354292/</a></div><div>4.&nbsp;src/backend/optimizer/path/costsize.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >cost_index function :&nbsp;</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Now interpolate based on estimated index order correlation to get total</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* disk I/O cost for main table accesses.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; csquared = indexCorrelation * indexCorrelation;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; run_cost += max_IO_cost + csquared * (min_IO_cost - max_IO_cost);</font></div></div><p></p></pre></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL index scan enlarge heap page scans when index and column correlation small. - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>