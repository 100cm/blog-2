<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Replica data from other Database to PostgreSQL release 9.0 and formerly</h2>
	<h5 id="">2012-03-10 10:40:14&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201221010730677/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">PostgreSQL 9.0以前的版本没有办法很方便的加载Oracle fdw模块.<wbr><div>或者你根本就不想直接在你的数据库里面直接加载Oracle fdw模块, 而是想通过一个集中的数据网关来接入Oracle数据库怎么办呢?</div><div>如图 :&nbsp;</div><div><div><img title="Replica data from other Database to PostgreSQL release 9.0 and formerly - 德哥@Digoal - The Heart,The World."  alt="Replica data from other Database to PostgreSQL release 9.0 and formerly - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img0.ph.126.net/yzDyD-58WX_95EXm_pBT_g==/1325465665347787000.jpg"  ></div>&nbsp;其中FDW Server作为生产PostgreSQL连接其他生产数据库的网关.&nbsp;</div><div><br></div><div>我们来举一个实际的例子, PostgreSQL 通过 这个数据网关连接远程的Oracle数据库.</div><div>Oracle 中有一个表 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >tbl</font></div><div><font size="2"  >(id int</font></div><div><font size="2"  >col1 varchar2(256),</font></div><div><font size="2"  >createtime date);</font></div><p></p></pre></div><div><br></div><div>在PostgreSQL 数据网关上建立连接到Oracle的FDW :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >superuser : </font></div><div><font size="2"  >create server digoal foreign data wrapper oracle_fdw options (dbserver '//192.168.xxx.xxx:1521/digoal');</font></div><div><font size="2"  >create user mapping for digoal server digoal options (user 'digoal',password '略');</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >create FOREIGN table digoal.tbl (id int, col1 varchar(256), createtime timestamp(0) without time zone) server digoal options (table 'tbl',schema 'digoal',plan_costs 'true');</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >grant select on digoal.tbl to digoal;</font></div><p></p></pre></div><div><br></div><div>在生产PostgreSQL数据库中通过dblink建立连接到PostgreSQL数据网关的对应的oracle 外部表的视图,或者通过postgresql fdw建立外部表. 本例使用dblink建立视图.</div><div><pre class="prettyprint"  ><p><font size="2"  >create view v_tbl as select id,col1,createtime from dblink('dbname=digoal host=数据网关IP port=端口 password=略 user=digoal','select id,col1,createtime from digoal.tbl') as link_tbl(id int, col1 varchar(256),createtime timestamp(0) without time zone);</font></p></pre></div><div>建立数据同步的控制表和记录表 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >create table sync_ctl(modifytime timestamp(0) without time zone);</font></div><div><font size="2"  >create table sync_record(cnt int,result text,createtime timestamp(0) without time zone);</font></div><p></p></pre></div><div>建立一个本地表, 存放同步过来的记录</div><div><pre class="prettyprint"  style="line-height: 22px;"  ><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >tbl</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >(id int</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >col1 varchar(256),</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >createtime timestamp(0) without time zone);</font></div></pre></div><div><div>建立数据同步函数 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >create or replace function sync_tbl() returns text as $$</font></div><div><font size="2"  >declare</font></div><div><font size="2"  >v_modifytime timestamp(0) without time zone;</font></div><div><font size="2"  >v_now timestamp(0) without time zone;</font></div><div><font size="2"  >v_result text;</font></div><div><font size="2"  >v_cnt int;</font></div><div><font size="2"  >begin</font></div><div><font size="2"  >v_result := 'no_operate';</font></div><div><font size="2"  >v_now := now();</font></div><div><font size="2"  >-- 防止多个调用,导致数据重复.</font></div><div><font size="2"  >-- 如果同步是根据createtime来的, 推荐不要放在12点准时执行, 可能远程的记录未来得及插入. 尽量1点以后执行.</font></div><div><font size="2"  >lock table sync_ctl in exclusive mode;</font></div><div><font size="2"  >perform 1 from sync_ctl limit 1;</font></div><div><font size="2"  >if not found then</font></div><div><font size="2"  >&nbsp; insert into sync_ctl(modifytime) values(v_now-interval '1 day');</font></div><div><font size="2"  >end if;</font></div><div><font size="2"  >select modifytime into v_modifytime from sync_ctl limit 1;</font></div><div><font size="2"  >if v_modifytime &lt; current_date then</font></div><div><font size="2"  >&nbsp; insert into tbl(id,col1,createtime) select&nbsp; <span style="line-height: 22px;"  >id,col1,createtime</span>&nbsp;&nbsp;from v_tbl where createtime &gt;=date(v_modifytime) and createtime &lt; date(v_now);</font></div><div><font size="2"  >&nbsp; update sync_ctl set modifytime=v_now;</font></div><div><font size="2"  >&nbsp; select count(*) into v_cnt from tbl where createtime &gt;=date(v_modifytime) and createtime &lt; date(v_now);</font></div><div><font size="2"  >&nbsp; v_result := 'ok';</font></div><div><font size="2"  >&nbsp; insert into sync_record(cnt,result,createtime) values(v_cnt,v_result,v_now);</font></div><div><font size="2"  >end if;</font></div><div><font size="2"  >return v_result;</font></div><div><font size="2"  >exception</font></div><div><font size="2"  >when others then</font></div><div><font size="2"  >&nbsp; v_result := 'error';</font></div><div><font size="2"  >&nbsp; return v_result;</font></div><div><font size="2"  >end;</font></div><div><font size="2"  >$$ language plpgsql;</font></div><p></p></pre></div></div><div><br></div><div>同步时执行上面的函数即可.</div><div><pre class="prettyprint"  ><p><font size="2"  >select * from sync_tbl();</font></p></pre></div><div>结果no_operate表示没有任何操作, 可能已经同步了.</div><div>结果error表示同步有异常, 需要检查.</div><div>结果ok表示同步正常, 记录最后一次同步时间和同步的记录数.</div><div><br></div><div>【参考】</div><div>注意事项如下 :&nbsp;</div><div><a href="http://blog.163.com/digoal@126/blog/static/1638770402012295525666/"  >http://blog.163.com/digoal@126/blog/static/1638770402012295525666/</a> </div></div>
	</div>
</div>
</body>
</html>