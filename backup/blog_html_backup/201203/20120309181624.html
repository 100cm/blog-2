<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Replica small data to PostgreSQL from Oracle's Big table</h2>
	<h5 id="">2012-03-09 18:16:24&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012295525666/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">有时候会遇到从Oracle同步数据到PostgreSQL数据库的需求, 当Oracle那边的表是大表的时候,&nbsp;<div>即使同步到PostgreSQL的数据量很小也可能很慢.</div><div>原因可能是</div><div>1. Oracle那边的执行计划可能不优. 比如走全表扫描了. 或者走的索引不对.&nbsp;<br></div><div>2. 条件没有正确的转换给Oracle, 那就惨了, 数据全部取过来然后在PostgreSQL中过滤.</div><div><br></div><div>例如我们需要同步的是前一天的数据, 实际上走分区的全表扫描可能比走索引快. 但是又不好写HINT.</div><div>那么怎么来解决这种问题呢? 来看个例子 :&nbsp;</div><div>例如我们要从Oracle的tbl表同步前一天的数据, 这个表做了按月分区. &nbsp;一个月大概5000W记录. 10GB左右.</div><div>我们要同步的数据条件是<span style="line-height: 22px;"   >cond1 = '1' and cond2 in( '10','15'). 这个取出来每天只有几百条记录.&nbsp;</span></div><div><div>同步的SQL应该是</div><div>select a, b, c, createtime from tbl where createtime&gt;=sysdate-1 and createtime&lt;sysdate and&nbsp;<span style="line-height: 22px;"   >cond1 = '1' and cond2 in( '10','15').</span></div><div><span style="line-height: 22px;"   >这个SQL可以走时间索引也可以走cond1和cond2的联合索引. 或者走分区扫描.</span></div><div>几种执行计划的时间相差比较大.&nbsp;</div><div>走联合索引的效率可能是最高的, 不过这个索引不存在, 在ORACLE中也不存在PostgreSQL中这样的partial索引, 而且建立索引之后会带来写入的延迟. 最终决定不建立.</div><div><br></div><div>为了避免第二种情况的发生, 让PG读ORACLE的视图, 而不是直接读表.</div><div>通过限定视图中的数据量来限定PG的最大可能获取量.</div><div><br></div><div>oracle :&nbsp;</div><div>digoal user :&nbsp;</div><div><pre class="prettyprint"   ><p><font size="2"   >create view v_tbl as select a,b,c,createtime from tbl where cond1 = '1' and cond2 in( '10','15') and createtime &gt;= sysdate-7;</font></p></pre></div><div>这里限定我们要限定的条件, 并且加了一个时间的限定.</div><div>然后再到PostgreSQL中创建基于这个视图的外部表.</div><div>注 : 如果你的oracle_fdw支持where语句下发的话, 可以不用这么麻烦.</div><div><br></div><div>postgresql9.1 :&nbsp;</div><div>superuser :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >cretae role digoal nosuperuser encrypted password 'DIGOAL';</font></div><div><font size="2"   >create server digoal foreign data wrapper oracle_fdw options (dbserver '//192.168.xxx.xxx:1521/digoal');</font></div><div><font size="2"   >create user mapping for digoal server digoal options (user 'digoal',password 'digoal_oracle');</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >create FOREIGN table digoal.ora_tbl (a varchar(9),b varchar(420),c varchar(45),createtime timestamp(0) without time zone) server digoal options (table 'v_tbl',schema 'digoal',plan_costs 'true');</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >grant select on digoal.ora_tbl to digoal;</font></div><p></p></pre></div><div><br></div><div>digoal user :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create table tbl (a varchar(9),b varchar(420),c varchar(45),createtime timestamp(0) without time zone);</font></div><div><font size="2"   >create table sync_record(modifytime timestamp(0) without time zone);</font></div><p></p></pre></div><div>sync_record 用于记录最后一次同步时间, 防止重复同步.</div></div><div>下面是同步调用的函数 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create or replace function sync_tbl() returns text as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >v_modifytime timestamp(0) without time zone;</font></div><div><font size="2"   >v_now timestamp(0) without time zone;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >v_now = now();</font></div><div><font size="2"   >-- lock表防止同时调用这个同步过程. 导致重复同步</font></div><div><p></p><div><font size="2"   >lock table sync_record in exclusive mode;</font></div><div><font size="2"   >perform 1 from sync_record limit 1;</font></div><div><font size="2"   >if not found then</font></div><div><font size="2"   >insert into sync_record(modifytime) values(v_now-interval '1 day');</font></div><div><font size="2"   >end if;</font></div><div><font size="2"   >select modifytime into v_modifytime from sync_record limit 1;</font></div><div><font size="2"   >if v_modifytime &lt; current_date then</font></div><div><font size="2"   >insert into tbl(a,b,c,createtime) select a,b,c,createtime from ora_tbl where createtime &gt;=date(v_modifytime) and createtime &lt; date(v_now);</font></div><div><font size="2"   >update sync_record set modifytime=v_now;</font></div><div><font size="2"   >end if;</font></div><div><font size="2"   >return 'ok';</font></div><div><font size="2"   >exception</font></div><div><font size="2"   >when others then</font></div><div><font size="2"   >return 'error';</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div></div><p></p></pre></div><div><p></p></div></div><div><p></p><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select * from sync_tbl();</font></div><div><font size="2"   >&nbsp;sync_tbl_app_charge&nbsp;</font></div><div><font size="2"   >---------------------</font></div><div><font size="2"   >&nbsp;ok</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><p></p></div></div>
	</div>
</div>
</body>
</html>