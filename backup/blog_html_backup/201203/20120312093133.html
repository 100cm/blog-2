<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">UPDATE column's value equal to another column(OLD or NEW).</h2>
	<h5 id="">2012-03-12 9:31:33&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201221292626858/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">某些场景可能会用到update 语句中列值等于另一个列值的情况或者用到另一个列值的表达式.<div>但是被关联的那个列也改变了, 也就是产生了一个NEW, 还有一个OLD的值.</div><div>那么在更新的过程中用的是OLD还是NEW呢?</div><div>例子 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table test (id int, col1 int, col2 int,col3 int);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >Time: 1.035 ms</font></div><div><div><font size="2"   >digoal=&gt; insert into test values (1,10,20,30);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >Time: 0.582 ms</font></div></div><div><div><font size="2"   >digoal=&gt; update test set col1=col1+1,col2=col1+10,col3=col1+col2;</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   >Time: 1.225 ms</font></div><div><font size="2"   >digoal=&gt; select * from test ;</font></div><div><font size="2"   >&nbsp;id | col1 | col2 | col3&nbsp;</font></div><div><font size="2"   >----+------+------+------</font></div><div><font size="2"   >&nbsp; 1 | &nbsp; 11 | &nbsp; 20 | &nbsp; 30</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div>显然col2=col1+10和col3=col1+col2这里用到的实际上是OLD.col1和OLD.col2.<wbr></div><div>再看看ORACLE中是否也是一样的情况 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; create table test(id int primary key,col1 int, col2 int,col3 int);</font></div><div><span style="font-size: small;"   >Table created.</span></div><div><font size="2"   ><br></font></div><div><font size="2"   >SQL&gt; insert into test values (1,10,20,30);</font></div><div><span style="font-size: small;"   >1 row created.</span></div><div><font size="2"   ><br></font></div><div><font size="2"   >SQL&gt; commit;</font></div><div><span style="font-size: small;"   >Commit complete.</span></div><div><font size="2"   ><br></font></div><div><font size="2"   >SQL&gt; update test set col1=col1+1,col2=col1+10,col3=col1+col2;</font></div><div><span style="font-size: small;"   >1 row updated.</span></div><div><font size="2"   ><br></font></div><div><font size="2"   >SQL&gt; select * from test;</font></div><div><span style="font-size: small;"   >&nbsp; &nbsp; &nbsp; &nbsp; ID &nbsp; &nbsp; &nbsp; COL1 &nbsp; &nbsp; &nbsp; COL2 &nbsp; &nbsp; &nbsp; COL3</span></div><div><font size="2"   >---------- ---------- ---------- ----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; 11 &nbsp; &nbsp; &nbsp; &nbsp; 20 &nbsp; &nbsp; &nbsp; &nbsp; 30</font></div><p></p></pre></div><div>Oracle也一样用的是OLD值.</div><div><br></div><div>如果要让数据库使用NEW值怎么办呢? 可以使用触发器来实现, 将NEW值进行修改后返回, 使用BEFORE触发器 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; CREATE FUNCTION test_update() RETURNS trigger AS $$</font></div><div><font size="2"   >digoal$&gt; BEGIN</font></div><div><font size="2"   >digoal$&gt; NEW.col2=NEW.col1+10;</font></div><div><font size="2"   >digoal$&gt; NEW.col3=NEW.col1+NEW.col2;</font></div><div><font size="2"   >digoal$&gt; RETURN NEW;</font></div><div><font size="2"   >digoal$&gt; END;</font></div><div><font size="2"   >digoal$&gt; $$ LANGUAGE plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><div><font size="2"   >Time: 2.550 ms</font></div><div><font size="2"   >digoal=&gt;&nbsp;</font></div><div><font size="2"   >digoal=&gt; CREATE TRIGGER test_update BEFORE UPDATE ON test</font></div><div><font size="2"   >digoal-&gt; &nbsp; &nbsp; FOR EACH ROW EXECUTE PROCEDURE test_update();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >Time: 1.224 ms</font></div><p></p></pre></div><div><div>使用触发器后, 更新col1前触发器修正了NEW.col2和NEW.col3. 因此结果被我们修改了.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; truncate test;</font></div><div><font size="2"   >TRUNCATE TABLE</font></div><div><font size="2"   >Time: 5.334 ms</font></div><div><font size="2"   >digoal=&gt; insert into test values (1,10,20,30);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >Time: 0.579 ms</font></div><div><font size="2"   >digoal=&gt; select ctid,* from test;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | col1 | col2 | col3&nbsp;</font></div><div><font size="2"   >-------+----+------+------+------</font></div><div><font size="2"   >&nbsp;(0,1) | &nbsp;1 | &nbsp; 10 | &nbsp; 20 | &nbsp; 30</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >这里虽然update只修改了col1的值, 但是在触发器内我们顺带修改了col2和col3, 因此结果是col1,col2,col3都修改了</font></div><div><div><font size="2"   >digoal=&gt; update test set col1=col1+1;</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=&gt; select ctid,* from test;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | col1 | col2 | col3&nbsp;</font></div><div><font size="2"   >-------+----+------+------+------</font></div><div><font size="2"   >&nbsp;(0,2) | &nbsp;1 | &nbsp; 11 | &nbsp; 21 | &nbsp; 32</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div></div><div>同时从ctid可以看出, 使用这种方法, 更新只产生了一条tuple. 而不是两条.&nbsp;</div><div><br></div><div><span style="line-height: 28px; white-space: pre;"   >但是这种方法太隐晦了, 如果要使用NEW值更新的话, 最好可以在语法中体现出来, 目前PG不支持, 现实中我们可以这么做.</span></div><div><span style="line-height: 28px; white-space: pre;"   ><br></span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >update test set col1=col1+1,col2=(col1+1)+10,col3=(<span style="line-height: 28px;"   >col1+1)</span>+(<span style="line-height: 28px;"   >(col1+1)+10)</span>;</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >因为我们的需求是 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >NEW.col1 = OLD.col1+1</font></div><div><font size="2"   >NEW.col2 = NEW.col1 + 10 =&nbsp;<span style="line-height: 28px;"   >OLD.col1+1 + 10</span></font></div><div><font size="2"   >NEW.col3 = NEW.col1 + NEW.col2 = .....</font></div><p></p></pre></div><div><span style="white-space:pre;"   >这种方法也只会产生一个新的tuple版本.</span></div><div><span style="white-space:pre;"   ><br></span></div><div><span style="white-space:pre;"   >如果使用with的写法, 会产生多条垃圾.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >with t1(pk int, col1 int) as (update test set col1=col1+1 where pk=? returning (NEW.pk, NEW.col1)) update test set col2=t1.col1 from t1 where test.pk=? and test.pk=t1.pk;</font></div><div></div><p></p></pre></div><div>【参考】</div><div><a rel="nofollow" href="http://www.postgresql.org/docs/9.1/static/plpgsql-trigger.html"   >http://www.postgresql.org/docs/9.1/static/plpgsql-trigger.html</a> </div></div>
	</div>
</div>
</body>
</html>