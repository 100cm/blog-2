<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL function's SECURITY DEFINER | INVOKER, SET configuration_parameter { TO value | = value | FROM CURRENT }</h2>
	<h5 id="">2015-07-17 16:31:43&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020156173121155/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 函数可以设置被调用时的角色，以及参数。</div><div>详细的语法如下：</div><wbr><div><pre style="-webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border: 1px solid rgb(207, 207, 207); padding: 2ex; margin-top: 2ex; margin-bottom: 2ex; margin-left: 2ex; overflow: auto; border-radius: 8px; line-height: normal; background-color: rgb(247, 247, 247);"   ><font size="2"   >CREATE [ OR REPLACE ] FUNCTION
    <tt style="font-weight: bold; font-style: italic;"   >name</tt> ( [ [ <tt style="font-weight: bold; font-style: italic;"   >argmode</tt> ] [ <tt style="font-weight: bold; font-style: italic;"   >argname</tt> ] <tt style="font-weight: bold; font-style: italic;"   >argtype</tt> [ { DEFAULT | = } <tt style="font-weight: bold; font-style: italic;"   >default_expr</tt> ] [, ...] ] )
    [ RETURNS <tt style="font-weight: bold; font-style: italic;"   >rettype</tt>
      | RETURNS TABLE ( <tt style="font-weight: bold; font-style: italic;"   >column_name</tt> <tt style="font-weight: bold; font-style: italic;"   >column_type</tt> [, ...] ) ]
  { LANGUAGE <tt style="font-weight: bold; font-style: italic;"   >lang_name</tt>
    | TRANSFORM { FOR TYPE <tt style="font-weight: bold; font-style: italic;"   >type_name</tt> } [, ... ]
    | WINDOW
    | IMMUTABLE | STABLE | VOLATILE | [ NOT ] LEAKPROOF
    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
    | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
    | COST <tt style="font-weight: bold; font-style: italic;"   >execution_cost</tt>
    | ROWS <tt style="font-weight: bold; font-style: italic;"   >result_rows</tt>
    | SET <tt style="font-weight: bold; font-style: italic;"   >configuration_parameter</tt> { TO <tt style="font-weight: bold; font-style: italic;"   >value</tt> | = <tt style="font-weight: bold; font-style: italic;"   >value</tt> | FROM CURRENT }
    | AS '<tt style="font-weight: bold; font-style: italic;"   >definition</tt>'
    | AS '<tt style="font-weight: bold; font-style: italic;"   >obj_file</tt>', '<tt style="font-weight: bold; font-style: italic;"   >link_symbol</tt>'
  } ...
    [ WITH ( <tt style="font-weight: bold; font-style: italic;"   >attribute</tt> [, ...] ) ]</font></pre></div><div>当函数被调用时，可以选择以创建函数的角色执行函数，或者以调用者的角色执行函数(默认)。</div><div>同时，我们还可以设置函数被调用时的参数。</div><div>我们可以跟踪一下，跟踪角色需要用到session_user和current_user，这两者的差别可参考如下代码：</div><div><span style="line-height: 28px;"   >src/backend/utils/init/miscinit.c</span></div><div><span style="line-height: 28px;"   >session_user是指</span>登陆数据库时的角色或者被<span style="line-height: 28px;"   >SET SESSION AUTHORIZATION设置的角色</span><span style="line-height: 28px;"   >。</span></div><div><span style="line-height: 28px;"   >current_user是指set role设置的角色，或者继承自session user，或者是函数调用时定义的角色。</span></div><div><span style="line-height: 28px;"   >举个例子，先搞明白这两个用户的含义：</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create role digoal login;</font></div><div><div><font size="2"   >postgres=&gt; \c postgres postgres</font></div><div><font size="2"   >You are now connected to database "postgres" as user "postgres".</font></div></div><div><div><font size="2"   >postgres=# select session_user,current_user;</font></div><div><font size="2"   >&nbsp;session_user | current_user&nbsp;</font></div><div><font size="2"   >--------------+--------------</font></div><div><font size="2"   >&nbsp;postgres &nbsp; &nbsp; | postgres</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >postgres=# set role digoal;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >postgres=&gt; select session_user,current_user;</font></div><div><font size="2"   >&nbsp;session_user | current_user&nbsp;</font></div><div><font size="2"   >--------------+--------------</font></div><div><font size="2"   >&nbsp;postgres &nbsp; &nbsp; | digoal</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div><br></div><div>创建测试函数：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create or replace function f1() returns void as $$</font></div><div><font size="2"   >declare&nbsp;</font></div><div><font size="2"   >&nbsp; x text;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; show search_path into x;&nbsp;</font></div><div><font size="2"   >&nbsp; raise notice 'search_path: % | session_role: % | current_role: %', x, session_user, current_user;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql security definer set search_path to 'public';</font></div><p></p></pre></div><div>这里的security definer表示调用函数时，使用函数owner的权限进行调用。</div><div><span style="line-height: 28px;"   >set search_path to 'public'，表示在调用函数时，使用这个值作为search_path。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# grant usage on schema postgres to digoal;</font></div><div><font size="2"   >GRANT</font></div><p></p></pre></div><div>使用digoal用户连接到postgres数据库，并调用postgres.f1()函数：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \c postgres digoal</font></div><div><font size="2"   >You are now connected to database "postgres" as user "digoal".</font></div><div><font size="2"   >postgres=&gt; select postgres.f1();</font></div><div><font size="2"   >NOTICE: &nbsp;search_path: public | session_role: digoal | current_role: postgres</font></div><div><font size="2"   >&nbsp;f1&nbsp;</font></div><div><font size="2"   >----</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>从NOTICE可以看到我们对函数的设置起作用了。search_path是我们设置的public, 而不是默认的<span style="line-height: 28px;"   >&nbsp;"$user",public。</span></div><div><span style="line-height: 28px;"   >current_role则是函数的definer postgres。</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=&gt; select session_user,current_user;</font></div><div><font size="2"   >&nbsp;session_user | current_user&nbsp;</font></div><div><font size="2"   >--------------+--------------</font></div><div><font size="2"   >&nbsp;digoal &nbsp; &nbsp; &nbsp; | digoal</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >postgres=&gt; show search_path;</font></div><div><font size="2"   >&nbsp; search_path &nbsp;&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp;"$user",public</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div>因此我们使用security definer时，需特别注意，因为可能造成权限升级，例如本文使用超级用户创建的security definer函数。</div><div>我们把这个函数的security改为invoker。再次使用digoal调用f1()，可以看到current_role是digoal了。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=&gt; \c postgres postgres</font></div><div><font size="2"   >You are now connected to database "postgres" as user "postgres".</font></div><div><font size="2"   >postgres=# alter function f1() security invoker;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><div><font size="2"   >postgres=# \c postgres digoal</font></div><div><font size="2"   >You are now connected to database "postgres" as user "digoal".</font></div><div><font size="2"   >postgres=&gt; select postgres.f1();</font></div><div><font size="2"   >NOTICE: &nbsp;search_path: public | session_role: digoal | current_role: digoal</font></div><div><font size="2"   >&nbsp;f1&nbsp;</font></div><div><font size="2"   >----</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>下面举个例子，说明security definer的不安因素。使用超级用户创建一个函数如下，用于检查用户是否通过密码认证。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create table postgres.pwds(username name,pwd text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# insert into pwds values ('digoal','hello');</font></div><div><font size="2"   >INSERT 0 1</font></div></div><div><div><font size="2"   ><span style="line-height: 28px;"   >postgres=#</span><span style="line-height: 28px;"   >&nbsp;</span>CREATE FUNCTION check_password(uname TEXT, pass TEXT)</font></div><div><font size="2"   >RETURNS BOOLEAN AS $$</font></div><div><font size="2"   >DECLARE passed BOOLEAN;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SELECT &nbsp;(pwd = $2) INTO passed</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FROM &nbsp; &nbsp;pwds</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; WHERE &nbsp; username = $1;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; RETURN passed;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$$ &nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp; &nbsp; SECURITY invoker; &nbsp;-- 假设pwds这个表只有超级用户可以访问。所以普通用户调用这个函数时，如果设置为security invoker会有问题。</font></div></div><p></p></pre></div><div><br></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >\c postgres digoal</font></div><div><div><font size="2"   >postgres=&gt; show search_path;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; search_path &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >---------------------------</font></div><div><font size="2"   >&nbsp;postgres, "$user", public</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >postgres=&gt; select postgres.check_password('digoal','hello');</font></div><div><font size="2"   >ERROR: &nbsp;permission denied for relation pwds</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "SELECT &nbsp;(pwd = $2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FROM &nbsp; &nbsp;pwds</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; WHERE &nbsp; username = $1"</font></div><div><font size="2"   >PL/pgSQL function check_password(text,text) line 4 at SQL statement</font></div></div><p></p></pre></div><div>但是如果设置为security definer，想想有什么安全隐患呢？</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# alter function check_password(text,text) security definer;</font></div><div><font size="2"   >ALTER FUNCTION</font></div></div><div><div><font size="2"   >postgres=# \c postgres digoal</font></div><div><font size="2"   >You are now connected to database "postgres" as user "digoal".</font></div><div><font size="2"   >postgres=&gt; select postgres.check_password('digoal','hello');</font></div><div><font size="2"   >&nbsp;check_password&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp;t</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >postgres=&gt; select postgres.check_password('digoal','hello1');</font></div><div><font size="2"   >&nbsp;check_password&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp;f</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div>这样看貌似没有隐患，但是因为函数中没有使用schema.table的方式，所以我们可以使用普通用户自己建立一张认证表，并自定义search_path来修改扫描优先级，来通过认证，甚至可以使用临时表的SCHEMA，都不需要修改search_path(因为临时表schema优先级被排在最前)，偷偷就搞定了。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=&gt; create temp table pwds(username text,pwd text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=&gt; insert into pwds values ('digoal','err');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=&gt; select postgres.check_password('digoal','err');</font></div><div><font size="2"   >&nbsp;check_password&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp;t</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>为了提高security definer函数的安全性。可以有以下方法。</div><div>1. 建议在里面使用的函数或表等一切对象，都使用schema强制指定。</div><div>2. 设置search_path, 防止普通用户钻空子。</div><div>例如：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# CREATE or replace FUNCTION check_password(uname TEXT, pass TEXT)</font></div><div><font size="2"   >RETURNS BOOLEAN AS $$</font></div><div><font size="2"   >DECLARE passed BOOLEAN;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SELECT &nbsp;(pwd = $2) INTO passed</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FROM &nbsp; &nbsp;postgres.pwds</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; WHERE &nbsp; username = $1;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; RETURN passed;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$$ &nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp; &nbsp; SECURITY definer;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><p></p></pre></div><div>现在钻不了空子了：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \c postgres digoal</font></div><div><font size="2"   >You are now connected to database "postgres" as user "digoal".</font></div><div><font size="2"   >postgres=&gt; create temp table pwds(username text,pwd text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=&gt; insert into pwds values ('digoal','err');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=&gt; select postgres.check_password('digoal','err');</font></div><div><font size="2"   >&nbsp;check_password&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp;f</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>或者在调用函数时使用设置的search_path，将普通用户能创建表的schema都去除。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# CREATE or replace FUNCTION check_password(uname TEXT, pass TEXT)</font></div><div><font size="2"   >RETURNS BOOLEAN AS $$</font></div><div><font size="2"   >DECLARE passed BOOLEAN;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SELECT &nbsp;(pwd = $2) INTO passed</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FROM &nbsp; &nbsp;pwds &nbsp; &nbsp; &nbsp; &nbsp; -- &nbsp;不使用schema</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; WHERE &nbsp; username = $1; &nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; RETURN passed;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$$ &nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp; &nbsp; SECURITY definer set search_path to "$user",public,pg_temp; &nbsp;-- 将临时表schema放到最后</font></div><div><font size="2"   >CREATE FUNCTION</font></div><p></p></pre></div><div>现在也安全了：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \c postgres digoal</font></div><div><div><font size="2"   >postgres=&gt; create temp table pwds(username text,pwd text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=&gt; insert into pwds values ('digoal','err');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=&gt; set search_path=pg_temp,postgres,"$user",public;<br>SET</font></div><div><font size="2"   >postgres=&gt; select * from pwds ;<br> username | pwd <br>----------+-----<br> digoal   | err<br>(1 row)</font></div><div><font size="2"   >因为函数中设置了search<span style="line-height: 21px;"   >_path to "$user",public,pg_temp; 所以还是会用postgres.pwds这个表的数据。</span></font></div><div><font size="2"   >postgres=&gt; select postgres.check_password('digoal','err');</font></div><div><font size="2"   >&nbsp;check_password&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp;f</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div>不过这里还是推荐在函数中使用schema，防止这类问题。</div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.5/static/sql-createfunction.html"   >http://www.postgresql.org/docs/9.5/static/sql-createfunction.html</a></div><div>2.&nbsp;src/backend/utils/init/miscinit.c</div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 28px;"   ><font size="2"   >/* ----------------------------------------------------------------</font></span></div><div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;User ID state</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We have to track several different values associated with the concept</font></div><div><font size="2"   >&nbsp;* of "user ID".</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* AuthenticatedUserId is determined at connection start and never changes.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* SessionUserId is initially the same as AuthenticatedUserId, but can be</font></div><div><font size="2"   >&nbsp;* changed by SET SESSION AUTHORIZATION (if AuthenticatedUserIsSuperuser).</font></div><div><font size="2"   >&nbsp;* This is the ID reported by the SESSION_USER SQL function.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* OuterUserId is the current user ID in effect at the "outer level" (outside</font></div><div><font size="2"   >&nbsp;* any transaction or function). &nbsp;This is initially the same as SessionUserId,</font></div><div><font size="2"   >&nbsp;* but can be changed by SET ROLE to any role that SessionUserId is a</font></div><div><font size="2"   >&nbsp;* member of. &nbsp;(XXX rename to something like CurrentRoleId?)</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* CurrentUserId is the current effective user ID; this is the one to use</font></div><div><font size="2"   >&nbsp;* for all normal permissions-checking purposes. &nbsp;At outer level this will</font></div><div><font size="2"   >&nbsp;* be the same as OuterUserId, but it changes during calls to SECURITY</font></div><div><font size="2"   >&nbsp;* DEFINER functions, as well as locally in some specialized commands.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* SecurityRestrictionContext holds flags indicating reason(s) for changing</font></div><div><font size="2"   >&nbsp;* CurrentUserId. &nbsp;In some cases we need to lock down operations that are</font></div><div><font size="2"   >&nbsp;* not directly controlled by privilege settings, and this provides a</font></div><div><font size="2"   >&nbsp;* convenient way to do it.</font></div><div><font size="2"   >&nbsp;* ----------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;*/</font></div></div><p></p></pre></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL functions SECURITY DEFINER | INVOKER, SET configuration_parameter { TO value | = value | FROM CURRENT } - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>