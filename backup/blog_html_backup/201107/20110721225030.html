<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL V8.4 Warm-Standby design and implement</h2>
	<h5 id="">2011-07-21 22:50:30&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201162112935395/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">虽然现在PostgreSQL 9.0已经很成熟了，但是很多企业还是在用PostgreSQL 8.4的版本。<div>那么8.4怎么设计和实施一个数据库standby以及备份策略呢，下面简单的拿一个案例来分享一下 :&nbsp;</div><div><div><img title="PostgreSQL V8.4 Warm-Standby design and implement - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL V8.4 Warm-Standby design and implement - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img.ph.126.net/PUImyQkdFFGMzLgRAJjVYA==/1551771546622665615.jpg"  ></div>&nbsp;</div><div>以上分为三台主机，实际使用中，备份机和Standby库的主机可以是同一台机器。</div><div>以下是配置部分 :&nbsp;</div><div><div>主节点 10.0.0.10</div><div>远程NFS归档目录(postgres用户读写权限) /data/recoverydir/pg_arch</div><div><span>本地归档目录(postgres</span>用户读写权限<span>) /data1/archivedir/pg_arch</span></div><div><span>备份目录(postgres</span>用户读写权限<span>) /data1/pg_backup</span></div><div><span>日志目录(postgres</span>用户读写权限<span>) /data1/pg_run_log ; ln -s /data1/pg_run_log /var/log/pg_run_log</span></div><div>&nbsp; df</div><div>/dev/sdb1 670G 48G 589G 8% /data1</div><div>10.0.0.20:/data1/archivedir 670G 66G 571G 11% /data/recoverydir</div><div>&nbsp; /etc/fstab</div><div>10.0.0.20:/data1/archivedir /data/recoverydir nfs &nbsp;rw,rsize=8192,wsize=8192,noatime &nbsp; &nbsp; &nbsp; 1 3</div><div>&nbsp; /etc/exports</div><div>/data1/archivedir 10.0.0.20/32(rw,sync,wdelay,no_root_squash,anonuid=0,anongid=0)</div><div>exportfs -av</div><div>固定nfs监听端口,如修改 /etc/services</div><div># Local services</div><div>mountd 845/tcp #rpc.mountd</div><div>mountd 842/udp #rpc.mountd</div><div>rquotad 790/tcp #rpc.rquotad</div><div>rquotad 787/udp #rpc.rquotad</div><div><br></div><div><br></div><div>备节点 10.0.0.20</div><div><span>远程NFS归档目录(postgres</span>用户读写权限<span>) /data/recoverydir/pg_arch</span></div><div><span>本地归档目录(postgres</span>用户读写权限<span>) /data1/archivedir/pg_arch</span></div><div><span>备份目录(postgres</span>用户读写权限<span>) /data1/pg_backup</span></div><div><span>日志目录(postgres</span>用户读写权限<span>) /data1/pg_run_log ; ln -s /data1/pg_run_log /var/log/pg_run_log</span></div><div>&nbsp; df</div><div>/dev/sdb1 670G 48G 589G 8% /data1</div><div>10.0.0.10:/data1/archivedir 670G 66G 571G 11% /data/recoverydir</div><div>&nbsp; /etc/fstab</div><div>10.0.0.10:/data1/archivedir /data/recoverydir nfs &nbsp;rw,rsize=8192,wsize=8192,noatime &nbsp; &nbsp; &nbsp; 1 3</div><div>&nbsp; /etc/exports</div><div>/data1/archivedir 10.0.0.10/32(rw,sync,wdelay,no_root_squash,anonuid=0,anongid=0)</div><div>固定nfs监听端口,如修改 /etc/services</div><div># Local services</div><div>mountd 845/tcp #rpc.mountd</div><div>mountd 842/udp #rpc.mountd</div><div>rquotad 790/tcp #rpc.rquotad</div><div>rquotad 787/udp #rpc.rquotad</div><div><br></div><div><br></div><div># On 备库节点,配置rsync</div><div># Rsyncd On Standby Database Server &amp; Backup Server</div><div>cat /etc/rsyncd.postgres.conf&nbsp;</div><div># Rsyncd On Standby Database Server &amp; Backup Server</div><div>port = 873</div><div>hosts deny = 0.0.0.0/0</div><div>read only = false</div><div>write only = false</div><div>gid = 0</div><div>uid = 0</div><div>use chroot = no</div><div>max connections = 10</div><div>pid file = /var/run/rsync.pid</div><div>lock file = /var/run/rsync.lock</div><div>log file = /var/log/rsync.log</div><div><br></div><div>[pgdata]</div><div>path = /data1/pg_data</div><div>comment = Building Database Dir.</div><div>hosts allow = 10.0.0.20,10.0.0.10</div><div><br></div><div>[pgbackup]</div><div>path = /data1/pg_backup</div><div>comment = Database Backup Dir.</div><div>hosts allow = 10.0.0.20,10.0.0.10</div><div><br></div><div># On 备库节点,开启rsync后台进程,如果配置修改的话重新执行一遍以下程序,表示reload</div><div>rsync -v --daemon --config=/etc/rsyncd.postgres.conf</div><div><br></div><div># On 主库节点,开启归档</div><div>fsync = on</div><div>full_page_writes = on</div><div>archive_mode = on</div><div>archive_command = 'cp -f %p /data1/archivedir/pg_arch/%f 2&gt;&gt;/var/log/pg_run_log/archive_cp_5432.log'&nbsp;</div><div>archive_timeout = 300</div><div><br></div><div># 如果原来archive_mode = off , 修改后需要重启数据库,否则只需要reload配置</div><div><br></div><div># On 备库节点,新建standby, 1.删除已经存在的数据文件目录,(用于重新建立)</div><div>rm -rf /data1/pg_data</div><div># On 主库节点,同步数据文件到备库</div><div>psql -h 127.0.0.1 postgres postgres -c "select pg_start_backup(now()::text);"</div><div>rsync -acvz --exclude=pg_xlog /data1/pg_data/* 10.0.0.20::pgdata</div><div>psql -h 127.0.0.1 postgres postgres -c "select pg_stop_backup();"</div><div><br></div><div># On 备库节点,新建standby, 2.配置standby</div><div># recovery.conf</div><div>restore_command = 'pg_standby -d -s 2 -t /tmp/pgsql.trigger.5432 /data/recoverydir/pg_arch %f %p 2&gt;&gt;/var/log/pg_run_log/restore_standby_5432.log'</div><div>recovery_target_timeline = 'latest'</div><div>recovery_end_command = 'rm -f /tmp/pgsql.trigger.5432'</div><div># 新建目录</div><div>mkdir /data1/pg_data/pg_xlog</div><div>rm -f /data1/pg_data/recovery.done</div><div>chown -R postgres:postgres /data1/pg_data</div><div>chmod -R 700 /data1/pg_data</div><div># 启动standby库,进入recovery模式</div><div>pg_ctl start -D /data1/pg_data</div><div><br></div><div># 至此,standby就建立好了.</div><div><br></div><div>下面来谈谈怎么做备份 :&nbsp;</div><div><br></div><div># On 主库节点,备份数据库,一周一次,crontab: 1 3 * * 2 /usr/local/postgres/backupsh/backup_database_5432.sh &gt;&gt;/var/log/pg_run_log/backup_database_5432.log 2&gt;&amp;1</div><div>vi /usr/local/postgres/backupsh/backup_database_5432.sh</div><div>chmod 500 /usr/local/postgres/backupsh/backup_database_5432.sh</div><div>#!/bin/bash</div><div>DATE=`date +%Y%m%d`</div><div>TIME=`date +%F`</div><div>echo -e "$TIME : select pg_start_backup();\n"</div><div>psql -h 127.0.0.1 postgres postgres -c "select pg_start_backup(now()::text);"</div><div>RESULT=$?</div><div>echo -e "$TIME : select pg_start_backup(); result:$RESULT\n"</div><div>if [ $RESULT -ne 0 ]; then</div><div>exit $RESULT</div><div>fi</div><div>echo -e "$TIME : Backup Database use rsync.\n"</div><div>rsync -acvz --exclude=pg_xlog /data1/pg_data/* 10.0.0.20::pgbackup/data_backup_$DATE</div><div>RESULT=$?</div><div>echo -e "$TIME : Backup Database use rsync. result:$RESULT\n"</div><div>echo -e "$TIME : select pg_stop_backup();\n"</div><div>psql -h 127.0.0.1 postgres postgres -c "select pg_stop_backup();"</div><div>RESULT=$?</div><div>echo -e "$TIME : select pg_stop_backup(); result:$RESULT\n"</div><div>exit $RESULT</div><div><br></div><div># On 主库节点,备份归档日志,一天一次,crontab: 1 1 * * * /usr/local/postgres/backupsh/backup_archive_5432.sh &gt;&gt;/var/log/pg_run_log/backup_archive_5432.log 2&gt;&amp;1</div><div>vi /usr/local/postgres/backupsh/backup_archive_5432.sh</div><div>chmod 500 /usr/local/postgres/backupsh/backup_archive_5432.sh</div><div>#!/bin/bash</div><div>TIME=`date +%F`</div><div>echo -e "$TIME : Backup archivelog use rsync.\n"</div><div>rsync -acvz /data1/archivedir/pg_arch/* 10.0.0.20::pgbackup/arch_backup</div><div>RESULT=$?</div><div>echo -e "$TIME : Backup archivelog use rsync. result:$RESULT\n"</div><div>exit $RESULT</div><div><br></div><div># 至此,备份就做好了</div><div>下面来谈谈怎么做一个策略,定期清理历史备份.假设清理15天前的备份.</div><div><br></div><div># On 备库节点,清理超过保留时间窗口的数据,一天一次,crontab: 1 6 * * * /usr/local/postgres/backupsh/purge_backup.sh &gt;&gt;/var/log/pg_run_log/purge_backup_5432.log 2&gt;&amp;1</div><div>vi /usr/local/postgres/backupsh/purge_backup_5432.sh</div><div>chmod 500 /usr/local/postgres/backupsh/purge_backup_5432.sh</div><div>#!/bin/bash</div><div>TIME=`date +%F`</div><div>echo -e "$TIME : Delete Archivelog From Primary Host Dir.\n"</div><div>find /data/recoverydir/pg_arch/* -mtime +15 -exec rm -rf {} \;</div><div>echo -e "$TIME : Delete Archivelog From Backup Host Dir.\n"</div><div>find /data1/pg_backup/arch_backup/* -mtime +15 -exec rm -rf {} \;</div><div>echo -e "$TIME : Delete Datafile From Backup Host Dir.\n"</div><div>for i in `ls -1rt /data1/pg_backup/|grep data_backup_|head --lines=-1`</div><div>do</div><div>rm -rf /data1/pg_backup/$i</div><div>done</div><div><br></div><div># 至此,清楚历史备份也部署好了.</div><div>下面来谈谈PITR,基于时间点的恢复测试.</div><div><br></div><div># On 备库节点,数据恢复测试,数据恢复</div><div>mkdir /data1/pg_backup/data_backup_$DATE/pg_xlog</div><div>chown -R postgres:postgres /data1/pg_backup</div><div>chmod 700 /data1/pg_backup/data_backup_$DATE</div><div>rm -f /data1/pg_backup/data_backup_$DATE/recovery.done</div><div># 编辑配置文件postgresql.conf,修改监听端口与本地已经存在的端口分开.</div><div>port = 5433</div><div>archive_command = 'cp -f %p /data1/archivedir/pg_arch/%f 2&gt;&gt;/var/log/pg_run_log/archive_cp_5433.log'</div><div># 编辑配置文件,recovery.conf</div><div>restore_command = 'pg_standby -d -s 2 -t /tmp/pgsql.trigger.5433 /data/recoverydir/pg_arch %f %p 2&gt;&gt;/var/log/pg_run_log/restore_standby_5433.log'</div><div># recovery_target_timeline = 'latest'</div><div># 以下时间来自数据库select now()这种的输出,然后推算;</div><div>recovery_target_time = '2011-07-20 11:13:15.64642+02'</div><div>recovery_target_inclusive = 'true'</div><div>recovery_end_command = 'rm -f /tmp/pgsql.trigger.5433'</div><div><br></div><div># 启动备库开始恢复</div><div>pg_ctl start -D /data1/pg_backup/data_backup_$DATE</div><div># 触发激活(三选一,空文件默认smart,fast表示立刻激活,不找下一个WAL文件.smart表示自动找下一个wal文件,找到就APPLY,直到没有下一个WAL了就激活)</div><div>touch /tmp/pgsql.trigger.5433</div><div>echo "fast" &gt; /tmp/pgsql.trigger.5433</div><div>echo "smart" &gt; /tmp/pgsql.trigger.5433</div><div># On 备库节点,数据恢复测试,reindex HASH索引</div><div><br></div><div># 至此,PITR的测试结束,</div><div>下面谈谈应该监控哪些日志.</div><div><br></div><div># 监控日志文件</div><div># 主库节点</div><div>/var/log/pg_run_log/archive_cp_5432.log</div><div>/var/log/pg_run_log/backup_database_5432.log</div><div>/var/log/pg_run_log/backup_archive_5432.log</div><div># 备节点</div><div>/var/log/pg_run_log/restore_standby_5432.log</div><div>/var/log/rsync.log</div><div>/var/log/pg_run_log/purge_backup_5432.log</div><div><br></div><div>【note】</div><div>由于备份对系统的IO有一定影响，建议在执行备份脚本的时候或者脚本里面的rsync前面加上nice -n 19。这样对系统影响最小.</div><div><div>Nicenesses range from&nbsp;-20 (most favorable scheduling) to 19 (least favorable).</div></div><div><br></div><div>【补充】</div><div>其他测试点:</div><div>数据文件备份crontab脚本测试</div><div>归档文件备份crontab脚本测试</div><div>清理超过保留时间窗口的数据crontab脚本测试</div><div>时间点恢复测试,激活时smart和fast对比,是否达到一致效果</div><div>standby激活测试</div><div>存储空间测算</div><div>监控日志文件</div><div>时间线文件删掉之后是否可以做恢复,是否可以做standby等</div></div><div><br></div><div>【参考】</div><div><a rel="nofollow" href="http://www.postgresql.org/docs/8.4/static/pgstandby.html"  >http://www.postgresql.org/docs/8.4/static/pgstandby.html</a></div><div><div>pg_standby的激活模式 :&nbsp;</div><div>Smart Failover</div><div>In smart failover, the server is brought up after applying all WAL files available in the archive. This results in zero data loss, even if the standby server has fallen behind, but if there is a lot of unapplied WAL it can be a long time before the standby server becomes ready. To trigger a smart failover, create a trigger file containing the word smart, or just create it and leave it empty.</div><div><br></div><div>Fast Failover</div><div>In fast failover, the server is brought up immediately. Any WAL files in the archive that have not yet been applied will be ignored, and all transactions in those files are lost. To trigger a fast failover, create a trigger file and write the word fast into it. pg_standby can also be configured to execute a fast failover automatically if no new WAL file appears within a defined interval.</div><div><br></div><div>#恢复文件格式 ,recovery.conf example</div><div>#recovery_target_timeline = '33' &nbsp;# number or 'latest'</div><div>#recovery_target_inclusive = 'true' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 'true' or 'false'</div><div>#recovery_target_xid = '1100842'</div><div>#recovery_target_time = '2004-07-14 22:39:00 EST' # 可用select now();输出格式</div><div>#recovery_end_command = ''</div><div>#restore_command = 'cp /mnt/server/archivedir/%f %p'</div></div><div><br></div><div>【注意】</div><div><a rel="nofollow" href="http://www.postgresql.org/docs/8.4/static/continuous-archiving.html"  >http://www.postgresql.org/docs/8.4/static/continuous-archiving.html</a></div><div><h2 style="font-size: 1.2em !important; margin-top: 2ex; margin-right: 0em; margin-bottom: 1.2em; margin-left: 0em; font-weight: bold; color: rgb(102, 102, 102); font-family: verdana, sans-serif; line-height: normal;"  ><a name="CONTINUOUS-ARCHIVING-CAVEATS" rel="nofollow"  >24.3.6. Caveats</a></h2><p style="font-size: 1em; line-height: 1.5em; margin-top: 1.2em; margin-right: 0em; margin-bottom: 1.2em; margin-left: 0em; font-family: verdana, sans-serif;"  >At this writing, there are several limitations of the continuous archiving technique. These will probably be fixed in future releases:</p><p style="font-size: 1em; line-height: 1.5em; margin-top: 1.2em; margin-right: 0em; margin-bottom: 1.2em; margin-left: 0em; font-family: verdana, sans-serif;"  ></p><p style="font-size: 1em; line-height: 1.5em; margin-top: 1.2em; margin-right: 0em; margin-bottom: 1.2em; margin-left: 0em; font-family: verdana, sans-serif;"  ></p><ul style="font-size: 1em; line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em; font-family: verdana, sans-serif;"  ><li style="font-size: 1em; line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em;"  ><p style="font-size: 1em; line-height: 1.5em; margin-top: 0.2em; margin-right: 0em; margin-bottom: 1.2em; margin-left: 0em;"  >Operations on hash indexes are not presently WAL-logged, so replay will not update these indexes. The recommended workaround is to manually&nbsp;<a style="color: rgb(0, 102, 162); text-decoration: underline;" rel="nofollow" href="http://www.postgresql.org/docs/8.4/static/sql-reindex.html"  ><i>REINDEX</i></a>&nbsp;each such index after completing a recovery operation.</p></li><li style="font-size: 1em; line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em;"  ><p style="font-size: 1em; line-height: 1.5em; margin-top: 0.2em; margin-right: 0em; margin-bottom: 1.2em; margin-left: 0em;"  >If a&nbsp;<a style="color: rgb(0, 102, 162); text-decoration: underline;" rel="nofollow" href="http://www.postgresql.org/docs/8.4/static/sql-createdatabase.html"  ><i>CREATE DATABASE</i></a>&nbsp;command is executed while a base backup is being taken, and then the template database that the&nbsp;<tt>CREATE DATABASE</tt>&nbsp;copied is modified while the base backup is still in progress, it is possible that recovery will cause those modifications to be propagated into the created database as well. This is of course undesirable. To avoid this risk, it is best not to modify any template databases while taking a base backup.</p></li><li style="font-size: 1em; line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em;"  ><p style="font-size: 1em; line-height: 1.5em; margin-top: 0.2em; margin-right: 0em; margin-bottom: 1.2em; margin-left: 0em;"  ><a style="color: rgb(0, 102, 162); text-decoration: underline;" rel="nofollow" href="http://www.postgresql.org/docs/8.4/static/sql-createtablespace.html"  ><i>CREATE TABLESPACE</i></a>&nbsp;commands are WAL-logged with the literal absolute path, and will therefore be replayed as tablespace creations with the same absolute path. This might be undesirable if the log is being replayed on a different machine. It can be dangerous even if the log is being replayed on the same machine, but into a new data directory: the replay will still overwrite the contents of the original tablespace. To avoid potential gotchas of this sort, the best practice is to take a new base backup after creating or dropping tablespaces.</p></li></ul><p style="font-size: 1em; line-height: 1.5em; margin-top: 1.2em; margin-right: 0em; margin-bottom: 1.2em; margin-left: 0em; font-family: verdana, sans-serif;"  ></p><p style="font-size: 1em; line-height: 1.5em; margin-top: 1.2em; margin-right: 0em; margin-bottom: 1.2em; margin-left: 0em; font-family: verdana, sans-serif;"  >It should also be noted that the default&nbsp;<acronym>WAL&nbsp;format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the&nbsp;<a style="color: rgb(0, 102, 162); text-decoration: underline;" rel="nofollow" href="http://www.postgresql.org/docs/8.4/static/runtime-config-wal.html#GUC-FULL-PAGE-WRITES"  >full_page_writes</a>&nbsp;parameter. (Read the notes and warnings in<a style="color: rgb(0, 102, 162); text-decoration: underline;" rel="nofollow" href="http://www.postgresql.org/docs/8.4/static/wal.html"  >Chapter 28</a>&nbsp;before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when&nbsp;<tt>full_page_writes</tt>&nbsp;is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</p></div></div>
	</div>
</div>
</body>
</html>