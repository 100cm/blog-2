<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Lua function closures</h2>
	<h5 id="">2014-01-08 15:08:38&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020140824452824/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">lua的函数为数据类型之一, 也叫first-class.<wbr><div>所以可以把函数赋予给变量, 这个我在前一篇BLOG中写过, 例如</div><div>function f(x) return x*2 end</div><div>和f = function(x) return x*2 end</div><div>是一样的写法.</div><div>甚至可以把函数作为返回值, 例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >function f(x)&nbsp;</font></div><div><font size="2"   >&nbsp; return function (x) return x*2 end&nbsp;</font></div><div><font size="2"   >end</font></div><p></p></pre></div><div>这里其实返回了一个匿名函数,</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >a = f(1)</font></div><div><div><font size="2"   >&gt; a = f(1)</font></div><div><font size="2"   >&gt; = a</font></div><div><font size="2"   >function: 0x12a0ab0</font></div><div><font size="2"   >&gt; =a(1)</font></div><div><font size="2"   >2</font></div><div><font size="2"   >&gt; return a(2)</font></div><div><font size="2"   >4</font></div></div><p></p></pre></div><div>那么什么是closure呢?</div><div>我们来看一个函数 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >function newc()</font></div><div><font size="2"   >&nbsp; local i = 0 &nbsp;</font></div><div><font size="2"   >&nbsp; return function ()</font></div><div><font size="2"   >&nbsp; &nbsp; i = i+1 &nbsp;-- 非本地, 非全局, 函数中的函数可以访问它上层的本地变量, 并可以逃逸这个变量, 成为一个非本地, 非全局变量.</font></div><div><font size="2"   >&nbsp; &nbsp; return i</font></div><div><font size="2"   >&nbsp; end</font></div><div><font size="2"   >end</font></div><p></p></pre></div><div>这个函数返回一个函数, 在返回的匿名函数中, i其实是newc函数的本地变量, 对匿名函数来说, i变量非本地, 非全局.</div><div>那么把newc()的结果匿名函数赋予给一个变量后, i就变成了这个函数的一部分,&nbsp;</div><div>closure包含"函数的定义"以及"函数需要访问的非本地, 非全局变量, 这个例子是i".</div><div>我们可以理解为closure实际上包含了两部分信息, 一部分是定义区域, 一部分是函数自有的变量区域(非本地, 非全局.)</div><div>利用这种方式创建的函数, 自由变量可以用作计数器, 例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; c1 = newc()</font></div><div><font size="2"   >&gt; = c1</font></div><div><font size="2"   >function: 0x1291a70</font></div><div><font size="2"   >&gt; return &nbsp;c1() &nbsp;-- i这个自由变量在当前这个c1函数/closure内自增.</font></div><div><font size="2"   >1</font></div><div><font size="2"   >&gt; return &nbsp;c1()</font></div><div><font size="2"   >2</font></div><div><font size="2"   >&gt; return &nbsp;c1()</font></div><div><font size="2"   >3</font></div><div><font size="2"   >&gt; c2 = newc()</font></div><div><font size="2"   >&gt; = c2&nbsp;<span style="line-height: 28px;"   >&nbsp;</span><span style="line-height: 28px;"   >&nbsp;-- i这个自由变量在当前这个c2函数/closure内自增. 和c1/closure没有关系.</span></font></div><div><font size="2"   >function: 0x12a2290</font></div><div><font size="2"   >&gt; return &nbsp;c2()</font></div><div><font size="2"   >1</font></div><div><font size="2"   >&gt; return &nbsp;c2()</font></div><div><font size="2"   >2</font></div><div><font size="2"   >&gt; return &nbsp;c1()</font></div><div><font size="2"   >4</font></div><p></p></pre></div><div><br></div><div>由于函数名只是一个closure的名称, 所以可以很方便的复写. 例如</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; do&nbsp;</font></div><div><font size="2"   >&nbsp; local oldsin = math.sin &nbsp;-- 把math.sin这个函数名指向的closure赋予给本地变量oldsin. 对外就隐藏了</font></div><div><font size="2"   >&nbsp; local k = math.pi/180 &nbsp;</font></div><div><font size="2"   >&nbsp; math.sin = function(x) &nbsp; &nbsp;-- 复写math.sin</font></div><div><font size="2"   >&nbsp; &nbsp; return oldsin(x*k)</font></div><div><font size="2"   >&nbsp; end</font></div><div><font size="2"   >end</font></div><p></p></pre></div><div>那么以后调用math.sin就是新的closure了, 老的closure因为被指向为一个本地变量, 已经无法被使用了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; = oldsin(1)</font></div><div><font size="2"   >stdin:1: attempt to call global 'oldsin' (a nil value)</font></div><div><font size="2"   >stack traceback:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; stdin:1: in main chunk</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; [C]: in ?</font></div><div><font size="2"   >&gt; = math.sin(1)</font></div><div><font size="2"   >0.00030461741507571</font></div><p></p></pre></div><div>这种用法类似黑盒, 把一个closure隐藏, 对外使用新的一个closure.</div><div>还有一个例子是对文件操作加一个权限判断, 隐藏没有权限判断的io.open函数.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; do&nbsp;</font></div><div><font size="2"   >&nbsp; local oldopen = io.open &nbsp;-- 把老的io.open存储到一个本地变量, 对外隐藏.</font></div><div><font size="2"   >&nbsp; local access_ok = function (filename, mode) &nbsp;-- 权限判断函数</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;-- check access, return boolean</font></div><div><font size="2"   >&nbsp; &nbsp; end</font></div><div><font size="2"   >&nbsp; io.open = function (filename, mode) &nbsp;-- 复写io.open</font></div><div><font size="2"   >&nbsp; &nbsp; if access_ok(filename, mode) then</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; return oldopen(filename,mode)  -- 在黑盒中访问外部的本地变量oldopen, 这个新的io.open函数/closure包含了oldopen这个变量.</font></div><div><font size="2"   >&nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; return nil, "access denied"</font></div><div><font size="2"   >&nbsp; &nbsp; end</font></div><div><font size="2"   >&nbsp; end</font></div><div><font size="2"   >end</font></div><p></p></pre></div><div>-- 那么以后调用io.open时其实调用的是复写的io.open.</div><br><div>小结.</div><div>1. Lua函数或closure的一个重大功能是, 对上层函数的本地变量的可访问, 以及逃逸(逃逸这个说得明白点就是closure中包含变量信息, 同时包含定义信息).</div><div>2. 支持复写, 同时结合本地变量的逃逸, 很好的达到黑盒目的.</div></div>
	</div>
</div>
</body>
</html>