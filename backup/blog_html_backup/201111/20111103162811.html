<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">classic case: expired consume</h2>
	<h5 id="">2011-11-03 16:28:11&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201110314133817/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><span style="WHITE-SPACE: pre;"  ></span>大多数运营商对话费的做了有效期的限制。如30元话费冲到手机卡里，有效期是3个月。100元是10个月。更多的话最长可以达到18个月。  <div>可能是为了促进消费。</div>  <div><span style="WHITE-SPACE: pre;"  ></span>还有一种情况是，分了两种有效期的钱，比如1种收入来自点击广告，有效期是1个月。另一种收入来自充值，有效期是3个月。</div>  <div><span style="WHITE-SPACE: pre;"  ></span>在消费的时候，优先消费将要过期的钱。每天都有一笔钱将要过期（一个月前的）。</div>  <div><span style="WHITE-SPACE: pre;"  ></span>用户每次登陆账号的时候都要显示当前可用余额是多少（在有效期内的钱），每次点击广告增加的钱要实时的显示出来。</div>  <div><span style="WHITE-SPACE: pre;"  ></span>可能要用到pgmemcached提高效率。</div>  <div>下面是一个例子 :&nbsp;</div>  <div>用户账户表,</div>  <div>create table user_balance(userid int8,balance numeric check (balance&gt;=0),expired date,constraint pk_user_balance primary key (userid,expired));</div>  <div><br></div>  <div>充值函数,</div>  <div>  <div>create or replace function charge (i_userid int8,i_balance numeric,i_expired date) returns int as $BODY$</div>  <div>declare</div>  <div>begin</div>  <div>perform 1 from user_balance where userid=i_userid and expired=i_expired;</div>  <div>if found then</div>  <div>update user_balance set balance=balance+i_balance where userid=i_userid and expired=i_expired;</div>  <div>else</div>  <div>insert into user_balance (userid,balance,expired) values (i_userid,i_balance,i_expired);</div>  <div>end if;</div>  <div>return 0;</div>  <div>exception</div>  <div>when others then</div>  <div>return 1;</div>  <div>end;</div>  <div>$BODY$ language plpgsql;</div></div>  <div><br></div>  <div>消费函数,</div>  <div>  <div>create or replace function consume (i_userid int8,i_balance numeric) returns int as $BODY$</div>  <div>declare</div>  <div>v_balance1 numeric;</div>  <div>v_balance2 numeric;</div>  <div>v_userid int8;</div>  <div>v_expired date;</div>  <div>v_cursor1 refcursor;</div>  <div>begin</div>  <div>perform sum(balance) from user_balance where userid=i_userid and expired &gt;= current_date and balance&gt;0 having sum(balance)&gt;=i_balance;</div>  <div>if found then</div>  <div>v_balance1 = i_balance;</div>  <div>-- raise notice 'v_balance1: %',v_balance1;</div>  <div>open v_cursor1 for select userid,balance,expired from user_balance where userid=i_userid and expired &gt;= current_date and balance&gt;0 order by expired for update;</div>  <div>while v_balance1&gt;0 LOOP</div>  <div>fetch from v_cursor1 into v_userid,v_balance2,v_expired;</div>  <div>update user_balance set balance=(case when balance&lt;=v_balance1 then 0 else balance-v_balance1 end) where current of v_cursor1;</div>  <div>v_balance1=v_balance1-v_balance2;</div>  <div>-- raise notice 'v_balance1: %',v_balance1;</div>  <div>-- raise notice 'v_balance2: %',v_balance2;</div>  <div>END LOOP;</div>  <div>CLOSE v_cursor1;</div>  <div>else</div>  <div>return 1;</div>  <div>end if;</div>  <div>if v_balance1&gt;0 then</div>  <div>raise EXCEPTION 'USER: % consume failed.', user_id;</div>  <div>return 3;</div>  <div>end if;</div>  <div>return 0;</div>  <div>exception</div>  <div>when others then</div>  <div>return 2;</div>  <div>end;</div>  <div>$BODY$ language plpgsql;</div></div>  <div><br></div>  <div>这里今天是11月3号, 测试,</div>  <div>插入测试数据, 部分是过期的充值, 为了测试效果.</div>  <div>  <div>digoal=&gt; select * from charge(1,2,'2011-11-04');</div>  <div>&nbsp;charge&nbsp;</div>  <div>--------</div>  <div>&nbsp; &nbsp; &nbsp; 0</div>  <div>digoal=&gt; select * from charge(1,2,'2011-11-03');</div>  <div>&nbsp;charge&nbsp;</div>  <div>--------</div>  <div>&nbsp; &nbsp; &nbsp; 0</div>  <div>digoal=&gt; select * from charge(1,5,'2011-12-03');</div>  <div>&nbsp;charge&nbsp;</div>  <div>--------</div>  <div>&nbsp; &nbsp; &nbsp; 0</div>  <div>digoal=&gt; select * from charge(1,5,'2011-10-03');</div>  <div>&nbsp;charge&nbsp;</div>  <div>--------</div>  <div>&nbsp; &nbsp; &nbsp; 0</div>  <div>digoal=&gt; select * from charge(1,5,'2011-10-03');</div>  <div>&nbsp;charge&nbsp;</div>  <div>--------</div>  <div>&nbsp; &nbsp; &nbsp; 0</div>  <div>digoal=&gt; select * from charge(1,5,'2011-10-04');</div>  <div>&nbsp;charge&nbsp;</div>  <div>--------</div>  <div>&nbsp; &nbsp; &nbsp; 0</div>  <div>digoal=&gt; select * from charge(1,500,'2011-12-01');</div>  <div>&nbsp;charge&nbsp;</div>  <div>--------</div>  <div>&nbsp; &nbsp; &nbsp; 0</div></div>  <div>充值测试最终结果如下 :&nbsp;</div>  <div>  <div>  <div>digoal=&gt; select * from user_balance order by expired ;</div>  <div>&nbsp;userid | balance | &nbsp;expired &nbsp;&nbsp;</div>  <div>--------+---------+------------</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp;10 | 2011-10-03</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 5 | 2011-10-04</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 2 | 2011-11-03</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 2 | 2011-11-04</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; 500 | 2011-12-01</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 5 | 2011-12-03</div></div></div>  <div><br></div>  <div>消费测试 :&nbsp;</div>  <div>消费10元。</div>  <div>  <div>digoal=&gt; select * from consume(1,10);</div>  <div>&nbsp;consume&nbsp;</div>  <div>---------</div>  <div>&nbsp; &nbsp; &nbsp; &nbsp;0</div>  <div>(1 row)</div>  <div><br></div>  <div>Time: 1.791 ms</div>  <div>digoal=&gt; select * from user_balance order by expired ;</div>  <div>&nbsp;userid | balance | &nbsp;expired &nbsp;&nbsp;</div>  <div>--------+---------+------------</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp;10 | 2011-10-03</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 5 | 2011-10-04</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 0 | 2011-11-03</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 0 | 2011-11-04</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; 494 | 2011-12-01</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 5 | 2011-12-03</div>  <div>(6 rows)</div>  <div><br></div>  <div>Time: 0.349 ms</div></div>  <div>符合预期，从先过期的钱币开始消费，过期的钱币无法使用。</div>  <div><br></div>  <div>超额消费测试，符合预期，无法超额消费。</div>  <div>  <div>digoal=&gt; select * from consume(1,1000);</div>  <div>&nbsp;consume&nbsp;</div>  <div>---------</div>  <div>&nbsp; &nbsp; &nbsp; &nbsp;1</div>  <div>(1 row)</div>  <div><br></div>  <div>Time: 0.648 ms</div>  <div>digoal=&gt; select * from user_balance order by expired ;</div>  <div>&nbsp;userid | balance | &nbsp;expired &nbsp;&nbsp;</div>  <div>--------+---------+------------</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp;10 | 2011-10-03</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 5 | 2011-10-04</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 0 | 2011-11-03</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 0 | 2011-11-04</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; 494 | 2011-12-01</div>  <div>&nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 5 | 2011-12-03</div>  <div>(6 rows)</div>  <div><br></div>  <div>Time: 0.359 ms</div></div>  <div><br></div>  <div>【错误的改进】</div><div>千万不要不用FOR UPDATE。</div><div>原因在这篇BLOG指出,</div><div><a href="http://blog.163.com/digoal@126/blog/static/1638770402011102521151980/"  >http://blog.163.com/digoal@126/blog/static/1638770402011102521151980/</a></div><div><br></div>  <div>前面的消费函数每次消费都要FOR UPDATE , 以免别的进程对这些记录做DML操作.</div>  <div>下面换一种方法, 可以不需要FOR UPDATE. 提高并发性.这让我想起一种应用场景,悲观锁和乐观锁.（但是这里请别这么用)</div>  <div>create or replace function consume (i_userid int8,i_balance numeric) returns int as $BODY$</div>  <div>declare</div>  <div>v_balance1 numeric;</div>  <div>v_balance2 numeric;</div>  <div>v_userid int8;</div>  <div>v_expired date;</div>  <div>v_cursor1 refcursor;</div>  <div>begin</div>  <div>perform sum(balance) from user_balance where userid=i_userid and expired &gt;= current_date and balance&gt;0 having sum(balance)&gt;=i_balance;</div>  <div>if found then</div>  <div>v_balance1 = i_balance;</div>  <div>-- raise notice 'v_balance1: %',v_balance1;</div>  <div>open v_cursor1 for select userid,balance,expired from user_balance where userid=i_userid and expired &gt;= current_date and balance&gt;0 order by expired;</div>  <div>while v_balance1&gt;0 LOOP</div>  <div>fetch from v_cursor1 into v_userid,v_balance2,v_expired;</div>  <div>update user_balance set balance=(case when v_balance2&lt;=v_balance1 then balance-v_balance2 else balance-v_balance1 end) where current of v_cursor1;</div>  <div>v_balance1=v_balance1-v_balance2;</div>  <div>-- raise notice 'v_balance1: %',v_balance1;</div>  <div>-- raise notice 'v_balance2: %',v_balance2;</div>  <div>END LOOP;</div>  <div>CLOSE v_cursor1;</div>  <div>else</div>  <div>return 1;</div>  <div>end if;</div>  <div>if v_balance1&gt;0 then</div>  <div>raise EXCEPTION 'USER: % consume failed.', user_id;</div>  <div>return 3;</div>  <div>end if;</div>  <div>return 0;</div>  <div>exception</div>  <div>when others then</div>  <div>return 2;</div>  <div>end;</div>  <div>$BODY$ language plpgsql;</div>  <div>&nbsp;</div>  <div>[改进1]</div>  <div>怎么提高同一个用户消费的并发能力。因为都是从最快到期的记录开始更新，所以并发性就比较差了。</div>  <div>我记得PostgreSQL源码在讲FSM的部分有提到过提高块并发的处理方法。(binary tree结构存储剩余空间)</div><div><div>&nbsp; &nbsp; 4</div><div>&nbsp;4 &nbsp; &nbsp; 2</div><div>3 4 &nbsp; 0 2 &nbsp; &nbsp;&lt;- This level represents heap pages</div></div><div>(有一定的借鉴意义)</div>  <div>如果能智能选择每次更新的记录，那就不存在行锁冲突的问题了。</div>  <div>比如</div>  <div>userid , balance&nbsp;, expired </div>  <div>1 , 10 , '2011-11-04'</div>  <div>1 , 5 , '2011-11-05'</div>  <div>1 , 15 , '2011-11-06'</div>  <div>如果有两个进程同时对用户1进行扣费，其中一个扣费12元，另一个扣费10元。</div>  <div>按照前面的函数，只能等一个处理完了再处理另外一个。（行锁等待）</div>  <div>其中一个进程1</div>  <div>update user_balance set balance=balance-10 where id=1 and expired='2011-11-04';</div>  <div>update user_balance set balance=balance-2 where id=1 and expired='2011-11-05';<br>另外一个进程2</div>  <div>update user_balance set balance=balance-10 where id=1 and expired='2011-11-04';<br>等待进程1，并报错，因为balance已经=0了.-10就是负了。</div>  <div>&nbsp;</div>  <div>但是如果能智能选择的话，这个过程可以变成 : </div>  <div>其中一个进程1<br>update user_balance set balance=balance-10 where id=1 and expired='2011-11-04';<br>update user_balance set balance=balance-2 where id=1 and expired='2011-11-05';<br>另外一个进程2<br>update user_balance set balance=balance-10 where id=1 and expired='2011-11-06';<br>无须等待进程1.</div>  <div>有点缺陷是</div>  <div>balance=3 where id=1 and expired='2011-11-05'; 按照规则这笔资金应该在进程2中先消费掉。但是提高了并发能力。</div>  <div>所以有利有弊。</div>  <div>&nbsp;</div>  <div>【注意事项】</div>  <div>1. 由于每次消费都需要从记录表获取当前额度，所以开销会比较大。需要提防恶意攻击。期待9.2的INDEX ONLY SCAN.</div>  <div>2. 更新指针无法使用returning返货结果。但是可以先fetch出来老的数据，后更新这个指针。</div>  <div><br></div>  <div><br></div>  <div><br><wbr></div></div>
	</div>
</div>
</body>
</html>