<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Test PostgreSQL 9.1's group commit</h2>
	<h5 id="">2011-11-22 14:41:45&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402011102214142132/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>许久以前针对PostgreSQL在release中指出的merge duplicate fsync IO请求做了简单的测试,链接如下 :&nbsp;</div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020117243337487/"  >http://blog.163.com/digoal@126/blog/static/16387704020117243337487/</a></div><div>同时, PostgreSQL 9.1还有另一方面的性能增强, 类似merge duplicate fsync 带来的效果. 如下 :&nbsp;</div><div><p style="font-size: 12px; line-height: 18px; margin-top: 0.2em; margin-right: 0em; margin-bottom: 1.2em; margin-left: 0em; font-family: verdana, sans-serif;"  >Improve performance of&nbsp;<a style="color: rgb(0, 102, 162); " rel="nofollow" href="http://www.postgresql.org/docs/9.1/static/runtime-config-wal.html#GUC-COMMIT-SIBLINGS"  ><tt>commit_siblings</tt></a>&nbsp;(Greg Smith)</p><p style="font-size: 12px; line-height: 18px; margin-top: 0.2em; margin-right: 0em; margin-bottom: 1.2em; margin-left: 0em; font-family: verdana, sans-serif;"  >This allows the use of&nbsp;<tt>commit_siblings</tt>&nbsp;with less overhead.</p></div><div>其实与此效果类似的还有异步提交,synchronous_commit = off; 异步提交带来的效果是立竿见影的, 可惜异步提交如果数据库异常DOWN机可能丢失约10MS的事务. 而group commit和merge duplicate fsync是没有丢失问题的.</div><div><br></div><div>下面分别测试如下场景 :&nbsp;</div><div>1. 同步提交, 无分组提交</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >synchronous_commit = on</font></div><div><font size="2"  >commit_delay = 0</font></div><p></p></pre></div><div><div>2. 同步提交, 分组提交</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >synchronous_commit = on</font></div><div><font size="2"  >commit_delay = 10</font></div></div><div><font size="2"  >commit_siblings = 16 (来自前面的最高峰时的连接数, 一般可以设置为2倍CPU核数.)</font></div><p></p></pre></div></div><div><div><div>3. 异步提交, 不分组提交</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >synchronous_commit = off</font></div><div><font size="2"  >commit_delay = 0</font></div><p></p></pre></div></div><div><br></div></div><div>测试SQL分别为 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >SQL-1 :&nbsp;</font></div><div><div><font size="2"  >BEGIN;</font></div><div><font size="2"  >INSERT INTO group_commit_test (id,info) values (1,'digoal');</font></div><div><font size="2"  >COMMIT;</font></div></div><div><font size="2"  ><br></font></div><div><font size="2"  >SQL-2 :&nbsp;</font></div><div><font size="2"  >INSERT INTO group_commit_test (id,info) values (1,'digoal');</font></div><p></p></pre></div><div><br></div><div>测试SHELL :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >#!/bin/bash</font></div><div><font size="2"  >for i in 4 8 16 32 64 128 256 512</font></div><div><font size="2"  >do&nbsp;</font></div><div><font size="2"  >pgbench -M extended -c $i -f /home/postgres/group_commit_test.sql -j $i -n -r -T 120 -h 127.0.0.1 -p 1921 -U digoal digoal &gt;&gt;//home/postgres/group_commit_test.log 2&gt;&amp;1</font></div><div><font size="2"  >psql -h 127.0.0.1 -c "checkpoint;"</font></div><div><font size="2"  >done</font></div><p></p></pre></div><div><br></div><div>测试用机 :&nbsp;</div><div>DELL R610, 24GMEM, 8核, 146G SAS.</div><div><br></div><div>测试结果 :&nbsp;</div><div><div><div><img title="Test PostgreSQL 9.1s group commit - 德哥@Digoal - The Heart,The World."  alt="Test PostgreSQL 9.1s group commit - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img8.ph.126.net/OjzVW6NvaRfbsj52jDSuSw==/2738751523411793098.jpg"  ></div>&nbsp;</div><div><br></div><div>&nbsp; 按照5.8W的TPS来算，一台这样的测试机一天可以入50亿的数据。据说浙江省移动的彩信用的IBM小型机+ORACLE一天录15亿数据, 数据库负载已经比较高了。现在没有什么可比性，下次问朋友要一下对应的表结构和索引，看看PG能做到什么程度。</div><div><br></div><div>【小结】</div></div><div>1. 异步提交适合性能要求高, 但是容忍数据库异常DOWN机丢失10MS左右数据的场景。</div><div>2. 分组提交适合并发连接多, 同一时刻ACTIVE事务多并且XLOG磁盘组的IO能力已经达到极限的场景。</div><div>3. BEGIN; 和COMMIT; 带来的数据库overhead太严重了, 没有多SQL事务建议使用autocommit模式; 多SQL事务建议用函数替代。</div><div>4. 为什么异步提交的TPS能这么高, 原因就是不需要等待IO. 所以在异步提交测试的适合CPU IDLE几乎为0, 此时的瓶颈是CPU, 连接数超过CPU核数之后TPS开始下降。</div><div>5. 而同步提交的场景CPU空闲都在50%左右, 分组提交的IO等待为0, 不分组提交的IO等待为4左右。</div><div>6. 最高TPS，异步提交场景连接数等于CPU核数时达到最高点，而同步提交场景连接数为2倍CPU核数时达到TPS最高点。</div><div><br></div><div>【附件】</div><div>详细测试输出.</div><div>另外提供一下这台测试机的fsync调用测试. 我在测试中使用的是fdatasync.&nbsp;</div><div>开启了RAID卡写缓存。</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@digoal -&gt; pg_test_fsync&nbsp;</font></div><div><font size="2"  >2000 operations per test</font></div><div><font size="2"  >O_DIRECT supported on this platform for open_datasync and open_sync.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Compare file sync methods using one 8kB write:</font></div><div><font size="2"  >(in wal_sync_method preference order, except fdatasync</font></div><div><font size="2"  >is Linux's default)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; open_datasync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n/a</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fdatasync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 12839.525 ops/sec</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fsync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 12936.025 ops/sec</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fsync_writethrough &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n/a</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; open_sync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 14160.094 ops/sec</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Compare file sync methods using two 8kB writes:</font></div><div><font size="2"  >(in wal_sync_method preference order, except fdatasync</font></div><div><font size="2"  >is Linux's default)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; open_datasync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n/a</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fdatasync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8953.834 ops/sec</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fsync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8966.318 ops/sec</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; fsync_writethrough &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n/a</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; open_sync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7124.537 ops/sec</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Compare open_sync with different write sizes:</font></div><div><font size="2"  >(This is designed to compare the cost of writing 16kB</font></div><div><font size="2"  >in different write open_sync sizes.)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 16kB open_sync write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10694.901 ops/sec</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8kB open_sync writes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7130.557 ops/sec</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4kB open_sync writes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4233.333 ops/sec</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2kB open_sync writes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2324.192 ops/sec</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1kB open_sync writes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1195.532 ops/sec</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Test if fsync on non-write file descriptor is honored:</font></div><div><font size="2"  >(If the times are similar, fsync() can sync data written</font></div><div><font size="2"  >on a different descriptor.)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; write, fsync, close &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11850.447 ops/sec</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; write, close, fsync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11924.850 ops/sec</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Non-Sync'ed 8kB writes:</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 206100.577 ops/sec</font></div><p></p></pre></div><div><br></div><div>【参考】</div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020117243337487/"  >http://blog.163.com/digoal@126/blog/static/16387704020117243337487/</a></div><div><br></div><div><dt style="font-family: verdana, sans-serif; line-height: normal;"  ><pre class="prettyprint"  ><p></p><dt style="font-family: verdana, sans-serif; line-height: normal;"  ><font size="2"  ><tt>commit_delay</tt>&nbsp;(<tt>integer</tt>)</font></dt><dd style="font-family: verdana, sans-serif; line-height: normal;"  ><p style="line-height: 1.5em; margin: 1.2em 0em;"  ><font size="2"  >When the commit data for a transaction is flushed to disk, any additional commits ready at that time are also flushed out.&nbsp;<tt>commit_delay</tt>&nbsp;adds a time delay, set in microseconds, before a transaction attempts to flush the WAL buffer out to disk. A nonzero delay can allow more transactions to be committed with only one flush operation, if system load is high enough that additional transactions become ready to commit within the given interval. But the delay is just wasted if no other transactions become ready to commit. Therefore, the delay is only performed if at least&nbsp;<tt>commit_siblings</tt>&nbsp;other transactions are active at the instant that a server process has written its commit record. The default&nbsp;<tt>commit_delay</tt>&nbsp;is zero (no delay). Since all pending commit data will be written at every flush regardless of this setting, it is rare that adding delay by increasing this parameter will actually improve performance.</font></p></dd><dt style="font-family: verdana, sans-serif; line-height: normal;"  ><font size="2"  ><a name="GUC-COMMIT-SIBLINGS" rel="nofollow"  ></a><tt>commit_siblings</tt>&nbsp;(<tt>integer</tt>)</font></dt><dd style="font-family: verdana, sans-serif; line-height: normal;"  ><p style="line-height: 1.5em; margin: 1.2em 0em;"  ><font size="2"  >Minimum number of concurrent open transactions to require before performing the&nbsp;<tt>commit_delay</tt>&nbsp;delay. A larger value makes it more probable that at least one other transaction will become ready to commit during the delay interval. The default is five transactions.</font></p></dd><p></p></pre></dt></div></div>
	</div>
</div>
</body>
</html>