<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">whether pg_start_backup() force keep xlog in pg_xlog directory before execute pg_stop_backup()</h2>
	<h5 id="">2011-11-30 14:39:25&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402011103023159353/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>今天在群里讨论的一个问题 :&nbsp;</div><div>开了pg_start_backup() , 但是忘记使用pg_stop_backup()来关闭备份, XLOG会怎么样?</div><div>&nbsp; 答案是xlog不会怎么样，不会一直保持不做rotate，也就是说PG_XLOG目录不会一直膨胀。</div><div>&nbsp; 但是需要注意的是<span style="line-height: 22px;"  >, 数据库不允许同时有多个客户端执行</span><span style="line-height: 22px;"  >pg_start_backup(), 所以要想再次执行必须先用</span><span style="line-height: 22px;"  >pg_stop_backup()来停止.&nbsp;</span></div><div>&nbsp; 我对pg_start_backup()的理解是，既然开始备份了，当然要保证这个备份是可以恢复的，所以当然需要用来恢复的XLOG是要保持住的，测试结果是，不会保持。</div><div>&nbsp; 可能postgres不想在这个里面增加复杂度，他允许你在没有开启archive的时候使用pg_start_backup()，因为PG还有一个wal_keep_segments 参数是用来配置需要保持多少个segments的，所以只要KEEP足够，在备份完数据文件后再备份一下XLOG目录就可以了。</div><div>&nbsp; 另外需要提的是,pg_start_backup()开始后，会再数据文件目录创建一个标签文件，另外在XLOG里面也会生成一个标签文件。直到pg_stop_backup()被调用，标签文件被清掉。</div><div><br></div><div>一次测试结果</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"  >total 2.3G</font></div><div><font size="2"  >-rw------- 1 postgres postgres 285 Oct 24 12:59 00000001000000050000003B.00000020.backup</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:08 000000010000002400000019</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:08 00000001000000240000001A</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:08 00000001000000240000001B</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:08 00000001000000240000001C</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:08 00000001000000240000001D</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:08 00000001000000240000001E</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:09 00000001000000240000001F</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:09 000000010000002400000020</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:09 000000010000002400000021</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:09 000000010000002400000022</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:09 000000010000002400000023</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:10 000000010000002400000024</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:10 000000010000002400000025</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:10 000000010000002400000026</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:10 000000010000002400000027</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:10 000000010000002400000028</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:10 000000010000002400000029</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:10 00000001000000240000002A</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:10 00000001000000240000002B</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:10 00000001000000240000002C</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:10 00000001000000240000002D</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:12 00000001000000240000002E</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:12 00000001000000240000002F</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:12 000000010000002400000030</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:12 000000010000002400000031</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:12 000000010000002400000032</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:12 000000010000002400000033</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:12 000000010000002400000034</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:12 000000010000002400000035</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:12 000000010000002400000036</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:12 000000010000002400000037</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:12 000000010000002400000038</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:12 000000010000002400000039</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:07 00000001000000240000003A</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:07 00000001000000240000003B</font></div><div><font size="2"  >-rw------- 1 postgres postgres 64M Nov 30 14:07 00000001000000240000003C</font></div><div><font size="2"  >drwx------ 2 postgres postgres 12K Oct 25 10:42 archive_status</font></div><p></p></pre></div><div>从上面的结果看显然pg_start_backup()没有强制KEEP xlog。</div><div>start_backup执行完之后产生的第一个XLOG&nbsp;<span style="line-height: 22px;"  >00000001000000050000003B.00000020.backup 已经被rotate掉了.&nbsp;</span></div><div><br></div><div>&nbsp; 在PostgreSQL里面还分两种类型的数据文件级备份 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* do_pg_start_backup is the workhorse of the user-visible pg_start_backup()</font></div><div><font size="2"  >&nbsp;* function. It creates the necessary starting checkpoint and constructs the</font></div><div><font size="2"  >&nbsp;* backup label file.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* There are two kind of backups: exclusive and non-exclusive. An exclusive</font></div><div><font size="2"  >&nbsp;* backup is started with pg_start_backup(), and there can be only one active</font></div><div><font size="2"  >&nbsp;* at a time. The backup label file of an exclusive backup is written to</font></div><div><font size="2"  >&nbsp;* $PGDATA/backup_label, and it is removed by pg_stop_backup().</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* A non-exclusive backup is used for the streaming base backups (see</font></div><div><font size="2"  >&nbsp;* src/backend/replication/basebackup.c). The difference to exclusive backups</font></div><div><font size="2"  >&nbsp;* is that the backup label file is not written to disk. Instead, its would-be</font></div><div><font size="2"  >&nbsp;* contents are returned in *labelfile, and the caller is responsible for</font></div><div><font size="2"  >&nbsp;* including it in the backup archive as 'backup_label'. There can be many</font></div><div><font size="2"  >&nbsp;* non-exclusive backups active at the same time, and they don't conflict</font></div><div><font size="2"  >&nbsp;* with an exclusive backup either.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Every successfully started non-exclusive backup must be stopped by calling</font></div><div><font size="2"  >&nbsp;* do_pg_stop_backup() or do_pg_abort_backup().</font></div><div><font size="2"  >&nbsp;*/</font></div><p></p></pre></div><div>一种就是人机交互的模式如调用<span style="line-height: 22px;"  >pg_start_backup(). 它不允许同时有多个客户端在执行</span><span style="line-height: 22px;"  >pg_start_backup().</span></div><div><span style="line-height: 22px;"  >另一种是流复制用到的模式, 如pg_basebackup, 它允许同时使用, 就是说可以同时有多个客户端在执行pg_basebackup.</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* exclusiveBackup is true if a backup started with pg_start_backup() is</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* in progress, and nonExclusiveBackups is a counter indicating the number</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* of streaming base backups currently in progress. forcePageWrites is set</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to true when either of these is non-zero. lastBackupStart is the latest</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* checkpoint redo location used as a starting point for an online backup.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><p></p></pre></div><div><span style="line-height: 22px;"  ><br></span></div><div><span style="line-height: 22px;"  >最后人机交互的pg_start_backup()干了哪几件比较重要的事情呢?</span></div><div><span style="line-height: 22px;"  >1. &nbsp;写备份标签文件到$PGDATA, &nbsp;它包含了哪些信息呢?</span></div><div><div><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >The label file<span style="line-height: 22px;"  >&nbsp;contains the user-supplied label string (typically this would be used&nbsp;</span><span style="line-height: 22px;"  >to tell where the backup dump will be stored) and the starting time and&nbsp;</span><span style="line-height: 22px;"  >starting WAL location for the dump.</span></font></div><div><div><font size="2"  >pg_start_backup(PG_FUNCTION_ARGS)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; text &nbsp; &nbsp; &nbsp; *backupid = PG_GETARG_TEXT_P(0);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fast = PG_GETARG_BOOL(1);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *backupidstr;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;startpoint;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;startxlogstr[MAXFNAMELEN];</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; backupidstr = text_to_cstring(backupid);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; startpoint = do_pg_start_backup(backupidstr, fast, NULL);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; snprintf(startxlogstr, sizeof(startxlogstr), "%X/%X",</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;startpoint.xlogid, startpoint.xrecoff);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(cstring_to_text(startxlogstr));</font></div><div><font size="2"  >}</font></div></div><p></p></pre></div><div style="line-height: 22px;"  >2. checkpoint之前强制切换xlog文件确保checkpoint之后的wal文件不包含前面的timeline IDs. timeline我们在讲主备角色切换的时候接触过, 备库激活后timeline会自增1, 详细的解释如下 :&nbsp;</div></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Force an XLOG file switch before the checkpoint, to ensure that the WAL</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* segment the checkpoint is written to doesn't contain pages with old</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* timeline IDs. That would otherwise happen if you called</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* pg_start_backup() right after restoring from a PITR archive: the first</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* WAL segment containing the startup checkpoint has pages in the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* beginning with the old timeline ID. That can cause trouble at recovery:</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we won't have a history file covering the old timeline if pg_xlog</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* directory was not included in the base backup and the WAL archive was</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* cleared too before starting the backup.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; RequestXLogSwitch();</font></div><p></p></pre></div><div>3. 在shared memory中激活备份标记, 打开full-page WAL writes, 然后强制checkpoint, 把shared buffer里面的脏页面刷到磁盘上.</div><div>最终的目的是确保我们的数据文件备份和xlog备份可用于恢复数据库, 而不会有不一致的块(因为在拷贝的过程中BLOCK可能在变化, 可能拷贝了一个BLOCK的前半部分是改变前的, 后半部分是改变后的, 因此需要full-page WAL write来恢复这种块). 具体的解释如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >        /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Mark backup active in shared memory. &nbsp;We must do full-page WAL writes</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* during an on-line backup even if not doing so at other times, because</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* it's quite possible for the backup dump to obtain a "torn" (partially</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* written) copy of a database page if it reads the page concurrently with</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* our write to the same page. &nbsp;This can be fixed as long as the first</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* write to the page in the WAL sequence is a full-page write. Hence, we</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* turn on forcePageWrites and then force a CHECKPOINT, to ensure there</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* are no dirty pages in shared memory that might get dumped while the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* backup is in progress without having a corresponding WAL record. &nbsp;(Once</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the backup is complete, we need not force full-page writes anymore,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* since we expect that any pages not modified during the backup interval</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* must have been correctly captured by the backup.)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We must hold WALInsertLock to change the value of forcePageWrites, to</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ensure adequate interlocking against XLogInsert().</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LWLockAcquire(WALInsertLock, LW_EXCLUSIVE);</font></div><p></p></pre></div><div>那么为什么一定要在checkpoint前打开full-page WAL write呢?&nbsp;</div><div>&nbsp; checkpoint之后, BLOCK在第一次被改变的时候, 是写full page到XLOG文件的, 但是前提是full_page_writes参数=on.&nbsp;</div><div>&nbsp; 因此如果我们的参数中full_page_writes=off了. 如果仅仅是checkpoint , 就不能确保 <span style="line-height: 22px;"  >checkpoint之后, BLOCK在第一次被改变的时候, 是写full page到XLOG文件的</span>&nbsp;了.&nbsp;</div><div>&nbsp; 所以pg_start_backup()中设计了一个打开full-page WAL write的过程(XLogCtl-&gt;Insert.forcePageWrites = true;). 并且这个过程必须在checkpoint发出之前. 而且full-page write要hold住直到备份结束.</div><div>&nbsp; 从xlog的doPageWrites也可以看出在写page到WAL文件之前是需要先看看full_page_writes的值或者是<span style="line-height: 22px;"  >Insert-&gt;forcePageWrites标记的值, 来判断此次写是否要full-page write.</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Decide if we need to do full-page writes in this XLOG record: true if</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* full_page_writes is on or we have a PITR request for it. &nbsp;Since we</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* don't yet have the insert lock, forcePageWrites could change under us,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* but we'll recheck it once we have the lock.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; doPageWrites = fullPageWrites || Insert-&gt;forcePageWrites;</font></div><p></p></pre></div><div><br></div><div>【其他】</div><div>shared memory中用于XLOG控制的数据结构 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >/*----------</font></div><div><font size="2"  >&nbsp;* Shared-memory data structures for XLOG control</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* LogwrtRqst indicates a byte position that we need to write and/or fsync</font></div><div><font size="2"  >&nbsp;* the log up to (all records before that point must be written or fsynced).</font></div><div><font size="2"  >&nbsp;* LogwrtResult indicates the byte positions we have already written/fsynced.</font></div><div><font size="2"  >&nbsp;* These structs are identical but are declared separately to indicate their</font></div><div><font size="2"  >&nbsp;* slightly different functions.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* We do a lot of pushups to minimize the amount of access to lockable</font></div><div><font size="2"  >&nbsp;* shared memory values. &nbsp;There are actually three shared-memory copies of</font></div><div><font size="2"  >&nbsp;* LogwrtResult, plus one unshared copy in each backend. &nbsp;Here's how it works:</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XLogCtl-&gt;LogwrtResult is protected by info_lck</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XLogCtl-&gt;Write.LogwrtResult is protected by WALWriteLock</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XLogCtl-&gt;Insert.LogwrtResult is protected by WALInsertLock</font></div><div><font size="2"  >&nbsp;* One must hold the associated lock to read or write any of these, but</font></div><div><font size="2"  >&nbsp;* of course no lock is needed to read/write the unshared LogwrtResult.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* XLogCtl-&gt;LogwrtResult and XLogCtl-&gt;Write.LogwrtResult are both "always</font></div><div><font size="2"  >&nbsp;* right", since both are updated by a write or flush operation before</font></div><div><font size="2"  >&nbsp;* it releases WALWriteLock. &nbsp;The point of keeping XLogCtl-&gt;Write.LogwrtResult</font></div><div><font size="2"  >&nbsp;* is that it can be examined/modified by code that already holds WALWriteLock</font></div><div><font size="2"  >&nbsp;* without needing to grab info_lck as well.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* XLogCtl-&gt;Insert.LogwrtResult may lag behind the reality of the other two,</font></div><div><font size="2"  >&nbsp;* but is updated when convenient. &nbsp; &nbsp; &nbsp;Again, it exists for the convenience of</font></div><div><font size="2"  >&nbsp;* code that is already holding WALInsertLock but not the other locks.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* The unshared LogwrtResult may lag behind any or all of these, and again</font></div><div><font size="2"  >&nbsp;* is updated when convenient.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* The request bookkeeping is simpler: there is a shared XLogCtl-&gt;LogwrtRqst</font></div><div><font size="2"  >&nbsp;* (protected by info_lck), but we don't need to cache any copies of it.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Note that this all works because the request and result positions can only</font></div><div><font size="2"  >&nbsp;* advance forward, never back up, and so we can easily determine which of two</font></div><div><font size="2"  >&nbsp;* values is "more up to date".</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* info_lck is only held long enough to read/update the protected variables,</font></div></div><div><div><font size="2"  >&nbsp;* so it's a plain spinlock. &nbsp;The other locks are held longer (potentially</font></div><div><font size="2"  >&nbsp;* over I/O operations), so we use LWLocks for them. &nbsp;These locks are:</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* WALInsertLock: must be held to insert a record into the WAL buffers.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* WALWriteLock: must be held to write WAL buffers to disk (XLogWrite or</font></div><div><font size="2"  >&nbsp;* XLogFlush).</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* ControlFileLock: must be held to read/update control file or create</font></div><div><font size="2"  >&nbsp;* new log file.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* CheckpointLock: must be held to do a checkpoint or restartpoint (ensures</font></div><div><font size="2"  >&nbsp;* only one checkpointer at a time; currently, with all checkpoints done by</font></div><div><font size="2"  >&nbsp;* the bgwriter, this is just pro forma).</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;*----------</font></div><div><font size="2"  >&nbsp;*/</font></div></div><p></p></pre></div><div><br></div><div><br></div><div><br></div>【参考】<wbr><div>src/backend/access/transam/xlog.c</div><div>src/backend/replication/basebackup.c</div></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">osdba - 2012-03-22 22:33:02</h5>
				<div><span style=""  >PostgreSQL热备份的过程一般为：</span><br style=""  ><br style=""  >数据库中执行：pg_start_backup() ;然后使用操作系统的tar或 cp命令拷贝 PostgreSQL数据文件。数据库中执行：pg_stop_backup()&nbsp;&nbsp;;<br style=""  ><br style=""  ><span style=""  >有人可能会问为什么我们开始用操作系统备份数据库前需要执行pg_start_backup()?</span><br style=""  ><br style=""  ><span style=""  >实际上pg_start_backup()主要做了以下两个工作：</span><br style=""  ><br style=""  >置写日志标志为：XLogCtl-&gt;Insert.forcePageWrites = true，也就是把这个标志设置为true后，数据库会把变化的整个数据块都记录到数据库中，而不仅仅是块中记录的变化。强制发生一次checkpoint点。<br style=""  ><br style=""  ><span style=""  >为什么要强制WAL日志把整个块都写入WAL中呢？</span><br style=""  ><br style=""  ><span style=""  >想象一下： 如果你用cp命令拷贝文件时，数据库也可能会同时写这个文件，那么可能会出现，一个数据块，数据库正在写，cp命令正在读，这样有可能拷贝的数据块的前半部分是新数据，后半部分是旧数据，也就是单个数据块的数据不一致，这时，如果后面使用WAL日志把数据推到一个一致点时，如果WAL日志中只记录是块中行的变化，那么对于这种不一致块就无法恢复。但这时如果WAL日志中记录的是整个新数据块的内容，那么后面重演WAL日志时，把整个新块的内容写到这个块中后，这个块的内容就达到了一致点了，这样就没有问题了。</span><br style=""  ><br style=""  ><span style=""  >强制发生一次checkpoint，也是为了把前面的脏数据都刷到磁盘中，这样从这之后产生的日志都是记录了整个数据块，这样就可以保证恢复的正确。</span></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 osdba - 2012-03-22 22:33:02</h5>
				<div style="width:600px;">老唐的点评详细入微,已更新到<img src="http://b.bst.126.net/common/portrait/face/preview/face1.gif"  >BLOG.<br><br></div>
			</div>
	</div>
</div>
</body>
</html>