<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL add "Index Only Scan" present to explain command</h2>
	<h5 id="">2012-02-15 11:52:19&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020121151180751/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 9.1.2 还没有Index Only Scan的执行计划.</div><div>原因可能是Index 文件中没有包含tuple的版本信息, 无法完成MVCC。</div><div>未来也许会支持Index Only Scan</div><div><br></div><div>2012-1-26日, 增加了一个committed的补丁.</div><div><a style="color: rgb(0, 78, 102); font-family: verdana, sans-serif; font-size: 12px; line-height: normal; text-align: -webkit-auto; background-color: rgb(245, 245, 245); " rel="nofollow" href="https://commitfest.postgresql.org/action/patch_view?id=766"  >show Heap Fetches in EXPLAIN ANALYZE output for index-only scans</a> </div><div><br></div><div>下面在PostgreSQL 9.2devel版本中测试一下 :&nbsp;</div><div>创建测试表 :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.2devel=&gt; create table t1 (id int primary key,info text);</font></div><div><font size="2"  >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"</font></div><div><font size="2"  >CREATE TABLE</font></div><p></p></pre></div><div>插入测试数据 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.2devel=&gt; insert into t1 select generate_series(1,100000),'digoal';</font></div><div><font size="2"  >INSERT 0 100000</font></div><p></p></pre></div><div>测试SQL1 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.2devel=&gt; explain (analyze,verbose,costs,buffers) select * from t1 where id between 90000 and 91000 order by id;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >---------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Index Scan using t1_pkey on digoal.t1 &nbsp;(cost=0.00..33.67 rows=1018 width=11) (actual time=0.025..1.063 rows=1001 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;Output: id, info</font></div><div><font size="2"  >&nbsp; &nbsp;Index Cond: ((t1.id &gt;= 90000) AND (t1.id &lt;= 91000))</font></div><div><font size="2"  >&nbsp; &nbsp;Buffers: shared hit=11</font></div><div><font size="2"  >&nbsp;Total runtime: 1.880 ms</font></div><div><font size="2"  >(5 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >测试SQL2 :&nbsp;</span> </div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.2devel=&gt; explain (analyze,verbose,costs,buffers) select id from t1 where id between 90000 and 91000 order by id;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >-------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Index Only Scan using t1_pkey on digoal.t1 &nbsp;(cost=0.00..33.67 rows=1018 width=4) (actual time=0.018..1.088 rows=1001 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;Output: id</font></div><div><font size="2"  >&nbsp; &nbsp;Index Cond: ((t1.id &gt;= 90000) AND (t1.id &lt;= 91000))</font></div><div><font size="2"  >&nbsp; &nbsp;Heap Fetches: 1001</font></div><div><font size="2"  >&nbsp; &nbsp;Buffers: shared hit=11</font></div><div><font size="2"  >&nbsp;Total runtime: 1.884 ms</font></div><div><font size="2"  >(6 rows)</font></div><p></p></pre></div></div><div><br></div><div>再到PostgreSQL9.1.2中做同样的测试 :&nbsp;</div><div><span style="line-height: 22px;"  >创建测试表 :&nbsp;</span> </div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.1.2=&gt; create table t1 (id int primary key,info text);</font></div><div><font size="2"  >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"</font></div><div><font size="2"  >CREATE TABLE</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >插入测试数据 :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.1.2=&gt; insert into t1 select generate_series(1,100000),'digoal';</font></div><div><font size="2"  >INSERT 0 100000</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >测试SQL1 :&nbsp;</span> </div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.1.2=&gt; explain (analyze,verbose,costs,buffers) select * from t1 where id between 90000 and 91000 order by id;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >-----------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Index Scan using t1_pkey on sar.t1 &nbsp;(cost=0.00..33.00 rows=987 width=11) (actual time=0.012..0.388 rows=1001 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;Output: id, info</font></div><div><font size="2"  >&nbsp; &nbsp;Index Cond: ((t1.id &gt;= 90000) AND (t1.id &lt;= 91000))</font></div><div><font size="2"  >&nbsp; &nbsp;Buffers: shared hit=11</font></div><div><font size="2"  >&nbsp;Total runtime: 0.527 ms</font></div><div><font size="2"  >(5 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >测试SQL2 :&nbsp;</span> </div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.1.2=&gt; explain (analyze,verbose,costs,buffers) select id from t1 where id between 90000 and 91000 order by id;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >----------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Index Scan using t1_pkey on sar.t1 &nbsp;(cost=0.00..33.00 rows=987 width=4) (actual time=0.026..0.473 rows=1001 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;Output: id</font></div><div><font size="2"  >&nbsp; &nbsp;Index Cond: ((t1.id &gt;= 90000) AND (t1.id &lt;= 91000))</font></div><div><font size="2"  >&nbsp; &nbsp;Buffers: shared hit=11</font></div><div><font size="2"  >&nbsp;Total runtime: 0.633 ms</font></div><div><font size="2"  >(5 rows)</font></div><p></p></pre></div></div><div><br></div><div>【小结】</div><div>1. PostgreSQL9.2devel的explain 多了Index Only Scan的输出和<span style="line-height: 22px;"  >Heap Fetches的输出。</span></div><div><span style="line-height: 22px;"  >目前9.2还处于开发阶段, 从性能上看反而有下降, 可能还有其他原因。</span></div><div><span style="line-height: 22px;"  >2.&nbsp;</span><span style="line-height: 22px;"  >Index Only Scan相比Index Scan可以降低IO请求, 原因是它不再需要扫描表的page. 在IO能力足够的环境或者表已经在数据库缓存或文件系统CACHE中的情况下, 这种优势并不明显. 只有当IO成为瓶颈的时候, 它的优势就显现出来了.</span></div><div><span style="line-height: 22px;"  >3. count(*)其实也可以走Index Only Scan, 它的性能提升能有多少也取决于系统的IO能力, 表的大小, 索引的大小, 扫描的PAGE数等.</span></div><div><br></div>【参考】<div>src/backend/commands/explain.c</div><div><br><br><wbr></div></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">理查德 - 2012-04-06 11:31:42</h5>
				<div>这个测试存在以下几个问题：<div>一、缓存没有清除。index only scan就是指只访问index，不访问表。之所以能提升性能，归根结底，是因为不访问表可以大量减少磁盘访问。然而，博主在测试的时候，没有清除缓存，这样，索引覆盖的优势便体现不出来了，因为在有缓存的情况下，有没有索引覆盖都不需要访问磁盘。建议每次测试清除换存，另外注意，清除缓存包括清除数据库的缓存和操作系统的缓存。</div><div>二、字段太少。字段太少将使索引扫面的优势不明显，测试用的表，索引大约占去整个表的一边（只有两个字段），那么索引覆盖只访问索引，非索引覆盖访问全表，后者花费时间大约为前者两倍。建议增加字段数。<br><br></div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 理查德 - 2012-04-06 11:31:42</h5>
				<div style="width:600px;">本身index only scan也不会带来突破性的性能提升. 现实场景中不可能没有缓存.<div>能真正带来性能提升的应该是有个地方记录了TUPLE的条目数.<br><br></div></div>
			</div>
	</div>
</div>
</body>
</html>