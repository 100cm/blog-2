<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">how difference when update a table's column which it in TOAST or BASETABLE</h2>
	<h5 id="">2012-02-16 13:22:41&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012116115354333/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">今天一位合作商的同事找到我, 问了一个关于数据库优化的问题.<div><div>问题是这样的 :&nbsp;</div><div>&nbsp; &nbsp; 我现在在优化数据库操作, 我的一个role表结构里, 有几个比较大的text.&nbsp;</div><div>&nbsp; &nbsp; 然后我现在只修改一个role里的int字段, 你上次说整条role记录就会拷贝一次是么,</div><div>&nbsp; &nbsp; 这个拷贝是不是影响数据库的操作时间啊?</div><div><br></div><div>我们知道PostgreSQL的MVCC机制是通过行版本来做的, 每次删除操作, 是修改了TUPLE上的xmax标签.</div><div>检索TUPLE时根据（xmax的标签和当前的txid snapshot）与当前事务ID进行比较, 以及事务隔离级别 来辨别这条TUPLE对本事务是否可见。</div><div><br></div><div>例如 :&nbsp;</div><div>SESSION A :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; insert into t1 values(1,'digoal','DIGOAL');</font></div><div><font size="2"  >INSERT 0 1</font></div><p></p></pre></div><div><br></div><div>SESSION B :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select xmin,xmax,ctid,cmin,cmax,* from t1;</font></div><div><font size="2"  >&nbsp; &nbsp;xmin &nbsp; &nbsp;| xmax | ctid &nbsp;| cmin | cmax | id | info1 &nbsp;| info2 &nbsp;</font></div><div><font size="2"  >-----------+------+-------+------+------+----+--------+--------</font></div><div><font size="2"  >&nbsp;562469017 | &nbsp; &nbsp;0 | (0,1) | &nbsp; &nbsp;0 | &nbsp; &nbsp;0 | &nbsp;1 | digoal | DIGOAL</font></div><p></p></pre></div><div><br></div><div>SESSION A :</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >digoal=&gt; delete from t1 where id=1;</font></div><div><font size="2"  >DELETE 1</font></div><p></p></pre></div><div>暂时不要COMMIT。</div><div><br></div><div>SESSION B :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select xmin,xmax,ctid,cmin,cmax,* from t1;</font></div><div><font size="2"  >&nbsp; &nbsp;xmin &nbsp; &nbsp;| &nbsp; xmax &nbsp; &nbsp;| ctid &nbsp;| cmin | cmax | id | info1 &nbsp;| info2 &nbsp;</font></div><div><font size="2"  >-----------+-----------+-------+------+------+----+--------+--------</font></div><div><font size="2"  >&nbsp;562469017 | 562469018 | (0,1) | &nbsp; &nbsp;0 | &nbsp; &nbsp;0 | &nbsp;1 | digoal | DIGOAL</font></div><p></p></pre></div><div>这个时候在SESSION B看到这条记录的xmax已经改变了. 但是当前是可见的.</div><div><br></div><div>当SESSION A commit之后，SESSION B就看不到这条记录了。</div><div>但是即使commit, 这条数据还留在PAGE里面(<span style="line-height: 22px;"  >假设我没有开启AUTOVACUUM, 否则这条记录会被vacuum掉.</span>). 我们可以通过pageinspect中的函数来查看t1表的PAGE raw数据。如下，</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# &nbsp;select * from heap_page_items(get_raw_page('digoal.t1',0)); # 参数0来自ctid中的PAGE号.</font></div><div><div><font size="2"  >&nbsp;lp | lp_off | lp_flags | lp_len | &nbsp;t_xmin &nbsp; | &nbsp;t_xmax &nbsp; | t_field3 | t_ctid | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"  >----+--------+----------+--------+-----------+-----------+----------+--------+-------------+------------+--------+--------+-------</font></div><div><font size="2"  >&nbsp; 1 | &nbsp; 8144 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 42 | 562469017 | 562469018 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (0,1) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 | &nbsp; &nbsp; &nbsp; 1282 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >(1 row)</font></div></div><p></p></pre></div><div><br></div><div>UPDATE操作和DELETE操作类似，如下 :&nbsp;</div><div>SESSION A :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; truncate t1;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><font size="2"  >digoal=&gt; insert into t1 values(1,'digoal','DIGOAL');</font></div><div><font size="2"  >INSERT 0 1</font></div><p></p></pre></div><div><br></div><div>SESSION A :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >digoal=&gt; update t1 set id=2 where id=1;</font></div><div><font size="2"  >UPDATE 1</font></div><p></p></pre></div><div>先不要提交,</div><div><br></div><div><div style="line-height: 22px;"  >SESSION B :&nbsp;</div><div style="line-height: 22px;"  ><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >digoal=&gt; select xmin,xmax,ctid,cmin,cmax,* from t1;</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp;xmin &nbsp; &nbsp;| &nbsp; xmax &nbsp; &nbsp;| ctid &nbsp;| cmin | cmax | id | info1 &nbsp;| info2 &nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  >-----------+-----------+-------+------+------+----+--------+--------</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp;562469030 | 562469031 | (0,1) | &nbsp; &nbsp;0 | &nbsp; &nbsp;0 | &nbsp;1 | digoal | DIGOAL</font></div><div style="line-height: 22px;"  ><font size="2"  >(1 row)</font></div><p></p></pre></div></div></div><div><br></div><div><div style="line-height: 22px;"  >SESSION A :&nbsp;</div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; commit;&nbsp;</font></p></pre></div></div><div style="line-height: 22px;"  >A提交之后,插入了一条新的记录, 老的还在, 只是看不到了.</div><div style="line-height: 22px;"  ><br></div><div>SESSION B :</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp;<span style="line-height: 22px;"  >digoal=&gt; select xmin,xmax,ctid,cmin,cmax,* from t1;</span></font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp;xmin &nbsp; &nbsp;| xmax | ctid &nbsp;| cmin | cmax | id | info1 &nbsp;| info2 &nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  >-----------+------+-------+------+------+----+--------+--------</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp;562469031 | &nbsp; &nbsp;0 | (0,2) | &nbsp; &nbsp;0 | &nbsp; &nbsp;0 | &nbsp;2 | digoal | DIGOAL</font></div><div style="line-height: 22px;"  ></div><p></p></pre></div><div>好了罗嗦了一堆，只是要说明PostgreSQL的MVCC机制。</div></div><div>接下来进入本文重点.</div><div>那么在更新一条记录的时候, 我们看到重新插入了一条记录（携带被修改的值）进去, 有几个疑问.</div><div>1. 更新的时候插入的记录是不是整条记录, (例如一个5个字段的表, 更新了1个字段, 新插入的记录是不是完整的5个字段的记录, 还是只新插入了这个被更新的字段)</div><div>2. 当表中有TOAST相关的字段时, 是否也需要重新插入一次.</div><div><br></div><div>解答 &nbsp;:&nbsp;</div><div>1. PostgreSQL为行存储的风格, 所以是整条记录的所有字段被新插入(但是不包含未被更新的TOAST字段).</div><div>2. 当一条记录中的某变长字段的值在压缩后还超过2K（1/4块大小,近似2K），并且选择了TOAST存储, 如external或者extended时。那么这条记录中的这个字段将会使用TOAST存储。也就是说, 并不是字段选择了external或者extended就一定会存储到TOAST中。</div><div>3. 因此存储在TOAST中的值被更新时并不影响其他存储在TOAST中未被更新的内容, 但是会影响指向这条TOAST记录的基表中的记录。那条记录是需要删除(修改XMAX)并新插入的。</div><div><br></div><div>下面来看个测试 :&nbsp;</div><div>先关闭AUTOVACUUM，以便能看到测试效果。</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; create table storage_test (id int primary key,info1 text,info2 text);</font></div><div><font size="2"  >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "storage_test_pkey" for table "storage_test"</font></div><div><font size="2"  >CREATE TABLE</font></div><p></p></pre></div><div>查看存储选项, 显示extended, 表示info1和info2的字段大于2K时(近似2K bytes) 存储到TOAST中.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; \d+ storage_test</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Table "digoal.storage_test"</font></div><div><font size="2"  >&nbsp;Column | &nbsp;Type &nbsp; | Modifiers | Storage &nbsp;| Description&nbsp;</font></div><div><font size="2"  >--------+---------+-----------+----------+-------------</font></div><div><font size="2"  >&nbsp;id &nbsp; &nbsp; | integer | not null &nbsp;| plain &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;info1 &nbsp;| text &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | extended |&nbsp;</font></div><div><font size="2"  >&nbsp;info2 &nbsp;| text &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | extended |&nbsp;</font></div><div><font size="2"  >Indexes:</font></div><div><font size="2"  >&nbsp; &nbsp; "storage_test_pkey" PRIMARY KEY, btree (id)</font></div><div><font size="2"  >Has OIDs: no</font></div><p></p></pre></div><div><br></div><div>插入测试数据 :&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; insert into storage_test select generate_series(1,10000),'此处省略1W字','<span style="line-height: 22px;"  >此处省略1W字');</span></font></p></pre></div><div><span style="line-height: 22px;"  >查看storage_test表的TOAST表 :&nbsp;</span></div><div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >digoal=&gt; select reltoastrelid,reltoastidxid from pg_class where relname='storage_test';</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp;reltoastrelid | reltoastidxid&nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  >---------------+---------------</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; 19403055 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0</font></div><p></p></pre></div><div style="line-height: 22px;"  >查看<span style="line-height: 22px;"  >storage_test</span><span style="line-height: 22px;"  >表的空间大小 :&nbsp;</span></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select pg_relation_size('storage_test');</font></div><div><font size="2"  >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;688128</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >查看</span><span style="line-height: 22px;"  >storage_test</span><span style="line-height: 22px;"  >表的共计(包含索引,TOAST,FSM,VM等)空间大小 :&nbsp;</span> </div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select pg_total_relation_size('storage_test');</font></div><div><font size="2"  >&nbsp;pg_total_relation_size&nbsp;</font></div><div><font size="2"  >------------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;83771392</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>查看它的TOAST表的空间大小 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select pg_relation_size(19403055);</font></div><div><font size="2"  >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;81920000</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div></div><div>从空间大小上可以看出,info1和info2字段已经存储到TOAST中了。</div><div>不信可以看看column_size :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select pg_column_size(info1),pg_column_size(info2) from storage_test limit 1;</font></div><div><font size="2"  >&nbsp;pg_column_size | pg_column_size&nbsp;</font></div><div><font size="2"  >----------------+----------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3134 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3134</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>列长3134字节, 已经超出2K了，显然是在TOAST中存着。</div><div><br></div><div>接下来更新info1字段, 看看要不要把info2字段也拷贝一份生成一条新的记录 .&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; update storage_test set info1=info2 ;</font></div><div><font size="2"  >UPDATE 10000</font></div><div><font size="2"  >digoal=&gt; analyze storage_test ;</font></div><div><font size="2"  >ANALYZE</font></div><div><font size="2"  >digoal=&gt; select pg_relation_size(19403055);</font></div><div><font size="2"  >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 122880000</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>TOAST表变大了, 大了多少呢 ?&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select 122880000-81920000;</font></div><div><font size="2"  >&nbsp;?column?&nbsp;</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp;40960000</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>大了一半, 也就是说info1的更新不需要拷贝info2.</div><div>那么看看info1的更新会不会影响基表.&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select pg_relation_size('storage_test');</font></div><div><font size="2"  >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1368064</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>显然影响了, storage_test基表变大了,</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select 1368064-688128;</font></div><div><font size="2"  >&nbsp;?column?&nbsp;</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp; &nbsp;679936</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>除去PAGE头信息应该刚好大一倍。</div><div>也就是说每条TUPLE对应的TOAST发生更新之后，基表的TUPLE中指向TOAST的地址发生了变化，因此需要重新生成一条新的TUPLE。</div><div><br></div><div>接下来我们把info1和info2都改到基表中存储.</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=&gt; alter table storage_test alter column info1 set storage main;</font></div><div><font size="2"  >ALTER TABLE</font></div><div><font size="2"  >digoal=&gt; alter table storage_test alter column info2 set storage main;</font></div><div><font size="2"  >ALTER TABLE</font></div><div><font size="2"  >digoal=&gt; vacuum full storage_test ;</font></div><div><font size="2"  >VACUUM</font></div></div><div><font size="2"  >digoal=&gt; select reltoastrelid,reltoastidxid from pg_class where relname='storage_test';</font></div><div><div><font size="2"  >&nbsp;reltoastrelid | reltoastidxid&nbsp;</font></div><div><font size="2"  >---------------+---------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; 19403055 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=&gt; select pg_relation_size('storage_test');</font></div><div><font size="2"  >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;81920000</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=&gt; select pg_total_relation_size('storage_test');</font></div><div><font size="2"  >&nbsp;pg_total_relation_size&nbsp;</font></div><div><font size="2"  >------------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;82173952</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=&gt; select pg_relation_size(19403055);</font></div><div><font size="2"  >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0</font></div><div><font size="2"  >(1 row)</font></div></div><p></p></pre></div><div>修改完后, 已经确认数据现在都存储在基表了.</div><div><br></div><div>接下来修改info1的内容，看看要不要把info2也拷贝一份重新生成一条记录.</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=&gt; update storage_test set info1=info2 ;</font></div><div><font size="2"  >UPDATE 10000</font></div><div><font size="2"  >digoal=&gt; select pg_relation_size('storage_test');</font></div><div><font size="2"  >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 163840000</font></div><div><font size="2"  >(1 row)</font></div></div><div><div><font size="2"  >digoal=&gt; select 163840000-81920000;</font></div><div><font size="2"  >&nbsp;?column?&nbsp;</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp;81920000</font></div><div><font size="2"  >(1 row)</font></div></div><p></p></pre></div><div>storage_test变大了一倍,说明info1更新时也需要拷贝info2的内容生成一条新的记录.</div><div><br></div><div><br></div></div><div>【小结】</div><div>1. 从前面的测试可用看出当info1和info2字段都在TOAST中存储时, 更新info1不需要拷贝info2的内容. 但是需要拷贝基表中的所有字段.&nbsp;</div><div>2. 当info1和info2 都在基表中存储时，更新任何一个字段，这两个字段的内容都需要拷贝. 如 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; vacuum full storage_test ;</font></div><div><font size="2"  >VACUUM</font></div><div><font size="2"  >digoal=&gt; update storage_test set id=id ;</font></div><div><font size="2"  >UPDATE 10000</font></div><div><font size="2"  >digoal=&gt; select pg_relation_size('storage_test');</font></div><div><font size="2"  >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 163840000</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>3.&nbsp;</div><div>到底一个字段的更新在插入新数据时，会不会涉及到拷贝其他字段的内容。取决于其他字段的存储方式，在基础tuple中是一个指针，还是真实数据存储在基础TUPLE中。</div><div>在基表中存储的字段存储选项如(main)，如果字段内容大于2k, 指向这些字段的是一个指针，而不是多个指针。</div><div>例如 :&nbsp;</div><div>a表的某 tuple : column1(main)(3k),&nbsp;<span style="line-height: 22px;"  >column2(main)(3k),&nbsp;</span><span style="line-height: 22px;"  >column3(extended)(3k)</span></div><div><span style="line-height: 22px;"  >update a set column1=?;</span></div><div><span style="line-height: 22px;"  >这条SQL新插入的记录需要拷贝column2的内容,新增column1的内容, 但不需要拷贝column3的内容.</span><span style="line-height: 22px;"  >因为column3在tuple中是一个指针.</span></div><div><span style="line-height: 22px;"  >update a set column3=?;</span> </div><div><span style="line-height: 22px;"  >这条SQL新插入的记录需要新增column3的内容, 不需要拷贝column1和column2的内容. 因为column1和column2在tuple中是一个指针.</span></div><div><span style="line-height: 22px;"  ><br></span></div><div><span style="line-height: 22px;"  >当字段存储选项如(extended)，如果字段内容大于2k, 指向这些字段的是多个指针(每个字段一个)，而不是一个指针。</span></div><div><span style="line-height: 22px;"  >例如 :&nbsp;</span></div><div><div style="line-height: 22px;"  >a表的某 tuple : column1(main)(3k),&nbsp;<span style="line-height: 22px;"  >column2(extended)(3k),&nbsp;</span><span style="line-height: 22px;"  >column3(extended)(3k)</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >update a set column1=?;</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >这条SQL新插入的记录需要</span><span style="line-height: 22px;"  >新增column1的内容, 不需要拷贝column2和column3的内容. 因为column2和column3在tuple中是2个指针.</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >update a set column2=?;</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >这条SQL新插入的记录需要新增column2的内容, 不需要拷贝column1和column3的内容. 因为column1和column3在tuple中是2个指针.</span></div></div><div><br></div><div><br></div><div>4. 对于这方面的性能优化如何考虑呢 &nbsp;?&nbsp;</div><div>4.1. 如果一个表中的大部分字段(指基表中的字段)都可能被更新时, 并且不是在一条SQL中更新多个字段, 而是在多条SQL中更新不同字段.</div><div>那么考虑把这个表拆成多个表比较好.</div><div>4.2. 由于不管怎么更新都会涉及到基表的记录重新插入，所以不建议频繁分开字段更新的表字段太多。大部分字段集中在一条SQL语句中不考虑在内。</div><div><br></div><div>【参考】</div><div>以前写过几篇关于PostgreSQL PAGE DUMP的文章 :&nbsp;</div><div>Use pageinspect EXTENSION view PostgreSQL Page's raw infomation</div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020114273265960/"  >http://blog.163.com/digoal@126/blog/static/16387704020114273265960/</a> </div><div>use pg_filedump dump block contents</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201142610215685/"  >http://blog.163.com/digoal@126/blog/static/163877040201142610215685/</a> </div><div><br></div><div><br></div></div><br><wbr></div></div>
	</div>
</div>
</body>
</html>