<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">execute plan difference between Oracle and PostgreSQL's partition table</h2>
	<h5 id="">2012-02-24 16:21:39&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201212432441676/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">Oracle和PostgreSQL在分区表的执行计划方面略有不同。<div>Oracle在执行计划方面显然占据了有事。<br><div>大家来看个例子 :&nbsp;<div>以下是PostgreSQL中的测试 :&nbsp;</div><div>首先constraint_exclusion 这个参数需要配置为partition或on. 具体我就不解释了, 不了解的同学可以去翻看以下手册.&nbsp;</div><div>创建测试表 :&nbsp;<br><wbr><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table t(id int primary key);</font></div><div><font size="2"   >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "t_pkey" for table "t"</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>创建子表, 用于存储分区数据 .&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table t1(like t including all) inherits(t);</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "id" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=&gt; create table t2(like t including all) inherits(t);</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "id" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "t2_pkey" for table "t2"</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=&gt; create table t3(like t including all) inherits(t);</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "id" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "t3_pkey" for table "t3"</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=&gt; create table t4(like t including all) inherits(t);</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "id" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "t4_pkey" for table "t4"</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >添加约束, 你可以理解为ORACLE创建分区表时写的partition 子句。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; alter table t1 add constraint ck_t1_1 check(id&lt;0);</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=&gt; alter table t2 add constraint ck_t2_1 check(id&gt;=0 and id&lt;100);</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=&gt; alter table t3 add constraint ck_t3_1 check(id&gt;=100 and id&lt;200);</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=&gt; alter table t4 add constraint ck_t4_1 check(id&gt;=200);</font></div><div><font size="2"   >ALTER TABLE</font></div><p></p></pre></div></div></div></div></div><div>但是请注意, PostgreSQL的子表和子表之间的约束是没有任何关系的, 所以也可以有重叠, 即非全局约束.</div><div>这是和Oracle差别的关键所在.</div><div><br></div><div>接下来看一组执行计划 :&nbsp;</div><div>分区字段传入常量, 执行时扫描的是父表和约束对应的子表 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; explain select * from t where id=10;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Result &nbsp;(cost=0.00..8.54 rows=2 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Append &nbsp;(cost=0.00..8.54 rows=2 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using t_pkey on t &nbsp;(cost=0.00..4.27 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = 10)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using t2_pkey on t2 t &nbsp;(cost=0.00..4.27 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = 10)</font></div><p></p></pre></div><div><br></div><div>分区字段传入变量,&nbsp;<span style="line-height: 22px;"   >执行时扫描的是父表和约束对应的子表 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; prepare p_test as select * from t where id=$1;</font></div><div><font size="2"   >PREPARE</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=&gt; explain execute p_test(1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Result &nbsp;(cost=0.00..8.54 rows=2 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Append &nbsp;(cost=0.00..8.54 rows=2 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using t_pkey on t &nbsp;(cost=0.00..4.27 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = 1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using t2_pkey on t2 t &nbsp;(cost=0.00..4.27 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = 1)</font></div><div><font size="2"   >(6 rows)</font></div><p></p></pre></div><div><br></div><div>子句查询,&nbsp;<span style="line-height: 22px;"   >执行时扫描的是父表和所有子表, &nbsp;</span></div><div>注意这里使用的子查询是子表的查询, 理论上应该是扫描父表和该子表 :&nbsp;</div><div>所以这个是不优的计划, 后面我会来讲如何避免这种情况.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; explain select * from t where id=(select id from t1 limit 1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Result &nbsp;(cost=0.02..21.36 rows=5 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp;InitPlan 1 (returns $0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;-&gt; &nbsp;Limit &nbsp;(cost=0.00..0.02 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using t1_pkey on t1 &nbsp;(cost=0.00..58.25 rows=2400 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Append &nbsp;(cost=0.00..21.34 rows=5 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using t_pkey on t &nbsp;(cost=0.00..4.27 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = $0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using t1_pkey on t1 t &nbsp;(cost=0.00..4.27 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = $0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using t2_pkey on t2 t &nbsp;(cost=0.00..4.27 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = $0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using t3_pkey on t3 t &nbsp;(cost=0.00..4.27 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = $0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using t4_pkey on t4 t &nbsp;(cost=0.00..4.27 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = $0)</font></div><div><font size="2"   >(15 rows)</font></div><p></p></pre></div><div>在PostgreSQL 中, 因为没有全局约束, 所以这个子查询不能被分解成仅仅查询父表和该子表, 而是扫描了所有子表.</div><div><br></div><div><span style="line-height: 28px;"   >你可以很清晰的发现, ORACLE只扫描了单个分区, 而不是所有分区.</span></div><div><span style="line-height: 28px;"   >这是Oracle全局约束起的作用.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; create table t(id int) partition by range(id)&nbsp;</font></div><div><font size="2"   >&nbsp; 2 &nbsp;(partition t1 values less than (0),</font></div><div><font size="2"   >&nbsp; 3 &nbsp;partition t2 values less than (100),</font></div><div><font size="2"   >&nbsp; 4 &nbsp;partition t3 values less than (200),</font></div><div><font size="2"   >&nbsp; 5 &nbsp;partition t4 values less than (300));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Table created.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SQL&gt; explain plan for select * from t where id = (select id from t partition (t1) where rownum=1);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Explained.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SQL&gt; select * from table(dbms_xplan.display);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >PLAN_TABLE_OUTPUT</font></div><div><font size="2"   >--------------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >Plan hash value: 4145048349</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >--------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >| Id &nbsp;| Operation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Name | Rows &nbsp;| Bytes | Cost (%CPU)| Time &nbsp; &nbsp; | Pstart| Pstop |</font></div><div><font size="2"   >--------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >| &nbsp; 0 | SELECT STATEMENT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 1 | &nbsp; &nbsp;13 | &nbsp; &nbsp; 4 &nbsp; (0)| 00:00:01 | &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; |</font></div><div><font size="2"   >| &nbsp; 1 | &nbsp;PARTITION RANGE SINGLE &nbsp; | &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 1 | &nbsp; &nbsp;13 | &nbsp; &nbsp; 2 &nbsp; (0)| 00:00:01 | &nbsp; KEY | &nbsp; KEY |</font></div><div><font size="2"   >|* &nbsp;2 | &nbsp; TABLE ACCESS FULL &nbsp; &nbsp; &nbsp; | T &nbsp; &nbsp;| &nbsp; &nbsp; 1 | &nbsp; &nbsp;13 | &nbsp; &nbsp; 2 &nbsp; (0)| 00:00:01 | &nbsp; KEY | &nbsp; KEY |</font></div><div><font size="2"   >|* &nbsp;3 | &nbsp; &nbsp;COUNT STOPKEY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; |</font></div><div><font size="2"   >| &nbsp; 4 | &nbsp; &nbsp; PARTITION RANGE SINGLE| &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 1 | &nbsp; &nbsp;13 | &nbsp; &nbsp; 2 &nbsp; (0)| 00:00:01 | &nbsp; &nbsp; 1 | &nbsp; &nbsp; 1 |</font></div><div><font size="2"   >| &nbsp; 5 | &nbsp; &nbsp; &nbsp;TABLE ACCESS FULL &nbsp; &nbsp;| T &nbsp; &nbsp;| &nbsp; &nbsp; 1 | &nbsp; &nbsp;13 | &nbsp; &nbsp; 2 &nbsp; (0)| 00:00:01 | &nbsp; &nbsp; 1 | &nbsp; &nbsp; 1 |</font></div><div><font size="2"   >--------------------------------------------------------------------------------------------------</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Predicate Information (identified by operation id):</font></div><div><font size="2"   >---------------------------------------------------</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp;2 - filter("ID"= (SELECT /*+ */ "ID" FROM "T" "T" WHERE ROWNUM=1))</font></div><div><font size="2"   >&nbsp; &nbsp;3 - filter(ROWNUM=1)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Note</font></div><div><font size="2"   >-----</font></div><div><font size="2"   >&nbsp; &nbsp;- dynamic sampling used for this statement</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >22 rows selected.</font></div><p></p></pre></div><div><br></div><div>接下来我们来回到PostgreSQL, 看看如何规避那个不优的执行计划.</div><div>即子句的输出要化为变量, 让优化器知道这个变量的值来选择合适的分区.</div><div>这里通过创建一个函数来处理.</div><div>在实际使用中, 你可能会使用一个变量来保存子句的输出, 在传入SQL.&nbsp;</div><div>我这里通过在t4中插入几百万条记录, 通过执行时间来分辨它是否是全子表扫描还是单子表扫描, 从执行时间来看是单子表扫描.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create or replace function f_test(i_id int) returns setof int as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >v_id int;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >  select id into v_id from t1 limit 1;</font></div><div><font size="2"   >  return query select id from t where id = v_id;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=&gt; select * from f_test(1);</font></div><div><font size="2"   >&nbsp;f_test&nbsp;</font></div><div><font size="2"   >--------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;-1</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Time: 0.926 ms</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >删除t4的约束后, t4介入扫描, 时间变长.</font></div><div><font size="2"   >digoal=&gt; alter table t4 drop constraint ck_t4_1;</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >Time: 1.190 ms</font></div><div><font size="2"   >digoal=&gt; select * from f_test(1);</font></div><div><font size="2"   >&nbsp;f_test&nbsp;</font></div><div><font size="2"   >--------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;-1</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Time: 715.849 ms</font></div><p></p></pre></div></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">越狱迷失 - 2012-03-23 12:51:12</h5>
				<div>感谢德哥,把分区查询讲解的这么详细<img src="http://b.bst.126.net/common/portrait/face/preview/face1.gif"  ></div>
			</div>
	</div>
</div>
</body>
</html>