<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">max_locks_per_transaction & pg_locks entrys limit</h2>
	<h5 id="">2014-10-17 23:09:16&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402014917101714102/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>有网友问PostgreSQL存储的对象越多, 是不是性能会越差.&nbsp;</div><div>我们这么来分析, 存储的对象越多, 元数据就会越大, 例如 :&nbsp;</div><div>我用这种方法来创建一堆表,&nbsp;</div><div>为了在一个事务中创建多个表, 这里需要调整一下max_locks_per_transaction 以及(或) max connection, 满足创建多表需要的锁插槽数.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# do language plpgsql $$&nbsp;</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >tbl name;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; create table if not exists tbl (id int primary key, info text, crt_time timestamp);</font></div><div><font size="2"   >&nbsp; for i in 400000..500000 loop</font></div><div><font size="2"   >&nbsp; &nbsp; execute 'create table if not exists tbl_'||i||'(like tbl including all)';</font></div><div><font size="2"   >&nbsp; end loop;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$;</font></div><p></p></pre></div><div><br></div><div>在调用以上inline block的过程中, 我们可以看到pg_locks中不断的新增插槽, 以及新建relation的锁信息.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select count(*) from pg_locks;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;18381</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=# select count(*) from pg_locks;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;33569</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select max(relation) from pg_locks;</font></div><div><font size="2"   >&nbsp; &nbsp;max &nbsp;&nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;1185124</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select max(relation) from pg_locks;</font></div><div><font size="2"   >&nbsp; &nbsp;max &nbsp;&nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;1186892</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select max(relation) from pg_locks;</font></div><div><font size="2"   >&nbsp; &nbsp;max &nbsp;&nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;1190188</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>这就是为什么需要调整<span style="line-height: 28px;"   >max_locks_per_transaction 以及(或) max connection的原因, 为的是得到更多的lock slots.</span></div><div>The shared lock table tracks locks on max_locks_per_transaction * (max_connections + max_prepared_transactions) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time.</div><div>一些介绍可参考</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402011219116636/"   >http://blog.163.com/digoal@126/blog/static/1638770402011219116636/</a></div><wbr><div><br></div><div>例如, 我在创建50W个表后,&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# select count(*) from pg_class;</font></div><div><font size="2"   >&nbsp; count &nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;2000322</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 721.482 ms</font></div><div><font size="2"   >digoal=# select count(*) from pg_class where relname ~ '^tbl';</font></div><div><font size="2"   >&nbsp; count &nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;1000002</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 1917.384 ms</font></div></div><div><div><font size="2"   >digoal=# select count(*) from pg_class where relname ~ '^tbl' and relkind='r';</font></div><div><font size="2"   >&nbsp;count &nbsp;</font></div><div><font size="2"   >--------</font></div><div><font size="2"   >&nbsp;500001</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 2098.243 ms</font></div></div><p></p></pre></div><div>除了pg_class, 还有pg_index, pg_attribute等元表都会新增大量数据.</div><div>没有插入任何数据的情况下, 数据库已经达到了35GB.</div><div>什么情况下会读元表的, 哪些元表的操作会走索引, 哪些不会走索引呢.</div><div>可参阅 src/backend/utils/cache</div><div><br></div><div>为了提高效率, 元表的数据在数据库启动时, 会加载到内存. 但是, 如果元表的数据量太大的话, 一方面是加载变慢了, 另一方面元表的数据检索也会变慢, 即使是在内存中检索.&nbsp;</div><div>一般情况下, 元表的检索都有索引, 并且也不会频繁的检索.&nbsp;</div><div>但是也有不使用索引的情况, 例如有些应用框架会去查一些元表, 且做大量元表的管理查询. 如果你发现在表多了之后, 变慢, 可以跟踪一下是不是应用框架的问题.</div><div>如果框架没有问题, 数据库中存在多个表的话, 会带来的副作用还有可能是内存和CPU的负担变大.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select count(*) from pg_class;</font></div><div><font size="2"   >&nbsp; count &nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;2000322</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 353.556 ms</font></div><div><font size="2"   >digoal=# select count(*) from pg_attribute;</font></div><div><font size="2"   >&nbsp; count &nbsp;&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;10502467</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 1959.034 ms</font></div><p></p></pre></div><div>例如众多的表可能在使用过程中都被用到, 那么需要更多的内存来存储plan cache. 特别是并发大, 长连接的话, 会长期占用CACHE.&nbsp;</div><div>CPU的负担则可能是由于父子表带来的, PLAN开销, 扫描开销都会变大.</div><div>如果不使用父子表的话, 只是单表的操作, 理论上没有太大影响.</div><div>测试系统中有50W个表的情况下的单表操作性能.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres@db-172-16-3-221-&gt; psql</font></div><div><font size="2"   >psql (9.3.5)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# create or replace function f_tbl(v_id int) returns void as $$</font></div><div><font size="2"   >digoal$# declare</font></div><div><font size="2"   >digoal$# begin</font></div><div><font size="2"   >digoal$# &nbsp; update tbl set info='test' where id=v_id;</font></div><div><font size="2"   >digoal$# &nbsp; if not found then</font></div><div><font size="2"   >digoal$# &nbsp; &nbsp; insert into tbl values(v_id,'test');</font></div><div><font size="2"   >digoal$# &nbsp; end if;</font></div><div><font size="2"   >digoal$# exception when others then</font></div><div><font size="2"   >digoal$# &nbsp; return;</font></div><div><font size="2"   >digoal$# end;</font></div><div><font size="2"   >digoal$# $$ language plpgsql strict;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><div><font size="2"   >digoal=# select f_tbl(1);</font></div><div><font size="2"   >&nbsp;f_tbl&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select f_tbl(1);</font></div><div><font size="2"   >&nbsp;f_tbl&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select * from tbl;</font></div><div><font size="2"   >&nbsp;id | info | crt_time&nbsp;</font></div><div><font size="2"   >----+------+----------</font></div><div><font size="2"   >&nbsp; 1 | test |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres@db-172-16-3-221-&gt; vi test.sql</font></div><div><font size="2"   >\setrandom id 1 5000000</font></div><div><font size="2"   >select f_tbl(:id);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres@db-172-16-3-221-&gt; pgbench -n -r -f ./test.sql -c 8 -j 4 -T 30</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: simple</font></div><div><font size="2"   >number of clients: 8</font></div><div><font size="2"   >number of threads: 4</font></div><div><font size="2"   >duration: 30 s</font></div><div><font size="2"   >number of transactions actually processed: 1176626</font></div><div><font size="2"   >tps = 39220.499301 (including connections establishing)</font></div><div><font size="2"   >tps = 39231.529469 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.002908 &nbsp; &nbsp; &nbsp; &nbsp;\setrandom id 1 5000000</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.199018 &nbsp; &nbsp; &nbsp; &nbsp;select f_tbl(:id);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres@db-172-16-3-221-&gt; psql</font></div><div><font size="2"   >psql (9.3.5)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select count(*) from tbl;</font></div><div><font size="2"   >&nbsp; count &nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;1048010</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div><br></div><div>测试在数据库中只有1个表的情况下<span style="line-height: 28px;"   >的单表操作性能.</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# \c postgres</font></div><div><font size="2"   >You are now connected to database "postgres" as user "postgres".</font></div><div><font size="2"   >postgres=# drop database digoal;</font></div></div><div><div><font size="2"   >postgres=# create database digoal;</font></div><div><font size="2"   >CREATE DATABASE</font></div></div><div><div><font size="2"   >postgres=# \c digoal</font></div><div><font size="2"   >You are now connected to database "digoal" as user "postgres".</font></div></div><div><div style="line-height: 28px;"   ><font size="2"   >digoal=# create table tbl(id int primary key, info text, crt_time timestamp);</font></div><div style="line-height: 28px;"   ><font size="2"   >CREATE TABLE</font></div></div><div><div><font size="2"   >digoal=# create or replace function f_tbl(v_id int) returns void as $$</font></div><div><font size="2"   >digoal$# declare &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >digoal$# begin &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >digoal$# &nbsp; update tbl set info='test' where id=v_id; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >digoal$# &nbsp; if not found then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >digoal$# &nbsp; &nbsp; insert into tbl values(v_id,'test'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >digoal$# &nbsp; end if; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >digoal$# exception when others then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >digoal$# &nbsp; return; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >digoal$# end; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >digoal$# $$ language plpgsql strict; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >CREATE FUNCTION</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres@db-172-16-3-221-&gt; pgbench -n -r -f ./test.sql -c 8 -j 4 -T 30</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: simple</font></div><div><font size="2"   >number of clients: 8</font></div><div><font size="2"   >number of threads: 4</font></div><div><font size="2"   >duration: 30 s</font></div><div><font size="2"   >number of transactions actually processed: 1191138</font></div><div><font size="2"   >tps = 39704.058701 (including connections establishing)</font></div><div><font size="2"   >tps = 39714.073461 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.002761 &nbsp; &nbsp; &nbsp; &nbsp;\setrandom id 1 5000000</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.196848 &nbsp; &nbsp; &nbsp; &nbsp;select f_tbl(:id);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# select count(*) from tbl;</font></div><div><font size="2"   >&nbsp; count &nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;1060031</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >可以看到没有性能差别.</span></div><div><br></div>[参考]<div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402011219116636/"   >http://blog.163.com/digoal@126/blog/static/1638770402011219116636/</a></div><div>2.&nbsp;src/backend/storage/ipc/shmem.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* ShmemAlloc -- allocate max-aligned chunk from shared memory</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Assumes ShmemLock and ShmemSegHdr are initialized.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Returns: real pointer to memory or NULL if we are out</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;of space. &nbsp;Has to return a real pointer in order</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;to be compatible with malloc().</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void *</font></div><div><font size="2"   >ShmemAlloc(Size size)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;newStart;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Size &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;newFree;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; void &nbsp; &nbsp; &nbsp; *newSpace;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* use volatile pointer to prevent code rearrangement */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; volatile PGShmemHeader *shmemseghdr = ShmemSegHdr;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ensure all space is adequately aligned.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; size = MAXALIGN(size);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(shmemseghdr != NULL);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(ShmemLock);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; newStart = shmemseghdr-&gt;freeoffset;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* extra alignment for large requests, since they are probably buffers */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (size &gt;= BLCKSZ)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newStart = BUFFERALIGN(newStart);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; newFree = newStart + size;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (newFree &lt;= shmemseghdr-&gt;totalsize)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newSpace = (void *) ((char *) ShmemBase + newStart);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shmemseghdr-&gt;freeoffset = newFree;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newSpace = NULL;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(ShmemLock);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!newSpace)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_OUT_OF_MEMORY),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("out of shared memory")));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return newSpace;</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>3. src/backend/storage/lmgr/lock.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* LockAcquireExtended - allows us to specify additional options</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* reportMemoryError specifies whether a lock request that fills the</font></div><div><font size="2"   >&nbsp;* lock table should generate an ERROR or not. This allows a priority</font></div><div><font size="2"   >&nbsp;* caller to note that the lock table is full and then begin taking</font></div><div><font size="2"   >&nbsp;* extreme action to reduce the number of other lock holders before</font></div><div><font size="2"   >&nbsp;* retrying the action.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >LockAcquireResult</font></div><div><font size="2"   >LockAcquireExtended(const LOCKTAG *locktag,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool sessionLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool dontWait,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool reportMemoryError)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >....</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If this lock could potentially have been taken via the fast-path by</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* some other backend, we must (temporarily) disable further use of the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* fast-path for this lock tag, and migrate any locks already taken via</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* this method to the main lock table.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (ConflictsWithRelationFastPath(locktag, lockmode))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fasthashcode = FastPathStrongLockHashPartition(hashcode);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BeginStrongLockAcquire(locallock, fasthashcode);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!FastPathTransferRelationLocks(lockMethodTable, locktag,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hashcode))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AbortStrongLockAcquire();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (reportMemoryError)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_OUT_OF_MEMORY),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("out of shared memory"),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("You might need to increase max_locks_per_transaction.")));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return LOCKACQUIRE_NOT_AVAIL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >......</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Find or create lock and proclock entries with this tag</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: if the locallock object already existed, it might have a pointer</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to the lock already ... but we should not assume that that pointer is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* valid, since a lock object with zero hold and request counts can go</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* away anytime. &nbsp;So we have to use SetupLockInTable() to recompute the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* lock and proclock pointers, even if they're already set.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; proclock = SetupLockInTable(lockMethodTable, MyProc, locktag,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashcode, lockmode);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!proclock)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AbortStrongLockAcquire();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(partitionLock);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (reportMemoryError)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_OUT_OF_MEMORY),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("out of shared memory"),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("You might need to increase max_locks_per_transaction.")));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return LOCKACQUIRE_NOT_AVAIL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div><div><br></div><div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="max_locks_per_transaction  pg_locks entrys limit - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a><br></div></div>
	</div>
</div>
</body>
</html>