<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Compare Oracle's & PostgreSQL's Partition Table write performance</h2>
	<h5 id="">2011-03-30 9:02:13&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201123084853271/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">之前写过一篇关于PostgreSQL分区表优化的文章，<br><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402011210114036419/"  >http://blog.163.com/digoal@126/blog/static/1638770402011210114036419/</a><br>PostgreSQL的对于应用透明的分区表需要依赖RULE或TRIGGER来实现，应用-awareness的除外。因此在数据库端做分区需要消耗大量的CPU资源。<br>那么ORACLE的分区表是不是也要消耗大量CPU资源呢？<br>下面来简单的测试一下：<br>ORACLE：<br><pre class="prettyprint"  ><p><font size="2"  >分区表<br>create table tbl_user(id int,firstname varchar2(64),lastname varchar2(64),corp varchar2(64),age int,primary key (id)) partition by range ( id ) (<br>partition p_1 values less than (-14000001),<br>partition p_2 values less than (-13000001),<br>partition p_3 values less than (-12000001),<br>partition p_4 values less than (-11000001),<br>partition p_5 values less than (-10000001),<br>partition p_6 values less than (-9000001),<br>partition p_7 values less than (-8000001),<br>partition p_8 values less than (-7000001),<br>partition p_9 values less than (-6000001),<br>partition p_10 values less than (-5000001),<br>partition p_11 values less than (-4000001),<br>partition p_12 values less than (-3000001),<br>partition p_13 values less than (-2000001),<br>partition p_14 values less than (-1000001),<br>partition p_15 values less than (-1),<br>partition p_16 values less than (1000001)<br>);<br>SQL&gt; insert into tbl_user(id,firstname,lastname,corp,age) select level,'zhou','digoal','sky-mobi',27 from dual connect by level &lt;1000001;<br>1000000 rows created.<br>Elapsed: 00:00:04.71<br>SQL&gt; commit;<br>Elapsed: 00:00:00.02<br>SQL&gt; select count(*) from tbl_user partition (p_16);<br>&nbsp; COUNT(*)<br>----------<br>&nbsp;&nbsp; 1000000<br>SQL&gt; drop table tbl_user;<br>Elapsed: 00:00:36.76<br>插入耗时 : 4730ms<br>单表<br>SQL&gt; create table tbl_user (id int,firstname varchar2(64),lastname varchar2(64),corp varchar2(64),age int,primary key (id));<br> Elapsed: 00:00:00.03<br> SQL&gt; insert into tbl_user(id,firstname,lastname,corp,age) select  level,'zhou','digoal','sky-mobi',27 from dual connect by level  &lt;1000001;<br> 1000000 rows created.<br> Elapsed: 00:00:04.43<br> SQL&gt; commit;<br> Elapsed: 00:00:00.02<br> SQL&gt; drop table tbl_user;<br> Elapsed: 00:00:33.44<br>插入耗时 : 4450ms</font></p></pre><br>PostgreSQL : <br><p></p><pre class="prettyprint"  ><p></p><p><font size="2"  >分区表<br>create table tbl_user (id int,firstname varchar(64),lastname varchar(64),corp varchar(64) ,age int,primary key (id));<br><br>CREATE OR REPLACE FUNCTION digoal.f_create_table(i_min integer, i_max integer)<br>&nbsp;RETURNS void<br>&nbsp;LANGUAGE plpgsql<br>AS $function$<br>declare<br>begin<br>for i in i_min..i_max loop<br>execute 'create table tbl_user_'||i||' (like tbl_user including constraints including defaults including indexes) inherits (tbl_user);';<br>end loop;<br>return;<br>end;<br>$function$;<br><br>select * from f_create_table(0,15);<br><br>CREATE OR REPLACE FUNCTION tbl_user_insert_trigger()<br>RETURNS TRIGGER AS $$<br>BEGIN<br>&nbsp;&nbsp;&nbsp; IF&nbsp;&nbsp;&nbsp; ( NEW.id &lt; -14000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_0 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -13000001 and NEW.id &gt;= -14000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_1 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -12000001 and NEW.id &gt;= -13000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_2 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -11000001 and NEW.id &gt;= -12000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_3 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -10000001 and NEW.id &gt;= -11000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_4 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -9000001 and NEW.id &gt;= -10000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_5 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -8000001 and NEW.id &gt;= -9000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_6 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -7000001 and NEW.id &gt;= -8000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_7 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -6000001 and NEW.id &gt;= -7000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_8 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -5000001 and NEW.id &gt;= -6000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_9 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -4000001 and NEW.id &gt;= -5000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_10 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -3000001 and NEW.id &gt;= -4000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_11 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -2000001 and NEW.id &gt;= -3000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_12 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -1000001 and NEW.id &gt;= -2000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_13 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; -1 and NEW.id &gt;= -1000001 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_14 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSIF ( NEW.id &lt; 1000001 and NEW.id &gt;= -1 ) THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO tbl_user_15 VALUES (NEW.*);<br>&nbsp;&nbsp;&nbsp; ELSE<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RAISE EXCEPTION 'ID out of range.&nbsp; Please fix the tbl_user_insert_trigger() function!';<br>&nbsp;&nbsp;&nbsp; END IF;<br>&nbsp;&nbsp;&nbsp; RETURN NULL;<br>END;<br>$$<br>LANGUAGE plpgsql;<br><br>CREATE TRIGGER insert_tbl_user_trigger<br>&nbsp;&nbsp;&nbsp; BEFORE INSERT ON tbl_user<br>&nbsp;&nbsp;&nbsp; FOR EACH ROW EXECUTE PROCEDURE tbl_user_insert_trigger();<br><br>digoal=&gt; insert into tbl_user select generate_series(1,1000000),'zhou','digoal','sky-mobi',27;<br>INSERT 0 0<br>Time: 30157.443 ms<br>digoal=&gt; select count(*) from tbl_user_15;<br>&nbsp; count&nbsp; <br>---------<br>&nbsp;1000000<br>digoal=&gt; insert into tbl_user select generate_series(-15000001,-14000000),'zhou','digoal','sky-mobi',27;<br>INSERT 0 0<br>Time: 21707.555 ms<br>digoal=&gt; select count(*) from tbl_user_0;<br> &nbsp; count&nbsp; <br> ---------<br> &nbsp;1000000<br> 插入耗时 : 30157ms</font></p><font size="2"  >PostgreSQL分区表的插入性能完全取决于触发器的开销，你会发现第一次判断跳出和最后一次判断跳出相差了30157-21707=8450ms。<br><br>单表 <br>digoal=&gt; insert into tbl_user_info_single select generate_series(-15000001,-14000000),'zhou','digoal','sky-mobi',27;<br>INSERT 0 1000002<br>Time: 1469.540 ms<br>插入耗时 1469ms</font><p></p></pre><br>分区表比较:<br><pre class="prettyprint"  ><p><font size="2"  >oracle insert 100W 耗时 4730ms<br>postgresql insert 100W 耗时 30157ms</font></p></pre>单表比较:<br><pre class="prettyprint"  ><p><font size="2"  >oracle insert 100W 耗时 4450ms<br> postgresql insert 100W 耗时 1469ms</font></p></pre>从以上对比可以看出，如果要做应用透明的分区，PostgreSQL不如Oracle。<div>如果做application-awareness的分区，也就是让应用来处理分区的代码，PostgreSQL的性能好过Oracle。</div><div>在做PostgreSQL开发是开发人员需要认识到这点。<br></div></div>
	</div>
</div>
</body>
</html>