<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">TOAST,The Oversized-Attribute Storage Technique</h2>
	<h5 id="">2011-03-29 11:30:37&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201122910531988/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">toast直接翻译的话就是切片面包(<span>sliced bread</span>)的意思，PostgreSQL中TOAST是一个缩写，全称是The Oversized-Attribute Storage Technique，为什么会有OVERSIZED-ATTRIBUTE呢？原因很简单，因为在PostgreSQL,一条记录不能跨PAGE存储，跨越PAGE的话必须使用TOAST（即unaligned,与原表分开存储）存储。TOAST表不能独立创建，只有当普通表包含了main,extended或external存储格式的字段时，系统会自动创建一个和普通表关联的TOAST表。当一条记录(tuple)在存储时(如果压缩的话算压缩后的大小)大于TOAST_TUPLE_THRESHOLD(通常是2kB)这个值时，会存储到TOAST表。而此时在普通表的该字段处包含了一个指向TOAST的tableoid和chunk_id的数据，从而能够找到该字段的记录。<br>TOAST和普通的TABLE存储不太一样，TOAST表一般包含如下字段 : <br><pre class="prettyprint"   ><p><font size="2"   >&nbsp;tableoid&nbsp; -- TOAST表的OID<br>&nbsp;cmax<br>&nbsp;xmax<br>&nbsp;cmin<br>&nbsp;xmin<br>&nbsp;ctid<br>&nbsp;chunk_id&nbsp; -- 普通表通过TOAST pointer把一个被TOAST的列关联到这里<br>&nbsp;chunk_seq -- 同一个chunk_id如果大于<tt>TOAST_MAX_CHUNK_SIZE，将被切片存储。这里存储切片后的序号。</tt><br>&nbsp;chunk_data -- 真实的数据</font></p></pre>chunk_id + chunk_seq = primary key<br><br>并不是所有的字段都可以使用TOAST来存储，在PostgreSQL中字段(field)类型有定长的如int4,int8等,也有变长的字段类型如varchar,text等，变长的数据类型最大可以存储1GB的数据，这个可以从PostgreSQL的源代码得到证实，变长字段最多可以选择使用32BIT的列头,预留2BIT作为FLAG，还有30BIT存储字段长度2^30刚好等于1GB。<br>具体的代码后面会有解释。下面来看一下存储格式。<br><br>对于定长的字段类型，存储格式如下：<br><ul><li><p>      <font size="2"   ><tt>PLAIN</tt> prevents either  compression or       out-of-line storage; furthermore it disables use of  single-byte headers       for varlena types.       This is the only  possible strategy for       columns of non-<acronym>TOAST-able data types.      </font></p></li></ul>对于变长的字段类型，除了可以使用PLAIN格式，还可以使用如下存储格式：<br><ul><li><p>      <font size="2"   ><tt>EXTENDED</tt> allows both compression and out-of-line       storage.  This is the default for most <acronym>TOAST-able data types.       Compression will be attempted first, then out-of-line storage if       the row is still too big.      </font></p></li><li><p>      <font size="2"   ><tt>EXTERNAL</tt> allows out-of-line storage but not       compression.  Use of <tt>EXTERNAL</tt> will       make substring operations on wide <tt>text</tt> and       <tt>bytea</tt>  columns faster (at the penalty of increased storage       space)  because these operations are optimized to fetch only the       required  parts of the out-of-line value when it is not compressed.      </font></p></li><li><p>      <font size="2"   ><tt>MAIN</tt>  allows compression but not out-of-line       storage.  (Actually,  out-of-line storage will still be performed       for such columns, but  only as a last resort when there is no other       way to make the row  small enough to fit on a page.)      </font></p></li></ul><br>例如我们来创建一个测试表：<br>根据前面的介绍，TOAST表只在有变长字段，并且存储为main,extended或external时才会创建。<br><pre class="prettyprint"   ><p><font size="2"   >digoal=&gt; create table tbl_user (id int);&nbsp; -- 这样的表是没有TOAST的。<br>digoal=&gt; select relname,reltoastrelid from pg_class where relname='tbl_user';<br>&nbsp;relname&nbsp; | reltoastrelid <br>----------+---------------<br>&nbsp;tbl_user |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</font></p></pre>原因很简单，定长类型以PLAIN存储。<br>当其中有一个字段存储格式为main时，系统字段创建了一个OID=2066068的TOAST表。<br><pre class="prettyprint"   ><p><font size="2"   >digoal=&gt; \d+ tbl_user<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table "digoal.tbl_user"<br>&nbsp;Column |&nbsp; Type&nbsp;&nbsp; | Modifiers | Storage | Description <br>--------+---------+-----------+---------+-------------<br>&nbsp;id&nbsp;&nbsp;&nbsp;&nbsp; | integer |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | plain&nbsp;&nbsp; | <br>digoal=&gt; create table tbl_user (id numeric);<br>digoal=&gt; \d+ tbl_user<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table "digoal.tbl_user"<br>&nbsp;Column |&nbsp; Type&nbsp;&nbsp; | Modifiers | Storage | Description <br>--------+---------+-----------+---------+-------------<br>&nbsp;id&nbsp;&nbsp;&nbsp;&nbsp; | numeric |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | main&nbsp;&nbsp;&nbsp; | <br>digoal=&gt; select relname,reltoastrelid from pg_class where relname='tbl_user';<br>&nbsp;relname&nbsp; | reltoastrelid <br>----------+---------------<br>&nbsp;tbl_user |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2066068</font></p></pre><br>如何查找关联的TOAST表？<br>这个前面已经介绍了。根据reltoastrelid 就可以关联到toast表.<br><pre class="prettyprint"   ><p><font size="2"   >digoal=&gt; select relname from pg_class where oid=2066068;<br>&nbsp;&nbsp;&nbsp;&nbsp; relname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>------------------<br>&nbsp;pg_toast_2066065</font></p></pre><br>如何获得字段大小？<br><pre class="prettyprint"   ><p><font size="2"   >digoal=&gt; create table tbl_article (id int,author name,title varchar(256),content text);<br>digoal=&gt; \d+ tbl_article <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table "digoal.tbl_article"<br>&nbsp;Column&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Modifiers | Storage&nbsp; | Description <br>---------+------------------------+-----------+----------+-------------<br>&nbsp;id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | plain&nbsp;&nbsp;&nbsp; | <br>&nbsp;author&nbsp; | name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | plain&nbsp;&nbsp;&nbsp; | <br>&nbsp;title&nbsp;&nbsp; | character varying(256) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | extended | <br>&nbsp;content | text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | extended | <br>digoal=&gt; select relname,reltoastrelid from pg_class where relname='tbl_article';<br>&nbsp;&nbsp; relname&nbsp;&nbsp; | reltoastrelid <br>-------------+---------------<br>&nbsp;tbl_article |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2066074</font></p></pre>下面来插入一条测试记录 : <br><pre class="prettyprint"   ><p><font size="2"   >insert into tbl_article (id,author,title,content) values (1,'digoal.zhou','test','51.2. Index Access Method FunctionsThe index construction and maintenance functions that an index access method must provide are:IndexBuildResult *ambuild (Relation heapRelation,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Relation indexRelation,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexInfo *indexInfo);Build a new index. The index relation has been physically created, but is empty. It must be filled in with whatever fixed data the access method requires, plus entries for all tuples already existing in the table. Ordinarily the ambuild function will call IndexBuildHeapScan() to scan the table for existing tuples and compute the keys that need to be inserted into the index. The function must return a pallocd struct containing statistics about the new index.boolaminsert (Relation indexRelation,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Datum *values,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool *isnull,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ItemPointer heap_tid,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Relation heapRelation,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexUniqueCheck checkUnique);Insert a new tuple into an existing index. The values and isnull arrays give the key values to be indexed, and heap_tid is the TID to be indexed. If the access method supports unique indexes (its pg_am.amcanunique flag is true) then checkUnique indicates the type of uniqueness check to perform. This varies depending on whether the unique constraint is deferrable; see Section 51.5 for details. Normally the access method only needs the heapRelation parameter when performing uniqueness checking (since then it will have to look into the heap to verify tuple liveness).The functions Boolean result value is significant only when checkUnique is UNIQUE_CHECK_PARTIAL. In this case a TRUE result means the new entry is known unique, whereas FALSE means it might be non-unique (and a deferred uniqueness check must be scheduled). For other cases a constant FALSE result is recommended.Some indexes might not index all tuples. If the tuple is not to be indexed, aminsert should just return without doing anything.IndexBulkDeleteResult *ambulkdelete (IndexVacuumInfo *info,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexBulkDeleteResult *stats,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexBulkDeleteCallback callback,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *callback_state);Delete tuple(s) from the index. This is a "bulk delete" operation that is intended to be implemented by scanning the whole index and checking each entry to see if it should be deleted. The passed-in callback function must be called, in the style callback(TID, callback_state) returns bool, to determine whether any particular index entry, as identified by its referenced TID, is to be deleted. Must return either NULL or a pallocd struct containing statistics about the effects of the deletion operation. It is OK to return NULL if no information needs to be passed on to amvacuumcleanup.Because of limited maintenance_work_mem, ambulkdelete might need to be called more than once when many tuples are to be deleted. The stats argument is the result of the previous call for this index (it is NULL for the first call within a VACUUM operation). This allows the AM to accumulate statistics across the whole operation. Typically, ambulkdelete will modify and return the same struct if the passed stats is not null.IndexBulkDeleteResult *amvacuumcleanup (IndexVacuumInfo *info,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexBulkDeleteResult *stats);Clean up after a VACUUM operation (zero or more ambulkdelete calls). This does not have to do anything beyond returning index statistics, but it might perform bulk cleanup such as reclaiming empty index pages. stats is whatever the last ambulkdelete call returned, or NULL if ambulkdelete was not called because no tuples needed to be deleted. If the result is not NULL it must be a pallocd struct. The statistics it contains will be used to update pg_class, and will be reported by VACUUM if VERBOSE is given. It is OK to return NULL if the index was not changed at all during the VACUUM operation, but otherwise correct stats should be returned.As of PostgreSQL 8.4, amvacuumcleanup will also be called at completion of an ANALYZE operation. In this case stats is always NULL and any return value will be ignored. This case can be distinguished by checking info-&gt;analyze_only. It is recommended that the access method do nothing except post-insert cleanup in such a call, and that only in an autovacuum worker process.voidamcostestimate (PlannerInfo *root,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexOptInfo *index,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List *indexQuals,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RelOptInfo *outer_rel,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cost *indexStartupCost,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cost *indexTotalCost,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Selectivity *indexSelectivity,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double *indexCorrelation);Estimate the costs of an index scan. This function is described fully in Section 51.6, below.bytea *amoptions (ArrayType *reloptions,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool validate);');</font></p></pre><br><pre class="prettyprint"   ><p><font size="2"   >digoal=&gt; select oid,relname,reltoastrelid from pg_class where relname='tbl_article';<br>&nbsp;&nbsp; oid&nbsp;&nbsp; |&nbsp;&nbsp; relname&nbsp;&nbsp; | reltoastrelid <br>---------+-------------+---------------<br>&nbsp;2066071 | tbl_article |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2066074<br>digoal=&gt; select pg_relation_size(2066071);<br>&nbsp;pg_relation_size <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192<br>digoal=&gt; select pg_relation_size(2066074);<br>&nbsp;pg_relation_size <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192</font></p></pre>注意到，此时已经使用了TOAST，下面来从COLUMN_SIZE来证实一下（2485&gt;TOAST_TUPLE_THRESHOLD 2KB）<br><pre class="prettyprint"   ><p><font size="2"   >digoal=&gt; select pg_column_size(id),pg_column_size(author),pg_column_size(title),pg_column_size(content) from tbl_article;<br>&nbsp;pg_column_size | pg_column_size | pg_column_size | pg_column_size <br>----------------+----------------+----------------+----------------<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2485</font></p></pre>换插一条比较短的记录，看看是否会用到TOAST？<br><pre class="prettyprint"   ><p><font size="2"   >digoal=&gt; truncate table tbl_article;<br>digoal=&gt; select pg_relation_size(2066074);<br>&nbsp;pg_relation_size <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>digoal=&gt; select pg_relation_size(2066071);<br>&nbsp;pg_relation_size <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>digoal=&gt; insert into tbl_article (id,author,title,content) values (1,'digoal.zhou','test','test');<br>digoal=&gt; select pg_relation_size(2066071);<br>&nbsp;pg_relation_size <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192<br>digoal=&gt; select pg_relation_size(2066074);<br>&nbsp;pg_relation_size <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</font></p></pre>很明显，TOAST未被使用，因为此时没有一个变长字段的长度超过2kB。<br><pre class="prettyprint"   ><p><font size="2"   >digoal=&gt; select pg_column_size(id),pg_column_size(author),pg_column_size(title),pg_column_size(content) from tbl_article;<br>&nbsp;pg_column_size | pg_column_size | pg_column_size | pg_column_size <br>----------------+----------------+----------------+----------------<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5<br>pg_column_size : bytes required to store the value, perhaps with compression</font></p></pre><br>测试超长字段索引 : <br><pre class="prettyprint"   ><p><font size="2"   >insert into tbl_article (id,author,title,content) values (1,'digoal.zhou','test','此处省略1W字');<br>digoal=&gt; select pg_column_size(id),pg_column_size(author),pg_column_size(title),pg_column_size(content) from tbl_article;<br>&nbsp;pg_column_size | pg_column_size | pg_column_size | pg_column_size <br>----------------+----------------+----------------+----------------<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5075<br>digoal=&gt; create index idx_content on tbl_article (content);<br>ERROR:&nbsp; index row size 5088 exceeds maximum 2712 for index "idx_content"<br>HINT:&nbsp; Values larger than 1/3 of a buffer page cannot be indexed.<br>Consider a function index of an MD5 hash of the value, or use full text indexing.</font></p></pre>索引无法在超长字段上创建，有两处函数会报这个错。<br>src/backend/access/nbtree/nbtsort.c<div>src/backend/access/nbtree/nbtinsert.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check whether the item can fit on a btree page at all. (Eventually, we</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ought to try to apply TOAST methods if not.) We actually need to be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* able to fit three items on every page, so restrict any one item to 1/3</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the per-page available space. Note that at this point, itupsz doesn't</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* include the ItemId.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* NOTE: similar code appears in _bt_insertonpg() to defend against</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* oversize items being inserted into an already-existing index. But</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* during creation of an index, we don't go through there.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (itupsz &gt; BTMaxItemSize(npage))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errmsg("index row size %zu exceeds maximum %zu for index \"%s\"",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;itupsz, BTMaxItemSize(npage),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RelationGetRelationName(wstate-&gt;index)),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errhint("Values larger than 1/3 of a buffer page cannot be indexed.\n"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "Consider a function index of an MD5 hash of the value, "</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "or use full text indexing."),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errtableconstraint(wstate-&gt;heap,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(wstate-&gt;index))));</font></div><p></p></pre></div><div>BTREE索引长度限制，约为BLOCK_SIZE的1/3：</div><div>src/include/access/nbtree.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Maximum size of a btree index entry, including its tuple header.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We actually need to be able to fit three items on every page,</font></div><div><font size="2"   >&nbsp;* so restrict any one item to 1/3 the per-page available space.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define BTMaxItemSize(page) \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN_DOWN((PageGetPageSize(page) - \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MAXALIGN(SizeOfPageHeaderData + 3*sizeof(ItemIdData)) - \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MAXALIGN(sizeof(BTPageOpaqueData))) / 3)</font></div><p></p></pre></div><div><br>如何查看类型的默认存储格式？<br><pre class="prettyprint"   ><p><font size="2"   >digoal=&gt; select typname,typstorage from pg_type order by typname;<br>p : plain<br>m : main<br>e : external<br>x : extended</font></p></pre><br>如何修改类型的存储格式？<br><pre class="prettyprint"   ><p><font size="2"   >alter table tbl_article alter column {$column_name} set storage { PLAIN | MAIN | EXTERNAL | EXTENDED } ;</font><br></p></pre>TOAST表的好处：<br> 1， UPDATE一个普通表时，当该表的TOAST表存储的数据没有修改时，TOAST表不需要更新。<br> 2， 由于TOAST在物理存储上和普通表分开，所以当SELECT时没有查询被TOAST的列数据时，不需要把这些TOAST的PAGE加载到内存，从而加快了检索速度并且节约了使用空间。<br> 3， 在排序时，由于TOAST和普通表存储分开，当针对非TOAST字段排序时大大提高了排序速度。<br><br>使用TOAST存储格式注意事项：<br>1， 当变长字段上需要使用索引时，权衡CPU和存储的开销，考虑是否需要压缩或非压缩存储。（压缩节约磁盘空间，但是带来CPU的开销）<br>2， 对于经常要查询或UPDATE的变长字段，如果字段长度不是太大，可以考虑使用MAIN存储。<br>3， 在超长字段，或者将来会插入超长值的字段上建索引的话需要注意，因为索引最大不能超过三分之一的PAGE，所以超长字段上可能建索引不成功，或者有索引的情况下，超长字段插入值将不成功。解决办法一般可以使用MD5值来建，当然看你的需求了。<br><br>[小结]</div><div><div>1. 哪些tuple会触发TOAST？</div><div>当行的长度超过TOAST_TUPLE_THRESHOLD时，会调用toast_insert_or_update，即触发TOAST。(<span style="line-height: 28px;"   >TOAST_TUPLE_THRESHOLD的</span><span style="line-height: 28px;"   >计算方法参考本文末尾)</span></div><div>见源码：</div><div><div>src/backend/access/heap/heapam.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Subroutine for heap_insert(). Prepares a tuple for insertion. This sets the</font></div><div><font size="2"   >&nbsp;* tuple header fields, assigns an OID, and toasts the tuple if necessary.</font></div><div><font size="2"   >&nbsp;* Returns a toasted version of the tuple if it was toasted, or the original</font></div><div><font size="2"   >&nbsp;* tuple if not. Note that in any case, the header fields are also set in</font></div><div><font size="2"   >&nbsp;* the original tuple.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static HeapTuple</font></div><div><font size="2"   >heap_prepare_insert(Relation relation, HeapTuple tup, TransactionId xid,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommandId cid, int options)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >....</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else if (HeapTupleHasExternal(tup) || tup-&gt;t_len &gt; TOAST_TUPLE_THRESHOLD)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return toast_insert_or_update(relation, tup, NULL, options); &nbsp;</font></div><div><font size="2"   >....</font></div><div><font size="2"   >}</font></div><div><font size="2"   >...........................................</font></div><div><font size="2"   >HTSU_Result</font></div><div><font size="2"   >heap_update(Relation relation, ItemPointer otid, HeapTuple newtup,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommandId cid, Snapshot crosscheck, bool wait,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapUpdateFailureData *hufd, LockTupleMode *lockmode)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >......</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_toast = (HeapTupleHasExternal(&amp;oldtup) ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHasExternal(newtup) ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup-&gt;t_len &gt; TOAST_TUPLE_THRESHOLD);</font></div><div><font size="2"   >......</font></div><div><font size="2"   >}</font></div><p></p></pre></div></div><div>2. 哪些字段的内容会存储到TOAST，生成TOAST的规则。</div><div>这个其实就是toast_insert_or_update函数的处理逻辑：</div><div>src/backend/access/heap/tuptoaster.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* ----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Compress and/or save external until data fits into target length</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; &nbsp;1: Inline compress attributes with attstorage 'x', and store very</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; large attributes with attstorage 'x' or 'e' external immediately</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; &nbsp;2: Store attributes with attstorage 'x' or 'e' external</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; &nbsp;3: Inline compress attributes with attstorage 'm'</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; &nbsp;4: Store attributes with attstorage 'm' external</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* compute header overhead --- this should match heap_form_tuple() */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; hoff = offsetof(HeapTupleHeaderData, t_bits);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (has_nulls)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hoff += BITMAPLEN(numAttrs);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (newtup-&gt;t_data-&gt;t_infomask &amp; HEAP_HASOID)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hoff += sizeof(Oid);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; hoff = MAXALIGN(hoff);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* now convert to a limit on the tuple data size */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; maxDataLen = TOAST_TUPLE_TARGET - hoff;</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >第一步，依字段顺序压缩存储属性为x(extended)的字段直到TUPLE长度&lt;=</span><span style="line-height: 28px;"   >maxDataLen</span><span style="line-height: 28px;"   >，如果压缩（x属性）后或（e属性不压缩）字段长度&gt;maxDataLen，则直接将该字段切到TOAST。</span></div><div><span style="line-height: 28px;"   >（如果循环结束前</span><span style="line-height: 28px;"   >TUPLE长度&lt;=</span><span style="line-height: 28px;"   >maxDataLen，则有可能某些字段就不需要被压缩，跳出循环</span><span style="line-height: 28px;"   >）</span></div><div>第二步，上一步处理完后如果<span style="line-height: 28px;"   >TUPLE长度还是&gt;</span><span style="line-height: 28px;"   >maxDataLen，依字段顺序将属性为x,e还未切入TOAST的字段切入TOAST直到</span><span style="line-height: 28px;"   >TUPLE长度&lt;=</span><span style="line-height: 28px;"   >maxDataLen</span><span style="line-height: 28px;"   >。</span></div><div><span style="line-height: 28px;"   >（如果循环结束前</span><span style="line-height: 28px;"   >TUPLE长度&lt;=</span><span style="line-height: 28px;"   >maxDataLen，则有可能某些字段就不需要切入TOAST</span><span style="line-height: 28px;"   >，跳出循环</span><span style="line-height: 28px;"   >）</span></div><div>第三步<span style="line-height: 28px;"   >，上一步处理完后如果</span><span style="line-height: 28px;"   >TUPLE长度还是&gt;</span><span style="line-height: 28px;"   >maxDataLen，压缩属性为m(main)的字段。</span></div><div><span style="line-height: 28px;"   >（如果循环结束前</span><span style="line-height: 28px;"   >TUPLE长度&lt;=</span><span style="line-height: 28px;"   >maxDataLen，则有可能某些字段就不需要被压缩</span><span style="line-height: 28px;"   >，跳出循环</span><span style="line-height: 28px;"   >）</span></div><div>第四步<span style="line-height: 28px;"   >，上一步处理完后如果</span><span style="line-height: 28px;"   >TUPLE长度还是&gt;</span><span style="line-height: 28px;"   >maxDataLen，</span><span style="line-height: 28px;"   >依字段顺序将属性为m(main)的字段切入TOAST直到</span><span style="line-height: 28px;"   >TUPLE长度&lt;=</span><span style="line-height: 28px;"   >maxDataLen</span><span style="line-height: 28px;"   >。</span></div><div><span style="line-height: 28px;"   >（如果循环结束前</span><span style="line-height: 28px;"   >TUPLE长度&lt;=</span><span style="line-height: 28px;"   >maxDataLen，则有可能某些属性为m的字段依旧保留在HEAP TUPLE中</span><span style="line-height: 28px;"   >，跳出循环</span><span style="line-height: 28px;"   >）</span></div><div><br></div><div><span style="line-height: 28px;"   >3. 字段存储到TOAST后，在HEAP TUPLE中存储什么，如何指向TOAST？</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >切入TOAST的字段在HEAP TUPLE中会存储一个类似指针的结构，结构如下：</span></div><div style="line-height: 28px;"   ><pre class="prettyprint"   style="line-height: 28px;"   ><p style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   ><span style="line-height: 21px;"   >struct varatt_external</span><br style="line-height: 21px;"   ><span style="line-height: 21px;"   >{</span><br style="line-height: 21px;"   ><span style="line-height: 21px;"   >&nbsp;&nbsp;&nbsp; int32&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_rawsize;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Original data size (includes header) */</span><br style="line-height: 21px;"   ><span style="line-height: 21px;"   >&nbsp;&nbsp;&nbsp; int32&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_extsize;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* External saved size (doesn't) */</span><br style="line-height: 21px;"   ><span style="line-height: 21px;"   >&nbsp;&nbsp;&nbsp; Oid&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_valueid;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Unique ID of value within TOAST table */</span><br style="line-height: 21px;"   ><span style="line-height: 21px;"   >&nbsp;&nbsp;&nbsp; Oid&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_toastrelid;&nbsp;&nbsp;&nbsp; /* RelID of TOAST table containing it */</span><br style="line-height: 21px;"   ><span style="line-height: 21px;"   >};</span></font></p></pre></div><div><br></div>本文使用到的函数：<br><pre class="prettyprint"   ><p><font size="2"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List of functions<br>&nbsp;&nbsp; Schema&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Result data type | Argument data types |&nbsp; Type&nbsp; <br>------------+------------------------+------------------+---------------------+--------<br>&nbsp;pg_catalog | pg_column_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | "any"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | normal<br>&nbsp;pg_catalog | pg_database_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | bigint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | normal<br>&nbsp;pg_catalog | pg_database_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | bigint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | oid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | normal<br>&nbsp;pg_catalog | pg_indexes_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | bigint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | regclass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | normal<br>&nbsp;pg_catalog | pg_relation_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | bigint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | regclass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | normal<br>&nbsp;pg_catalog | pg_relation_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | bigint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | regclass, text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | normal<br>&nbsp;pg_catalog | pg_size_pretty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | bigint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | normal<br>&nbsp;pg_catalog | pg_table_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | bigint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | regclass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | normal<br>&nbsp;pg_catalog | pg_tablespace_size&nbsp;&nbsp;&nbsp;&nbsp; | bigint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | normal<br>&nbsp;pg_catalog | pg_tablespace_size&nbsp;&nbsp;&nbsp;&nbsp; | bigint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | oid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | normal<br>&nbsp;pg_catalog | pg_total_relation_size | bigint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | regclass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | normal<br>(11 rows)</font></p></pre><br>[参考]<br>1. postgres.h<br><pre class="prettyprint"   ><p><font size="2"   >/*<br>&nbsp;* struct varatt_external is a "TOAST pointer", that is, the information<br>&nbsp;* needed to fetch a stored-out-of-line Datum.&nbsp;&nbsp;&nbsp; The data is compressed<br>&nbsp;* if and only if va_extsize &lt; va_rawsize - VARHDRSZ.&nbsp; This struct must not<br>&nbsp;* contain any padding, because we sometimes compare pointers using memcmp.<br>&nbsp;*<br>&nbsp;* Note that this information is stored unaligned within actual tuples, so<br>&nbsp;* you need to memcpy from the tuple into a local struct variable before<br>&nbsp;* you can look at these fields!&nbsp; (The reason we use memcmp is to avoid<br>&nbsp;* having to do that just to detect equality of two TOAST pointers...)<br>&nbsp;*/<br>struct varatt_external<br>{<br>&nbsp;&nbsp;&nbsp; int32&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_rawsize;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Original data size (includes header) */<br>&nbsp;&nbsp;&nbsp; int32&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_extsize;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* External saved size (doesn't) */<br>&nbsp;&nbsp;&nbsp; Oid&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_valueid;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Unique ID of value within TOAST table */<br>&nbsp;&nbsp;&nbsp; Oid&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_toastrelid;&nbsp;&nbsp;&nbsp; /* RelID of TOAST table containing it */<br>};<br><br>/*<br>&nbsp;* These structs describe the header of a varlena object that may have been<br>&nbsp;* TOASTed.&nbsp; Generally, don't reference these structs directly, but use the<br>&nbsp;* macros below.<br>&nbsp;*<br>&nbsp;* We use separate structs for the aligned and unaligned cases because the<br>&nbsp;* compiler might otherwise think it could generate code that assumes<br>&nbsp;* alignment while touching fields of a 1-byte-header varlena.<br>&nbsp;*/<br>typedef union<br>{<br>&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Normal varlena (4-byte length) */<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; uint32&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_header;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_data[1];<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_4byte;<br>&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Compressed-in-line format */<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; uint32&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_header;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; uint32&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_rawsize; /* Original data size (excludes header) */<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_data[1]; /* Compressed data */<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_compressed;<br>} varattrib_4b;<br><br>typedef struct<br>{<br>&nbsp;&nbsp;&nbsp; uint8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_header;<br>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_data[1];&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Data begins here */<br>} varattrib_1b;<br><br>typedef struct<br>{<br>&nbsp;&nbsp;&nbsp; uint8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_header;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Always 0x80 or 0x01 */<br>&nbsp;&nbsp;&nbsp; uint8&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_len_1be;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Physical length of datum */<br>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; va_data[1];&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Data (for now always a TOAST pointer) */<br>} varattrib_1b_e;<br><br>/*<br>&nbsp;* Bit layouts for varlena headers on big-endian machines:<br>&nbsp;*<br>&nbsp;* 00xxxxxx 4-byte length word, aligned, uncompressed data (up to 1G)<br>&nbsp;* 01xxxxxx 4-byte length word, aligned, *compressed* data (up to 1G)<br>&nbsp;* 10000000 1-byte length word, unaligned, TOAST pointer<br>&nbsp;* 1xxxxxxx 1-byte length word, unaligned, uncompressed data (up to 126b)<br>&nbsp;*<br>&nbsp;* Bit layouts for varlena headers on little-endian machines:<br>&nbsp;*<br>&nbsp;* xxxxxx00 4-byte length word, aligned, uncompressed data (up to 1G)<br>&nbsp;* xxxxxx10 4-byte length word, aligned, *compressed* data (up to 1G)<br>&nbsp;* 00000001 1-byte length word, unaligned, TOAST pointer<br>&nbsp;* xxxxxxx1 1-byte length word, unaligned, uncompressed data (up to 126b)<br>&nbsp;*<br>&nbsp;* The "xxx" bits are the length field (which includes itself in all cases).<br>&nbsp;* In the big-endian case we mask to extract the length, in the little-endian<br>&nbsp;* case we shift.&nbsp; Note that in both cases the flag bits are in the physically<br>&nbsp;* first byte.&nbsp;&nbsp;&nbsp; Also, it is not possible for a 1-byte length word to be zero;<br>&nbsp;* this lets us disambiguate alignment padding bytes from the start of an<br>&nbsp;* unaligned datum.&nbsp; (We now *require* pad bytes to be filled with zero!)<br>&nbsp;*/</font></p></pre>2. tuptoaster.h<br><pre class="prettyprint"   ><p><font size="2"   >/*<br>&nbsp;* The code will also consider moving MAIN data out-of-line, but only as a<br>&nbsp;* last resort if the previous steps haven't reached the target tuple size.<br>&nbsp;* In this phase we use a different target size, currently equal to the<br>&nbsp;* largest tuple that will fit on a heap page.&nbsp;&nbsp;&nbsp; This is reasonable since<br>&nbsp;* the user has told us to keep the data in-line if at all possible.<br>&nbsp;*/<br><br>/*<br>&nbsp;* If an index value is larger than TOAST_INDEX_TARGET, we will try to<br>&nbsp;* compress it (we can't move it out-of-line, however).&nbsp; Note that this<br>&nbsp;* number is per-datum, not per-tuple, for simplicity in index_form_tuple().<br>&nbsp;*/<br>#define TOAST_INDEX_TARGET&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (MaxHeapTupleSize / 16)<br><br>/*<br>&nbsp;* When we store an oversize datum externally, we divide it into chunks<br>&nbsp;* containing at most TOAST_MAX_CHUNK_SIZE data bytes.&nbsp;&nbsp;&nbsp; This number *must*<br>&nbsp;* be small enough that the completed toast-table tuple (including the<br>&nbsp;* ID and sequence fields and all overhead) will fit on a page.<br>&nbsp;* The coding here sets the size on the theory that we want to fit<br>&nbsp;* EXTERN_TUPLES_PER_PAGE tuples of maximum size onto a page.<br>&nbsp;*<br>&nbsp;* NB: Changing TOAST_MAX_CHUNK_SIZE requires an initdb.<br>&nbsp;*/</font></p></pre>3.&nbsp;src/include/access/tuptoaster.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Find the maximum size of a tuple if there are to be N tuples per page.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define MaximumBytesPerTuple(tuplesPerPage) \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN_DOWN((BLCKSZ - \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MAXALIGN(SizeOfPageHeaderData + (tuplesPerPage) * sizeof(ItemIdData))) \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / (tuplesPerPage))</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* These symbols control toaster activation. &nbsp;If a tuple is larger than</font></div><div><font size="2"   >&nbsp;* TOAST_TUPLE_THRESHOLD, we will try to toast it down to no more than</font></div><div><font size="2"   >&nbsp;* TOAST_TUPLE_TARGET bytes through compressing compressible fields and</font></div><div><font size="2"   >&nbsp;* moving EXTENDED and EXTERNAL data out-of-line.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The numbers need not be the same, though they currently are. &nbsp;It doesn't</font></div><div><font size="2"   >&nbsp;* make sense for TARGET to exceed THRESHOLD, but it could be useful to make</font></div><div><font size="2"   >&nbsp;* it be smaller.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Currently we choose both values to match the largest tuple size for which</font></div><div><font size="2"   >&nbsp;* TOAST_TUPLES_PER_PAGE tuples can fit on a heap page.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* XXX while these can be modified without initdb, some thought needs to be</font></div><div><font size="2"   >&nbsp;* given to needs_toast_table() in toasting.c before unleashing random</font></div><div><font size="2"   >&nbsp;* changes. &nbsp;Also see LOBLKSIZE in large_object.h, which can *not* be</font></div><div><font size="2"   >&nbsp;* changed without initdb.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define TOAST_TUPLES_PER_PAGE &nbsp; 4</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define TOAST_TUPLE_THRESHOLD &nbsp; MaximumBytesPerTuple(TOAST_TUPLES_PER_PAGE)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define TOAST_TUPLE_TARGET &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TOAST_TUPLE_THRESHOLD</font></div><p></p></pre></div><div>4.&nbsp;src/include/storage/itemid.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* An item pointer (also called line pointer) on a buffer page</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* In some cases an item pointer is "in use" but does not have any associated</font></div><div><font size="2"   >&nbsp;* storage on the page. &nbsp;By convention, lp_len == 0 in every item pointer</font></div><div><font size="2"   >&nbsp;* that does not have storage, independently of its lp_flags state.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef struct ItemIdData</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; unsigned &nbsp; &nbsp; &nbsp; &nbsp;lp_off:15, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* offset to tuple (from start of page) */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp_flags:2, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* state of item pointer, see below */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp_len:15; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* byte length of tuple */</font></div><div><font size="2"   >} ItemIdData;</font></div><p></p></pre></div><div>5.&nbsp;src/include/pg_config.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/* Size of a disk block --- this also limits the size of a tuple. You can set</font></div><div><font size="2"   >&nbsp; &nbsp;it bigger if you need bigger tuples (although TOAST should reduce the need</font></div><div><font size="2"   >&nbsp; &nbsp;to have large tuples, since fields can be spread across multiple tuples).</font></div><div><font size="2"   >&nbsp; &nbsp;BLCKSZ must be a power of 2. The maximum possible value of BLCKSZ is</font></div><div><font size="2"   >&nbsp; &nbsp;currently 2^15 (32768). This is determined by the 15-bit widths of the</font></div><div><font size="2"   >&nbsp; &nbsp;lp_off and lp_len fields in ItemIdData (see include/storage/itemid.h).</font></div><div><font size="2"   >&nbsp; &nbsp;Changing BLCKSZ requires an initdb. */</font></div><div><font size="2"   >#define BLCKSZ 32768</font></div><p></p></pre></div><div>6.&nbsp;src/include/storage/bufpage.h</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* For historical reasons, the 64-bit LSN value is stored as two 32-bit</font></div><div><font size="2"   >&nbsp;* values.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef struct</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xlogid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* high bits */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xrecoff; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* low bits */</font></div><div><font size="2"   >} PageXLogRecPtr;</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >typedef uint16 LocationIndex;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >typedef struct PageHeaderData</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* XXX LSN is member of *any* block, not only page-organized ones */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PageXLogRecPtr pd_lsn; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* LSN: next byte after last byte of xlog</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* record for last change to this page */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pd_checksum; &nbsp; &nbsp;/* checksum */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pd_flags; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* flag bits, see below */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LocationIndex pd_lower; &nbsp; &nbsp; &nbsp; &nbsp; /* offset to start of free space */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LocationIndex pd_upper; &nbsp; &nbsp; &nbsp; &nbsp; /* offset to end of free space */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LocationIndex pd_special; &nbsp; &nbsp; &nbsp; /* offset to start of special space */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pd_pagesize_version;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId pd_prune_xid; /* oldest prunable XID, or zero if none */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ItemIdData &nbsp; &nbsp; &nbsp;pd_linp[1]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* beginning of line pointer array */</font></div><div><font size="2"   >} PageHeaderData;</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* line pointer(s) do not count as part of header</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define SizeOfPageHeaderData (offsetof(PageHeaderData, pd_linp))</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >7. src/include/c.h</span></div><div><pre class="prettyprint"   ><p><font size="2"   >typedef uint32 TransactionId;</font></p></pre></div><div><br></div><div>计算，当数据库集群的BLOCK SIZE=32KB时：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >TOAST_TUPLE_THRESHOLD =&nbsp;MaximumBytesPerTuple(TOAST_TUPLES_PER_PAGE) =&nbsp;</font></div><div><font size="2"   >MaximumBytesPerTuple(4) =&nbsp;</font></div><div><div><font size="2"   >MAXALIGN_DOWN((BLCKSZ -&nbsp;<span style="line-height: 28px;"   >MAXALIGN(SizeOfPageHeaderData + (4) * sizeof(ItemIdData)))</span><span style="line-height: 28px;"   >&nbsp;/ (4)) =&nbsp;</span></font></div></div><div><font size="2"   >MAXALIGN_DOWN((32768&nbsp;-&nbsp;<span style="line-height: 28px;"   >MAXALIGN(192 + (4) * 32))</span><span style="line-height: 28px;"   >&nbsp;/ (4)) ~= 8KB</span></font></div><div><font size="2"   ><span style="line-height: 28px;"   >~=&nbsp;</span><span style="line-height: 28px;"   >BLCKSZ</span><span style="line-height: 28px;"   >&nbsp;*</span><span style="line-height: 28px;"   >(1/4)</span></font></div><p></p></pre></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="TOAST,The Oversized-Attribute Storage Technique - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>