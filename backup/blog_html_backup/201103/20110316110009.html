<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">The MAX page size in PostgreSQL</h2>
	<h5 id="">2011-03-16 11:00:09&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402011216105821109/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">PageSize是block size的抽象概念.同时也是I/O操作的最小单元。因此pagesize的大小选择一般要参考数据库应用类型，如OLTP一般默认的8K就够了。DW的话可以选择更大的PAGESIZE(最大支持32KB)。<div>另外还需要注意一个问题, 当一个对象的存储空间不足时, PostgreSQL一次只会扩展一个数据块, 并且扩展数据块需要对这个文件加排他锁, 当并发很高时, 如果数据块太小, 性能会下降严重, 因此高并发写的应用, 建议使用32KB的数据块.<br>数据库启动后可以在pg_setting中查看PostgreSQL的block size.<br>postgres=# select * from pg_settings where name = 'block_size';<br>-[ RECORD 1 ]-------------------------------<br>name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | block_size<br>setting&nbsp;&nbsp;&nbsp; | 8192<br>unit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | <br>category&nbsp;&nbsp; | Preset Options<br>short_desc | Shows the size of a disk block.<br>extra_desc | <br>context&nbsp;&nbsp;&nbsp; | internal<br>vartype&nbsp;&nbsp;&nbsp; | integer<br>source&nbsp;&nbsp;&nbsp;&nbsp; | default<br>min_val&nbsp;&nbsp;&nbsp; | 8192<br>max_val&nbsp;&nbsp;&nbsp; | 8192<br>enumvals&nbsp;&nbsp; | <br>boot_val&nbsp;&nbsp; | 8192<br>reset_val&nbsp; | 8192<br>sourcefile | <br>sourceline | <br>在数据库初始化配置的时候决定了pagesize的大小.<br>./configure --help<br>&nbsp; --with-blocksize=BLOCKSIZE<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set table block size in kB [8]<br>Set the <i>block size</i>, in kilobytes.  This is the  unit          of storage and I/O within tables.  The default, 8  kilobytes,          is suitable for most situations; but other values  may be useful          in special cases.          The value must be a  power of 2 between 1 and 32 (kilobytes).          Note that changing  this value requires an initdb.         <br>那么MAXSIZE到底是由什么决定的，来看看源码就会明白了 : <br>出自bufpage.h<br>PostgreSQL最大的pagesize=32K.<br>原因是每个page里面标记tuple的ItemIdData数据类型里面的lp_off和lp_len只有15个比特位，最大支持32K.<br><br>原文如下:<br>/*<br>&nbsp;* A postgres disk page is an abstraction layered on top of a postgres<br>&nbsp;* disk block (which is simply a unit of i/o, see block.h).<br>&nbsp;*<br>&nbsp;* specifically, while a disk block can be unformatted, a postgres<br>&nbsp;* disk page is always a slotted page of the form:<br>&nbsp;*<br>&nbsp;* +----------------+---------------------------------+<br>&nbsp;* | PageHeaderData | linp1 linp2 linp3 ...&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; |<br>&nbsp;* +-----------+----+---------------------------------+<br>&nbsp;* | ... linpN |&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; |<br>&nbsp;* +-----------+--------------------------------------+<br>&nbsp;* |&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; ^ pd_lower&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; |<br>&nbsp;* |&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; |<br>&nbsp;* |&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;v pd_upper&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; |<br>&nbsp;* +-------------+------------------------------------+<br>&nbsp;* |&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;| tupleN ...&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; |<br>&nbsp;* +-------------+------------------+-----------------+<br>&nbsp;* |&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; ... tuple3 tuple2 tuple1 | "special space" |<br>&nbsp;* +--------------------------------+-----------------+<br>&nbsp;*&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ^ pd_special<br>&nbsp;*<br>&nbsp;* a page is full when nothing can be added between pd_lower and<br>&nbsp;* pd_upper.<br>&nbsp;*<br>&nbsp;* all blocks written out by an access method must be disk pages.<br>&nbsp;*<br>&nbsp;* EXCEPTIONS:<br>&nbsp;*<br>&nbsp;* obviously, a page is not formatted before it is initialized by<br>&nbsp;* a call to PageInit.<br>&nbsp;*<br>&nbsp;* NOTES:<br>&nbsp;*<br>&nbsp;* linp1..N form an ItemId array.&nbsp; ItemPointers point into this array<br>&nbsp;* rather than pointing directly to a tuple.&nbsp; Note that OffsetNumbers<br>&nbsp;* conventionally start at 1, not 0.<br>&nbsp;*<br>&nbsp;* tuple1..N are added "backwards" on the page.&nbsp; because a tuple's<br>&nbsp;* ItemPointer points to its ItemId entry rather than its actual<br>&nbsp;* byte-offset position, tuples can be physically shuffled on a page<br>&nbsp;* whenever the need arises.<br>&nbsp;*<br>&nbsp;* AM-generic per-page information is kept in PageHeaderData.<br>&nbsp;*<br>&nbsp;* AM-specific per-page data (if any) is kept in the area marked "special<br>&nbsp;* space"; each AM has an "opaque" structure defined somewhere that is<br>&nbsp;* stored as the page trailer.&nbsp;&nbsp;&nbsp; an access method should always<br>&nbsp;* initialize its pages with PageInit and then set its own opaque<br>&nbsp;* fields.<br>&nbsp;*/<br><br>typedef Pointer Page;<br><br><br>/*<br>&nbsp;* location (byte offset) within a page.<br>&nbsp;*<br>&nbsp;* note that this is actually limited to 2^15 because we have limited<br>&nbsp;* ItemIdData.lp_off and ItemIdData.lp_len to 15 bits (see itemid.h).<br>&nbsp;*/<br>typedef uint16 LocationIndex;<br><br>/*<br>&nbsp;* disk page organization<br>&nbsp;*<br>&nbsp;* space management information generic to any page<br>&nbsp;*<br>&nbsp;*&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pd_lsn&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; - identifies xlog record for last change to this page.<br>&nbsp;*&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pd_tli&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; - ditto.<br>&nbsp;*&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pd_flags&nbsp;&nbsp;&nbsp; - flag bits.<br>&nbsp;*&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pd_lower&nbsp;&nbsp;&nbsp; - offset to start of free space.<br>&nbsp;*&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pd_upper&nbsp;&nbsp;&nbsp; - offset to end of free space.<br>&nbsp;*&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pd_special&nbsp;&nbsp;&nbsp; - offset to start of special space.<br>&nbsp;*&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pd_pagesize_version - size in bytes and page layout version number.<br>&nbsp;*&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pd_prune_xid - oldest XID among potentially prunable tuples on page.<br>&nbsp;*<br>&nbsp;* The LSN is used by the buffer manager to enforce the basic rule of WAL:<br>&nbsp;* "thou shalt write xlog before data".&nbsp; A dirty buffer cannot be dumped<br>&nbsp;* to disk until xlog has been flushed at least as far as the page's LSN.<br>&nbsp;* We also store the 16 least significant bits of the TLI for identification<br>&nbsp;* purposes (it is not clear that this is actually necessary, but it seems<br>&nbsp;* like a good idea).<br>&nbsp;*<br>&nbsp;* pd_prune_xid is a hint field that helps determine whether pruning will be<br>&nbsp;* useful.&nbsp;&nbsp;&nbsp; It is currently unused in index pages.<br>&nbsp;*<br>&nbsp;* The page version number and page size are packed together into a single<br>&nbsp;* uint16 field.&nbsp; This is for historical reasons: before PostgreSQL 7.3,<br>&nbsp;* there was no concept of a page version number, and doing it this way<br>&nbsp;* lets us pretend that pre-7.3 databases have page version number zero.<br>&nbsp;* We constrain page sizes to be multiples of 256, leaving the low eight<br>&nbsp;* bits available for a version number.<br>&nbsp;*<br>&nbsp;* Minimum possible page size is perhaps 64B to fit page header, opaque space<br>&nbsp;* and a minimal tuple; of course, in reality you want it much bigger, so<br>&nbsp;* the constraint on pagesize mod 256 is not an important restriction.<br>&nbsp;* On the high end, we can only support pages up to 32KB because lp_off/lp_len<br>&nbsp;* are 15 bits.<br>&nbsp;*/<br></div></div>
	</div>
</div>
</body>
</html>