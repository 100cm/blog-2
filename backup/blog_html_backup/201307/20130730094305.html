<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL JDBC 9.2-1000+ failover support</h2>
	<h5 id="">2013-07-30 9:43:05&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201363091731827/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL jdbc 9.2 1000以及以上版本开始支持配置多个数据库连接,&nbsp;</div><div><a rel="nofollow" href="http://jdbc.postgresql.org/changes.html#all-committers"   >http://jdbc.postgresql.org/changes.html#all-committers</a></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Version 9.2-1000 (2012-09-27)</font></div><div><font size="2"   >add Implementation of simple connection failover Committed by davec. Thanks to Mikko Tiihonen.</font></div><p></p></pre></div><div>目前的模式采用round-robin模式连接, 直到成功获取连接. 代码见本文末尾部分.</div><div>配置方法如下 :&nbsp;</div><div>jdbc:postgresql://host1:port1,host2:port2,...../test</div><div>目前这个版本的功能比较单一, 并且存在一定的性能问题 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >By&nbsp;Chen Huajun</font></div><div><font size="2"   >Hi All,</font></div><div><font size="2"   >In the latest jdbc driver,multi backends can be assigned in the URL as following.&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp;&gt;With latest jdbc drivers you can simply configure multiple host:port pairs in the url separated by comma:&nbsp;</font></div><div><font size="2"   >&nbsp;&gt;jdbc:postgresql://host1:port1,host2:port2/test&nbsp;</font></div><div><font size="2"   >&nbsp;&gt;It has only the most basic failover support. When a new connection is opened the hosts are tried in round-robin until a connection is successfully established.&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >But there is a performance problem .if the first host is down,&nbsp;</font></div><div><font size="2"   >all connecting must be blocked until connect timeout at first,&nbsp;</font></div><div><font size="2"   >and then try connect to the next host.&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Why not adjust the order of hosts dynamically?&nbsp;</font></div><div><font size="2"   >For excample, after a successful connecting,if the target host is not the first host,&nbsp;</font></div><div><font size="2"   >swap the target host and the first host.&nbsp;</font></div><div><font size="2"   >And then subsequent connecting will try the most suitable host at first.&nbsp;</font></div><p></p></pre></div><div>该补丁截止2013-07-30尚未提交.&nbsp;</div><div>那么基于这个补丁, 能做些什么事情呢?</div><div>1. 首先如果数据库本身已经做了集群, 例如 :&nbsp;</div><div><a rel="nofollow" href="https://github.com/digoal/sky_postgresql_cluster"   >https://github.com/digoal/sky_postgresql_cluster</a></div><div>那么pgjdbc中只需要配置vip即可. 不需要配置多个数据库.</div><div>2. 对于未配置HA的数据库系统, jdbc的这个功能能够起到一定的作用, 例如当主节点挂掉, 备节点可以提供只读的功能. 基于这个特点可以在程序中将读的数据源和写的数据源分开, 当主节点挂掉时确保读的应用不受到影响.&nbsp;</div><div>3. 还有一种应用场景是仅提供写的应用, 多个数据库的表结构一致, 都可以写. 这种在没有做数据库HA的情况下就比较适合了. 例如日志型的应用, 在大数据中这种场景比较普遍.</div><div>DATABASEs :&nbsp;</div><div>192.168.1.2:5432/digoal</div><div><span style="line-height: 22px;"   >192.168.1.3:5432/digoal</span></div><div><span style="line-height: 22px;"   >192.168.1.4:5432/digoal</span></div><div><span style="line-height: 22px;"   >配置 :&nbsp;</span></div><div>jdbc:postgresql://192.168.1.2:5432,<span style="line-height: 22px;"   >192.168.1.3:5432,</span><span style="line-height: 22px;"   >192.168.1.4:5432</span><span style="line-height: 22px;"   >/digoal</span></div><div><span style="line-height: 22px;"   >如果场景中涉及部分共用数据集, 可以通过应用层面或者数据库层面做一些数据同步来实现.</span></div><div><br></div>[参考]<div>1.&nbsp;<a rel="nofollow" href="https://github.com/pgjdbc/pgjdbc"   >https://github.com/pgjdbc/pgjdbc</a><br><wbr><div>2.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://jdbc.postgresql.org/download.html"   >http://jdbc.postgresql.org/download.html</a></div><div>3.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://postgresql.1045698.n5.nabble.com/Re-Failover-Datasource-td4496411.html"   >http://postgresql.1045698.n5.nabble.com/Re-Failover-Datasource-td4496411.html</a></div><div>4.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://amutu.com/blog/2013/07/postgresql-jdbc%E6%94%AF%E6%8C%81fail-over%E9%85%8D%E7%BD%AE/"   >http://amutu.com/blog/2013/07/postgresql-jdbc%E6%94%AF%E6%8C%81fail-over%E9%85%8D%E7%BD%AE/</a></div><div>5.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="https://github.com/digoal/sky_postgresql_cluster"   >https://github.com/digoal/sky_postgresql_cluster</a></div><div>6.&nbsp;postgresql-jdbc-9.2-1003.src/org/postgresql/core/ConnectionFactory.java</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*-------------------------------------------------------------------------</font></div><div><font size="2"   >*</font></div><div><font size="2"   >* Copyright (c) 2004-2011, PostgreSQL Global Development Group</font></div><div><font size="2"   >* Copyright (c) 2004, Open Cloud Limited.</font></div><div><font size="2"   >*</font></div><div><font size="2"   >*</font></div><div><font size="2"   >*-------------------------------------------------------------------------</font></div><div><font size="2"   >*/</font></div><div><font size="2"   >package org.postgresql.core;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >import java.util.Properties;</font></div><div><font size="2"   >import java.sql.SQLException;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >import org.postgresql.util.HostSpec;</font></div><div><font size="2"   >import org.postgresql.util.PSQLException;</font></div><div><font size="2"   >import org.postgresql.util.GT;</font></div><div><font size="2"   >import org.postgresql.util.PSQLState;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/**</font></div><div><font size="2"   >&nbsp;* Handles protocol-specific connection setup.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @author Oliver Jowett (oliver@opencloud.com)</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >public abstract class ConnectionFactory {</font></div><div><font size="2"   >&nbsp; &nbsp; /**</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* Protocol version to implementation instance map.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* If no protocol version is specified, instances are</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* tried in order until an exception is thrown or a non-null</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* connection is returned.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; private static final Object[][] versions = {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { "3", new org.postgresql.core.v3.ConnectionFactoryImpl() },</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { "2", new org.postgresql.core.v2.ConnectionFactoryImpl() },</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; /**</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* Establishes and initializes a new connection.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;*&lt;p&gt;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* If the "protocolVersion" property is specified, only that protocol</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* version is tried. Otherwise, all protocols are tried in order, falling</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* back to older protocols as necessary.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;*&lt;p&gt;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* Currently, protocol versions 3 (7.4+) and 2 (pre-7.4) are supported.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @param hostSpecs at least one host and port to connect to; multiple elements for round-robin failover</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @param user the username to authenticate with; may not be null.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @param database the database on the server to connect to; may not be null.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @param info extra properties controlling the connection;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* &nbsp; &nbsp;notably, "password" if present supplies the password to authenticate with.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @param logger the logger to use for this connection</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @return the new, initialized, connection</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @throws SQLException if the connection could not be established.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; public static ProtocolConnection openConnection(HostSpec[] hostSpecs, String user, String database, Properties info, Logger logger) throws SQLException {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; String protoName = info.getProperty("protocolVersion");</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; versions.length; ++i)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String versionProtoName = (String) versions[i][0];</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (protoName != null &amp;&amp; !protoName.equals(versionProtoName))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ConnectionFactory factory = (ConnectionFactory) versions[i][1];</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProtocolConnection connection = factory.openConnectionImpl(hostSpecs, user, database, info, logger);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (connection != null)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return connection;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; throw new PSQLException(GT.tr("A connection could not be made using the requested protocol {0}.", protoName),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PSQLState.CONNECTION_UNABLE_TO_CONNECT);</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; /**</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* Implementation of {@link #openConnection} for a particular protocol version.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* Implemented by subclasses of {@link ConnectionFactory}.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @param hostSpecs at least one host and port to connect to; multiple elements for round-robin failover</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @param user the username to authenticate with; may not be null.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @param database the database on the server to connect to; may not be null.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @param info extra properties controlling the connection;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* &nbsp; &nbsp;notably, "password" if present supplies the password to authenticate with.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @param logger the logger to use for this connection</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @return the new, initialized, connection, or &lt;code&gt;null&lt;/code&gt; if this protocol</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* &nbsp; &nbsp;version is not supported by the server.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* @throws SQLException if the connection could not be established for a reason other</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* &nbsp; &nbsp;than protocol version incompatibility.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; public abstract ProtocolConnection openConnectionImpl(HostSpec[] hostSpecs, String user, String database, Properties info, Logger logger) throws SQLException;</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div></div></div>
	</div>
</div>
</body>
</html>