<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.4 patch: extensible TOAST compression support</h2>
	<h5 id="">2013-07-29 17:00:38&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201362261024670/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 9.4 可能会新增的一个补丁, 支持TOAST表的压缩算法扩展.&nbsp;</div><div>PostgreSQL 存储变长字段时可以选择基表存储或者TOAST存储, 当使用TOAST存储时, 可以支持压缩或不压缩存储, 目前压缩算法仅仅支持pglz算法.&nbsp;</div><div>TOAST存储的字段最大可以存储1G的长度.&nbsp;<span style="line-height: 22px;"   >字段长度使用4字节来表示, 只用到30个比特位, 多出2个比特位. 00表示不压缩, 01表示压缩. 如果要支持更多的压缩算法需要用到这2个比特位. 另外该补丁扩展了1个字节用来支持更多的压缩算法.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >* add lz4 compression algorithm (2 clause bsd)</font></div><div><font size="2"   >* move compression algorithms into own subdirectory</font></div><div><font size="2"   >* clean up compression/decompression functions</font></div><div><font size="2"   >* allow 258 compression algorithms, uses 1byte extra for any but the</font></div><div><font size="2"   >&nbsp; first three</font></div><div><font size="2"   >* don't pass a varlena to pg_lzcompress.c anymore, but data directly</font></div><div><font size="2"   >* add pglz_long as a test fourth compression method that uses the +1</font></div><div><font size="2"   >&nbsp; byte encoding</font></div><div><font size="2"   >* us postgres' endian detection in snappy for compatibility with osx</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >目前补丁新增了3个压缩算法, snappy, lz4, pglz_long</span></div><div><span style="line-height: 22px;"   >对TOAST有兴趣的朋友可以同时阅读如下BLOG :&nbsp;</span></div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020136264471312/"   >http://blog.163.com/digoal@126/blog/static/16387704020136264471312/</a></div><div><br></div><div>下面测试一下这个补丁.</div><div>1. 下载一个9.4 开发版源码.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >http://git.postgresql.org/gitweb/?p=postgresql.git;a=snapshot;h=129759d6a539059cde85d0dad19992ff45da3bb4;sf=tgz</font></div><div></div><p></p></pre></div><div>2. 编译安装</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >cd&nbsp;postgresql-129759d</font></div><div><font size="2"   >./configure --prefix=/home/pg94/pgsql9.4devel --with-pgport=1921 --with-perl --with-tcl --with-python --with-openssl --with-pam --without-ldap --with-libxml --with-libxslt --enable-thread-safety --with-wal-blocksize=16 &amp;&amp; gmake &amp;&amp; gmake install</font></div><p></p></pre></div><div>注意, 如果是直接打补丁然后编译安装, 可能会报错utils/errcodes.h不存在, 如果你遇到这个错误, 请先不要打补丁, 编译安装完后再打补丁.</div><div><br></div><div>3. 下载补丁</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >cd&nbsp;<span style="line-height: 22px;"   >postgresql-129759d</span></font></div><div><font size="2"   >wget&nbsp;http://www.postgresql.org/message-id/attachment/29333/0001-Add-snappy-compression-algorithm-to-contrib.patch</font></div><div><font size="2"   >wget&nbsp;http://www.postgresql.org/message-id/attachment/29334/0002-Add-lz4-compression-algorithm-to-contrib.patch</font></div><div><font size="2"   >wget&nbsp;http://www.postgresql.org/message-id/attachment/29335/0003-Introduce-pluggable-compression.patch</font></div><p></p></pre></div><div><br></div><div>4. 打补丁</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >patch -p1 &lt; ./0001-Add-snappy-compression-algorithm-to-contrib.patch&nbsp;</font></div><div><font size="2"   >patch -p1 &lt; ./0002-Add-lz4-compression-algorithm-to-contrib.patch&nbsp;</font></div><div><font size="2"   >patch -p1 &lt; ./0003-Introduce-pluggable-compression.patch</font></div><p></p></pre></div><div><br></div><div>5. 编译安装</div><div>报错</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >../../src/common/libpgcommon_srv.a(snappy_srv.o): In function `snappy_uncompress':</font></div><div><font size="2"   >snappy.c:(.text+0x531): undefined reference to `le32toh'</font></div><div><font size="2"   >snappy.c:(.text+0x782): undefined reference to `le32toh'</font></div><div><font size="2"   >../../src/common/libpgcommon_srv.a(snappy_srv.o): In function `snappy_compress':</font></div><div><font size="2"   >snappy.c:(.text+0xdb2): undefined reference to `htole16'</font></div><div><font size="2"   >snappy.c:(.text+0xdec): undefined reference to `htole16'</font></div><div><font size="2"   >snappy.c:(.text+0xf6f): undefined reference to `htole16'</font></div><div><font size="2"   >collect2: ld returned 1 exit status</font></div><div><font size="2"   >gmake[2]: *** [postgres] Error 1</font></div><div><font size="2"   >gmake[2]: Leaving directory `/home/pg94/postgresql-129759d/src/backend'</font></div><div><font size="2"   >gmake[1]: *** [all-backend-recurse] Error 2</font></div><div><font size="2"   >gmake[1]: Leaving directory `/home/pg94/postgresql-129759d/src'</font></div><div><font size="2"   >gmake: *** [all-src-recurse] Error 2</font></div><p></p></pre></div><div><br></div><div>修复错误, 修改<span style="line-height: 22px;"   >snappy.c, 把snappy-compat.h中</span><span style="line-height: 22px;"   >le32toh和</span><span style="line-height: 22px;"   >htole16的定义拷贝到snappy.c 如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >vi src/common/snappy/snappy.c</font></div><div><div><font size="2"   >#include "snappy-compat.h"</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#if &nbsp; &nbsp;__DARWIN_BYTE_ORDER == __DARWIN_LITTLE_ENDIAN</font></div><div><font size="2"   ># &nbsp;define &nbsp; &nbsp; &nbsp; htole16(x) (x)</font></div><div><font size="2"   ># &nbsp;define &nbsp; &nbsp; &nbsp; le32toh(x) (x)</font></div><div><font size="2"   >#elif &nbsp;__DARWIN_BYTE_ORDER == __DARWIN_BIG_ENDIAN</font></div><div><font size="2"   ># &nbsp;define &nbsp; &nbsp; &nbsp; htole16(x) __DARWIN_OSSwapInt16(x)</font></div><div><font size="2"   ># &nbsp;define &nbsp; &nbsp; &nbsp; le32toh(x) __DARWIN_OSSwapInt32(x)</font></div><div><font size="2"   >#else</font></div><div><font size="2"   ># &nbsp;error "Endianness is undefined"</font></div><div><font size="2"   >#endif</font></div></div><p></p></pre></div><div><br></div><div>6. 初始化数据库</div><pre class="prettyprint"   ><p></p><div><font size="2"   >initdb -D $PGDATA -E UTF8 --locale=C -W -U postgres</font></div><div></div><p></p></pre><div><span style="line-height: 22px;"   >7. 启动数据库, 测试</span></div><div>查看新增的一个参数<span style="line-height: 22px;"   >toast_compression_algo.</span></div><div><span style="line-height: 22px;"   >支持4个值, 0,1,2,3. 分别表示压缩算法</span><span style="line-height: 22px;"   >0: pglz, 1: snappy, 2: lz4, 3: pglz_long</span></div><wbr><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from pg_settings where name ~ 'toast_compression_algo';</font></div><div><font size="2"   >-[ RECORD 1 ]----------------------------------------------------------------------</font></div><div><font size="2"   >name &nbsp; &nbsp; &nbsp; | toast_compression_algo</font></div><div><font size="2"   >setting &nbsp; &nbsp;| 2</font></div><div><font size="2"   >unit &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >category &nbsp; | Client Connection Defaults / Statement Behavior</font></div><div><font size="2"   >short_desc | chooses the compression algo: 0: pglz, 1: snappy, 2: lz4, 3: pglz_long</font></div><div><font size="2"   >extra_desc |&nbsp;</font></div><div><font size="2"   >context &nbsp; &nbsp;| user</font></div><div><font size="2"   >vartype &nbsp; &nbsp;| integer</font></div><div><font size="2"   >source &nbsp; &nbsp; | default</font></div><div><font size="2"   >min_val &nbsp; &nbsp;| 0</font></div><div><font size="2"   >max_val &nbsp; &nbsp;| 3</font></div><div><font size="2"   >enumvals &nbsp; |&nbsp;</font></div><div><font size="2"   >boot_val &nbsp; | 2</font></div><div><font size="2"   >reset_val &nbsp;| 2</font></div><div><font size="2"   >sourcefile |&nbsp;</font></div><div><font size="2"   >sourceline |&nbsp;</font></div><p></p></pre></div><div>生成1份大数据.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# copy (select repeat(md5(random()::text),10000) from generate_series(1,10000)) to '/home/pg94/toast.dmp';</font></div><div><font size="2"   >COPY 10000</font></div><div><font size="2"   >Time: 29034.168 ms</font></div></div><div><font size="2"   >大小3GB</font></div><div><font size="2"   >-rw-r--r-- 1 pg94 pg94 3.0G Jul 29 16:39 toast.dmp</font></div><p></p></pre></div><div>7.1 导入到pglz数据表</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# set toast_compression_algo=0;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >Time: 0.323 ms</font></div><div><font size="2"   >digoal=# create table test_pglz(info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >Time: 225.286 ms</font></div></div><div><div><font size="2"   >digoal=# copy test_pglz from &nbsp;'/home/pg94/toast.dmp' ;</font></div><div><font size="2"   >COPY 10000</font></div><div><font size="2"   >Time: 65924.167 ms</font></div></div><p></p></pre></div><div>确认数据在toast表中, 查看toast表和基表大小</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# select * from pg_class where relname='test_pglz';</font></div><div><font size="2"   >-[ RECORD 1 ]--+----------</font></div><div><font size="2"   >relname &nbsp; &nbsp; &nbsp; &nbsp;| test_pglz</font></div><div><font size="2"   >relnamespace &nbsp; | 2200</font></div><div><font size="2"   >reltype &nbsp; &nbsp; &nbsp; &nbsp;| 16393</font></div><div><font size="2"   >reloftype &nbsp; &nbsp; &nbsp;| 0</font></div><div><font size="2"   >relowner &nbsp; &nbsp; &nbsp; | 10</font></div><div><font size="2"   >relam &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 0</font></div><div><font size="2"   >relfilenode &nbsp; &nbsp;| 16391</font></div><div><font size="2"   >reltablespace &nbsp;| 0</font></div><div><font size="2"   >relpages &nbsp; &nbsp; &nbsp; | 64</font></div><div><font size="2"   >reltuples &nbsp; &nbsp; &nbsp;| 10000</font></div><div><font size="2"   >relallvisible &nbsp;| 0</font></div><div><font size="2"   >reltoastrelid &nbsp;| 16394</font></div><div><font size="2"   >reltoastidxid &nbsp;| 0</font></div><div><font size="2"   >relhasindex &nbsp; &nbsp;| f</font></div><div><font size="2"   >relisshared &nbsp; &nbsp;| f</font></div><div><font size="2"   >relpersistence | p</font></div><div><font size="2"   >relkind &nbsp; &nbsp; &nbsp; &nbsp;| r</font></div><div><font size="2"   >relnatts &nbsp; &nbsp; &nbsp; | 1</font></div><div><font size="2"   >relchecks &nbsp; &nbsp; &nbsp;| 0</font></div><div><font size="2"   >relhasoids &nbsp; &nbsp; | f</font></div><div><font size="2"   >relhaspkey &nbsp; &nbsp; | f</font></div><div><font size="2"   >relhasrules &nbsp; &nbsp;| f</font></div><div><font size="2"   >relhastriggers | f</font></div><div><font size="2"   >relhassubclass | f</font></div><div><font size="2"   >relispopulated | t</font></div><div><font size="2"   >relfrozenxid &nbsp; | 1687</font></div><div><font size="2"   >relminmxid &nbsp; &nbsp; | 1</font></div><div><font size="2"   >relacl &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >reloptions &nbsp; &nbsp; |&nbsp;</font></div></div><div><div><font size="2"   >digoal=# select pg_relation_size('16394'::regclass)/1024/1024;</font></div><div><font size="2"   >-[ RECORD 1 ]</font></div><div><font size="2"   >?column? | 39</font></div></div><div><div><font size="2"   >digoal=# select pg_relation_size('test_pglz'::regclass)/1024/1024.0;</font></div><div><font size="2"   >-[ RECORD 1 ]--------------------</font></div><div><font size="2"   >?column? | 0.50000000000000000000</font></div></div><p></p></pre></div><div><span style="line-height: 22px;"   >7.2 导入到snappy数据表 :&nbsp;</span></div><div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >digoal=# set toast_compression_algo=1;</font></div><div style="line-height: 22px;"   ><font size="2"   >SET</font></div><div style="line-height: 22px;"   ><font size="2"   >Time: 0.291 ms</font></div><div style="line-height: 22px;"   ><font size="2"   >digoal=# create table test_snappy(info text);</font></div><div style="line-height: 22px;"   ><font size="2"   >CREATE TABLE</font></div><div style="line-height: 22px;"   ><font size="2"   >Time: 27.662 ms</font></div><div style="line-height: 22px;"   ><font size="2"   >digoal=# copy test_snappy from &nbsp;'/home/pg94/toast.dmp' ;</font></div><div style="line-height: 22px;"   ><font size="2"   >COPY 10000</font></div><div style="line-height: 22px;"   ><font size="2"   >Time: 42846.571 ms</font></div><div style="line-height: 22px;"   ><font size="2"   >查看表大小</font></div><div><div><font size="2"   >digoal=# select reltoastrelid from pg_class where relname='test_snappy';</font></div><div><font size="2"   >-[ RECORD 1 ]-+------</font></div><div><font size="2"   >reltoastrelid | 26400</font></div></div><div><div><font size="2"   >digoal=# select pg_relation_size('test_snappy'::regclass)/1024/1024.0;</font></div><div><font size="2"   >-[ RECORD 1 ]--------------------</font></div><div><font size="2"   >?column? | 0.50000000000000000000</font></div></div><div><div><font size="2"   >digoal=# select pg_relation_size('26400'::regclass)/1024/1024.0;</font></div><div><font size="2"   >-[ RECORD 1 ]------------------</font></div><div><font size="2"   >?column? | 156.2500000000000000</font></div></div><p></p></pre></div><div><div><span style="line-height: 22px;"   >7.3 导入到lz4数据表 :</span></div></div></div><div><span style="line-height: 22px;"   >lz4压缩比最高, 压缩后未达到</span>TOAST_TUPLE_THRESHOLD阈值, &nbsp;所以未存储到TOAST中.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# set toast_compression_algo=2;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >Time: 0.200 ms</font></div><div><font size="2"   >digoal=# create table test_lz4(info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >Time: 33.929 ms</font></div><div><font size="2"   >digoal=# copy test_lz4 from &nbsp;'/home/pg94/toast.dmp' ;</font></div><div><font size="2"   >COPY 10000</font></div><div><font size="2"   >Time: 33985.440 ms</font></div><div><font size="2"   >digoal=# select reltoastrelid from pg_class where relname='test_lz4';</font></div><div><font size="2"   >-[ RECORD 1 ]-+------</font></div><div><font size="2"   >reltoastrelid | 36406</font></div><div><font size="2"   >digoal=# select pg_relation_size('test_lz4'::regclass)/1024/1024.0;</font></div><div><font size="2"   >-[ RECORD 1 ]-----------------</font></div><div><font size="2"   >?column? | 13.0234375000000000</font></div><div><font size="2"   >digoal=# select pg_relation_size('36406'::regclass)/1024/1024.0;</font></div><div><font size="2"   >-[ RECORD 1 ]--------------------</font></div><div><font size="2"   >?column? | 0.00000000000000000000</font></div><p></p></pre></div><div><br></div></div><div><span style="line-height: 22px;"   >7.4 导入到pglz_long数据表 :</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# set toast_compression_algo=3;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >Time: 0.278 ms</font></div><div><font size="2"   >digoal=# create table test_pglz_long(info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >Time: 25.622 ms</font></div><div><font size="2"   >digoal=# copy test_pglz_long from &nbsp;'/home/pg94/toast.dmp' ;</font></div><div><font size="2"   >COPY 10000</font></div><div><font size="2"   >Time: 72135.470 ms</font></div><div><font size="2"   >digoal=# select reltoastrelid from pg_class where relname='test_pglz_long';</font></div><div><font size="2"   >-[ RECORD 1 ]-+------</font></div><div><font size="2"   >reltoastrelid | 36412</font></div><div><font size="2"   >digoal=# select pg_relation_size('test_pglz_long'::regclass)/1024/1024.0;</font></div><div><font size="2"   >-[ RECORD 1 ]--------------------</font></div><div><font size="2"   >?column? | 0.50000000000000000000</font></div><div><font size="2"   >digoal=# select pg_relation_size('36412'::regclass)/1024/1024.0;</font></div><div><font size="2"   >-[ RECORD 1 ]-----------------</font></div><div><font size="2"   >?column? | 39.0625000000000000</font></div><p></p></pre></div><div>解压缩速度测试 :&nbsp;</div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# copy test_pglz to '/dev/null' with binary;</font></div><div><font size="2"   >COPY 10000</font></div><div><font size="2"   >Time: 7978.786 ms</font></div><div><font size="2"   >digoal=# copy test_snappy to '/dev/null' with binary;</font></div><div><font size="2"   >COPY 10000</font></div><div><font size="2"   >Time: 3401.034 ms</font></div><div><font size="2"   >digoal=# copy test_lz4 to '/dev/null' with binary;</font></div><div><font size="2"   >COPY 10000</font></div><div><font size="2"   >Time: 2533.736 ms</font></div><div><font size="2"   >digoal=# copy test_pglz_long to '/dev/null' with binary;</font></div><div><font size="2"   >COPY 10000</font></div><div><font size="2"   >Time: 7994.396 ms</font></div><p></p></pre></div><div>最后测试一下不压缩存储</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# alter table test_uncompress_toast alter column info set storage external;</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >Time: 0.695 ms</font></div><div><font size="2"   >digoal=# copy test_uncompress_toast from '/home/pg94/toast.dmp' ;</font></div><div><font size="2"   >COPY 10000</font></div><div><font size="2"   >Time: 128210.037 ms</font></div><div><font size="2"   >digoal=# copy test_uncompress_toast to '/dev/null' with binary;</font></div><div><font size="2"   >COPY 10000</font></div><div><font size="2"   >Time: 5090.905 ms</font></div><p></p></pre></div><div><br></div><div>[小结]</div><div>1. 本文用到的测试数据显示lz4压缩算法压缩比最高, 压缩和解压缩速度最快.</div><div>2. 除了使用数据库本身的数据压缩, 还可以考虑文件系统层面的压缩, 例如ZFS文件系统.&nbsp;</div><div><a rel="nofollow" href="http://www.citusdata.com/blog/64-zfs-compression"   >http://www.citusdata.com/blog/64-zfs-compression</a></div><div><br></div>[参考]<div>1.&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020136264471312/"   >http://blog.163.com/digoal@126/blog/static/16387704020136264471312/</a><br><wbr><div>2.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://www.postgresql.org/message-id/flat/20130530114225.GI4201@awork2.anarazel.de#20130530114225.GI4201@awork2.anarazel.de"   >http://www.postgresql.org/message-id/flat/20130530114225.GI4201@awork2.anarazel.de#20130530114225.GI4201@awork2.anarazel.de</a></div>3.&nbsp;<a rel="nofollow" href="http://www.postgresql.org/message-id/flat/20130216164231.GA15069@awork2.anarazel.de#20130216164231.GA15069@awork2.anarazel.de"   >http://www.postgresql.org/message-id/flat/20130216164231.GA15069@awork2.anarazel.de#20130216164231.GA15069@awork2.anarazel.de</a><br><div>4.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://www.postgresql.org/message-id/flat/20130605150144.GD28067@alap2.anarazel.de#20130605150144.GD28067@alap2.anarazel.de"   >http://www.postgresql.org/message-id/flat/20130605150144.GD28067@alap2.anarazel.de#20130605150144.GD28067@alap2.anarazel.de</a></div>5.&nbsp;<div><pre class="prettyprint"   ><p></p><div><font size="2"   >On 2013-06-15 12:20:28 +0200, Andres Freund wrote:</font></div><div><font size="2"   >&gt; On 2013-06-14 21:56:52 -0400, Robert Haas wrote:</font></div><div><font size="2"   >&gt; &gt; I don't think we need it. &nbsp;I think what we need is to decide is which</font></div><div><font size="2"   >&gt; &gt; algorithm is legally OK to use. &nbsp;And then put it in.</font></div><div><font size="2"   >&gt; &gt;&nbsp;</font></div><div><font size="2"   >&gt; &gt; In the past, we've had a great deal of speculation about that legal</font></div><div><font size="2"   >&gt; &gt; question from people who are not lawyers. &nbsp;Maybe it would be valuable</font></div><div><font size="2"   >&gt; &gt; to get some opinions from people who ARE lawyers. &nbsp;Tom and Heikki both</font></div><div><font size="2"   >&gt; &gt; work for real big companies which, I'm guessing, have substantial</font></div><div><font size="2"   >&gt; &gt; legal departments; perhaps they could pursue getting the algorithms of</font></div><div><font size="2"   >&gt; &gt; possible interest vetted. &nbsp;Or, I could try to find out whether it's</font></div><div><font size="2"   >&gt; &gt; possible do something similar through EnterpriseDB.</font></div><div><font size="2"   >&gt;&nbsp;</font></div><div><font size="2"   >&gt; I personally don't think the legal arguments holds all that much water</font></div><div><font size="2"   >&gt; for snappy and lz4. But then the opinion of a european non-lawyer doesn't</font></div><div><font size="2"   >&gt; hold much either.</font></div><div><font size="2"   >&gt; Both are widely used by a large number open and closed projects, some of</font></div><div><font size="2"   >&gt; which have patent grant clauses in their licenses. E.g. hadoop,</font></div><div><font size="2"   >&gt; cassandra use lz4, and I'd be surprised if the companies behind those</font></div><div><font size="2"   >&gt; have opened themselves to litigation.</font></div><div><font size="2"   >&gt;&nbsp;</font></div><div><font size="2"   >&gt; I think we should preliminarily decide which algorithm to use before we</font></div><div><font size="2"   >&gt; get lawyers involved. I'd surprised if they can make such a analysis</font></div><div><font size="2"   >&gt; faster than we can rule out one of them via benchmarks.</font></div><div><font size="2"   >&gt;&nbsp;</font></div><div><font size="2"   >&gt; Will post an updated patch that includes lz4 as well.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Attached.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Changes:</font></div><div><font size="2"   >* add lz4 compression algorithm (2 clause bsd)</font></div><div><font size="2"   >* move compression algorithms into own subdirectory</font></div><div><font size="2"   >* clean up compression/decompression functions</font></div><div><font size="2"   >* allow 258 compression algorithms, uses 1byte extra for any but the</font></div><div><font size="2"   >&nbsp; first three</font></div><div><font size="2"   >* don't pass a varlena to pg_lzcompress.c anymore, but data directly</font></div><div><font size="2"   >* add pglz_long as a test fourth compression method that uses the +1</font></div><div><font size="2"   >&nbsp; byte encoding</font></div><div><font size="2"   >* us postgres' endian detection in snappy for compatibility with osx</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Based on the benchmarks I think we should go with lz4 only for now. The</font></div><div><font size="2"   >patch provides the infrastructure should somebody else want to add more</font></div><div><font size="2"   >or even proper configurability.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Todo:</font></div><div><font size="2"   >* windows build support</font></div><div><font size="2"   >* remove toast_compression_algo guc</font></div><div><font size="2"   >* remove either snappy or lz4 support</font></div><div><font size="2"   >* remove pglz_long support (just there for testing)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >New benchmarks:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Table size:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp; &nbsp; &nbsp; &nbsp;Name &nbsp; &nbsp; &nbsp; &nbsp;| Type &nbsp;| Owner &nbsp;| &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+--------------------+-------+--------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | messages_pglz &nbsp; &nbsp; &nbsp;| table | andres | 526 MB |&nbsp;</font></div><div><font size="2"   >&nbsp;public | messages_snappy &nbsp; &nbsp;| table | andres | 523 MB |&nbsp;</font></div><div><font size="2"   >&nbsp;public | messages_lz4 &nbsp; &nbsp; &nbsp; | table | andres | 522 MB |&nbsp;</font></div><div><font size="2"   >&nbsp;public | messages_pglz_long | table | andres | 527 MB |&nbsp;</font></div><div><font size="2"   >(4 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Workstation (2xE5520, enough s_b for everything):</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Data load:</font></div><div><font size="2"   >pglz:<span>		</span>36643.384 ms</font></div><div><font size="2"   >snappy: <span>	</span>24626.894 ms</font></div><div><font size="2"   >lz4:<span>	</span> &nbsp; &nbsp; &nbsp; &nbsp;23871.421 ms</font></div><div><font size="2"   >pglz_long:<span>	</span>37097.681 ms</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >COPY messages_* TO '/dev/null' WITH BINARY;</font></div><div><font size="2"   >pglz: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3116.083 ms</font></div><div><font size="2"   >snappy: &nbsp; &nbsp; &nbsp; &nbsp; 2524.388 ms</font></div><div><font size="2"   >lz4: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2349.396 ms</font></div><div><font size="2"   >pglz_long: &nbsp; &nbsp; &nbsp;3104.134 ms</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >COPY (SELECT rawtxt FROM messages_*) TO '/dev/null' WITH BINARY;</font></div><div><font size="2"   >pglz: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1609.969 ms</font></div><div><font size="2"   >snappy: &nbsp; &nbsp; &nbsp; &nbsp; 1031.696 ms</font></div><div><font size="2"   >lz4: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 886.782 ms</font></div><div><font size="2"   >pglz_long: &nbsp; &nbsp; &nbsp;1606.803 ms</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >On my elderly laptop (core 2 duo), too load shared buffers:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Data load:</font></div><div><font size="2"   >pglz:<span>		</span>39968.381 ms</font></div><div><font size="2"   >snappy: <span>	</span>26952.330 ms</font></div><div><font size="2"   >lz4:<span>	</span> &nbsp; &nbsp; &nbsp; &nbsp;29225.472 ms</font></div><div><font size="2"   >pglz_long:<span>	</span>39929.568 ms</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >COPY messages_* TO '/dev/null' WITH BINARY;</font></div><div><font size="2"   >pglz: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3920.588 ms</font></div><div><font size="2"   >snappy: &nbsp; &nbsp; &nbsp; &nbsp; 3421.938 ms</font></div><div><font size="2"   >lz4: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3311.540 ms</font></div><div><font size="2"   >pglz_long: &nbsp; &nbsp; &nbsp;3885.920 ms</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >COPY (SELECT rawtxt FROM messages_*) TO '/dev/null' WITH BINARY;</font></div><div><font size="2"   >pglz: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2238.145 ms</font></div><div><font size="2"   >snappy: &nbsp; &nbsp; &nbsp; &nbsp; 1753.403 ms</font></div><div><font size="2"   >lz4: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1638.092 ms</font></div><div><font size="2"   >pglz_long: &nbsp; &nbsp; &nbsp;2227.804 ms</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Greetings,</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Andres Freund</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >--&nbsp;</font></div><div><font size="2"   >&nbsp;Andres Freund<span>	</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; http://www.2ndQuadrant.com</font></div><div><font size="2"   >&nbsp;PostgreSQL Development, 24x7 Support, Training &amp; Services</font></div><p></p></pre></div><div>6.&nbsp;</div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >+ * toast_get_compress_size_algo -</font></div><div><font size="2"   >+ *</font></div><div><font size="2"   >+ * get metadata about compressed Datum</font></div><div><font size="2"   >+ *</font></div><div><font size="2"   >+ *</font></div><div><font size="2"   >+ * How to disambiguate between compression strategies:</font></div><div><font size="2"   >+ *</font></div><div><font size="2"   >+ * For historical reasons the first 4 bytes of a compressed Datum are used to</font></div><div><font size="2"   >+ * store the raw size of the datum as an unsigned integer. Since the length</font></div><div><font size="2"   >+ * cannot be more than 1GB due to general toast limitations we have the 2 high</font></div><div><font size="2"   >+ * bits to disambiguate whether the Datum has been compressed with the legacy</font></div><div><font size="2"   >+ * pglz or something else. We cannot change the meaning of Datums with the</font></div><div><font size="2"   >+ * first 2 bits unset since we need to support the old ondisk format.</font></div><div><font size="2"   >+ *</font></div><div><font size="2"   >+ * Since earlier our only compression format was pglz, which stored two 0 bits</font></div><div><font size="2"   >+ * we can use those two bits to discern different formats. If the compresion</font></div><div><font size="2"   >+ * format we use has a higher numeric value than 2 we store b11/3 in the high</font></div><div><font size="2"   >+ * bits and use an extra byte for storing the numeric id - 2 in an extra byte.</font></div><div><font size="2"   >+ *</font></div><div><font size="2"   >+ * So storage looks like:</font></div><div><font size="2"   >+ * 1) [4 byte varlena header]</font></div><div><font size="2"   >+ * 2) [4 byte uncompressed length, 2 high bits for algorithm]</font></div><div><font size="2"   >+ * 3) [1 optional byte of algorithm id - 2]</font></div><div><font size="2"   >+ * 4) [compressed data ...]</font></div><div><font size="2"   >+ *</font></div><div><font size="2"   >+ * On little endian the storage for 2) looks like:</font></div><div><font size="2"   >+ * [1st length byte][3rd length byte][2nd length byte][6 bit length][2 bit algorithm]</font></div><div><font size="2"   >+ *</font></div><div><font size="2"   >+ * Due to the 2 high bits only being in the 4th bit we cannot store the</font></div><div><font size="2"   >+ * algorithm in a convenient format if we need more than two bits to represent</font></div><div><font size="2"   >+ * it.</font></div><div><font size="2"   >+ * ----</font></div><div><font size="2"   >+ */</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>