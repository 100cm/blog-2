<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL pgbench BUG or not?</h2>
	<h5 id="">2013-07-24 9:51:36&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201362495136271/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">在测试pgbench 新功能速率限制时. 发现一个疑似pgbench的BUG.<div>无论是否使用rate限速选项都会发生.</div><div>如下 :&nbsp;</div><div>代码版本 :&nbsp;<a rel="nofollow" href="http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=10a509d82956dee14eb2011bd266cd3c728ae188"   >http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=10a509d82956dee14eb2011bd266cd3c728ae188</a><br>使用其他版本测试都有这个问题, 因为计算时间的代码部分是一样的.</div><div>安装后测试 :&nbsp;<wbr></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >vi test.sql</font></div><div><font size="2"   >select 1;</font></div><p></p></pre></div><div>测试结果 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg94@db-172-16-3-33-&gt; pgbench &nbsp;-M prepared -n -r -f ./test.sql -T 10 -c 800 -j 100 digoal</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 800</font></div><div><font size="2"   >number of threads: 100</font></div><div><font size="2"   >duration: 10 s</font></div><div><font size="2"   >number of transactions actually processed: 2037960</font></div><div><font size="2"   >tps = 199534.267305 (including connections establishing)</font></div><div><font size="2"   >tps = 675603.691013 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 1.019046 &nbsp; &nbsp; &nbsp; &nbsp;select 1;</font></div><p></p></pre></div><div>注意当pgbench客户端线程数达到一定值后excluding connections的tps就不准确了.</div><div><span style="line-height: 22px;"   >包含连接时间和不包含连接时间产生的值偏差非常大.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg94@db-172-16-3-33-&gt; pgbench &nbsp;-M prepared -n -r -f ./test.sql -T 10 -c 800 -j 10 digoal</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 800</font></div><div><font size="2"   >number of threads: 10</font></div><div><font size="2"   >duration: 10 s</font></div><div><font size="2"   >number of transactions actually processed: 1035345</font></div><div><font size="2"   >tps = 102285.117970 (including connections establishing)</font></div><div><font size="2"   >tps = 115616.181725 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 6.812371 &nbsp; &nbsp; &nbsp; &nbsp;select 1;</font></div><p></p></pre></div></div><div>当线程数较小时, 结果偏差不大.&nbsp;</div>[分析]<div>1. 包含和不包含连接时间的计算 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span>	</span>tps_include = normal_xacts / time_include;</font></div><div><font size="2"   ><span>	</span>tps_exclude = normal_xacts / (time_include -</font></div><div><font size="2"   ><span>						</span>(INSTR_TIME_GET_DOUBLE(conn_total_time) / nthreads));</font></div><p></p></pre></div><div>因为PostgreSQL采用C-S结构, 新建连接时postgres将为每个连接fork子进程. 10秒的测试时间,大多花在创建连接上. &nbsp;把测试时间延长后这个值会比较靠谱.&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg93@db-172-16-3-33-&gt; pgbench -M prepared -n -r -f ./test.sql -c 160 -j 160 -T 120 digoal&nbsp;</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 160</font></div><div><font size="2"   >number of threads: 160</font></div><div><font size="2"   >duration: 120 s</font></div><div><font size="2"   >number of transactions actually processed: 28424102</font></div><div><font size="2"   >tps = 236795.526880 (including connections establishing)</font></div><div><font size="2"   >tps = 350493.897174 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.438618 &nbsp; &nbsp; &nbsp; &nbsp;select 1;</font></div><p></p></pre></div><div>2. 测试结果同时也说明了PostgreSQL不适合高并发的短连接类型的业务. 如果有这类业务, 请务必使用连接池. 例如pgbouncer, 或者程序的连接池.</div>3. 2013-08-06出的一个补丁, 未解决这个问题, 见一下博文<div><a href="http://blog.163.com/digoal@126/blog/static/1638770402013772212424/"   >http://blog.163.com/digoal@126/blog/static/1638770402013772212424/</a></div></div>
	</div>
</div>
</body>
</html>