<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap Userspace probing - 2</h2>
	<h5 id="">2013-09-30 16:04:26&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020138301545039/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>接上一篇BLOG</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201382941342901/"   >http://blog.163.com/digoal@126/blog/static/163877040201382941342901/</a></div>本文讲一下 Target process mode<wbr><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Target process mode (invoked with stap -c CMD or -x PID) implicitly restricts all process.* probes to the given child process. It does not affect kernel.* or other probe types.&nbsp;</font></div><div><font size="2"   >The CMD string is normally run directly, rather than from a ``/bin/sh -c'' sub-shell, since utrace and uprobe probes receive a fairly "clean" event stream.&nbsp;</font></div><div><font size="2"   >If meta-characters such as redirection operators are present in CMD, ``/bin/sh -c CMD'' is still used, and utrace and uprobe probes will receive events from the shell.</font></div><p></p></pre></div><div>目标进程模式使用方法stap -c CMD或stap -x PID. 使用这种模式可限制探针只在指定进程生效, 对于其他进程不会触发. 注意目标进程模式只限制process.*探针, 其他探针不受此限制, 例如kernel.*, syscall.*不受此限制. 例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-39 ~]# ps -ewf|grep postgres|grep pg94</font></div><div><font size="2"   >pg94 &nbsp; &nbsp; 15967 &nbsp; &nbsp; 1 &nbsp;0 Sep29 ? &nbsp; &nbsp; &nbsp; &nbsp;00:00:00 /home/pg94/pgsql9.4devel/bin/postgres</font></div></div><div><font size="2"   >process.*探针在目标进程模式中, 被限制在目标进程激活.</font></div><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -x 15967 -e 'probe process.syscall {printf("%s, %s, %d\n", pp(), execname(), $syscall); }'</font></div><div><font size="2"   >process.syscall, postgres, 23</font></div></div><div><font size="2"   >其他探针不受-x限制. 如以下的stapio也触发了</font></div><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -x 15967 -e 'probe syscall.* {printf("%s, %s\n", pp(), execname()); exit();}'</font></div><div><font size="2"   >kernel.function("sys_fcntl@fs/fcntl.c:357").call?, stapio</font></div></div><div><font size="2"   >其他探针需要限制target pid的话可以使用if (pid() == target())</font></div><div><font size="2"   >stap -x 15967 -e 'probe syscall.* {if(pid() == target()) {printf("%s, %s\n", pp(), execname()); exit();}}</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >另一个书上的例子 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >% stap -e 'probe process.syscall, process.end {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%s %d %s\n", execname(), pid(), pp())}' \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;-c ls</font></div><div><font size="2"   >Here is the output from this command:</font></div><div><font size="2"   >ls 2323 process.syscall</font></div><div><font size="2"   >ls 2323 process.syscall</font></div><div><font size="2"   >ls 2323 process.end</font></div><p></p></pre></div><div>一般在探针的process("PATH")中PATH指定的是可执行程序, 如果指定的是动态库文件会怎么样呢?</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >If PATH names a shared library, all processes that map that shared library can be probed.&nbsp;</font></div><div><font size="2"   >If dwarf debugging information is installed, try using a command with this syntax:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe process("/lib64/libc-2.8.so").function("....") { ... }</font></div><div><font size="2"   >This command probes all threads that call into that library.&nbsp;</font></div><div><font size="2"   >以上探针表示所有调用到libc-2.8.so这个动态库的进程都被触发, 如果加了.function这限定到函数级别(必须有对应的debufinfo包).</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Typing ``stap -c CMD'' or ``stap -x PID'' restricts this to the target command and descendants only.&nbsp;</font></div><div><font size="2"   >You can use $$vars and others.&nbsp;</font></div><div><font size="2"   >使用目标进程模式时加stap -c或者 -x参数来限定进程. 如果使用了.function函数探针, 同样可以使用$$vars以及其他输出参数, 本地变量等的输出.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >You can provide the location of debug information to the stap command with the -d DIRECTORY option.&nbsp;</font></div><div><font size="2"   >1.8的stap版本中未找到对应的-d DIRECTORY参数.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >To qualify a probe point to a location in a library required by a particular process try using a command with this syntax:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe process("...").library("...").function("....") { ... }</font></div><div><font size="2"   >The library name may use wildcards.</font></div><div><font size="2"   >如果要在探针中限定进程号或者程序名与库文件对应时的触发, 而非目标进程模式的话, 可以使用以上探针语法.</font></div><p></p></pre></div><div>举例 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 lib]# stap --download-debuginfo=yes -e 'probe process("/lib64/ld-2.5.so").function("*") { printf ("%s, %s\n", pp(), execname()); exit(); }'</font></div><div><font size="2"   >WARNING: abrt-action-install-debuginfo-to-abrt-cache is not installed. Continuing without downloading debuginfo.</font></div><div><font size="2"   >WARNING: cannot find module /lib64/ld-2.5.so debuginfo: No DWARF information found</font></div><div><font size="2"   >semantic error: while resolving probe point: identifier 'process' at &lt;input&gt;:1:7</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: probe process("/lib64/ld-2.5.so").function("*") { printf ("%s, %s\n", pp(), execname()); exit(); }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >semantic error: no match</font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div><div><font size="2"   >Missing separate debuginfos, use: debuginfo-install glibc-2.5-65.x86_64</font></div><p></p></pre></div><div>被告知缺少debuginfo.</div><div>换个有debuginfo的动态库</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 lib]# stap --download-debuginfo=yes -e 'probe process("/usr/local/lib/libevent-1.4.so.2.2.0").function("*") { printf ("%s, %s\n", pp(), execname()); } probe timer.s(1) {exit();}'</font></div><div><font size="2"   >WARNING: abrt-action-install-debuginfo-to-abrt-cache is not installed. Continuing without downloading debuginfo.</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("evsignal_process@/opt/soft_bak/libevent-1.4.14b-stable/signal.c:314"), rpc.idmapd</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("timeout_process@/opt/soft_bak/libevent-1.4.14b-stable/event.c:927"), rpc.idmapd</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("gettime@/opt/soft_bak/libevent-1.4.14b-stable/event.c:140"), rpc.idmapd</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("timeout_correct@/opt/soft_bak/libevent-1.4.14b-stable/event.c:892"), rpc.idmapd</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("min_heap_top@/opt/soft_bak/libevent-1.4.14b-stable/min_heap.h:63"), rpc.idmapd</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("timeout_next@/opt/soft_bak/libevent-1.4.14b-stable/event.c:856"), rpc.idmapd</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("gettime@/opt/soft_bak/libevent-1.4.14b-stable/event.c:140"), rpc.idmapd</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("epoll_dispatch@/opt/soft_bak/libevent-1.4.14b-stable/epoll.c:183"), rpc.idmapd</font></div><p></p></pre></div><div>可以输出函数参数, 本地变量等.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 lib]# stap --download-debuginfo=yes -e 'probe process("/usr/local/lib/libevent-1.4.so.2.2.0").function("*") { printf ("%s, %s, %s\n", pp(), execname(), $$vars); } probe timer.s(1) {exit();}'</font></div><div><font size="2"   >WARNING: abrt-action-install-debuginfo-to-abrt-cache is not installed. Continuing without downloading debuginfo.</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("evsignal_process@/opt/soft_bak/libevent-1.4.14b-stable/signal.c:314"), rpc.idmapd, base=0x2b27590e74f0 sig=? ev=? next_ev=? ncalls=? i=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("timeout_process@/opt/soft_bak/libevent-1.4.14b-stable/event.c:927"), rpc.idmapd, base=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("gettime@/opt/soft_bak/libevent-1.4.14b-stable/event.c:140"), rpc.idmapd, base=0x2b27590e74f0 tp=0x2b27590e7b08</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("timeout_correct@/opt/soft_bak/libevent-1.4.14b-stable/event.c:892"), rpc.idmapd, tv=? base=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("min_heap_top@/opt/soft_bak/libevent-1.4.14b-stable/min_heap.h:63"), rpc.idmapd, s=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("timeout_next@/opt/soft_bak/libevent-1.4.14b-stable/event.c:856"), rpc.idmapd, tv_p=? base=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("gettime@/opt/soft_bak/libevent-1.4.14b-stable/event.c:140"), rpc.idmapd, base=0x2b27590e74f0 tp=0x2b27590e7ae8</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("epoll_dispatch@/opt/soft_bak/libevent-1.4.14b-stable/epoll.c:183"), rpc.idmapd, base=0x2b27590e74f0 arg=0x2b27590e6170 tv=0x0 epollop=? events=? evep=? i=? res=? timeout=?</font></div><p></p></pre></div><div>对应的进程如下</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 lib]# which rpc.idmapd</font></div><div><font size="2"   >/usr/sbin/rpc.idmapd</font></div><p></p></pre></div><div>使用目标进程模式</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-39 lib]# ps -ewf|grep rpc.idmapd</font></div><div><font size="2"   >root &nbsp; &nbsp; &nbsp;3299 &nbsp; &nbsp; 1 &nbsp;0 Sep26 ? &nbsp; &nbsp; &nbsp; &nbsp;00:00:00 rpc.idmapd</font></div></div><div><div><font size="2"   >[root@db-172-16-3-39 lib]# stap -x 3299 -e 'probe process("/usr/local/lib/libevent-1.4.so.2.2.0").function("*") { printf ("%s, %s, %s\n", pp(), execname(), $$vars); } probe timer.s(1) {exit();}'</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("evsignal_process@/opt/soft_bak/libevent-1.4.14b-stable/signal.c:314"), rpc.idmapd, base=0x2b27590e74f0 sig=? ev=? next_ev=? ncalls=? i=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("timeout_process@/opt/soft_bak/libevent-1.4.14b-stable/event.c:927"), rpc.idmapd, base=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("gettime@/opt/soft_bak/libevent-1.4.14b-stable/event.c:140"), rpc.idmapd, base=0x2b27590e74f0 tp=0x2b27590e7b08</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("timeout_correct@/opt/soft_bak/libevent-1.4.14b-stable/event.c:892"), rpc.idmapd, tv=? base=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("min_heap_top@/opt/soft_bak/libevent-1.4.14b-stable/min_heap.h:63"), rpc.idmapd, s=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("timeout_next@/opt/soft_bak/libevent-1.4.14b-stable/event.c:856"), rpc.idmapd, tv_p=? base=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("gettime@/opt/soft_bak/libevent-1.4.14b-stable/event.c:140"), rpc.idmapd, base=0x2b27590e74f0 tp=0x2b27590e7ae8</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("epoll_dispatch@/opt/soft_bak/libevent-1.4.14b-stable/epoll.c:183"), rpc.idmapd, base=0x2b27590e74f0 arg=0x2b27590e6170 tv=0x0 epollop=? events=? evep=? i=? res=? timeout=?</font></div></div><p></p></pre></div><div>在探针中限制进程:&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 lib]# stap -e 'probe process("/usr/sbin/rpc.idmapd").library("/usr/local/lib/libevent-1.4.so.2.2.0").function("*") { printf ("%s, %s, %s\n", pp(), execname(), $$vars); } probe timer.s(1) {exit();}'</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("evsignal_process@/opt/soft_bak/libevent-1.4.14b-stable/signal.c:314"), rpc.idmapd, base=0x2b27590e74f0 sig=? ev=? next_ev=? ncalls=? i=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("timeout_process@/opt/soft_bak/libevent-1.4.14b-stable/event.c:927"), rpc.idmapd, base=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("gettime@/opt/soft_bak/libevent-1.4.14b-stable/event.c:140"), rpc.idmapd, base=0x2b27590e74f0 tp=0x2b27590e7b08</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("timeout_correct@/opt/soft_bak/libevent-1.4.14b-stable/event.c:892"), rpc.idmapd, tv=? base=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("min_heap_top@/opt/soft_bak/libevent-1.4.14b-stable/min_heap.h:63"), rpc.idmapd, s=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("timeout_next@/opt/soft_bak/libevent-1.4.14b-stable/event.c:856"), rpc.idmapd, tv_p=? base=?</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("gettime@/opt/soft_bak/libevent-1.4.14b-stable/event.c:140"), rpc.idmapd, base=0x2b27590e74f0 tp=0x2b27590e7ae8</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").function("epoll_dispatch@/opt/soft_bak/libevent-1.4.14b-stable/epoll.c:183"), rpc.idmapd, base=0x2b27590e74f0 arg=0x2b27590e6170 tv=0x0 epollop=? events=? evep=? i=? res=? timeout=?</font></div><p></p></pre></div><div><br></div><div>程序链表探针 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >The first syntax in the following will probe the <u>functions in the program linkage table of a particular process</u>.&nbsp;</font></div><div><font size="2"   >The second syntax will also add <u>the program linkage tables of libraries required by that process</u>.&nbsp;</font></div><div><font size="2"   >.plt("...") can be specified to match particular plt entries.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe process("...").plt { ... }</font></div><div><font size="2"   >probe process("...").plt process("...").library("...").plt { ... }</font></div><p></p></pre></div><div>举例 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 lib]# stap -e 'probe process("/usr/sbin/rpc.idmapd").library("/usr/local/lib/libevent-1.4.so.2.2.0").plt { printf ("%s, %s\n", pp(), execname()); } probe timer.s(1) {exit();}'</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").statement(0x5080)?, rpc.idmapd</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").statement(0x50a0)?, rpc.idmapd</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").statement(0x5350)?, rpc.idmapd</font></div><div><font size="2"   >process("/usr/local/lib/libevent-1.4.so.2.2.0").statement(0x5160)?, rpc.idmapd</font></div><p></p></pre></div><div><br></div><div><div><pre class="prettyprint"   ><div><font size="2"   >[root@db-172-16-3-39 lib]# objdump -d /usr/local/lib/libevent-1.4.so.2.2.0|grep -E "5080|50a0|5350|5160"</font></div><div><font size="2"   >0000000000005080 &lt;__errno_location@plt&gt;:</font></div><div><font size="2"   >&nbsp; &nbsp; 5080: &nbsp; &nbsp; &nbsp; ff 25 c2 41 21 00 &nbsp; &nbsp; &nbsp; jmpq &nbsp; *2179522(%rip) &nbsp; &nbsp; &nbsp; &nbsp;# 219248 &lt;_GLOBAL_OFFSET_TABLE_+0x380&gt;</font></div><div><font size="2"   >00000000000050a0 &lt;evsignal_process@plt&gt;:</font></div><div><font size="2"   >&nbsp; &nbsp; 50a0: &nbsp; &nbsp; &nbsp; ff 25 b2 41 21 00 &nbsp; &nbsp; &nbsp; jmpq &nbsp; *2179506(%rip) &nbsp; &nbsp; &nbsp; &nbsp;# 219258 &lt;_GLOBAL_OFFSET_TABLE_+0x390&gt;</font></div><div><font size="2"   >0000000000005160 &lt;epoll_wait@plt&gt;:</font></div><div><font size="2"   >&nbsp; &nbsp; 5160: &nbsp; &nbsp; &nbsp; ff 25 52 41 21 00 &nbsp; &nbsp; &nbsp; jmpq &nbsp; *2179410(%rip) &nbsp; &nbsp; &nbsp; &nbsp;# 2192b8 &lt;_GLOBAL_OFFSET_TABLE_+0x3f0&gt;</font></div><div><font size="2"   >0000000000005350 &lt;clock_gettime@plt&gt;:</font></div><div><font size="2"   >&nbsp; &nbsp; 5350: &nbsp; &nbsp; &nbsp; ff 25 5a 40 21 00 &nbsp; &nbsp; &nbsp; jmpq &nbsp; *2179162(%rip) &nbsp; &nbsp; &nbsp; &nbsp;# 2193b0 &lt;_GLOBAL_OFFSET_TABLE_+0x4e8&gt;</font></div><p></p></pre></div></div><div><br></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 23px;" href="http://blog.163.com/digoal@126/blog/static/163877040201382941342901/"   >http://blog.163.com/digoal@126/blog/static/163877040201382941342901/</a></div><div>2.&nbsp;<a style="line-height: 23px;" rel="nofollow" href="http://docs.oracle.com/cd/E22055_01/html/821-2505/afamv.html"   >http://docs.oracle.com/cd/E22055_01/html/821-2505/afamv.html</a></div><div>3.&nbsp;<a style="line-height: 23px;" rel="nofollow" href="http://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html"   >http://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html</a></div><div>4.&nbsp;<a style="line-height: 23px;" rel="nofollow" href="http://stackoverflow.com/questions/9688076/process-linkage-table-and-global-offset-table"   >http://stackoverflow.com/questions/9688076/process-linkage-table-and-global-offset-table</a></div><div>5. man readelf</div><div>6. man nm</div><div>7. man objdump</div><div>8.&nbsp;</div><div><div>共享对象之间的函数调用</div><div>一个共享对象中的函数调用另一个共享对象中的函数时，其执行情况比在程序内对函数的简单调用更复杂。每个共享对象都包含一个程序链接表 (Program Linkage Table, PLT)，该表包含位于该共享对象外部并从该共享对象引用的每个函数的条目。最初，PLT 中每个外部函数的地址实际上是 ld.so（即动态链接程序）内的地址。第一次调用这样的函数时，控制权将转移到动态链接程序，该动态链接程序会解析对实际外部函数的调用并为后续调用修补 PLT 地址。</div><div><br></div><div>如果在执行三个 PLT 指令之一的过程中发生分析事件，则 PLT PC 会被删除，并将独占时间归属到调用指令。如果在通过 PLT 条目首次调用期间发生分析事件，但是叶 PC 不是 PLT 指令之一，PLT 和 ld.so 中的代码引起的任何 PC 都将归属到人工函数 @plt 中，该函数将累计非独占时间。每个共享对象都存在一个这样的人工函数。如果程序使用 LD_AUDIT 接口，则可能从不修补 PLT 条目，而且来自 @plt 的非叶 PC 可能发生得更频繁。</div></div></div>
	</div>
</div>
</body>
</html>