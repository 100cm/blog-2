<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL drop|clear shared buffer with specific database or filenode</h2>
	<h5 id="">2013-09-14 17:06:36&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020138141447693/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>用过Oracle的同学应该知道oracle可以通过sql清除shared buffer中的数据.</div><div>有网友问过我这个问题, 找了一下互联网, 国外也有朋友关心过这样的问题. 摘录如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Is there a particular one of Oracle's memory clearning features you want to use in PostgreSQL? In Oracle you cannot flush the entire SGA without a restart, but you can flush three parts of the SGA using three separate commands.</font></div><div><font size="2"   >1. In Oracle you can flush the redo buffer by issuing a COMMIT or by rotating the logs. You can force a log switch in PostgreSQL using "select pg_switch_xlog();".</font></div><div><font size="2"   >2. In Oracle when you flush the shared pool this does three things: (a) removes sql and pl/sql statements from the shared library cache, (b) flushes the dictionary cache of object info and security data, and (c) flushes the query result cache (11g only). I am relatively new to PostgreSQL and have not seen an equivalent in PostgreSQL to these things. Based on other replies it does not seem possible to flush the catalog cache in PostgreSQL.</font></div><div><font size="2"   >3. In Oracle when you request a flush of the buffer cache it signals a checkpoint to ensure all dirty buffers are written out AND later it will remove the dirty buffers from memory. This can take anywhere from a few seconds on very small systems to several minutes on VLDB systems, per my observations. The Oracle checkpoint is fast, and the SQL prompt comes back very fast, but the removal of dirty buffers from memory runs in the background with a low priority over a long period of time. If you are planning to use "alter system flush buffer_cache" to clear memory in between tests you actually have no way to know when memory is clear except to wait a long time and then assume all is well (yes, this is also true with ASM and direct i/o to raw devices). In PostgreSQL, you can checkpoint manually to signal bgwriter to flush dirty pages to the operating system's cache and from there you will see a lazy write to disk (e.g., watch pdflush on linux), so immediately re-running a query will still get some caching benefits eventhough the checkpoint is complete. There are operating system commands that you could use for that ("cat /proc/meminfo" to see what's there, "sync" to write dirty pages to disk, then "echo 3 &gt; /proc/sys/vm/drop_caches" to remove the now clean pages, and then "cat /proc/meminfo" one more time). And, if you are using SAN consider array based caching as well.</font></div><div><font size="2"   >Sincerely,</font></div><div><font size="2"   >Mark R. Johnson</font></div><div><font size="2"   >Owner, Remington Database Solutions, LLC</font></div><div><font size="2"   >Author, Oracle Database 10g: From Nuts to Soup</font></div><p></p></pre></div><div>PostgreSQL目前没有提供安全的清除掉shared buffer中的内容的SQL或者接口.</div><div>老唐曾经写过一篇文章测试清理(为什么不叫flush呢?因为是直接drop的, 没有flush的动作)postgresql shared buffer, 由于"手段相当残忍", 开个玩笑, 意思就是说别在生产上这么搞, 因为是用了PG truncate table或者drop database时用到的直接丢弃缓存的做法. 不考虑是否dirty, 是否需要flush到disk. 确实有点残忍.</div><div>如果要清除shared buffer中的内容, 为了安全, 需要确保这个buffer是clear的, 而不是dirty的.&nbsp;</div><div>PostgreSQL自带一个插件名为pg_buffercache, 可以查看当前shared buffer中内容, 如下.&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from pg_buffercache limit 6;</font></div><div><font size="2"   >&nbsp;bufferid | relfilenode | reltablespace | reldatabase | relforknumber | relblocknumber | isdirty | usagecount&nbsp;</font></div><div><font size="2"   >----------+-------------+---------------+-------------+---------------+----------------+---------+------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 12691 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1664 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 12449 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1664 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 3 | &nbsp; &nbsp; &nbsp; 12464 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 4 | &nbsp; &nbsp; &nbsp; 12464 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 5 | &nbsp; &nbsp; &nbsp; 12464 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 6 | &nbsp; &nbsp; &nbsp; 12464 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><p></p></pre></div><div><span style="line-height: 23px;"   >pg_buffercache中遍历了整个shared buffer, 所以有多大的shared buffer, 这里就有多少记录.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select count(*) from pg_buffercache;</font></div><div><font size="2"   >&nbsp;count &nbsp;</font></div><div><font size="2"   >--------</font></div><div><font size="2"   >&nbsp;262144</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>所以这个值刚好等于shared buffer配置的值.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select name,setting,unit from pg_settings where name ~ 'shared';</font></div><div><font size="2"   >-[ RECORD 1 ]---------------------</font></div><div><font size="2"   >name &nbsp; &nbsp;| shared_buffers</font></div><div><font size="2"   >setting | 262144</font></div><div><font size="2"   >unit &nbsp; &nbsp;| 8kB</font></div><p></p></pre></div><div><br></div><div>接下来进入正题, 如何清除shared buffer呢?</div><div><span style="line-height: 23px;"   >本文的做法是通过修改pg_buffercache, 添加清除shared buffer的几个函数(也是用到老唐提到的那两个函数, 同时增加清除缓存列表的功能), 当然手段也比一样残忍, 请勿在生产中使用.</span></div><div><span style="line-height: 23px;"   >代码修改如下 :&nbsp;</span></div><div>cd&nbsp;postgresql-9.1.1/contrib/pg_buffercache</div><div>vi pg_buffercache--1.0.sql</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/* contrib/pg_buffercache/pg_buffercache--1.0.sql */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >-- Register the function.</font></div><div><font size="2"   >CREATE FUNCTION pg_buffercache_pages()</font></div><div><font size="2"   >RETURNS SETOF RECORD</font></div><div><font size="2"   >AS 'MODULE_PATHNAME', 'pg_buffercache_pages'</font></div><div><font size="2"   >LANGUAGE C;</font></div><div><font size="2"   >-- add by digoal</font></div><div><font size="2"   >CREATE FUNCTION pg_flush_database(dbid oid)</font></div><div><font size="2"   >RETURNS void</font></div><div><font size="2"   >AS 'MODULE_PATHNAME', 'pg_flush_database'</font></div><div><font size="2"   >LANGUAGE C;</font></div><div><span style="line-height: 23px;"   ><font size="2"   >-- add by digoal</font></span></div><div><font size="2"   >CREATE FUNCTION pg_flush_filenode(spc oid, db oid, filenode oid)</font></div><div><font size="2"   >RETURNS void</font></div><div><font size="2"   >AS 'MODULE_PATHNAME', 'pg_flush_filenode'</font></div><div><font size="2"   >LANGUAGE C;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >-- Create a view for convenient access.</font></div><div><font size="2"   >CREATE VIEW pg_buffercache AS</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SELECT P.* FROM pg_buffercache_pages() AS P</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; (bufferid integer, relfilenode oid, reltablespace oid, reldatabase oid,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;relforknumber int2, relblocknumber int8, isdirty bool, usagecount int2);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >-- Don't want these to be available to public.</font></div><div><font size="2"   >REVOKE ALL ON FUNCTION pg_buffercache_pages() FROM PUBLIC;</font></div><div><font size="2"   >REVOKE ALL ON pg_buffercache FROM PUBLIC;</font></div><div><span style="line-height: 23px;"   ><font size="2"   >-- add by digoal</font></span></div><div><font size="2"   >REVOKE ALL ON FUNCTION pg_flush_database(oid) FROM PUBLIC;</font></div><div><font size="2"   >REVOKE ALL ON FUNCTION pg_flush_filenode(oid,oid,oid) FROM PUBLIC;</font></div><p></p></pre></div></div><div><br></div><div>vi&nbsp;pg_buffercache_pages.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >#include "utils/relcache.h"</font></div><div><font size="2"   >// add by digoal</font></div><div><font size="2"   >#include "utils/inval.h"</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >Datum &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_buffercache_pages(PG_FUNCTION_ARGS);</font></div><div><font size="2"   >// add by digoal</font></div><div><font size="2"   >void &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pg_flush_database(PG_FUNCTION_ARGS);</font></div><div><font size="2"   >void &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pg_flush_filenode(PG_FUNCTION_ARGS);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >PG_FUNCTION_INFO_V1(pg_buffercache_pages);</font></div><div><font size="2"   >// add by digoal</font></div><div><font size="2"   >PG_FUNCTION_INFO_V1(pg_flush_database);</font></div><div><font size="2"   >PG_FUNCTION_INFO_V1(pg_flush_filenode);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >void</font></div><div><font size="2"   >pg_flush_database(PG_FUNCTION_ARGS)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; DropDatabaseBuffers(PG_GETARG_OID(0));</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><span style="line-height: 20px;"   >// 这几个参数很好理解, 就是表空间id, 数据库id, 以及filenode.</span></font></div><div><font size="2"   >void</font></div><div><font size="2"   >pg_flush_filenode(PG_FUNCTION_ARGS)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; RelFileNodeBackend v_nb;</font></div><div><font size="2"   >&nbsp; v_nb.backend=InvalidBackendId;</font></div><div><font size="2"   >&nbsp; v_nb.node.spcNode=PG_GETARG_OID(0);</font></div><div><font size="2"   >&nbsp; v_nb.node.dbNode=PG_GETARG_OID(1);</font></div><div><font size="2"   >&nbsp; v_nb.node.relNode=PG_GETARG_OID(2);</font></div><div><font size="2"   >&nbsp; DropRelFileNodeBuffers(v_nb, MAIN_FORKNUM, 0);</font></div><div><font size="2"   >&nbsp; CacheInvalidateSmgr(v_nb);</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div>编译安装 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >su - root</font></div><div><font size="2"   >export PATH=/opt/pgsql/bin:$PATH</font></div><div><div><font size="2"   >which pg_config</font></div><div><font size="2"   >/opt/pgsql/bin/pg_config</font></div></div><div><font size="2"   >gmake clean</font></div><div><font size="2"   >gmake</font></div><div><font size="2"   >gmake install</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >su - postgres</font></div><div><font size="2"   >pg_ctl restart</font></div><div><font size="2"   >psql digoal postgres</font></div><div><font size="2"   >create extension pg_buffercache;</font></div><div><font size="2"   >\df</font></div><div><div><font size="2"   >&nbsp;public | pg_buffercache_pages &nbsp; &nbsp; | SETOF record &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;| normal</font></div><div><font size="2"   >&nbsp;public | pg_flush_database &nbsp; &nbsp; &nbsp; &nbsp;| void &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | dbid oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;| normal</font></div><div><font size="2"   >&nbsp;public | pg_flush_filenode &nbsp; &nbsp; &nbsp; &nbsp;| void &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | spc oid, db oid, filenode oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;| normal</font></div></div><p></p></pre></div><div>清缓存测试 :&nbsp;</div><div>创建测试表</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table t2(id int);</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>插入测试数据</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# insert into t2 select generate_series(1,1000);</font></div><div><font size="2"   >INSERT 0 1000</font></div><p></p></pre></div></div><div>查找数据库oid, 要用于查找shared buffer信息.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select oid from pg_database where datname ='digoal';</font></div><div><font size="2"   >&nbsp; oid &nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;12698</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>查找刚才创建的测试表在shared buffer中的信息, 可以看到有7个数据块. 有一些是脏的数据块</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from pg_buffercache where reldatabase=12698 and relfilenode=pg_relation_filenode('t2'::regclass) order by relblocknumber;</font></div><div><font size="2"   >&nbsp;bufferid | relfilenode | reltablespace | reldatabase | relforknumber | relblocknumber | isdirty | usagecount&nbsp;</font></div><div><font size="2"   >----------+-------------+---------------+-------------+---------------+----------------+---------+------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 298 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 296 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 | t &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 299 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 | t &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 297 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 300 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 | t &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 301 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 | t &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 302 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 | t &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >(7 rows)</font></div><p></p></pre></div><div>为了安全的把他们从shared buffer中剔除, 先做一次checkpoint , 把脏数据库写到磁盘, (其实这样还不是最安全的, 最好再把这个表给锁了, 不让任何程序操作它, 这里就不演示了.)</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# checkpoint;</font></div><div><font size="2"   >CHECKPOINT</font></div><p></p></pre></div><div>执行完checkpoint后, 这个表的数据都变成clean的了, isdirty=f;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from pg_buffercache where reldatabase=12698 and relfilenode=pg_relation_filenode('t2'::regclass) order by relblocknumber;</font></div><div><font size="2"   >&nbsp;bufferid | relfilenode | reltablespace | reldatabase | relforknumber | relblocknumber | isdirty | usagecount&nbsp;</font></div><div><font size="2"   >----------+-------------+---------------+-------------+---------------+----------------+---------+------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 298 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 296 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 299 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 297 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 300 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 301 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 302 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >(7 rows)</font></div><p></p></pre></div></div><div>接下来就可以用<span style="line-height: 23px;"   >pg_flush_filenode这个函数来清除它的缓存了. 输入spcid, dbid, filenodeid. (这些信息在上面都有了 )</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select pg_flush_filenode(1663,12698,1412335);</font></div><div><font size="2"   >&nbsp;pg_flush_filenode&nbsp;</font></div><div><font size="2"   >-------------------</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>清除完后再次查看, 还有两条记录, 怎么回事呢?</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from pg_buffercache where reldatabase=12698 and relfilenode=pg_relation_filenode('t2'::regclass) order by relblocknumber;</font></div><div><font size="2"   >&nbsp;bufferid | relfilenode | reltablespace | reldatabase | relforknumber | relblocknumber | isdirty | usagecount&nbsp;</font></div><div><font size="2"   >----------+-------------+---------------+-------------+---------------+----------------+---------+------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 298 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; 297 | &nbsp; &nbsp; 1412335 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1663 | &nbsp; &nbsp; &nbsp; 12698 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div></div><div>因为我们的代码中固定了只清除mainfork, 不清除fsm和visibility map.</div><div>如果要清除另外两个, 可以修改一下代码(把<span style="line-height: 23px;"   >relforknumber</span>=0,1,2的都清除掉).</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >void</font></div><div><font size="2"   >pg_flush_filenode(PG_FUNCTION_ARGS)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; RelFileNodeBackend v_nb;</font></div><div><font size="2"   >&nbsp; v_nb.backend=InvalidBackendId;</font></div><div><font size="2"   >&nbsp; v_nb.node.spcNode=PG_GETARG_OID(0);</font></div><div><font size="2"   >&nbsp; v_nb.node.dbNode=PG_GETARG_OID(1);</font></div><div><font size="2"   >&nbsp; v_nb.node.relNode=PG_GETARG_OID(2);</font></div><div><font size="2"   >&nbsp; DropRelFileNodeBuffers(v_nb, MAIN_FORKNUM, 0);</font></div><div><font size="2"   >&nbsp; DropRelFileNodeBuffers(v_nb,&nbsp;FSM_FORKNUM, 0);</font></div><div><font size="2"   >&nbsp; DropRelFileNodeBuffers(v_nb,&nbsp;VISIBILITYMAP_FORKNUM, 0);</font></div><div><font size="2"   >&nbsp; CacheInvalidateSmgr(v_nb);</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >gmake</font></div><div><font size="2"   >gmake install</font></div><p></p></pre></div><div>这样就可以了.</div><div>另一种测试方法, 把大表的OS cache清除后, 但是不清除pg shared buffer, 查询速度还是很快.</div><div>第一次查询</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select count(*) from t2;</font></div><div><font size="2"   >&nbsp; count &nbsp;&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;10003000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 3197.338 ms</font></div><p></p></pre></div><div>第二次查询</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select count(*) from t2;</font></div><div><font size="2"   >&nbsp; count &nbsp;&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;10003000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 1324.868 ms</font></div><p></p></pre></div><div>查看有多少个块在shared buffer中.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select count(*) from pg_buffercache where reldatabase=12698 and relfilenode=pg_relation_filenode('t2'::regclass);</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;44262</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 147.996 ms</font></div><p></p></pre></div><div>shared buffer中的数据块和这个表的大小相当</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select 44274*8*1024;</font></div><div><font size="2"   >&nbsp;?column? &nbsp;</font></div><div><font size="2"   >-----------</font></div><div><font size="2"   >&nbsp;362692608</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 0.108 ms</font></div><div><font size="2"   >postgres=# select pg_relation_size('t2'::regclass);</font></div><div><font size="2"   >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 362594304</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 0.752 ms</font></div><p></p></pre></div><div>清除os 缓存 :&nbsp;</div><pre class="prettyprint"   ><p></p><div><font size="2"   ># echo 3 &gt; /proc/sys/vm/drop_caches</font></div><div></div><p></p></pre><div><span style="line-height: 23px;"   >再次查询, 速度还是很快, 因为shared buffer还没有清除.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select count(*) from t2;</font></div><div><font size="2"   >&nbsp; count &nbsp;&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;10003000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 1324.843 ms</font></div><p></p></pre></div><div><br></div><div>只有当<span style="line-height: 23px;"   >OS cache和pg shared buffer都清除后查询速度才会下降(因为落到磁盘了).</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 23px;"   ><font size="2"   ># echo 3 &gt; /proc/sys/vm/drop_caches</font></span></div><div><div><font size="2"   >postgres=# select pg_flush_filenode(1663,12698,relfilenode) from (select distinct relfilenode from pg_buffercache where reldatabase=12698 and relfilenode=pg_relation_filenode('t2'::regclass))t;</font></div><div><font size="2"   >&nbsp;pg_flush_filenode&nbsp;</font></div><div><font size="2"   >-------------------</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 184.753 ms</font></div></div><p></p></pre></div><div>都清除后, 速度降了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select count(*) from t2;</font></div><div><font size="2"   >&nbsp; count &nbsp;&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;10003000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 3191.493 ms</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 23px;"   >[参考]</span></div><wbr><div>1.&nbsp;<a style="line-height: 23px;" rel="nofollow" href="http://grokbase.com/t/postgresql/pgsql-general/115373p5n4/can-we-flush-the-postgres-shared-memory"   >http://grokbase.com/t/postgresql/pgsql-general/115373p5n4/can-we-flush-the-postgres-shared-memory</a></div><div>2.&nbsp;<a style="line-height: 23px;" rel="nofollow" href="http://stackoverflow.com/questions/1216660/see-and-clear-postgres-caches-buffers"   >http://stackoverflow.com/questions/1216660/see-and-clear-postgres-caches-buffers</a></div><div>3.&nbsp;<a style="line-height: 23px;" rel="nofollow" href="http://www.kennygorman.com/wordpress/?p=250"   >http://www.kennygorman.com/wordpress/?p=250</a></div><div>4.&nbsp;<a style="line-height: 23px;" rel="nofollow" href="http://linux-mm.org/Drop_Caches"   >http://linux-mm.org/Drop_Caches</a></div><div>5.&nbsp;<a style="line-height: 23px;" rel="nofollow" href="http://blog.osdba.net/?p=90"   >http://blog.osdba.net/?p=90</a></div><div>6.&nbsp;src/backend/storage/buffer/bufmgr.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/* ---------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DropRelFileNodeBuffers</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This function removes from the buffer pool all the pages of the</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;specified relation that have block numbers &gt;= firstDelBlock.</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(In particular, with firstDelBlock = 0, all pages are removed.)</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Dirty pages are simply dropped, without bothering to write them</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;out first. &nbsp; &nbsp; &nbsp;Therefore, this is NOT rollback-able, and so should be</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;used only with extreme caution!</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Currently, this is called only from smgr.c when the underlying file</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;is about to be deleted or truncated (firstDelBlock is needed for</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the truncation case). &nbsp;The data in the affected pages would therefore</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;be deleted momentarily anyway, and there is no point in writing it.</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;It is the responsibility of higher-level code to ensure that the</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;deletion or truncation does not lose any data that could be needed</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;later. &nbsp;It is also the responsibility of higher-level code to ensure</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;that no other process could be trying to load more pages of the</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;relation into buffers.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XXX currently it sequentially searches the buffer pool, should be</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;changed to more clever ways of searching. &nbsp;However, this routine</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;is used only in code paths that aren't very performance-critical,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and we shouldn't slow down the hot paths to make it faster ...</font></div><div><font size="2"   >&nbsp;* --------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >DropRelFileNodeBuffers(RelFileNodeBackend rnode, ForkNumber forkNum,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BlockNumber firstDelBlock)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (rnode.backend != InvalidBackendId)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (rnode.backend == MyBackendId)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DropRelFileNodeLocalBuffers(rnode.node, forkNum, firstDelBlock);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; NBuffers; i++)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; volatile BufferDesc *bufHdr = &amp;BufferDescriptors[i];</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockBufHdr(bufHdr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (RelFileNodeEquals(bufHdr-&gt;tag.rnode, rnode.node) &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufHdr-&gt;tag.forkNum == forkNum &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufHdr-&gt;tag.blockNum &gt;= firstDelBlock)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidateBuffer(bufHdr); &nbsp; &nbsp; &nbsp; /* releases spinlock */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* ---------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DropDatabaseBuffers</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This function removes all the buffers in the buffer cache for a</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;particular database. &nbsp;Dirty pages are simply dropped, without</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bothering to write them out first. &nbsp; &nbsp; &nbsp;This is used when we destroy a</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;database, to avoid trying to flush data to disk when the directory</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tree no longer exists. &nbsp;Implementation is pretty similar to</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DropRelFileNodeBuffers() which is for destroying just one relation.</font></div><div><font size="2"   >&nbsp;* --------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >DropDatabaseBuffers(Oid dbid)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; volatile BufferDesc *bufHdr;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We needn't consider local buffers, since by assumption the target</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* database isn't our own.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div></div><div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; NBuffers; i++)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufHdr = &amp;BufferDescriptors[i];</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockBufHdr(bufHdr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (bufHdr-&gt;tag.rnode.dbNode == dbid)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidateBuffer(bufHdr); &nbsp; &nbsp; &nbsp; /* releases spinlock */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UnlockBufHdr(bufHdr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><br></div><div>7.&nbsp;src/backend/storage/smgr/smgr.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;smgrtruncate() -- Truncate supplied relation to the specified number</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;of blocks</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The truncation is done immediately, so this can't be rolled back.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >smgrtruncate(SMgrRelation reln, ForkNumber forknum, BlockNumber nblocks)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Get rid of any buffers for the about-to-be-deleted blocks. bufmgr will</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* just drop them without bothering to write the contents.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; DropRelFileNodeBuffers(reln-&gt;smgr_rnode, forknum, nblocks);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Send a shared-inval message to force other backends to close any smgr</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* references they may have for this rel. &nbsp;This is useful because they</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* might have open file pointers to segments that got removed, and/or</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* smgr_targblock variables pointing past the new rel end. &nbsp; &nbsp; &nbsp;(The inval</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* message will come back to our backend, too, causing a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* probably-unnecessary local smgr flush. &nbsp;But we don't expect that this</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* is a performance-critical path.) &nbsp;As in the unlink code, we want to be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* sure the message is sent before we start changing things on-disk.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CacheInvalidateSmgr(reln-&gt;smgr_rnode);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Do the truncation.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; (*(smgrsw[reln-&gt;smgr_which].smgr_truncate)) (reln, forknum, nblocks);</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>8.&nbsp;utils/inval.h</div><div><br></div><div>9.&nbsp;src/backend/utils/cache/inval.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* CacheInvalidateSmgr</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Register invalidation of smgr references to a physical relation.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Sending this type of invalidation msg forces other backends to close open</font></div><div><font size="2"   >&nbsp;* smgr entries for the rel. &nbsp;This should be done to flush dangling open-file</font></div><div><font size="2"   >&nbsp;* references when the physical rel is being dropped or truncated. &nbsp; &nbsp; &nbsp;Because</font></div><div><font size="2"   >&nbsp;* these are nontransactional (i.e., not-rollback-able) operations, we just</font></div><div><font size="2"   >&nbsp;* send the inval message immediately without any queuing.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: in most cases there will have been a relcache flush issued against</font></div><div><font size="2"   >&nbsp;* the rel at the logical level. &nbsp;We need a separate smgr-level flush because</font></div><div><font size="2"   >&nbsp;* it is possible for backends to have open smgr entries for rels they don't</font></div><div><font size="2"   >&nbsp;* have a relcache entry for, e.g. because the only thing they ever did with</font></div><div><font size="2"   >&nbsp;* the rel is write out dirty shared buffers.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: because these messages are nontransactional, they won't be captured</font></div><div><font size="2"   >&nbsp;* in commit/abort WAL entries. &nbsp;Instead, calls to CacheInvalidateSmgr()</font></div><div><font size="2"   >&nbsp;* should happen in low-level smgr.c routines, which are executed while</font></div><div><font size="2"   >&nbsp;* replaying WAL as well as when creating it.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: In order to avoid bloating SharedInvalidationMessage, we store only</font></div><div><font size="2"   >&nbsp;* three bytes of the backend ID using what would otherwise be padding space.</font></div><div><font size="2"   >&nbsp;* Thus, the maximum possible backend ID is 2^23-1.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >CacheInvalidateSmgr(RelFileNodeBackend rnode)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SharedInvalidationMessage msg;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; msg.sm.id = SHAREDINVALSMGR_ID;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; msg.sm.backend_hi = rnode.backend &gt;&gt; 16;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; msg.sm.backend_lo = rnode.backend &amp; 0xffff;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; msg.sm.rnode = rnode.node;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SendSharedInvalidMessages(&amp;msg, 1);</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>10.&nbsp;src/include/storage/relfilenode.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* The physical storage of a relation consists of one or more forks. The</font></div><div><font size="2"   >&nbsp;* main fork is always created, but in addition to that there can be</font></div><div><font size="2"   >&nbsp;* additional forks for storing various metadata. ForkNumber is used when</font></div><div><font size="2"   >&nbsp;* we need to refer to a specific fork in a relation.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef enum ForkNumber</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; InvalidForkNumber = -1,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; MAIN_FORKNUM = 0,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FSM_FORKNUM,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; VISIBILITYMAP_FORKNUM,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; INIT_FORKNUM</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* NOTE: if you add a new fork, change MAX_FORKNUM below and update the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* forkNames array in catalog.c</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >} ForkNumber;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define MAX_FORKNUM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INIT_FORKNUM</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>