<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">systemtap probe aliases (Prologue-style = & Epilogue-style +=) and suffixes</h2>
	<h5 id="">2013-09-12 12:59:43&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201381210355655/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>前面我们多次用到的tapset, 其实就是一堆function和probe alias的定义.</div><div>例如 :&nbsp;<span style="line-height: 22px;"   >/usr/share/systemtap/tapset/syscalls2.stp中的probe syscall.read, 就是一个alias.</span></div><div><span style="line-height: 22px;"   >本文要讲的也是probe alias.</span></div><div><span style="line-height: 22px;"   >probe alias分2种, 1种是把alias中定义的handler加到底层probe point handler的前面, 另一种是把handler加到末尾.</span></div><div>分别为 Prologue-style = &amp; Epilogue-style += ;&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >For a prologue style alias, the statement block that follows an alias definition is implicitly added as a prologue to any probe that refers to the alias.</font></div><div><font size="2"   >The statement block that follows an alias definition is implicitly added as an epilogue to any probe that refers to the alias. It is not useful to define new variables there (since no subsequent code will see them), but rather the code can take action based upon variables set by the prologue or by the user code.</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >1. 例如, 下面这个是prologue-style, 用等号定义. :&nbsp;</span></div><div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >probe syscall.read = kernel.function("sys_read").call</font></div><div style="line-height: 22px;"   ><font size="2"   >{</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "read"</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; fd = $fd</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; buf_uaddr = $buf</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; count = $count</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%d, %p, %d", $fd, $buf, $count)</font></div><div style="line-height: 22px;"   ><font size="2"   >}</font></div><p></p></pre></div></div><div style="line-height: 22px;"   >这个alias的handler中定义了一些本地变量, 赋予值. 在使用这个alias时, 默认会将这些定义放到handler前面.</div><div style="line-height: 22px;"   >例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp&nbsp;</font></div><div><font size="2"   >probe syscall.read {</font></div><div><font size="2"   >&nbsp; for (i=0; i&lt;10; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; printf("line %d: %s, %d, %s, %d, %s\n", i, name, fd, kernel_string(buf_uaddr), count, argstr)</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap test.stp&nbsp;</font></div><div><font size="2"   >line 0: read, 4, , 8196, 4, 0x7fff5b2b7010, 8196</font></div><div><font size="2"   >line 1: read, 4, , 8196, 4, 0x7fff5b2b7010, 8196</font></div><div><font size="2"   >line 2: read, 4, , 8196, 4, 0x7fff5b2b7010, 8196</font></div><div><font size="2"   >line 3: read, 4, , 8196, 4, 0x7fff5b2b7010, 8196</font></div><div><font size="2"   >line 4: read, 4, , 8196, 4, 0x7fff5b2b7010, 8196</font></div><div><font size="2"   >line 5: read, 4, , 8196, 4, 0x7fff5b2b7010, 8196</font></div><div><font size="2"   >line 6: read, 4, , 8196, 4, 0x7fff5b2b7010, 8196</font></div><div><font size="2"   >line 7: read, 4, , 8196, 4, 0x7fff5b2b7010, 8196</font></div><div><font size="2"   >line 8: read, 4, , 8196, 4, 0x7fff5b2b7010, 8196</font></div><div><font size="2"   >line 9: read, 4, , 8196, 4, 0x7fff5b2b7010, 8196</font></div><p></p></pre></div><div>使用alias和不使用alias的以下用法一样 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp</font></div><div><font size="2"   >probe kernel.function("sys_read").call {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "read"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; fd = $fd</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; buf_uaddr = $buf</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; count = $count</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%d, %p, %d", $fd, $buf, $count)</font></div><div><font size="2"   >&nbsp; for (i=0; i&lt;10; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; printf("line %d: %s, %d, %s, %d, %s\n", i, name, fd, kernel_string(buf_uaddr), count, argstr)</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap test.stp&nbsp;</font></div><div><font size="2"   >line 0: read, 4, , 8196, 4, 0x7fffcb11bf90, 8196</font></div><div><font size="2"   >line 1: read, 4, , 8196, 4, 0x7fffcb11bf90, 8196</font></div><div><font size="2"   >line 2: read, 4, , 8196, 4, 0x7fffcb11bf90, 8196</font></div><div><font size="2"   >line 3: read, 4, , 8196, 4, 0x7fffcb11bf90, 8196</font></div><div><font size="2"   >line 4: read, 4, , 8196, 4, 0x7fffcb11bf90, 8196</font></div><div><font size="2"   >line 5: read, 4, , 8196, 4, 0x7fffcb11bf90, 8196</font></div><div><font size="2"   >line 6: read, 4, , 8196, 4, 0x7fffcb11bf90, 8196</font></div><div><font size="2"   >line 7: read, 4, , 8196, 4, 0x7fffcb11bf90, 8196</font></div><div><font size="2"   >line 8: read, 4, , 8196, 4, 0x7fffcb11bf90, 8196</font></div><div><font size="2"   >line 9: read, 4, , 8196, 4, 0x7fffcb11bf90, 8196</font></div><p></p></pre></div><div><br></div><div>2. 例如, 下面这个是Epilogue-style, 用+=定义. :&nbsp;<br><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp</font></div><div><font size="2"   >probe myprobe += kernel.function("sys_read").call {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "read"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; fd = $fd</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; buf_uaddr = $buf</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; count = $count</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%d, %p, %d", $fd, $buf, $count)</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe myprobe {</font></div><div><font size="2"   >&nbsp; for (i=0; i&lt;10; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; printf("line %d: %s, %d, %d, %d, %s\n", i, name, fd, buf_uaddr, count, argstr)</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >}</font></div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 5 test.stp&nbsp;</font></div><div><font size="2"   >Parsed kernel "/lib/modules/2.6.18-348.12.1.el5/build/.config", containing 1977 tuples</font></div><div><font size="2"   >Parsed kernel /lib/modules/2.6.18-348.12.1.el5/build/Module.symvers, which contained 3546 vmlinux exports</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/x86_64/*.stp ", found: 4, processed: 4</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/*.stp ", found: 81, processed: 81</font></div><div><font size="2"   >Pass 1: parsed user script and 85 library script(s) using 146868virt/23720res/3008shr/21464data kb, in 170usr/0sys/171real ms.</font></div><div><font size="2"   >line 0: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 1: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 2: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 3: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 4: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 5: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 6: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 7: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 8: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 9: , 0, 0, 0,&nbsp;</font></div><p></p></pre></div></div><div>这些本地变量的值都是初始值, 就好象没有被赋值一样. 为什么呢?</div><div>因为+=定义的probe alias中handler是加到末尾的. 所以以上的stp和以下用法一致.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp</font></div><div><font size="2"   >probe kernel.function("sys_read").call {</font></div><div><font size="2"   >&nbsp; for (i=0; i&lt;10; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; printf("line %d: %s, %d, %d, %d, %s\n", i, name, fd, buf_uaddr, count, argstr)</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "read"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; fd = $fd</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; buf_uaddr = $buf</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; count = $count</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%d, %p, %d", $fd, $buf, $count)</font></div><div><font size="2"   >}</font></div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 5 test.stp&nbsp;</font></div><div><font size="2"   >Parsed kernel "/lib/modules/2.6.18-348.12.1.el5/build/.config", containing 1977 tuples</font></div><div><font size="2"   >Parsed kernel /lib/modules/2.6.18-348.12.1.el5/build/Module.symvers, which contained 3546 vmlinux exports</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/x86_64/*.stp ", found: 4, processed: 4</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/*.stp ", found: 81, processed: 81</font></div><div><font size="2"   >Pass 1: parsed user script and 85 library script(s) using 146808virt/23704res/3008shr/21404data kb, in 170usr/0sys/173real ms.</font></div><div><font size="2"   >line 0: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 1: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 2: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 3: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 4: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 5: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 6: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 7: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 8: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 9: , 0, 0, 0,&nbsp;</font></div><p></p></pre></div><div><br></div><div>更直观的例子 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp</font></div><div><font size="2"   >probe myprobe += kernel.function("sys_read").call {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "read"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; fd = $fd</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; buf_uaddr = $buf</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; count = $count</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%d, %p, %d", $fd, $buf, $count)</font></div><div><font size="2"   >&nbsp; printf("this is epilogue style probe alias\n")</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe myprobe {</font></div><div><font size="2"   >&nbsp; for (i=0; i&lt;10; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; printf("line %d: %s, %d, %d, %d, %s\n", i, name, fd, buf_uaddr, count, argstr)</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >}</font></div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 5 test.stp&nbsp;</font></div><div><font size="2"   >Parsed kernel "/lib/modules/2.6.18-348.12.1.el5/build/.config", containing 1977 tuples</font></div><div><font size="2"   >Parsed kernel /lib/modules/2.6.18-348.12.1.el5/build/Module.symvers, which contained 3546 vmlinux exports</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/x86_64/*.stp ", found: 4, processed: 4</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/*.stp ", found: 81, processed: 81</font></div><div><font size="2"   >Pass 1: parsed user script and 85 library script(s) using 146812virt/23716res/3008shr/21408data kb, in 170usr/0sys/173real ms.</font></div><div><font size="2"   >line 0: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 1: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 2: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 3: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 4: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 5: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 6: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 7: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 8: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 9: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >this is epilogue style probe alias</font></div><p></p></pre></div><div><br></div><div>根据epilogue style alias的解释, 以上脚本与以下脚本功能一致.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp</font></div><div><font size="2"   >probe kernel.function("sys_read").call {</font></div><div><font size="2"   >&nbsp; for (i=0; i&lt;10; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; printf("line %d: %s, %d, %d, %d, %s\n", i, name, fd, buf_uaddr, count, argstr)</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "read"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; fd = $fd</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; buf_uaddr = $buf</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; count = $count</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%d, %p, %d", $fd, $buf, $count)</font></div><div><font size="2"   >&nbsp; printf("this is epilogue style probe alias\n")</font></div><div><font size="2"   >}</font></div></div><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 5 test.stp&nbsp;</font></div><div><font size="2"   >Parsed kernel "/lib/modules/2.6.18-348.12.1.el5/build/.config", containing 1977 tuples</font></div><div><font size="2"   >Parsed kernel /lib/modules/2.6.18-348.12.1.el5/build/Module.symvers, which contained 3546 vmlinux exports</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/x86_64/*.stp ", found: 4, processed: 4</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/*.stp ", found: 81, processed: 81</font></div><div><font size="2"   >Pass 1: parsed user script and 85 library script(s) using 146800virt/23704res/3008shr/21396data kb, in 170usr/10sys/172real ms.</font></div><div><font size="2"   >line 0: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 1: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 2: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 3: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 4: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 5: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 6: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 7: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 8: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >line 9: , 0, 0, 0,&nbsp;</font></div><div><font size="2"   >this is epilogue style probe alias</font></div></div><p></p></pre></div><div>注意这里exit()执行了为什么还会有最后的printf执行, 原因见 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >man function::exit</font></div><div><div><font size="2"   >DESCRIPTION</font></div><div><font size="2"   >This only enqueues a request to start shutting down the script. New probes will not fire (except lqendrq probes), but all currently running ones may complete their work.</font></div></div><p></p></pre></div><div>当前正在处理的handler会全部执行完然后退出. 所以exit()后的打印可以被输出.</div><div><br></div><div><span style="line-height: 22px;"   >本文的第二部分要讲一下alias的suffix, 我们知道probe point其实有点类似DNS的管理风格, 方便event的分组表示.</span></div><div>在使用alias时, 可以自定义suffix, 也可以继承上一级point的suffix.</div><div>这个很好理解, 所以直接截取手册原文.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >It is possible to include a suffix with a probe alias invocation. If only the initial part of a probe point matches an alias, the remainder is treated as a suffix and attached to the underlying probe point(s) when the alias is expanded. For example:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* Define an alias: */</font></div><div><font size="2"   >probe sendrecv = tcp.sendmsg, tcp.recvmsg { ... }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* Use the alias in its basic form: */</font></div><div><font size="2"   >probe sendrecv { ... }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* Use the alias with an additional suffix: */</font></div><div><font size="2"   >probe sendrecv.return { ... }</font></div><div><font size="2"   >Here, the second use of the probe alias is equivalent to writing probe tcp.sendmsg.return, tcp.recvmsg.return.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >As another example, the probe points tcp.sendmsg.return and tcp.recvmsg.return are actually defined as aliases in the tapset tcp.stp. They expand to a probe point of the form kernel.function("...").return, so they can also be suffixed:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe tcp.sendmsg.return.maxactive(10) {</font></div><div><font size="2"   >&nbsp; &nbsp; printf("returning from sending %d bytes\n", size)</font></div><div><font size="2"   >}</font></div><div><font size="2"   >Here, the probe point expands to kernel.function("tcp_sendmsg").return.maxactive(10).</font></div><p></p></pre></div><div>下面是suffix的通配符介绍 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >When expanding wildcards, SystemTap generally avoids considering alias suffixes in the expansion. The exception is when a wildcard element is encountered that does not have any ordinary expansions. Consider the following example:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe some_unrelated_probe = ... { ... }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe myprobe = syscall.read { ... }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe myprobe.test = some_unrelated_probe { ... }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe myprobe.* { ... }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe myprobe.ret* { ... }</font></div><div><font size="2"   >Here, return would be a valid suffix for myprobe. The wildcard myprobe.* matches the ordinary alias myprobe.test, and hence the suffix expansion myprobe.return is not included. Conversely, myprobe.ret* does not match any ordinary aliases, so the suffix myprobe.return is included as an expansion.</font></div><p></p></pre></div><div>这里要说一下, 当仅仅使用*时, 如果alias没有定义suffix, 会报错.</div><div>只有当用到了前缀+*时, 并且alias中没有匹配的suffix, 才会去上一级probe point中匹配对应的suffix.</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -l 'syscall.read.**'</font></div><div><font size="2"   >syscall.read.return</font></div><p></p></pre></div><div>当<span style="line-height: 22px;"   >alias没有定义suffix, 即使上一级的probe point有return这个suffix, 使用*通配符会报错. 如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp</font></div><div><font size="2"   >probe myprobe = syscall.read {&nbsp;</font></div><div><font size="2"   >&nbsp; var = "myprobe"</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe myprobe.* {</font></div><div><font size="2"   >&nbsp; printf("%s\n", var)</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap test.stp&nbsp;</font></div><div><font size="2"   >semantic error: while resolving probe point: identifier 'myprobe' at test.stp:5:7</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: probe myprobe.* {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >semantic error: probe point mismatch at position 1 &nbsp;didn't find any wildcard matches: identifier '*' at :5:15</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: probe myprobe.* {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div><p></p></pre></div><div>只有定义了alias的suffix, 直接使用*通配符才不会报错.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp</font></div><div><font size="2"   >probe myprobe.test = syscall.read {&nbsp;</font></div><div><font size="2"   >&nbsp; var = "myprobe"</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe myprobe.* {</font></div><div><font size="2"   >&nbsp; printf("%s\n", var)</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap test.stp&nbsp;</font></div><div><font size="2"   >myprobe</font></div><p></p></pre></div><div>最后手册中提到的probe myprobe.ret*在我环境中未测试成功, 可能和systemtap版本有关系.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp</font></div><div><font size="2"   >probe myprobe = syscall.read {&nbsp;</font></div><div><font size="2"   >&nbsp; var = "myprobe"</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe myprobe.test = syscall.read.return {&nbsp;</font></div><div><font size="2"   >&nbsp; var = "myprobe"</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe myprobe.* {</font></div><div><font size="2"   >&nbsp; printf("%s\n", var)</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >}</font></div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap test.stp&nbsp;</font></div><div><font size="2"   >myprobe</font></div><p></p></pre></div><div><br></div><div>失败 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp</font></div><div><font size="2"   >probe myprobe = syscall.read {&nbsp;</font></div><div><font size="2"   >&nbsp; var = "myprobe"</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe myprobe.test = syscall.read.return {&nbsp;</font></div><div><font size="2"   >&nbsp; var = "myprobe"</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe myprobe.ret* {</font></div><div><font size="2"   >&nbsp; printf("%s\n", var)</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap test.stp&nbsp;</font></div><div><font size="2"   >semantic error: while resolving probe point: identifier 'myprobe' at test.stp:9:7</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: probe myprobe.ret* {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >semantic error: probe point mismatch at position 1 &nbsp;(alternatives: &nbsp;test) didn't find any wildcard matches: identifier 'ret*' at :9:15</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: probe myprobe.ret* {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div></div><p></p></pre></div><div>stap版本</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -V</font></div><div><font size="2"   >Systemtap translator/driver (version 1.8/0.152 non-git sources)</font></div><div><font size="2"   >Copyright (C) 2005-2012 Red Hat, Inc. and others</font></div><div><font size="2"   >This is free software; see the source for copying conditions.</font></div><div><font size="2"   >enabled features: AVAHI LIBRPM LIBSQLITE3 NSS BOOST_SHARED_PTR TR1_UNORDERED_MAP NLS</font></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="https://sourceware.org/systemtap/langref/Components_SystemTap_script.html"   >https://sourceware.org/systemtap/langref/Components_SystemTap_script.html</a></div><div>2.&nbsp;/usr/share/systemtap/tapset/syscalls2.stp</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   ># read _______________________________________________________</font></div><div><font size="2"   ># ssize_t sys_read(unsigned int fd, char __user * buf, size_t count)</font></div><div><font size="2"   >probe syscall.read = kernel.function("sys_read").call</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "read"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; fd = $fd</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; buf_uaddr = $buf</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; count = $count</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%d, %p, %d", $fd, $buf, $count)</font></div><div><font size="2"   >}</font></div></div><div><div><font size="2"   >probe syscall.read.return = kernel.function("sys_read").return</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "read"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; retstr = return_str(1, $return)</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div>3.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="https://sourceware.org/systemtap/man/function::exit.3stap.html"   >https://sourceware.org/systemtap/man/function::exit.3stap.html</a></div></div>
	</div>
</div>
</body>
</html>