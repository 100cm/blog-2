<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL pending patch : record identical byte-for-byte compare operator ===</h2>
	<h5 id="">2013-09-18 10:18:42&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201381892035454/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><pre class="prettyprint"   ><p></p><div><font size="2"   >From:<span>	</span>Kevin Grittner &lt;kgrittn(at)ymail(dot)com&gt;</font></div><div><font size="2"   >To:<span>	</span>"pgsql-hackers(at)postgresql(dot)org" &lt;pgsql-hackers(at)postgresql(dot)org&gt;</font></div><div><font size="2"   >Subject:<span>	</span>record identical operator</font></div><div><font size="2"   >Date:<span>	</span>2013-09-12 22:27:27</font></div><div><font size="2"   >Message-ID:<span>	</span>1379024847.48294.YahooMailNeo@web162904.mail.bf1.yahoo.com (view raw)</font></div><div><font size="2"   >Attached is a patch for a bit of infrastructure I believe to be</font></div><div><font size="2"   >necessary for correct behavior of REFRESH MATERIALIZED VIEW</font></div><div><font size="2"   >CONCURRENTLY as well as incremental maintenance of matviews.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The idea is that after RMVC or incremental maintenance, the matview</font></div><div><font size="2"   >should not be visibly different that it would have been at creation</font></div><div><font size="2"   >or on a non-concurrent REFRESH. &nbsp;The issue is easy to demonstrate</font></div><div><font size="2"   >with citext, but anywhere that the = operator allows user-visible</font></div><div><font size="2"   >differences between "equal" values it can be an issue.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >test=# CREATE TABLE citext_table (</font></div><div><font size="2"   >test(# &nbsp; id serial primary key,</font></div><div><font size="2"   >test(# &nbsp; name citext</font></div><div><font size="2"   >test(# );</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >test=# INSERT INTO citext_table (name)</font></div><div><font size="2"   >test-# &nbsp; VALUES ('one'), ('two'), ('three'), (NULL), (NULL);</font></div><div><font size="2"   >INSERT 0 5</font></div><div><font size="2"   >test=# CREATE MATERIALIZED VIEW citext_matview AS</font></div><div><font size="2"   >test-# &nbsp; SELECT * FROM citext_table;</font></div><div><font size="2"   >SELECT 5</font></div><div><font size="2"   >test=# CREATE UNIQUE INDEX citext_matview_id</font></div><div><font size="2"   >test-# &nbsp; ON citext_matview (id);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >test=# UPDATE citext_table SET name = 'Two' WHERE name = 'TWO';</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >At this point, the table and the matview have visibly different</font></div><div><font size="2"   >values, yet without the patch the query used to find differences</font></div><div><font size="2"   >for RMVC would be essentially like this (slightly simplified for</font></div><div><font size="2"   >readability):</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >test=# SELECT *</font></div><div><font size="2"   >&nbsp; FROM citext_matview m</font></div><div><font size="2"   >&nbsp; FULL JOIN citext_table t ON (t.id = m.id AND t = m)</font></div><div><font size="2"   >&nbsp; WHERE t IS NULL OR m IS NULL;</font></div><div><font size="2"   >&nbsp;id | name | id | name</font></div><div><font size="2"   >----+------+----+------</font></div><div><font size="2"   >(0 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >No differences were found, so without this patch, the matview would</font></div><div><font size="2"   >remain visibly different from the results generated by a run of its</font></div><div><font size="2"   >defining query.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The patch adds an "identical" operator (===) for the record type:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >test=# SELECT *</font></div><div><font size="2"   >&nbsp; FROM citext_matview m</font></div><div><font size="2"   >&nbsp; FULL JOIN citext_table t ON (t.id = m.id AND t === m)</font></div><div><font size="2"   >&nbsp; WHERE t IS NULL OR m IS NULL;</font></div><div><font size="2"   >&nbsp;id | name | id | name</font></div><div><font size="2"   >----+------+----+------</font></div><div><font size="2"   >&nbsp; &nbsp; | &nbsp; &nbsp; &nbsp;| &nbsp;2 | Two</font></div><div><font size="2"   >&nbsp; 2 | two &nbsp;| &nbsp; &nbsp;|</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The difference is now found, so RMVC makes the appropriate change.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >test=# REFRESH MATERIALIZED VIEW CONCURRENTLY citext_matview;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><div><font size="2"   >test=# SELECT * FROM citext_matview ORDER BY id;</font></div><div><font size="2"   >&nbsp;id | name &nbsp;</font></div><div><font size="2"   >----+-------</font></div><div><font size="2"   >&nbsp; 1 | one</font></div><div><font size="2"   >&nbsp; 2 | Two</font></div><div><font size="2"   >&nbsp; 3 | three</font></div><div><font size="2"   >&nbsp; 4 |</font></div><div><font size="2"   >&nbsp; 5 |</font></div><div><font size="2"   >(5 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The patch adds all of the functions, operators, and catalog</font></div><div><font size="2"   >information to support merge joins using the "identical" operator.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The new operator is logically similar to IS NOT DISTINCT FROM for a</font></div><div><font size="2"   >record, although its implementation is very different. &nbsp;For one</font></div><div><font size="2"   >thing, it doesn't replace the operation with column level operators</font></div><div><font size="2"   >in the parser. &nbsp;For another thing, it doesn't look up operators for</font></div><div><font size="2"   >each type, so the "identical" operator does not need to be</font></div><div><font size="2"   >implemented for each type to use it as shown above. &nbsp;It compares</font></div><div><font size="2"   >values byte-for-byte, after detoasting. &nbsp;The test for identical</font></div><div><font size="2"   >records can avoid the detoasting altogether for any values with</font></div><div><font size="2"   >different lengths, and it stops when it finds the first column with</font></div><div><font size="2"   >a difference.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >I toyed with the idea of supporting hashing of records using this</font></div><div><font size="2"   >operator, but could not see how that would be a performance win.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The identical (===) and not identical (!==) operator names were</font></div><div><font size="2"   >chosen because of a vague similarity to the "exactly equals"</font></div><div><font size="2"   >concepts in JavaScript and PHP, which use that name. &nbsp;The semantics</font></div><div><font size="2"   >aren't quite the same, but it seemed close enough not to be too</font></div><div><font size="2"   >surprising. &nbsp;The additional operator names seemed natural to me</font></div><div><font size="2"   >based on the first two, but I'm not really that attached to these</font></div><div><font size="2"   >names for the operators if someone has a better idea.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Since the comparison of record values is not documented (only</font></div><div><font size="2"   >comparisons involving row value constructors), it doesn't seem like</font></div><div><font size="2"   >we should document this special case. &nbsp;It is intended primarily for</font></div><div><font size="2"   >support of matview refresh and maintenance, and it seems likely</font></div><div><font size="2"   >that record comparison was not documented on the basis that it is</font></div><div><font size="2"   >intended primarily for support of such things as indexing and merge</font></div><div><font size="2"   >joins -- so leaving the new operators undocumented seems consistent</font></div><div><font size="2"   >with existing policy. &nbsp;I'm open to arguments that the policy should</font></div><div><font size="2"   >change.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >--</font></div><div><font size="2"   >Kevin Grittner</font></div><div><font size="2"   >EDB: http://www.enterprisedb.com</font></div><div><font size="2"   >The Enterprise PostgreSQL Company</font></div><p></p></pre></div><div>这个补丁的目的是新增1个record比较的操作符. 使用字节流的方式进行比较, 而不是每列的比较.</div><div>因为值的比较和类型有关, 例如numeric的=操作符, 末尾的0多少个不关心, 只关心值是否相等.</div><div>例如 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select numeric '1.0' = numeric '1.00';</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;t</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>但实际上这两个值的含义不一样, 在磁盘上存储的字节流也不一样.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# select byteain(numeric_out(1.0)) = byteain(numeric_out(1.00));</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;f</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=# select byteain(numeric_out(1.00)), byteain(numeric_out(1.0));</font></div><div><font size="2"   >&nbsp; byteain &nbsp; | byteain &nbsp;</font></div><div><font size="2"   >------------+----------</font></div><div><font size="2"   >&nbsp;\x312e3030 | \x312e30</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div></div><div>除了numeric以外, 还有citext也有类似情况. 例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create extension citext;</font></div><div><font size="2"   >CREATE EXTENSION</font></div></div><div><div><font size="2"   >digoal=# select citext 'abc' = citext 'ABC';</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;t</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=# select byteain(citextout(citext 'abc')) = byteain(citextout(citext 'ABC'));</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;f</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=# select byteain(citextout(citext 'abc'));</font></div><div><font size="2"   >&nbsp;byteain &nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;\x616263</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select byteain(citextout(citext 'ABC'));</font></div><div><font size="2"   >&nbsp;byteain &nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;\x414243</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div>本文谈到的这个补丁不采用各种类型的=操作符进行比较, 而是直接拿磁盘上存储的字节流来比较, (如果是toast存储的字段, 使用解压后的字节流)</div><div>打补丁 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 postgresql-dd778e9]# wget http://www.postgresql.org/message-id/attachment/30102/record-identical-v1.patch</font></div><div><div><font size="2"   >[root@db-172-16-3-33 postgresql-dd778e9]# patch -p1 &lt; record-identical-v1.patch&nbsp;</font></div><div><font size="2"   >patching file contrib/citext/expected/citext.out</font></div><div><font size="2"   >patching file contrib/citext/expected/citext_1.out</font></div><div><font size="2"   >patching file contrib/citext/sql/citext.sql</font></div><div><font size="2"   >patching file src/backend/commands/matview.c</font></div><div><font size="2"   >patching file src/backend/utils/adt/rowtypes.c</font></div><div><font size="2"   >patching file src/include/catalog/pg_amop.h</font></div><div><font size="2"   >patching file src/include/catalog/pg_amproc.h</font></div><div><font size="2"   >patching file src/include/catalog/pg_opclass.h</font></div><div><font size="2"   >patching file src/include/catalog/pg_operator.h</font></div><div><font size="2"   >patching file src/include/catalog/pg_opfamily.h</font></div><div><font size="2"   >patching file src/include/catalog/pg_proc.h</font></div><div><font size="2"   >patching file src/include/utils/builtins.h</font></div><div><font size="2"   >patching file src/test/regress/expected/opr_sanity.out</font></div></div><p></p></pre></div><div># 注意, 这个补丁修改了citext和matview(物化视图的刷新部分).</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 postgresql-dd778e9]# gmake &amp;&amp; gmake install</font></div><div><font size="2"   >[root@db-172-16-3-33 postgresql-dd778e9]# cd contrib</font></div><div><font size="2"   >[root@db-172-16-3-33 contrib]# gmake &amp;&amp; gmake install</font></div><p></p></pre></div><div># 因为动了catalog, 所以需要重新初始化数据库. (可以通过pg_upgrade来升级, 这里测试环境就不搞这么复杂了, 直接初始化)</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-33 contrib]# su - pg94</font></div><div><font size="2"   >pg94@db-172-16-3-33-&gt; initdb -D $PGDATA -E UTF8 --locale=C -W -U postgres</font></div><div><font size="2"   >pg94@db-172-16-3-33-&gt; pg_ctl start</font></div><div><div><font size="2"   >pg94@db-172-16-3-33-&gt; psql</font></div><div><font size="2"   >psql (9.4devel)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >digoal=# \do *.*===*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List of operators</font></div><div><font size="2"   >&nbsp; &nbsp;Schema &nbsp; | Name | Left arg type | Right arg type | Result type | Description&nbsp;</font></div><div><font size="2"   >------------+------+---------------+----------------+-------------+-------------</font></div><div><font size="2"   >&nbsp;pg_catalog | === &nbsp;| record &nbsp; &nbsp; &nbsp; &nbsp;| record &nbsp; &nbsp; &nbsp; &nbsp; | boolean &nbsp; &nbsp; | identical</font></div><div><font size="2"   >(1 row)</font></div></div></div><div><div><font size="2"   >digoal=# SELECT (ARRAY[1,2,3,NULL])[1:3] = ARRAY[1,2,3];</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;t</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# SELECT row((ARRAY[1,2,3,NULL])[1:3])::record = row(ARRAY[1,2,3])::record;</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;t</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# SELECT row((ARRAY[1,2,3,NULL])[1:3])::record === row(ARRAY[1,2,3])::record;</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;f</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div>array的空字节使用byteain看不出来 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# SELECT byteain(record_out(row((ARRAY[1,2,3,NULL])[1:3])::record)) , byteain(record_out(row(ARRAY[1,2,3])::record));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;byteain &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; byteain &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------------------+--------------------------</font></div><div><font size="2"   >&nbsp;\x28227b312c322c337d2229 | \x28227b312c322c337d2229</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >I haven't yet tested your patch, but what I am talking about is that</font></div><div><font size="2"   >e.g.: SELECT (ARRAY[1,2,3,NULL])[1:3] = ARRAY[1,2,3];</font></div><div><font size="2"   >obviously should be true. But both arrays don't have the same binary</font></div><div><font size="2"   >representation since the former has a null bitmap, the latter not.</font></div><div><font size="2"   >So, if you had a composite type like (int4[]) and would compare that</font></div><div><font size="2"   >without invoking operators you'd return something false in some cases</font></div><div><font size="2"   >because of the null bitmaps.</font></div><p></p></pre></div><div>接下来测试物化视图增量刷新的部分 :&nbsp;</div><div>1. 打补丁后 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create extension citext;</font></div><div><font size="2"   >CREATE EXTENSION</font></div></div><div><div><font size="2"   >digoal=# create table test(id int primary key, c1 citext, c2 numeric);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# insert into test values (1,'abc',1.0);</font></div><div><font size="2"   >INSERT 0 1</font></div></div><div><div><font size="2"   >digoal=# insert into test values (2,'ABC',1.0);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test values (3,'ABC',1.00);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test values (4,'abc',1.00);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# select * from test;</font></div><div><font size="2"   >&nbsp;id | c1 &nbsp;| &nbsp;c2 &nbsp;</font></div><div><font size="2"   >----+-----+------</font></div><div><font size="2"   >&nbsp; 1 | abc | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 2 | ABC | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 3 | ABC | 1.00</font></div><div><font size="2"   >&nbsp; 4 | abc | 1.00</font></div><div><font size="2"   >(4 rows)</font></div></div><p></p></pre></div><div><div>创建物化视图</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# CREATE MATERIALIZED VIEW mv_test AS select * from test;</font></div><div><font size="2"   >SELECT 4</font></div></div><div><div><font size="2"   >digoal=# select * from mv_test;</font></div><div><font size="2"   >&nbsp;id | c1 &nbsp;| &nbsp;c2 &nbsp;</font></div><div><font size="2"   >----+-----+------</font></div><div><font size="2"   >&nbsp; 1 | abc | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 2 | ABC | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 3 | ABC | 1.00</font></div><div><font size="2"   >&nbsp; 4 | abc | 1.00</font></div><div><font size="2"   >(4 rows)</font></div></div><p></p></pre></div></div><div>给物化视图创建唯一索引, 以便增量更新</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create unique index idx_test_id on mv_test(id);</font></div><div><font size="2"   >CREATE INDEX</font></div><p></p></pre></div><div>更新citext字段, Abc, 这个更新后, new和old值使用这个类型对应的=操作符实际上是相等的.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# update test set c1='Abc' where id=1;</font></div><div><font size="2"   >UPDATE 1</font></div></div><div><div><font size="2"   >digoal=# refresh MATERIALIZED VIEW CONCURRENTLY mv_test;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div></div><p></p></pre></div><div>打补丁后, record的比较按字节流进行, 所以id=1的值发生的变更会造成刷新.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from mv_test;</font></div><div><font size="2"   >&nbsp;id | c1 &nbsp;| &nbsp;c2 &nbsp;</font></div><div><font size="2"   >----+-----+------</font></div><div><font size="2"   >&nbsp; 2 | ABC | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 3 | ABC | 1.00</font></div><div><font size="2"   >&nbsp; 4 | abc | 1.00</font></div><div><font size="2"   >&nbsp; 1 | Abc | &nbsp;1.0</font></div><div><font size="2"   >(4 rows)</font></div><p></p></pre></div><div>更新numeric的值, 增加1个有效值. 虽然使用numeric对应的=操作符比较1.0=1.00.&nbsp;</div><div>但是打补丁后使用的是===进行比较, 所以刷新时还是会更新这条记录</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# update test set c2=1.00 where id=1;</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   >digoal=# refresh MATERIALIZED VIEW CONCURRENTLY mv_test;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><div><font size="2"   >digoal=# select * from mv_test;</font></div><div><font size="2"   >&nbsp;id | c1 &nbsp;| &nbsp;c2 &nbsp;</font></div><div><font size="2"   >----+-----+------</font></div><div><font size="2"   >&nbsp; 2 | ABC | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 3 | ABC | 1.00</font></div><div><font size="2"   >&nbsp; 4 | abc | 1.00</font></div><div><font size="2"   >&nbsp; 1 | Abc | 1.00</font></div><div><font size="2"   >(4 rows)</font></div><p></p></pre></div><div>打补丁后, 物化视图的刷新更真实, 会完全匹配到基表.</div><div><br></div><div>2. 打补丁前 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table test(id int primary key, c1 citext, c2 numeric);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# insert into test values (1,'abc',1.0);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test values (2,'ABC',1.0);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test values (3,'ABC',1.00);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test values (4,'abc',1.00);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# select * from test;</font></div><div><font size="2"   >&nbsp;id | c1 &nbsp;| &nbsp;c2 &nbsp;</font></div><div><font size="2"   >----+-----+------</font></div><div><font size="2"   >&nbsp; 1 | abc | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 2 | ABC | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 3 | ABC | 1.00</font></div><div><font size="2"   >&nbsp; 4 | abc | 1.00</font></div><div><font size="2"   >(4 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# CREATE MATERIALIZED VIEW mv_test AS select * from test;</font></div><div><font size="2"   >SELECT 4</font></div><div><font size="2"   >digoal=# select * from mv_test;</font></div><div><font size="2"   >&nbsp;id | c1 &nbsp;| &nbsp;c2 &nbsp;</font></div><div><font size="2"   >----+-----+------</font></div><div><font size="2"   >&nbsp; 1 | abc | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 2 | ABC | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 3 | ABC | 1.00</font></div><div><font size="2"   >&nbsp; 4 | abc | 1.00</font></div><div><font size="2"   >(4 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# create unique index idx_test_id on mv_test(id);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >digoal=# update test set c1='Abc' where id=1;</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   >digoal=# refresh MATERIALIZED VIEW CONCURRENTLY mv_test;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><div><font size="2"   >digoal=# select * from mv_test;</font></div><div><font size="2"   >&nbsp;id | c1 &nbsp;| &nbsp;c2 &nbsp;</font></div><div><font size="2"   >----+-----+------</font></div><div><font size="2"   >&nbsp; 1 | abc | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 2 | ABC | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 3 | ABC | 1.00</font></div><div><font size="2"   >&nbsp; 4 | abc | 1.00</font></div><div><font size="2"   >(4 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# update test set c2=1.00 where id=1;</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   >digoal=# select * from mv_test;</font></div><div><font size="2"   >&nbsp;id | c1 &nbsp;| &nbsp;c2 &nbsp;</font></div><div><font size="2"   >----+-----+------</font></div><div><font size="2"   >&nbsp; 1 | abc | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 2 | ABC | &nbsp;1.0</font></div><div><font size="2"   >&nbsp; 3 | ABC | 1.00</font></div><div><font size="2"   >&nbsp; 4 | abc | 1.00</font></div><div><font size="2"   >(4 rows)</font></div><p></p></pre></div><div>显然打补丁前, 物化视图对于这类更新没有体现在物化视图上.</div><div><br></div><div>[小结]</div><div>1. 使用本补丁时需要注意, ===这个操作符是对record进行byte-for-byte的比较, 虽然numeric 1.0和numeric 1.00看起来应该相等, 但是底层的存储实际上是不一样的. 这种情况下使用===就比较有用了.</div><div>2. 对于物化视图的增量刷新场景, 每条记录要做出比较, 本补丁将物化视图增量刷新做出了修改, 把record的对比改成使用===这种模式, 所以对于citext这种类型, 可以看出打补丁前后发生的明显变化.</div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 23px;" rel="nofollow" href="http://www.postgresql.org/message-id/flat/1379024847.48294.YahooMailNeo@web162904.mail.bf1.yahoo.com#1379024847.48294.YahooMailNeo@web162904.mail.bf1.yahoo.com"   >http://www.postgresql.org/message-id/flat/1379024847.48294.YahooMailNeo@web162904.mail.bf1.yahoo.com#1379024847.48294.YahooMailNeo@web162904.mail.bf1.yahoo.com</a></div><div>2.&nbsp;<span style="line-height: 23px;"   >src/backend/utils/adt/arrayfuncs.c</span></div><div style="line-height: 23px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 23px;"   ><font size="2"   >/*</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp;* Set a specific array element's null-bitmap entry</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp;* nullbitmap: pointer to array's null bitmap (mustn't be NULL)</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp;* offset: 0-based linear element number of array element</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp;* isNull: null status to set</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 23px;"   ><font size="2"   >static void</font></div><div style="line-height: 23px;"   ><font size="2"   >array_set_isnull(bits8 *nullbitmap, int offset, bool isNull)</font></div><div style="line-height: 23px;"   ><font size="2"   >{</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask;</font></div><div style="line-height: 23px;"   ><font size="2"   ><br style="line-height: 23px;"   ></font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; nullbitmap += offset / 8;</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bitmask = 1 &lt;&lt; (offset % 8);</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (isNull)</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *nullbitmap &amp;= ~bitmask;</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div style="line-height: 23px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *nullbitmap |= bitmask;</font></div><div style="line-height: 23px;"   ><font size="2"   >}</font></div><p></p></pre></div><div style="line-height: 23px;"   ><br></div></div>
	</div>
</div>
</body>
</html>