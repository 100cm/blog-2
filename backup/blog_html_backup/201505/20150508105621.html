<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL Why checkpointer impact performance so much ? - 4</h2>
	<h5 id="">2015-05-08 10:56:21&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020154653422892/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">这一篇主要谈一下和检查点相关的几个跟踪。<div>1. 锁等待次数和时间的跟踪。<wbr><div>2. 刷新缓存相关函数的时间跟踪。</div><div>从这些跟踪结果来反映检查点对数据库性能的影响。</div><div>先整理一下检查点相关的一些探针，如果不能满足跟踪的需求，可以再自定义添加：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >刷事务提交日志相关的探针结构，了解结构对我们计算时间很有帮助：</font></div><div><div><font size="2"   >CheckPointCLOG@src/backend/access/transam/clog.c</font></div><div><font size="2"   >&nbsp; TRACE_POSTGRESQL_CLOG_CHECKPOINT_START(true);</font></div><div><font size="2"   >&nbsp; TRACE_POSTGRESQL_CLOG_CHECKPOINT_DONE(true);</font></div><div><span style="line-height: 28px;"   ><font size="2"   ><br></font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >刷子事务相关的探针：</font></span></div><div><font size="2"   >CheckPointSUBTRANS@src/backend/access/transam/subtrans.c</font></div><div><font size="2"   >&nbsp; TRACE_POSTGRESQL_SUBTRANS_CHECKPOINT_START(true);</font></div><div><font size="2"   >&nbsp; TRACE_POSTGRESQL_SUBTRANS_CHECKPOINT_DONE(true);</font></div><div><span style="line-height: 28px;"   ><font size="2"   ><br></font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >刷多事务相关的探针：</font></span></div><div><font size="2"   >CheckPointMultiXact@src/backend/access/transam/multixact.c</font></div><div><font size="2"   >&nbsp; TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_START(true);</font></div><div><font size="2"   >&nbsp; TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_DONE(true);</font></div><div><span style="line-height: 28px;"   ><font size="2"   ><br></font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >刷Buffer相关的探针：</font></span></div><div><font size="2"   >CheckPointBuffers(flags)@src/backend/storage/buffer/bufmgr.c</font></div><div><font size="2"   >&nbsp; TRACE_POSTGRESQL_BUFFER_CHECKPOINT_START(flags); &nbsp;// buffer检查点开始</font></div><div><font size="2"   >&nbsp; { &nbsp;<span style="line-height: 28px;"   >-- 遍历BUFFER区，将</span><span style="line-height: 28px;"   >头信息need checkpoint的块刷入磁盘</span></font></div><div><font size="2"   >&nbsp; BufferSync(flags) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// &nbsp;与第一个trace之间包含遍历整个buffer区,增加脏块头信息need checkpoint</font></div><div><font size="2"   >&nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_SYNC_START(NBuffers, num_to_write); &nbsp;// 开始sync buffer</font></div><div><font size="2"   >&nbsp; &nbsp; { &nbsp;-- &nbsp;sync单个buffer</font></div><div><font size="2"   >&nbsp; &nbsp; SyncOneBuffer</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; FlushBuffer</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_FLUSH_START(buf-&gt;tag.forkNum, &nbsp; &nbsp;// 单个buffer块, flush开始</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf-&gt;tag.blockNum,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rnode.node.spcNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rnode.node.dbNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rnode.node.relNode);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_FLUSH_DONE(buf-&gt;tag.forkNum, &nbsp; &nbsp;// 单个buffer块, flush结束</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf-&gt;tag.blockNum,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rnode.node.spcNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rnode.node.dbNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_rnode.node.relNode);</font></div><div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; }</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_SYNC_WRITTEN(buf_id); &nbsp;// 单个buffer块, writeten结束</font></div></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; } // &nbsp;<span style="line-height: 28px;"   >SYNC_START和</span><span style="line-height: 28px;"   >SYNC_WRITTEN之间是单个buffer的writter时间</span></font></div><div><font size="2"   >&nbsp; &nbsp;&nbsp;<span style="line-height: 28px;"   >//&nbsp;</span><span style="line-height: 28px;"   >BufferSync末端，缓存区的need checkpointer的脏块全部written完毕。</span></font></div><div><font size="2"   >&nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_SYNC_DONE(NBuffers, num_written, num_to_write);&nbsp;</font></div><div><font size="2"   >&nbsp; } &nbsp;//&nbsp;<span style="line-height: 28px;"   >BufferSync结束</span></font></div><div><font size="2"   >&nbsp; TRACE_POSTGRESQL_BUFFER_CHECKPOINT_SYNC_START();</font></div><div><font size="2"   >&nbsp; // &nbsp;调用smgrsync(); // 前面的write操作持久化到磁盘。</font></div><div><font size="2"   >&nbsp; TRACE_POSTGRESQL_BUFFER_CHECKPOINT_DONE();</font></div></div><p></p></pre></div><div><div>需要用到的probe name如下：</div><div><pre class="prettyprint"   ><p></p><div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe checkpoint__start(int);</font></div><div><font size="2"   ><br></font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe clog__checkpoint__start(bool);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe clog__checkpoint__done(bool);</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe subtrans__checkpoint__start(bool);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe subtrans__checkpoint__done(bool);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe multixact__checkpoint__start(bool);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe multixact__checkpoint__done(bool);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe buffer__checkpoint__start(int);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe buffer__sync__start(int, int);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe buffer__flush__start(ForkNumber, BlockNumber, Oid, Oid, Oid);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe buffer__flush__done(ForkNumber, BlockNumber, Oid, Oid, Oid);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe buffer__sync__written(int);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe buffer__sync__done(int, int, int);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe buffer__checkpoint__sync__start();</font></div></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe buffer__checkpoint__done();</font></div></div><div><font size="2"   ><br></font></div><div><span style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe checkpoint__done(int, int, int, int, int);</font></span></div><p></p></pre></div></div><div><span style="line-height: 28px;"   >含义请参考</span></div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/dynamic-trace.html"   >http://www.postgresql.org/docs/devel/static/dynamic-trace.html</a></div><div>src/backend/utils/probes.d</div><div>src/backend/utils/probes.h</div><div><br></div><div>使用stap统计他们开始和结束的时间区间，对于sync和flush单个buffer统计耗时柱状分布。</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 21px;"   >stap -v 11111 -e '<br>global var, stat_var, tmp;<br>probe process("/opt/pgsql/bin/postgres").mark("checkpoint__start") {<br>  /* clear data */<br>  delete var<br>  delete stat_var<br>  delete tmp<br><br>  var[pid(),0] = gettimeofday_us()<br>  printf("checkpoint__start pid:%d, us_epoch: %d\n", pid(), var[pid(),0])<br><br>}<br><br>probe process("/opt/pgsql/bin/postgres").mark("clog__checkpoint__start") {<br>  var[pid(),1] = gettimeofday_us()<br>}<br>probe process("/opt/pgsql/bin/postgres").mark("clog__checkpoint__done") {<br>  var[pid(),2] = gettimeofday_us()<br>  printf("clog__checkpoint__done us: %d\n", var[pid(),2]-var[pid(),1])<br>}<br><br>probe process("/opt/pgsql/bin/postgres").mark("subtrans__checkpoint__start") {<br>  var[pid(),3] = gettimeofday_us()<br>}<br>probe process("/opt/pgsql/bin/postgres").mark("subtrans__checkpoint__done") {<br>  var[pid(),4] = gettimeofday_us()<br>  printf("subtrans__checkpoint__done us: %d\n", var[pid(),4]-var[pid(),3])<br>}<br><br>probe process("/opt/pgsql/bin/postgres").mark("multixact__checkpoint__start") {<br>  var[pid(),5] = gettimeofday_us()<br>}<br>probe process("/opt/pgsql/bin/postgres").mark("multixact__checkpoint__done") {<br>  var[pid(),6] = gettimeofday_us()<br>  printf("multixact__checkpoint__done us: %d\n", var[pid(),6]-var[pid(),5])<br>}<br><br>probe process("/opt/pgsql/bin/postgres").mark("buffer__checkpoint__start") {<br>  var[pid(),7] = gettimeofday_us()<br>  tmp[pid(),1] = $flags     /* bitwise flags used to distinguish different checkpoint types */<br>  printf("buffer__checkpoint__start flags: %d\n", tmp[pid(),1])<br>}<br><br>probe process("/opt/pgsql/bin/postgres").mark("buffer__sync__start") {<br>  var[pid(),8] = gettimeofday_us()<br>  tmp[pid(),2] = $NBuffers     /* number buffers */<br>  tmp[pid(),3] = $num_to_write   /* dirty buffers */<br>  printf("buffer__sync__start num_buffers: %d, dirty_buffers: %d\n", tmp[pid(),2], tmp[pid(),3])<br>  printf("scan buffers, lock bufheader one-by-one, add need chkpoint flag for dirty buffer: total us %d \n", var[pid(),8] - var[pid(),7])<br>}<br><br>/* start loop scan buffers */<br>probe process("/opt/pgsql/bin/postgres").mark("buffer__flush__start") {<br>  var[pid(),9] = gettimeofday_us()<br>}<br>probe process("/opt/pgsql/bin/postgres").mark("buffer__flush__done") {<br>  var[pid(),10] = gettimeofday_us()<br>  stat_var[pid(),1] &lt;&lt;&lt; var[pid(),10] - var[pid(),9]<br>}<br>probe process("/opt/pgsql/bin/postgres").mark("buffer__sync__written") {<br>  var[pid(),11] = gettimeofday_us()<br>  stat_var[pid(),2] &lt;&lt;&lt; var[pid(),11] - var[pid(),10]<br>}<br>/* end loop scan buffers */<br><br>probe process("/opt/pgsql/bin/postgres").mark("buffer__sync__done") {<br>  var[pid(),12] = gettimeofday_us()<br>  tmp[pid(),7] = $NBuffers   /* number buffers */<br>  tmp[pid(),8] = $num_written   /* actual written buffers */<br>  tmp[pid(),9] = $num_to_write   /* expect dirty buffers need flush */<br><br>  if ( @count(stat_var[pid(),1]) &gt; 0 ) {<br>    printf("buffer__flush us min: %d, max: %d, avg: %d, sum: %d, count: %d\n", @min(stat_var[pid(),1]), @max(stat_var[pid(),1]), @avg(stat_var[pid(),1]), @sum(stat_var[pid(),1]), @count(stat_var[pid(),1]) )<br>    print(@hist_log(stat_var[pid(),1]))<br>  }<br><br>  if ( @count(stat_var[pid(),2]) &gt; 0 ) {<br>    printf("buffer__sync us min: %d, max: %d, avg: %d, sum: %d, count: %d\n", @min(stat_var[pid(),2]), @max(stat_var[pid(),2]), @avg(stat_var[pid(),2]), @sum(stat_var[pid(),2]), @count(stat_var[pid(),2]) )<br>    print(@hist_log(stat_var[pid(),2]))<br>  }<br>  <br>  printf("buffer__sync__done num_buffers: %d, actual_written_buffers: %d, dirty_buffers: %d\n", tmp[pid(),7], tmp[pid(),8], tmp[pid(),9])<br>  printf("buffer__sync__done us: %d\n", var[pid(),12] - var[pid(),8])<br>}<br><br>probe process("/opt/pgsql/bin/postgres").mark("buffer__checkpoint__sync__start") {<br>  var[pid(),13] = gettimeofday_us()<br>}<br><br>probe process("/opt/pgsql/bin/postgres").mark("buffer__checkpoint__done") {<br>  var[pid(),14] = gettimeofday_us()<br>  printf("buffer__checkpoint__done sync us: %d\n", var[pid(),14] - var[pid(),13])<br>}<br><br>probe process("/opt/pgsql/bin/postgres").mark("checkpoint__done") {<br>  var[pid(),15] = gettimeofday_us()<br>  printf("checkpoint__done pid:%d, us_epoch: %d\n", pid(), var[pid(),15])<br>  printf("checkpoint__done us: %d\n", var[pid(),15] - var[pid(),0])<br><br>  /* clear data */<br>  delete var<br>  delete stat_var<br>  delete tmp<br><br>}'</span></font></div><p></p></pre></div><div>执行开始：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 21px;"   >Pass 1: parsed user script and 111 library script(s) using 209424virt/36924res/3164shr/34644data kb, in 250usr/40sys/283real ms.<br>Pass 2: analyzed script: 22 probe(s), 7 function(s), 4 embed(s), 3 global(s) using 214056virt/42604res/4212shr/39276data kb, in 60usr/100sys/177real ms.<br>Pass 3: translated to C into "/tmp/stapDx3Mm2/stap_9b2d08e0dae6cce58d0357dbfb7496d6_10956_src.c" using 214056virt/42924res/4532shr/39276data kb, in 10usr/80sys/99real ms.<br>Pass 4: compiled C into "stap_9b2d08e0dae6cce58d0357dbfb7496d6_10956.ko" in 2220usr/490sys/2691real ms.<br>Pass 5: starting run.</span></font></div><p></p></pre></div><div>同时执行pgbench做压力测试：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >$ vi&nbsp;test.sql</font></div><div><font size="2"   >\setrandom id 1 50000000</font></div><div><font size="2"   >update tbl set info=now(),crt_time=now() where id=:id;</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >$ pgbench -M prepared -n -r -f ./test.sql -P 5 -c 26 -j 26 -T 10000000</font></div><div><font size="2"   ><span style="line-height: 21px;"   >progress: 5.0 s, 35426.2 tps, lat 0.729 ms stddev 0.616<br>progress: 10.0 s, 41056.1 tps, lat 0.631 ms stddev 0.556<br>progress: 15.0 s, 41447.5 tps, lat 0.625 ms stddev 0.546<br>progress: 20.0 s, 41920.3 tps, lat 0.618 ms stddev 0.542<br>progress: 25.0 s, 42192.7 tps, lat 0.614 ms stddev 0.510<br>progress: 30.0 s, 42177.1 tps, lat 0.614 ms stddev 0.496<br>progress: 35.0 s, 42974.5 tps, lat 0.603 ms stddev 0.417<br>progress: 40.0 s, 42003.3 tps, lat 0.617 ms stddev 0.504<br>progress: 45.0 s, 42467.8 tps, lat 0.610 ms stddev 0.498</span></font></div></div></div><div><font size="2"   >......</font></div><p></p></pre></div></div><div><span style="line-height: 28px;"   >提取其中一次跟踪到的checkpoint结果如下：</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 21px;"   >checkpoint__start pid:29658, us_epoch: 1431051835987299<br>clog__checkpoint__done us: 43383<br>subtrans__checkpoint__done us: 3170<br>multixact__checkpoint__done us: 6<br>buffer__checkpoint__start flags: 64<br>buffer__sync__start num_buffers: 524288, dirty_buffers: 153863<br>scan buffers, lock bufheader one-by-one, add need chkpoint flag for dirty buffer: total us 201192</span></font></div><div><font size="2"   ><span style="line-height: 21px;"   >// 从这里开始性能开始下降,也就是说,问题出在循环flush buffer的过程中, 但是性能会在约几秒后恢复, 并没有等到flush循环结束.<br>buffer__flush us min: 33, max: 48992, avg: 114, sum: 17671488, count: 153863<br> value |-------------------------------------------------- count<br>     8 |                                                        0<br>    16 |                                                        0<br>    32 |@@@@@@                                              12836<br>    64 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  104806<br>   128 |@@@@@@@@@@@@@@@@                                    35471<br>   256 |                                                      597<br>   512 |                                                       34<br>  1024 |                                                       18<br>  2048 |                                                       17<br>  4096 |                                                       30<br>  8192 |                                                       46<br> 16384 |                                                        6<br> 32768 |                                                        2<br> 65536 |                                                        0<br>131072 |                                                        0<br><br>buffer__sync us min: 1, max: 1717, avg: 2, sum: 334008, count: 153863<br>value |-------------------------------------------------- count<br>    0 |                                                        0<br>    1 |@@@@@                                               14633<br>    2 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  134842<br>    4 |                                                     1857<br>    8 |                                                     2398<br>   16 |                                                      106<br>   32 |                                                       24<br>   64 |                                                        1<br>  128 |                                                        0<br>  256 |                                                        1<br>  512 |                                                        0<br> 1024 |                                                        1<br> 2048 |                                                        0<br> 4096 |                                                        0<br><br>buffer__sync__done num_buffers: 524288, actual_written_buffers: 153863, dirty_buffers: 153863<br>buffer__sync__done us: 268814089<br>buffer__checkpoint__done sync us: 2391<br>checkpoint__done pid:29658, us_epoch: 1431052105132986<br>checkpoint__done us: 269145687</span></font></div><p></p></pre></div><div>分析：</div><div><div style="line-height: 28px;"   >简单的解释一下：</div><div style="line-height: 28px;"   >这里用的时间单位是微秒，即10的-6次方秒。</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   >我的系统使用了32KB的数据块，配置了16GB的Shared Buffer, 因此可以看到<span style="line-height: 28px;"   >num_buffers: 524288个32K的块刚好16GB。</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >检查点开始后有短暂的性能下降，但是不会持续到检查点结束，影响时间维持5秒左右。</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >progress: 255.0 s, 43021.9 tps, lat 0.602 ms stddev 0.434</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 260.0 s, 41028.6 tps, lat 0.631 ms stddev 0.512</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 265.0 s, 39556.4 tps, lat 0.655 ms stddev 0.631</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 270.0 s, 19495.2 tps, lat 1.331 ms stddev 2.350</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 275.0 s, 31672.6 tps, lat 0.818 ms stddev 0.915</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 280.0 s, 38465.6 tps, lat 0.674 ms stddev 0.656</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 285.0 s, 43365.8 tps, lat 0.597 ms stddev 0.629</font></div><p></p></pre></div><div style="line-height: 28px;"   >整个过程的耗时：</div></div></span></div></div></div><div>1. 标记脏块需要遍历整个BUFFER区，耗时为201192微秒<span style="line-height: 28px;"   >，0.2秒。</span></div><div>2. 遍历BUFFER区，调用FlushBuffer将脏块write到系统内核的区间，耗时268814089微秒，268.8秒，这里包含了大量的sleep。</div><div>(使用CheckpointWriteDelay调度sleep，可能产生多次休息，休息区间由几个参数决定，我在前面的文章也已经讲过了。)</div><div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >CheckpointWriteDelay休息区间受到几个参数影响：</span></div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >checkpoint_segments 越大  休息区间越大。</font></div><div style="line-height: 28px;"   ><font size="2"   >checkpoint_timeout&nbsp;<span style="line-height: 28px;"   >越大&nbsp;</span><span style="line-height: 28px;"   >休息区间越大。</span></font></div><div style="line-height: 28px;"   ><font size="2"   >checkpoint_completion_target&nbsp;<span style="line-height: 28px;"   >越大&nbsp;</span><span style="line-height: 28px;"   >休息区间越大。</span></font></div><div style="line-height: 28px;"   ><font size="2"   ><span style="line-height: 28px;"   >checkpoint_completion_target&nbsp;</span><span style="line-height: 28px;"   >如果设置为1，那么下一个checkpoint会紧接着开始。</span></font></div><p></p></pre></div></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   >3. buffer write, sync柱状图到内核的统计柱状图信息。</div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >buffer__flush us min: 33, max: 48992, avg: 114, sum: 17671488, count: 153863</font></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >buffer__sync us min: 1, max: 1717, avg: 2, sum: 334008, count: 153863</font></span></div><p></p></pre></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >buffer write to内核， 一共耗时</span>17671488微秒，<span style="line-height: 28px;"   >17.67秒，注意这个才是真实的FlushBuffer的时间。</span></div><div style="line-height: 28px;"   >buffer sync to持久化存储， 一共耗时334008微秒，0.334秒。</div><div style="line-height: 28px;"   >以上操作的时间跨度<span style="line-height: 28px;"   >为整个检查点区间的积累，所以是很分散的，而性能影响仅仅持续了检查点开始的前几秒，还需要从代码层面继续寻找原因，很大可能还是和lwlock锁有关系。</span></div></div><div>4. 将write到内核的数据sync到持久化存储的耗时2391<span style="line-height: 28px;"   >微秒，</span>0.002秒。</div><div>5. 整个checkpoint过程的耗时269145687<span style="line-height: 28px;"   >微秒，269.1秒。</span></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015463252387/"   >http://blog.163.com/digoal@126/blog/static/1638770402015463252387/</a></div><div><div style="line-height: 28px;"   >2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/dynamic-trace.html"   >http://www.postgresql.org/docs/devel/static/dynamic-trace.html</a></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >3.&nbsp;</span><a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201391883345365/"   >http://blog.163.com/digoal@126/blog/static/163877040201391883345365/</a></div><div style="line-height: 28px;"   >4. src/backend/utils/probes.d</div><div style="line-height: 28px;"   >5. src/backend/utils/probes.h</div></div></div><div style="line-height: 28px;"   ><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL Why checkpointer impact performance so much ? - 4 - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>