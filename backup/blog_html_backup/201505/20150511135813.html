<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">parallel blocking|waiting by slow BLOCK extend relation , ExclusiveLock on extension of relation</h2>
	<h5 id="">2015-05-11 13:58:13&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201541112115908/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>前面一篇文章我简单的介绍了一下如何找到出现锁等待的会话，以及它到底在等那个会话，在等的这个会话现在在执行什么操作，事务开启多久了？</div><div>参考：</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015410104726197/"   >http://blog.163.com/digoal@126/blog/static/1638770402015410104726197/</a></div><div><br></div><div>锁在数据库中是一个非常需要注意的东西，锁时间越长，影响可能越大。</div><div>有一个例子是这样的，某个业务有比较高并发的插入请求，当对象的空间被写满时，数据库会扩展一个数据块供客户使用，但是一次只会扩展一个数据块，而且扩展数据块的操作是extend locktype的ExclusiveLock。</div><div>也就是说，同一时间只允许一个扩展块的操作，其他的都会进入锁等待队列。</div><div>那么问题来了，如果第一个请求的扩展块的动作变慢了的话，因为并发量大，接下来的插入请求也需要扩展块，而如果其中任何一个出现扩展块堵塞，那么就非常容易引起越来越多的扩展块请求和拥塞。</div><div>这个时候该怎么办呢？</div><div>先找到堵塞原因，</div><div>1. 从数据库层面找，<span style="line-height: 28px;"   >使用如下：</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create or replace function f_lock_level(i_mode text) returns int as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; case i_mode</font></div><div><font size="2"   >&nbsp; &nbsp; when 'INVALID' then return 0;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'AccessShareLock' then return 1;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'RowShareLock' then return 2;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'RowExclusiveLock' then return 3;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ShareUpdateExclusiveLock' then return 4;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ShareLock' then return 5;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ShareRowExclusiveLock' then return 6;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ExclusiveLock' then return 7;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'AccessExclusiveLock' then return 8;</font></div><div><font size="2"   >&nbsp; &nbsp; else return 0;</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >end;&nbsp;</font></div><div><font size="2"   >$$ language plpgsql strict;</font></div><div><font size="2"   >修改查询语句，按锁级别排序：</font></div><div><font size="2"   >with t_wait as &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >(select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a,transactionid,b.query,b.xact_start,b.query_start,b.usename,b.datname from pg_locks a,pg_stat_activity b where a.pid=b.pid and not a.granted),</font></div><div><font size="2"   >t_run as&nbsp;</font></div><div><font size="2"   >(select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a,transactionid,b.query,b.xact_start,b.query_start,b.usename,b.datname from pg_locks a,pg_stat_activity b where a.pid=b.pid and a.granted)&nbsp;</font></div><div><font size="2"   >select r.locktype,r.mode r_mode,r.usename r_user,r.datname r_db,r.relation::regclass,r.pid r_pid,r.xact_start r_xact_start,r.query_start r_query_start,now()-r.query_start r_locktime,r.query r_query,</font></div><div><font size="2"   >w.mode w_mode,w.pid w_pid,w.xact_start w_xact_start,w.query_start w_query_start,now()-w.query_start w_locktime,w.query w_query &nbsp;</font></div><div><font size="2"   >from t_wait w,t_run r where</font></div><div><font size="2"   >&nbsp; r.locktype is not distinct from w.locktype and</font></div><div><font size="2"   >&nbsp; r.database is not distinct from w.database and</font></div><div><font size="2"   >&nbsp; r.relation is not distinct from w.relation and</font></div><div><font size="2"   >&nbsp; r.page is not distinct from w.page and</font></div><div><font size="2"   >&nbsp; r.tuple is not distinct from w.tuple and</font></div><div><font size="2"   >&nbsp; r.classid is not distinct from w.classid and</font></div><div><font size="2"   >&nbsp; r.objid is not distinct from w.objid and</font></div><div><font size="2"   >&nbsp; r.objsubid is not distinct from w.objsubid and</font></div><div><font size="2"   >&nbsp; r.transactionid is not distinct from w.transactionid and</font></div><div><font size="2"   >&nbsp; r.pid &lt;&gt; w.pid</font></div><div><font size="2"   >&nbsp; order by f_lock_level(w.mode)+f_lock_level(r.mode) desc,r.xact_start;</font></div><p></p></pre></div><div>如果无法排查，从系统层面或内核层面排查。<span style="line-height: 28px;"   >例如从上面找到的大家都在等的那个PID，跟踪进程的系统调用。</span></div><div><span style="line-height: 28px;"   >如果来不及排查，迅速杀掉所有的扩展块请求，恢复业务先。</span></div><div><br></div><div>另一方面，对于这种业务类型，使用32KB的数据块可以更好的提高效率。</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201392641033482"   >http://blog.163.com/digoal@126/blog/static/163877040201392641033482</a></div><div><br></div><div>常见的日志如下，如果你的系统频繁出现这样的等待，说明你要提高IO能力，或者将数据块改为32KB的。</div><div>"process 33604 still waiting for ExclusiveLock on extension of relation 686064100 of database 35078604 after 1000.289 ms"</div><div>"process 5626 acquired ExclusiveLock on extension of relation 686064091 of database 35078604 after 3247.773 ms"</div><div><span style="line-height: 28px;"   >下面这个错误，是因为设置了锁超时参数：</span></div><div><span style="line-height: 28px;"   >ERROR,55P03,"canceling statement due to lock timeout"</span></div><div><br></div><div>如果你的环境遇到这种问题了，怎么处理比较好呢？</div><div>1. 提高IO能力</div><div>2. 将数据块改为32KB，必须重新编译PostgreSQL，重新初始化数据库，迁移数据。</div><div>3. 监控，遇到高并发的块扩展等待，自动杀掉。</div><div>下面是自动杀的方法：</div><div>将pg_locks中的mode信息转换为数字，数字越大，锁级别越高。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create or replace function f_lock_level(i_mode text) returns int as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; case i_mode</font></div><div><font size="2"   >&nbsp; &nbsp; when 'INVALID' then return 0;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'AccessShareLock' then return 1;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'RowShareLock' then return 2;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'RowExclusiveLock' then return 3;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ShareUpdateExclusiveLock' then return 4;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ShareLock' then return 5;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ShareRowExclusiveLock' then return 6;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ExclusiveLock' then return 7;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'AccessExclusiveLock' then return 8;</font></div><div><font size="2"   >&nbsp; &nbsp; else return 0;</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >end;&nbsp;</font></div><div><font size="2"   >$$ language plpgsql strict;</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >事务持续时间和发生等待的会话个数作为参数，当扩展数据块的锁等待超出时间和会话个数时，杀掉这些会话。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create or replace function f_kill_extend(i_interval interval, i_waiting int8) returns void as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; v_database oid;</font></div><div><font size="2"   >&nbsp; v_relation oid;</font></div><div><font size="2"   >&nbsp; v_pid int;</font></div><div><font size="2"   >&nbsp; v_record record;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >if (pg_is_in_recovery()) then</font></div><div><font size="2"   >&nbsp; return;</font></div><div><font size="2"   >end if;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >for v_record in with t_wait as &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >(select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a,transactionid,b.query,b.xact_start,b.query_start,b.usename,b.datname from pg_locks a,pg_stat_activity b where a.pid=b.pid and not a.granted),</font></div><div><font size="2"   >t_run as&nbsp;</font></div><div><font size="2"   >(select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a,transactionid,b.query,b.xact_start,b.query_start,b.usename,b.datname from pg_locks a,pg_stat_activity b where a.pid=b.pid and a.granted)&nbsp;</font></div><div><font size="2"   >select r.locktype,r.mode r_mode,r.usename r_user,r.datname r_db,r.relation::regclass,r.pid r_pid,r.xact_start r_xact_start,r.query_start r_query_start,now()-r.query_start r_locktime,r.query r_query,</font></div><div><font size="2"   >w.mode w_mode,w.pid w_pid,w.xact_start w_xact_start,w.query_start w_query_start,now()-w.query_start w_locktime,w.query w_query &nbsp;</font></div><div><font size="2"   >from t_wait w,t_run r where</font></div><div><font size="2"   >&nbsp; r.locktype is not distinct from w.locktype and</font></div><div><font size="2"   >&nbsp; r.database is not distinct from w.database and</font></div><div><font size="2"   >&nbsp; r.relation is not distinct from w.relation and</font></div><div><font size="2"   >&nbsp; r.page is not distinct from w.page and</font></div><div><font size="2"   >&nbsp; r.tuple is not distinct from w.tuple and</font></div><div><font size="2"   >&nbsp; r.classid is not distinct from w.classid and</font></div><div><font size="2"   >&nbsp; r.objid is not distinct from w.objid and</font></div><div><font size="2"   >&nbsp; r.objsubid is not distinct from w.objsubid and</font></div><div><font size="2"   >&nbsp; r.transactionid is not distinct from w.transactionid and</font></div><div><font size="2"   >&nbsp; r.pid &lt;&gt; w.pid</font></div><div><font size="2"   >&nbsp; order by f_lock_level(w.mode)+f_lock_level(r.mode) desc,r.xact_start&nbsp;</font></div><div><font size="2"   >LOOP</font></div><div><font size="2"   >&nbsp; raise notice '%', v_record;</font></div><div><font size="2"   >END LOOP;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >for v_database,v_relation in select database,relation from pg_locks where&nbsp;</font></div><div><font size="2"   >&nbsp; locktype='extend' and mode='ExclusiveLock' and not&nbsp;granted and</font></div><div><font size="2"   >&nbsp; pid in (select pid from pg_stat_activity where now()-xact_start &gt; i_interval)&nbsp;</font></div><div><font size="2"   >&nbsp; group by 1,2 having count(*) &gt; i_waiting</font></div><div><font size="2"   >loop</font></div><div><font size="2"   >&nbsp; perform pg_terminate_backend(pid) from pg_locks&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; where locktype='extend' and mode='ExclusiveLock'&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; and database=v_database and relation=v_relation;</font></div><div><font size="2"   >end loop;</font></div><div><font size="2"   >return;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql strict;</font></div><p></p></pre></div><div>输出示例：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select f_kill_extend(interval '1 s', 10);</font></div><div><font size="2"   >NOTICE: &nbsp;(extend,ExclusiveLock,digoal,digoal,16399,13698,"2015-05-11 13:14:55.10005+08","2015-05-11 13:14:55.100272+08",00:00:00.309695,"update tbl set crt_time=now() where id between $1 and $2+10000;",ExclusiveLock,13671,"2015-05-11 13:14:55.315437+08","2015-05-11 13:14:55.315592+08",00:00:00.094375,"update tbl set crt_time=now() where id between $1 and $2+10000;")</font></div><div><font size="2"   >NOTICE: &nbsp;(extend,ExclusiveLock,digoal,digoal,16399,13698,"2015-05-11 13:14:55.10005+08","2015-05-11 13:14:55.100272+08",00:00:00.309695,"update tbl set crt_time=now() where id between $1 and $2+10000;",ExclusiveLock,13681,"2015-05-11 13:14:55.037967+08","2015-05-11 13:14:55.038253+08",00:00:00.371714,"update tbl set crt_time=now() where id between $1 and $2+10000;")</font></div><div><font size="2"   >NOTICE: &nbsp;(extend,ExclusiveLock,digoal,digoal,16399,13698,"2015-05-11 13:14:55.10005+08","2015-05-11 13:14:55.100272+08",00:00:00.309695,"update tbl set crt_time=now() where id between $1 and $2+10000;",ExclusiveLock,13665,"2015-05-11 13:14:55.129919+08","2015-05-11 13:14:55.130171+08",00:00:00.279796,"update tbl set crt_time=now() where id between $1 and $2+10000;")</font></div><div><font size="2"   >NOTICE: &nbsp;(extend,ExclusiveLock,digoal,digoal,16399,13698,"2015-05-11 13:14:55.10005+08","2015-05-11 13:14:55.100272+08",00:00:00.309695,"update tbl set crt_time=now() where id between $1 and $2+10000;",ExclusiveLock,13699,"2015-05-11 13:14:55.229596+08","2015-05-11 13:14:55.229881+08",00:00:00.180086,"update tbl set crt_time=now() where id between $1 and $2+10000;")</font></div><div><font size="2"   >NOTICE: &nbsp;(extend,ExclusiveLock,digoal,digoal,16399,13698,"2015-05-11 13:14:55.10005+08","2015-05-11 13:14:55.100272+08",00:00:00.309695,"update tbl set crt_time=now() where id between $1 and $2+10000;",ExclusiveLock,13677,"2015-05-11 13:14:55.276543+08","2015-05-11 13:14:55.276723+08",00:00:00.133244,"update tbl set crt_time=now() where id between $1 and $2+10000;")</font></div><div><font size="2"   >NOTICE: &nbsp;(transactionid,ExclusiveLock,digoal,digoal,,13564,"2015-05-11 13:12:48.891089+08","2015-05-11 13:13:02.936059+08",00:01:52.473908,"update tbl set info=now() where id=1;",ShareLock,13614,"2015-05-11 13:13:12.810098+08","2015-05-11 13:13:21.54997+08",00:01:33.859997,"update tbl set info=now() where id&lt;1000;")</font></div><div><font size="2"   >&nbsp;f_kill_extend&nbsp;</font></div><div><font size="2"   >---------------</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015410104726197/"   >http://blog.163.com/digoal@126/blog/static/1638770402015410104726197/</a></div><div>2.&nbsp;src/backend/storage/lmgr/lock.c</div><div>3.&nbsp;src/include/storage/lock.h</div><div>4.&nbsp;src/backend/storage/smgr/md.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;mdextend() -- Add a block to the specified relation.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;The semantics are nearly the same as mdwrite(): write at the</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;specified position. &nbsp;However, this is to be used for the case of</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;extending a relation (i.e., blocknum is at or beyond the current</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EOF). &nbsp;Note that we assume writing a block beyond current EOF</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;causes intervening file space to become filled with zeroes.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >mdextend(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;char *buffer, bool skipFsync)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; off_t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seekpos;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; MdfdVec &nbsp; &nbsp;*v;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* This assert is too expensive to have on normally ... */</font></div><div><font size="2"   >#ifdef CHECK_WRITE_VS_EXTEND</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(blocknum &gt;= mdnblocks(reln, forknum));</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If a relation manages to grow to 2^32-1 blocks, refuse to extend it any</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* more --- we mustn't create a block whose number actually is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* InvalidBlockNumber.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (blocknum == InvalidBlockNumber)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("cannot extend file \"%s\" beyond %u blocks",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relpath(reln-&gt;smgr_rnode, forknum),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidBlockNumber)));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; v = _mdfd_getseg(reln, forknum, blocknum, skipFsync, EXTENSION_CREATE);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; seekpos = (off_t) BLCKSZ *(blocknum % ((BlockNumber) RELSEG_SIZE));</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(seekpos &lt; (off_t) BLCKSZ * RELSEG_SIZE);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: because caller usually obtained blocknum by calling mdnblocks,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* which did a seek(SEEK_END), this seek is often redundant and will be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* optimized away by fd.c. &nbsp;It's not redundant, however, if there is a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* partial page at the end of the file. In that case we want to try to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* overwrite the partial page with a full page. &nbsp;It's also not redundant</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* if bufmgr.c had to dump another buffer of the same file to make room</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* for the new page's buffer.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (FileSeek(v-&gt;mdfd_vfd, seekpos, SEEK_SET) != seekpos)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode_for_file_access(),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not seek to block %u in file \"%s\": %m",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocknum, FilePathName(v-&gt;mdfd_vfd))));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if ((nbytes = FileWrite(v-&gt;mdfd_vfd, buffer, BLCKSZ)) != BLCKSZ)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nbytes &lt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode_for_file_access(),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not extend file \"%s\": %m",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FilePathName(v-&gt;mdfd_vfd)),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("Check free disk space.")));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* short write: complain appropriately */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_DISK_FULL),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not extend file \"%s\": wrote only %d of %d bytes at block %u",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FilePathName(v-&gt;mdfd_vfd),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes, BLCKSZ, blocknum),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("Check free disk space.")));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!skipFsync &amp;&amp; !SmgrIsTemp(reln))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; register_dirty_segment(reln, forknum, v);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(_mdnblocks(reln, forknum, v) &lt;= ((BlockNumber) RELSEG_SIZE));</font></div></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="parallel blocking|waiting by slow BLOCK extend relation , ExclusiveLock on extension of relation - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>