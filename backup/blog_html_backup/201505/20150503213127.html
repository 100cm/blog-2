<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">why postgresql cann't reclaim tuple is HEAPTUPLE_RECENTLY_DEAD</h2>
	<h5 id="">2015-05-03 21:31:27&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020153305256157/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>前几天写过一篇文章关于如何防止PostgreSQL表膨胀。</div><div>其中有一条是避免持有事务排他锁的长事务，因为这个事务开始到结束之间产生的垃圾无法被回收，容易导致膨胀。</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015329115636287/"   >http://blog.163.com/digoal@126/blog/static/1638770402015329115636287/</a></div><div><br></div><div>具体是什么原因呢？</div><div>看看PostgreSQL垃圾回收代码就知道原因了。</div><div><br></div><div><span style="line-height: 28px;"   >回收垃圾的函数其中之一</span></div><div>src/backend/commands/vacuumlazy.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;lazy_scan_heap() -- scan an open heap relation</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This routine prunes each page in the heap, which will among other</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;things truncate dead tuples to dead line pointers, defragment the</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;page, and set commit status bits (see heap_page_prune). &nbsp;It also builds</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lists of dead tuples and pages with free space, calculates statistics</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on the number of live tuples in the heap, and marks pages as</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;all-visible if appropriate. &nbsp;When done, or when we run low on space for</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dead-tuple TIDs, invoke vacuuming of indexes and call lazy_vacuum_heap</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;to reclaim dead line pointers.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If there are no indexes then we can reclaim line pointers on the fly;</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dead line pointers need only be retained until all index pointers that</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reference them have been killed.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static void</font></div><div><font size="2"   >lazy_scan_heap(Relation onerel, LVRelStats *vacrelstats,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Relation *Irel, int nindexes, bool scan_all)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; for (blkno = 0; blkno &lt; nblocks; blkno++)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;buf;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;page;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tupgone, &nbsp;// 表示TUPLE是否可以回收</font></div></div><div><font size="2"   >......</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: If you change anything in the loop below, also look at</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* heap_page_is_all_visible to see if that needs to be changed.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (offnum = FirstOffsetNumber;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;offnum &lt;= maxoff;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;offnum = OffsetNumberNext(offnum))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;itemid;</font></div></div><div><font size="2"   >......</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupgone = false;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switch (HeapTupleSatisfiesVacuum(&amp;tuple, OldestXmin, buf)) &nbsp;// 判断TUPLE状态，是否满足VACUUM条件</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case HEAPTUPLE_DEAD:</font></div></div><div><font size="2"   >......</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (HeapTupleIsHotUpdated(&amp;tuple) ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleIsHeapOnly(&amp;tuple))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeep += 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupgone = true; /* we can delete the tuple */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_visible = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div></div><div><font size="2"   >......</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case HEAPTUPLE_RECENTLY_DEAD: &nbsp; // 这就表示在最老的活动事务之后产生的垃圾, 无法回收</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If tuple is recently deleted then we must not remove it</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* from relation.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeep += 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_visible = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div></div><p></p></pre></div><div><br></div><div>我们看看<span style="line-height: 28px;"   >HeapTupleSatisfiesVacuum(&amp;tuple, OldestXmin, buf)这个用于判断TUPLE是否满足VACUUM条件的函数</span></div><div><div style="line-height: 28px;"   >OldestXmin如何获得？</div><div>src/backend/commands/vacuum.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* vacuum_set_xid_limits() -- compute oldest-Xmin and freeze cutoff points</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The output parameters are:</font></div><div><font size="2"   >&nbsp;* - oldestXmin is the cutoff value used to distinguish whether tuples are</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; DEAD or RECENTLY_DEAD (see HeapTupleSatisfiesVacuum).</font></div><div><font size="2"   >&nbsp;* - freezeLimit is the Xid below which all Xids are replaced by</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; FrozenTransactionId during vacuum.</font></div><div><font size="2"   >&nbsp;* - xidFullScanLimit (computed from table_freeze_age parameter)</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; represents a minimum Xid value; a table whose relfrozenxid is older than</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; this will have a full-table vacuum applied to it, to freeze tuples across</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; the whole table. &nbsp;Vacuuming a table younger than this value can use a</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; partial scan.</font></div><div><font size="2"   >&nbsp;* - multiXactCutoff is the value below which all MultiXactIds are removed from</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; Xmax.</font></div><div><font size="2"   >&nbsp;* - mxactFullScanLimit is a value against which a table's relminmxid value is</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; compared to produce a full-table vacuum, as with xidFullScanLimit.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* xidFullScanLimit and mxactFullScanLimit can be passed as NULL if caller is</font></div><div><font size="2"   >&nbsp;* not interested.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >vacuum_set_xid_limits(Relation rel,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int freeze_min_age,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int freeze_table_age,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int multixact_freeze_min_age,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int multixact_freeze_table_age,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *oldestXmin,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *freezeLimit,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *xidFullScanLimit,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactId *multiXactCutoff,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactId *mxactFullScanLimit)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >......</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We can always ignore processes running lazy vacuum. &nbsp;This is because we</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* use these values only for deciding which tuples we must keep in the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* tables. &nbsp;Since lazy vacuum doesn't write its XID anywhere, it's safe to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ignore it. &nbsp;In theory it could be problematic to ignore lazy vacuums in</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* a full vacuum, but keep in mind that only one vacuum process can be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* working on a particular table at any time, and that each vacuum is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* always an independent transaction.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; *oldestXmin = GetOldestXmin(rel, true); &nbsp;// 设置当前系统中最老的未提交的事务号</font></div></div><p></p></pre></div><div><br></div><div style="line-height: 28px;"   >src/backend/storage/ipc/procarray.c</div><div><div><pre class="prettyprint"   ><p style="line-height: 28px;"   ></p><div><div><div style="line-height: 28px;"   ><font size="2"   >/*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* GetOldestXmin -- returns oldest transaction that was running</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;when any current transaction was started.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* If rel is NULL or a shared relation, all backends are considered, otherwise</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* only backends running in this database are considered.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* If ignoreVacuum is TRUE then backends with the PROC_IN_VACUUM flag set are</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* ignored.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* This is used by VACUUM to decide which deleted tuples must be preserved in</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* the passed in table. For shared relations backends in all databases must be</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* considered, but for non-shared relations that's not required, since only</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* backends in my own database could ever see the tuples in them. Also, we can</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* ignore concurrently running lazy VACUUMs because (a) they must be working</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* on other tables, and (b) they don't need to do snapshot-based lookups.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* This is also used to determine where to truncate pg_subtrans. &nbsp;For that</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* backends in all databases have to be considered, so rel = NULL has to be</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* passed in.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* Note: we include all currently running xids in the set of considered xids.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* This ensures that if a just-started xact has not yet set its snapshot,</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* when it does set the snapshot it cannot set xmin less than what we compute.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* See notes in src/backend/access/transam/README.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* Note: despite the above, it's possible for the calculated value to move</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* backwards on repeated calls. The calculated value is conservative, so that</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* anything older is definitely not considered as running by anyone anymore,</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* but the exact value calculated depends on a number of things. For example,</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* if rel = NULL and there are no transactions running in the current</font></div><div><font size="2"   style="line-height: 28px;"   >&nbsp;* database, GetOldestXmin() returns latestCompletedXid. If a transaction   &nbsp;</font></div><div><font size="2"   ><span style="line-height: 21px;"   >  //  latestCompletedXid</span></font><span style="line-height: 21px; font-size: small; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, 宋体;"   >集群中最新的已提交事务号，这以后的所有事务</span></div><div><span style="line-height: 21px; font-size: small; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, 宋体;"   >   //    即使在后来变成垃圾, 也不回收。vacuum不考虑其他未提交事务是否需要看到这些垃圾数据(隔离级别为repeatable read级别及以上的可能会读到)</span></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* begins after that, its xmin will include in-progress transactions in other</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* databases that started earlier, so another call will return a lower value.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* Nonetheless it is safe to vacuum a table in the current database with the</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* first result. &nbsp;There are also replication-related effects: a walsender</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* process can set its xmin based on transactions that are no longer running</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* in the master but are still being replayed on the standby, thus possibly</font></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* making the GetOldestXmin reading go backwards. &nbsp;In this case there is a</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* possibility that we lose data that the standby would like to have, but</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* there is little we can do about that --- data is only protected if the</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* walsender runs continuously while queries are executed on the standby.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* (The Hot Standby code deals with such cases by failing standby queries</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* that needed to access already-removed data, so there's no integrity bug.)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* The return value is also adjusted with vacuum_defer_cleanup_age, so</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* increasing that setting on the fly is another easy way to make</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* GetOldestXmin() move backwards, with no consequences for data integrity.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 28px;"   ><font size="2"   >TransactionId</font></div><div style="line-height: 28px;"   ><font size="2"   >GetOldestXmin(Relation rel, bool ignoreVacuum)</font></div><div style="line-height: 28px;"   ><font size="2"   >{</font></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ProcArrayStruct *arrayP = procArray;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId result; &nbsp;// 返回结果</font></div></div></div></div></div><div style="line-height: 28px;"   ><font size="2"   >......</font></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We initialize the MIN() calculation with latestCompletedXid + 1. This</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* is a lower bound for the XIDs that might appear in the ProcArray later,</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* and so protects us against overestimating the result due to future</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* additions.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; result = ShmemVariableCache-&gt;latestCompletedXid;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsNormal(result));</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdAdvance(result);</font></div></div><p style="line-height: 28px;"   ></p></pre></div></div></div><div style="line-height: 28px;"   ><br></div><div>src/include/access/transam.h</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/* in transam/varsup.c */</font></div><div><font size="2"   >extern PGDLLIMPORT VariableCache ShmemVariableCache;</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* VariableCache is a data structure in shared memory that is used to track</font></div><div><font size="2"   >&nbsp;* OID and XID assignment state. &nbsp;For largely historical reasons, there is</font></div><div><font size="2"   >&nbsp;* just one struct with different fields that are protected by different</font></div><div><font size="2"   >&nbsp;* LWLocks.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: xidWrapLimit and oldestXidDB are not "active" values, but are</font></div><div><font size="2"   >&nbsp;* used just to generate useful messages when xidWarnLimit or xidStopLimit</font></div><div><font size="2"   >&nbsp;* are exceeded.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef struct VariableCacheData</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* These fields are protected by OidGenLock.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextOid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* next OID to assign */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;oidCount; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* OIDs available before must do XLOG work */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* These fields are protected by XidGenLock.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId nextXid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* next XID to assign */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId oldestXid; &nbsp; &nbsp; &nbsp; &nbsp;/* cluster-wide minimum datfrozenxid */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidVacLimit; &nbsp; &nbsp; &nbsp;/* start forcing autovacuums here */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidWarnLimit; /* start complaining here */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidStopLimit; /* refuse to advance nextXid beyond here */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidWrapLimit; /* where the world ends */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestXidDB; &nbsp; &nbsp;/* database with minimum datfrozenxid */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* These fields are protected by ProcArrayLock.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId latestCompletedXid; &nbsp; &nbsp; &nbsp; /* newest XID that has committed or  这就是集群中最新的已提交事务号</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* aborted */</font></div><div><font size="2"   >} VariableCacheData;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >typedef VariableCacheData *VariableCache;</font></div></div><p></p></pre></div><div>可以看到，PostgreSQL垃圾回收时，只是判断TUPLE是否是在垃圾回收开始后产生的，如果是，那么就不回收。</div><div>类似使用这个函数的效果：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >txid_current_snapshot()</font></div><div><div><font size="2"   >Snapshot Components</font></div><div><font size="2"   >Name<span>	</span>Description</font></div><div><font size="2"   >xmin<span>	</span>Earliest transaction ID (txid) that is still active. All earlier transactions will either be committed and visible, or rolled back and dead.</font></div><div><font size="2"   >// 执行vacuum的进程开始时，根据当时snapshot取到这个XMIN，在扫描垃圾TUPLE时，大于这个XMIN的垃圾即是HEAPTUPLE_RECENTLY_DEAD</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >xmax<span>	</span>First as-yet-unassigned txid. All txids greater than or equal to this are not yet started as of the time of the snapshot, and thus invisible.</font></div><div><font size="2"   >xip_list<span>	</span>Active txids at the time of the snapshot. The list includes only those active txids between xmin and xmax; there might be active txids higher than xmax. A txid that is xmin &lt;= txid &lt; xmax and not in this list was already completed at the time of the snapshot, and thus either visible or dead according to its commit status. The list does not include txids of subtransactions.</font></div><div><font size="2"   >txid_snapshot's textual representation is xmin:xmax:xip_list. For example 10:20:10,14,15 means xmin=10, xmax=20, xip_list=10, 14, 15.</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >要解决这个容易膨胀的问题，我们需要知道数据库中存在的最老的未提交的repeatable read或serializable隔离级别的事务号。</span></div><div>用这个事务号作为判断HEAPTUPLE_RECENTLY_DEAD的依据。</div><div>例如，当A库中存在级别<span style="line-height: 28px;"   >repeatable read或serializable的最小未结束事务号为Xa, 那么A库中Xa后产生的垃圾不能回收，但是其他库Xa后产生的垃圾能否回收和其他库中的最小</span><span style="line-height: 28px;"   >repeatable read或serializable未结束事务号有关，和A库无关</span><span style="line-height: 28px;"   >。</span></div><div><br></div><div style="line-height: 28px;"   >[参考]</div><div style="line-height: 28px;"   >1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015329115636287/"   >http://blog.163.com/digoal@126/blog/static/1638770402015329115636287/</a></div><div>2. src/include/storage/proc.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Prior to PostgreSQL 9.2, the fields below were stored as part of the</font></div><div><font size="2"   >&nbsp;* PGPROC. &nbsp;However, benchmarking revealed that packing these particular</font></div><div><font size="2"   >&nbsp;* members into a separate array as tightly as possible sped up GetSnapshotData</font></div><div><font size="2"   >&nbsp;* considerably on systems with many CPU cores, by reducing the number of</font></div><div><font size="2"   >&nbsp;* cache lines needing to be fetched. &nbsp;Thus, think very carefully before adding</font></div><div><font size="2"   >&nbsp;* anything else here.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef struct PGXACT</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* id of top-level transaction currently being</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* executed by this proc, if running and XID</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* is assigned; else InvalidTransactionId */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xmin; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* minimal running XID as it was when we were</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* starting our xact, excluding LAZY VACUUM:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* vacuum must not remove tuples deleted by</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* xid &gt;= xmin ! */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacuumFlags; &nbsp; &nbsp;/* vacuum-related flags, see above */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;overflowed;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;delayChkpt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* true if this proc delays checkpoint start;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* previously called InCommit */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids;</font></div><div><font size="2"   >} PGXACT;</font></div><p></p></pre></div><div><br></div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="why postgresql cannt reclaim tuple is HEAPTUPLE_RECENTLY_DEAD - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>