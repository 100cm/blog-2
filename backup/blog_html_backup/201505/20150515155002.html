<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.5 new feature - pg_audit module</h2>
	<h5 id="">2015-05-15 15:50:02&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201541595510867/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>以前写过一些PostgreSQL审计相关的文章，有些是通过系统自带的参数来配置审计功能的，还有是通过扩展模块来配置审计的，还有通过事件触发器，或者触发器来实现跟踪和审计的。如下：</div><div>1. PostgreSQL自带的日志审计，实现语句级别，数据库级别，用户级别的审计。</div><div>弊端是审计颗粒度太大。</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020132208241607/"   >http://blog.163.com/digoal@126/blog/static/16387704020132208241607/</a></div><div>通过触发器来审计表级别，行级别（带条件的），用户级别的数据库操作。</div><div>弊端是开销大。</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020132209854525/"   >http://blog.163.com/digoal@126/blog/static/16387704020132209854525/</a></div><div>通过事件触发器审计数据库或限制数据库的DDL操作。</div><div>弊端是目前只能审计DDL操作。</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020132131361949/"   >http://blog.163.com/digoal@126/blog/static/16387704020132131361949/</a></div><div>使用pg_log_userqueries模块审计用户级或数据库级的数据库操作。</div><div>弊端是颗粒度太大。</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012019112218804/"   >http://blog.163.com/digoal@126/blog/static/1638770402012019112218804/</a></div><div>使用hstore和触发器跟踪表级别的数据操作。</div><div>弊端是性能开销大。</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201252575529358/"   >http://blog.163.com/digoal@126/blog/static/163877040201252575529358/</a></div><div><span style="line-height: 28px;"   >使用hstore和触发器跟踪表级别的数据操作，并实现flashback query。</span></div><div><span style="line-height: 28px;"   >弊端是性能开销大，不适合频繁DML操作的表。</span></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402014728105442434/"   >http://blog.163.com/digoal@126/blog/static/1638770402014728105442434/</a></div><div>修改数据库默认的命令级别，GetCommandLogLevel@src/backend/tcop/utility.c，<span style="line-height: 28px;"   >定制日志输出。</span></div><div><span style="line-height: 28px;"   >弊端是需要修改源码。</span></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201421702248430/"   >http://blog.163.com/digoal@126/blog/static/163877040201421702248430/</a></div><div><br></div><div>这些审计功能可以满足大部分需求，需要非常细的审计，可以用触发器，需要颗粒度大的，性能损耗小的审计，用数据库自带的配置。但是我如果又要细的，又要性能损耗小的，目前还不支持。</div><div>包括今天我要说的这个9.5的插件，其实也是颗粒度较大的，审计没有细化到行级别，要做行级别的审计，还是需要用触发器。</div><div>今天要说的这个插件是通过钩子来实现审计的，</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Install our hook functions after saving the existing pointers to preserve</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the chains.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; next_ExecutorStart_hook = ExecutorStart_hook;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ExecutorStart_hook = pg_audit_ExecutorStart_hook;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; next_ExecutorCheckPerms_hook = ExecutorCheckPerms_hook;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ExecutorCheckPerms_hook = pg_audit_ExecutorCheckPerms_hook;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; next_ProcessUtility_hook = ProcessUtility_hook;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ProcessUtility_hook = pg_audit_ProcessUtility_hook;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; next_object_access_hook = object_access_hook;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; object_access_hook = pg_audit_object_access_hook;</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >这几个钩子分别在这几处：</span></div><div>src/backend/executor/execMain.c</div><div>用来跟踪赋权和非DDL语句。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   > /* ----------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ExecutorStart</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This routine must be called at the beginning of any execution of any</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;query plan</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Takes a QueryDesc previously created by CreateQueryDesc (which is separate</font></div><div><font size="2"   >&nbsp;* only because some places use QueryDescs for utility commands). &nbsp;The tupDesc</font></div><div><font size="2"   >&nbsp;* field of the QueryDesc is filled in to describe the tuples that will be</font></div><div><font size="2"   >&nbsp;* returned, and the internal fields (estate and planstate) are set up.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* eflags contains flag bits as described in executor.h.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* NB: the CurrentMemoryContext when this is called will become the parent</font></div><div><font size="2"   >&nbsp;* of the per-query context used for this Executor invocation.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We provide a function hook variable that lets loadable plugins</font></div><div><font size="2"   >&nbsp;* get control when ExecutorStart is called. &nbsp;Such a plugin would</font></div><div><font size="2"   >&nbsp;* normally call standard_ExecutorStart().</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* ----------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >ExecutorStart(QueryDesc *queryDesc, int eflags)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (ExecutorStart_hook)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*ExecutorStart_hook) (queryDesc, eflags);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standard_ExecutorStart(queryDesc, eflags);</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   > /*</font></div><div><font size="2"   >&nbsp;* ExecCheckRTPerms</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Check access permissions for all relations listed in a range table.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Returns true if permissions are adequate. &nbsp;Otherwise, throws an appropriate</font></div><div><font size="2"   >&nbsp;* error if ereport_on_violation is true, or simply returns false otherwise.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note that this does NOT address row level security policies (aka: RLS). &nbsp;If</font></div><div><font size="2"   >&nbsp;* rows will be returned to the user as a result of this permission check</font></div><div><font size="2"   >&nbsp;* passing, then RLS also needs to be consulted (and check_enable_rls()).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* See rewrite/rowsecurity.c.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >bool</font></div><div><font size="2"   >ExecCheckRTPerms(List *rangeTable, bool ereport_on_violation)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ListCell &nbsp; *l;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result = true;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, rangeTable)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(l);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = ExecCheckRTEPerms(rte);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!result)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ereport_on_violation)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aclcheck_error(ACLCHECK_NO_PRIV, ACL_KIND_CLASS,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;get_rel_name(rte-&gt;relid));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (ExecutorCheckPerms_hook)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (*ExecutorCheckPerms_hook) (rangeTable,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ereport_on_violation);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return result;</font></div></div><div><font size="2"   >}</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >src/backend/tcop/utility.c</span></div><div>用来跟踪DDL。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   > /*</font></div><div><font size="2"   >&nbsp;* ProcessUtility</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;general utility function invoker</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;parsetree: the parse tree for the utility statement</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;queryString: original source text of command</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;context: identifies source of statement (toplevel client command,</font></div></div><div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;non-toplevel client command, subcommand of a larger utility command)</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;params: parameters to use during execution</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;dest: where to send results</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;completionTag: points to a buffer of size COMPLETION_TAG_BUFSIZE</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;in which to store a command completion status string.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Notes: as of PG 8.4, caller MUST supply a queryString; it is not</font></div><div><font size="2"   >&nbsp;* allowed anymore to pass NULL. &nbsp;(If you really don't have source text,</font></div><div><font size="2"   >&nbsp;* you can pass a constant string, perhaps "(query not available)".)</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* completionTag is only set nonempty if we want to return a nondefault status.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* completionTag may be NULL if caller doesn't want a status string.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >ProcessUtility(Node *parsetree,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const char *queryString,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ProcessUtilityContext context,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ParamListInfo params,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DestReceiver *dest,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;char *completionTag)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(queryString != NULL); &nbsp; &nbsp;/* required as of 8.4 */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We provide a function hook variable that lets loadable plugins get</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* control when ProcessUtility is called. &nbsp;Such a plugin would normally</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* call standard_ProcessUtility().</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (ProcessUtility_hook)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*ProcessUtility_hook) (parsetree, queryString,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context, params,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest, completionTag);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standard_ProcessUtility(parsetree, queryString,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context, params,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest, completionTag);</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div>pg_audit支持的跟踪语句分类如下：</div><div>依旧没有将INSERT,UPDATE,DELETE,TRUNCATE分开。</div><div>但是实际上通过对象审计可以实现比这个更强大的审计，例如可以将颗粒度细化到对象的privilege级别，如select,update,insert,delete,truncate on table, execute on function, ....。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/* Bits within auditLogBitmap, defines the classes we understand */</font></div><div><font size="2"   >#define LOG_DDL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (1 &lt;&lt; 0) &nbsp; &nbsp; &nbsp; &nbsp;/* CREATE/DROP/ALTER objects */</font></div><div><font size="2"   >#define LOG_FUNCTION &nbsp; &nbsp;(1 &lt;&lt; 1) &nbsp; &nbsp; &nbsp; &nbsp;/* Functions and DO blocks */</font></div><div><font size="2"   >#define LOG_MISC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(1 &lt;&lt; 2) &nbsp; &nbsp; &nbsp; &nbsp;/* Statements not covered */</font></div><div><font size="2"   >#define LOG_READ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(1 &lt;&lt; 3) &nbsp; &nbsp; &nbsp; &nbsp;/* SELECTs */</font></div><div><font size="2"   >#define LOG_ROLE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(1 &lt;&lt; 4) &nbsp; &nbsp; &nbsp; &nbsp;/* GRANT/REVOKE, CREATE/ALTER/DROP ROLE */</font></div><div><font size="2"   >#define LOG_WRITE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (1 &lt;&lt; 5) &nbsp; &nbsp; &nbsp; &nbsp;/* INSERT, UPDATE, DELETE, TRUNCATE */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define LOG_NONE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* nothing */</font></div><div><font size="2"   >#define LOG_ALL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (0xFFFFFFFF) &nbsp; &nbsp;/* All */</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >使用pg_audit模块的优势：</span></div><div>1. 可以记录嵌套级别的SQL，例如一个on line code, 或者函数调用，里面的SQL也可以被记录下来。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >shared_preload_libraries = 'pg_audit'</font></div><div><div><font size="2"   >pg_audit.log = 'function, ddl, write'</font></div><div><font size="2"   >pg_audit.log_parameter = on</font></div><div><font size="2"   >pg_audit.log_relation = on</font></div></div><p></p></pre></div><div><br></div><div>记录DDL：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create table tbl(id int);</font></div><div><font size="2"   >CREATE TABLE</font></div></div><div><font size="2"   >2015-05-15 15:11:17.463 CST,"postgres","postgres",5922,"[local]",55559bff.1722,8,"CREATE TABLE",2015-05-15 15:10:55 CST,2/5,1757,LOG,00000,"AUDIT: SESSION,2,1,DDL,CREATE TABLE,,,create table tbl(id int);,&lt;none&gt;",,,,,,"create table tbl(id int);",,"log_audit_event, pg_audit.c:686","psql"</font></div><p></p></pre></div><div><br></div><div>记录FUNCTION，以及内部DDL。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# do language plpgsql $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; for i in 1..100 loop</font></div><div><font size="2"   >&nbsp; &nbsp; execute 'create table test_'||i||' (id int)';&nbsp;</font></div><div><font size="2"   >&nbsp; end loop;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$;</font></div><div><font size="2"   >DO</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >2015-05-15 15:12:15.905 CST,"postgres","postgres",5922,"[local]",55559bff.1722,10,"DO",2015-05-15 15:10:55 CST,2/7,0,LOG,00000,"AUDIT: SESSION,3,1,FUNCTION,DO,,,""do language plpgsql $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; for i in 1..100 loop</font></div><div><font size="2"   >&nbsp; &nbsp; execute 'create table test_'||i||' (id int)';</font></div><div><font size="2"   >&nbsp; end loop;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$;"",&lt;none&gt;",,,,,,"do language plpgsql $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; for i in 1..100 loop</font></div><div><font size="2"   >&nbsp; &nbsp; execute 'create table test_'||i||' (id int)';</font></div><div><font size="2"   >&nbsp; end loop;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$;",,"log_audit_event, pg_audit.c:686","psql"</font></div><div><font size="2"   >2015-05-15 15:12:15.907 CST,"postgres","postgres",5922,"[local]",55559bff.1722,11,"DO",2015-05-15 15:10:55 CST,2/7,1758,LOG,00000,"AUDIT: SESSION,3,2,DDL,CREATE TABLE,,,create table test_1 (id int),&lt;none&gt;",,,,,"SQL statement ""create table test_1 (id int)""</font></div><div><font size="2"   >PL/pgSQL function inline_code_block line 5 at EXECUTE statement","do language plpgsql $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; for i in 1..100 loop</font></div><div><font size="2"   >&nbsp; &nbsp; execute 'create table test_'||i||' (id int)';</font></div><div><font size="2"   >&nbsp; end loop;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$;",,"log_audit_event, pg_audit.c:686","psql"</font></div></div><div><font size="2"   >......</font></div><div><div><font size="2"   >2015-05-15 15:12:15.949 CST,"postgres","postgres",5922,"[local]",55559bff.1722,110,"DO",2015-05-15 15:10:55 CST,2/7,1758,LOG,00000,"AUDIT: SESSION,3,101,DDL,CREATE TABLE,,,create table test_100 (id int),&lt;none&gt;",,,,,"SQL statement ""create table test_100 (id int)""</font></div><div><font size="2"   >PL/pgSQL function inline_code_block line 5 at EXECUTE statement","do language plpgsql $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; for i in 1..100 loop</font></div><div><font size="2"   >&nbsp; &nbsp; execute 'create table test_'||i||' (id int)';</font></div><div><font size="2"   >&nbsp; end loop;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$;",,"log_audit_event, pg_audit.c:686","psql"</font></div></div><p></p></pre></div><div><br></div><div>2. 支持对象审计，这种审计方法比较奇特，例如我要审计某个表的INSERT操作，那么首先在数据库中创建一个审计角色，把这个表的INSERT权限赋予给这个审计角色，那么任何人对这个表执行INSERT都会被审计。</div><div><pre class="prettyprint"   ><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* GUC variable for pg_audit.role</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Administrators can choose which role to base OBJECT auditing off of.</font></div><div><font size="2"   >&nbsp;* Object-level auditing uses the privileges which are granted to this role to</font></div><div><font size="2"   >&nbsp;* determine if a statement should be logged.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >char *auditRole = NULL;</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Object type, used for SELECT/DML statements and function calls.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* For relation objects, this is essentially relkind (though we do not have</font></div><div><font size="2"   >&nbsp;* access to a function which will just return a string given a relkind;</font></div><div><font size="2"   >&nbsp;* getRelationTypeDescription() comes close but is not public currently).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We also handle functions, so it isn't quite as simple as just relkind.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This should be kept consistent with what is returned from</font></div><div><font size="2"   >&nbsp;* pg_event_trigger_ddl_commands(), as that's what we use for DDL.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define OBJECT_TYPE_TABLE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "TABLE"</font></div><div><font size="2"   >#define OBJECT_TYPE_INDEX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "INDEX"</font></div><div><font size="2"   >#define OBJECT_TYPE_SEQUENCE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"SEQUENCE"</font></div><div><font size="2"   >#define OBJECT_TYPE_TOASTVALUE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"TOAST TABLE"</font></div><div><font size="2"   >#define OBJECT_TYPE_VIEW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"VIEW"</font></div><div><font size="2"   >#define OBJECT_TYPE_MATVIEW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "MATERIALIZED VIEW"</font></div><div><font size="2"   >#define OBJECT_TYPE_COMPOSITE_TYPE &nbsp; &nbsp; &nbsp;"COMPOSITE TYPE"</font></div><div><font size="2"   >#define OBJECT_TYPE_FOREIGN_TABLE &nbsp; &nbsp; &nbsp; "FOREIGN TABLE"</font></div><div><font size="2"   >#define OBJECT_TYPE_FUNCTION &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"FUNCTION"</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define OBJECT_TYPE_UNKNOWN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "UNKNOWN"</font></div></div><p></p></pre></div><div><br></div><div>测试：</div><div>假设我这里需要使用的是审计角色digoal。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg_audit.role = 'digoal'</font></div><div></div><p></p></pre></div><div><span style="line-height: 28px;"   >创建一个审计角色，digoal，不需要登录权限。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create role digoal nologin;</font></div><div></div><p></p></pre></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create table t(id int);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# delete from t;</font></div><div><font size="2"   >DELETE 0</font></div></div><div><div><font size="2"   >postgres=# grant select on t to digoal; &nbsp;-- 表示我要审计表t的select操作。</font></div><div><font size="2"   >GRANT</font></div><div><font size="2"   >postgres=# delete from t;</font></div><div><font size="2"   >DELETE 0</font></div></div><div><div><font size="2"   >postgres=# select * from t;</font></div><div><font size="2"   >&nbsp;id&nbsp;</font></div><div><font size="2"   >----</font></div><div><font size="2"   >(0 rows)</font></div></div><p></p></pre></div><div>查看日志，只有select操作被审计了，其他操作不会被审计。</div><div><pre class="prettyprint"   ><p><font size="2"   >2015-05-15 15:39:57.661 CST,"postgres","postgres",6572,"[local]",5555a299.19ac,4,"SELECT",2015-05-15 15:39:05 CST,2/7,0,LOG,00000,"AUDIT: OBJECT,2,1,READ,SELECT,TABLE,public.t,select * from t;,&lt;none&gt;",,,,,,"select * from t;",,"log_audit_event, pg_audit.c:686","psql"</font></p></pre></div><div>通过对象审计，可以将PostgreSQL的审计功能提升一个档次。</div><div><br></div><div>[参考]</div>1.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201421702248430/"   >http://blog.163.com/digoal@126/blog/static/163877040201421702248430/</a><br><wbr><div>2.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012019112218804/"   >http://blog.163.com/digoal@126/blog/static/1638770402012019112218804/</a></div><div>3.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201252575529358/"   >http://blog.163.com/digoal@126/blog/static/163877040201252575529358/</a></div><div>4.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020132131361949/"   >http://blog.163.com/digoal@126/blog/static/16387704020132131361949/</a></div><div>5.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020132208241607/"   >http://blog.163.com/digoal@126/blog/static/16387704020132208241607/</a></div><div>6.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020132209854525/"   >http://blog.163.com/digoal@126/blog/static/16387704020132209854525/</a></div><div>7.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402014728105442434/"   >http://blog.163.com/digoal@126/blog/static/1638770402014728105442434/</a></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL 9.5 new feature - pg_audit module - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>