<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Let PostgreSQL's On Schedule checkpoint write buffer smooth spread cycle by tuning IsCheckpointOnSchedule</h2>
	<h5 id="">2015-05-11 16:49:53&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201541134842882/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>如果要了解PostgreSQL checkpoint的机制，请参考我前面写的几篇checkpoint的源码分析。</div><div><div style="line-height: 28px;"   >1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201542103933969/"   >http://blog.163.com/digoal@126/blog/static/163877040201542103933969/</a></div><div style="line-height: 28px;"   >2.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015463252387/"   >http://blog.163.com/digoal@126/blog/static/1638770402015463252387/</a></div><div style="line-height: 28px;"   >3.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020154651655783/"   >http://blog.163.com/digoal@126/blog/static/16387704020154651655783/</a></div><div style="line-height: 28px;"   >4.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020154653422892/"   >http://blog.163.com/digoal@126/blog/static/16387704020154653422892/</a></div></div><div style="line-height: 28px;"   >在写前面几篇文章时，我发现一个问题，即PostgreSQL的checkpoint调度有点小问题，在使用了异步提交的情况下，并不能均匀的将buffer write分布到整个checkpoint_completion_target。</div><div style="line-height: 28px;"   >例如：</div><div style="line-height: 28px;"   >我这里的checkpoint 调度配置如下：</div><div><div style="line-height: 28px;"   >checkpoint_segments = 512</div><div style="line-height: 28px;"   >checkpoint_timeout = 5min</div><div style="line-height: 28px;"   >checkpoint_completion_target = 0.9</div><div style="line-height: 28px;"   >理论上checkpoint write buffer应该均匀的分布在<span style="line-height: 28px;"   >512*0.9个xlog范围内或5*0.9分钟内。</span></div><div><span style="line-height: 28px;"   >但如果开启了异步提交(</span>synchronous_commit=off<span style="line-height: 28px;"   >)，那么事情会变成怎么样呢？</span></div><div style="line-height: 28px;"   >使用stap进行跟踪：</div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># <span style="line-height: 21px;"   >stap -DMAXSKIPPED=100000 -v 11111 -e '</span></font></div><font size="2"   ><span style="line-height: 21px;"   >global s_var, e_var, stat_var;<br><br>/* probe smgr__md__read__start(ForkNumber, BlockNumber, Oid, Oid, Oid, int); */<br>probe process("/opt/pgsql/bin/postgres").mark("smgr__md__read__start") {<br>  s_var[pid(),1] = gettimeofday_us()<br>}<br><br>/* probe smgr__md__read__done(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int); */<br>probe process("/opt/pgsql/bin/postgres").mark("smgr__md__read__done") {<br>  e_var[pid(),1] = gettimeofday_us()<br>  if ( s_var[pid(),1] &gt; 0 )<br>    stat_var[pid(),1] &lt;&lt;&lt; e_var[pid(),1] - s_var[pid(),1]<br>}<br><br>/* probe smgr__md__write__start(ForkNumber, BlockNumber, Oid, Oid, Oid, int); */<br>probe process("/opt/pgsql/bin/postgres").mark("smgr__md__write__start") {<br>  s_var[pid(),2] = gettimeofday_us()<br>}<br><br>/* probe smgr__md__write__done(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int); */<br>probe process("/opt/pgsql/bin/postgres").mark("smgr__md__write__done") {<br>  e_var[pid(),2] = gettimeofday_us()<br>  if ( s_var[pid(),2] &gt; 0 )<br>    stat_var[pid(),2] &lt;&lt;&lt; e_var[pid(),2] - s_var[pid(),2]<br>}<br><br>probe process("/opt/pgsql/bin/postgres").mark("buffer__sync__start") {<br>  printf("buffer__sync__start num_buffers: %d, dirty_buffers: %d\n", $NBuffers, $num_to_write)<br>}<br><br>probe process("/opt/pgsql/bin/postgres").mark("checkpoint__start") {<br>  printf("checkpoint start\n")<br>}<br><br>probe process("/opt/pgsql/bin/postgres").mark("checkpoint__done") {<br>  printf("checkpoint done\n")<br>}<br><br>probe timer.s(1) {<br>  foreach ([v1,v2] in stat_var +) {<br>    if ( @count(stat_var[v1,v2]) &gt;0 ) {<br>      printf("r1_or_w2 %d, pid: %d, min: %d, max: %d, avg: %d, sum: %d, count: %d\n", v2, v1, @min(stat_var[v1,v2]), @max(stat_var[v1,v2]), @avg(stat_var[v1,v2]), @sum(stat_var[v1,v2]), @count(stat_var[v1,v2]))<br>    }<br>  }<br>  printf("----------------------------------end-----------------------------\n")<br>  delete s_var<br>  delete e_var<br>  delete stat_var<br>}'</span></font><p></p></pre></div><div>这里继续使用我前几篇写checkpoint原理的文章中的测试用例和测试数据。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >$ vi test.sql</font></div><div><font size="2"   >\setrandom id 1 50000000</font></div><div><font size="2"   >update tbl set crt_time=now() where id = :id ;</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >$&nbsp;pgbench -M prepared -n -r -f ./test.sql -P 1 -c 28 -j 28 -T 100000000</font></div><p></p></pre></div><div>发生检查点时的tps：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >progress: 255.0 s, 58152.2 tps, lat 0.462 ms stddev 0.504</font></div><div><font size="2"   >progress: 256.0 s, 31382.8 tps, lat 0.844 ms stddev 2.331</font></div><div><font size="2"   >progress: 257.0 s, 14615.5 tps, lat 1.863 ms stddev 4.554</font></div><div><font size="2"   >progress: 258.0 s, 16258.4 tps, lat 1.652 ms stddev 4.139</font></div><div><font size="2"   >progress: 259.0 s, 17814.7 tps, lat 1.526 ms stddev 4.035</font></div><div><font size="2"   >progress: 260.0 s, 14573.8 tps, lat 1.825 ms stddev 5.592</font></div><div><font size="2"   >progress: 261.0 s, 16736.6 tps, lat 1.600 ms stddev 5.018</font></div><div><font size="2"   >progress: 262.0 s, 19060.5 tps, lat 1.448 ms stddev 4.818</font></div><div><font size="2"   >progress: 263.0 s, 20553.2 tps, lat 1.290 ms stddev 4.146</font></div><div><font size="2"   >progress: 264.0 s, 26223.0 tps, lat 1.042 ms stddev 3.711</font></div><div><font size="2"   >progress: 265.0 s, 31953.0 tps, lat 0.836 ms stddev 2.837</font></div><div><font size="2"   >progress: 266.0 s, 43396.1 tps, lat 0.627 ms stddev 1.615</font></div><div><font size="2"   >progress: 267.0 s, 50487.8 tps, lat 0.533 ms stddev 0.647</font></div><div><font size="2"   >progress: 268.0 s, 53537.7 tps, lat 0.502 ms stddev 0.598</font></div><div><font size="2"   >progress: 269.0 s, 54259.3 tps, lat 0.496 ms stddev 0.624</font></div><div><font size="2"   >progress: 270.0 s, 56139.8 tps, lat 0.479 ms stddev 0.524</font></div><p></p></pre></div><div><br></div><div>stap跟踪输出：</div><div>当发生检查点时，checkpointer发生write buffer 的操作。但是你会发现，写buffer操作并不均匀，前面写得多，后面写得少。</div><div>正常情况下写<span style="line-height: 28px;"   >156467个buffer，均匀分布在5*0.9即270秒的话，每秒应该写579个脏块才算均匀。</span></div><div><span style="line-height: 28px;"   >但是实际情况是，第一秒写了8596个脏块，接下来的十几秒实际都超出了按时间均匀的速度，原因是XLOG步调更快，checkpointer根本停不下来：</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >checkpoint start</font></div><div><font size="2"   >buffer__sync__start num_buffers: 262144, dirty_buffers: 156467</font></div><div><p></p><div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 41, max: 1471, avg: 49, sum: 425291, count: 8596</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 41, max: 153, avg: 49, sum: 450597, count: 9078</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 41, max: 643, avg: 51, sum: 429193, count: 8397</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 41, max: 1042, avg: 55, sum: 449091, count: 8097</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 41, max: 254, avg: 52, sum: 296668, count: 5617</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 39, max: 171, avg: 54, sum: 321027, count: 5851</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 41, max: 138, avg: 60, sum: 300056, count: 4953</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 42, max: 1217, avg: 65, sum: 312859, count: 4748</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 41, max: 1371, avg: 56, sum: 353905, count: 6304</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 41, max: 358, avg: 58, sum: 236254, count: 4038</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 34, max: 1239, avg: 63, sum: 296906, count: 4703</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 31, max: 17408, avg: 63, sum: 415234, count: 6534</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 31, max: 5486, avg: 57, sum: 190345, count: 3318</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 29, max: 510, avg: 53, sum: 136221, count: 2563</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 32, max: 733, avg: 52, sum: 108327, count: 2070</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 34, max: 382, avg: 53, sum: 96157, count: 1812</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 43, max: 327, avg: 53, sum: 83641, count: 1571</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 33, max: 102, avg: 54, sum: 79991, count: 1468</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 35, max: 88, avg: 53, sum: 74338, count: 1389</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 32, max: 86, avg: 52, sum: 65710, count: 1243</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 30, max: 347, avg: 52, sum: 66866, count: 1263</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 31, max: 93, avg: 54, sum: 75642, count: 1398</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >r1_or_w2 2, pid: 19848, min: 33, max: 100, avg: 51, sum: 62302, count: 1216</font></div></div></div><div><font size="2"   >......</font></div><p></p></pre></div><div><div><span style="line-height: 28px;"   >原因分析：</span></div></div></div><div style="line-height: 28px;"   >因为开启了full page write的情况下，检查点后任何数据块第一次变脏时，需要写full page的WAL，所以导致WAL写的量会瞬间变大（假设测试用例是大表全随机更新的场景，第一次变脏的数据块更多，WAL瞬间量越大）。</div><div style="line-height: 28px;"   >因此，如果按XLOG的写入量来调度CHECKPOINTER的write buffer的话，前期write buffer就会更多，后期更少。</div><div style="line-height: 28px;"   >我们可以通过修改IsCheckpointOnSchedule来修正这个问题。当开启了full page write时，不使用XLOG调度，只是用时间调度，当然这样也有问题，有可能时间间隔很长，超出了checkpoint_segments，那么会导致检查点无法在下次检查点开始前结束write buffer的动作。</div><div>src/backend/postmaster/checkpointer.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* IsCheckpointOnSchedule -- are we on schedule to finish this checkpoint</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in time?</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Compares the current progress against the time/segments elapsed since last</font></div><div><font size="2"   >&nbsp;* checkpoint, and returns true if the progress we've made this far is greater</font></div><div><font size="2"   >&nbsp;* than the elapsed time/segments.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static bool</font></div><div><font size="2"   >IsCheckpointOnSchedule(double progress)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;recptr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct timeval now;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;elapsed_xlogs,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsed_time;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(ckpt_active);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Scale progress according to checkpoint_completion_target. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; progress *= CheckPointCompletionTarget;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check against the cached value first. Only do the more expensive</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* calculations once we reach the target previously calculated. Since</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* neither time or WAL insert pointer moves backwards, a freshly</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* calculated value can only be greater than or equal to the cached value.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (progress &lt; ckpt_cached_elapsed)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check progress against WAL segments written and checkpoint_segments.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We compare the current WAL insert location against the location</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We compare the current WAL insert location against the location</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* computed before calling CreateCheckPoint. The code in XLogInsert that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* actually triggers a checkpoint when checkpoint_segments is exceeded</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* compares against RedoRecptr, so this is not completely accurate.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* However, it's good enough for our purposes, we're only calculating an</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* estimate anyway.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/ &nbsp;// 问题出在<span style="line-height: 28px;"   >CheckPointSegments的计算方法上，因为再开启异步提交时，产生XLOG的步调比写buffer的步调更快。</span></font></div><div><span style="line-height: 28px;"   ><font size="2"   >                   // 因此写buffer在前期会赶不上写XLOG，导致前期写BUFFER要更多，后期写更少。</font></span></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!RecoveryInProgress())</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = GetInsertRecPtr();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsed_xlogs = (((double) (recptr - ckpt_start_recptr)) / XLogSegSize) / CheckPointSegments;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (progress &lt; elapsed_xlogs)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_cached_elapsed = elapsed_xlogs;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >           // 而时间检查不会出现这样的问题，因为时间是均匀的，所以可以让检查点写BUFFER的步调和时间步调一致。</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check progress against time elapsed and checkpoint_timeout.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; gettimeofday(&amp;now, NULL);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; elapsed_time = ((double) ((pg_time_t) now.tv_sec - ckpt_start_time) +</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; now.tv_usec / 1000000.0) / CheckPointTimeout;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (progress &lt; elapsed_time)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_cached_elapsed = elapsed_time;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* It looks like we're on schedule. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div>简单粗暴的解决办法，<span style="line-height: 28px;"   >修改代码如下：</span></div><div><div><div><pre class="prettyprint"   ><p style="line-height: 28px;"   ></p><div><div><font size="2"   style="line-height: 28px;"   >vi </font><font size="2"   ><span style="line-height: 21px;"   >src/backend/postmaster/checkpointer.c</span></font></div><div><br></div><div style="line-height: 28px;"   ><font size="2"   >/*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* IsCheckpointOnSchedule -- are we on schedule to finish this checkpoint</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in time?</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* Compares the current progress against the time/segments elapsed since last</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* checkpoint, and returns true if the progress we've made this far is greater</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* than the elapsed time/segments.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 28px;"   ><font size="2"   >static bool</font></div><div style="line-height: 28px;"   ><font size="2"   >IsCheckpointOnSchedule(double progress)</font></div><div style="line-height: 28px;"   ><font size="2"   >{</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;recptr;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct timeval now;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;elapsed_xlogs,</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsed_time;</font></div><div style="line-height: 28px;"   ><font size="2"   ><br style="line-height: 28px;"   ></font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(ckpt_active);</font></div><div style="line-height: 28px;"   ><font size="2"   ><br style="line-height: 28px;"   ></font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Scale progress according to checkpoint_completion_target. */</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; progress *= CheckPointCompletionTarget;</font></div><div style="line-height: 28px;"   ><font size="2"   ><br style="line-height: 28px;"   ></font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check against the cached value first. Only do the more expensive</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* calculations once we reach the target previously calculated. Since</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* neither time or WAL insert pointer moves backwards, a freshly</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* calculated value can only be greater than or equal to the cached value.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (progress &lt; ckpt_cached_elapsed)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div style="line-height: 28px;"   ><font size="2"   ><br></font></div><div><font size="2"   ><span style="line-height: 21px;"   >        /*<br>         * Check progress against WAL segments written and checkpoint_segments.<br>         *<br>         * We compare the current WAL insert location against the location<br>         * computed before calling CreateCheckPoint. The code in XLogInsert that<br>         * actually triggers a checkpoint when checkpoint_segments is exceeded<br>         * compares against RedoRecptr, so this is not completely accurate.<br>         * However, it's good enough for our purposes, we're only calculating an<br>         * estimate anyway.<br>         */<br>        if (!RecoveryInProgress())<br>        {<br>                if (!fullPageWrites</span></font><span style="line-height: 21px; font-size: small; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, 宋体;"   >)</span></div><div><font size="2"   ><span style="line-height: 21px;"   >                {<br>                    recptr = GetInsertRecPtr();<br>                    elapsed_xlogs = (((double) (recptr - ckpt_start_recptr)) / XLogSegSize) / CheckPointSegments;<br><br>                    if (progress &lt; elapsed_xlogs)<br>                    {<br>                        ckpt_cached_elapsed = elapsed_xlogs;<br>                        return false;<br>                    }</span></font></div><div><font size="2"   ><span style="line-height: 21px;"   >                 }<br>        }</span></font></div><div style="line-height: 28px;"   ><font size="2"   ><br></font></div></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check progress against time elapsed and checkpoint_timeout.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; gettimeofday(&amp;now, NULL);</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; elapsed_time = ((double) ((pg_time_t) now.tv_sec - ckpt_start_time) +</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; now.tv_usec / 1000000.0) / CheckPointTimeout;</font></div><div style="line-height: 28px;"   ><font size="2"   ><br style="line-height: 28px;"   ></font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (progress &lt; elapsed_time)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_cached_elapsed = elapsed_time;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div style="line-height: 28px;"   ><font size="2"   ><br style="line-height: 28px;"   ></font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* It looks like we're on schedule. */</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div style="line-height: 28px;"   ><font size="2"   >}</font></div></div><p style="line-height: 28px;"   ></p></pre></div></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ># gmake &amp;&amp; gmake install</div><div style="line-height: 28px;"   >重新测试：</div><div style="line-height: 28px;"   >pg_ctl restart -m fast</div><div style="line-height: 28px;"   >检查点发生时的tps：</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >progress: 291.0 s, 63144.9 tps, lat 0.426 ms stddev 0.383</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 292.0 s, 55063.7 tps, lat 0.480 ms stddev 1.433</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 293.0 s, 12225.3 tps, lat 2.238 ms stddev 4.460</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 294.0 s, 16436.4 tps, lat 1.621 ms stddev 4.043</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 295.0 s, 18516.5 tps, lat 1.444 ms stddev 3.286</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 296.0 s, 21983.7 tps, lat 1.251 ms stddev 2.941</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 297.0 s, 25759.7 tps, lat 1.034 ms stddev 2.356</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 298.0 s, 33139.4 tps, lat 0.821 ms stddev 1.676</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 299.0 s, 41904.9 tps, lat 0.644 ms stddev 1.134</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 300.0 s, 52432.9 tps, lat 0.513 ms stddev 0.470</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 301.0 s, 57115.4 tps, lat 0.471 ms stddev 0.325</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 302.0 s, 59422.1 tps, lat 0.452 ms stddev 0.297</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 303.0 s, 59860.5 tps, lat 0.449 ms stddev 0.309</font></div><p></p></pre></div></div><div style="line-height: 28px;"   >stap跟踪结果：</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >checkpoint start</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >buffer__sync__start num_buffers: 262144, dirty_buffers: 156761</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 51, max: 137, avg: 60, sum: 52016, count: 860</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 51, max: 108, avg: 58, sum: 35526, count: 604</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 51, max: 145, avg: 71, sum: 39779, count: 559</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 52, max: 172, avg: 79, sum: 47279, count: 594</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 44, max: 160, avg: 63, sum: 36907, count: 581</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 51, max: 113, avg: 61, sum: 33895, count: 552</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 51, max: 116, avg: 61, sum: 38177, count: 617</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 51, max: 113, avg: 62, sum: 34199, count: 550</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 53, max: 109, avg: 65, sum: 39842, count: 606</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 50, max: 118, avg: 64, sum: 35099, count: 545</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 50, max: 107, avg: 64, sum: 39027, count: 606</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 51, max: 114, avg: 62, sum: 34054, count: 545</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 47, max: 106, avg: 63, sum: 38573, count: 605</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 48, max: 101, avg: 62, sum: 38051, count: 607</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------end-----------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >r1_or_w2 2, pid: 22334, min: 42, max: 103, avg: 61, sum: 33596, count: 545</font></div><div style="line-height: 28px;"   ><font size="2"   >......</font></div><p></p></pre></div><div style="line-height: 28px;"   >现在写buffer已经比较均匀了，但是我们看到虽然现在checkpointer写BUFFER是均匀的，但是pgbench在checkpoint开始的前10秒左右还是有非常剧烈的性能下降然后逐渐上升。</div><div style="line-height: 28px;"   >因为我们这里只看到检查点写BUFFER带来的IO影响，其实性能下降还有其他因素在里面，这里先不阐述，和xlog有关，后面再写。</div><div style="line-height: 28px;"   >如果你的系统IO比较差，并且要使用异步XLOG提交的话，在做检查点时可能受到IO影响较大，建议你调整一下这部分代码，同时加大target参数，但是建议不超过0.9，最好是调整后观察IO影响会不会降低，降低到不影响业务为宜。</div><div style="line-height: 28px;"   ><br></div><div style="line-height: 28px;"   >为什么checkpoint后使用WAL调度会导致不均匀呢？或者说为什么wal会更快，因为我们这里使用的压力测试用例是大量的更新，checkpoint后会产生较多的wal full page write(如果你设置了full_page_writes=on)，所以另一种调教方法是，当打开了full page write, 给wal加一个指数来均衡，这个指数是一个经验值，所以也不是非常完美，个人还是比较偏向直接用时间来调度。</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   ><span>		</span>/*</font></div><div style="line-height: 28px;"   ><font size="2"   ><span>		</span> * Immediately after a checkpoint, a lot more WAL is generated when</font></div><div style="line-height: 28px;"   ><font size="2"   ><span>		</span> * full_page_write is enabled, because every WAL record has to include</font></div><div style="line-height: 28px;"   ><font size="2"   ><span>		</span> * a full image of the modified page. It levels off as time passes and</font></div><div style="line-height: 28px;"   ><font size="2"   ><span>		</span> * more updates fall on pages that have already been modified since</font></div><div style="line-height: 28px;"   ><font size="2"   ><span>		</span> * the last checkpoint.</font></div><div style="line-height: 28px;"   ><font size="2"   ><span>		</span> *</font></div><div style="line-height: 28px;"   ><font size="2"   ><span>		</span> * To correct for that effect, apply a corrective factor on the</font></div><div style="line-height: 28px;"   ><font size="2"   ><span>		</span> * amount of WAL consumed so far.</font></div><div style="line-height: 28px;"   ><font size="2"   ><span>		</span> */</font></div><div style="line-height: 28px;"   ><font size="2"   ><span>		</span>if (fullPageWrites)</font></div><div style="line-height: 28px;"   ><font size="2"   ><span>			</span>elapsed_xlogs = pow(elapsed_xlogs, 1.5);</font></div><p></p></pre></div></div></div></div></div><div>从另一个角度来看，XLOG产生速度越快，对IO的需求量越大，这个时候如果要降低checkpointer write buffer对IO的争抢，应该sleep才对，但是现有的策略是xlog产生速度越快，checkpointer write buffer也越多。所以单纯从时间角度来均衡checkpointer的写buffer可能比较靠谱。或者有好的算法可以做到产生XLOG越快的时候，让checkpointer尽量休息，而产生XLOG少的时候，让checkpointer快点写。</div><div><br></div>[参考]<wbr><div>1.&nbsp;src/backend/postmaster/checkpointer.c</div><div>2.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201542103933969/"   >http://blog.163.com/digoal@126/blog/static/163877040201542103933969/</a></div><div>3.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015463252387/"   >http://blog.163.com/digoal@126/blog/static/1638770402015463252387/</a></div><div>4.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020154651655783/"   >http://blog.163.com/digoal@126/blog/static/16387704020154651655783/</a></div><div>5.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020154653422892/"   >http://blog.163.com/digoal@126/blog/static/16387704020154653422892/</a></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="Lets PostgreSQL checkpoint write buffer smooth spread on time by tuning IsCheckpointOnSchedule - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>