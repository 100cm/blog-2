<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL Why checkpointer impact performance so much ? - 5</h2>
	<h5 id="">2015-05-12 9:07:09&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020154811421484/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>我们前面分析了checkpoint的原理，并且对整个过程checkpoint了跟踪，但是并未发现到底是什么造成tps的下降。</div><div><a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020154653422892/"   >http://blog.163.com/digoal@126/blog/static/16387704020154653422892/</a></div><div>本文主要针对PostgreSQL的lwlock重点跟踪一下：</div><div>src/backend/storage/lmgr/lwlock.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_WAIT_START(T_NAME(l), T_ID(l), mode);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (;;)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* "false" means cannot accept cancel/die interrupt here. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGSemaphoreLock(&amp;proc-&gt;sem, false);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!proc-&gt;lwWaiting)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits++;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_LWLOCK_WAIT_DONE(T_NAME(l), T_ID(l), mode);</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >src/include/storage/lwlock.h</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >typedef enum LWLockMode</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LW_SHARED,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LW_WAIT_UNTIL_FREE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* A special mode used in PGPROC-&gt;lwlockMode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* when waiting for lock to become free. Not</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to be used as LWLockAcquire argument */</font></div><div><font size="2"   >} LWLockMode;</font></div></pre></div><div><table border="1"   style="margin: 2ex 0px 2ex 2ex; -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border-spacing: 0px; border-collapse: collapse; border: 2px solid rgb(167, 198, 223); color: rgb(0, 0, 0); font-family: verdana, sans-serif; font-size: 12.1599998474121px; line-height: normal; background-color: rgb(224, 236, 239);"   ><tbody><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >lwlock-wait-start</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >(char *, int, LWLockMode)</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Probe that fires when an LWLock was not immediately available and a server process has begun to wait for the lock to become available. arg0 is the LWLock's tranche. arg1 is the LWLock's offset within its tranche. arg2 is the requested lock mode, either exclusive or shared.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >lwlock-wait-done</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >(char *, int, LWLockMode)</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Probe that fires when a server process has been released from its wait for an LWLock (it does not actually have the lock yet). arg0 is the LWLock's tranche. arg1 is the LWLock's offset within its tranche. arg2 is the requested lock mode, either exclusive or shared.</td></tr></table></div><div><br></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >$ vi test.sql</font></div><div><div><font size="2"   >\setrandom id 1 50000000</font></div><div><font size="2"   >update tbl set info=now(),crt_time=now() where id=:id;</font></div></div><div><div><font size="2"   >$ pgbench -M prepared -n -r -f ./test.sql -c 3 -j 3 -P 2 -T 100000000</font></div><div><div><font size="2"   >progress: 776.0 s, 13169.7 tps, lat 0.226 ms stddev 0.063</font></div><div><font size="2"   >progress: 778.0 s, 7930.0 tps, lat 0.377 ms stddev 0.096</font></div><div><font size="2"   >progress: 780.0 s, 7660.1 tps, lat 0.390 ms stddev 0.108</font></div><div><font size="2"   >progress: 782.0 s, 8118.8 tps, lat 0.368 ms stddev 0.098</font></div><div><font size="2"   >progress: 784.0 s, 8576.5 tps, lat 0.348 ms stddev 0.093</font></div><div><font size="2"   >progress: 786.0 s, 9251.4 tps, lat 0.323 ms stddev 0.085</font></div><div><font size="2"   >progress: 788.0 s, 9812.2 tps, lat 0.304 ms stddev 0.078</font></div><div><font size="2"   >progress: 790.0 s, 10036.8 tps, lat 0.297 ms stddev 0.074</font></div><div><font size="2"   >progress: 792.0 s, 10359.1 tps, lat 0.288 ms stddev 0.081</font></div><div><font size="2"   >progress: 794.0 s, 10675.3 tps, lat 0.280 ms stddev 0.077</font></div><div><font size="2"   >progress: 796.0 s, 10904.1 tps, lat 0.274 ms stddev 0.071</font></div><div><font size="2"   >progress: 798.0 s, 11470.2 tps, lat 0.260 ms stddev 0.076</font></div><div><font size="2"   >progress: 800.0 s, 11909.3 tps, lat 0.250 ms stddev 0.074</font></div><div><font size="2"   >progress: 802.0 s, 12297.4 tps, lat 0.243 ms stddev 0.073</font></div><div><font size="2"   >progress: 804.0 s, 12463.8 tps, lat 0.239 ms stddev 0.075</font></div><div><font size="2"   >progress: 806.0 s, 12513.3 tps, lat 0.238 ms stddev 0.076</font></div><div><font size="2"   >progress: 808.0 s, 12669.9 tps, lat 0.235 ms stddev 0.068</font></div></div></div><p></p></pre></div><div><div>以13000为TPS，一次请求需要230786.9微秒.</div><div>1000000*(1/(13000/3))</div><div><br></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# select pid,query from pg_stat_activity;</font></div><div><font size="2"   >&nbsp;pid &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------+-------------------------------------------------------</font></div><div><font size="2"   >&nbsp;4249 | update tbl set info=now(),crt_time=now() where id=$1;</font></div><div><font size="2"   >&nbsp;5527 | autovacuum: VACUUM ANALYZE digoal.tbl</font></div><div><font size="2"   >&nbsp;4250 | update tbl set info=now(),crt_time=now() where id=$1;</font></div><div><font size="2"   >&nbsp;4251 | update tbl set info=now(),crt_time=now() where id=$1;</font></div><div><font size="2"   >&nbsp;4134 | select pid,query from pg_stat_activity;</font></div><div><font size="2"   >(5 rows)</font></div></div><div><font size="2"   >ps -ewf|grep 1484</font></div><div><font size="2"   >postgres &nbsp;1484 30863 &nbsp;4 12:35 ? &nbsp; &nbsp; &nbsp; &nbsp;00:02:17 postgres: wal writer process&nbsp;</font></div><p></p></pre></div><div>跟踪这几个进程的锁等待情况。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># stap -DMAXSKIPPED=100000 -v 11111 -e '</font></div><div><font size="2"   >global s_var, e_var, stat_var;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* probe lwlock__wait__start(const char *, int, LWLockMode); */</font></div><div><font size="2"   >probe process("/opt/pgsql/bin/postgres").mark("lwlock__wait__start") {</font></div><div><font size="2"   >&nbsp; s_var[pid()] = gettimeofday_us()</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* probe lwlock__wait__done(const char *, int, LWLockMode); */</font></div><div><font size="2"   >probe process("/opt/pgsql/bin/postgres").mark("lwlock__wait__start") {</font></div><div><font size="2"   >&nbsp; e_var[pid()] = gettimeofday_us()</font></div><div><font size="2"   >&nbsp; if ( s_var[pid()] &gt; 0 &amp;&amp; ((pid() &gt;= 4249 &amp;&amp; pid() &lt;= 4251) || pid() ==1484 ) &nbsp; )</font></div><div><font size="2"   >&nbsp; &nbsp; stat_var[pid()] &lt;&lt;&lt; e_var[pid()] - s_var[pid()]</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe timer.s(1) {</font></div><div><font size="2"   >&nbsp; foreach ([v1] in stat_var +) {</font></div><div><font size="2"   >&nbsp; &nbsp; if ( @count(stat_var[v1]) &gt;0 ) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; printf("pid: %d, min: %d, max: %d, avg: %d, sum: %d, count: %d\n", v1, @min(stat_var[v1]), @max(stat_var[v1]), @avg(stat_var[v1]), @sum(stat_var[v1]), @count(stat_var[v1]))</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; printf("----------------------------------end-----------------------------\n")</font></div><div><font size="2"   >&nbsp; delete s_var</font></div><div><font size="2"   >&nbsp; delete e_var</font></div><div><font size="2"   >&nbsp; delete stat_var</font></div><div><font size="2"   >}'</font></div><p></p></pre></div></div><div><span style="line-height: 28px;"   >当检查点发生时，WAL writer process出现了比较多的lwlock等待。</span></div><div>1484是wal writer process，其他几个是数据库测试进程。</div><div>从count列可以看出，检查点发生后，数据库测试进程的等待次数变少了。</div><div>从avg来看，等待的平均时间发生了细微的变化，大概增加了1微秒的平均时间，这个等待并不足以造成性能下降。</div><div>因为正常的一次请求需要用掉<span style="line-height: 28px;"   >230786.9微秒。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pid: 1484, min: 0, max: 3, avg: 1, sum: 25, count: 19</font></div><div><font size="2"   >pid: 4249, min: 0, max: 2, avg: 0, sum: 161, count: 214</font></div><div><font size="2"   >pid: 4251, min: 0, max: 3, avg: 0, sum: 181, count: 227</font></div><div><font size="2"   >pid: 4250, min: 0, max: 2, avg: 0, sum: 181, count: 232</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 4249, min: 0, max: 3, avg: 0, sum: 134, count: 150</font></div><div><font size="2"   >pid: 4250, min: 0, max: 5, avg: 1, sum: 167, count: 157</font></div><div><font size="2"   >pid: 4251, min: 0, max: 3, avg: 0, sum: 145, count: 168</font></div><div><font size="2"   >pid: 1484, min: 0, max: 3, avg: 0, sum: 142, count: 255</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 4250, min: 0, max: 6, avg: 2, sum: 187, count: 75</font></div><div><font size="2"   >pid: 4251, min: 0, max: 3, avg: 1, sum: 88, count: 83</font></div><div><font size="2"   >pid: 4249, min: 0, max: 3, avg: 0, sum: 102, count: 107</font></div><div><font size="2"   >pid: 1484, min: 0, max: 6, avg: 0, sum: 302, count: 467</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 4250, min: 0, max: 6, avg: 2, sum: 198, count: 84</font></div><div><font size="2"   >pid: 4251, min: 0, max: 4, avg: 1, sum: 124, count: 102</font></div><div><font size="2"   >pid: 4249, min: 0, max: 2, avg: 0, sum: 98, count: 108</font></div><div><font size="2"   >pid: 1484, min: 0, max: 4, avg: 0, sum: 380, count: 633</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 4250, min: 0, max: 6, avg: 2, sum: 197, count: 77</font></div><div><font size="2"   >pid: 4251, min: 0, max: 4, avg: 1, sum: 106, count: 102</font></div><div><font size="2"   >pid: 4249, min: 0, max: 2, avg: 0, sum: 101, count: 111</font></div><div><font size="2"   >pid: 1484, min: 0, max: 4, avg: 0, sum: 396, count: 719</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 4249, min: 0, max: 4, avg: 1, sum: 88, count: 85</font></div><div><font size="2"   >pid: 4251, min: 0, max: 6, avg: 1, sum: 102, count: 91</font></div><div><font size="2"   >pid: 4250, min: 0, max: 6, avg: 2, sum: 221, count: 108</font></div><div><font size="2"   >pid: 1484, min: 0, max: 4, avg: 0, sum: 360, count: 705</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 4250, min: 0, max: 7, avg: 2, sum: 211, count: 93</font></div><div><font size="2"   >pid: 4249, min: 0, max: 13, avg: 1, sum: 152, count: 124</font></div><div><font size="2"   >pid: 4251, min: 0, max: 4, avg: 1, sum: 132, count: 130</font></div><div><font size="2"   >pid: 1484, min: 0, max: 5, avg: 0, sum: 419, count: 730</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><p></p></pre></div><div><br></div><div>从另一个方面来观察，看看检查点发生时单次请求，PG所有函数的处理时间如何？</div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres &nbsp;3167 &nbsp;2767 93 13:59 ? &nbsp; &nbsp; &nbsp; &nbsp;00:00:47 postgres: digoal digoal [local] UPDATE</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >但是函数量太大，会死机没法跟踪，即使不死机，也不合理，因为正常1毫秒以内的请求，使用STAP跟踪后，额外开销比较大，会上升到100多毫秒。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># stap -v 11111 -x 3167 -e '</font></div><div><font size="2"   >global f_start[999999],f_stop[999999]</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe process("/opt/pgsql/bin/postgres").function("*@/opt/soft_bak/postgresql-9.4.1/src/*").call {&nbsp;</font></div><div><font size="2"   >&nbsp; f_start[execname(), pid(), tid(), cpu()] = gettimeofday_ns()</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe process("/opt/pgsql/bin/postgres").function("*@/opt/soft_bak/postgresql-9.4.1/src/*").return {&nbsp;</font></div><div><font size="2"   >&nbsp; t=gettimeofday_ns()</font></div><div><font size="2"   >&nbsp; a=execname()</font></div><div><font size="2"   >&nbsp; b=cpu()</font></div><div><font size="2"   >&nbsp; c=pid()</font></div><div><font size="2"   >&nbsp; d=pp()</font></div><div><font size="2"   >&nbsp; e=tid()</font></div><div><font size="2"   >&nbsp; if (f_start[a,c,e,b]) {</font></div><div><font size="2"   >&nbsp; &nbsp; f_stop[a,d] &lt;&lt;&lt; t - f_start[a,c,e,b]</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe timer.s(1) {</font></div><div><font size="2"   >&nbsp; foreach ([a,d] in f_stop @sum - limit 10 ) {&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; printf("avg_ns:%d, sum_ns:%d, cnt:%d, execname:%s, pp:%s\n", @avg(f_stop[a,d]), @sum(f_stop[a,d]), @count(f_stop[a,d]), a, d)</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >   delete f_start</font></div><div><font size="2"   >   delete f_stop</font></div><div><font size="2"   >}<span style="line-height: 28px;"   >'</span></font></div><p></p></pre></div><div><span style="line-height: 28px;"   >例如：</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >开启stap前</font></div><div><div><font size="2"   >digoal=&gt; update tbl set info=now() where id=1;</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   >Time: 1.129 ms</font></div><div><font size="2"   >开启stap后</font></div><div><font size="2"   >digoal=&gt; update tbl set info=now() where id=1;</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   >Time: 167.001 ms</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >可以缩小</span><span style="line-height: 28px;"   >function("*@/opt/soft_bak/postgresql-9.4.1/src/*")的范围，再跟踪。</span></div><div><span style="line-height: 28px;"   >例如我们首先怀疑是锁的问题，那么可以缩小范围到</span><span style="line-height: 28px;"   >function("*@/opt/soft_bak/postgresql-9.4.1/src/</span><span style="line-height: 28px;"   >backend/storage/lmgr/</span><span style="line-height: 28px;"   >*")</span></div><div><pre class="prettyprint"   ><div><font size="2"   ># stap -v 11111 -x 3167 -e '</font></div><div><font size="2"   >global f_start[999999],f_stop[999999]</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe process("/opt/pgsql/bin/postgres").function("*@/opt/soft_bak/postgresql-9.4.1/src/backend/storage/lmgr/*").call {&nbsp;</font></div><div><font size="2"   >&nbsp; f_start[execname(), pid(), tid(), cpu()] = gettimeofday_ns()</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe process("/opt/pgsql/bin/postgres").function("*@/opt/soft_bak/postgresql-9.4.1/src/backend/storage/lmgr/*").return {&nbsp;</font></div><div><font size="2"   >&nbsp; t=gettimeofday_ns()</font></div><div><font size="2"   >&nbsp; a=execname()</font></div><div><font size="2"   >&nbsp; b=cpu()</font></div><div><font size="2"   >&nbsp; c=pid()</font></div><div><font size="2"   >&nbsp; d=pp()</font></div><div><font size="2"   >&nbsp; e=tid()</font></div><div><font size="2"   >&nbsp; if (f_start[a,c,e,b]) {</font></div><div><font size="2"   >&nbsp; &nbsp; f_stop[a,d] &lt;&lt;&lt; t - f_start[a,c,e,b]</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe timer.s(1) {</font></div><div><font size="2"   >&nbsp; foreach ([a,d] in f_stop @sum - limit 10 ) {&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; printf("avg_ns:%d, sum_ns:%d, cnt:%d, execname:%s, pp:%s\n", @avg(f_stop[a,d]), @sum(f_stop[a,d]), @count(f_stop[a,d]), a, d)</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >   printf("-------------------------end--------------------------\n")</font></div><div><font size="2"   >   delete f_start</font></div><div><font size="2"   >   delete f_stop</font></div><div><font size="2"   >}'</font></div><p></p></pre></div><div><div>结果截取：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 21px;"   >-------------------------end--------------------------<br>avg_ns:3108, sum_ns:80113700, cnt:25772, execname:postgres, pp:process("/opt/pgsql9.4.1/bin/postgres").function("LWLockRelease@/opt/soft_bak/postgresql-9.4.1/src/backend/storage/lmgr/lwlock.c:1118").return<br>avg_ns:3237, sum_ns:74622113, cnt:23051, execname:postgres, pp:process("/opt/pgsql9.4.1/bin/postgres").function("LWLockAcquire@/opt/soft_bak/postgresql-9.4.1/src/backend/storage/lmgr/lwlock.c:465").return<br>avg_ns:10610, sum_ns:37179631, cnt:3504, execname:postgres, pp:process("/opt/pgsql9.4.1/bin/postgres").function("LockRelationOid@/opt/soft_bak/postgresql-9.4.1/src/backend/storage/lmgr/lmgr.c:87").return<br>avg_ns:7832, sum_ns:34298340, cnt:4379, execname:postgres, pp:process("/opt/pgsql9.4.1/bin/postgres").function("LockAcquire@/opt/soft_bak/postgresql-9.4.1/src/backend/storage/lmgr/lock.c:672").return<br>-------------------------end--------------------------  发生检查点后,请求量变少了.<br>avg_ns:3122, sum_ns:70382918, cnt:22539, execname:postgres, pp:process("/opt/pgsql9.4.1/bin/postgres").function("LWLockRelease@/opt/soft_bak/postgresql-9.4.1/src/backend/storage/lmgr/lwlock.c:1118").return<br>avg_ns:3302, sum_ns:66548991, cnt:20152, execname:postgres, pp:process("/opt/pgsql9.4.1/bin/postgres").function("LWLockAcquire@/opt/soft_bak/postgresql-9.4.1/src/backend/storage/lmgr/lwlock.c:465").return<br>avg_ns:10591, sum_ns:32493427, cnt:3068, execname:postgres, pp:process("/opt/pgsql9.4.1/bin/postgres").function("LockRelationOid@/opt/soft_bak/postgresql-9.4.1/src/backend/storage/lmgr/lmgr.c:87").return<br>avg_ns:7832, sum_ns:30037745, cnt:3835, execname:postgres, pp:process("/opt/pgsql9.4.1/bin/postgres").function("LockAcquire@/opt/soft_bak/postgresql-9.4.1/src/backend/storage/lmgr/lock.c:672").return<br>-------------------------end--------------------------</span></font></div><p></p></pre></div></div><div>每秒需要获得和释放几百万次的LWLock。排名前4的耗时较大。</div><div>当发生检查点时，请求量变少了，和前一篇跟踪LWLock等待的结果是一样的，请求量变少。</div><div>看样子也不是这个原因导致的性能下降。</div><div>原因还是回到代码，从第四篇的跟踪来看，性能下降出现在FLUSH BUFFER的循环中，也就是从这里开始：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_SYNC_START(NBuffers, num_to_write);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Loop over all buffers again, and write the ones (still) marked with</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* BM_CHECKPOINT_NEEDED. &nbsp;In this loop, we start at the clock sweep point</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* since we might as well dump soon-to-be-recycled buffers first.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note that we don't read the buffer alloc count here --- that should be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* left untouched till the next BgBufferSync() call.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; buf_id = StrategySyncStart(NULL, NULL);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; num_to_scan = NBuffers;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; num_written = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; while (num_to_scan-- &gt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div></div><div><font size="2"   >......</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 28px;"   >StrategySyncStart是指根据LRU算法，让checkpointer从</span><span style="color: rgb(136, 0, 0); font-family: monospace; font-size: small; line-height: 21px; white-space: pre-wrap;"   >nextVictimBuffer</span><span style="line-height: 28px;"   >开始sync。</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* StrategySyncStart -- tell BufferSync where to start syncing</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The result is the buffer index of the best buffer to sync first.</font></div><div><font size="2"   >&nbsp;* BufferSync() will proceed circularly around the buffer array from there.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* In addition, we return the completed-pass count (which is effectively</font></div><div><font size="2"   >&nbsp;* the higher-order bits of nextVictimBuffer) and the count of recent buffer</font></div><div><font size="2"   >&nbsp;* allocs if non-NULL pointers are passed. &nbsp;The alloc count is reset after</font></div><div><font size="2"   >&nbsp;* being read.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >int</font></div><div><font size="2"   >StrategySyncStart(uint32 *complete_passes, uint32 *num_buf_alloc)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockAcquire(BufFreelistLock, LW_EXCLUSIVE);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; result = StrategyControl-&gt;nextVictimBuffer;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (complete_passes)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *complete_passes = StrategyControl-&gt;completePasses;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (num_buf_alloc)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *num_buf_alloc = StrategyControl-&gt;numBufferAllocs;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyControl-&gt;numBufferAllocs = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(BufFreelistLock);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return result;</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div style="line-height: 28px;"   ><br></div></div><div style="line-height: 28px;"   >但是对于我们的测试用例来说，实际上几乎所有的dirty buffer都是热的。从哪里开始都一样。</div><div style="line-height: 28px;"   >所以，性能下降与这个并无关联：</div><div style="line-height: 28px;"   >1. sync buffer时，可能有短暂的锁冲突，但是，从我们前面LWLock和再前面的跟踪结果来看<span style="line-height: 28px;"   >影响极小，几乎可以忽略</span><span style="line-height: 28px;"   >。</span></div><div style="line-height: 28px;"   >2. 检查点会将脏块同步到磁盘，然后脏块会变成非脏块，但是它依旧还在shared buffer中，所以紧接着的操作也不需要物理读（md read）。</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><div style="line-height: 28px;"   ><font size="2"   >$ pgbench -M prepared -n -r -f ./test.sql -P 1 -c 26 -j 26 -T 10000000</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 1.0 s, 13550.0 tps, lat 1.891 ms stddev 3.474</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 2.0 s, 15505.7 tps, lat 1.655 ms stddev 3.549</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 3.0 s, 18030.0 tps, lat 1.443 ms stddev 3.210</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 4.0 s, 20844.0 tps, lat 1.258 ms stddev 2.867</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 5.0 s, 25317.6 tps, lat 1.025 ms stddev 2.127</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 6.0 s, 31146.7 tps, lat 0.833 ms stddev 1.702</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 7.0 s, 40137.8 tps, lat 0.646 ms stddev 0.975</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 8.0 s, 51564.9 tps, lat 0.502 ms stddev 0.368</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 9.0 s, 53915.6 tps, lat 0.480 ms stddev 0.311</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 10.0 s, 56830.9 tps, lat 0.456 ms stddev 0.281</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 11.0 s, 57333.8 tps, lat 0.452 ms stddev 0.283</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 12.0 s, 58938.8 tps, lat 0.439 ms stddev 0.270</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 13.0 s, 59608.3 tps, lat 0.434 ms stddev 0.265</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 14.0 s, 59014.8 tps, lat 0.439 ms stddev 0.281</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 15.0 s, 60241.9 tps, lat 0.430 ms stddev 0.259</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 16.0 s, 61337.1 tps, lat 0.422 ms stddev 0.248</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 17.0 s, 60821.9 tps, lat 0.426 ms stddev 0.259</font></div><div style="line-height: 28px;"   ><font size="2"   >progress: 18.0 s, 60850.2 tps, lat 0.425 ms stddev 0.265</font></div><p></p></pre></div></div><div><span style="line-height: 28px;"   >我们可以来跟踪一下物理读和物理写，你就可以看到，检查点发生后，其实并没有物理读。</span></div><div><table border="1"   style="margin: 2ex 0px 2ex 2ex; -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border-spacing: 0px; border-collapse: collapse; border: 2px solid rgb(167, 198, 223); color: rgb(0, 0, 0); font-family: verdana, sans-serif; font-size: 12.1599998474121px; line-height: normal; background-color: rgb(224, 236, 239);"   ><tbody><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >smgr-md-read-start</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Probe that fires when beginning to read a block from a relation. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or InvalidBackendId (-1) for a shared buffer.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >smgr-md-read-done</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Probe that fires when a block read is complete. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or InvalidBackendId (-1) for a shared buffer. arg6 is the number of bytes actually read, while arg7 is the number requested (if these are different it indicates trouble).</td></tr></table></div><div><div><span style="line-height: 28px;"   >src</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* ReadBuffer_common -- common logic for all ReadBuffer variants</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* *hit is set to true if the request was satisfied from shared buffer cache.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static Buffer</font></div><div><font size="2"   >ReadBuffer_common(SMgrRelation smgr, char relpersistence, ForkNumber forkNum,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blockNum, ReadBufferMode mode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferAccessStrategy strategy, bool *hit)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >......</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe buffer__read__start(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; probe buffer__read__done(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool);</font></div><p></p></pre></div><div>跟踪读写：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># stap -DMAXSKIPPED=100000 -v 11111 -e '</font></div><div><font size="2"   >global s_var, e_var, stat_var;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* probe smgr__md__read__start(ForkNumber, BlockNumber, Oid, Oid, Oid, int); */</font></div><div><font size="2"   >probe process("/opt/pgsql/bin/postgres").mark("smgr__md__read__start") {</font></div><div><font size="2"   >&nbsp; s_var[pid(),1] = gettimeofday_us()</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* probe smgr__md__read__done(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int); */</font></div><div><font size="2"   >probe process("/opt/pgsql/bin/postgres").mark("smgr__md__read__done") {</font></div><div><font size="2"   >&nbsp; e_var[pid(),1] = gettimeofday_us()</font></div><div><font size="2"   >&nbsp; if ( s_var[pid(),1] &gt; 0 )</font></div><div><font size="2"   >&nbsp; &nbsp; stat_var[pid(),1] &lt;&lt;&lt; e_var[pid(),1] - s_var[pid(),1]</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* probe buffer__write__start(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool); */</font></div><div><font size="2"   >probe process("/opt/pgsql/bin/postgres").mark("buffer__write__start") {</font></div><div><font size="2"   >&nbsp; s_var[pid(),2] = gettimeofday_us()</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* probe buffer__write__done(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool); */</font></div><div><font size="2"   >probe process("/opt/pgsql/bin/postgres").mark("buffer__write__done") {</font></div><div><font size="2"   >&nbsp; e_var[pid(),2] = gettimeofday_us()</font></div><div><font size="2"   >&nbsp; if ( s_var[pid(),2] &gt; 0 )</font></div><div><font size="2"   >&nbsp; &nbsp; stat_var[pid(),2] &lt;&lt;&lt; e_var[pid(),2] - s_var[pid(),2]</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe timer.s(1) {</font></div><div><font size="2"   >&nbsp; foreach ([v1,v2] in stat_var +) {</font></div><div><font size="2"   >&nbsp; &nbsp; if ( @count(stat_var[v1,v2]) &gt;0 ) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; printf("pid: %d, what: %d, min: %d, max: %d, avg: %d, sum: %d, count: %d\n", v1, v2, @min(stat_var[v1,v2]), @max(stat_var[v1,v2]), @avg(stat_var[v1,v2]), @sum(stat_var[v1,v2]), @count(stat_var[v1,v2]))</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; printf("----------------------------------end-----------------------------\n")</font></div><div><font size="2"   >&nbsp; delete s_var</font></div><div><font size="2"   >&nbsp; delete e_var</font></div><div><font size="2"   >&nbsp; delete stat_var</font></div><div><font size="2"   >}'</font></div><p></p></pre></div></div><div><div>开启压力测试：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >$ pgbench -M prepared -n -r -f ./test.sql -P 1 -c 26 -j 26 -T 10000000</font></div><div><font size="2"   >......</font></div><div><font size="2"   >progress: 56.0 s, 60813.0 tps, lat 0.426 ms stddev 0.271</font></div><div><font size="2"   >progress: 57.0 s, 59748.9 tps, lat 0.433 ms stddev 0.390</font></div><div><font size="2"   >progress: 58.0 s, 61135.6 tps, lat 0.423 ms stddev 0.398</font></div><div><font size="2"   >progress: 59.0 s, 64174.6 tps, lat 0.403 ms stddev 0.333</font></div><div><font size="2"   >progress: 60.0 s, 59503.6 tps, lat 0.435 ms stddev 0.282</font></div><div><font size="2"   >progress: 61.0 s, 60662.4 tps, lat 0.427 ms stddev 0.271</font></div><div><font size="2"   >progress: 62.0 s, 60582.2 tps, lat 0.427 ms stddev 0.274</font></div><div><font size="2"   >progress: 63.0 s, 61523.6 tps, lat 0.421 ms stddev 0.258</font></div><div><font size="2"   >progress: 64.0 s, 62394.7 tps, lat 0.415 ms stddev 0.251</font></div><div><font size="2"   >progress: 65.0 s, 60892.6 tps, lat 0.425 ms stddev 0.277</font></div><div><font size="2"   >progress: 66.0 s, 60703.2 tps, lat 0.426 ms stddev 0.280</font></div><div><font size="2"   >progress: 67.0 s, 61629.9 tps, lat 0.420 ms stddev 0.261</font></div><div><font size="2"   >progress: 68.0 s, 61231.5 tps, lat 0.423 ms stddev 0.270</font></div><p></p></pre></div></div><div><div><span style="line-height: 28px;"   >当tps进入顶峰，现在所有的热块都在内存中，可以看到现在没有物理读了。</span></div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >执行检查点：</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >progress: 20.0 s, 60582.5 tps, lat 0.427 ms stddev 0.265</font></div><div><font size="2"   >progress: 21.0 s, 40974.3 tps, lat 0.624 ms stddev 1.782</font></div><div><font size="2"   >progress: 22.0 s, 14963.3 tps, lat 1.754 ms stddev 4.243</font></div><div><font size="2"   >progress: 23.0 s, 16382.7 tps, lat 1.577 ms stddev 4.138</font></div><div><font size="2"   >progress: 24.0 s, 20179.2 tps, lat 1.286 ms stddev 2.839</font></div><div><font size="2"   >progress: 25.0 s, 23749.2 tps, lat 1.101 ms stddev 2.816</font></div><div><font size="2"   >progress: 26.0 s, 27464.7 tps, lat 0.945 ms stddev 2.581</font></div><div><font size="2"   >progress: 27.0 s, 33850.6 tps, lat 0.764 ms stddev 2.011</font></div><div><font size="2"   >progress: 28.0 s, 43315.9 tps, lat 0.600 ms stddev 1.134</font></div><div><font size="2"   >progress: 29.0 s, 50216.6 tps, lat 0.516 ms stddev 0.492</font></div><div><font size="2"   >progress: 30.0 s, 52857.0 tps, lat 0.490 ms stddev 0.323</font></div><div><font size="2"   >progress: 31.0 s, 53428.6 tps, lat 0.485 ms stddev 0.322</font></div><div><font size="2"   >progress: 32.0 s, 54710.5 tps, lat 0.473 ms stddev 0.303</font></div><div><font size="2"   >progress: 33.0 s, 57824.2 tps, lat 0.448 ms stddev 0.289</font></div><div><font size="2"   >progress: 34.0 s, 59573.5 tps, lat 0.435 ms stddev 0.273</font></div><div><font size="2"   >progress: 35.0 s, 58162.8 tps, lat 0.445 ms stddev 0.413</font></div><div><font size="2"   >progress: 36.0 s, 57951.4 tps, lat 0.447 ms stddev 0.435</font></div><p></p></pre></div><div>跟踪结果，我们只看到checkpointer在write buffer，并没有看到pgbench的连接产生物理读(md read)：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 18027, what: 2, min: 42, max: 101, avg: 49, sum: 57592, count: 1154</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 18027, what: 2, min: 42, max: 124, avg: 51, sum: 520545, count: 10079</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 18027, what: 2, min: 44, max: 191, avg: 65, sum: 464196, count: 7139</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 18027, what: 2, min: 42, max: 145, avg: 53, sum: 467482, count: 8799</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 18027, what: 2, min: 42, max: 131, avg: 53, sum: 447230, count: 8366</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 18027, what: 2, min: 37, max: 175, avg: 57, sum: 429778, count: 7465</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 18027, what: 2, min: 42, max: 10551, avg: 65, sum: 331686, count: 5065</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 18027, what: 2, min: 41, max: 158, avg: 61, sum: 397299, count: 6429</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 18027, what: 2, min: 29, max: 1173, avg: 61, sum: 672717, count: 10976</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 18027, what: 2, min: 26, max: 11093, avg: 58, sum: 933458, count: 16027</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 18027, what: 2, min: 27, max: 448, avg: 56, sum: 937812, count: 16633</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 18027, what: 2, min: 27, max: 112, avg: 55, sum: 937420, count: 16996</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><div><font size="2"   >pid: 18027, what: 2, min: 27, max: 98, avg: 54, sum: 431355, count: 7901</font></div><div><font size="2"   >----------------------------------end-----------------------------</font></div><p></p></pre></div></div><div><br></div><div>到目前为止，只能说，LWLOCK，WRITE BUFFER都没有对性能造成影响，我们并没有找到执行checkpoint时，带来的性能下降的真正原因。</div><div>下一篇将揭晓答案。</div><div><br></div><div><span style="line-height: 28px;"   >[参考]</span></div><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020154653422892/"   >http://blog.163.com/digoal@126/blog/static/16387704020154653422892/</a></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL Why checkpointer impact performance so much ? - 5 - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>