<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL complex index's column position tuning case</h2>
	<h5 id="">2013-04-22 9:31:11&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201332283735674/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>本文主要讨论一下复合索引的列顺序问题.</div><div>-- # 测试表</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table t(c1 int, c2 int, c3 text);</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>-- 测试数据</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# insert into t select generate_series(1,10),generate_series(1,100000),md5(random()::text);</font></div><div><font size="2"   >INSERT 0 100000</font></div><p></p></pre></div><div>-- 列选择性, c2最好.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select count(distinct c1),count(distinct c2),count(*) from t;</font></div><div><font size="2"   >&nbsp;count | count &nbsp;| count &nbsp;</font></div><div><font size="2"   >-------+--------+--------</font></div><div><font size="2"   >&nbsp; &nbsp; 10 | 100000 | 100000</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>-- 创建索引, 将选择性不好的c1列放在前面.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create index idx_t_1 on t(c1,c2);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >digoal=# analyze t;</font></div><div><font size="2"   >ANALYZE</font></div><p></p></pre></div><div>-- 以c1=1为where条件, 扫描964个块.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select * from t where c1=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_t_1 on public.t &nbsp;(cost=0.00..1138.44 rows=10203 width=41) (actual time=0.033..4.752 rows=10000 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: c1, c2, c3</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (t.c1 = 1)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=964</font></div><div><font size="2"   >&nbsp;Total runtime: 5.699 ms</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >-- 以c2=1为where条件, 扫描276个块.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select * from t where c2=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_t_1 on public.t &nbsp;(cost=0.00..1027.26 rows=1 width=41) (actual time=0.028..4.092 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: c1, c2, c3</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (t.c2 = 1)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=276</font></div><div><font size="2"   >&nbsp;Total runtime: 4.124 ms</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >-- 以c1=1 and c2=1为where条件, 扫描3个块.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select * from t where c1=1 and c2=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_t_1 on public.t &nbsp;(cost=0.00..2.27 rows=1 width=41) (actual time=0.024..0.025 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: c1, c2, c3</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: ((t.c1 = 1) AND (t.c2 = 1))</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=3</font></div><div><font size="2"   >&nbsp;Total runtime: 0.057 ms</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >-- 以c2=1 and c1=1为where条件, 扫描3个块.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select * from t where c2=1 and c1=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_t_1 on public.t &nbsp;(cost=0.00..2.27 rows=1 width=41) (actual time=0.020..0.021 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: c1, c2, c3</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: ((t.c1 = 1) AND (t.c2 = 1))</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=3</font></div><div><font size="2"   >&nbsp;Total runtime: 0.049 ms</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div><br></div><div>-- 删除c1,c2索引, 创建c2,c1索引.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# drop index idx_t_1;</font></div><div><font size="2"   >DROP INDEX</font></div><div><font size="2"   >digoal=# create index idx_t_2 on t(c2,c1);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >digoal=# analyze t;</font></div><div><font size="2"   >ANALYZE</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >-- 以c1=1为where条件, 扫描1210个块.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select * from t where c1=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_t_2 on public.t &nbsp;(cost=0.00..1587.06 rows=9943 width=41) (actual time=0.026..8.918 rows=10000 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: c1, c2, c3</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (t.c1 = 1)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=1210</font></div><div><font size="2"   >&nbsp;Total runtime: 9.734 ms</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >-- 以c2=1为where条件, 扫描3个块.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select * from t where c2=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_t_2 on public.t &nbsp;(cost=0.00..2.27 rows=1 width=41) (actual time=0.019..0.020 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: c1, c2, c3</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (t.c2 = 1)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=3</font></div><div><font size="2"   >&nbsp;Total runtime: 0.048 ms</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >-- 以c1=1 and c2=1为where条件, 扫描3个块.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select * from t where c1=1 and c2=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_t_2 on public.t &nbsp;(cost=0.00..2.27 rows=1 width=41) (actual time=0.013..0.014 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: c1, c2, c3</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: ((t.c2 = 1) AND (t.c1 = 1))</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=3</font></div><div><font size="2"   >&nbsp;Total runtime: 0.038 ms</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >-- 以c2=1 and c1=1为where条件, 扫描3个块.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select * from t where c2=1 and c1=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_t_2 on public.t &nbsp;(cost=0.00..2.27 rows=1 width=41) (actual time=0.011..0.012 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: c1, c2, c3</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: ((t.c2 = 1) AND (t.c1 = 1))</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=3</font></div><div><font size="2"   >&nbsp;Total runtime: 0.033 ms</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div></div><div><br></div><div>[小结]</div><div>1. 对于使用c1 and c2为查询条件的查询, 两个索引的效率一样.</div><div>2. 对于仅使用c1为查询条件的情况, (c1,c2)索引效率高于(c2,c1), 但是由于c1选择性不好, 所以差别不大.</div><div>3.&nbsp;<span style="line-height: 22px;"   >对于仅使用c2为查询条件的情况, (c2,c1)索引效率高于(c1,c2), 但是由于c2选择性好, 所以差别非常大.</span></div><div>4. 结合以上结果, 对于复合索引的列顺序, 除了需要考虑驱动列放在第一位之外, 如果有多单列查询条件, 那么需要考虑到顺序是选择性好的放最前面.&nbsp;</div><div><br></div><wbr></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">francs - 2013-04-22 11:03:42</h5>
				<div>学习了：选择性好的放前面，这个准则和 Oracle 一致。</div>
			</div>
	</div>
</div>
</body>
</html>