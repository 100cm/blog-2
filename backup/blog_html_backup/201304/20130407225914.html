<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL non-consistent backup script</h2>
	<h5 id="">2013-04-07 22:59:14&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201337104355272/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">pg_dump 备份为一致性备份. 如下 :&nbsp;<div><pre class="prettyprint"   ><p><font size="2"   >src/bin/pg_dump/pg_dump.c<br><wbr></font></p><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Start transaction-snapshot mode transaction to dump consistent data.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ExecuteSqlStatement(fout, "BEGIN");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (fout-&gt;remoteVersion &gt;= 90100)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (serializable_deferrable)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecuteSqlStatement(fout,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "SET TRANSACTION ISOLATION LEVEL "</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "SERIALIZABLE, READ ONLY, DEFERRABLE");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecuteSqlStatement(fout,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "SET TRANSACTION ISOLATION LEVEL "</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "REPEATABLE READ");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecuteSqlStatement(fout,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "SET TRANSACTION ISOLATION LEVEL SERIALIZABLE");</font></div></div><p></p></pre><div># 并且pg_dump是在一个事务中完成的,&nbsp;</div></div><div># pg_dump备份时需要依次进行锁表的操作, 锁级别为IN ACCESS SHARE MODE. 这个锁与AccessExclusiveLock冲突.</div><div># 因此与操作TRUNCATE TABLE, ALTER TABLE, DROP TABLE, VACUUM FULL 以及unqualified LOCK TABLE冲突.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Read-lock target tables to make sure they aren't DROPPED or altered</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* in schema before we get around to dumping them.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note that we don't explicitly lock parents of the target tables; we</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* assume our lock on the child is enough to prevent schema</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* alterations to parent tables.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* NOTE: it'd be kinda nice to lock other relations too, not only</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* plain tables, but the backend doesn't presently allow that.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tblinfo[i].dobj.dump &amp;&amp; tblinfo[i].relkind == RELKIND_RELATION)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resetPQExpBuffer(query);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendPQExpBuffer(query,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "LOCK TABLE %s IN ACCESS SHARE MODE",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmtQualifiedId(fout,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tblinfo[i].dobj.namespace-&gt;dobj.name,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tblinfo[i].dobj.name));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecuteSqlStatement(fout, query-&gt;data);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div><div>当程序中使用到了这些SQL(如<span style="line-height: 22px;"   >TRUNCATE TABLE, ALTER TABLE, DROP TABLE, VACUUM FULL 以及unqualified LOCK TABLE</span><span style="line-height: 22px;"   >)时, 如果数据库非常庞大并且在做pg_dump备份时, SQL将会处于等待状态.</span></div><div>等待直到pg_dump结束(锁的释放需要等待顶级事务块结束).</div><div>例如 :&nbsp;</div><div>1. 系统中有1000个表, 备份第一个表a时会对第一个表a加access share锁. 此时如果其他程序要truncate table a; 需要等待1000个表完全备份完毕才可以进行下去.</div><div>2. 当程序先持有a的<span style="line-height: 22px;"   >AccessExclusiveLock, 那么pg_dump也需要等待程序释放</span><span style="line-height: 22px;"   >AccessExclusiveLock. 同时pg_dump有锁获取超时机制.</span></div><div><span style="line-height: 22px;"   ><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (lockWaitTimeout &amp;&amp; fout-&gt;remoteVersion &gt;= 70300)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Arrange to fail instead of waiting forever for a table lock.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* NB: this coding assumes that the only queries issued within the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* following loop are LOCK TABLEs; else the timeout may be undesirably</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* applied to other things too.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resetPQExpBuffer(query);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendPQExpBuffer(query, "SET statement_timeout = ");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringLiteralConn(query, lockWaitTimeout, GetConnection(fout));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecuteSqlStatement(fout, query-&gt;data);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div><div><br></div></span></div><div>因此庞大的数据库做pg_dump需要考虑到以上问题.</div><div>例如在不需要全库一致性备份的前提下, 缩小一致性备份的范围, 这样可以减少单次pg_dump的时间, 从而减少程序等待锁的时间.</div><div>如下脚本 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >#!/bin/bash</font></div><div><font size="2"   ># 环境变量</font></div><div><font size="2"   >PATH=$PATH:$HOME/bin</font></div><div><font size="2"   >export PATH</font></div><div><font size="2"   >export LANG=en_US.utf8</font></div><div><font size="2"   >export PGHOME=/opt/pgsql</font></div><div><font size="2"   >export LD_LIBRARY_PATH=$PGHOME/lib:/lib64:/usr/lib64:/usr/local/lib64:/lib:/usr/lib:/usr/local/lib</font></div><div><font size="2"   >export DATE=`date +"%Y%m%d%H%M"`</font></div><div><font size="2"   >export PATH=$PGHOME/bin:$PATH:.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ># 程序变量</font></div><div><font size="2"   >TODAY=`date +%Y%m%d`</font></div><div><font size="2"   >EMAIL="digoal@126.com"</font></div><div><font size="2"   >BAKBASEDIR="/database/pgbak"</font></div><div><font size="2"   >RESERVE_DAY=4</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >HOST="10.10.10.10"</font></div><div><font size="2"   >PORT="1921"</font></div><div><font size="2"   >ROLE="postgres"</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ># 不一致备份, 按单表进行.</font></div><div><font size="2"   >for DB in `psql -A -q -t -h $HOST -p $PORT -U $ROLE postgres -c "select datname from pg_database where datname not in ('postgres','template0','template1')"`</font></div><div><font size="2"   >do</font></div><div><font size="2"   >echo -e "------`date +%F\ %T`----Start Backup----IP:$HOST PORT:$PORT DBNAME:$DB TYPE:$BAKTYPE TO:$BAKBASEDIR------"</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >for TABLE in `psql -A -q -t -h $HOST -p $PORT -U $ROLE $DB -c "select schemaname||'.'||tablename from pg_tables where schemaname !~ '^pg_' and schemaname &lt;&gt;'information_schema'"`</font></div><div><font size="2"   >do</font></div><div><font size="2"   >pg_dump -f ${BAKBASEDIR}/${DB}-${TABLE}-${TODAY}.dmp.ing -F c -t $TABLE --lock-wait-timeout=6000 -E UTF8 -h ${HOST} -p ${PORT} -U ${ROLE} -w ${DB}</font></div><div><font size="2"   >if [ $? -ne 0 ]; then</font></div><div><font size="2"   >echo -e "backup $HOST $PORT $DB $BAKBASEDIR error \n `date +%F%T` \n"|mutt -s "ERROR : PostgreSQL_backup " ${EMAIL}</font></div><div><font size="2"   >echo -e "------`date +%F\ %T`----Error Backup----IP:$HOST PORT:$PORT DBNAME:$DB TABLE:$TABLE TO:$BAKBASEDIR------"</font></div><div><font size="2"   >rm -f ${BAKBASEDIR}/${DB}-${TABLE}-${TODAY}.dmp.ing</font></div><div><font size="2"   >break</font></div><div><font size="2"   >fi</font></div><div><font size="2"   >mv ${BAKBASEDIR}/${DB}-${TABLE}-${TODAY}.dmp.ing ${BAKBASEDIR}/${DB}-${TABLE}-${TODAY}.dmp</font></div><div><font size="2"   >echo -e "------`date +%F\ %T`----Success Backup----IP:$HOST PORT:$PORT DBNAME:$DB TABLE:$TABLE TO:$BAKBASEDIR------"</font></div><div><font size="2"   >done</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >done</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >echo -e "find ${BAKBASEDIR}/${DB}_${TABLE}_${TODAY}.dmp* -daystart -mtime +${RESERVE_DAY} -delete"</font></div><div><font size="2"   >find ${BAKBASEDIR}/${DB}_${TABLE}_${TODAY}.dmp* -daystart -mtime +${RESERVE_DAY} -delete</font></div><p></p></pre></div><div># 这只是个简单的例子, 实际使用时需要考虑业务逻辑, 确保业务数据一致性. 例如某一些有关联的表确保放在同一个pg_dump中导出.</div></div><div>多个-t talbename参数即可.</div><div># 同时需要注意单表不要太大, 否则该单表的DDL操作也会加大和pg_dump发生冲突的概率.</div><div># 对于较大的数据库还是建议使用PITR物理增量备份方式.</div><div><br></div><div>【参考<span style="line-height: 22px;"   >】</span></div><div><span style="line-height: 22px;"   >1. src/bin/pg_dump/pg_dump.c</span></div></div>
	</div>
</div>
</body>
</html>