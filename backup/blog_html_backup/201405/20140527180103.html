<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">be careful use prepared statement with pgbouncer and other connection pools</h2>
	<h5 id="">2014-05-27 18:01:03&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201442755046734/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">鉴于PostgreSQL是进程模式的, 所以如果应用场景是短连接的话, 需要架设一个连接池来解决连接瓶颈的问题.<wbr><div>譬如pgbouncer,</div><div>对付短连接, 还需使用transaction或 statment模式.</div><div>但是, 如果你的场景中还有用到prepared statement的话, 使用连接池容易出现问题.</div><div>不管是pgbouncer还是其他连接池, 都是需要面对的.</div><div>问题</div><div>程序a创建了一个prepared statement,</div><div>调用</div><div>事务关闭</div><div>其他程序可能复用这个连接</div><div>其他程序可能创建一个同名的prepared statement, 这个时候就发生了冲突.</div><div>另外程序A可能连接到其他的server pool, 所以可能刚才创建的prepared statement在其他server pool中不存在,&nbsp;</div><div>所以程序A调用这个prepared statement的时候, 也会报错.</div><div>同时, libpq只提供了创建prepared statement的接口, 但是没有提供删除接口, 目前PostgreSQL的prepared statement只能通过</div><div>deallocate来消除.</div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/libpq-exec.html"   >http://www.postgresql.org/docs/9.4/static/libpq-exec.html</a></div><div><pre class="prettyprint"   ><p><font size="2"   >Prepared statements for use with PQexecPrepared can also be created by executing SQL PREPARE statements. Also, although there is no libpq function for deleting a prepared statement, the SQL DEALLOCATE statement can be used for that purpose.</font></p></pre></div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/sql-deallocate.html"   >http://www.postgresql.org/docs/9.4/static/sql-deallocate.html</a></div><div>所以要使用连接池的话, 同时还要使用绑定变量, 可以考虑使用会话级别的连接池, 同时在连接回收时在pgbouncer中设置discard all;</div><div>这个语句可以释放掉会话端存储的prepared statement.</div><div>它相当于执行了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SET SESSION AUTHORIZATION DEFAULT;</font></div><div><font size="2"   >RESET ALL;</font></div><div><font size="2"   >DEALLOCATE ALL;</font></div><div><font size="2"   >CLOSE ALL;</font></div><div><font size="2"   >UNLISTEN *;</font></div><div><font size="2"   >SELECT pg_advisory_unlock_all();</font></div><div><font size="2"   >DISCARD PLANS;</font></div><div><font size="2"   >DISCARD TEMP;</font></div><div><font size="2"   >DISCARD SEQUENCES;</font></div><p></p></pre></div><div>如果使用的是事务或语句级别的连接池, 连接复用就可能出现本文前面提到的问题.</div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/sql-deallocate.html"   >http://www.postgresql.org/docs/9.4/static/sql-deallocate.html</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/libpq-exec.html"   >http://www.postgresql.org/docs/9.4/static/libpq-exec.html</a></div><div>3.&nbsp;src/backend/commands/prepare.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Internal version of DEALLOCATE</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* If showError is false, dropping a nonexistent statement is a no-op.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >DropPreparedStatement(const char *stmt_name, bool showError)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PreparedStatement *entry;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Find the query's hash table entry; raise error if wanted */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; entry = FetchPreparedStatement(stmt_name, showError);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (entry)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Release the plancache entry */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DropCachedPlan(entry-&gt;plansource);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Now we can remove the hash table entry */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_search(prepared_queries, entry-&gt;stmt_name, HASH_REMOVE, NULL);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Drop all cached statements.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >DropAllPreparedStatements(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; HASH_SEQ_STATUS seq;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PreparedStatement *entry;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* nothing cached */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!prepared_queries)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* walk over cache */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; hash_seq_init(&amp;seq, prepared_queries);</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; while ((entry = hash_seq_search(&amp;seq)) != NULL)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Release the plancache entry */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DropCachedPlan(entry-&gt;plansource);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Now we can remove the hash table entry */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_search(prepared_queries, entry-&gt;stmt_name, HASH_REMOVE, NULL);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="be careful use prepared statement with pgbouncer and other connection pools - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>