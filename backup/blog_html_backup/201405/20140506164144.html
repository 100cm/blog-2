<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.4 New Feature - Auto-resize the catalog cache</h2>
	<h5 id="">2014-05-06 16:41:44&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020144643130318/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 9.4 对catalog元数据的缓存改进, 动态加载使得catalog不需要一次性加载至内存哈希表, 一方面减少了内存需求, 一方面也提高了访问效率. 对于catalog比较大但是活跃数据较少的数据库应用场景尤为有用.</div><div>例如堆积了很多历史表的数据库, 或者数据仓库. 存在大量函数的数据库. 等.</div><div><br></div><div><pre class="prettyprint"   ><div><font size="2"   >Make catalog cache hash tables resizeable.</font></div><div><font size="2"   >author<span>	</span>Heikki Linnakangas &lt;heikki.linnakangas@iki.fi&gt;<span>	</span></font></div><div><font size="2"   >Thu, 5 Sep 2013 16:47:56 +0000 (19:47 +0300)</font></div><div><font size="2"   >committer<span>	</span>Heikki Linnakangas &lt;heikki.linnakangas@iki.fi&gt;<span>	</span></font></div><div><font size="2"   >Thu, 5 Sep 2013 17:20:03 +0000 (20:20 +0300)</font></div><div><font size="2"   >commit<span>	</span>20cb18db4668b016748fbb5fcb1422bc3e0d52d1</font></div><div><font size="2"   >tree<span>	</span>82ee53ee378c3fc6fde586f7e3a628421eae7bf6<span>	</span>tree | snapshot</font></div><div><font size="2"   >parent<span>	</span>b1892aaeaaf34d8d1637221fc1cbda82ac3fcd71<span>	</span>commit | diff</font></div><div><font size="2"   >Make catalog cache hash tables resizeable.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >If the hash table backing a catalog cache becomes too full (fillfactor &gt; 2),</font></div><div><font size="2"   >enlarge it. A new buckets array, double the size of the old, is allocated,</font></div><div><font size="2"   >and all entries in the old hash are moved to the right bucket in the new</font></div><div><font size="2"   >hash.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >This has two benefits. First, cache lookups don't get so expensive when</font></div><div><font size="2"   >there are lots of entries in a cache, like if you access hundreds of</font></div><div><font size="2"   >thousands of tables. Second, we can make the (initial) sizes of the caches</font></div><div><font size="2"   >much smaller, which saves memory.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >This patch dials down the initial sizes of the catcaches. The new sizes are</font></div><div><font size="2"   >chosen so that a backend that only runs a few basic queries still won't need</font></div><div><font size="2"   >to enlarge any of them.</font></div><p></p></pre></div><div>当catalog哈希表快满时, 使用RehashCatCache进行扩展, 详见末尾.</div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=20cb18db4668b016748fbb5fcb1422bc3e0d52d1"   >http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=20cb18db4668b016748fbb5fcb1422bc3e0d52d1</a></div><div>2.&nbsp;src/backend/utils/cache/catcache.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >+ * Enlarge a catcache, doubling the number of buckets.</font></div><div><font size="2"   >+ */</font></div><div><font size="2"   >+static void</font></div><div><font size="2"   >+RehashCatCache(CatCache *cp)</font></div><div><font size="2"   >+{</font></div><div><font size="2"   >+ &nbsp; dlist_head *newbucket;</font></div><div><font size="2"   >+ &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; newnbuckets;</font></div><div><font size="2"   >+ &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; i;</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; elog(DEBUG1, "rehashing catalog cache id %d for %s; %d tups, %d buckets",</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;cp-&gt;id, cp-&gt;cc_relname, cp-&gt;cc_ntup, cp-&gt;cc_nbuckets);</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; /* Allocate a new, larger, hash table. */</font></div><div><font size="2"   >+ &nbsp; newnbuckets = cp-&gt;cc_nbuckets * 2;</font></div><div><font size="2"   >+ &nbsp; newbucket = (dlist_head *) MemoryContextAllocZero(CacheMemoryContext, newnbuckets * sizeof(dlist_head));</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; /* Move all entries from old hash table to new. */</font></div><div><font size="2"   >+ &nbsp; for (i = 0; i &lt; cp-&gt;cc_nbuckets; i++)</font></div><div><font size="2"   >+ &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; dlist_mutable_iter iter;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; dlist_foreach_modify(iter, &amp;cp-&gt;cc_bucket[i])</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CatCTup &nbsp; &nbsp;*ct = dlist_container(CatCTup, cache_elem, iter.cur);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; hashIndex = HASH_INDEX(ct-&gt;hash_value, newnbuckets);</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(iter.cur);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_head(&amp;newbucket[hashIndex], &amp;ct-&gt;cache_elem);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >+ &nbsp; }</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; /* Switch to the new array. */</font></div><div><font size="2"   >+ &nbsp; pfree(cp-&gt;cc_bucket);</font></div><div><font size="2"   >+ &nbsp; cp-&gt;cc_nbuckets = newnbuckets;</font></div><div><font size="2"   >+ &nbsp; cp-&gt;cc_bucket = newbucket;</font></div><div><font size="2"   >+}</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >...</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >+ &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp;* If the hash table has become too full, enlarge the buckets array.</font></div><div><font size="2"   >+ &nbsp; &nbsp;* Quite arbitrarily, we enlarge when fill factor &gt; 2.</font></div><div><font size="2"   >+ &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; if (cache-&gt;cc_ntup &gt; cache-&gt;cc_nbuckets * 2)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; RehashCatCache(cache);</font></div><div><font size="2"   >+</font></div></div><p></p></pre></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL 9.4 New Feature - Auto-resize the catalog cache - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>