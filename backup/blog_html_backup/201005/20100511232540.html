<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Oracle Index Skip Scans使用场景</h2>
	<h5 id="">2010-05-11 23:25:40&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201041111254019/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><P style="TEXT-INDENT: 2em;"  >INDEX跳跃扫描一般用在WHERE条件里面没有使用到引导列，但是用到了引导列以外的其他列，并且引导列的DISTINCT值较少的情况。</P>  <P style="TEXT-INDENT: 2em;"  >在这种情况下，数据库把这个复合索引逻辑上拆散为多个子索引，依次搜索子索引中非引导列的WHERE条件里面的值。</P>  <P style="TEXT-INDENT: 2em;"  >使用方法如下:</P>  <P style="TEXT-INDENT: 2em;"  >/*+ INDEX_SS ( [ @ qb_name ] tablespec [ indexspec [ indexspec ]... ] ) */</P>  <P style="TEXT-INDENT: 2em;"  >The&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >INDEX_SS</P>  <P style="TEXT-INDENT: 2em;"  >hint instructs the optimizer to perform an index skip scan for the specified table. If the statement uses an index range scan, then Oracle scans the index entries in ascending order of their indexed values. In a partitioned index, the results are in ascending order within each partition.Each parameter serves the same purpose as in&nbsp;"INDEX Hint". For example:</P>  <P style="TEXT-INDENT: 2em;"  >SELECT /*+ INDEX_SS(e emp_name_ix) */ last_name FROM employees e WHERE first_name = 'Steven';</P>  <P style="TEXT-INDENT: 2em;"  >下面是来自ORACLE PERFORMANCE TUNING里的原文：</P>  <P style="TEXT-INDENT: 2em;"  >Index skip scans improve index scans by nonprefix columns. Often, scanning index blocks is faster than scanning table data blocks.</P>  <P style="TEXT-INDENT: 2em;"  >Skip scanning lets a composite index be split logically into smaller subindexes. In skip scanning, the initial column of the composite index is not specified in the query. In other words, it is skipped.</P>  <P style="TEXT-INDENT: 2em;"  >The number of logical subindexes is determined by the number of distinct values in the initial column. Skip scanning is advantageous if there are few distinct values in the leading column of the composite index and many distinct values in the nonleading key of the index.</P>  <P style="TEXT-INDENT: 2em;"  >Example 13-5 Index Skip Scan</P>  <P style="TEXT-INDENT: 2em;"  >Consider, for example, a table&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >employees</P>  <P style="TEXT-INDENT: 2em;"  >&nbsp;(</P>  <P style="TEXT-INDENT: 2em;"  >sex</P>  <P style="TEXT-INDENT: 2em;"  >,&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >employee_id</P>  <P style="TEXT-INDENT: 2em;"  >,&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >address</P>  <P style="TEXT-INDENT: 2em;"  >) with a composite index on (</P>  <P style="TEXT-INDENT: 2em;"  >sex</P>  <P style="TEXT-INDENT: 2em;"  >,&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >employee_id</P>  <P style="TEXT-INDENT: 2em;"  >). Splitting this composite index would result in two logical subindexes, one for&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >M</P>  <P style="TEXT-INDENT: 2em;"  >&nbsp;and one for&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >F</P>  <P style="TEXT-INDENT: 2em;"  >.</P>  <P style="TEXT-INDENT: 2em;"  >For this example, suppose you have the following index data:</P>  <P style="TEXT-INDENT: 2em;"  >('F',98)('F',100)('F',102)('F',104)('M',101)('M',103)('M',105)</P>  <P style="TEXT-INDENT: 2em;"  >The index is split logically into the following two subindexes:   </P><UL>  <LI>The first subindex has the keys with the value&nbsp;   <P></P>  <P style="TEXT-INDENT: 2em;"  >F</P>  <P style="TEXT-INDENT: 2em;"  >.</P></LI>  <LI>The second subindex has the keys with the value&nbsp;   <P></P>  <P style="TEXT-INDENT: 2em;"  >M</P>  <P style="TEXT-INDENT: 2em;"  ><A target="_blank" href="http://img104.ph.126.net/DV9ADWZcCs8ayBMB4Rxhlw==/700309742057728405.gif" ><IMG title="Oracle Index Skip Scans使用场景 - 德哥(DiGoal,Just Do It!) - Not Only DBA"  alt="Oracle Index Skip Scans使用场景 - 德哥(DiGoal,Just Do It!) - Not Only DBA"  src="http://img104.ph.126.net/DV9ADWZcCs8ayBMB4Rxhlw==/700309742057728405.gif"  ></A>.</P></LI>  <LI>  <P style="TEXT-INDENT: 2em;"  ><A rel="nofollow" href="http://dba.sky-mobi.com/wp-content/uploads/2010/05/pfgrf197.gif"  ></A>The column&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >sex</P>  <P style="TEXT-INDENT: 2em;"  >&nbsp;is skipped in the following query:</P>  <P style="TEXT-INDENT: 2em;"  >SELECT * FROM employeesWHERE employee_id = 101;</P>  <P style="TEXT-INDENT: 2em;"  >A complete scan of the index is not performed, but the subindex with the value&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >F</P>  <P style="TEXT-INDENT: 2em;"  >&nbsp;is searched first, followed by a search of the subindex with the value&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >M</P>  <P style="TEXT-INDENT: 2em;"  >.</P></LI></UL></div>
	</div>
</div>
</body>
</html>