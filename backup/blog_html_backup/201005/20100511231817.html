<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.0 流复制介绍</h2>
	<h5 id="">2010-05-11 23:18:17&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402010411111817376/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><p style="TEXT-INDENT: 2em;"   >PostgreSQL9提供了一个非常兴奋的功能，hot-standby,功能与ORACLE 11G的ACTIVE STANDBY类似。并且增加了流复制的功能，这个与oracle 的standby redo log功能类似,大大的缩短了备份库与主库的事务间隔。</p>  <p style="TEXT-INDENT: 2em;"   >HOT-STANDBY可以提供容灾，恢复的同时可以把数据库打开，提供查询功能。以前的版本恢复的时候是不能打开的。</p>  <p style="TEXT-INDENT: 2em;"   >首先看一张postgreSQL的高可用，负载均衡，复制特征矩阵图</p>  <p style="TEXT-INDENT: 2em;"   ><a rel="nofollow" href="http://dba.sky-mobi.com/wp-content/uploads/2010/05/postgresql-ha-lb-rep.jpg"   ></a></p>  <p style="TEXT-INDENT: 2em;"   ><a target="_blank" href="http://img542.ph.126.net/qry8eEXGZeYB3GMXjbpR1g==/104145741384016767.jpg"   ><img title="PostgreSQL 9.0 流复制介绍 - 德哥(DiGoal,Just Do It!) - Not Only DBA"   alt="PostgreSQL 9.0 流复制介绍 - 德哥(DiGoal,Just Do It!) - Not Only DBA"   src="http://img542.ph.126.net/qry8eEXGZeYB3GMXjbpR1g==/104145741384016767.jpg"   ></a></p>  <p style="TEXT-INDENT: 2em;"   >这里有一个很好的特性   <table border="1"   >  <thead>  <tr>  <th>Hot/Warm Standby Using PITR</th></tr></thead>  <tbody></table>  <table border="1"   >  <tbody>  <tr>  <td>Slaves accept read-only queries</td></tr></table></p>  <p style="TEXT-INDENT: 2em;"   ></p>  <p style="TEXT-INDENT: 2em;"   >下面是来自POSTGRESQL WIKI的文档，非常简单，这里就不作翻译了。</p>  <p style="TEXT-INDENT: 2em;"   >SR is being developed for inclusion in PostgreSQL 9.0 by NTT OSS Center. The lead developer is&nbsp;.&nbsp;<a rel="nofollow" href="http://www.pgcon.org/2008/schedule/events/76.en.html"   >Synchronous Log Shipping Replication Presentation</a>&nbsp;introduces the early design of the feature.</p>  <p style="TEXT-INDENT: 2em;"   >Users Overview</p>  <p style="TEXT-INDENT: 2em;"   >  </p><ul>  <li>Log-shipping   <ul>  <li>XLOG records generated in the primary are periodically shipped to the standby via the network.</li>  <li>In the existing warm standby, only records in a filled file are shipped, what’s referred to as file-based log-shipping. In SR, XLOG records in partially-filled XLOG file are shipped too, implementing record-based log-shipping. This means the window for data loss in SR is usually smaller than in warm standby, unless the warm standby was also configured for record-based shipping (which is complicated to setup).</li>  <li>The content of XLOG files written to the standby are exactly the same as those on the primary. XLOG files shipped can be used for a normal recovery and PITR.</li></ul></li>  <li>Multiple standbys   <ul>  <li>More than one standby can establish a connection to the primary for SR. XLOG records are concurrently shipped to all these standbys. The delay/death of a standby does not harm log-shipping to other standbys.</li>  <li>The maximum number of standbys can be specified as a GUC variable.</li></ul></li>  <li>Continuous recovery   <ul>  <li>The standby continuously replays XLOG records shipped without using pg_standby.</li>  <li>XLOG records shipped are replayed as soon as possible without waiting until XLOG file has been filled. The combination of&nbsp;<a rel="nofollow" href="http://wiki.postgresql.org/wiki/Hot_Standby"   >Hot Standby</a>&nbsp;and SR would make the latest data inserted into the primary visible in the standby almost immediately.</li>  <li>The standby periodically removes old XLOG files which are no longer needed for recovery, to prevent excessive disk usage.</li></ul></li>  <li>Setup   <ul>  <li>The start of log-shipping does not interfere with any query processing on the primary.</li>  <li>The standby can be started in various conditions.   <ul>  <li>If there are XLOG files in archive directory and restore_command is supplied, at first those files are replayed. Then the standby requests XLOG records following the last applied one to the primary. This prevents XLOG files already present in the standby from being shipped again. Similarly, XLOG files in pg_xlog are also replayed before starting log-shipping.</li>  <li>If there is no XLOG files on the standby, the standby requests XLOG records following the starting XLOG location of recovery (the redo starting location).</li></ul></li></ul></li>  <li>Connection settings and authentication   <ul>  <li>A user can configure the same settings as a normal connection to a connection for SR (e.g., keepalive, pg_hba.conf).</li></ul></li>  <li>Activation   <ul>  <li>The standby can keep waiting for activation as long as a user likes. This prevents the standby from being automatically brought up by failure of recovery or network outage.</li></ul></li>  <li>Progress report   <ul>  <li>The primary and standby report the progress of log-shipping in PS display.</li></ul></li>  <li>Graceful shutdown   <ul>  <li>When smart/fast shutdown is requested, the primary waits to exit until XLOG records have been sent to the standby, up to the shutdown checkpoint record.</li></ul></li></ul>  <p></p>  <p style="TEXT-INDENT: 2em;"   ><a rel="nofollow"   ></a></p>  <p style="TEXT-INDENT: 2em;"   >Restrictions</p>  <p style="TEXT-INDENT: 2em;"   >  </p><ul>  <li>Synchronous log-shipping   <ul>  <li>Currently SR supports only asynchronous log-shipping. The commit command might return a “success” to a client before the corresponding XLOG records are shipped to the standby.</li></ul></li>  <li>Replication beyond timeline   <ul>  <li>A user has to get a fresh backup whenever making the old standby catch up.</li></ul></li>  <li>Clustering   <ul>  <li>Postgres doesn’t provide any clustering feature.</li></ul></li></ul>  <p></p>  <p style="TEXT-INDENT: 2em;"   ><a rel="nofollow"   ></a></p>  <p style="TEXT-INDENT: 2em;"   >How to Use</p>  <p style="TEXT-INDENT: 2em;"   >  </p><ul>  <li>1.&nbsp;Install postgres in the primary and standby server as usual. This requires only&nbsp;configure,&nbsp;makeand&nbsp;make install.</li>  <li>2.&nbsp;Create the initial database cluster in the primary server as usual, using&nbsp;initdb.</li>  <li>3.&nbsp;Set up connections and authentication so that the standby server can successfully connect to the&nbsp;replication&nbsp;pseudo-database on the primary.</li></ul>  <p></p>  <p style="TEXT-INDENT: 2em;"   >$ $EDITOR postgresql.conflisten_addresses = '192.168.0.10'$ $EDITOR pg_hba.conf# The standby server must have superuser access privileges.host replication postgres 192.168.0.20/22 trust   </p><ul>  <li>4.&nbsp;Set up the streaming replication related parameters on the primary server.</li></ul>  <p></p>  <p style="TEXT-INDENT: 2em;"   >$ $EDITOR postgresql.conf# To enable read-only queries on a standby server, wal_level must be set to# "hot_standby". But you can choose "archive" if you never connect to the# server in standby mode.wal_level = hot_standby# Set the maximum number of concurrent connections from the standby servers.max_wal_senders = 5# To prevent the primary server from removing the WAL segments required for# the standby server before shipping them, set the minimum number of segments# retained in the pg_xlog directory. At least wal_keep_segments should be# larger than the number of segments generated between the beginning of# online-backup and the startup of streaming replication. If you enable WAL# archiving to an archive directory accessible from the standby, this may# not be necessary.wal_keep_segments = 32# Enable WAL archiving on the primary to an archive directory accessible from# the standby. If wal_keep_segments is a high enough number to retain the WAL# segments required for the standby server, this may not be necessary.archive_mode = onarchive_command = 'cp&nbsp;%p /path_to/archive/%f'   </p><ul>  <li>5.&nbsp;Start postgres on the primary server.</li>  <li>6.&nbsp;Make a base backup by copying the primary server’s data directory to the standby server.</li></ul>  <p></p>  <p style="TEXT-INDENT: 2em;"   >$ psql -c "SELECT pg_start_backup('label', true)"$ rsync -a ${PGDATA}/ standby:/srv/pgsql/standby/ --exclude postmaster.pid$ psql -c "SELECT pg_stop_backup()"   </p><ul>  <li>7.&nbsp;Set up replication-related parameters, connections and authentication in the standby server like the primary, so that the standby might work as a primary after failover.</li>  <li>8.&nbsp;Enable read-only queries on the standby server. But if wal_level is&nbsp;archive&nbsp;on the primary, leave hot_standby unchanged (i.e., off).</li></ul>  <p></p>  <p style="TEXT-INDENT: 2em;"   >$ $EDITOR postgresql.confhot_standby = on   </p><ul>  <li>9.&nbsp;Create a recovery command file in the standby server; the following parameters are required for streaming replication.</li></ul>  <p></p>  <p style="TEXT-INDENT: 2em;"   >$ $EDITOR recovery.conf# Specifies whether to start the server as a standby. In streaming replication,# this parameter must to be set to on.standby_mode = 'on'# Specifies a connection string which is used for the standby server to connect# with the primary.primary_conninfo = 'host=192.168.0.10 port=5432 user=postgres'# Specifies a trigger file whose presence should cause streaming replication to# end (i.e., failover).trigger_file = '/path_to/trigger'# Specifies a command to load archive segments from the WAL archive. If# wal_keep_segments is a high enough number to retain the WAL segments# required for the standby server, this may not be necessary. But# a large workload can cause segments to be recycled before the standby# is fully synchronized, requiring you to start again from a new base backup.restore_command = 'cp /path_to/archive/%f "%p"'   </p><ul>  <li>10.&nbsp;Start postgres in the standby server. It will start streaming replication.</li>  <li>11.&nbsp;You can check the progress of streaming replication by using&nbsp;ps&nbsp;command.</li></ul>  <p></p>  <p style="TEXT-INDENT: 2em;"   ># The displayed LSNs indicate the byte position that the standby server has# written up to in the xlogs.[primary] $ ps -ef | grep senderpostgres 6879 6831 0 10:31&nbsp;? 00:00:00 postgres: wal sender process postgres 127.0.0.1(44663) streaming 0/2000000[standby] $ ps -ef | grep receiverpostgres 6878 6872 1 10:31&nbsp;? 00:00:01 postgres: wal receiver process streaming 0/2000000   </p><ul>  <li>How to do failover   <ul>  <li>Create the trigger file in the standby after the primary fails.</li></ul></li>  <li>How to stop the primary or the standby server   <ul>  <li>Shut down it as usual (pg_ctl stop).</li></ul></li>  <li>How to restart streaming replication after failover   <ul>  <li>Repeat the operations from&nbsp;6th; making a fresh backup, some configurations and starting the original primary as the standby. The primary server doesn’t need to be stopped during these operations.</li></ul></li>  <li>How to restart streaming replication after the standby fails   <ul>  <li>Restart postgres in the standby server after eliminating the cause of failure.</li></ul></li>  <li>How to disconnect the standby from the primary   <ul>  <li>Create the trigger file in the standby while the primary is running. Then the standby would be brought up.</li></ul></li>  <li>How to re-synchronize the stand-alone standby after isolation   <ul>  <li>Shut down the standby as usual. And repeat the operations from&nbsp;6th.</li></ul></li></ul>具体的应用场景案例分享可参看以下BLOG.<div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >1. 《PostgreSQL 9.1 Allow standby recovery to switch to a new timeline automatically》</font></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201182395310376/"   ><font size="2"   >http://blog.163.com/digoal@126/blog/static/163877040201182395310376/</font></a></div><div><font size="2"   >2.&nbsp;</font><span style="line-height: 19px; font-size: small;"   >《</span><span style="font-size: small;"   >PostgreSQL 9.2 devel adding cascading replication support》</span></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012012361519/"   ><font size="2"   >http://blog.163.com/digoal@126/blog/static/1638770402012012361519/</font></a></div><div><font size="2"   >3. 《PostgreSQL HOT STANDBY using Stream》</font></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020110442050808/"   ><font size="2"   >http://blog.163.com/digoal@126/blog/static/16387704020110442050808/</font></a></div></div><div><font size="2"   >4. 《PostgreSQL cluster role switchover between primary and standby》</font></div><div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201141154024306/"   ><font size="2"   >http://blog.163.com/digoal@126/blog/static/163877040201141154024306/</font></a></div><div><font size="2"   >5. 《We can ignore the performance influence when use sync replication in PostgreSQL 9.1》</font></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201192203458765/"   ><font size="2"   >http://blog.163.com/digoal@126/blog/static/163877040201192203458765/</font></a></div><div><font size="2"   >6. 《PostgreSQL 9.1 Replication role privilege change to REPLICATION from SUPERUSER》</font></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020114112379185/"   ><font size="2"   >http://blog.163.com/digoal@126/blog/static/16387704020114112379185/</font></a></div><div><font size="2"   >7. 《PostgreSQL 9.0.2 Replication Best Practices》</font></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402010113034232645/"   ><font size="2"   >http://blog.163.com/digoal@126/blog/static/1638770402010113034232645/</font></a></div><div><font size="2"   >8. 《PostgreSQL replication monitor》</font></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201141134748660/"   ><font size="2"   >http://blog.163.com/digoal@126/blog/static/163877040201141134748660/</font></a></div><div><font size="2"   >9. 《New replication mode: async, write, fsync, replay》</font></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020121231117557/"   ><font size="2"   >http://blog.163.com/digoal@126/blog/static/16387704020121231117557/</font></a></div></div><div><div><font size="2"   >10. 《PostgreSQL HOT STANDBY using log shipping》</font></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402010113053825671/"   ><font size="2"   >http://blog.163.com/digoal@126/blog/static/1638770402010113053825671/</font></a></div></div><p></p></pre></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL 9.0 流复制介绍 - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">huominglong - 2013-08-08 17:43:07</h5>
				<div>问个问题 流复制的sender和receiver进程是怎么协同工作的，wal的记录通过tcp传输的过程是怎么样的，master是通过什么知道slave的wal日志已经应用到什么位置了</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 huominglong - 2013-08-08 17:43:07</h5>
				<div style="width:600px;">Plsease see&nbsp;http://www.postgresql.org/docs/9.2/static/protocol-replication.html<div>and src/backend/replication/</div></div>
			</div>
	</div>
</div>
</body>
</html>