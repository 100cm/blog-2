<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">pg_reorg doesn't break your DML,but don't forget it's performance influence.</h2>
	<h5 id="">2011-08-08 13:13:52&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201178111910161/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><span style="white-space:pre;"> </span>&nbsp;这几天在做一个从Oracle迁移到PostgreSQL数据库环境的业务压力测试。</div><div><span style="white-space:pre;"> </span>目前该业务在Oracle里面压力最大的部分是两个表的频繁UPDATE。</div><div><span style="white-space:pre;"> </span>迁移到PostgreSQL的话，势必也面临这方面得挑战。</div><div><span style="white-space:pre;"> </span>在大压力下测试1天下来（每分钟产生4.6GB的XLOG），平均的更新SQL QPS约9000每秒. 平均响应时间约2ms 。这个数字已经远远超过业务的需求。</div><div><span style="white-space:pre;"> </span>但是从1天的性能趋势图来看，性能程下降趋势，原因是索引在大量的更新后膨胀了。表的话因为开启了AUTOVACUUM基本上保持在一个SIZE。</div><div><span style="white-space:pre;"> </span>需要解决性能下降的问题，就要解决索引的膨胀问题。</div><div><span style="white-space:pre;"> </span>处理方法可以是重建索引，reindex不提供concurrency的选项。新建索引提供concurrency的选项。</div><div><span style="white-space:pre;"> </span>因此想到了一个pg_reorg的开源软件，这个软件提供在线重组数据的功能，使用的方法是在源表新建触发器，然后用WORK TABLE来完成数据的重组，重组完后更改系统的CATALOG，用WORK TABLE 替换源表。</div><div><span style="white-space:pre;"> </span>可以说pg_reorg解决了一个数据库层面锁等待的问题。使得重组的过程中不中断DML操作。这个用REINDEX是做不到的。</div><div><span style="white-space:pre;"> </span>但是不够是用reindex或者是reindex来重组索引，都会带来一个问题，对数据库存储的IO开销的增加。这个是我们必须考虑的。</div><div><span style="white-space:pre;"> </span>特别是pg_reorg concurrency的情况下，如果系统本来就处于高度繁忙的状态，执行pg_reorg会带来严重的性能压力。</div><div><br></div><div><span style="white-space:pre;"> </span>下面是我在一个高度压力下面做pg_reorg的结果,对一个3.8GB(索引12.5GB)的表进行重组。同时使用pgbench不停的更新这个表的记录,开3个数据库连接, 重组耗时约20分钟。</div><div><span style="white-space:pre;"> </span>做PG_REORG之前的业务性能:</div><div><span style="white-space:pre;">  </span>QPS=2728 , 平均响应时间1.1毫秒</div><div><span style="white-space:pre;"> </span>做pg_reorg时的业务性能:</div><div><span style="white-space:pre;">  </span>QPS=2101&nbsp;, 平均响应时间1.4毫秒</div><div><span style="white-space:pre;">  </span>性能下降 23%</div><div><br></div><div><span style="white-space:pre;"> </span>做完pg_reorg之后,表变成3.4GB,索引6.3GB</div><div><span style="white-space:pre;">  </span>业务性能达到QPS=4523&nbsp;, 平均响应时间0.7毫秒</div><div><span style="white-space:pre;">  </span>性能提升 66%，提升明显。</div><div><br></div><div><span style="white-space:pre;"> </span>pg_reorg重组开始和结束的时候，需要对表加一个ACCESS EXCLUSIVE MODE锁，开始的时候是要在表上加触发器，结束的时候是要将工作表切换到源表。</div><div><span style="white-space:pre;"> </span>如果这两次加载锁的时间超过了软件设置的时间，将会杀掉冲突锁的BACKEND 进程。确保能拿到锁。</div><div><span style="white-space:pre;"> </span>如：</div><div><span style="white-space:pre;"> </span>重组开始时</div><div><div>LOG: (query) BEGIN ISOLATION LEVEL READ COMMITTED</div><div>LOG: (query) SET LOCAL statement_timeout = 1000</div><div>LOG: (query) LOCK TABLE cac_player_info.cac_player_info IN ACCESS EXCLUSIVE MODE</div><div>LOG: (query) ROLLBACK</div><div>LOG: (query) BEGIN ISOLATION LEVEL READ COMMITTED</div><div>WARNING: canceling conflicted backends</div><div>LOG: (query) SELECT pg_cancel_backend(pid) FROM pg_locks WHERE locktype = 'relation' &nbsp; AND relation = $1 AND pid &lt;&gt; pg_backend_pid()</div><div>LOG: &nbsp; &nbsp;(param:0) = 16432</div><div>LOG: (query) SET LOCAL statement_timeout = 1000</div><div>LOG: (query) LOCK TABLE cac_player_info.cac_player_info IN ACCESS EXCLUSIVE MODE</div><div>LOG: (query) RESET statement_timeout</div><div>LOG: (query) SELECT reorg.conflicted_triggers($1)</div><div>LOG: &nbsp; &nbsp;(param:0) = 16432</div><div>LOG: (query) CREATE TYPE reorg.pk_16432 AS (player_info_id numeric(10,0))</div><div>LOG: (query) CREATE TABLE reorg.log_16432 (id bigserial PRIMARY KEY, pk reorg.pk_16432, row cac_player_info.cac_player_info)</div><div>LOG: (query) CREATE TRIGGER z_reorg_trigger BEFORE INSERT OR DELETE OR UPDATE ON cac_player_info.cac_player_info FOR EACH ROW EXECUTE PROCEDURE reorg.reorg_trigger('INSERT INTO reorg.log_16432(pk, row) VALUES( CASE WHEN $1 IS NULL THEN NULL ELSE (ROW($1.player_info_id)::reorg.pk_16432) END, $2)')</div><div>LOG: (query) SELECT reorg.disable_autovacuum('reorg.log_16432')</div><div>LOG: (query) COMMIT</div><div>LOG: (query) BEGIN ISOLATION LEVEL SERIALIZABLE</div><div>LOG: (query) SELECT set_config('work_mem', current_setting('maintenance_work_mem'), true)</div><div>LOG: (query) SET LOCAL synchronize_seqscans = off</div><div>LOG: (query) SELECT reorg.array_accum(virtualtransaction) FROM pg_locks WHERE locktype = 'virtualxid' AND pid &lt;&gt; pg_backend_pid()</div><div>LOG: (query) DELETE FROM reorg.log_16432</div><div>LOG: (query) CREATE TABLE reorg.table_16432 WITH (oids=false) TABLESPACE pg_default AS SELECT player_info_id,sky_id,nick_name,gender,head_bmp_id,account_status,chat_status,exp,level_num,next_level_exp,money,active_time,create_time,last_login_server_mod_id FROM ONLY cac_player_info.cac_player_info</div><div>LOG: (query) SELECT reorg.disable_autovacuum('reorg.table_16432')</div><div>LOG: (query) COMMIT</div></div><div>。。。。。。。。。。。。。。。。</div><div><br></div><div><span style="white-space:pre;"> </span>重组结束时:</div><div><div>LOG: (query) BEGIN ISOLATION LEVEL READ COMMITTED</div><div>LOG: (query) SET LOCAL statement_timeout = 1000</div><div>LOG: (query) LOCK TABLE cac_player_info.cac_player_info IN ACCESS EXCLUSIVE MODE</div><div>LOG: (query) ROLLBACK</div><div>LOG: (query) BEGIN ISOLATION LEVEL READ COMMITTED</div><div>WARNING: canceling conflicted backends</div><div>LOG: (query) SELECT pg_cancel_backend(pid) FROM pg_locks WHERE locktype = 'relation' &nbsp; AND relation = $1 AND pid &lt;&gt; pg_backend_pid()</div><div>LOG: &nbsp; &nbsp;(param:0) = 16432</div><div>LOG: (query) SET LOCAL statement_timeout = 1000</div><div>LOG: (query) LOCK TABLE cac_player_info.cac_player_info IN ACCESS EXCLUSIVE MODE</div><div>LOG: (query) RESET statement_timeout</div><div>LOG: (query) SELECT reorg.reorg_apply($1, $2, $3, $4, $5, $6)</div></div><div>。。。。。。。。。。。。</div><div><br></div><div><br></div><div>对于使用pg_reorg进行表重组的建议 :&nbsp;</div><div>1. 避开pg_reorg明文禁止的限制。</div><div><span style="color: rgb(32, 32, 32); font-family: 'Lucida Grande', Verdana, Arial, Helvetica, メイリオ, Meiryo, 'ヒラギノ角ゴ Pro W3', 'Hiragino Kaku Gothic Pro', Osaka, 'ＭＳ Ｐゴシック', sans-serif; line-height: normal; font-size: medium;">pg_reorg cannot reorganize temp tables.</span></div><div><span style="color: rgb(32, 32, 32); font-family: 'Lucida Grande', Verdana, Arial, Helvetica, メイリオ, Meiryo, 'ヒラギノ角ゴ Pro W3', 'Hiragino Kaku Gothic Pro', Osaka, 'ＭＳ Ｐゴシック', sans-serif; line-height: normal; font-size: medium;">pg_reorg cannot reorganize tables using GiST indexes.</span></div><div><span style="color: rgb(32, 32, 32); font-family: 'Lucida Grande', Verdana, Arial, Helvetica, メイリオ, Meiryo, 'ヒラギノ角ゴ Pro W3', 'Hiragino Kaku Gothic Pro', Osaka, 'ＭＳ Ｐゴシック', sans-serif; line-height: normal; font-size: medium;">You cannot do DDL commands&nbsp;<strong>except</strong>&nbsp;VACUUM and ANALYZE during pg_reorg. In many case pg_reorg would fail and rollback collectly, but there are some cases ending with data-corruption .</span></div><div>2. 避免表关联如reference，可能会带来一定的问题。</div><div>3. 避开业务高峰，最好在最低谷的时候执行。</div><div>4. 可能还需要考虑周边的影响，如使用了pgfincore的情况下，是否需要重新定义表的fincore属性。</div><div><br></div><div>【参考】</div><div><a rel="nofollow" href="http://pgfoundry.org/projects/reorg/">http://pgfoundry.org/projects/reorg/</a></div></div>
	</div>
</div>
</body>
</html>