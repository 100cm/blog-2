<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Why use age(xid) function in standby emit error message : cannot assign TransactionIds during recovery</h2>
	<h5 id="">2012-07-12 13:02:38&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201261204118729/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">今天早上的时候QQ群里有位兄弟问了一个问题如下 :&nbsp;<div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg 9.1 使用stream 方式 做主备 ，在备库日志中每隔5分钟就出现：</font></div><div><font size="2"   >CSTERROR: &nbsp;cannot assign TransactionIds during recovery</font></div><div><font size="2"   >&nbsp;CSTSTATEMENT: &nbsp;SET statement_timeout=30000;BEGIN;SET statement_timeout=30000;COMMIT;SELECT datname, age(datfrozenxid) FROM pg_database WHERE datallowconn ORDER BY 1, 2</font></div><div><font size="2"   >大家有没遇到过这样的问题呢</font></div><p></p></pre></div><div>先不谈每隔5分钟, 和它没关系, 可能是什么定时任务触发了这个查询. 还是先找找这个出错的SQL是哪个,&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \set VERBOSITY verbose</font></div><div><div><font size="2"   >postgres=# SELECT datname, age(datfrozenxid) FROM pg_database WHERE datallowconn ORDER BY 1, 2;</font></div><div><font size="2"   >ERROR: &nbsp;XX000: cannot assign TransactionIds during recovery</font></div><div><font size="2"   >LOCATION: &nbsp;GetNewTransactionId, varsup.c:64</font></div></div><p></p></pre></div><div>这里我们看到出错的是这个SQL (<span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"   >SELECT datname, age(datfrozenxid) FROM pg_database WHERE datallowconn ORDER BY 1, 2;</span>)，但是为什么会出错呢?</div><div>从错误日志来看，找到varsup.c里面的<span style="line-height: 22px;"   >GetNewTransactionId函数 :&nbsp;</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Allocate the next XID for a new transaction or subtransaction.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The new XID is also stored into MyProc before returning.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: when this is called, we are actually already inside a valid</font></div><div><font size="2"   >&nbsp;* transaction, since XIDs are now not allocated until the transaction</font></div><div><font size="2"   >&nbsp;* does something. &nbsp; &nbsp; &nbsp;So it is safe to do a database lookup if we want to</font></div><div><font size="2"   >&nbsp;* issue a warning about XID wrap.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >TransactionId</font></div><div><font size="2"   >GetNewTransactionId(bool isSubXact)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* During bootstrap initialization, we return the special bootstrap</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* transaction id.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (IsBootstrapProcessingMode())</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!isSubXact);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MyProc-&gt;xid = BootstrapTransactionId;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return BootstrapTransactionId;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div><div><br></div><div>-- 执行到下面这个判断报的错.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* safety check, we should never get this far in a HS slave */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (RecoveryInProgress())</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "cannot assign TransactionIds during recovery");</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockAcquire(XidGenLock, LW_EXCLUSIVE);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; xid = ShmemVariableCache-&gt;nextXid;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check to see if it's safe to assign another XID. &nbsp;This protects against</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* catastrophic data loss due to XID wraparound. &nbsp;The basic rules are:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><p></p></pre></div></div><div>那么为什么要调用这个函数呢,&nbsp;GetNewTransactionId, 这个函数是获取一个新的事务ID。</div><div>也就是说age(xid)函数在执行时要获取一个新的事务ID，为什么呢？</div><div>因为算一个XID的年龄必须要知道当前的事务号才有得比较。</div><div>我们可以在一个PostgreSQL 9.1.3 的primary数据库中执行, 看看是不是执行完age(xid)后, 事务号会发生变化.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select datname,age(datfrozenxid) from pg_database where datname='postgres';</font></div><div><font size="2"   >&nbsp;datname &nbsp;| &nbsp; age &nbsp; &nbsp;</font></div><div><font size="2"   >----------+----------</font></div><div><font size="2"   >&nbsp;postgres | 14686244</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >确保没有其他客户端连接的情况下，再次执行</font></div><div><font size="2"   >postgres=# select datname,age(datfrozenxid) from pg_database where datname='postgres';</font></div><div><font size="2"   >&nbsp;datname &nbsp;| &nbsp; age &nbsp; &nbsp;</font></div><div><font size="2"   >----------+----------</font></div><div><font size="2"   >&nbsp;postgres | 14686245</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>年龄增长了1.</div><div>也就是说PostgreSQL 9.1 中age()函数需要调用<span style="line-height: 22px;"   >GetNewTransactionId 去获取当前事务ID。</span></div><div><span style="line-height: 22px;"   >那么我们到9.3的数据库中试试会不会这样呢?</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select datname,age(datfrozenxid) from pg_database where datname='postgres';</font></div><div><font size="2"   >&nbsp;datname &nbsp;| age&nbsp;</font></div><div><font size="2"   >----------+-----</font></div><div><font size="2"   >&nbsp;postgres | &nbsp;33</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><span style="line-height: 22px;"   >确保没有其他客户端连接的情况下，再次执行</span> </font></div><div><font size="2"   >postgres=# select datname,age(datfrozenxid) from pg_database where datname='postgres';</font></div><div><font size="2"   >&nbsp;datname &nbsp;| age&nbsp;</font></div><div><font size="2"   >----------+-----</font></div><div><font size="2"   >&nbsp;postgres | &nbsp;33</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>9.3 没有发生这样的情况. age(xid) 函数显然没有去获取一个新的XID。</div><div>经证实PostgreSQL9.2beta2 中age函数也不需要获取一个新的XID。</div><div><br></div><div>其他age函数则不会出现这个问题 :&nbsp;</div><div><div><pre class="prettyprint"   ><div><div><font size="2"   >postgres=# select age(timestamp '2011-01-01');</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; age &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------------------</font></div><div><font size="2"   >&nbsp;1 year 6 mons 11 days</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# select age(timestamp '2011-01-01',now());</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; age &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >--------------------------------------------</font></div><div><font size="2"   >&nbsp;-1 years -6 mons -11 days -13:04:46.049847</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# \df *.*age*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List of functions</font></div><div><font size="2"   >&nbsp; &nbsp;Schema &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Result data type | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Argument data types &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp;Type &nbsp;</font></div><div><font size="2"   >------------+------------------------+------------------+----------------------------------------------------------+--------</font></div><div><font size="2"   >&nbsp;pg_catalog | age &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| interval &nbsp; &nbsp; &nbsp; &nbsp; | timestamp with time zone &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | normal</font></div><div><font size="2"   >&nbsp;pg_catalog | age &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| interval &nbsp; &nbsp; &nbsp; &nbsp; | timestamp with time zone, timestamp with time zone &nbsp; &nbsp; &nbsp; | normal</font></div><div><font size="2"   >&nbsp;pg_catalog | age &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| interval &nbsp; &nbsp; &nbsp; &nbsp; | timestamp without time zone &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| normal</font></div><div><font size="2"   >&nbsp;pg_catalog | age &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| interval &nbsp; &nbsp; &nbsp; &nbsp; | timestamp without time zone, timestamp without time zone | normal</font></div><div><font size="2"   >&nbsp;pg_catalog | age &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| integer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| xid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| normal</font></div><p></p></pre></div></div><wbr></div>
<div><br></div><a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="Why use age(xid) function in standby emit error message : cannot assign TransactionIds during recovery - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>