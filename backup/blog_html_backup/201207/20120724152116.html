<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">AccessShareLock followed by AccessExclusiveLock and followed by other lock request waiting forever</h2>
	<h5 id="">2012-07-24 15:21:16&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020126243121392/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">今天一位网友反映的一个很奇特的问题, 数据库中有一些进程处于idle in transaction的状态, 并且其他的进程显现出来的是在等待这些 <span style="line-height: 22px;"  >idle in transaction</span>&nbsp;进程的锁释放. 奇特不是奇特在idle in transaction, 而是奇特在下面. 请不要把关注重点放在idle in transaction. 往下看.<div><br></div><div>这些<span style="line-height: 22px;"  >idle in transaction进程持有的锁是</span>AccessShareLock, 等待锁的进程中有一些是请求与idle in transaction 那些进程持有的<span style="line-height: 22px;"  >同表的</span>AccessShareLock 锁的. 我们知道AccessShareLock和AccessShareLock锁是不冲突的. 但是为什么会出现这样的情况呢?</div><div><br></div><div>原因查明是这样的 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >session 1 :&nbsp;</font></div><div><font size="2"  >begin;</font></div><div><font size="2"  >AccessShareLock granted</font></div><div><font size="2"  >idle in transaction</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >session 2 :&nbsp;</font></div><div><font size="2"  >AccessExclusiveLock waiting</font></div><div><font size="2"  >(注意, session 2 未获得 AccessExclusiveLock 锁, 它只是在请求这个锁)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >session others :&nbsp;</font></div><div><font size="2"  >any lock request, waiting session 2.</font></div><div><font size="2"  ><span style="line-height: 19px;"  >(奇特在这个地方, 请求任何锁都会处于等待状态, 包括AccessShareLock)</span></font></div><p></p></pre></div><div>这里不分析为什么会有大量的idle in transaction事务存在, 这个要从应用程序着手查找原因, 这里只讨论一下PostgreSQL 的锁释放和冲突与其他数据库不一样的地方.</div><div><br></div><div>接下来重现一下, 大家在设计程序和维护数据库的时候要避免这种情况发生, 如果使用autocommit则不会出现这种情况.</div><div>SESSION 1 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >postgres=# select * from t1;</font></div><div><font size="2"  >&nbsp;id&nbsp;</font></div><div><font size="2"  >----</font></div><div><font size="2"  >&nbsp; 1</font></div><div><font size="2"  >&nbsp; 2</font></div><div><font size="2"  >(2 rows)</font></div><p></p></pre></div><div><br></div><div>SESSION 2 :&nbsp;</div><div>-- 查看锁信息</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# select * from lockview1;</font></div><div><font size="2"  >&nbsp; pid &nbsp;| &nbsp;vxid &nbsp; | lock_type | &nbsp; &nbsp;lock_mode &nbsp; &nbsp;| granted | xid_lock | relname&nbsp;</font></div><div><font size="2"  >-------+---------+-----------+-----------------+---------+----------+---------</font></div><div><font size="2"  >&nbsp;13053 | 10/4513 | relation &nbsp;| AccessShareLock | t &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| t1</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div>SESSION 3 :&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >postgres=# vacuum full t1;</font></p></pre></div><div>-- 处于等待状态</div><div><br></div><div><div style="line-height: 22px;"  >SESSION 2 :&nbsp;</div><div style="line-height: 22px;"  >-- 查看锁信息</div><div><div><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >postgres=# select * from lockview1;</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; pid &nbsp;| &nbsp; vxid &nbsp; | lock_type | &nbsp; &nbsp; &nbsp;lock_mode &nbsp; &nbsp; &nbsp;| granted | xid_lock | relname&nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  >-------+----------+-----------+---------------------+---------+----------+---------</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp;13053 | 10/4513 &nbsp;| relation &nbsp;| AccessShareLock &nbsp; &nbsp; | t &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| t1</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp;13135 | 12/17353 | relation &nbsp;| AccessExclusiveLock | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| t1</font></div><div style="line-height: 22px;"  ><font size="2"  >(2 rows)</font></div><p></p></pre></div><div style="line-height: 22px;"  ><br></div></div></div><div>SESSION 4 :&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >postgres=# select * from t1;</font></p></pre></div><div>-- 处于等待状态</div><div><br></div><div><div style="line-height: 22px;"  >SESSION 2 :&nbsp;</div><div style="line-height: 22px;"  >-- 查看锁信息</div><div><div><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >postgres=# select * from lockview1;</font></div><div><div><font size="2"  >&nbsp; pid &nbsp;| &nbsp; vxid &nbsp; | lock_type | &nbsp; &nbsp; &nbsp;lock_mode &nbsp; &nbsp; &nbsp;| granted | xid_lock | relname&nbsp;</font></div><div><font size="2"  >-------+----------+-----------+---------------------+---------+----------+---------</font></div></div><div><div><font size="2"  >&nbsp;13053 | 10/4513 &nbsp;| relation &nbsp;| AccessShareLock &nbsp; &nbsp; | t &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| t1</font></div><div><font size="2"  >&nbsp;13135 | 12/17353 | relation &nbsp;| AccessExclusiveLock | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| t1</font></div><div><font size="2"  >&nbsp;13172 | 13/18637 | relation &nbsp;| AccessShareLock &nbsp; &nbsp; | f &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| t1</font></div></div><p></p></pre></div></div></div><div><br></div><div>【锁信息大全】</div><div>src/include/storage/lock.h</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/* NoLock is not a lock mode, but a flag value meaning "don't get a lock" */</font></div><div><font size="2"  >#define NoLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >#define AccessShareLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* SELECT */</font></div><div><font size="2"  >#define RowShareLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* SELECT FOR UPDATE/FOR SHARE */</font></div><div><font size="2"  >#define RowExclusiveLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* INSERT, UPDATE, DELETE */</font></div><div><font size="2"  >#define ShareUpdateExclusiveLock 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* VACUUM (non-FULL),ANALYZE, CREATE</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* INDEX CONCURRENTLY */</font></div><div><font size="2"  >#define ShareLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* CREATE INDEX (WITHOUT CONCURRENTLY) */</font></div><div><font size="2"  >#define ShareRowExclusiveLock &nbsp; 6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* like EXCLUSIVE MODE, but allows ROW</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* SHARE */</font></div><div><font size="2"  >#define ExclusiveLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* blocks ROW SHARE/SELECT...FOR</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* UPDATE */</font></div><div><font size="2"  >#define AccessExclusiveLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* ALTER TABLE, DROP TABLE, VACUUM</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* FULL, and unqualified LOCK TABLE */</font></div><p></p></pre></div><div><br></div><div>【查看锁的视图】</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >-- 1.&nbsp;</font></div><div><div><font size="2"  >CREATE VIEW lockview AS</font></div><div><font size="2"  >SELECT pid, virtualtransaction AS vxid, locktype AS lock_type,</font></div><div><font size="2"  >mode AS lock_mode, granted,</font></div><div><font size="2"  >CASE</font></div><div><font size="2"  >WHEN virtualxid IS NOT NULL AND transactionid IS NOT NULL</font></div><div><font size="2"  >THEN virtualxid || ' ' || transactionid</font></div><div><font size="2"  >WHEN virtualxid::text IS NOT NULL</font></div><div><font size="2"  >THEN virtualxid</font></div><div><font size="2"  >ELSE transactionid::text</font></div><div><font size="2"  >END AS xid_lock, relname,</font></div><div><font size="2"  >page, tuple, classid, objid, objsubid</font></div><div><font size="2"  >FROM pg_locks LEFT OUTER JOIN pg_class ON (pg_locks.relation = pg_class.oid)</font></div><div><font size="2"  >WHERE -- do not show our view's locks</font></div><div><font size="2"  >pid != pg_backend_pid() AND</font></div><div><font size="2"  >-- no need to show self-vxid locks</font></div><div><font size="2"  >virtualtransaction IS DISTINCT FROM virtualxid</font></div><div><font size="2"  >-- granted is ordered earlier</font></div><div><font size="2"  >ORDER BY 1, 2, 5 DESC, 6, 3, 4, 7;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >-- 2.&nbsp;</font></div><div><font size="2"  >CREATE VIEW lockview1 AS</font></div><div><font size="2"  >SELECT pid, vxid, lock_type, lock_mode, granted, xid_lock, relname</font></div><div><font size="2"  >FROM lockview</font></div><div><font size="2"  >-- granted is ordered earlier</font></div><div><font size="2"  >ORDER BY 1, 2, 5 DESC, 6, 3, 4, 7;</font></div></div><div><font size="2"  ><br></font></div><div><font size="2"  >-- 3.</font></div><div><div><font size="2"  >CREATE VIEW lockview2 AS</font></div><div><font size="2"  >SELECT pid, vxid, lock_type, page, tuple, classid, objid, objsubid</font></div><div><font size="2"  >FROM lockview</font></div><div><font size="2"  >-- granted is first</font></div><div><font size="2"  >-- add non-display columns to match ordering of lockview</font></div><div><font size="2"  >ORDER BY 1, 2, granted DESC, vxid, xid_lock::text, 3, 4, 5, 6, 7, 8;</font></div></div><p></p></pre></div>【小结】<div>PostgreSQL 为什么在事务中SQL结束后还持有AccessShareLock锁 , 这个和它的锁机制有关系, PostgreSQL锁释放是放在事务结束的时候统一释放的. 当然这样做有弊端也有好处, 包括可以回滚DDL在内是它的好处之一.</div>问题的关键点, 这也是PostgreSQL 与其他数据库不一样的地方. :&nbsp;<div>1. 事务中的 PostgreSQL 隐性锁<span style="line-height: 22px;"  >AccessShareLock</span>不会在SQL结束后释放, 要等到事务结束后释放.</div><div>2. 等待中的锁也会和后来请求的锁发生冲突, 看起来像个锁队列.</div><br><div>下面在Oracle中模拟一下,</div><div>第一种情况在Oracle中不存在 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >SESSION 1 :&nbsp;</font></div><div><div><font size="2"  >SQL&gt; select * from test;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ID</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2</font></div></div><div><font size="2"  ><br></font></div><div><font size="2"  >SESSION 2 :&nbsp;</font></div><div><div><font size="2"  >SQL&gt; alter table test add c1 int;</font></div><div><font size="2"  >Table altered.</font></div></div><div><font size="2"  >(无需等待)</font></div><p></p></pre></div><div><br></div><div>第二种情况在Oracle中不存在 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >SESSION 1 :&nbsp;</font></div><div><div><font size="2"  >SQL&gt; select * from test where id=1 for update;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ID &nbsp; &nbsp; &nbsp; &nbsp; C1</font></div><div><font size="2"  >---------- ----------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div></div><div><font size="2"  ><br></font></div><div><font size="2"  >SESSION 2 :&nbsp;</font></div><div><div><font size="2"  >SQL&gt; alter table test add c2 int;</font></div><div><font size="2"  >alter table test add c2 int</font></div><div><font size="2"  >*</font></div><div><font size="2"  >ERROR at line 1:</font></div><div><font size="2"  >ORA-00054: resource busy and acquire with NOWAIT specified</font></div></div><div><font size="2"  >(SESSION 2将直接返回资源繁忙的错误.)</font></div><p></p></pre></div></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">Cutis_Dow - 2015-04-15 19:57:05</h5>
				<div>pg锁的第一个问题：select 后无法释放<span style=""  >AccessShareLock 能否 在select 后加 nolock 或者commit?</span><div><span style=""  ><br></span></div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 Cutis_Dow - 2015-04-15 19:57:05</h5>
				<div style="width:600px;">任何显锁都是在事务结束释放的, 只要锁了就要等到事务结束.</div>
			</div>
			<div id="">
				<h5 id="">francs - 2012-07-24 15:50:18</h5>
				<div>”idle in transaction“ 说明程序没提交也没回滚，如果程序有很多&quot;idle in transaction&quot;的进程，显然是不合理的，占有的资料没有释放。</div>
			</div>
	</div>
</div>
</body>
</html>