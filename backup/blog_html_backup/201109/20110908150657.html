<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">key size limited with PostgreSQL btree index access method</h2>
	<h5 id="">2011-09-08 15:06:57&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020118805051532/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>今天在看mongoDB的文档时发现mongoDB对索引列的SIZE也有限制。如下</div><div><span style="font-family: helvetica, arial, sans-serif; font-size: 13px; line-height: 17px; background-color: rgb(243, 244, 235);"  ><h5 style="margin-top: 12px; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px; line-height: normal; font-weight: bold; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; font-size: 11pt; color: rgb(0, 51, 102); text-decoration: none !important;"  >Keys Too Large To Index</h5><p style="margin-top: 0px; font-size: 10pt; line-height: 13pt; color: rgb(76, 58, 44) !important; text-decoration: none !important; max-width: 800px;"  >Index entries have a limitation on their maximum size (the sum of the values), currently approximately 800 bytes. Documents which fields have values (key size in index terminology) greater than this size can not be indexed. You will see log messages similar to:</p><div style="margin-top: 10px; margin-right: 20px; margin-bottom: 10px; margin-left: 20px; color: black; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: rgb(255, 255, 255); border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-top-style: dashed; border-right-style: dashed; border-bottom-style: dashed; border-left-style: dashed; overflow-x: auto; overflow-y: auto; border-top-color: rgb(102, 153, 204); border-right-color: rgb(102, 153, 204); border-bottom-color: rgb(102, 153, 204); border-left-color: rgb(102, 153, 204); background-position: initial initial; background-repeat: initial initial;"  ><div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); padding-top: 0px; padding-right: 12px; padding-bottom: 0px; padding-left: 12px; text-align: left; font-size: 0.95em; background-position: initial initial; background-repeat: initial initial;"  ><pre style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: left; overflow-x: auto; overflow-y: auto; white-space: pre-wrap; font-family: 'Courier New', Courier, monospace; line-height: 1.3;"  >...Btree::insert: key too large to index, skipping...</pre></div></div><p style="margin-top: 0px; font-size: 10pt; line-height: 13pt; color: rgb(76, 58, 44) !important; text-decoration: none !important; max-width: 800px;"  >Queries against this index will not return the unindexed documents. You can force a query to use another index, or really no index, using this special index hint:</p><div style="margin-top: 10px; margin-right: 20px; margin-bottom: 10px; margin-left: 20px; color: black; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: rgb(255, 255, 255); border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-top-style: dashed; border-right-style: dashed; border-bottom-style: dashed; border-left-style: dashed; overflow-x: auto; overflow-y: auto; border-top-color: rgb(102, 153, 204); border-right-color: rgb(102, 153, 204); border-bottom-color: rgb(102, 153, 204); border-left-color: rgb(102, 153, 204); background-position: initial initial; background-repeat: initial initial;"  ><div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); padding-top: 0px; padding-right: 12px; padding-bottom: 0px; padding-left: 12px; text-align: left; font-size: 0.95em; background-position: initial initial; background-repeat: initial initial;"  ><pre style="margin-top: 10px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: left; overflow-x: auto; overflow-y: auto; white-space: pre-wrap; font-family: 'Courier New', Courier, monospace; line-height: 1.3;"  >db.myCollection.find({&lt;key&gt;: &lt;value too large to index&gt;}).hint({$natural: 1})</pre></div></div><p style="margin-top: 0px; font-size: 10pt; line-height: 13pt; color: rgb(76, 58, 44) !important; text-decoration: none !important; max-width: 800px;"  >This will cause the document to be used for comparison of that field (or fields), rather than the index.</p><div style="margin-top: 10px; margin-right: 20px; margin-bottom: 10px; margin-left: 20px; overflow-x: hidden; overflow-y: hidden;"  ><table style="margin-top: 0px; margin-right: 0px; margin-bottom: 1em; margin-left: 0px; font-size: 10pt; line-height: 13pt; color: rgb(0, 0, 0); clear: left; background-color: rgb(255, 255, 206); text-align: left; padding-top: 0px; padding-right: 20px; padding-bottom: 0px; padding-left: 20px; width: 715px;"  ><colgroup style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px;"  ><col width="24"  style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px;"  ><col style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px;"  ><tbody style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px;"  ><tr style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-size: 10pt; line-height: 13pt; color: rgb(0, 0, 0);"  ><td valign="top"  style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-size: 1em; color: rgb(0, 0, 0); padding-top: 14px; padding-right: 0px; padding-bottom: 14px; padding-left: 0px; border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial;"  >NOTE:&nbsp;</td><td style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font-size: 1em; line-height: 13pt; color: rgb(0, 0, 0); padding-top: 14px; padding-right: 0px; padding-bottom: 14px; padding-left: 0px; border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial;"  >This limitation will eventually be removed (see&nbsp;<a style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; text-decoration: none; color: rgb(0, 51, 102); " rel="nofollow" href="http://jira.mongodb.org/browse/SERVER-3372"  >SERVER-3372&nbsp;</a>).</td></tr></table></div></span></div><div>虽然size &gt; 800 bytes不会被索引，但是能被插进去。这和PostgreSQL有所不同，PostgreSQL不能被索引的话记录是不能被插进表去的。</div><div>下面分几个方面来测试一下PostgreSQL的索引SIZE限制.</div><div>引用源码里面的一段btree相关comment :&nbsp;</div><div><div># src/backend/access/nbtree/nbtinsert.c&nbsp;&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check whether the item can fit on a btree page at all. (Eventually, we</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ought to try to apply TOAST methods if not.) We actually need to be</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* able to fit three items on every page, so restrict any one item to 1/3</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the per-page available space. Note that at this point, itupsz doesn't</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* include the ItemId.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* NOTE: similar code appears in _bt_insertonpg() to defend against</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* oversize items being inserted into an already-existing index. But</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* during creation of an index, we don't go through there.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (itupsz &gt; BTMaxItemSize(npage))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errmsg("index row size %lu exceeds maximum %lu for index \"%s\"",</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(unsigned long) itupsz,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(unsigned long) BTMaxItemSize(npage),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RelationGetRelationName(wstate-&gt;index)),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errhint("Values larger than 1/3 of a buffer page cannot be indexed.\n"</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "Consider a function index of an MD5 hash of the value, "</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "or use full text indexing.")));</font></div><p></p></pre></div></div><div><div><br></div><div># include/access/nbtree.h&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Maximum size of a btree index entry, including its tuple header.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* We actually need to be able to fit three items on every page,</font></div><div><font size="2"  >&nbsp;* so restrict any one item to 1/3 the per-page available space.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >#define BTMaxItemSize(page) \</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN_DOWN((PageGetPageSize(page) - \</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MAXALIGN(SizeOfPageHeaderData + 3*sizeof(ItemIdData)) - \</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MAXALIGN(sizeof(BTPageOpaqueData))) / 3)</font></div><p></p></pre></div></div><div>从上面的代码和解释大概可以看出索引KEY的SIZE需要受到PAGE SIZE的限制，计算方法如上。</div><div><br></div><div>限制和索引access method有关，下面着重测试btree索引的限制.</div><div>测试表结构:</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# \d index_test&nbsp;</font></div><div><font size="2"  >&nbsp;Table "public.index_test"</font></div><div><font size="2"  >&nbsp;Column | Type | Modifiers&nbsp;</font></div><div><font size="2"  >--------+------+-----------</font></div><div><font size="2"  >&nbsp;info &nbsp; | text |&nbsp;</font></div><p></p></pre></div><div><br></div><div>测试环境:</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >PostgreSQL9.1beta2</font></div><div><font size="2"  >RHEL5 64位</font></div><div><font size="2"  >UTF8字符集</font></div><div><font size="2"  >BLOCK=8KB</font></div><p></p></pre></div><div><br></div><div>测试项 :&nbsp;</div><div>1. 索引方法</div><div><pre class="prettyprint"  ><p><font size="2"  >btree , hash</font></p></pre></div><div><br></div><div>2. 字段存储类型,以下4种存储类型的解释可以参考我之前写过的BLOG或者PostgreSQL手册.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >plain</font></div><div><font size="2"  >main</font></div><div><font size="2"  >external 不压缩,直接存到TOAST。</font></div><div><font size="2"  >extended 先压缩,大于1/3则完全存储到TOAST,否则存储到HEAP表本地。</font></div><p></p></pre></div><div><br></div><div>3. 数据量</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >index_key &lt; 1/3BLOCK_SIZE</font></div><div><font size="2"  >1/3BLOCK_SIZE &lt; index_key &lt; BLOCK_SIZE</font></div><div><font size="2"  >index_key &gt; BLOCK_SIZE</font></div><p></p></pre></div><div><br></div><div>4. 混合测试</div><div>目的,</div><div>1. 索引建立时是否有个标记来记录KEY的存储类型的。</div><div>2. 索引存储的值是和表一致？或是根据索引记录的存储类型来压缩？</div><div><br></div><div>下面开始正式的测试过程。</div><div>text 类型默认是extended 格式存储,如下</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# \d+ index_test&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Table "public.index_test"</font></div><div><font size="2"  >&nbsp;Column | Type | Modifiers | Storage &nbsp;| Description&nbsp;</font></div><div><font size="2"  >--------+------+-----------+----------+-------------</font></div><div><font size="2"  >&nbsp;info &nbsp; | text | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | extended |&nbsp;</font></div><p></p></pre></div><div>先测试plain,因此要改一下,为了测试比较清晰,先清数据,</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=# truncate table index_test ;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div></div><div><div><font size="2"  >digoal=# alter table index_test alter column info set storage plain;</font></div><div><font size="2"  >ALTER TABLE</font></div></div><div><div><font size="2"  >digoal=# \d+ index_test&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Table "public.index_test"</font></div><div><font size="2"  >&nbsp;Column | Type | Modifiers | Storage | Description&nbsp;</font></div><div><font size="2"  >--------+------+-----------+---------+-------------</font></div><div><font size="2"  >&nbsp;info &nbsp; | text | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | plain &nbsp; |&nbsp;</font></div><div><font size="2"  >Has OIDs: no</font></div></div><p></p></pre></div><div>现在就是plain存储了.</div><div>暂时不往里面建索引，试试插入几条和前面数据量匹配的数据。</div><div>2000个中文字.</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_2000';</font></div><div><font size="2"  >COPY 1</font></div><p></p></pre></div><div>5000个中文字.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_5000';</font></div><div><font size="2"  >ERROR: &nbsp;row is too big: size 15032, maximum size 8160</font></div><div><font size="2"  >CONTEXT: &nbsp;COPY index_test, line 1: "索引测试索引测试索引测试索引测试索引测试索引测试索引测试索引测试索..."</font></div><p></p></pre></div><div>10000个中文字.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_10000';</font></div><div><font size="2"  >ERROR: &nbsp;row is too big: size 30032, maximum size 8160</font></div><div><font size="2"  >CONTEXT: &nbsp;COPY index_test, line 1: "索引测试索引测试索引测试索引测试索引测试索引测试索引测试索引测试索..."</font></div><p></p></pre></div></div><div>显然，PLAIN存储不能存储超过8160个字节（这里测试的是8KB的BLOCK）</div><div><br></div><div>下面修改为main测试</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# truncate table index_test ;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><font size="2"  >digoal=# alter table index_test alter column info set storage main;</font></div><div><font size="2"  >ALTER TABLE</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_2000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_5000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_10000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# select pg_column_size(info) from index_test ;</font></div><div><font size="2"  >&nbsp;pg_column_size&nbsp;</font></div><div><font size="2"  >----------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;91</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 194</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 366</font></div><div><font size="2"  >(3 rows)</font></div><p></p></pre></div><div>数据压缩后可以插入.</div><div><br></div><div>下面修改为external测试</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# truncate table index_test ;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><font size="2"  >digoal=# alter table index_test alter column info set storage external;</font></div><div><font size="2"  >ALTER TABLE</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_2000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_5000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_10000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# select pg_column_size(info) from index_test ;</font></div><div><font size="2"  >&nbsp;pg_column_size&nbsp;</font></div><div><font size="2"  >----------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6000</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 15000</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 30000</font></div><div><font size="2"  >(3 rows)</font></div><p></p></pre></div><div>注意到数据插入到TOAST表了, 因此HEAP表只用到了一个PAGE 8KB , HEAP表里面该列的位置存放的是一个指向TOAST表的对象。</div><div>TOAST的内部结构可以参考源码或者我之前写过一篇关于TOAST的BLOG。</div><div>另外需要注意的是，即使有多个列是extended存储的，也都存储到一个TOAST表里面。</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=# select pg_relation_size('index_test');</font></div><div><font size="2"  >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8192</font></div><div><font size="2"  >(1 row)</font></div></div><div><div><font size="2"  >digoal=# select relname from pg_class where oid in (select reltoastrelid from pg_class where relname='index_test');</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;relname &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp;pg_toast_2129400</font></div><div><font size="2"  >(1 row)</font></div></div><div><div><font size="2"  >digoal=# alter table index_test add column info1 text;</font></div><div><font size="2"  >ALTER TABLE</font></div></div><div><div><font size="2"  >digoal=# insert into index_test (info1) select info from index_test ;</font></div><div><font size="2"  >INSERT 0 10240</font></div></div><div><div style="line-height: 22px;"  ><font size="2"  >digoal=# select relname from pg_class where oid in (select reltoastrelid from pg_class where relname='index_test');</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp;relname &nbsp; &nbsp; &nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  >------------------</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp;pg_toast_2129400</font></div><div style="line-height: 22px;"  ><font size="2"  >(1 row)</font></div></div><p></p></pre></div><div><div><br></div></div><div>下面修改为extended测试</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=# alter table index_test alter column info set storage extended;</font></div><div><font size="2"  >ALTER TABLE</font></div></div><div><div><font size="2"  >digoal=# truncate table index_test ;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div></div><div><font size="2"  >插入5W中文字</font></div><div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/compress_2000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >插入15W中文字</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/compress_5000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >插入30W中文字</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/compress_10000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# select pg_column_size(info),octet_length(info)/3 from index_test ;</font></div><div><font size="2"  >&nbsp;pg_column_size | ?column?&nbsp;</font></div><div><font size="2"  >----------------+----------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1741 | &nbsp; &nbsp;50000 &nbsp;(完全存储在heap 表)&nbsp;注意没有超出1/3PAGE的大小.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5171 | &nbsp; 150000&nbsp;(完全存储在TOAST 表)&nbsp;注意已经超出1/3PAGE的大小.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10321 | &nbsp; 300000&nbsp;(完全存储在TOAST 表) 注意已经超出一个PAGE的大小.</font></div><div><font size="2"  >(3 rows)</font></div></div><p></p></pre></div><div>如下:</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# truncate table index_test ;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/compress_2000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# select pg_column_size(info),octet_length(info)/3 from index_test ;</font></div><div><font size="2"  >&nbsp;pg_column_size | ?column?&nbsp;</font></div><div><font size="2"  >----------------+----------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1741 | &nbsp; &nbsp;50000</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 2</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 4</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 8</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 16</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 32</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 64</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 128</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 256</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 512</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 1024</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 2048</font></div><div><font size="2"  >digoal=# select pg_relation_size('index_test');</font></div><div><font size="2"  >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8388608</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=# select pg_total_relation_size('index_test');</font></div><div><font size="2"  >&nbsp;pg_total_relation_size&nbsp;</font></div><div><font size="2"  >------------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8421376</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=# truncate table index_test ;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/compress_5000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 2</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 4</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 8</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 16</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 32</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 64</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 128</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 256</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 512</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 1024</font></div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 2048</font></div><div><font size="2"  >digoal=# select pg_relation_size('index_test');</font></div><div><font size="2"  >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;221184</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=# select pg_total_relation_size('index_test');</font></div><div><font size="2"  >&nbsp;pg_total_relation_size&nbsp;</font></div><div><font size="2"  >------------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24535040</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div>接下来要测试索引了:</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# truncate table index_test ;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><font size="2"  >digoal=# alter table index_test alter column info set storage plain;</font></div><div><font size="2"  >ALTER TABLE</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_2000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# create index idx_test on index_test using btree (info);</font></div><div><font size="2"  >ERROR: &nbsp;index row size 6016 exceeds maximum 2712 for index "idx_test"</font></div><div><font size="2"  >HINT: &nbsp;Values larger than 1/3 of a buffer page cannot be indexed.</font></div><div><font size="2"  >Consider a function index of an MD5 hash of the value, or use full text indexing.</font></div><div><font size="2"  >digoal=# select pg_column_size(info) from index_test ;</font></div><div><font size="2"  >&nbsp;pg_column_size&nbsp;</font></div><div><font size="2"  >----------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6004</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>未压缩存储2000个中文字加上列的头部信息需要6004字节，超出索引了。下面把存储改为MAIN的存储。</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# alter table index_test alter column info set storage main;</font></div><div><font size="2"  >ALTER TABLE</font></div><p></p></pre></div><div>注意，修改只对修改之后插入的数据生效，以前的数据不会变化。占用空间还是6004字节。</div><div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >digoal=# select pg_column_size(info) from index_test ;</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp;pg_column_size&nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  >----------------</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6004</font></div><div style="line-height: 22px;"  ><font size="2"  >(1 row)</font></div><p></p></pre></div></div><div style="line-height: 22px;"  >但是，索引可以建立了。说明建立索引时需要读取表字段的存储格式，并且按照这个存储格式来存储到索引里面,所以第一条记录6004字节在索引里面会被压缩,而不是原样复制。</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# create index idx_test on index_test using btree (info);</font></div><div><font size="2"  >CREATE INDEX</font></div><p></p></pre></div></div><div>再插入同样的数据，压缩后只有91字节。</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_2000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# select pg_column_size(info) from index_test ;</font></div><div><font size="2"  >&nbsp;pg_column_size&nbsp;</font></div><div><font size="2"  >----------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6004</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;91</font></div><div><font size="2"  >(2 rows)</font></div><p></p></pre></div><div><div style="line-height: 22px;"  ><br></div></div><div>而且索引的存储格式一旦索引建立以后就不会变更了，即使表的变更了。索引的也不会变更。来看如下例子.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# TRUNCATE table index_test ;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><font size="2"  >digoal=# drop index idx_test ;</font></div><div><font size="2"  >DROP INDEX</font></div><div><font size="2"  >digoal=# alter table index_test alter column info set storage plain;</font></div><div><font size="2"  >ALTER TABLE</font></div><div><font size="2"  >digoal=# create index idx_test on index_test using btree (info);</font></div><div><font size="2"  >CREATE INDEX</font></div><p></p></pre></div><div>这里建立的索引使用的存储格式是PLAIN。</div><div>然后我把表的存储格式变成main.然后插入2000个中文字看看什么情况？</div><div><p></p><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=# alter table index_test alter column info set storage main;</font></div><div><font size="2"  >ALTER TABLE</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_2000';</font></div><div><font size="2"  >ERROR: &nbsp;index row size 6016 exceeds maximum 2712 for index "idx_test"</font></div><div><font size="2"  >HINT: &nbsp;Values larger than 1/3 of a buffer page cannot be indexed.</font></div><div><font size="2"  >Consider a function index of an MD5 hash of the value, or use full text indexing.</font></div><p></p></div><div><font size="2"  >CONTEXT: &nbsp;COPY index_test, line 1: "索引测试索引测试索引测试索引测试索引测试索引测试索引测试索引测试索..."</font></div><p></p></pre></div></div><div>这里报错了，报的是索引的错误。正好说明即使被索引的字段的存储方式变更了。索引的也不会变更。</div><div>为什么会这样设计，其实是可以改进的。</div><div><br></div><div>接下来看看索引会不会使用TOAST表,答案是9.1beta2这个版本不使用，如下.</div><div>9.2不存在这个问题 .&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# drop index idx_test;</font></div><div><font size="2"  >DROP INDEX</font></div><div><font size="2"  >digoal=# TRUNCATE table index_test ;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><font size="2"  >digoal=# alter table index_test alter column info set storage external;</font></div><div><font size="2"  >ALTER TABLE</font></div><div><font size="2"  >digoal=# create index idx_test on index_test using btree (info);</font></div><div><font size="2"  >CREATE INDEX</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_2000';</font></div><div><font size="2"  >ERROR: &nbsp;index row size 6016 exceeds maximum 2712 for index "idx_test"</font></div><div><font size="2"  >HINT: &nbsp;Values larger than 1/3 of a buffer page cannot be indexed.</font></div><div><font size="2"  >Consider a function index of an MD5 hash of the value, or use full text indexing.</font></div><div><font size="2"  >CONTEXT: &nbsp;COPY index_test, line 1: "索引测试索引测试索引测试索引测试索引测试索引测试索引测试索引测试索..."</font></div><p></p></pre></div><div><pre class="prettyprint"  ><div><font size="2"  >digoal=# drop index idx_test;</font></div><div><font size="2"  >DROP INDEX</font></div><div><font size="2"  >digoal=# alter table index_test alter column info set storage extended;</font></div><div><font size="2"  >ALTER TABLE</font></div><div><font size="2"  >digoal=# create index idx_test on index_test using btree (info);</font></div><div><font size="2"  >CREATE INDEX</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/uncompress_2000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/compress_2000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/compress_5000';</font></div><div><font size="2"  >ERROR: &nbsp;index row size 5184 exceeds maximum 2712 for index "idx_test"</font></div><div><font size="2"  >HINT: &nbsp;Values larger than 1/3 of a buffer page cannot be indexed.</font></div><div><font size="2"  >Consider a function index of an MD5 hash of the value, or use full text indexing.</font></div><div><font size="2"  >CONTEXT: &nbsp;COPY index_test, line 1: "索引测试索引测试索引测试索引测试索引测试索引测试索引测试索引测试索..."</font></div><p></p></pre></div><div>显然索引是没有使用TOAST的，因为代码里有这段话,可能以后会尝试TOAST.</div><div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check whether the item can fit on a btree page at all. (Eventually, we</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ought to try to apply TOAST methods if not.) We actually need to be</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* able to fit three items on every page, so restrict any one item to 1/3</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the per-page available space. Note that at this point, itupsz doesn't</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* include the ItemId.</font></div><p></p></pre></div></div><div>最后来一个HASH的索引。</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=# drop index idx_test ;</font></div></div><div><div><font size="2"  >DROP INDEX</font></div><div><font size="2"  >digoal=# create index idx_test on index_test using hash (info);</font></div><div><font size="2"  >CREATE INDEX</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/compress_5000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# copy index_test from '/home/postgres/index_test/compress_10000';</font></div><div><font size="2"  >COPY 1</font></div><div><font size="2"  >digoal=# select pg_column_size(info),octet_length(info) from index_test ;</font></div><div><font size="2"  >&nbsp;pg_column_size | octet_length&nbsp;</font></div><div><font size="2"  >----------------+--------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;91 | &nbsp; &nbsp; &nbsp; &nbsp; 6000</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1741 | &nbsp; &nbsp; &nbsp; 150000</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5171 | &nbsp; &nbsp; &nbsp; 450000</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10321 | &nbsp; &nbsp; &nbsp; 900000</font></div><div><font size="2"  >(4 rows)</font></div></div><p></p></pre></div><div>压缩后10321字节的字段允许存储，但是不要被这个误导，因为HASH索引里面存储的不是字段内容。</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=# insert into index_test select * from index_test ;</font></div><div><font size="2"  >INSERT 0 2560</font></div></div><div><div><font size="2"  >digoal=# select pg_total_relation_size('index_test'::regclass);</font></div><div><font size="2"  >&nbsp;pg_total_relation_size&nbsp;</font></div><div><font size="2"  >------------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;64389120</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=# select pg_relation_size('index_test'::regclass);</font></div><div><font size="2"  >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;270336</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=# select pg_relation_size('idx_test'::regclass);</font></div><div><font size="2"  >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"  >------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;442368</font></div><div><font size="2"  >(1 row)</font></div></div><div><div><font size="2"  >digoal=# select count(*) from index_test ;</font></div><div><font size="2"  >&nbsp;count&nbsp;</font></div><div><font size="2"  >-------</font></div><div><font size="2"  >&nbsp; 5120</font></div><div><font size="2"  >(1 row)</font></div></div><p></p></pre></div><div>5120条记录，64M内容，HASH索引只用了400多KB（和字段内容有关系,因为我这里用的是4个中文字重复几千次）。</div><div><br></div><div>另一个与btree索引不同的是,虽然主表是extended存储的,但是HASH索引是plain存储的.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# \d+ idx_test&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index "public.idx_test"</font></div><div><font size="2"  >&nbsp;Column | &nbsp;Type &nbsp; | Definition | Storage | Description&nbsp;</font></div><div><font size="2"  >--------+---------+------------+---------+-------------</font></div><div><font size="2"  >&nbsp;info &nbsp; | integer | info &nbsp; &nbsp; &nbsp; | plain &nbsp; |&nbsp;</font></div><div><font size="2"  >hash, for table "public.index_test"</font></div><p></p></pre></div><div><br></div><div>【参考】</div><wbr><div>1.&nbsp;<a rel="nofollow" href="http://www.postgresql.org/docs/9.1/static/indexes-types.html"  >http://www.postgresql.org/docs/9.1/static/indexes-types.html</a></div><div>2. src/backend/access/common/indextuple.c</div><div>3. src/backend/access/nbtree/nbtinsert.c</div><div>4. src/backend/access/nbtree/nbtsort.c</div><div>5. src/backend/access/hash,gin,gist....</div><div>6. 修改TOAST阈值</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020130108132117/"  >http://blog.163.com/digoal@126/blog/static/16387704020130108132117/</a></div></div>
	</div>
</div>
</body>
</html>