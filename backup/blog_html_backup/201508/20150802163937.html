<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL How to get upstream node conninfo from standby node</h2>
	<h5 id="">2015-08-02 16:39:37&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020157243937165/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>在PostgreSQL的upstream节点可以获得downstream节点的连接信息，当downstream节点主动连接upstream节点时，在upstream节点会有一个sender process负责发送XLOG信息，而这个sender进程其实就是backend process，在pg_stat_activity中可以查看。</div><div>pg_stat_replication的视图定义如下：</div><div>postgres=# \x</div><div>Expanded display is on.</div><div>postgres=# select pg_get_viewdef('pg_stat_replication');</div><div>-[ RECORD 1 ]--+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>pg_get_viewdef | &nbsp;SELECT s.pid,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; s.usesysid,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; u.rolname AS usename,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; s.application_name,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; s.client_addr,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; s.client_hostname,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; s.client_port,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; s.backend_start,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; s.backend_xmin,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; w.state,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; w.sent_location,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; w.write_location,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; w.flush_location,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; w.replay_location,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; w.sync_priority,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; w.sync_state</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp;FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, waiting, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; pg_authid u,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; pg_stat_get_wal_senders() w(pid, state, sent_location, write_location, flush_location, replay_location, sync_priority, sync_state)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; WHERE ((s.usesysid = u.oid) AND (s.pid = w.pid));</div><div><br></div><div>可以看出这里用到了pg_stat_get_activity来获得sender进程的信息，包含了client_addr。</div><div>pg_stat_get_wal_senders则是用来获取sender进程的PID的，当然这里还包含了由downstream节点的walreceiver进程发送过来的wal sent,write,flush,replay的位置以及其他信息等。</div><div><br></div><div>好了，那么downstream节点如何获取upstream节点的连接信息呢？</div><div>因为downstream节点在pg_stat_activity中没有walreceiver进程的信息，所以需要其他方法来获取upstream节点的信息。</div><div>其中一种方法是直接从walreceiver的共享内存中获取。既然downstream节点要连接upstream节点，它必然需要连接信息，这个连接信息存储在downstream节点的$PGDATA/recovery.conf文件中，数据库启动时startup进程会从这个文件中解析到primary_conninfo。</div><div><br></div><div>首先分析walreceiver进程，它实际上是一个动态的加载模块，如果在recovery.conf中配置了primary_conninfo, startup进程会唤醒它。</div><div>startup进程同时需要从recover.conf中读取primary_conninfo的信息，存储在WalRcvData结构中。</div><div>如下：</div><div>src/include/replication/walreceiver.h</div><div>/*</div><div>&nbsp;* MAXCONNINFO: maximum size of a connection string.</div><div>&nbsp;*</div><div>&nbsp;* XXX: Should this move to pg_config_manual.h?</div><div>&nbsp;*/</div><div>#define MAXCONNINFO &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1024</div><div><br></div><div>/* Shared memory area for management of walreceiver process */</div><div>typedef struct</div><div>{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* PID of currently active walreceiver process, its current state and</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* start time (actually, the time at which it was requested to be</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* started).</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; pid_t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; WalRcvState walRcvState;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; pg_time_t &nbsp; &nbsp; &nbsp; startTime;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* receiveStart and receiveStartTLI indicate the first byte position and</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* timeline that will be received. When startup process starts the</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* walreceiver, it sets these to the point where it wants the streaming to</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* begin.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;receiveStart;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID &nbsp; &nbsp; &nbsp;receiveStartTLI;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* receivedUpto-1 is the last byte position that has already been</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* received, and receivedTLI is the timeline it came from. &nbsp;At the first</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* startup of walreceiver, these are set to receiveStart and</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* receiveStartTLI. After that, walreceiver updates these whenever it</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* flushes the received WAL to disk.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;receivedUpto;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID &nbsp; &nbsp; &nbsp;receivedTLI;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* latestChunkStart is the starting byte position of the current "batch"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* of received WAL. &nbsp;It's actually the same as the previous value of</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* receivedUpto before the last flush to disk. &nbsp;Startup process can use</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* this to detect whether it's keeping up or not.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;latestChunkStart;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Time of send and receive of any message received.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz lastMsgSendTime;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz lastMsgReceiptTime;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Latest reported end of WAL on the sender</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;latestWalEnd;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz latestWalEndTime;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* connection string; is used for walreceiver to connect with the primary.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;conninfo[MAXCONNINFO];</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* replication slot name; is also used for walreceiver to connect with the</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* primary</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;slotname[NAMEDATALEN];</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; slock_t &nbsp; &nbsp; &nbsp; &nbsp; mutex; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* locks shared variables shown above */</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Latch used by startup process to wake up walreceiver after telling it</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* where to start streaming (after setting receiveStart and</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* receiveStartTLI).</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Latch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latch;</div><div>} WalRcvData;</div><div>extern WalRcvData *WalRcv;</div><div><br></div><div>hook如下：</div><div>......</div><div>/* libpqwalreceiver hooks */</div><div>typedef void (*walrcv_connect_type) (char *conninfo);</div><div>extern PGDLLIMPORT walrcv_connect_type walrcv_connect;</div><div><br></div><div>typedef void (*walrcv_identify_system_type) (TimeLineID *primary_tli);</div><div>extern PGDLLIMPORT walrcv_identify_system_type walrcv_identify_system;</div><div><br></div><div>typedef void (*walrcv_readtimelinehistoryfile_type) (TimeLineID tli, char **filename, char **content, int *size);</div><div>extern PGDLLIMPORT walrcv_readtimelinehistoryfile_type walrcv_readtimelinehistoryfile;</div><div><br></div><div>typedef bool (*walrcv_startstreaming_type) (TimeLineID tli, XLogRecPtr startpoint, char *slotname);</div><div>extern PGDLLIMPORT walrcv_startstreaming_type walrcv_startstreaming;</div><div><br></div><div>typedef void (*walrcv_endstreaming_type) (TimeLineID *next_tli);</div><div>extern PGDLLIMPORT walrcv_endstreaming_type walrcv_endstreaming;</div><div><br></div><div>typedef int (*walrcv_receive_type) (int timeout, char **buffer);</div><div>extern PGDLLIMPORT walrcv_receive_type walrcv_receive;</div><div><br></div><div>typedef void (*walrcv_send_type) (const char *buffer, int nbytes);</div><div>extern PGDLLIMPORT walrcv_send_type walrcv_send;</div><div><br></div><div>typedef void (*walrcv_disconnect_type) (void);</div><div>extern PGDLLIMPORT walrcv_disconnect_type walrcv_disconnect;</div><div><br></div><div>/* prototypes for functions in walreceiver.c */</div><div>extern void WalReceiverMain(void) __attribute__((noreturn));</div><div>......</div><div><br></div><div>walreceiver模块使用WalRcv中的conninfo，连接到upstream节点。</div><div>src/backend/replication/libpqwalreceiver/libpqwalreceiver.c</div><div>/*</div><div>&nbsp;* Module load callback</div><div>&nbsp;*/</div><div>void</div><div>_PG_init(void)</div><div>{</div><div>......</div><div>&nbsp; &nbsp; &nbsp; &nbsp; walrcv_connect = libpqrcv_connect;</div><div>}</div><div><br></div><div>/*</div><div>&nbsp;* Establish the connection to the primary server for XLOG streaming</div><div>&nbsp;*/</div><div>static void</div><div>libpqrcv_connect(char *conninfo)</div><div>{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;conninfo_repl[MAXCONNINFO + 75];</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Connect using deliberately undocumented parameter: replication. The</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* database name is ignored by the server in replication mode, but specify</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* "replication" for .pgpass lookup.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(conninfo_repl, sizeof(conninfo_repl),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"%s dbname=replication replication=true fallback_application_name=walreceiver",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;conninfo);</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; streamConn = PQconnectdb(conninfo_repl);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (PQstatus(streamConn) != CONNECTION_OK)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("could not connect to the primary server: %s",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQerrorMessage(streamConn))));</div><div>}</div><div><br></div><div>src/backend/replication/walreceiver.c</div><div>/* Main entry point for walreceiver process */</div><div>void</div><div>WalReceiverMain(void)</div><div>{</div><div>......</div><div>&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;conninfo[MAXCONNINFO];</div><div>......</div><div>&nbsp; &nbsp; &nbsp; &nbsp; /* use volatile pointer to prevent code rearrangement */</div><div>&nbsp; &nbsp; &nbsp; &nbsp; volatile WalRcvData *walrcv = WalRcv;</div><div>......</div><div>&nbsp; &nbsp; &nbsp; &nbsp; /* Fetch information required to start streaming */</div><div>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy(conninfo, (char *) walrcv-&gt;conninfo, MAXCONNINFO);</div><div>......</div><div>&nbsp; &nbsp; &nbsp; &nbsp; /* Establish the connection to the primary for XLOG streaming */</div><div>&nbsp; &nbsp; &nbsp; &nbsp; EnableWalRcvImmediateExit();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; walrcv_connect(conninfo);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; DisableWalRcvImmediateExit();</div><div>......</div><div>我们可以定义一个函数，来读取WalRcv的信息，即可读取upstream节点的信息：</div><div>[root@digoal ~]# vi get_upstream_conninfo.c&nbsp;</div><div>#include "postgres.h"</div><div>#include &lt;assert.h&gt;</div><div>#include "fmgr.h"</div><div>#include "access/xlog.h"</div><div>#include "replication/walreceiver.h"</div><div>#include "utils/elog.h"</div><div>#include "utils/builtins.h"</div><div><br></div><div>#ifdef PG_MODULE_MAGIC</div><div>PG_MODULE_MAGIC;</div><div>#endif</div><div><br></div><div>PG_FUNCTION_INFO_V1(get_upstream_conninfo);</div><div><br></div><div>Datum</div><div>get_upstream_conninfo(PG_FUNCTION_ARGS)</div><div>{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; assert(PG_NARGS() == 0);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (!RecoveryInProgress())</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("recovery is not in progress"),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("This functions can only be executed during recovery.")));</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; /* use volatile pointer to prevent code rearrangement */</div><div>&nbsp; &nbsp; &nbsp; &nbsp; volatile WalRcvData *walrcv = WalRcv;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(cstring_to_text((char *) walrcv-&gt;conninfo));</div><div>}</div><div>编译：</div><div>[root@digoal ~]# gcc -O3 -Wall -Wextra -Werror -I /opt/soft_bak/postgresql-9.4.4/src/include -g -fPIC -c ./get_upstream_conninfo.c -o digoal.o</div><div>[root@digoal ~]# gcc -O3 -Wall -Wextra -Werror -I /opt/soft_bak/postgresql-9.4.4/src/include -g -shared digoal.o -o libdigoal.so</div><div>拷贝到$PGHOME/lib</div><div>[root@digoal ~]# cp libdigoal.so /opt/pgsql/lib/</div><div>创建函数：</div><div>postgres=# \set VERBOSITY verbose</div><div>postgres=# create or replace function get_upstream_conninfo() returns text as '$libdir/libdigoal.so', 'get_upstream_conninfo' language C STRICT;</div><div>CREATE FUNCTION</div><div><br></div><div>在主库执行直接返回错误即可：</div><div>postgres=# select get_upstream_conninfo();</div><div>ERROR: &nbsp;55000: recovery is not in progress</div><div>HINT: &nbsp;This functions can only be executed during recovery.</div><div>LOCATION: &nbsp;get_upstream_conninfo, get_upstream_conninfo.c:25</div><div>在downstream节点执行，可以获取到upstream节点的信息：</div><div>postgres@digoal-&gt; psql -h 127.0.0.1 -p 1922</div><div>psql (9.4.4)</div><div>Type "help" for help.</div><div>postgres=# \set VERBOSITY verbose</div><div>postgres=# select get_upstream_conninfo();</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;get_upstream_conninfo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div><div>----------------------------------------------------------------</div><div>&nbsp;host=192.168.150.128 port=1921 user=replica keepalives_idle=60</div><div>(1 row)</div><div><br></div><div>还有一种方法是直接读取recover.conf文件来解析连接信息，如下。</div><div>postgres=# select * from regexp_split_to_table(pg_read_file('recovery.conf'),'\n') t(a) where a ~ '^ *primary_conninfo';</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>-----------------------------------------------------------------------------------------------------------------------------------</div><div>&nbsp; &nbsp;primary_conninfo = 'host=192.168.150.128 port=1922 user=replica keepalives_idle=60' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # e.g. 'host=localhost port=5432'</div><div>(1 row)</div><div><br></div><div>[参考]</div><div>1. 解析配置文件的公共函数</div><div>src/backend/utils/misc/guc-file.c</div><div>*</div><div>&nbsp;* Read and parse a single configuration file. &nbsp;This function recurses</div><div>&nbsp;* to handle "include" directives.</div><div>&nbsp;*</div><div>&nbsp;* Input parameters:</div><div>&nbsp;* &nbsp; &nbsp; &nbsp;fp: file pointer from AllocateFile for the configuration file to parse</div><div>&nbsp;* &nbsp; &nbsp; &nbsp;config_file: absolute or relative path name of the configuration file</div><div>&nbsp;* &nbsp; &nbsp; &nbsp;depth: recursion depth (should be 0 in the outermost call)</div><div>&nbsp;* &nbsp; &nbsp; &nbsp;elevel: error logging level to use</div><div>&nbsp;* Output parameters:</div><div>&nbsp;* &nbsp; &nbsp; &nbsp;head_p, tail_p: head and tail of linked list of name/value pairs</div><div>&nbsp;*</div><div>&nbsp;* *head_p and *tail_p must be initialized to NULL before calling the outer</div><div>&nbsp;* recursion level. &nbsp;On exit, they contain a list of name-value pairs read</div><div>&nbsp;* from the input file(s).</div><div>&nbsp;*</div><div>&nbsp;* Returns TRUE if successful, FALSE if an error occurred. &nbsp;The error has</div><div>&nbsp;* already been ereport'd, it is only necessary for the caller to clean up</div><div>&nbsp;* its own state and release the ConfigVariable list.</div><div>&nbsp;*</div><div>&nbsp;* Note: if elevel &gt;= ERROR then an error will not return control to the</div><div>&nbsp;* caller, so there is no need to check the return value in that case.</div><div>&nbsp;*/</div><div>bool</div><div>ParseConfigFp(FILE *fp, const char *config_file, int depth, int elevel,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ConfigVariable **head_p, ConfigVariable **tail_p)</div><div>{</div><div>......</div><div>}</div><div><br></div><div>2. 读取recovery,.conf</div><div>src/backend/access/transam/xlog.c</div><div>#define RECOVERY_COMMAND_FILE &nbsp; "recovery.conf"</div><div><br></div><div>/*</div><div>&nbsp;* See if there is a recovery command file (recovery.conf), and if so</div><div>&nbsp;* read in parameters for archive recovery and XLOG streaming.</div><div>&nbsp;*</div><div>&nbsp;* The file is parsed using the main configuration parser.</div><div>&nbsp;*/</div><div>static void</div><div>readRecoveryCommandFile(void)</div><div>{</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; for (item = head; item; item = item-&gt;next)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (strcmp(item-&gt;name, "restore_command") == 0)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recoveryRestoreCommand = pstrdup(item-&gt;value);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG2,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg_internal("restore_command = '%s'",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;recoveryRestoreCommand)));</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>......</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (strcmp(item-&gt;name, "primary_conninfo") == 0)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PrimaryConnInfo = pstrdup(item-&gt;value);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG2,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg_internal("primary_conninfo = '%s'",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PrimaryConnInfo)));</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>}</div><div>3. 从流复制接收恢复数据库需要的XLOG数据</div><div>src/backend/access/transam/xlog.c</div><div>static bool</div><div>WaitForWALToBecomeAvailable(XLogRecPtr RecPtr, bool randAccess,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool fetching_ckpt, XLogRecPtr tliRecPtr)</div><div>{</div><div>......</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (PrimaryConnInfo)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;ptr;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID &nbsp; &nbsp; &nbsp;tli;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (fetching_ckpt)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = RedoStartLSN;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli = ControlFile-&gt;checkPointCopy.ThisTimeLineID;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = tliRecPtr;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli = tliOfPointInHistory(tliRecPtr, expectedTLEs);</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (curFileTLI &gt; 0 &amp;&amp; tli &lt; curFileTLI)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "according to history file, WAL location %X/%X belongs to timeline %u, but previous recovered WAL file came from timeline %u",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(uint32) (ptr &gt;&gt; 32), (uint32) ptr,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tli, curFileTLI);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curFileTLI = tli;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RequestXLogStreaming(tli, ptr, PrimaryConnInfo,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PrimarySlotName);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; receivedUpto = 0;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br></div><div>Flag Counter</div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL How to get upstream node conninfo from standby node - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>