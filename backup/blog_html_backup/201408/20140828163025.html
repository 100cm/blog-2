<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL bug? function's variable type cached within session.</h2>
	<h5 id="">2014-08-28 16:30:25&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020147284225645/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>我在使用触发器来跟踪表时, 发现一个问题, 也许是一个BUG.&nbsp;</div><div>在函数中使用表类型来作为变量类型的话, 如果这个表的定义发生了改变, 函数内的变量不能及时的反映这个变化, 必须要退出会话重新进入才可以反映这个变化.</div><div>当然这个问题很好解决, 不要在函数中使用表的变量即可.</div><div>(或者你可以选择hstore代替表类型)</div><div>参考 :&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201252575529358/"   >http://blog.163.com/digoal@126/blog/static/163877040201252575529358/</a></div><div><br></div><div>可能是在ALTER TABLE后未及时释放变量造成.</div><div>可参考</div><div>pl/plpgsql/src/pl_funcs.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/**********************************************************************</font></div><div><font size="2"   >&nbsp;* Release memory when a PL/pgSQL function is no longer needed</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The code for recursing through the function tree is really only</font></div><div><font size="2"   >&nbsp;* needed to locate PLpgSQL_expr nodes, which may contain references</font></div><div><font size="2"   >&nbsp;* to saved SPI Plans that must be freed. &nbsp;The function tree itself,</font></div><div><font size="2"   >&nbsp;* along with subsidiary data, is freed in one swoop by freeing the</font></div><div><font size="2"   >&nbsp;* function's permanent memory context.</font></div><div><font size="2"   >&nbsp;**********************************************************************/</font></div><div><font size="2"   >static void free_stmt(PLpgSQL_stmt *stmt);</font></div><div><font size="2"   >static void free_block(PLpgSQL_stmt_block *block);</font></div><div><font size="2"   >static void free_assign(PLpgSQL_stmt_assign *stmt);</font></div><div><font size="2"   >static void free_if(PLpgSQL_stmt_if *stmt);</font></div><div><font size="2"   >static void free_case(PLpgSQL_stmt_case *stmt);</font></div><div><font size="2"   >static void free_loop(PLpgSQL_stmt_loop *stmt);</font></div><div><font size="2"   >static void free_while(PLpgSQL_stmt_while *stmt);</font></div><div><font size="2"   >static void free_fori(PLpgSQL_stmt_fori *stmt);</font></div><div><font size="2"   >static void free_fors(PLpgSQL_stmt_fors *stmt);</font></div><div><font size="2"   >static void free_forc(PLpgSQL_stmt_forc *stmt);</font></div><div><font size="2"   >static void free_foreach_a(PLpgSQL_stmt_foreach_a *stmt);</font></div><div><font size="2"   >static void free_exit(PLpgSQL_stmt_exit *stmt);</font></div><div><font size="2"   >static void free_return(PLpgSQL_stmt_return *stmt);</font></div><div><font size="2"   >static void free_return_next(PLpgSQL_stmt_return_next *stmt);</font></div><div><font size="2"   >static void free_return_query(PLpgSQL_stmt_return_query *stmt);</font></div><div><font size="2"   >static void free_raise(PLpgSQL_stmt_raise *stmt);</font></div><div><font size="2"   >static void free_execsql(PLpgSQL_stmt_execsql *stmt);</font></div><div><font size="2"   >static void free_dynexecute(PLpgSQL_stmt_dynexecute *stmt);</font></div><div><font size="2"   >static void free_dynfors(PLpgSQL_stmt_dynfors *stmt);</font></div><div><font size="2"   >static void free_getdiag(PLpgSQL_stmt_getdiag *stmt);</font></div><div><font size="2"   >static void free_open(PLpgSQL_stmt_open *stmt);</font></div><div><font size="2"   >static void free_fetch(PLpgSQL_stmt_fetch *stmt);</font></div><div><font size="2"   >static void free_close(PLpgSQL_stmt_close *stmt);</font></div><div><font size="2"   >static void free_perform(PLpgSQL_stmt_perform *stmt);</font></div><div><font size="2"   >static void free_expr(PLpgSQL_expr *expr);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >void</font></div><div><font size="2"   >plpgsql_free_function_memory(PLpgSQL_function *func)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Better not call this on an in-use function */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(func-&gt;use_count == 0);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Release plans associated with variable declarations */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; func-&gt;ndatums; i++)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PLpgSQL_datum *d = func-&gt;datums[i];</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switch (d-&gt;dtype)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case PLPGSQL_DTYPE_VAR:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PLpgSQL_var *var = (PLpgSQL_var *) d;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_expr(var-&gt;default_val);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_expr(var-&gt;cursor_explicit_expr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case PLPGSQL_DTYPE_ROW:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case PLPGSQL_DTYPE_REC:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case PLPGSQL_DTYPE_RECFIELD:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case PLPGSQL_DTYPE_ARRAYELEM:</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_expr(((PLpgSQL_arrayelem *) d)-&gt;subscript);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "unrecognized data type: %d", d-&gt;dtype);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; func-&gt;ndatums = 0;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Release plans in statement tree */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (func-&gt;action)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_block(func-&gt;action);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; func-&gt;action = NULL;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* And finally, release all memory except the PLpgSQL_function struct</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* itself (which has to be kept around because there may be multiple</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* fn_extra pointers to it).</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (func-&gt;fn_cxt)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextDelete(func-&gt;fn_cxt);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; func-&gt;fn_cxt = NULL;</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><br></div><div>例子如下 :&nbsp;</div><div>PostgreSQL 9.3.4</div><div>创建一个测试表 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create table public.t (</font></div><div><font size="2"   >&nbsp; c1 int primary key,</font></div><div><font size="2"   >&nbsp; c2 text,</font></div><div><font size="2"   >&nbsp; crt_time timestamp</font></div><div><font size="2"   >);</font></div><p></p></pre></div><div>创建一个跟踪表, 使用表的类型来存储old_rec和new_rec.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE TABLE public.undo_t (</font></div><div><font size="2"   >&nbsp; id serial8 primary key,</font></div><div><font size="2"   >&nbsp; xid int8,</font></div><div><font size="2"   >&nbsp; relid oid,</font></div><div><font size="2"   >&nbsp; table_schema text,</font></div><div><font size="2"   >&nbsp; table_name text,</font></div><div><font size="2"   >&nbsp; when_tg text,</font></div><div><font size="2"   >&nbsp; level text,</font></div><div><font size="2"   >&nbsp; op text,</font></div><div><font size="2"   >&nbsp; encoding name,</font></div><div><font size="2"   >&nbsp; old_rec public.t, &nbsp;</font></div><div><font size="2"   >&nbsp; new_rec public.t, &nbsp;</font></div><div><font size="2"   >&nbsp; crt_time timestamp without time zone DEFAULT now(),</font></div><div><font size="2"   >&nbsp; username text,</font></div><div><font size="2"   >&nbsp; client_addr inet,</font></div><div><font size="2"   >&nbsp; client_port int</font></div><div><font size="2"   >);</font></div><p></p></pre></div><div>创建一个触发器函数, 用于跟踪insert, update, delete, truncate.</div><div>注意declare里面的v_new_rec和v_old_rec, 就是问题所在.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE OR REPLACE FUNCTION public.undo_t_trace()</font></div><div><font size="2"   >RETURNS trigger</font></div><div><font size="2"   >LANGUAGE plpgsql</font></div><div><font size="2"   >AS $BODY$</font></div><div><font size="2"   >DECLARE</font></div><div><font size="2"   >&nbsp; v_new_rec public.t; &nbsp;-- type cached in session, don't modified when table t altered. must reopen an session.</font></div><div><font size="2"   >&nbsp; v_old_rec public.t; &nbsp;-- type cached in session, don't modified when table t altered. must reopen an session.</font></div><div><font size="2"   >&nbsp; v_username text := session_user;</font></div><div><font size="2"   >&nbsp; v_client_addr inet := inet_client_addr();</font></div><div><font size="2"   >&nbsp; v_client_port int := inet_client_port();</font></div><div><font size="2"   >&nbsp; v_xid bigint := txid_current();</font></div><div><font size="2"   >&nbsp; v_encoding name := pg_client_encoding();</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; case TG_OP</font></div><div><font size="2"   >&nbsp; when 'DELETE' then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; v_old_rec := OLD;</font></div><div><font size="2"   >&nbsp; &nbsp; insert into public.undo_t (xid, relid, table_schema, table_name, when_tg, level, op, encoding, old_rec, username, client_addr, client_port)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_xid, tg_relid, tg_table_schema, tg_table_name, tg_when, tg_level, tg_op, v_encoding, v_old_rec, v_username, v_client_addr, v_client_port);</font></div><div><font size="2"   >&nbsp; when 'INSERT' then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%', NEW; &nbsp;-- OK</font></div><div><font size="2"   >&nbsp; &nbsp; v_new_rec := NEW;</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%', v_new_rec; &nbsp;-- use cached type. not OK.</font></div><div><font size="2"   >&nbsp; &nbsp; insert into public.undo_t (xid, relid, table_schema, table_name, when_tg, level, op, encoding, new_rec, username, client_addr, client_port)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_xid, tg_relid, tg_table_schema, tg_table_name, tg_when, tg_level, tg_op, v_encoding, v_new_rec, v_username, v_client_addr, v_client_port);</font></div><div><font size="2"   >&nbsp; when 'UPDATE' then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; v_old_rec := OLD;</font></div><div><font size="2"   >&nbsp; &nbsp; v_new_rec := NEW;</font></div><div><font size="2"   >&nbsp; &nbsp; insert into public.undo_t (xid, relid, table_schema, table_name, when_tg, level, op, encoding, old_rec, new_rec, username, client_addr, client_port)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_xid, tg_relid, tg_table_schema, tg_table_name, tg_when, tg_level, tg_op, v_encoding, v_old_rec, v_new_rec, v_username, v_client_addr, v_client_port);</font></div><div><font size="2"   >&nbsp; &nbsp; when 'TRUNCATE' then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; insert into public.undo_t (xid, relid, table_schema, table_name, when_tg, level, op, encoding, old_rec, username, client_addr, client_port)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; select v_xid, tg_relid, tg_table_schema, tg_table_name, tg_when, tg_level, tg_op, v_encoding, t, v_username, v_client_addr, v_client_port from public.t;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; return null;</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >&nbsp; &nbsp; RETURN null;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$BODY$ strict volatile;</font></div><p></p></pre></div><div>创建触发器 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE TRIGGER tg1 AFTER DELETE or INSERT or UPDATE ON public.t FOR EACH ROW EXECUTE PROCEDURE undo_t_trace();</font></div><div><font size="2"   >CREATE TRIGGER tg2 BEFORE TRUNCATE ON public.t FOR EACH STATEMENT EXECUTE PROCEDURE undo_t_trace();</font></div><p></p></pre></div><div><br></div><div>插入测试数据</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >insert into public.t values (1,'test',now());</font></div><div><font size="2"   >insert into public.t values (2,'test',now());</font></div><p></p></pre></div><div><br></div><div>可以看到跟踪正常</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select * from public.t;</font></div><div><font size="2"   >&nbsp;c1 | &nbsp;c2 &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----+------+----------------------------</font></div><div><font size="2"   >&nbsp; 1 | test | 2014-08-28 16:14:34.548555</font></div><div><font size="2"   >&nbsp; 2 | test | 2014-08-28 16:14:35.194634</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# select new_rec from public.undo_t;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rec &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >---------------------------------------</font></div><div><font size="2"   >&nbsp;(1,test,"2014-08-28 16:14:34.548555")</font></div><div><font size="2"   >&nbsp;(2,test,"2014-08-28 16:14:35.194634")</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div><br></div><div>接下来修改表的定义</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# alter table public.t add column c3 int;</font></div><div><font size="2"   >ALTER TABLE</font></div><p></p></pre></div><div>再次插入数据, 我们发现输出变量存储的NEW和NEW是不一样的, 变量存储的NEW没有新增的列, 而直接输出的NEW有刚刚新增的列.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# insert into public.t values (3,'test',now(),1);</font></div><div><font size="2"   >NOTICE: &nbsp;(3,test,"2014-08-28 16:15:58.394688",1)</font></div><div><font size="2"   >NOTICE: &nbsp;(3,test,"2014-08-28 16:15:58.394688",)</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# select * from public.t;</font></div><div><font size="2"   >&nbsp;c1 | &nbsp;c2 &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| c3&nbsp;</font></div><div><font size="2"   >----+------+----------------------------+----</font></div><div><font size="2"   >&nbsp; 1 | test | 2014-08-28 16:14:34.548555 | &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; 2 | test | 2014-08-28 16:14:35.194634 | &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; 3 | test | 2014-08-28 16:15:58.394688 | &nbsp;1</font></div><div><font size="2"   >(3 rows)</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >跟踪插入的数据并没有新增的列.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select new_rec from public.undo_t;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rec &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------</font></div><div><font size="2"   >&nbsp;(1,test,"2014-08-28 16:14:34.548555",)</font></div><div><font size="2"   >&nbsp;(2,test,"2014-08-28 16:14:35.194634",)</font></div><div><font size="2"   >&nbsp;(3,test,"2014-08-28 16:15:58.394688",)</font></div><div><font size="2"   >(3 rows)</font></div><p></p></pre></div><div><br></div><div>退出会话, 重新进入</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \q</font></div><div><font size="2"   >postgres@192_168_173_203-&gt; psql</font></div><div><font size="2"   >psql (9.3.4)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >postgres=# select new_rec from public.undo_t;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rec &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------</font></div><div><font size="2"   >&nbsp;(1,test,"2014-08-28 16:14:34.548555",)</font></div><div><font size="2"   >&nbsp;(2,test,"2014-08-28 16:14:35.194634",)</font></div><div><font size="2"   >&nbsp;(3,test,"2014-08-28 16:15:58.394688",)</font></div><div><font size="2"   >(3 rows)</font></div><p></p></pre></div><div>再次插入数据, 我们看到新增列时正常. 说明函数刷新了变量的类型.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# insert into public.t values (4,'test',now(),1);</font></div><div><font size="2"   >NOTICE: &nbsp;(4,test,"2014-08-28 16:16:45.857712",1)</font></div><div><font size="2"   >NOTICE: &nbsp;(4,test,"2014-08-28 16:16:45.857712",1)</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# select new_rec from public.undo_t;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new_rec &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------------------------------------</font></div><div><font size="2"   >&nbsp;(1,test,"2014-08-28 16:14:34.548555",)</font></div><div><font size="2"   >&nbsp;(2,test,"2014-08-28 16:14:35.194634",)</font></div><div><font size="2"   >&nbsp;(3,test,"2014-08-28 16:15:58.394688",)</font></div><div><font size="2"   >&nbsp;(4,test,"2014-08-28 16:16:45.857712",1)</font></div><div><font size="2"   >(4 rows)</font></div><p></p></pre></div><div>现在删掉一个列.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# alter table t drop column c2;</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >postgres=# \set VERBOSITY verbose</font></div><p></p></pre></div><div>再次插入, 问题又重现了,&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# insert into public.t values (5,now(),1);</font></div><div><font size="2"   >NOTICE: &nbsp;00000: (5,"2014-08-28 16:17:20.078688",1)</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:3041</font></div><div><font size="2"   >ERROR: &nbsp;22007: invalid input syntax for type timestamp: "1" &nbsp;这个报错出现在 &nbsp;v_new_rec := NEW; &nbsp;因为v_new_rec的类型cache了,&nbsp;</font></div><div><font size="2"   >CONTEXT: &nbsp;PL/pgSQL function undo_t_trace() line 18 at assignment</font></div><div><font size="2"   >LOCATION: &nbsp;DateTimeParseError, datetime.c:3567</font></div><p></p></pre></div><div><br></div><div>现在的解决办法是不使用表变量, 直接使用NEW或OLD.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >CREATE OR REPLACE FUNCTION public.undo_t_trace()</font></div><div><font size="2"   >RETURNS trigger</font></div><div><font size="2"   >LANGUAGE plpgsql</font></div><div><font size="2"   >AS $BODY$</font></div><div><font size="2"   >DECLARE</font></div><div><font size="2"   >&nbsp; v_username text := session_user;</font></div><div><font size="2"   >&nbsp; v_client_addr inet := inet_client_addr();</font></div><div><font size="2"   >&nbsp; v_client_port int := inet_client_port();</font></div><div><font size="2"   >&nbsp; v_xid bigint := txid_current();</font></div><div><font size="2"   >&nbsp; v_encoding name := pg_client_encoding();</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; case TG_OP</font></div><div><font size="2"   >&nbsp; when 'DELETE' then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; insert into public.undo_t (xid, relid, table_schema, table_name, when_tg, level, op, encoding, old_rec, username, client_addr, client_port)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_xid, tg_relid, tg_table_schema, tg_table_name, tg_when, tg_level, tg_op, v_encoding, OLD, v_username, v_client_addr, v_client_port);</font></div><div><font size="2"   >&nbsp; when 'INSERT' then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; insert into public.undo_t (xid, relid, table_schema, table_name, when_tg, level, op, encoding, new_rec, username, client_addr, client_port)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_xid, tg_relid, tg_table_schema, tg_table_name, tg_when, tg_level, tg_op, v_encoding, NEW, v_username, v_client_addr, v_client_port);</font></div><div><font size="2"   >&nbsp; when 'UPDATE' then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; insert into public.undo_t (xid, relid, table_schema, table_name, when_tg, level, op, encoding, old_rec, new_rec, username, client_addr, client_port)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_xid, tg_relid, tg_table_schema, tg_table_name, tg_when, tg_level, tg_op, v_encoding, OLD, NEW, v_username, v_client_addr, v_client_port);</font></div><div><font size="2"   >&nbsp; &nbsp; when 'TRUNCATE' then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; insert into public.undo_t (xid, relid, table_schema, table_name, when_tg, level, op, encoding, old_rec, username, client_addr, client_port)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; select v_xid, tg_relid, tg_table_schema, tg_table_name, tg_when, tg_level, tg_op, v_encoding, t, v_username, v_client_addr, v_client_port from public.t;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; return null;</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >&nbsp; &nbsp; RETURN null;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$BODY$ strict volatile;</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# alter table t add column c2 int;</font></div><div><font size="2"   >ALTER TABLE</font></div></div><div><div><font size="2"   >postgres=# insert into public.t values (6,now(),1,123);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# select new_rec from undo_t;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rec &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------</font></div><div><font size="2"   >&nbsp;(1,"2014-08-28 16:14:34.548555",,)</font></div><div><font size="2"   >&nbsp;(2,"2014-08-28 16:14:35.194634",,)</font></div><div><font size="2"   >&nbsp;(3,"2014-08-28 16:15:58.394688",,)</font></div><div><font size="2"   >&nbsp;(4,"2014-08-28 16:16:45.857712",1,)</font></div><div><font size="2"   >&nbsp;(5,"2014-08-28 16:26:37.160691",1,)</font></div><div><font size="2"   >&nbsp;(6,"2014-08-28 16:27:44.045674",1,123)</font></div><div><font size="2"   >(6 rows)</font></div></div><div><div><font size="2"   >postgres=# alter table t drop column crt_time;</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >postgres=# select new_rec from undo_t;</font></div><div><font size="2"   >&nbsp; new_rec &nbsp;</font></div><div><font size="2"   >-----------</font></div><div><font size="2"   >&nbsp;(1,,)</font></div><div><font size="2"   >&nbsp;(2,,)</font></div><div><font size="2"   >&nbsp;(3,,)</font></div><div><font size="2"   >&nbsp;(4,1,)</font></div><div><font size="2"   >&nbsp;(5,1,)</font></div><div><font size="2"   >&nbsp;(6,1,123)</font></div><div><font size="2"   >(6 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# insert into public.t values (7,1,123);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# select new_rec from undo_t;</font></div><div><font size="2"   >&nbsp; new_rec &nbsp;</font></div><div><font size="2"   >-----------</font></div><div><font size="2"   >&nbsp;(1,,)</font></div><div><font size="2"   >&nbsp;(2,,)</font></div><div><font size="2"   >&nbsp;(3,,)</font></div><div><font size="2"   >&nbsp;(4,1,)</font></div><div><font size="2"   >&nbsp;(5,1,)</font></div><div><font size="2"   >&nbsp;(6,1,123)</font></div><div><font size="2"   >&nbsp;(7,1,123)</font></div><div><font size="2"   >(7 rows)</font></div></div><p></p></pre></div><div><br></div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL bug? functions variable type cached within session. - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>