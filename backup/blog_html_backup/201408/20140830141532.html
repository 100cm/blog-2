<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">some limits when we use monetdb</h2>
	<h5 id="">2014-08-30 14:15:32&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201472962051905/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>使用monetdb时的一些注意事项,&nbsp;</div><div>1. m-funnel的返回结果集不能超过80K.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >man monetdbd</font></div><div><div><font size="2"   >MULTIPLEX-FUNNELS</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Monetdbd &nbsp;implements multiplex-funnel capabilities. &nbsp;As the name suggests two techniques are combined, the mul-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;tiplexer and the funnel.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;The funnel capability limits the access to the database to one client at a time. &nbsp;That is, if multiple &nbsp;clients</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;connect &nbsp;to &nbsp;the &nbsp;funnel, their queries will be serialized such that they are executed one after the other. &nbsp;An</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;effect of this approach is that clients no longer have an exclusive channel to the database, which &nbsp;means &nbsp;that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;individual queries from one client may have been interleaved with queries from others. &nbsp;This most notably makes</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;SQL transaction blocks unreliable with a funnel. &nbsp;The funnel, hence, is meant to scale down a large &nbsp;amount &nbsp;of</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;clients that perform short-running (read-only) queries, as typically seen in web-based query loads.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;When a funnel is defined to use multiple databases, the funnel adds a multiplexer to its query channel. &nbsp;A mul-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;tiplex-funnel sends each query to all of the defined databases. &nbsp;This behavior can be quite confusing at first,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;but &nbsp;proves &nbsp;to be useful in typical sharding configurations, where in particular simple selection queries have</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;to be performed on each of the shards. &nbsp;The multiplexer combines the answers from all defined databases in &nbsp;one</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;single &nbsp;answer &nbsp;that it sends back to the client. &nbsp;However, this combining is without any smart logic, that is,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;the multiplexer does not evaluate the query it is running, but just combines all answers it receives &nbsp;from &nbsp;the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;databases. &nbsp; This &nbsp;results &nbsp;in &nbsp;e.g. &nbsp;as many return tuples for a SELECT COUNT(*) query, as there are databases</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;defined.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Due to the two above mentioned characteristics, a multiplex-funnel has some limitations. &nbsp;As mentioned &nbsp;before,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;transactions over multiple queries are likely not to result in the desired behavior. &nbsp;This is due to each query</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;to the funnel is required to be self-contained. &nbsp;Further, since for &nbsp;each &nbsp;query, &nbsp;the &nbsp;results &nbsp;from &nbsp;multiple</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;servers &nbsp;have &nbsp;to &nbsp;be &nbsp;combined &nbsp;into one, that query must only return a single response, i.e. &nbsp;multi-statement</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;queries are most likely causing the funnel to respond with an error, or return garbled results. &nbsp;Last, the size</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;of &nbsp;each query is limited to currently about 80K. &nbsp;While this size should be sufficient for most queries, it is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;likely not enough for e.g. COPY INTO statements. &nbsp;Apart from the data transfer &nbsp;implications, &nbsp;such &nbsp;statements</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;should not be used with the funnel, as the results will be undefined due to the limited query buffer. &nbsp;Applica-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;tions using the funnel should aim for short and single-statement queries that require no transactions.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;See the create command in the monetdb(1) man-page for details on how to setup a multiplex-funnel.</font></div></div><p></p></pre></div><div><br></div><div>2. 使用宽表时需要注意, 表越宽, 插入越慢, 因为monetdb是列存储的, 为了把所有的列串成1行, 插入新行时, 哪怕只有1个列有值, 其他列为空, 其他列也是耗费空间的.</div><div>我们来建2个2万个字段的宽表. 其中一个有默认值, 另一个没有默认值.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-221 ~]# vi test.sql</font></div><div><font size="2"   ><span style="line-height: 21px;"   >#!/bin/bash<br><br>echo "drop table t1;"|mclient test<br>sql="create table t1(id int"<br><br>for ((i=1;i&lt;20000;i++)) <br>do<br>  sql="$sql, c$i int default 100"<br>done<br><br>sql="$sql);"<br>echo "$sql"|mclient test</span></font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >[root@db-172-16-3-221 ~]# chmod 500 test.sql</font></div><div><span style="line-height: 28px;"   ><font size="2"   >[root@db-172-16-3-221 ~]# ./test.sql</font></span></div><p></p></pre></div></div><div><br></div><div>对比一下这两个表的性能</div><div>插入测试</div><div>t1, 插入时其他19999个字段默认为100.</div><div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t1(id) values (1);</font></div><div style="line-height: 28px;"   ><font size="2"   >1 affected rows (25.1s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t1(id) values (2);</font></div><div style="line-height: 28px;"   ><font size="2"   >1 affected rows (8.4s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t1(id) values (3);</font></div><div style="line-height: 28px;"   ><font size="2"   >1 affected rows (8.4s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t1(id) values (4);</font></div><div style="line-height: 28px;"   ><font size="2"   >1 affected rows (8.4s)</font></div><p></p></pre></div></div><div><span style="line-height: 28px;"   >t2, 插入时, 其他19999个字段为空.</span></div></div><div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2(id) values (1);</font></div><div style="line-height: 28px;"   ><font size="2"   >1 affected rows (20.4s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2(id) values (2);</font></div><div style="line-height: 28px;"   ><font size="2"   >1 affected rows (2.7s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2(id) values (3);</font></div><div style="line-height: 28px;"   ><font size="2"   >1 affected rows (2.7s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2(id) values (4);</font></div><div style="line-height: 28px;"   ><font size="2"   >1 affected rows (2.7s)</font></div><p></p></pre></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >从插入性能来看, t1略差, 但是t2也好不到哪里去, 因为每个列都被操作了(即使为空).</span></div><div style="line-height: 28px;"   >从测试来看, 宽表的缺陷就在于插入效率太差.&nbsp;</div><div style="line-height: 28px;"   >批量插入测试 :&nbsp;</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2 select * from t1;</font></div><div style="line-height: 28px;"   ><font size="2"   >4 affected row (40.3s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2 select * from t2;</font></div><div style="line-height: 28px;"   ><font size="2"   >16 affected row (1m 8s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2 select * from t2;</font></div><div style="line-height: 28px;"   ><font size="2"   >32 affected row (23.0s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2 select * from t2;</font></div><div style="line-height: 28px;"   ><font size="2"   >64 affected row (22.4s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2 select * from t2;</font></div><div style="line-height: 28px;"   ><font size="2"   >128 affected row (13.5s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2 select * from t2;</font></div><div style="line-height: 28px;"   ><font size="2"   >256 affected row (13.5s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2 select * from t2;</font></div><div style="line-height: 28px;"   ><font size="2"   >512 affected row (20.3s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2 select * from t2;</font></div><div style="line-height: 28px;"   ><font size="2"   >1024 affected row (20.0s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2 select * from t2;</font></div><div style="line-height: 28px;"   ><font size="2"   >2048 affected row (18.5s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2 select * from t2;</font></div><div style="line-height: 28px;"   ><font size="2"   >4096 affected row (20.8s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2 select * from t2;</font></div><div style="line-height: 28px;"   ><font size="2"   >8192 affected row (20.3s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2 select * from t2;</font></div><div style="line-height: 28px;"   ><font size="2"   >16384 affected row (23.0s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t2 select * from t2;</font></div><div style="line-height: 28px;"   ><font size="2"   >32768 affected row (45.3s)</font></div><p></p></pre></div></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><br></span></div><div style="line-height: 28px;"   >添加字段测试, 因为行少, 所以添加速度很快. 当行多的时候, 添加速度就很慢了.</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >sql&gt;alter table t1 add column c20001 int;</font></div><div style="line-height: 28px;"   ><font size="2"   >operation successful (41.356ms)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;alter table t2 add column c20001 int;</font></div><div style="line-height: 28px;"   ><font size="2"   >operation successful (49.784ms)</font></div><div style="line-height: 28px;"   ></div><p></p></pre></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><br></div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >sql&gt;create table t3(id int);</font></div><div style="line-height: 28px;"   ><font size="2"   >operation successful (17.365ms)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t3 values (1);</font></div><div style="line-height: 28px;"   ><font size="2"   >1 affected rows (14.385ms)</font></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t3 select * from t3;</font></div><div style="line-height: 28px;"   ><font size="2"   >1 affected rows (6.774ms)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t3 select * from t3;</font></div><div style="line-height: 28px;"   ><font size="2"   >2 affected row (6.641ms)</font></div></div><div style="line-height: 28px;"   ><font size="2"   >.......</font></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >sql&gt;insert into t3 select * from t3;</font></div><div style="line-height: 28px;"   ><font size="2"   >536870912 affected row (14.8s)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;alter table t3 add column c1 int; &nbsp;-- 当已经有10亿记录时, 添加一行变得很慢. 因为要格式化列存储. 即使没有默认值.</font></div><div style="line-height: 28px;"   ><font size="2"   >operation successful (4m 7s)</font></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >sql&gt;alter table t3 add column c2 int;</font></div><div style="line-height: 28px;"   ><font size="2"   >operation successful (4m 9s)</font></div><div style="line-height: 28px;"   ><font size="2"   >-- 新增的列虽然没有数据, 但是空间需要预分配, 所以当前表有多少行, 就要分配多少空间, 行越多的表, 新增列越慢.</font></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >sql&gt;select * from sys.storage where "table"='t3';</font></div><div style="line-height: 28px;"   ><font size="2"   >+--------+-------+--------+------+-------------+------------+-----------+------------+----------+---------+--------+</font></div><div style="line-height: 28px;"   ><font size="2"   >| schema | table | column | type | location &nbsp; &nbsp;| count &nbsp; &nbsp; &nbsp;| typewidth | columnsize | heapsize | indices | sorted |</font></div><div style="line-height: 28px;"   ><font size="2"   >+========+=======+========+======+=============+============+===========+============+==========+=========+========+</font></div><div style="line-height: 28px;"   ><font size="2"   >| sys &nbsp; &nbsp;| t3 &nbsp; &nbsp;| id &nbsp; &nbsp; | int &nbsp;| 01/30/13054 | 1073741824 | &nbsp; &nbsp; &nbsp; &nbsp; 4 | 4294967296 | &nbsp; &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; 0 | true &nbsp; |</font></div><div style="line-height: 28px;"   ><font size="2"   >| sys &nbsp; &nbsp;| t3 &nbsp; &nbsp;| c1 &nbsp; &nbsp; | int &nbsp;| 01/12/11233 | 1073741824 | &nbsp; &nbsp; &nbsp; &nbsp; 4 | 4294967296 | &nbsp; &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; 0 | true &nbsp; |</font></div><div style="line-height: 28px;"   ><font size="2"   >| sys &nbsp; &nbsp;| t3 &nbsp; &nbsp;| c2 &nbsp; &nbsp; | int &nbsp;| 01/26/12651 | 1073741824 | &nbsp; &nbsp; &nbsp; &nbsp; 4 | 4294967296 | &nbsp; &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; 0 | true &nbsp; |</font></div><div style="line-height: 28px;"   ><font size="2"   >+--------+-------+--------+------+-------------+------------+-----------+------------+----------+---------+--------+</font></div><div style="line-height: 28px;"   ><font size="2"   >3 tuples (6.1s)</font></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >sql&gt;select * from t3 limit 5;</font></div><div style="line-height: 28px;"   ><font size="2"   >+------+------+------+</font></div><div style="line-height: 28px;"   ><font size="2"   >| id &nbsp; | c1 &nbsp; | c2 &nbsp; |</font></div><div style="line-height: 28px;"   ><font size="2"   >+======+======+======+</font></div><div style="line-height: 28px;"   ><font size="2"   >| &nbsp; &nbsp;1 | null | null |</font></div><div style="line-height: 28px;"   ><font size="2"   >| &nbsp; &nbsp;1 | null | null |</font></div><div style="line-height: 28px;"   ><font size="2"   >| &nbsp; &nbsp;1 | null | null |</font></div><div style="line-height: 28px;"   ><font size="2"   >| &nbsp; &nbsp;1 | null | null |</font></div><div style="line-height: 28px;"   ><font size="2"   >| &nbsp; &nbsp;1 | null | null |</font></div><div style="line-height: 28px;"   ><font size="2"   >+------+------+------+</font></div><div style="line-height: 28px;"   ><font size="2"   >5 tuples (29.136ms)</font></div></div></div></div></div><p></p></pre></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><br></div></div></div><div style="line-height: 28px;"   >更新测试, 对已经存在的记录更新效率明显比插入记录的效率高多了. 因为只涉及到更新列的操作, 插入则是所有列的操作.&nbsp;</div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >sql&gt;update t1 set c20001=1 where id=1;</font></div><div style="line-height: 28px;"   ><font size="2"   >1 affected rows (16.535ms)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;update t2 set c20001=1 where id=1;</font></div><div style="line-height: 28px;"   ><font size="2"   >3 affected row (16.722ms)</font></div><p></p></pre></div></div></div></div><div style="line-height: 28px;"   >虽然单条记录更新看起来不快, 但是可以批量更新以提升性能.</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >sql&gt;update t2 set c1=c2 ;</font></div><div style="line-height: 28px;"   ><font size="2"   >65536 affected row (48.002ms)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;update t2 set c1=1 ;</font></div><div style="line-height: 28px;"   ><font size="2"   >65536 affected row (61.021ms)</font></div><div style="line-height: 28px;"   ><font size="2"   >例如使用函数来批量更新列.</font></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >update t2 set c1=function(传入参数) ;</font></span></div><p></p></pre></div></div><div style="line-height: 28px;"   ><br></div><div style="line-height: 28px;"   >返回多列(2万)大数据量的查询测试 :&nbsp;</div><div><div><pre class="prettyprint"   ><p style="line-height: 28px;"   ></p><div style="line-height: 28px;"   ><font size="2"   >[root@db-172-16-3-221 ~]# mclient test -H</font></div><div style="line-height: 28px;"   ><font size="2"   >Welcome to mclient, the MonetDB/SQL interactive terminal (Jan2014-SP3)</font></div><div style="line-height: 28px;"   ><font size="2"   >Database: MonetDB v11.17.21 (Jan2014-SP3), 'mapi:monetdb://db-172-16-3-221:50000/test'</font></div><div style="line-height: 28px;"   ><font size="2"   >Type \q to quit, \? for a list of available commands</font></div><div style="line-height: 28px;"   ><font size="2"   >auto commit mode: on</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;\?</font></div><div style="line-height: 28px;"   ><font size="2"   >\? &nbsp; &nbsp; &nbsp;- show this message</font></div><div style="line-height: 28px;"   ><font size="2"   >\&lt;file &nbsp;- read input from file</font></div><div style="line-height: 28px;"   ><font size="2"   >\&gt;file &nbsp;- save response in file, or stdout if no file is given</font></div><div style="line-height: 28px;"   ><font size="2"   >\|cmd &nbsp; - pipe result to process, or stop when no command is given</font></div><div style="line-height: 28px;"   ><font size="2"   >\h &nbsp; &nbsp; &nbsp;- show the readline history</font></div><div style="line-height: 28px;"   ><font size="2"   >\D table- dumps the table, or the complete database if none given.</font></div><div style="line-height: 28px;"   ><font size="2"   >\d[Stvsfn]+ [obj] - list database objects, or describe if obj given</font></div><div style="line-height: 28px;"   ><font size="2"   >\A &nbsp; &nbsp; &nbsp;- enable auto commit</font></div><div style="line-height: 28px;"   ><font size="2"   >\a &nbsp; &nbsp; &nbsp;- disable auto commit</font></div><div style="line-height: 28px;"   ><font size="2"   >\e &nbsp; &nbsp; &nbsp;- echo the query in sql formatting mode</font></div><div style="line-height: 28px;"   ><font size="2"   >\f &nbsp; &nbsp; &nbsp;- format using a built-in renderer {csv,tab,raw,sql,xml}</font></div><div style="line-height: 28px;"   ><font size="2"   >\w# &nbsp; &nbsp; - set maximal page width (-1=unlimited, 0=terminal width, &gt;0=limit to num)</font></div><div style="line-height: 28px;"   ><font size="2"   >\r# &nbsp; &nbsp; - set maximum rows per page (-1=raw)</font></div><div style="line-height: 28px;"   ><font size="2"   >\L file - save client/server interaction</font></div><div style="line-height: 28px;"   ><font size="2"   >\X &nbsp; &nbsp; &nbsp;- trace mclient code</font></div><div style="line-height: 28px;"   ><font size="2"   >\q &nbsp; &nbsp; &nbsp;- terminate session</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;\&gt;/dev/null</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;select 1;</font></div><div style="line-height: 28px;"   ><font size="2"   >1 tuple (7.138ms)</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;\w-1</font></div><div style="line-height: 28px;"   ><font size="2"   >sql&gt;select * from t1;  -- 2万个列全量查询很慢, 几乎无法完成</font></div><div style="line-height: 28px;"   ><font size="2"   >1个小时没处理完.</font></div><div><font size="2"   >sql&gt;select id,c2000 from t1;  -- 减少列的话, 速度可以接受.<br>524292 tuples (31.110ms)</font></div><p style="line-height: 28px;"   ></p></pre></div><div style="line-height: 28px;"   ><br></div></div><div style="line-height: 28px;"   >[其他]</div><div style="line-height: 28px;"   >1. 如果使用PostgreSQL的话, 就不要对宽表抱有希望了, 因为PostgreSQL不允许行跨数据块存储, 所以对字段数做了限制.</div><div style="line-height: 28px;"   >例如一个8K的数据块, 如果每个字段4字节(例如int类型)的话, 可以存储2000个字段, 这还没有计算行头, 块头信息. 所以实际限制是1600或更小, 参考代码 :&nbsp;</div><div>src/include/access/htup_details.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*<br> * MaxTupleAttributeNumber limits the number of (user) columns in a tuple.<br> * The key limit on this value is that the size of the fixed overhead for<br> * a tuple, plus the size of the null-values bitmap (at 1 bit per column),<br> * plus MAXALIGN alignment, must fit into t_hoff which is uint8.  On most<br> * machines the upper limit without making t_hoff wider would be a little<br> * over 1700.  We use round numbers here and for MaxHeapAttributeNumber<br> * so that alterations in HeapTupleHeaderData layout won't change the<br> * supported max number of columns.<br> */<br>#define MaxTupleAttributeNumber 1664    /* 8 * 208 */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* MaxHeapAttributeNumber limits the number of (user) columns in a table.</font></div><div><font size="2"   >&nbsp;* This should be somewhat less than MaxTupleAttributeNumber. &nbsp;It must be</font></div><div><font size="2"   >&nbsp;* at least one less, else we will fail to do UPDATEs on a maximal-width</font></div><div><font size="2"   >&nbsp;* table (because UPDATE has to form working tuples that include CTID).</font></div><div><font size="2"   >&nbsp;* In practice we want some additional daylight so that we can gracefully</font></div><div><font size="2"   >&nbsp;* support operations that add hidden "resjunk" columns, for example</font></div><div><font size="2"   >&nbsp;* SELECT * FROM wide_table ORDER BY foo, bar, baz.</font></div><div><font size="2"   >&nbsp;* In any case, depending on column data types you will likely be running</font></div><div><font size="2"   >&nbsp;* into the disk-block-based limit on overall tuple size if you have more</font></div><div><font size="2"   >&nbsp;* than a thousand or so columns. &nbsp;TOAST won't help.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define MaxHeapAttributeNumber &nbsp;1600 &nbsp; &nbsp;/* 8 * 200 */</font></div><p></p></pre></div><div style="line-height: 28px;"   ><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="some limits when we use monetdb - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>