<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">order by limit x offset y performance tuning</h2>
	<h5 id="">2014-02-11 17:43:02&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201411152640383/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">再一次证明和开发人员沟通, 其乐无穷.<div>今天一位开发的同事给我一个SQL, 问我为什么只改了一个条件, 查询速度居然从毫秒就慢到几十秒了,</div><div>如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SELECT * &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; FROM tbl</font></div><div><font size="2"   >&nbsp; where create_time&gt;='2014-02-08' and create_time&lt;'2014-02-11'</font></div><div><font size="2"   >&nbsp; and x=3</font></div><div><font size="2"   >&nbsp; and id != '123'</font></div><div><font size="2"   >&nbsp; and id != '321'</font></div><div><font size="2"   >&nbsp; and y &gt; 0 order by create_time limit 1 offset 0;</font></div><p></p></pre></div><div>运行结果100毫秒左右.</div><div>执行计划 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Limit &nbsp;(cost=0.56..506.19 rows=1 width=1038)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx on tbl &nbsp;(cost=0.56..2381495.<span style="line-height: 28px;"   >60 rows=4710 width=1038)</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((create_time &gt;= '2014-02-08 00:00:00'::timestamp without time zone) AND (create_time &lt; '2014-02-11 00:00:00'::<span style="line-height: 28px;"   >timestamp without time zone))</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (((id)::text &lt;&gt; '123'::text) AND ((id)::text &lt;&gt; '321'::text) AND (y &gt; 0) AND (x<span style="line-height: 28px;"   >&nbsp;= 3))</span></font></div><p></p></pre></div><div><br></div><div>改成如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SELECT * &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; FROM tbl</font></div><div><font size="2"   >&nbsp; where create_time&gt;='2014-02-08' and create_time&lt;'2014-02-11'</font></div><div><font size="2"   >&nbsp; and x=3</font></div><div><font size="2"   >&nbsp; and id != '123'</font></div><div><font size="2"   >&nbsp; and id != '321'</font></div><div><font size="2"   >&nbsp; and y &gt; 0 order by create_time limit 1 offset 10;</font></div><p></p></pre></div><div>运行几十秒.</div><div>执行计划如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Limit &nbsp;(cost=5056.98..5562.62 rows=1 width=1038)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx on tbl &nbsp;(cost=0.56..2382076.<span style="line-height: 28px;"   >78 rows=4711 width=1038)</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((create_time &gt;= '2014-02-08 00:00:00'::timestamp without time zone) AND (create_time &lt; '2014-02-11 00:00:00'::<span style="line-height: 28px;"   >timestamp without time zone))</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (((id)::text &lt;&gt; '11622'::text) AND ((id)::text &lt;&gt; '13042'::text) AND (y &gt; 0) AND (x<span style="line-height: 28px;"   >&nbsp;= 3))</span></font></div><p></p></pre></div><div><br></div><div>我们看到两个SQL执行计划是一样的, 但是走索引扫描的记录却千差万别. 第二个SQL扫描了多少行呢?</div><div>我们来看看第二个查询得到的create_time值是多少:</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >select create_time from tbl&nbsp;</font></div><div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; where create_time&gt;='2014-02-08' and create_time&lt;'2014-02-11'</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; and x=3</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; and id != '123'</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; and id != '321'</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; and y &gt; 0 order by create_time limit 1 offset 10;</font></div></div><p></p></pre></div><div style="line-height: 28px;"   >结果 :&nbsp;</div><pre class="prettyprint"   ><p></p><div><font size="2"   >'2014-02-08 18:38:35.79'</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >那么它扫描了多少行(或者说多少个数据块)呢? 通过explain verbose可以输出.&nbsp;</span></div><div><span style="line-height: 28px;"   >当然使用以下查询也可以估算出来 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >select count(*) from tbl where create_time&lt;='2014-02-08 18:38:35.79' and create_time&gt;='2014-02-08';</font></div><div><font size="2"   >&nbsp; count &nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;1448081</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>也就是说本例的SQL中的WHERE条件的数据在create_time这个字段顺序上的分布比较零散, 并且数据量比较庞大.</div><div>所以offset 10后, 走create_time这个索引自然就慢了.</div><div>仔细的了解了一下开发人员的需求, 是要做类似翻页的需求.&nbsp;</div><div><br></div><div>优化方法1, 在不新增任何索引的前提下, 还是走create_time这个索引, 减少重复扫描的数据.</div><div>需要得到每次取到的最大的create_time值, 以及可以标示这条记录的唯一ID.</div><div>下次取的时候, 不要使用offset 下一页, 而是加上这两个条件.</div><div>例如 :&nbsp;</div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >select create_time from tbl&nbsp;</font></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >&nbsp; where create_time&gt;='2014-02-08' and create_time&lt;'2014-02-11'</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; and x=3</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; and id != '123'</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; and id != '321'</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; and pk not in (?) &nbsp;-- 这个ID是上次取到的create_time最大的值的所有记录的pk值.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; and y &gt; 0&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; and create_time &gt;= '<span style="line-height: 28px;"   >2014-02-08 18:38:35.79</span><span style="line-height: 28px;"   >' &nbsp;-- 这个时间是上次取到的数据的最大的时间值.</span></font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; order by create_time limit ? offset 0;</font></div></div><p></p></pre></div><div><div style="line-height: 28px;"   >通过这种方法, 可以减少limit x offset y这种方法取后面的分页数据带来的大量数据块离散扫描.</div><div style="line-height: 28px;"   >以前写的一些关于分页优化的例子 :&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201111694355822/"   >http://blog.163.com/digoal@126/blog/static/163877040201111694355822/</a></div></div></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012520105855757/"   >http://blog.163.com/digoal@126/blog/static/1638770402012520105855757/</a></div></div>
	</div>
</div>
</body>
</html>