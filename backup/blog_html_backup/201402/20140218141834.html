<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Lua iterator state cost (stateless < closure < state table < coroutine)</h2>
	<h5 id="">2014-02-18 14:18:34&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201411821834241/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>generic for循环函数的代价, 成本从低到高.</div><div>首先考虑使用stateless, 也就是函数中无状态值, 状态值通常在exp-list中直接指出.</div><div>其次是使用closure, 使用non-local变量传递状态值.</div><div>再次是使用状态表存储状态.</div><div>最后是coroutine.</div><div><br></div><div>Simply put, a closure is a function plus all it needs to access non-local variables correctly.</div><div><br></div><div>Whenever possible, you should try to write stateless iterators, those that&nbsp;<span style="line-height: 28px;"   >keep all their state in the for variables.&nbsp;</span></div><div>With them, you do not create new objects when you start a loop.&nbsp;</div><div>If you cannot fit your iteration into this model, then you should try closures.&nbsp;</div><div>Besides being more elegant, typically a closure is more efficient than an iterator using tables:&nbsp;</div><div>1.first, it is cheaper to create a closure than a table;&nbsp;</div><div>2.second, access to non-local variables is faster than access to table fields.&nbsp;</div><div>Later we will see yet another way to write iterators, with coroutines.&nbsp;</div><div>This is the most powerful solution, but a little more expensive.</div><wbr><div><br></div><div>1. 无状态的例子</div><div>iterator 函数, 参数为状态和控制变量</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; function iter(s,i)</font></div><div><font size="2"   >&gt;&gt; &nbsp; i = i+1</font></div><div><font size="2"   >&gt;&gt; &nbsp; local v = s[i]</font></div><div><font size="2"   >&gt;&gt; &nbsp; if v then</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; return i,v</font></div><div><font size="2"   >&gt;&gt; &nbsp; end</font></div><div><font size="2"   >&gt;&gt; end</font></div><p></p></pre></div><div>factory函数, 返回iterator函数, 状态和控制变量初始值, 状态值通过exp-list直接传入, 所以对于factory函数来说是不存储state值的, 因此称为stateless .</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; function ipairs(s)</font></div><div><font size="2"   >&gt;&gt; &nbsp; return iter, s, 0</font></div><div><font size="2"   >&gt;&gt; end</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&gt; a = {"one", "two", "three"}</font></div><div><font size="2"   >&gt; for i,v in ipairs(a) do&nbsp;</font></div><div><font size="2"   >&gt;&gt; &nbsp; print (i,v)</font></div><div><font size="2"   >&gt;&gt; end</font></div><div><font size="2"   >1 &nbsp; &nbsp; &nbsp; one</font></div><div><font size="2"   >2 &nbsp; &nbsp; &nbsp; two</font></div><div><font size="2"   >3 &nbsp; &nbsp; &nbsp; three</font></div><p></p></pre></div></div><div><br></div><div>2. 使用closure的例子, 将状态值存储在closure中.</div><div>factory函数, 返回iterator匿名函数以及state状态值. state封装在iterator匿名函数中.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; function allwords()</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp;local state = {line = io.read(), pos = 1} &nbsp;-- 使用factory函数的local变量表存储状态值, 对iterator来说就是non-local变量</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp;return function (state)</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp;while state.line do &nbsp;-- 重复直到最后一行</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp;local s,e = string.find(state.line, "%w+", state.pos) &nbsp;-- 查找单词</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp;if s then</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp; &nbsp;state.pos = e+1</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp; &nbsp;return string.sub(state.line, s, e) &nbsp;-- 返回单词</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp;else &nbsp;-- 否则下一行</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp; &nbsp;state.line = io.read()</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp; &nbsp;state.pos = 1</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp;end</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp;end</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp;return nil &nbsp;-- 如果没有值, iterator函数返回nil给控制变量, 因此结束generic for循环.</font></div><div><font size="2"   >&gt;&gt; &nbsp;end, state</font></div><div><font size="2"   >&gt;&gt; end</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&gt; for w in allwords() do</font></div><div><font size="2"   >&gt;&gt; &nbsp;print (w)</font></div><div><font size="2"   >&gt;&gt; end</font></div><div><font size="2"   >hello nihao a</font></div><div><font size="2"   >hello</font></div><div><font size="2"   >nihao</font></div><div><font size="2"   >a</font></div><p></p></pre></div><div><br></div><div>3. 使用状态表的例子</div><div>上一个例子改一下就变成表存储state值了, 只要把iterator函数放到外面即可.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; function iterator(state)  -- </font><span style="line-height: 21px; font-size: small; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, 宋体;"   >因为iterator函数在外头定义, 所以没有non-local变量, 所以和上面的例子差就差在这里.</span></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp;while state.line do</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp;local s,e = string.find(state.line, "%w+", state.pos)</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp;if s then</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp; &nbsp;state.pos = e+1</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp; &nbsp;return string.sub(state.line, s, e)</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp;else</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp; &nbsp;state.line = io.read()</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp; &nbsp;state.pos = 1</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; &nbsp;end</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp;end</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp;return nil</font></div><div><font size="2"   >&gt;&gt; &nbsp;end</font></div><div><font size="2"   >&gt;&nbsp;</font></div><div><font size="2"   >&gt; function allwords()</font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; local state = {line = io.read(), pos = 1} &nbsp;-- 使用表存储state值, 同时传递给iterator函数. </font></div><div><font size="2"   >&gt;&gt; &nbsp; &nbsp; return iterator, state</font></div><div><font size="2"   >&gt;&gt; end</font></div><div><font size="2"   >&gt; for w in allwords() do</font></div><div><font size="2"   >&gt;&gt; &nbsp; print(w)</font></div><div><font size="2"   >&gt;&gt; end</font></div><div><font size="2"   >hello nihao, yes &nbsp;&nbsp;</font></div><div><font size="2"   >hello</font></div><div><font size="2"   >nihao</font></div><div><font size="2"   >yes</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>