<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">use pg_reorg re-organize tables in postgresql avoid LONG time AccessExclusiveLock</h2>
	<h5 id="">2014-02-12 14:33:16&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201411205420775/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>在PostgreSQL中重组表一个比较老的话题了, 至于为什么要重组表, 不了解PG的朋友可以阅读以下PG的MVCC相关原理, 不喜欢阅读的朋友也可以看我的视频教程.</div><div><a target="_blank" rel="nofollow" href="http://www.tudou.com/home/digoal"   >http://www.tudou.com/home/digoal</a></div><div>通过解读fsm中的统计信息可以了解数据库中哪些对象需要重组, 方法如下 :&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402013527920474/"   >http://blog.163.com/digoal@126/blog/static/1638770402013527920474/</a></div><div>对于索引, 由于PG支持对同列定义多个索引, 所以使用concurrently的方法新建索引就可以达到重组索引的目的 :&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201231781923116/"   >http://blog.163.com/digoal@126/blog/static/163877040201231781923116/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201343031159876"   >http://blog.163.com/digoal@126/blog/static/163877040201343031159876</a></div><div>如果是表需要重组, 最简单的做法是执行vacuum full或者cluster命令, 但是这两个命令需要<span style="line-height: 28px;"   >AccessExclusiveLock锁, 所以会堵塞DML包括查询.&nbsp;</span></div><div><span style="line-height: 28px;"   >本文要说的pg_reorg插件就是解决这个锁问题的, 使用这个插件, 不需要整个过程加载</span><span style="line-height: 28px;"   >AccessExclusiveLock锁, 我们可以打开数据库QUERY审计来观察pg_reorg都干了些什么?本文将详细解说. pg_reorg只短暂的使用了</span><span style="line-height: 28px;"   >AccessExclusiveLock锁.</span></div><div>首先下载一个比较新的pg_reorg版本, 中间断档了一段时间, 现在又出新版本了. (期间有一位网友把pg_reorg的代码拿去更名为pg_repack, 后来还是回归pg_reorg了, 代码去pgfoundry下载吧)</div><pre class="prettyprint"   ><p></p><div><font size="2"   ># wget&nbsp;http://pgfoundry.org/frs/download.php/3558/pg_reorg-1.1.9.tar.gz</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >安装</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># unzip&nbsp;<span style="line-height: 28px;"   >pg_reorg-1.1.9.tar.gz</span></font></div><div><font size="2"   ># mv&nbsp;<span style="line-height: 28px;"   >pg_reorg-1.1.9&nbsp;</span><span style="line-height: 28px;"   >/opt/soft_bak/postgresql-9.3.1/</span>contrib</font></div><div><font size="2"   ># less&nbsp;<span style="line-height: 28px;"   >postgresql-9.3.1/config.log</span></font></div><div><font size="2"   >./configure --prefix=/home/pg931/pgsql9.3.1 --with-pgport=1922 --with-perl --with-tcl --with-python --with-openssl --with-pam --without-ldap --with-libxml --with-libxslt --enable-thread-safety --with-wal-blocksize=64 --with-blocksize=32 --enable-dtrace --enable-debug</font></div><div><font size="2"   >所以我们要把pg_reorg安装到<span style="line-height: 28px;"   >/home/pg931/pgsql9.3.1</span></font></div><div><font size="2"   ># export PATH=<span style="line-height: 28px;"   >/home/pg931/pgsql9.3.1/bin:$PATH</span></font></div><div><span style="line-height: 28px;"   ><font size="2"   ># which pg_config</font></span></div><div><font size="2"   ><span style="line-height: 28px;"   >/</span>home/pg931/pgsql9.3.1/bin/pg_config</font></div><div><font size="2"   ># cd&nbsp;<span style="line-height: 28px;"   >/opt/soft_bak/postgresql-9.3.1/</span><span style="line-height: 28px;"   >contrib/</span><span style="line-height: 28px;"   >pg_reorg-1.1.9</span></font></div><div><span style="line-height: 28px;"   ><font size="2"   ># gmake clean</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   ># gmake</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   ># gmake install</font></span></div><div><font size="2"   ><span style="line-height: 28px;"   >#&nbsp;</span><span style="line-height: 28px;"   >ll /home/pg931/pgsql9.3.1/lib/pg_reorg.so&nbsp;</span></font></div><div><font size="2"   >-rwxr-xr-x 1 root root 82562 Feb 12 13:18 /home/pg931/pgsql9.3.1/lib/pg_reorg.so</font></div><div><div><font size="2"   >[root@db-172-16-3-150 pgsql9.3.1]# su - pg931</font></div><div><font size="2"   >pg931@db-172-16-3-150-&gt; psql</font></div><div><font size="2"   >psql (9.3.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >digoal=# create extension pg_reorg;</font></div></div><p></p></pre></div><div><br></div><div>创建测试表 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table test (id int primary key, info text, crt_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>插入测试数据 :&nbsp;</div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# insert into test select generate_series(1,10000000), md5(random()::text), clock_timestamp();</font></div></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >创建相关的索引 :&nbsp;</span></div></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# set maintenance_work_mem='2GB';</font></div><div><font size="2"   >SET</font></div></div><div><div><font size="2"   >digoal=# create index idx_test_1 on test(info);</font></div><div><font size="2"   >CREATE INDEX</font></div></div><div><div><font size="2"   >digoal=# create index idx_test_2 on test(crt_time);</font></div><div><font size="2"   >CREATE INDEX</font></div></div><div><div><font size="2"   >digoal=# select pg_total_relation_size('test')/1024/1024||'MB';</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;1705MB</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div>人为的产生一个高水位, 保留ctid最大的一行, 其他的行删除 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# delete from test where id &lt;&gt; (select id from test order by ctid desc limit 1);</font></div><div><font size="2"   >DELETE 9999999</font></div><p></p></pre></div><div>使用普通的vacuum无法从磁盘释放高水位以下的空间, 仅仅能回收到fsm供后期的dml使用, 传统的vacuum full, cluster则可以释放这些空间, 当然会加<span style="line-height: 28px;"   >AccessExclusiveLock锁从而堵塞查询和DML.</span></div><div><span style="line-height: 28px;"   ><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# vacuum verbose test;</font></div><div><font size="2"   >INFO: &nbsp;vacuuming "public.test"</font></div><div><font size="2"   >INFO: &nbsp;index "test_pkey" now contains 1 row versions in 6806 pages</font></div><div><font size="2"   >DETAIL: &nbsp;0 index row versions were removed.</font></div><div><font size="2"   >6802 index pages have been deleted, 6802 are currently reusable.</font></div><div><font size="2"   >CPU 0.00s/0.00u sec elapsed 0.01 sec.</font></div><div><font size="2"   >INFO: &nbsp;index "idx_test_1" now contains 1 row versions in 17711 pages</font></div><div><font size="2"   >DETAIL: &nbsp;0 index row versions were removed.</font></div><div><font size="2"   >17704 index pages have been deleted, 17704 are currently reusable.</font></div><div><font size="2"   >CPU 0.00s/0.01u sec elapsed 0.04 sec.</font></div><div><font size="2"   >INFO: &nbsp;index "idx_test_2" now contains 1 row versions in 6802 pages</font></div><div><font size="2"   >DETAIL: &nbsp;0 index row versions were removed.</font></div><div><font size="2"   >6798 index pages have been deleted, 6798 are currently reusable.</font></div><div><font size="2"   >CPU 0.00s/0.00u sec elapsed 0.02 sec.</font></div><div><font size="2"   >INFO: &nbsp;"test": found 0 removable, 0 nonremovable row versions in 0 out of 23256 pages</font></div><div><font size="2"   >DETAIL: &nbsp;0 dead row versions cannot be removed yet.</font></div><div><font size="2"   >There were 0 unused item pointers.</font></div><div><font size="2"   >0 pages are entirely empty.</font></div><div><font size="2"   >CPU 0.00s/0.03u sec elapsed 0.09 sec.</font></div><div><font size="2"   >INFO: &nbsp;vacuuming "pg_toast.pg_toast_16480"</font></div><div><font size="2"   >INFO: &nbsp;index "pg_toast_16480_index" now contains 0 row versions in 1 pages</font></div><div><font size="2"   >DETAIL: &nbsp;0 index row versions were removed.</font></div><div><font size="2"   >0 index pages have been deleted, 0 are currently reusable.</font></div><div><font size="2"   >CPU 0.00s/0.00u sec elapsed 0.00 sec.</font></div><div><font size="2"   >INFO: &nbsp;"pg_toast_16480": found 0 removable, 0 nonremovable row versions in 0 out of 0 pages</font></div><div><font size="2"   >DETAIL: &nbsp;0 dead row versions cannot be removed yet.</font></div><div><font size="2"   >There were 0 unused item pointers.</font></div><div><font size="2"   >0 pages are entirely empty.</font></div><div><font size="2"   >CPU 0.00s/0.00u sec elapsed 0.00 sec.</font></div><div><font size="2"   >VACUUM</font></div><p></p></pre></div><div>可以看到普通的vacuum未释放空间</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select pg_total_relation_size('test')/1024/1024||'MB';</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;1705MB</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>接下来要使用pg_reorg来实现空间释放 :&nbsp;</div><div>首先我们把SQL审计打开</div></span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 28px;"   ><font size="2"   >pg931@db-172-16-3-150-&gt; cd $PGDATA</font></span></div><div><font size="2"   >log_statement = 'all'</font></div><div><font size="2"   >pg931@db-172-16-3-150-&gt; pg_ctl reload</font></div><p></p></pre></div><div>pg_reorg 的帮助信息 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg931@db-172-16-3-150-&gt; pg_reorg --help</font></div><div><font size="2"   >pg_reorg re-organizes a PostgreSQL database.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Usage:</font></div><div><font size="2"   >&nbsp; pg_reorg [OPTION]... [DBNAME]</font></div><div><font size="2"   >Options:</font></div><div><font size="2"   >&nbsp; -a, --all &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reorg all databases</font></div><div><font size="2"   >&nbsp; -n, --no-order &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;do vacuum full instead of cluster</font></div><div><font size="2"   >&nbsp; -o, --order-by=columns &nbsp; &nbsp;order by columns instead of cluster keys</font></div><div><font size="2"   >&nbsp; -t, --table=TABLE &nbsp; &nbsp; &nbsp; &nbsp; reorg specific table only</font></div><div><font size="2"   >&nbsp; -T, --wait-timeout=secs &nbsp; timeout to cancel other backends on conflict</font></div><div><font size="2"   >&nbsp; -Z, --no-analyze &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;don't analyze at end</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Connection options:</font></div><div><font size="2"   >&nbsp; -d, --dbname=DBNAME &nbsp; &nbsp; &nbsp; database to connect</font></div><div><font size="2"   >&nbsp; -h, --host=HOSTNAME &nbsp; &nbsp; &nbsp; database server host or socket directory</font></div><div><font size="2"   >&nbsp; -p, --port=PORT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; database server port</font></div><div><font size="2"   >&nbsp; -U, --username=USERNAME &nbsp; user name to connect as</font></div><div><font size="2"   >&nbsp; -w, --no-password &nbsp; &nbsp; &nbsp; &nbsp; never prompt for password</font></div><div><font size="2"   >&nbsp; -W, --password &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;force password prompt</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Generic options:</font></div><div><font size="2"   >&nbsp; -e, --echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo queries</font></div><div><font size="2"   >&nbsp; -E, --elevel=LEVEL &nbsp; &nbsp; &nbsp; &nbsp;set output message level</font></div><div><font size="2"   >&nbsp; --help &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;show this help, then exit</font></div><div><font size="2"   >&nbsp; --version &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output version information, then exit</font></div><div><font size="2"   >Read the website for details. &lt;http://reorg.projects.postgresql.org/&gt;</font></div><div><font size="2"   >Report bugs to &lt;reorg-general@lists.pgfoundry.org&gt;.</font></div><p></p></pre></div><div>为了输出详细的信息,&nbsp;<span style="line-height: 28px;"   >从代码中找到pg_reorg的elevel支持的级别如下 :&nbsp;</span></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >pgut.c</font></div><div style="line-height: 28px;"   ><font size="2"   >/*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* log_required -- is elevel logically &gt;= log_min_level?</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* physical order:</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* &nbsp; DEBUG &lt; LOG &lt; INFO &lt; NOTICE &lt; WARNING &lt; ERROR &lt; FATAL &lt; PANIC</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* log_min_messages order:</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* &nbsp; DEBUG &lt; INFO &lt; NOTICE &lt; WARNING &lt; ERROR &lt; LOG &lt; FATAL &lt; PANIC</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 28px;"   ><font size="2"   >bool</font></div><div style="line-height: 28px;"   ><font size="2"   >log_required(int elevel, int log_min_level)</font></div><div style="line-height: 28px;"   ><font size="2"   >{</font></div><p></p></pre></div><div style="line-height: 28px;"   >执行reorg, 重组TEST表, 不按特定排序, 输出DEBUG级别的信息, 但是还没有postgresql的输出多 :&nbsp;</div><div style="line-height: 28px;"   >从解说中我们能看到pg_reorg其实是需要超级用户权限的, 因为需要交换pg_class的信息.</div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg931@db-172-16-3-150-&gt; pg_reorg -n -t test -d digoal -h $PGDATA -e -E DEBUG</font></div><div><font size="2"   >LOG: (query) SET statement_timeout = 0</font></div><div><font size="2"   >LOG: (query) SET search_path = pg_catalog, pg_temp, public</font></div><div><font size="2"   >LOG: (query) SET client_min_messages = warning</font></div><div><font size="2"   >LOG: (query) SELECT * FROM reorg.tables WHERE relid = $1::regclass</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:0) = test</font></div><div><span style="line-height: 28px;"   ><font size="2"   >DEBUG: ---- reorg_one_table ----</font></span></div><div><font size="2"   >DEBUG: target_name &nbsp; &nbsp;: test</font></div><div><font size="2"   >DEBUG: target_oid &nbsp; &nbsp; : 16480</font></div><div><font size="2"   >DEBUG: target_toast &nbsp; : 16483</font></div><div><font size="2"   >DEBUG: target_tidx &nbsp; &nbsp;: 16485</font></div><div><font size="2"   >DEBUG: pkid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : 16486</font></div><div><font size="2"   >DEBUG: ckid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : 0</font></div><div><font size="2"   >DEBUG: create_pktype &nbsp;: CREATE TYPE reorg.pk_16480 AS (id integer)</font></div><div><font size="2"   >DEBUG: create_log &nbsp; &nbsp; : CREATE TABLE reorg.log_16480 (id bigserial PRIMARY KEY, pk reorg.pk_16480, row test)</font></div><div><span style="line-height: 28px;"   ><font size="2"   >DEBUG: create_trigger : CREATE TRIGGER z_reorg_trigger BEFORE INSERT OR DELETE OR UPDATE ON test FOR EACH ROW EXECUTE PROCEDURE reorg.reorg_trigger('INSERT INTO reorg.log_16480(pk, row) VALUES( CASE WHEN $1 IS NULL THEN NULL ELSE (ROW($1.id)::reorg.pk_16480) END, $2)')</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >DEBUG: create_table &nbsp; : CREATE TABLE reorg.table_16480 WITH (oids=false) TABLESPACE pg_default AS SELECT id,info,crt_time FROM ONLY test</font></span></div><div><font size="2"   >DEBUG: drop_columns &nbsp; : (skipped)</font></div><div><font size="2"   >DEBUG: delete_log &nbsp; &nbsp; : DELETE FROM reorg.log_16480</font></div><div><font size="2"   >DEBUG: lock_table &nbsp; &nbsp; : LOCK TABLE test IN ACCESS EXCLUSIVE MODE</font></div><div><font size="2"   >DEBUG: sql_peek &nbsp; &nbsp; &nbsp; : SELECT * FROM reorg.log_16480 ORDER BY id LIMIT $1</font></div><div><font size="2"   >DEBUG: sql_insert &nbsp; &nbsp; : INSERT INTO reorg.table_16480 VALUES ($1.*)</font></div><div><font size="2"   >DEBUG: sql_delete &nbsp; &nbsp; : DELETE FROM reorg.table_16480 WHERE (id) = ($1.id)</font></div><div><font size="2"   >DEBUG: sql_update &nbsp; &nbsp; : UPDATE reorg.table_16480 SET (id, info, crt_time) = ($2.id, $2.info, $2.crt_time) WHERE (id) = ($1.id)</font></div><div><font size="2"   >DEBUG: sql_pop &nbsp; &nbsp; &nbsp; &nbsp;: DELETE FROM reorg.log_16480 WHERE id &lt;= $1</font></div><div><font size="2"   >DEBUG: ---- setup ----</font></div><div><font size="2"   >LOG: (query) BEGIN ISOLATION LEVEL READ COMMITTED</font></div><div><font size="2"   >LOG: (query) SET LOCAL statement_timeout = 100</font></div><div><font size="2"   >LOG: (query) LOCK TABLE test IN ACCESS EXCLUSIVE MODE</font></div><div><font size="2"   >LOG: (query) RESET statement_timeout</font></div><div><font size="2"   >LOG: (query) SELECT reorg.conflicted_triggers($1)</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:0) = 16480</font></div><div><font size="2"   >LOG: (query) CREATE TYPE reorg.pk_16480 AS (id integer)</font></div><div><font size="2"   >LOG: (query) CREATE TABLE reorg.log_16480 (id bigserial PRIMARY KEY, pk reorg.pk_16480, row test)</font></div><div><font size="2"   >LOG: (query) CREATE TRIGGER z_reorg_trigger BEFORE INSERT OR DELETE OR UPDATE ON test FOR EACH ROW EXECUTE PROCEDURE reorg.reorg_trigger('INSERT INTO reorg.log_16480(pk, row) VALUES( CASE WHEN $1 IS NULL THEN NULL ELSE (ROW($1.id)::reorg.pk_16480) END, $2)')</font></div><div><font size="2"   >LOG: (query) SELECT reorg.disable_autovacuum('reorg.log_16480')</font></div><div><font size="2"   >LOG: (query) COMMIT</font></div><div><font size="2"   >DEBUG: ---- copy tuples ----</font></div><div><font size="2"   >LOG: (query) BEGIN ISOLATION LEVEL SERIALIZABLE</font></div><div><font size="2"   >LOG: (query) SELECT set_config('work_mem', current_setting('maintenance_work_mem'), true)</font></div><div><font size="2"   >LOG: (query) SET LOCAL synchronize_seqscans = off</font></div><div><font size="2"   >LOG: (query) SELECT reorg.array_accum(virtualtransaction) FROM pg_locks WHERE locktype = 'virtualxid' AND pid &lt;&gt; pg_backend_pid() AND (virtualxid, virtualtransaction) &lt;&gt; ('1/1', '-1/0')</font></div><div><font size="2"   >LOG: (query) DELETE FROM reorg.log_16480</font></div><div><font size="2"   >LOG: (query) CREATE TABLE reorg.table_16480 WITH (oids=false) TABLESPACE pg_default AS SELECT id,info,crt_time FROM ONLY test</font></div><div><font size="2"   >LOG: (query) SELECT reorg.disable_autovacuum('reorg.table_16480')</font></div><div><font size="2"   >LOG: (query) COMMIT</font></div><div><font size="2"   >DEBUG: ---- create indexes ----</font></div><div><font size="2"   >LOG: (query) SELECT indexrelid, reorg.reorg_indexdef(indexrelid, indrelid), indisvalid, pg_get_indexdef(indexrelid) FROM pg_index WHERE indrelid = $1</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:0) = 16480</font></div><div><font size="2"   >DEBUG: [0]</font></div><div><font size="2"   >DEBUG: target_oid &nbsp; : 16489</font></div><div><font size="2"   >DEBUG: create_index : CREATE INDEX index_16489 ON reorg.table_16480 USING btree (crt_time)</font></div><div><font size="2"   >LOG: (query) CREATE INDEX index_16489 ON reorg.table_16480 USING btree (crt_time)</font></div><div><font size="2"   >DEBUG: [1]</font></div><div><font size="2"   >DEBUG: target_oid &nbsp; : 16488</font></div><div><font size="2"   >DEBUG: create_index : CREATE INDEX index_16488 ON reorg.table_16480 USING btree (info)</font></div><div><font size="2"   >LOG: (query) CREATE INDEX index_16488 ON reorg.table_16480 USING btree (info)</font></div><div><font size="2"   >DEBUG: [2]</font></div><div><font size="2"   >DEBUG: target_oid &nbsp; : 16486</font></div><div><font size="2"   >DEBUG: create_index : CREATE UNIQUE INDEX index_16486 ON reorg.table_16480 USING btree (id)</font></div><div><font size="2"   >LOG: (query) CREATE UNIQUE INDEX index_16486 ON reorg.table_16480 USING btree (id)</font></div><div><font size="2"   >LOG: (query) SELECT reorg.reorg_apply($1, $2, $3, $4, $5, $6)</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:0) = SELECT * FROM reorg.log_16480 ORDER BY id LIMIT $1</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:1) = INSERT INTO reorg.table_16480 VALUES ($1.*)</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:2) = DELETE FROM reorg.table_16480 WHERE (id) = ($1.id)</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:3) = UPDATE reorg.table_16480 SET (id, info, crt_time) = ($2.id, $2.info, $2.crt_time) WHERE (id) = ($1.id)</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:4) = DELETE FROM reorg.log_16480 WHERE id &lt;= $1</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:5) = 1000</font></div><div><font size="2"   >LOG: (query) SELECT pid FROM pg_locks WHERE locktype = 'virtualxid' AND pid &lt;&gt; pg_backend_pid() AND virtualtransaction = ANY($1)</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:0) = {}</font></div><div><font size="2"   >DEBUG: ---- swap ----</font></div><div><font size="2"   >LOG: (query) BEGIN ISOLATION LEVEL READ COMMITTED</font></div><div><font size="2"   >LOG: (query) SET LOCAL statement_timeout = 100</font></div><div><font size="2"   >LOG: (query) LOCK TABLE test IN ACCESS EXCLUSIVE MODE</font></div><div><font size="2"   >LOG: (query) RESET statement_timeout</font></div><div><font size="2"   >LOG: (query) SELECT reorg.reorg_apply($1, $2, $3, $4, $5, $6)</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:0) = SELECT * FROM reorg.log_16480 ORDER BY id LIMIT $1</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:1) = INSERT INTO reorg.table_16480 VALUES ($1.*)</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:2) = DELETE FROM reorg.table_16480 WHERE (id) = ($1.id)</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:3) = UPDATE reorg.table_16480 SET (id, info, crt_time) = ($2.id, $2.info, $2.crt_time) WHERE (id) = ($1.id)</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:4) = DELETE FROM reorg.log_16480 WHERE id &lt;= $1</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:5) = 0</font></div><div><font size="2"   >LOG: (query) SELECT reorg.reorg_swap($1)</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:0) = 16480</font></div><div><font size="2"   >LOG: (query) COMMIT</font></div><div><font size="2"   >DEBUG: ---- drop ----</font></div><div><font size="2"   >LOG: (query) BEGIN ISOLATION LEVEL READ COMMITTED</font></div><div><font size="2"   >LOG: (query) SELECT reorg.reorg_drop($1)</font></div><div><font size="2"   >LOG: &nbsp; &nbsp;(param:0) = 16480</font></div><div><font size="2"   >LOG: (query) COMMIT</font></div><div><font size="2"   >DEBUG: ---- analyze ----</font></div><div><font size="2"   >LOG: (query) BEGIN ISOLATION LEVEL READ COMMITTED</font></div><div><font size="2"   >LOG: (query) ANALYZE test</font></div><div><font size="2"   >LOG: (query) COMMIT</font></div><p></p></pre></div><div><br></div><div>postgresql输出的日志以及解说 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.618 CST,,,26833,"",52fb0c96.68d1,1,"",2014-02-12 13:54:30 CST,,0,LOG,00000,"connection received: host=[local]",,</font></div><div><font size="2"   >,,,,,,"BackendInitialize, postmaster.c:3857",""</font></div><div><font size="2"   >2014-02-12 13:54:30.619 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,2,"authentication",2014-02-12 13:54:30 CST,3/45,0,LOG,</font></div><div><font size="2"   >00000,"connection authorized: user=postgres database=digoal",,,,,,,,"PerformAuthentication, postinit.c:239",""</font></div><div><font size="2"   >2014-02-12 13:54:30.620 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,3,"idle",2014-02-12 13:54:30 CST,3/46,0,LOG,00000,"sta</font></div><div><font size="2"   >tement: SET statement_timeout = 0",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.620 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,4,"idle",2014-02-12 13:54:30 CST,3/47,0,LOG,00000,"sta</font></div><div><font size="2"   >tement: SET search_path = pg_catalog, pg_temp, public",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.621 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,5,"idle",2014-02-12 13:54:30 CST,3/48,0,LOG,00000,"sta</font></div><div><font size="2"   >tement: SET client_min_messages = warning",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.632 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,6,"SELECT",2014-02-12 13:54:30 CST,3/49,0,LOG,00000,"e</font></div><div><font size="2"   >xecute &lt;unnamed&gt;: SELECT * FROM reorg.tables WHERE relid = $1::regclass","parameters: $1 = 'test'",,,,,,,"exec_execute_message, post</font></div><div><font size="2"   >gres.c:1906","pg_reorg"</font></div><p></p></pre></div><div>打开一个事务</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.641 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,7,"idle",2014-02-12 13:54:30 CST,3/50,0,LOG,00000,"sta</font></div><div><font size="2"   >tement: BEGIN ISOLATION LEVEL READ COMMITTED",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.641 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,8,"idle in transaction",2014-02-12 13:54:30 CST,3/50,0,LOG,00000,"statement: SET LOCAL statement_timeout = 100",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><p></p></pre></div><div>短暂的对test加access exclusive mode 锁, 为了创建触发器.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.642 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,9,"idle in transaction",2014-02-12 13:54:30 CST,3/50,0,LOG,00000,"statement: LOCK TABLE test IN ACCESS EXCLUSIVE MODE",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.642 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,10,"idle in transaction",2014-02-12 13:54:30 CST,3/50,2000,LOG,00000,"statement: RESET statement_timeout",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.642 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,11,"SELECT",2014-02-12 13:54:30 CST,3/50,2000,LOG,00000,"execute &lt;unnamed&gt;: SELECT reorg.conflicted_triggers($1)","parameters: $1 = '16480'",,,,,,,"exec_execute_message, postgres.c:1906","pg_reorg"</font></div><p></p></pre></div><div>创建主键类型的中间表</div><div><pre class="prettyprint"   ><p><font size="2"   >2014-02-12 13:54:30.643 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,12,"idle in transaction",2014-02-12 13:54:30 CST,3/50,2000,LOG,00000,"statement: CREATE TYPE reorg.pk_16480 AS (id integer)",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></p></pre></div><div>创建中间日志表, 记录重组过程TEST产生的DML :&nbsp;</div><div><pre class="prettyprint"   ><p><font size="2"   >2014-02-12 13:54:30.646 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,13,"idle in transaction",2014-02-12 13:54:30 CST,3/50,2000,LOG,00000,"statement: CREATE TABLE reorg.log_16480 (id bigserial PRIMARY KEY, pk reorg.pk_16480, row test)",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></p></pre></div><div>创建触发器, 负责将重组过程产生的DML写入中间日志表.</div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.657 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,14,"idle in transaction",2014-02-12 13:54:30 CST,3/50,2000,LOG,00000,"statement: CREATE TRIGGER z_reorg_trigger BEFORE INSERT OR DELETE OR UPDATE ON test FOR EACH ROW EXECUTE PROCEDURE reorg.reorg_trigger('INSERT INTO reorg.log_16480(pk, row) VALUES( CASE WHEN $1 IS NULL THEN NULL ELSE (ROW($1.id)::reorg.pk_16480) END, $2)')",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >禁止中间日志表的自动vacuum</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.657 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,15,"idle in transaction",2014-02-12 13:54:30 CST,3/50,2000,LOG,00000,"statement: SELECT reorg.disable_autovacuum('reorg.log_16480')",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >结束事务</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.658 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,16,"idle in transaction",2014-02-12 13:54:30 CST,3/50,2000,LOG,00000,"statement: COMMIT",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >开启事务, 注意是串行隔离级别, 因为要把TEST表的结果引入中间表 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.658 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,17,"idle",2014-02-12 13:54:30 CST,3/51,0,LOG,00000,"statement: BEGIN ISOLATION LEVEL SERIALIZABLE",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.658 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,18,"idle in transaction",2014-02-12 13:54:30 CST,3/51,0,LOG,00000,"statement: SELECT set_config('work_mem', current_setting('maintenance_work_mem'), true)",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.659 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,19,"idle in transaction",2014-02-12 13:54:30 CST,3/51,0,LOG,00000,"statement: SET LOCAL synchronize_seqscans = off",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.659 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,20,"idle in transaction",2014-02-12 13:54:30 CST,3/51,0,LOG,00000,"statement: SELECT reorg.array_accum(virtualtransaction) FROM pg_locks WHERE locktype = 'virtualxid' AND pid &lt;&gt; pg_backend_pid() AND (virtualxid, virtualtransaction) &lt;&gt; ('1/1', '-1/0')",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><p></p></pre></div><div>清除中间日志表记录的截止当前已提交的DML信息, 马上就要把test表写入到一个中间表了.</div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.660 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,21,"idle in transaction",2014-02-12 13:54:30 CST,3/51,0,LOG,00000,"statement: DELETE FROM reorg.log_16480",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >把TEST表的数据导入中间表, 注意不是中间日志表哦.</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.661 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,22,"idle in transaction",2014-02-12 13:54:30 CST,3/51,0,LOG,00000,"statement: CREATE TABLE reorg.table_16480 WITH (oids=false) TABLESPACE pg_default AS SELECT id,info,crt_time FROM ONLY test",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >关闭中间表的自动VACUUM</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.746 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,23,"idle in transaction",2014-02-12 13:54:30 CST,3/51,2001,LOG,00000,"statement: SELECT reorg.disable_autovacuum('reorg.table_16480')",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.746 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,24,"idle in transaction",2014-02-12 13:54:30 CST,3/51,2001,LOG,00000,"statement: COMMIT",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><p></p></pre></div><div>获取TEST表的索引定义</div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.747 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,25,"SELECT",2014-02-12 13:54:30 CST,3/52,0,LOG,00000,"execute &lt;unnamed&gt;: SELECT indexrelid, reorg.reorg_indexdef(indexrelid, indrelid), indisvalid, pg_get_indexdef(indexrelid) FROM pg_index WHERE indrelid = $1","parameters: $1 = '16480'",,,,,,,"exec_execute_message, postgres.c:1906","pg_reorg"</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >给中间表创建和TEST表一致的索引</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.748 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,26,"idle",2014-02-12 13:54:30 CST,3/53,0,LOG,00000,"statement: CREATE INDEX index_16489 ON reorg.table_16480 USING btree (crt_time)",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.752 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,27,"idle",2014-02-12 13:54:30 CST,3/54,0,LOG,00000,"statement: CREATE INDEX index_16488 ON reorg.table_16480 USING btree (info)",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.754 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,28,"idle",2014-02-12 13:54:30 CST,3/55,0,LOG,00000,"statement: CREATE UNIQUE INDEX index_16486 ON reorg.table_16480 USING btree (id)",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><p></p></pre></div><div>把中间日志表记录的DML在中间表上执行一遍, 类似增量同步TEST表的数据到中间表.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.757 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,29,"SELECT",2014-02-12 13:54:30 CST,3/56,0,LOG,00000,"execute &lt;unnamed&gt;: SELECT reorg.reorg_apply($1, $2, $3, $4, $5, $6)","parameters: $1 = 'SELECT * FROM reorg.log_16480 ORDER BY id LIMIT $1', $2 = 'INSERT INTO reorg.table_16480 VALUES ($1.*)', $3 = 'DELETE FROM reorg.table_16480 WHERE (id) = ($1.id)', $4 = 'UPDATE reorg.table_16480 SET (id, info, crt_time) = ($2.id, $2.info, $2.crt_time) WHERE (id) = ($1.id)', $5 = 'DELETE FROM reorg.log_16480 WHERE id &lt;= $1', $6 = '1000'",,,,,,,"exec_execute_message, postgres.c:1906","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.757 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,30,"SELECT",2014-02-12 13:54:30 CST,3/57,0,LOG,00000,"execute &lt;unnamed&gt;: SELECT pid FROM pg_locks WHERE locktype = 'virtualxid' AND pid &lt;&gt; pg_backend_pid() AND virtualtransaction = ANY($:1)","parameters: $1 = '{}'",,,,,,,"exec_execute_message, postgres.c:1906","pg_reorg"</font></div><p></p></pre></div><div>开启一个事务</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.758 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,31,"idle",2014-02-12 13:54:30 CST,3/58,0,LOG,00000,"statement: BEGIN ISOLATION LEVEL READ COMMITTED",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.758 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,32,"idle in transaction",2014-02-12 13:54:30 CST,3/58,0,LOG,00000,"statement: SET LOCAL statement_timeout = 100",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><p></p></pre></div><div>再次锁TEST表, 这次要做最后一步增量同步和表交换了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.758 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,33,"idle in transaction",2014-02-12 13:54:30 CST,3/58,0,LOG,00000,"statement: LOCK TABLE test IN ACCESS EXCLUSIVE MODE",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.758 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,34,"idle in transaction",2014-02-12 13:54:30 CST,3/58,2005,LOG,00000,"statement: RESET statement_timeout",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><p></p></pre></div><div>增量应用中间日志表的数据到中间表, 完成后中间表和TEST表完全一致.</div><div><pre class="prettyprint"   ><p><font size="2"   >2014-02-12 13:54:30.758 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,35,"SELECT",2014-02-12 13:54:30 CST,3/58,2005,LOG,00000,"execute &lt;unnamed&gt;: SELECT reorg.reorg_apply($1, $2, $3, $4, $5, $6)","parameters: $1 = 'SELECT * FROM reorg.log_16480 ORDER BY id LIMIT $1', $2 = 'INSERT INTO reorg.table_16480 VALUES ($1.*)', $3 = 'DELETE FROM reorg.table_16480 WHERE (id) = ($1.id)', $4 = 'UPDATE reorg.table_16480 SET (id, info, crt_time) = ($2.id, $2.info, $2.crt_time) WHERE (id) = ($1.id)', $5 = 'DELETE FROM reorg.log_16480 WHERE id &lt;= $1', $6 = '0'",,,,,,,"exec_execute_message, postgres.c:1906","pg_reorg"</font></p></pre></div><div>交换test表和中间表, 实际上是通过服务端编程接口SPI, 交换test和中间表在pg_class的记录, 详见代码lib/reorg.c中的swap_heap_or_index_files代码.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.759 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,36,"SELECT",2014-02-12 13:54:30 CST,3/58,2005,LOG,00000,"execute &lt;unnamed&gt;: SELECT reorg.reorg_swap($1)","parameters: $1 = '16480'",,,,,,,"exec_execute_message, postgres.c:1906","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.762 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,37,"idle in transaction",2014-02-12 13:54:30 CST,3/58,2005,LOG,00000,"statement: COMMIT",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><p></p></pre></div><div>最后一步是调用<span style="line-height: 28px;"   >reorg_drop</span><span style="line-height: 28px;"   >清除中间日志表和中间表(交换后的).</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2014-02-12 13:54:30.762 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,38,"idle",2014-02-12 13:54:30 CST,3/59,0,LOG,00000,"statement: BEGIN ISOLATION LEVEL READ COMMITTED",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.762 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,39,"SELECT",2014-02-12 13:54:30 CST,3/59,0,LOG,00000,"execute &lt;unnamed&gt;: SELECT reorg.reorg_drop($1)","parameters: $1 = '16480'",,,,,,,"exec_execute_message, postgres.c:1906","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.764 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,40,"idle in transaction",2014-02-12 13:54:30 CST,3/59,2006,LOG,00000,"statement: COMMIT",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:30.906 CST,,,25235,,52fb043d.6293,14,,2014-02-12 13:18:53 CST,,0,LOG,00000,"checkpoint complete: wrote 9901 buffers (1.5%); 0 transaction log file(s) added, 0 removed, 184 recycled; write=37.489 s, sync=0.024 s, total=37.528 s; sync files=8, longest=0.015 s, average=0.003 s",,,,,,,,"LogCheckpointEnd, xlog.c:6746",""</font></div><div><font size="2"   >2014-02-12 13:54:31.396 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,41,"idle",2014-02-12 13:54:30 CST,3/60,0,LOG,00000,"statement: BEGIN ISOLATION LEVEL READ COMMITTED",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:31.397 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,42,"idle in transaction",2014-02-12 13:54:30 CST,3/60,0,LOG,00000,"statement: ANALYZE test",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:31.397 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,43,"idle in transaction",2014-02-12 13:54:30 CST,3/60,2007,LOG,00000,"statement: COMMIT",,,,,,,,"exec_simple_query, postgres.c:890","pg_reorg"</font></div><div><font size="2"   >2014-02-12 13:54:31.398 CST,"postgres","digoal",26833,"[local]",52fb0c96.68d1,44,"idle",2014-02-12 13:54:30 CST,,0,LOG,00000,"disconnection: session time: 0:00:00.780 user=postgres database=digoal host=[local]",,,,,,,,"log_disconnections, postgres.c:4429","pg_reorg"</font></div><p></p></pre></div></div><div><br></div><div>触发器代码 &nbsp;:&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >reorg_trigger</font></div><div><div><font size="2"   >digoal=# \sf+ reorg.reorg_trigger</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CREATE OR REPLACE FUNCTION reorg.reorg_trigger()</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RETURNS trigger</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LANGUAGE c</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STRICT SECURITY DEFINER</font></div><div><font size="2"   >1 &nbsp; &nbsp; &nbsp; AS '$libdir/pg_reorg', $function$reorg_trigger$function$</font></div></div><div><font size="2"   >对应的代码 :&nbsp;</font></div><div><font size="2"   >lib/reorg.c</font></div><div><div><font size="2"   >/**</font></div><div><font size="2"   >&nbsp;* @fn &nbsp; &nbsp; &nbsp;Datum reorg_trigger(PG_FUNCTION_ARGS)</font></div><div><font size="2"   >&nbsp;* @brief &nbsp; Insert a operation log into log-table.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* reorg_trigger(sql)</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @param &nbsp; &nbsp; &nbsp; sql &nbsp; &nbsp; SQL to insert a operation log into log-table.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >Datum</font></div><div><font size="2"   >reorg_trigger(PG_FUNCTION_ARGS)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >...</font></div><div><font size="2"   >略.</font></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://github.com/reorg/pg_repack"   >https://github.com/reorg/pg_repack</a></div><div>2.&nbsp;<a target="_blank" rel="nofollow" href="http://pgxn.org/dist/pg_repack/"   >http://pgxn.org/dist/pg_repack/</a></div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://reorg.projects.pgfoundry.org/pg_reorg.html"   >http://reorg.projects.pgfoundry.org/pg_reorg.html</a></div><div>4.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201063041635986/"   >http://blog.163.com/digoal@126/blog/static/163877040201063041635986/</a></div><div>5.&nbsp;src/include/storage/lock.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/* NoLock is not a lock mode, but a flag value meaning "don't get a lock" */</font></div><div><font size="2"   >#define NoLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define AccessShareLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* SELECT */</font></div><div><font size="2"   >#define RowShareLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* SELECT FOR UPDATE/FOR SHARE */</font></div><div><font size="2"   >#define RowExclusiveLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* INSERT, UPDATE, DELETE */</font></div><div><font size="2"   >#define ShareUpdateExclusiveLock 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* VACUUM (non-FULL),ANALYZE, CREATE</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* INDEX CONCURRENTLY */</font></div><div><font size="2"   >#define ShareLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* CREATE INDEX (WITHOUT CONCURRENTLY) */</font></div><div><font size="2"   >#define ShareRowExclusiveLock &nbsp; 6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* like EXCLUSIVE MODE, but allows ROW</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* SHARE */</font></div><div><font size="2"   >#define ExclusiveLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* blocks ROW SHARE/SELECT...FOR</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* UPDATE */</font></div><div><font size="2"   >#define AccessExclusiveLock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* ALTER TABLE, DROP TABLE, VACUUM</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* FULL, and unqualified LOCK TABLE */</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>