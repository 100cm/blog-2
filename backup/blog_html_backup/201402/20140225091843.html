<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL upgrade to 9.3.3 attention, upgrade standby nodes first (freeze MultiXact fix)</h2>
	<h5 id="">2014-02-25 9:18:43&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201412591843299/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>如果你有系统要升级到9.3.3, 并且使用了流复制或者log shipping这类的技术做了standby节点的话, 请务必先升级standby节点.</div><div>原因是9.3.3修改了xlog的个数, 用于修复multixact id wrapped的bug.</div><div>所以必须先升级standby, 使之兼容新的xlog格式后再升级master, 这样master产生的新的xlog格式才能被standby所解析.</div><div>如下 :&nbsp;</div><div><ul style="font-size: 12px; line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em; font-family: verdana, sans-serif;"   ><li style="font-size: 1em; line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em;"   ><p style="font-size: 1em; line-height: 1.5em; margin: 0.2em 0em 1.2em;"   >Rework tuple freezing protocol (?lvaro Herrera, Andres Freund)</p><p style="font-size: 1em; line-height: 1.5em; margin: 0.2em 0em 1.2em;"   >The logic for tuple freezing was unable to handle some cases involving freezing of&nbsp;<a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/routine-vacuuming.html#VACUUM-FOR-MULTIXACT-WRAPAROUND"   ><i>multixact</i>&nbsp;IDs</a>, with the practical effect that shared row-level locks might be forgotten once old enough.</p><p style="font-size: 1em; line-height: 1.5em; margin: 0.2em 0em 1.2em;"   >Fixing this required changing the WAL record format for tuple freezing. While this is no issue for standalone servers, when using replication it means that&nbsp;<span style="font-weight: bold;"   >standby servers must be upgraded to 9.3.3 or later before their masters are</span>. An older standby will be unable to interpret freeze records generated by a newer master, and will fail with a PANIC message. (In such a case, upgrading the standby should be sufficient to let it resume execution.)</p></li></ul></div><div>PostgreSQL 9.3.3 新增autovacuum freeze multixact 的参数以及配置建议 :&nbsp;</div><div><ul style="font-size: 12px; line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em; font-family: verdana, sans-serif;"   ><li style="font-size: 1em; line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em;"   ><p style="font-size: 1em; line-height: 1.5em; margin: 0.2em 0em 1.2em;"   >Create separate GUC parameters to control multixact freezing (?lvaro Herrera)</p><p style="font-size: 1em; line-height: 1.5em; margin: 0.2em 0em 1.2em;"   >9.3 requires multixact tuple labels to be frozen before they grow too old, in the same fashion as plain transaction ID labels have been frozen for some time. Previously, the transaction ID freezing parameters were used for multixact IDs too; but since the consumption rates of transaction IDs and multixact IDs can be quite different, this did not work very well. Introduce new settings&nbsp;<a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE"   >vacuum_multixact_freeze_min_age</a>,&nbsp;<a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE"   >vacuum_multixact_freeze_table_age</a>, and&nbsp;<a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE"   >autovacuum_multixact_freeze_max_age</a>&nbsp;to control when to freeze multixacts.</p></li></ul></div><div><h3 style="font-size: 1.1em; margin: 2ex 0em 1.2em; color: rgb(102, 102, 102); font-family: verdana, sans-serif; line-height: normal;"   ><a id="VACUUM-FOR-MULTIXACT-WRAPAROUND" name="VACUUM-FOR-MULTIXACT-WRAPAROUND" rel="nofollow"   >23.1.5.1. Multixacts and Wraparound</a></h3><p style="font-size: 12px; line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ><i>Multixact IDs</i>&nbsp;are used to support row locking by multiple transactions. Since there is only limited space in a tuple header to store lock information, that information is encoded as a<span>"multiple transaction ID"</span>, or multixact ID for short, whenever there is more than one transaction concurrently locking a row. Information about which transaction IDs are included in any particular multixact ID is stored separately in the&nbsp;<tt>pg_multixact</tt>&nbsp;subdirectory, and only the multixact ID appears in the&nbsp;<tt>xmax</tt>&nbsp;field in the tuple header. Like transaction IDs, multixact IDs are implemented as a 32-bit counter and corresponding storage, all of which requires careful aging management, storage cleanup, and wraparound handling.</p><p style="font-size: 12px; line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   >During a&nbsp;<tt>VACUUM</tt>&nbsp;table scan, either partial or of the whole table, any multixact ID older than&nbsp;<a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE"   >vacuum_multixact_freeze_min_age</a>&nbsp;is replaced by a different value, which can be the zero value, a single transaction ID, or a newer multixact ID. For each table,&nbsp;<tt>pg_class</tt>.<tt>relminmxid</tt>&nbsp;stores the oldest possible multixact ID still appearing in any tuple of that table. If this value is older than&nbsp;<a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE"   >vacuum_multixact_freeze_table_age</a>, a whole-table scan is forced. Whole-table&nbsp;<tt>VACUUM</tt>&nbsp;scans, regardless of what causes them, enable advancing the value for that table. Eventually, as all tables in all databases are scanned and their oldest multixact values are advanced, on-disk storage for older multixacts can be removed.</p><p style="font-size: 12px; line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   >As a safety device, a whole-table vacuum scan will occur for any table whose multixact-age is greater than&nbsp;<a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE"   >autovacuum_multixact_freeze_max_age</a>. This will occur even if autovacuum is nominally disabled.</p></div><div><br></div><div>multixact id 在行的头部xmax以32比特位表示, 同时在t_infomask掩码中包含一位来表示.</div><div>src/include/access/htup_details.h</div><div><pre class="prettyprint"   ><p></p><div><div><span style="line-height: 28px;"   ><font size="2"   >typedef struct HeapTupleFields</font></span></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId t_xmin; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* inserting xact ID */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId t_xmax; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* deleting or locking xact ID */</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* information stored in t_infomask:</font></div><div><font size="2"   >&nbsp;*/</font></div></div><div><font size="2"   >#define HEAP_XMAX_IS_MULTI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x1000 &nbsp;/* t_xmax is a MultiXactId */</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>