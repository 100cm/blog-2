<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Lua code compilation</h2>
	<h5 id="">2014-02-19 10:21:24&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020141199432560/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">Lua 虽然是脚本解释语言, 在运行前需要预编译, 同时lua还支持代码预加载操作, 预编译操作等.&nbsp;<div><div>在lua代码中 &nbsp;1. 使用load可以将文本转换成匿名函数, &nbsp;2. 使用loadfile可以将外部文件转换成匿名函数. 3. 匿名函数可以赋予给一个变量然后调用, 或者直接使用()调用.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&gt; a=1</font></div><div><font size="2"   >&gt; load("a=a+1 print(a)") ()</font></div><div><font size="2"   >2</font></div></div><div><div><font size="2"   >&gt; f=load("a=a+1 print(a)")</font></div><div><font size="2"   >&gt; f()</font></div><div><font size="2"   >3</font></div></div><p></p></pre></div><div><br></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >load("a = a+1")</font></div><div><font size="2"   >效果"等同"于</font></div><div><font size="2"   >function () a = a+1 end</font></div><p></p></pre></div><div>但实际上是有差别的, &nbsp;1. load的效率远低于直接定义函数, &nbsp;2. 另外, LOAD是有全局环境.</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; do&nbsp;</font></div><div><font size="2"   >&gt;&gt; a = 100</font></div><div><font size="2"   >&gt;&gt; local a = 1</font></div><div><font size="2"   >&gt;&gt; f1 = function () a=a+1 print("1:" .. a) end</font></div><div><font size="2"   >&gt;&gt; f1()</font></div><div><font size="2"   >&gt;&gt; f2 = load("a=a+1 print(a)")</font></div><div><font size="2"   >&gt;&gt; f2()</font></div><div><font size="2"   >&gt;&gt; end</font></div><div><font size="2"   >1:2 &nbsp;-- f1输出本地变量的值</font></div><div><font size="2"   >101 &nbsp;-- f2输出全局变量的值</font></div><p></p></pre></div><div><br></div><div>注意, load和loadfile期望文本为chunk内容, 如果是表达式的话, 可在表达式前添加return返回表达式的值.&nbsp;</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><span style="line-height: 28px;"   ><font size="2"   >&gt; f = load("a")</font></span></div><div><font size="2"   >&gt; print (f)</font></div><div><font size="2"   >nil</font></div><div><font size="2"   >&gt; f()</font></div><div><font size="2"   >stdin:1: attempt to call global 'f' (a nil value)</font></div><div><font size="2"   >stack traceback:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; stdin:1: in main chunk</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; [C]: in ?</font></div></div><div><font size="2"   >改成 :&nbsp;</font></div><div><div><font size="2"   >&gt; f = load("return a")  -- 返回表达式的值</font></div><div><font size="2"   >&gt; f()</font></div><div><font size="2"   >&gt; print(f())</font></div><div><font size="2"   >nil</font></div></div><p></p></pre></div><div><br></div><div>load和loadfile只是预加载代码, 并不会执行它, 只有执行了这个匿名函数后, 里面的代码才会得以执行.&nbsp;</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; f1 = load("f2 = function() a=99 print(a) end")</font></div><div><font size="2"   >&gt; f2() &nbsp;-- 直接调用f2是不行的, 因为f1还没有执行.</font></div><div><font size="2"   >stdin:1: attempt to call global 'f2' (a nil value)</font></div><div><font size="2"   >stack traceback:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; stdin:1: in main chunk</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; [C]: in ?</font></div><div><font size="2"   >&gt; f1() &nbsp;-- f1被调用后, f2函数就存在了.</font></div><div><font size="2"   >&gt; f2()</font></div><div><font size="2"   >99</font></div><div><font size="2"   >&gt; f3 = load("b=0") &nbsp;-- b的定义同样要在f3函数调用后才会被执行</font></div><div><font size="2"   >&gt; print(b)</font></div><div><font size="2"   >nil</font></div><div><font size="2"   >&gt; f3()</font></div><div><font size="2"   >&gt; print(b)</font></div><div><font size="2"   >0</font></div><p></p></pre></div><div><br></div><div>load和loadfile不检查文本的内容, 如果非法的话, 返回nil, 同时输出错误信息.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&gt; print(load("err"))</font></div><div><font size="2"   >nil &nbsp; &nbsp; [string "err"]:1: syntax error near &lt;eof&gt;</font></div></div><div><div><font size="2"   >&gt; f = load("err")</font></div><div><font size="2"   >&gt; print(f)</font></div><div><font size="2"   >nil</font></div></div><p></p></pre></div><div>使用assert函数可以判断load和loadfile加载的内容是否正确(是否为nil), 如果为nil的话, 返回错误.</div></div><div>详见末尾assert的介绍.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; assert( load("err") )</font></div><div><font size="2"   >stdin:1: [string "err"]:1: syntax error near &lt;eof&gt;</font></div><div><font size="2"   >stack traceback:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; [C]: in function 'assert'</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; stdin:1: in main chunk</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; [C]: in ?</font></div><p></p></pre></div><div>如果正确则返回参数值(匿名函数)</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; f = assert( load("a=1 print(a)") )</font></div><div><font size="2"   >&gt; print(f)</font></div><div><font size="2"   >function: 0x204eae0</font></div><div><font size="2"   >&gt; f()</font></div><div><font size="2"   >1</font></div><p></p></pre></div><div><br></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&gt; assert(nil)</font></div><div><font size="2"   >stdin:1: assertion failed!</font></div><div><font size="2"   >stack traceback:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; [C]: in function 'assert'</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; stdin:1: in main chunk</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; [C]: in ?</font></div><div><font size="2"   >&gt; assert(nil,"nihao")</font></div><div><font size="2"   >stdin:1: nihao</font></div><div><font size="2"   >stack traceback:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; [C]: in function 'assert'</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; stdin:1: in main chunk</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; [C]: in ?</font></div></div><div><div><font size="2"   >&gt; = assert(1,"nihao")</font></div><div><font size="2"   >1 &nbsp; &nbsp; &nbsp; nihao</font></div><div><font size="2"   >&gt; a = assert(1,"nihao")</font></div><div><font size="2"   >&gt; print(a)</font></div><div><font size="2"   >1</font></div></div><p></p></pre></div><div><br></div><div>dofile是对loadfile封装后调用这个匿名函数 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >function dofile (filename)</font></div><div><font size="2"   >&nbsp; local f = assert(loadfile(filename))</font></div><div><font size="2"   >&nbsp; return f()</font></div><div><font size="2"   >end</font></div><p></p></pre></div><div><br></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; do</font></div><div><font size="2"   >&gt;&gt; print ("enter function to be plotted (with variable 'x'):")</font></div><div><font size="2"   >&gt;&gt; local l = io.read()</font></div><div><font size="2"   >&gt;&gt; local f = assert(load("local x = ...; return " .. l))</font></div><div><font size="2"   >&gt;&gt; for i=1,20 do</font></div><div><font size="2"   >&gt;&gt; &nbsp; print( string.rep("*", f(i)) )</font></div><div><font size="2"   >&gt;&gt; end</font></div><div><font size="2"   >&gt;&gt; end</font></div><div><font size="2"   >enter function to be plotted (with variable 'x'):</font></div><div><font size="2"   >x  -- 输入x</font></div><div><font size="2"   >*</font></div><div><font size="2"   >**</font></div><div><font size="2"   >***</font></div><div><font size="2"   >****</font></div><div><font size="2"   >*****</font></div><div><font size="2"   >******</font></div><div><font size="2"   >*******</font></div><div><font size="2"   >********</font></div><div><font size="2"   >*********</font></div><div><font size="2"   >**********</font></div><div><font size="2"   >***********</font></div><div><font size="2"   >************</font></div><div><font size="2"   >*************</font></div><div><font size="2"   >**************</font></div><div><font size="2"   >***************</font></div><div><font size="2"   >****************</font></div><div><font size="2"   >*****************</font></div><div><font size="2"   >******************</font></div><div><font size="2"   >*******************</font></div><div><font size="2"   >********************</font></div><p></p></pre></div><div>string.rep($1, $2) 将$1复制$2遍. 如string.rep("*", 10) 复制星号10遍.</div><div><br></div><div>load可以使用reader函数作为参数, 从reader函数读取输入, 直到输入为nil.</div><div>例如load(io.lines(filename, "*L"))</div><div>这里的io.lines(filename, "*L") 返回一个reader函数, 调用这个函数从文件中每次读取1行.</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020141188350795/"   >http://blog.163.com/digoal@126/blog/static/16387704020141188350795/</a></div><div>load使用reader函数作为参数时, 从reader输入直到nil.</div><div>所以<span style="line-height: 28px;"   >load(io.lines(filename, "*L")) 和 loadfile("filename")效果是一样的.</span></div><br><div>参考 :&nbsp;</div><div><h3 style="font-family: Verdana, Geneva, sans-serif; font-weight: normal; padding-left: 0.5em; border-left-style: solid; border-left-color: rgb(208, 208, 255); border-left-width: 1em; line-height: normal; text-align: justify;"   ><a style="background-color: rgb(248, 248, 248); padding: 8px; border: 2px solid rgb(160, 160, 160); border-top-left-radius: 8px; border-top-right-radius: 8px; border-bottom-right-radius: 8px; border-bottom-left-radius: 8px;" name="pdf-load" rel="nofollow"   ><code style="font-size: inherit; font-family: inherit;"   >load (ld [, source [, mode [, env]]])</code></a></h3><p style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   >Loads a chunk.</p><p style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   >If&nbsp;<code style="font-size: 12pt;"   >ld</code>&nbsp;is a string, the chunk is this string. If&nbsp;<code style="font-size: 12pt;"   >ld</code>&nbsp;is a function,&nbsp;<code style="font-size: 12pt;"   >load</code>&nbsp;calls it repeatedly to get the chunk pieces. Each call to&nbsp;<code style="font-size: 12pt;"   >ld</code>&nbsp;must return a string that concatenates with previous results. A return of an empty string,&nbsp;<b>nil</b>, or no value signals the end of the chunk.</p><p style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   >If there are no syntactic errors, returns the compiled chunk as a function; otherwise, returns&nbsp;<b>nil</b>&nbsp;plus the error message.</p><p style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   >If the resulting function has upvalues, the first upvalue is set to the value of&nbsp;<code style="font-size: 12pt;"   >env</code>, if that parameter is given, or to the value of the global environment. (When you load a main chunk, the resulting function will always have exactly one upvalue, the&nbsp;<code style="font-size: 12pt;"   >_ENV</code>&nbsp;variable (see&nbsp;<a style="color: rgb(0, 0, 128); background-color: inherit; text-decoration: none;" rel="nofollow" href="http://www.lua.org/manual/5.2/manual.html#2.2"   >§2.2</a>). When you load a binary chunk created from a function (see&nbsp;<a style="color: rgb(0, 0, 128); background-color: inherit; text-decoration: none;" rel="nofollow" href="http://www.lua.org/manual/5.2/manual.html#pdf-string.dump"   ><code style="font-size: 12pt;"   >string.dump</code></a>), the resulting function can have arbitrary upvalues.)</p><p style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   ><code style="font-size: 12pt;"   >source</code>&nbsp;is used as the source of the chunk for error messages and debug information (see&nbsp;<a style="color: rgb(0, 0, 128); background-color: inherit; text-decoration: none;" rel="nofollow" href="http://www.lua.org/manual/5.2/manual.html#4.9"   >§4.9</a>). When absent, it defaults to&nbsp;<code style="font-size: 12pt;"   >ld</code>, if&nbsp;<code style="font-size: 12pt;"   >ld</code>&nbsp;is a string, or to "<code style="font-size: 12pt;"   >=(load)</code>" otherwise.</p><p style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   >The string&nbsp;<code style="font-size: 12pt;"   >mode</code>&nbsp;controls whether the chunk can be text or binary (that is, a precompiled chunk). It may be the string "<code style="font-size: 12pt;"   >b</code>" (only binary chunks), "<code style="font-size: 12pt;"   >t</code>" (only text chunks), or "<code style="font-size: 12pt;"   >bt</code>" (both binary and text). The default is "<code style="font-size: 12pt;"   >bt</code>".</p><p style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   ></p><h3 style="font-family: Verdana, Geneva, sans-serif; font-weight: normal; padding-left: 0.5em; border-left-style: solid; border-left-color: rgb(208, 208, 255); border-left-width: 1em; line-height: normal; text-align: justify;"   ><a name="pdf-loadfile" rel="nofollow"   >loadfile ([filename [, mode [, env]]])</a></h3><p style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   >Similar to&nbsp;<a style="color: rgb(0, 0, 128); background-color: inherit; text-decoration: none;" rel="nofollow" href="http://www.lua.org/manual/5.2/manual.html#pdf-load"   ><code style="font-size: 12pt;"   >load</code></a>, but gets the chunk from file&nbsp;<code style="font-size: 12pt;"   >filename</code>&nbsp;or from the standard input, if no file name is given.</p></div><h3 style="font-family: Verdana, Geneva, sans-serif; font-weight: normal; padding-left: 0.5em; border-left-style: solid; border-left-color: rgb(208, 208, 255); border-left-width: 1em; line-height: normal; text-align: justify;"   ><a name="pdf-assert" rel="nofollow"   >assert (v [, message])</a></h3><span style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   >Issues an error when the value of its argument&nbsp;</span><code style="font-size: medium; line-height: normal; text-align: justify;"   >v</code><span style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   >&nbsp;is false (i.e.,&nbsp;</span><b style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   >nil</b><span style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   >&nbsp;or&nbsp;</span><b style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   >false</b><span style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   >); otherwise, returns all its arguments.&nbsp;</span><code style="font-size: medium; line-height: normal; text-align: justify;"   >message</code><span style="font-family: Helvetica, Arial, sans-serif; font-size: medium; line-height: normal; text-align: justify;"   >&nbsp;is an error message; when absent, it defaults to "assertion failed!"</span></div>
	</div>
</div>
</body>
</html>