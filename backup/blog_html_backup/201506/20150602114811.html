<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Add label type & operators & indexAM for PostgreSQL (like full text search) ?</h2>
	<h5 id="">2015-06-02 11:48:11&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201552102814822/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>用户画像在数据挖掘中是一种比较常见的应用，例如根据用户的访问行为，地理位置，基本属性等信息，分析后给用户贴上各种标签。有了这种数据之后，可以结合业务数据为运营提供参考，例如某个商品或游戏的人群分布情况；也可以为运营提供运营策略支持等。</div><div>标签系统的常见操作：</div><div>1. 选出带有某些标签的人群，并按照标签权重排序。</div><div>2. 选出多种标签组合的人群（例如包含某些标签，并且不包含某些标签）</div><div><br></div><div>标签系统和PostgreSQL的全文检索类型非常类似。</div><div>全文检索将分词和查询组合分为两种数据类型，</div><div>tsvector - 分词类型存储文本分析后的有意义的词语+位置信息+权重（其实不应该叫权重，应该叫文本层次）；</div><div>tsquery - 查询组合就是查询条件的组合，例如包含哪些分词，不包含哪些分词，还支持规则表达式。</div><div><br></div><div>全文检索包括几个重要的步骤：</div><div>1. parsers将文本按照一定的规则分拆成多个token，并且给token按类型归类例如（url, word, number, file, tag, version .....)。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE TEXT SEARCH PARSER name (</font></div><div><font size="2"   >&nbsp; &nbsp; START = start_function ,</font></div><div><font size="2"   >&nbsp; &nbsp; GETTOKEN = gettoken_function ,</font></div><div><font size="2"   >&nbsp; &nbsp; END = end_function ,</font></div><div><font size="2"   >&nbsp; &nbsp; LEXTYPES = lextypes_function</font></div><div><font size="2"   >&nbsp; &nbsp; [, HEADLINE = headline_function ]</font></div><div><font size="2"   >)</font></div><p></p></pre></div><div>2. dictionaries将token转换为规则化的分词（即lexeme）（例如去除复数，大小写转换），同时去除一些没有意义的词如stop word。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >CREATE TEXT SEARCH DICTIONARY name (</font></div><div><font size="2"   >&nbsp; &nbsp; TEMPLATE = template</font></div><div><font size="2"   >&nbsp; &nbsp; [, option = value [, ... ]]</font></div><div><font size="2"   >)</font></div></div><div><div><font size="2"   >CREATE TEXT SEARCH DICTIONARY my_russian (</font></div><div><font size="2"   >&nbsp; &nbsp; template = snowball,</font></div><div><font size="2"   >&nbsp; &nbsp; language = russian,</font></div><div><font size="2"   >&nbsp; &nbsp; stopwords = myrussian</font></div><div><font size="2"   >);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >ALTER TEXT SEARCH DICTIONARY name (</font></div><div><font size="2"   >&nbsp; &nbsp; option [ = value ] [, ... ]</font></div><div><font size="2"   >)</font></div></div><div><div><font size="2"   >The following example command changes the stopword list for a Snowball-based dictionary. Other parameters remain unchanged.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >ALTER TEXT SEARCH DICTIONARY my_dict ( StopWords = newrussian );</font></div><div><font size="2"   >The following example command changes the language option to dutch, and removes the stopword option entirely.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >ALTER TEXT SEARCH DICTIONARY my_dict ( language = dutch, StopWords );</font></div></div><p></p></pre></div><div>3.&nbsp;templates提供dictionaries下层的功能，创建字典时需指定一个模板，以及一些参数。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE TEXT SEARCH TEMPLATE name (</font></div><div><font size="2"   >&nbsp; &nbsp; [ INIT = init_function , ]</font></div><div><font size="2"   >&nbsp; &nbsp; LEXIZE = lexize_function</font></div><div><font size="2"   >)</font></div><p></p></pre></div><div>4.&nbsp;configurations选择一个parser，并配置token类型和字典的对应关系（如每种token type用哪些字典来处理)。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >CREATE TEXT SEARCH CONFIGURATION name (</font></div><div><font size="2"   >&nbsp; &nbsp; PARSER = parser_name |</font></div><div><font size="2"   >&nbsp; &nbsp; COPY = source_config</font></div><div><font size="2"   >)</font></div></div><div><div><font size="2"   >ALTER TEXT SEARCH CONFIGURATION name</font></div><div><font size="2"   >&nbsp; &nbsp; ADD MAPPING FOR token_type [, ... ] WITH dictionary_name [, ... ]</font></div><div><font size="2"   >ALTER TEXT SEARCH CONFIGURATION name</font></div><div><font size="2"   >&nbsp; &nbsp; ALTER MAPPING FOR token_type [, ... ] WITH dictionary_name [, ... ]</font></div><div><font size="2"   >ALTER TEXT SEARCH CONFIGURATION name</font></div><div><font size="2"   >&nbsp; &nbsp; ALTER MAPPING REPLACE old_dictionary WITH new_dictionary</font></div><div><font size="2"   >ALTER TEXT SEARCH CONFIGURATION name</font></div><div><font size="2"   >&nbsp; &nbsp; ALTER MAPPING FOR token_type [, ... ] REPLACE old_dictionary WITH new_dictionary</font></div><div><font size="2"   >ALTER TEXT SEARCH CONFIGURATION name</font></div><div><font size="2"   >&nbsp; &nbsp; DROP MAPPING [ IF EXISTS ] FOR token_type [, ... ]</font></div><div><font size="2"   >ALTER TEXT SEARCH CONFIGURATION name RENAME TO new_name</font></div><div><font size="2"   >ALTER TEXT SEARCH CONFIGURATION name OWNER TO { new_owner | CURRENT_USER | SESSION_USER }</font></div><div><font size="2"   >ALTER TEXT SEARCH CONFIGURATION name SET SCHEMA new_schema</font></div></div><p></p></pre></div><div>全文检索类型的限制：</div><div><div>1. The length of each lexeme must be less than 2K bytes</div><div>规则化后的lexeme必须要与2K，</div><div>2. The length of a tsvector (lexemes + positions) must be less than 1 megabyte</div><div>tsvector类型长度不超过1MB。</div><div>这两个限制见src/include/tsearch/ts_type.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >typedef struct</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint32</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haspos:1,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len:11, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* MAX 2Kb */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos:20; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* MAX 1Mb */</font></div><div><font size="2"   >} WordEntry;</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >3. The number of lexemes must be less than 2^64</span></div><div><span style="line-height: 28px;"   >一个tsvector中不能存储超过2的64次方个lexeme.</span></div><div><span style="line-height: 28px;"   >4. Position values in tsvector must be greater than 0 and no more than 16,383</span></div><div>位置值不超过</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >#define MAXENTRYPOS (1&lt;&lt;14)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >。。。</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (res - a &gt;= MAXNUMPOS - 1 ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WEP_GETPOS(*res) == MAXENTRYPOS - 1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div></div><div><font size="2"   >。。。</font></div><p></p></pre></div><div>5. No more than 256 positions per lexeme</div><div>每个lexeme不能超过256个位置。</div><pre class="prettyprint"   ><p></p><div><font size="2"   >#define MAXNUMPOS &nbsp; &nbsp; &nbsp; (256)</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >6. The number of nodes (lexemes + operators) in a tsquery must be less than 32,768</span></div></div><div>tsquery，<span style="line-height: 28px;"   >lexeme和operators累计不能</span><span style="line-height: 28px;"   >超过</span><span style="line-height: 28px;"   >32,768个。</span></div><div><br></div><div>根据标签系统的特性，以及标签系统的常用操作，我们如果要创建一个标签数据类型，应该注意哪些呢？</div><div>1. 同样我们应该包含两个类型，一个用来表示标签，一个用来表示查询条件</div><div>1.1. 标签+权重，每个标签应该有权重信息，例如数字越大权重越大。</div><div>1.2. 标签+权重组合描述查询条件，例如'x:&gt;1' || ( 'y:&lt;10' &amp;&amp; 'z' ) 表述包含权重大于1的X标签，或者包含权重小于10的y标签与不关心权重的Z标签。</div><div>2. 操作符，可以添加，替换，删除标签，修改查询条件等。</div><div>3. 函数</div><div>4. 聚合函数</div><div>5. 窗口函数</div><div>6. 索引</div><div>产生标签的算法不在本文讨论范围，可以考虑使用外部算法，或者在PostgreSQL中结合PL/R实现。</div><wbr><div><br></div>[参考]&nbsp;<div>1.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/textsearch-intro.html"   >http://www.postgresql.org/docs/devel/static/textsearch-intro.html</a>&nbsp;<div>2. src/include/tsearch/ts_type.h
<br></div></div><div>3. src/backend/utils/adt/tsvector.c</div><div>4. src/backend/utils/adt/tsquery.c</div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="Add label type  operators  indexAM for PostgreSQL (like full text search) ? - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>