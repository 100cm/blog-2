<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL pk,uk,check constraint ERROR, error tuple will insert and need vacuum?</h2>
	<h5 id="">2015-06-04 12:51:14&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020155403321739/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 是通过索引来保证唯一值约束的，（包括PKEY）。</div><div>但是，如果遇到唯一约束问题，HEAP和BTREE页里的数据会不会有垃圾呢?</div><div>SESSION A:</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table pk_test(id int primary key);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >Time: 51.559 ms</font></div><div><font size="2"   >digoal=&gt; begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >Time: 0.103 ms</font></div><div><font size="2"   >digoal=&gt; insert into pk_test values (1);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >Time: 0.565 ms</font></div><p></p></pre></div><div><br></div><div>SESSION B:</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=&gt; insert into pk_test values (1);</font></div><p></p></pre></div><div><br></div><div>SESSION C:</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=&gt; insert into pk_test values (1);</font></div><p></p></pre></div><div><br></div><div>观察有无行锁：</div><div>显然没有，因为不是靠锁来保证唯一。而且插入也不需要行锁，因为未提交的记录其他会话是看不到的，也不可能来查询或更新，没有加锁的必要。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create extension pgrowlocks;</font></div><div><font size="2"   >CREATE EXTENSION</font></div></div><div><div><font size="2"   >digoal=# select * from pgrowlocks('pk_test');</font></div><div><font size="2"   >&nbsp;locked_row | locker | multi | xids | modes | pids&nbsp;</font></div><div><font size="2"   >------------+--------+-------+------+-------+------</font></div><div><font size="2"   >(0 rows)</font></div></div><p></p></pre></div><div><br></div><div>观察对象锁等待：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create or replace function f_lock_level(i_mode text) returns int as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; case i_mode</font></div><div><font size="2"   >&nbsp; &nbsp; when 'INVALID' then return 0;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'AccessShareLock' then return 1;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'RowShareLock' then return 2;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'RowExclusiveLock' then return 3;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ShareUpdateExclusiveLock' then return 4;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ShareLock' then return 5;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ShareRowExclusiveLock' then return 6;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ExclusiveLock' then return 7;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'AccessExclusiveLock' then return 8;</font></div><div><font size="2"   >&nbsp; &nbsp; else return 0;</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >end;&nbsp;</font></div><div><font size="2"   >$$ language plpgsql strict;</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# with t_wait as &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >(select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.objid,a.objsubid,</font></div><div><font size="2"   >a.pid,a.virtualtransaction,a.virtualxid,a,transactionid,b.query,b.xact_start,b.query_start,</font></div><div><font size="2"   >b.usename,b.datname from pg_locks a,pg_stat_activity b where a.pid=b.pid and not a.granted),</font></div><div><font size="2"   >t_run as&nbsp;</font></div><div><font size="2"   >(select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.objid,a.objsubid,</font></div><div><font size="2"   >a.pid,a.virtualtransaction,a.virtualxid,a,transactionid,b.query,b.xact_start,b.query_start,</font></div><div><font size="2"   >b.usename,b.datname from pg_locks a,pg_stat_activity b where a.pid=b.pid and a.granted)&nbsp;</font></div><div><font size="2"   >select r.locktype,r.mode r_mode,r.usename r_user,r.datname r_db,r.relation::regclass,r.pid r_pid,</font></div><div><font size="2"   >r.page r_page,r.tuple r_tuple,r.xact_start r_xact_start,r.query_start r_query_start,</font></div><div><font size="2"   >now()-r.query_start r_locktime,r.query r_query,w.mode w_mode,w.pid w_pid,w.page w_page,</font></div><div><font size="2"   >w.tuple w_tuple,w.xact_start w_xact_start,w.query_start w_query_start,</font></div><div><font size="2"   >now()-w.query_start w_locktime,w.query w_query &nbsp;</font></div><div><font size="2"   >from t_wait w,t_run r where</font></div><div><font size="2"   >&nbsp; r.locktype is not distinct from w.locktype and</font></div><div><font size="2"   >&nbsp; r.database is not distinct from w.database and</font></div><div><font size="2"   >&nbsp; r.relation is not distinct from w.relation and</font></div><div><font size="2"   >&nbsp; r.page is not distinct from w.page and</font></div><div><font size="2"   >&nbsp; r.tuple is not distinct from w.tuple and</font></div><div><font size="2"   >&nbsp; r.classid is not distinct from w.classid and</font></div><div><font size="2"   >&nbsp; r.objid is not distinct from w.objid and</font></div><div><font size="2"   >&nbsp; r.objsubid is not distinct from w.objsubid and</font></div><div><font size="2"   >&nbsp; r.transactionid is not distinct from w.transactionid and</font></div><div><font size="2"   >&nbsp; r.pid &lt;&gt; w.pid</font></div><div><font size="2"   >&nbsp; order by f_lock_level(w.mode)+f_lock_level(r.mode) desc,r.xact_start;</font></div></div><p></p></pre></div><div><div>可以看到B,C会话正在等待transactionid锁，是由于约束检测造成的。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >-[ RECORD 1 ]-+--------------------------------</font></div><div><font size="2"   >locktype &nbsp; &nbsp; &nbsp;| transactionid</font></div><div><font size="2"   >r_mode &nbsp; &nbsp; &nbsp; &nbsp;| ExclusiveLock</font></div><div><font size="2"   >r_user &nbsp; &nbsp; &nbsp; &nbsp;| digoal</font></div><div><font size="2"   >r_db &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| digoal</font></div><div><font size="2"   >relation &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >r_pid &nbsp; &nbsp; &nbsp; &nbsp; | 24785</font></div><div><font size="2"   >r_page &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >r_tuple &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >r_xact_start &nbsp;| 2015-06-04 12:27:53.475664+08</font></div><div><font size="2"   >r_query_start | 2015-06-04 12:28:00.13671+08</font></div><div><font size="2"   >r_locktime &nbsp; &nbsp;| 00:00:43.79604</font></div><div><font size="2"   >r_query &nbsp; &nbsp; &nbsp; | insert into pk_test values (1);</font></div><div><font size="2"   >w_mode &nbsp; &nbsp; &nbsp; &nbsp;| ShareLock</font></div><div><font size="2"   >w_pid &nbsp; &nbsp; &nbsp; &nbsp; | 7536</font></div><div><font size="2"   >w_page &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >w_tuple &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >w_xact_start &nbsp;| 2015-06-04 12:28:19.256706+08</font></div><div><font size="2"   >w_query_start | 2015-06-04 12:28:21.89269+08</font></div><div><font size="2"   >w_locktime &nbsp; &nbsp;| 00:00:22.04006</font></div><div><font size="2"   >w_query &nbsp; &nbsp; &nbsp; | insert into pk_test values (1);</font></div><div><font size="2"   >-[ RECORD 2 ]-+--------------------------------</font></div><div><font size="2"   >locktype &nbsp; &nbsp; &nbsp;| transactionid</font></div><div><font size="2"   >r_mode &nbsp; &nbsp; &nbsp; &nbsp;| ExclusiveLock</font></div><div><font size="2"   >r_user &nbsp; &nbsp; &nbsp; &nbsp;| digoal</font></div><div><font size="2"   >r_db &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| digoal</font></div><div><font size="2"   >relation &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >r_pid &nbsp; &nbsp; &nbsp; &nbsp; | 24785</font></div><div><font size="2"   >r_page &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >r_tuple &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >r_xact_start &nbsp;| 2015-06-04 12:27:53.475664+08</font></div><div><font size="2"   >r_query_start | 2015-06-04 12:28:00.13671+08</font></div><div><font size="2"   >r_locktime &nbsp; &nbsp;| 00:00:43.79604</font></div><div><font size="2"   >r_query &nbsp; &nbsp; &nbsp; | insert into pk_test values (1);</font></div><div><font size="2"   >w_mode &nbsp; &nbsp; &nbsp; &nbsp;| ShareLock</font></div><div><font size="2"   >w_pid &nbsp; &nbsp; &nbsp; &nbsp; | 7411</font></div><div><font size="2"   >w_page &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >w_tuple &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >w_xact_start &nbsp;| 2015-06-04 12:28:10.211724+08</font></div><div><font size="2"   >w_query_start | 2015-06-04 12:28:12.188666+08</font></div><div><font size="2"   >w_locktime &nbsp; &nbsp;| 00:00:31.744084</font></div><div><font size="2"   >w_query &nbsp; &nbsp; &nbsp; | insert into pk_test values (1);</font></div><p></p></pre></div></div><div>结束会话a, B,C报错。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SESSION A:</font></div><div><div><font size="2"   >digoal=&gt; end;</font></div><div><font size="2"   >COMMIT</font></div><div><font size="2"   >Time: 0.235 ms</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >SESSION B:</font></div><div><div><font size="2"   >ERROR: &nbsp;duplicate key value violates unique constraint "pk_test_pkey"</font></div><div><font size="2"   >DETAIL: &nbsp;Key (id)=(1) already exists.</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >SESSION C:</font></div><div><div><font size="2"   >ERROR: &nbsp;duplicate key value violates unique constraint "pk_test_pkey"</font></div><div><font size="2"   >DETAIL: &nbsp;Key (id)=(1) already exists.</font></div></div><p></p></pre></div><div><br></div><div>接下来要观察, session b,c到底有没有将记录插进去，从ctid可以看到B,C的两条未提交的垃圾记录已经插入了heap page。</div><div>所以需要垃圾回收。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; insert into pk_test values(2);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=&gt; select ctid,* from pk_test ;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id&nbsp;</font></div><div><font size="2"   >-------+----</font></div><div><font size="2"   >&nbsp;(0,1) | &nbsp;1</font></div><div><font size="2"   >&nbsp;(0,4) | &nbsp;2</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div><br></div><div>但是index page是没有被插入的，因为这个INDEX就是保证唯一性的，不可能在这里出现重复。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create extension pageinspect;</font></div><div><font size="2"   >CREATE EXTENSION</font></div></div><div><div><font size="2"   >digoal=# select * from bt_page_items('digoal.pk_test_pkey',1);</font></div><div><font size="2"   >&nbsp;itemoffset | ctid &nbsp;| itemlen | nulls | vars | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------+-------+---------+-------+------+-------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | (0,1) | &nbsp; &nbsp; &nbsp;16 | f &nbsp; &nbsp; | f &nbsp; &nbsp;| 01 00 00 00 00 00 00 00</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | (0,4) | &nbsp; &nbsp; &nbsp;16 | f &nbsp; &nbsp; | f &nbsp; &nbsp;| 02 00 00 00 00 00 00 00</font></div><div><font size="2"   >(2 rows)</font></div></div><p></p></pre></div><div><br></div><div>接下来我们看看check约束，会不会造成垃圾数据？</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table ck_test(id int check (id&gt;10));</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=&gt; insert into ck_test values (1);</font></div><div><font size="2"   >ERROR: &nbsp;new row for relation "ck_test" violates check constraint "ck_test_id_check"</font></div><div><font size="2"   >DETAIL: &nbsp;Failing row contains (1).</font></div><div><font size="2"   >digoal=&gt; insert into ck_test values (11);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=&gt; select ctid,* from ck_test ;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id&nbsp;</font></div><div><font size="2"   >-------+----</font></div><div><font size="2"   >&nbsp;(0,1) | 11</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=&gt; insert into ck_test values (1);</font></div><div><font size="2"   >ERROR: &nbsp;new row for relation "ck_test" violates check constraint "ck_test_id_check"</font></div><div><font size="2"   >DETAIL: &nbsp;Failing row contains (1).</font></div><div><font size="2"   >digoal=&gt; insert into ck_test values (1);</font></div><div><font size="2"   >ERROR: &nbsp;new row for relation "ck_test" violates check constraint "ck_test_id_check"</font></div><div><font size="2"   >DETAIL: &nbsp;Failing row contains (1).</font></div><div><font size="2"   >digoal=&gt; insert into ck_test values (11);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=&gt; select ctid,* from ck_test ;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id&nbsp;</font></div><div><font size="2"   >-------+----</font></div><div><font size="2"   >&nbsp;(0,1) | 11</font></div><div><font size="2"   >&nbsp;(0,2) | 11</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>从ctid可以看到，check约束是在数据进入heap page前检查的，所以不会产生垃圾。</div><div><br></div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL pk,uk,check constraint ERROR, error tuple will insert and need vacuum? - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>