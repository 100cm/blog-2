<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">performance tuning case: array search & date order by , data updated daily (use cursor solve it)</h2>
	<h5 id="">2015-06-17 17:13:25&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020155174350255/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>一位PG社区的朋友提到的一个应用场景，目前遇到性能问题。</div><div>数据结构大概是这样的，包含一个主键，一个数组，一个时间，其他字段。</div><div>请求分析：</div><div>有检索需求，比较频繁。查找数组中包含某些元素的记录，并按时间排序输出所有符合条件的记录，检索到的符合条件的记录可能上万条，也可能较少。</div><div>有插入需求，量不大。</div><div>有更新需求，一条记录最多一天会被更新一次，当然也可能不会被更新。</div><div>无删除需求。</div><div>数据量在千万级别。</div><div><br></div><div>这个应用场景的不安定因素来自于一些热点值。</div><div>例如，当输出的数据量较大时，排序对CPU的开销较大。而这些热点值可能也是查询的热点。</div><div>对于检索的条件是数组，这个可以用GIN索引来解决，只有排序是无法解决的。</div><div><br></div><div>测试，生成300万测试记录：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create table test(id int primary key,info int[],crt_date date);</font></div><div><font size="2"   >CREATE TABLE</font></div></div><div><div><font size="2"   >postgres=# insert into test select generate_series(1,3000000), ('{'||round(random()*1000)||','||round(random()*1000)||','||round(random()*1000)||'}')::int[], current_date+round(random()*1000)::int;</font></div><div><font size="2"   >INSERT 0 3000000</font></div></div><div><div><font size="2"   >postgres=# create index idx_test_info on test using gin(info);</font></div><div><font size="2"   >CREATE INDEX</font></div></div><p></p></pre></div></div><div>当输出记录较少时，效率还是可以的，例如以下：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain (analyze,verbose,buffers,timing) select info,crt_date from test where info @&gt; '{1,8}'::int[] order by crt_date desc;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Sort &nbsp;(cost=101.23..101.29 rows=22 width=37) (actual time=1.668..1.672 rows=21 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: info, crt_date</font></div><div><font size="2"   >&nbsp; &nbsp;Sort Key: test.crt_date DESC</font></div><div><font size="2"   >&nbsp; &nbsp;Sort Method: quicksort &nbsp;Memory: 26kB</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=26</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Heap Scan on public.test &nbsp;(cost=16.17..100.74 rows=22 width=37) (actual time=1.609..1.647 rows=21 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: info, crt_date</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Recheck Cond: (test.info @&gt; '{1,8}'::integer[])</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heap Blocks: exact=21</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=26</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_test_info &nbsp;(cost=0.00..16.17 rows=22 width=0) (actual time=1.595..1.595 rows=21 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (test.info @&gt; '{1,8}'::integer[])</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=5</font></div><div><font size="2"   >&nbsp;Planning time: 0.224 ms</font></div><div><font size="2"   >&nbsp;Execution time: 1.722 ms</font></div><div><font size="2"   >(15 rows)</font></div><p></p></pre></div><div>返回21行，算上排序需要1.7毫秒。</div><div>但是如果返回记录数上万之后，来看看结果：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain (analyze,verbose,buffers,timing) select info,crt_date from test where info @&gt; '{1}'::int[] order by crt_date desc;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Sort &nbsp;(cost=7737.83..7754.58 rows=6700 width=37) (actual time=17.726..18.856 rows=8896 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: info, crt_date</font></div><div><font size="2"   >&nbsp; &nbsp;Sort Key: test.crt_date DESC</font></div><div><font size="2"   >&nbsp; &nbsp;Sort Method: quicksort &nbsp;Memory: 1080kB</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=5028</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Heap Scan on public.test &nbsp;(cost=59.93..7312.04 rows=6700 width=37) (actual time=3.722..13.585 rows=8896 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: info, crt_date</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Recheck Cond: (test.info @&gt; '{1}'::integer[])</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heap Blocks: exact=5025</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=5028</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_test_info &nbsp;(cost=0.00..58.25 rows=6700 width=0) (actual time=2.620..2.620 rows=8896 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (test.info @&gt; '{1}'::integer[])</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=3</font></div><div><font size="2"   >&nbsp;Planning time: 0.151 ms</font></div><div><font size="2"   >&nbsp;Execution time: 19.637 ms</font></div><div><font size="2"   >(15 rows)</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >返回</span><span style="line-height: 28px;"   >8896</span><span style="line-height: 28px;"   >行，算上排序需要19.6毫秒。（这是返回所有记录的时间，如果是分页的话，第一页会很快返回）</span></div><div><span style="line-height: 28px;"   ><br></span></div><div>优化建议。</div><div>1. 如果遇到排序带来的CPU负载过高的问题，可以创建热值partial index</div><div>对于热值，创建partial index。例如以上热值：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create index idx_test_info_1 on test (crt_date) where info @&gt; '{1}'::int[];</font></div><div><font size="2"   >CREATE INDEX</font></div><p></p></pre></div><div>禁止排序</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# set enable_sort=off;</font></div><div><font size="2"   >SET</font></div></div><div><div><font size="2"   >postgres=# explain (analyze,verbose,buffers,timing) select * from test where info @&gt; '{1}'::int[] order by crt_date desc;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >-------------</font></div><div><font size="2"   >&nbsp;Index Scan Backward using idx_test_info_1 on public.test &nbsp;(cost=0.29..18253.53 rows=6700 width=41) (actual time=0.013..9.147 rows=8</font></div><div><font size="2"   >896 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info, crt_date</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=8909</font></div><div><font size="2"   >&nbsp;Planning time: 0.253 ms</font></div><div><font size="2"   >&nbsp;Execution time: 9.911 ms</font></div><div><font size="2"   >(5 rows)</font></div></div><p></p></pre></div><div>当然这么做有很大的弊端，因为如果热值比较多，我们要为各种热值相关的查询条件创建很多的索引。</div><div><br></div><div>2. 因为一条记录一天最多更新一次，所以完全可以使用应用层缓存，或者pgmemcache这样的缓存插件，降低数据库的负担。</div><div><br></div><div>3. 使用游标，我们注意到用户使用了分页显示，但是对于用户来说，可能只会看第一页或前几页的内容，所以每次都全部取到程序端是没有必要的，用游标会更好。（注意不要使用order by limit x offset x这种方式分页，会冗余扫描多次，请使用cursor，但是记得用完关闭。）详见驱动API，如pg-jdbc。</div><div><br></div><div>压力测试：</div><div>测量类似分页，我这里只取第一页的内容(使用热值partial index)。</div><div>注意这种用法不是游标的用法。只是方便这里测试的。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >vi test.sql</font></div><div><font size="2"   >select * from test where info @&gt; '{1}'::int[] order by crt_date desc limit 10;</font></div><p></p></pre></div><div>性能非常可观：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg95@db-172-16-3-150-&gt; pgbench -M prepared -n -r -f ./test.sql -P 1 -c 16 -j 16 -T 30</font></div><div><font size="2"   >progress: 1.0 s, 72844.1 tps, lat 0.213 ms stddev 0.119</font></div><div><font size="2"   >progress: 2.0 s, 73691.9 tps, lat 0.215 ms stddev 0.019</font></div><div><font size="2"   >progress: 3.0 s, 73603.7 tps, lat 0.216 ms stddev 0.018</font></div><div><font size="2"   >progress: 4.0 s, 73501.3 tps, lat 0.216 ms stddev 0.063</font></div><div><font size="2"   >progress: 5.0 s, 73433.2 tps, lat 0.216 ms stddev 0.049</font></div><div><font size="2"   >progress: 6.0 s, 73645.1 tps, lat 0.216 ms stddev 0.023</font></div><div><font size="2"   >progress: 7.0 s, 73551.0 tps, lat 0.216 ms stddev 0.060</font></div><div><font size="2"   >progress: 8.0 s, 73640.9 tps, lat 0.216 ms stddev 0.018</font></div><div><font size="2"   >progress: 9.0 s, 73650.8 tps, lat 0.216 ms stddev 0.027</font></div><div><font size="2"   >progress: 10.0 s, 73753.5 tps, lat 0.215 ms stddev 0.068</font></div><p></p></pre></div><div>对比一次取完所有数据的性能：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >pg95@db-172-16-3-150-&gt; vi test.sql</font></div><div><font size="2"   >select * from test where info @&gt; '{1}'::int[] order by crt_date desc;</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >pg95@db-172-16-3-150-&gt; pgbench -M prepared -n -r -f ./test.sql -P 1 -c 16 -j 16 -T 30</font></div><div><font size="2"   >progress: 1.0 s, 219.9 tps, lat 68.165 ms stddev 7.355</font></div><div><font size="2"   >progress: 2.0 s, 233.8 tps, lat 67.849 ms stddev 15.181</font></div><div><font size="2"   >progress: 3.0 s, 238.4 tps, lat 68.023 ms stddev 10.556</font></div><div><font size="2"   >progress: 4.0 s, 233.9 tps, lat 68.030 ms stddev 4.459</font></div><div><font size="2"   >progress: 5.0 s, 233.6 tps, lat 68.019 ms stddev 4.131</font></div><div><font size="2"   >progress: 6.0 s, 235.5 tps, lat 67.472 ms stddev 3.204</font></div><div><font size="2"   >progress: 7.0 s, 237.7 tps, lat 67.627 ms stddev 3.257</font></div><div><font size="2"   >progress: 8.0 s, 233.5 tps, lat 67.779 ms stddev 4.815</font></div><div><font size="2"   >progress: 9.0 s, 238.7 tps, lat 67.723 ms stddev 7.603</font></div><div><font size="2"   >progress: 10.0 s, 232.0 tps, lat 68.098 ms stddev 13.948</font></div></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/functions-array.html"   >http://www.postgresql.org/docs/9.4/static/functions-array.html</a></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="performance tuning case: array search  date order by , data updated daily (use cursor solve it) - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>