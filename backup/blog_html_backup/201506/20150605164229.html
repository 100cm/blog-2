<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Why PostgreSQL stream replication standby so fast</h2>
	<h5 id="">2015-06-05 16:42:29&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402015554915111/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><span style="line-height: 28px;"   >PostgreSQL 流复制以及基于流复制的standby 延迟可以控制在微秒级别，为什么能有这么好的表现呢？</span></div><div><div><img title="Why PostgreSQL stream replication standby so fast - 德哥@Digoal - PostgreSQL research"   alt="Why PostgreSQL stream replication standby so fast - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/MXNd0yH53iKR4iXtPznbaQ==/6630165066653158148.png"   ></div>这主要和它的复制原理有关，因为它是基于BLOCK变更的复制和恢复。主节点（或上游节点）产生的xlog会在每次xlog flush或write后立即让wal sender进程触发读取xlog并发送到wal receiver端。因此产生XLOG和发送XLOG的过程是连续的。</div><div>例如一个比较大的插入或更新操作，假设一次更新的数据量有几个GB，在执行SQL的过程当中会不断的产生xlog数据，只要网卡性能超出产生XLOG的速度，那么当更新完成并提交时，在standby也能立即反应提交后的状态。</div><div><br></div><div>从代码可以看出，wal sender一次发送数据的量&lt;=<span style="line-height: 28px;"   >XLOG_BLCKSZ * 16，如果使用8K的</span><span style="line-height: 28px;"   >XLOG_BLCKSZ，那么一次网络传输的片段是128K。从上一篇测试网络性能的文章来看到32K时单线程即可将网卡带宽利用完，</span><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015553437256/"   >http://blog.163.com/digoal@126/blog/static/1638770402015553437256/</a>&nbsp;&nbsp;<span style="line-height: 28px;"   >所以128K要吃掉整个网络带宽不是问题。当然万兆网卡我没有测试过，如果你发现128K不够的话，可以修改一下这个限制。</span></div><div>src/backend/replication/walsender.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Maximum data payload in a WAL data message. &nbsp;Must be &gt;= XLOG_BLCKSZ.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We don't have a good idea of what a good value would be; there's some</font></div><div><font size="2"   >&nbsp;* overhead per message in both walsender and walreceiver, but on the other</font></div><div><font size="2"   >&nbsp;* hand sending large batches makes walsender less responsive to signals</font></div><div><font size="2"   >&nbsp;* because signals are checked only between messages. &nbsp;128kB (with</font></div><div><font size="2"   >&nbsp;* default 8k blocks) seems like a reasonable guess for now.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define MAX_SEND_SIZE (XLOG_BLCKSZ * 16)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >...</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Send out the WAL in its normal physical/stored form.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Read up to MAX_SEND_SIZE bytes of WAL that's been flushed to disk,</font></div><div><font size="2"   >&nbsp;* but not yet sent to the client, and buffer it in the libpq output</font></div><div><font size="2"   >&nbsp;* buffer.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* If there is no unsent WAL remaining, WalSndCaughtUp is set to true,</font></div><div><font size="2"   >&nbsp;* otherwise WalSndCaughtUp is set to false.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static void</font></div><div><font size="2"   >XLogSendPhysical(void)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >......</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Figure out how much to send in one message. If there's no more than</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* MAX_SEND_SIZE bytes to send, send everything. Otherwise send</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* MAX_SEND_SIZE bytes, but round back to logfile or page boundary.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The rounding is not only for performance reasons. Walreceiver relies on</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the fact that we never split a WAL record across two messages. Since a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* long WAL record is split at page boundary into continuation records,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* page boundary is always a safe cut-off point. We also assume that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* SendRqstPtr never points to the middle of a WAL record.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; startptr = sentPtr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; endptr = startptr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; endptr += MAX_SEND_SIZE;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* if we went beyond SendRqstPtr, back off */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (SendRqstPtr &lt;= endptr)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr = SendRqstPtr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (sendTimeLineIsHistoric)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WalSndCaughtUp = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WalSndCaughtUp = true;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* round down to page boundary. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endptr -= (endptr % XLOG_BLCKSZ);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WalSndCaughtUp = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; nbytes = endptr - startptr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(nbytes &lt;= MAX_SEND_SIZE);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* OK to read and send the slice.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;output_message);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;output_message, 'w');</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint64(&amp;output_message, startptr); &nbsp; &nbsp; &nbsp; &nbsp;/* dataStart */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint64(&amp;output_message, SendRqstPtr); /* walEnd */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint64(&amp;output_message, 0); &nbsp; &nbsp; &nbsp; /* sendtime, filled in last */</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Read the log directly into the output buffer to avoid extra memcpy</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* calls.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; enlargeStringInfo(&amp;output_message, nbytes);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRead(&amp;output_message.data[output_message.len], startptr, nbytes);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; output_message.len += nbytes;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; output_message.data[output_message.len] = '\0';</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Fill the send timestamp last, so that it is taken as late as possible.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;tmpbuf);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint64(&amp;tmpbuf, GetCurrentIntegerTimestamp());</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;output_message.data[1 + sizeof(int64) + sizeof(int64)],</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tmpbuf.data, sizeof(int64));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pq_putmessage_noblock('d', output_message.data, output_message.len);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; sentPtr = endptr;</font></div></div><div><font size="2"   >......</font></div><p></p></pre></div><div><br></div><div>flush后异步唤醒wal sender, 保证写wal和发送wal的连续性。</div><div>src/backend/access/transam/xlog.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; issue_xlog_fsync(openLogFile, openLogSegNo);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* signal that we need to wakeup walsenders later */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WalSndWakeupRequest();</font></div></div><div><font size="2"   >......</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If asked to flush, do so</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (LogwrtResult.Flush &lt; WriteRqst.Flush &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogwrtResult.Flush &lt; LogwrtResult.Write)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Could get here without iterating above loop, in which case we might</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* have no open file or the wrong one. &nbsp;However, we do not need to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* fsync more than one file.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (sync_method != SYNC_METHOD_OPEN &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sync_method != SYNC_METHOD_OPEN_DSYNC)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (openLogFile &gt;= 0 &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !XLByteInPrevSeg(LogwrtResult.Write, openLogSegNo))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogFileClose();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (openLogFile &lt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLByteToPrevSeg(LogwrtResult.Write, openLogSegNo);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; openLogFile = XLogFileOpen(openLogSegNo);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; openLogOff = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; issue_xlog_fsync(openLogFile, openLogSegNo);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* signal that we need to wakeup walsenders later */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WalSndWakeupRequest();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogwrtResult.Flush = LogwrtResult.Write;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><div><font size="2"   >......</font></div><div><div><font size="2"   >void</font></div><div><font size="2"   >XLogFlush(XLogRecPtr record)</font></div><div><font size="2"   >{</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* wake up walsenders now that we've released heavily contended locks */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; WalSndWakeupProcessRequests();</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Flush xlog, but without specifying exactly where to flush to.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We normally flush only completed blocks; but if there is nothing to do on</font></div><div><font size="2"   >&nbsp;* that basis, we check for unflushed async commits in the current incomplete</font></div><div><font size="2"   >&nbsp;* block, and flush through the latest one of those. &nbsp;Thus, if async commits</font></div><div><font size="2"   >&nbsp;* are not being used, we will flush complete blocks only. &nbsp;We can guarantee</font></div><div><font size="2"   >&nbsp;* that async commits reach disk after at most three cycles; normally only</font></div><div><font size="2"   >&nbsp;* one or two. &nbsp;(When flushing complete blocks, we allow XLogWrite to write</font></div><div><font size="2"   >&nbsp;* "flexibly", meaning it can stop at the end of the buffer ring; this makes a</font></div><div><font size="2"   >&nbsp;* difference only with very high load or long wal_writer_delay, but imposes</font></div><div><font size="2"   >&nbsp;* one extra cycle for the worst case for async commits.)</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This routine is invoked periodically by the background walwriter process.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Returns TRUE if we flushed anything.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >bool</font></div><div><font size="2"   >XLogBackgroundFlush(void)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >......</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* wake up walsenders now that we've released heavily contended locks */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; WalSndWakeupProcessRequests();</font></div></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;src/backend/replication</div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015553437256/"   >http://blog.163.com/digoal@126/blog/static/1638770402015553437256/<br></a><span style="line-height: 28px;"   >
</span><a style="line-height: 28px;" rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="Why PostgreSQL stream replication standby so fast - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div></div>
	</div>
</div>
</body>
</html>