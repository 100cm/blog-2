<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">等宽矩阵(a)相乘a %*% x = b的逆运算solve(a,b)=x</h2>
	<h5 id="">2015-04-10 11:41:01&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201531011412752/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>solve用来逆运算矩阵相乘.</div><div>例如</div><div>a %*% x = b的逆运算, solve(a,b) = x</div><div>这里必须注意, a必须是等宽矩阵, 如果不等宽, 会报错.&nbsp;<span style="line-height: 28px;"   >例如 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; a &lt;- matrix(1:12,2,6)</font></div><div><font size="2"   >&gt; x &lt;- matrix(1:12,6,2)</font></div><div><font size="2"   >&gt; a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;[,1] [,2] [,3] [,4] [,5] [,6]</font></div><div><font size="2"   >[1,] &nbsp; &nbsp;1 &nbsp; &nbsp;3 &nbsp; &nbsp;5 &nbsp; &nbsp;7 &nbsp; &nbsp;9 &nbsp; 11</font></div><div><font size="2"   >[2,] &nbsp; &nbsp;2 &nbsp; &nbsp;4 &nbsp; &nbsp;6 &nbsp; &nbsp;8 &nbsp; 10 &nbsp; 12</font></div><div><font size="2"   >&gt; x</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;[,1] [,2]</font></div><div><font size="2"   >[1,] &nbsp; &nbsp;1 &nbsp; &nbsp;7</font></div><div><font size="2"   >[2,] &nbsp; &nbsp;2 &nbsp; &nbsp;8</font></div><div><font size="2"   >[3,] &nbsp; &nbsp;3 &nbsp; &nbsp;9</font></div><div><font size="2"   >[4,] &nbsp; &nbsp;4 &nbsp; 10</font></div><div><font size="2"   >[5,] &nbsp; &nbsp;5 &nbsp; 11</font></div><div><font size="2"   >[6,] &nbsp; &nbsp;6 &nbsp; 12</font></div><div><font size="2"   >&gt; b &lt;- a %*% x</font></div><div><font size="2"   >&gt; b</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;[,1] [,2]</font></div><div><font size="2"   >[1,] &nbsp;161 &nbsp;377</font></div><div><font size="2"   >[2,] &nbsp;182 &nbsp;434</font></div><div><font size="2"   >&gt; solve(a,b)</font></div><div><font size="2"   >Error in solve.default(a, b) : 'a' (2 x 6) must be square</font></div><p></p></pre></div><div>除此之外, 还有可能因为其他报错, 但实际上是可以逆向解的. &nbsp;(可能是我对可逆的理解有问题, 以后再来处理这个问题)</div><div>错误代码见</div><div><span style="line-height: 28px;"   >src/modules/lapack/Lapack.c</span></div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; F77_CALL(dgesv)(&amp;n, &amp;p, avals, &amp;n, ipiv, REAL(B), &amp;n, &amp;info);</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; if (info &lt; 0)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; error(_("argument %d of Lapack routine %s had invalid value"),</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -info, "dgesv");</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; if (info &gt; 0)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; error(_("Lapack routine %s: system is exactly singular: U[%d,%d] = 0"),</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "dgesv", info, info);</font></div><p></p></pre></div></div><div style="line-height: 28px;"   >错误举例 :&nbsp;</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >&gt; a &lt;- matrix(1:16,4,4)</font></div><div style="line-height: 28px;"   ><font size="2"   >&gt; solve(a, a %*% a)</font></div><div style="line-height: 28px;"   ><font size="2"   >Error in solve.default(a, a %*% a) :&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; Lapack routine dgesv: system is exactly singular: U[3,3] = 0</font></div><p></p></pre></div><div style="line-height: 28px;"   >理论上这个值应该是等于a的, 但是报错了.</div><div style="line-height: 28px;"   ><br></div><div style="line-height: 28px;"   >好了接下来看几个可以计算的例子 :&nbsp;</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >&gt; a &lt;- matrix(1:4,2,2)</font></div><div style="line-height: 28px;"   ><font size="2"   >&gt; a</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;[,1] [,2]</font></div><div style="line-height: 28px;"   ><font size="2"   >[1,] &nbsp; &nbsp;1 &nbsp; &nbsp;3</font></div><div style="line-height: 28px;"   ><font size="2"   >[2,] &nbsp; &nbsp;2 &nbsp; &nbsp;4</font></div><div style="line-height: 28px;"   ><font size="2"   >&gt; solve(a) &nbsp; # solve(a) , 不给b的话, 其实b 默认就是和a维度一致并且对角线为1的矩阵.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;[,1] [,2]</font></div><div style="line-height: 28px;"   ><font size="2"   >[1,] &nbsp; -2 &nbsp;1.5</font></div><div style="line-height: 28px;"   ><font size="2"   >[2,] &nbsp; &nbsp;1 -0.5</font></div><div style="line-height: 28px;"   ><font size="2"   >&gt; solve(a, diag(1,2,2)) &nbsp; # 可以看到</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;[,1] [,2]</font></div><div style="line-height: 28px;"   ><font size="2"   >[1,] &nbsp; -2 &nbsp;1.5</font></div><div style="line-height: 28px;"   ><font size="2"   >[2,] &nbsp; &nbsp;1 -0.5</font></div><div style="line-height: 28px;"   ><font size="2"   >&gt; diag(1,2,2)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;[,1] [,2]</font></div><div style="line-height: 28px;"   ><font size="2"   >[1,] &nbsp; &nbsp;1 &nbsp; &nbsp;0</font></div><div style="line-height: 28px;"   ><font size="2"   >[2,] &nbsp; &nbsp;0 &nbsp; &nbsp;1</font></div><div style="line-height: 28px;"   ><font size="2"   >&gt; a %*% solve(a) &nbsp; # &nbsp;因为solve(a,b) = x, a %*% x = b, 所以&nbsp;<span style="line-height: 28px;"   >a %*% solve(a) = b = diag(1,2,2)</span></font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;[,1] [,2]</font></div><div style="line-height: 28px;"   ><font size="2"   >[1,] &nbsp; &nbsp;1 &nbsp; &nbsp;0</font></div><div style="line-height: 28px;"   ><font size="2"   >[2,] &nbsp; &nbsp;0 &nbsp; &nbsp;1</font></div><p></p></pre></div></div></div><div style="line-height: 28px;"   ><br></div><div style="line-height: 28px;"   >b还可以是向量, 向量会自动转成矩阵, 例如</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >&gt; solve(a, c(2,3))</font></div><div style="line-height: 28px;"   ><font size="2"   >[1] 0.5 0.5</font></div><div style="line-height: 28px;"   ><font size="2"   >&gt; a %*% solve(a, c(2,3))</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;[,1]</font></div><div style="line-height: 28px;"   ><font size="2"   >[1,] &nbsp; &nbsp;2</font></div><div style="line-height: 28px;"   ><font size="2"   >[2,] &nbsp; &nbsp;3</font></div><p></p></pre></div></div><div style="line-height: 28px;"   ><br></div>[参考]<wbr><div>1. help("solve")</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >solve &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; package:base &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; R Documentation</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Solve a System of Equations</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Description:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;This generic function solves the equation ‘a %*% x = b’ for ‘x’,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;where ‘b’ can be either a vector or a matrix.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Usage:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;solve(a, b, ...)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;## Default S3 method:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;solve(a, b, tol, LINPACK = FALSE, ...)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >Arguments:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;a: a square numeric or complex matrix containing the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coefficients of the linear system. &nbsp;Logical matrices are</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coerced to numeric.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;b: a numeric or complex vector or matrix giving the right-hand</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; side(s) of the linear system. &nbsp;If missing, ‘b’ is taken to be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; an identity matrix and ‘solve’ will return the inverse of</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ‘a’.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;tol: the tolerance for detecting linear dependencies in the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; columns of ‘a’. &nbsp;The default is ‘.Machine$double.eps’. Not</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currently used with complex matrices ‘a’.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp;LINPACK: logical. &nbsp;Defunct and ignored.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;...: further arguments passed to or from other methods</font></div><p></p></pre></div><div><br></div><div>2.&nbsp;</div><div>src/modules/lapack/Lapack.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/* Real case of solve.default */</font></div><div><font size="2"   >static SEXP La_solve(SEXP A, SEXP Bin, SEXP tolin)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; int n, p;</font></div><div><font size="2"   >&nbsp; &nbsp; double *avals, anorm, rcond, tol = asReal(tolin), *work;</font></div><div><font size="2"   >&nbsp; &nbsp; SEXP B, Adn, Bdn;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; if (!(isMatrix(A) &amp;&amp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (TYPEOF(A) == REALSXP || TYPEOF(A) == INTSXP || TYPEOF(A) == LGLSXP)))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; error(_("'a' must be a numeric matrix"));</font></div><div><font size="2"   >&nbsp; &nbsp; int *Adims = INTEGER(coerceVector(getAttrib(A, R_DimSymbol), INTSXP));</font></div><div><font size="2"   >&nbsp; &nbsp; n = Adims[0];</font></div><div><font size="2"   >&nbsp; &nbsp; if(n == 0) error(_("'a' is 0-diml"));</font></div><div><font size="2"   >&nbsp; &nbsp; int n2 = Adims[1];</font></div><div><font size="2"   >&nbsp; &nbsp; if(n2 != n) error(_("'a' (%d x %d) must be square"), n, n2);</font></div><div><font size="2"   >&nbsp; &nbsp; Adn = getAttrib(A, R_DimNamesSymbol);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; if (isMatrix(Bin)) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int *Bdims = INTEGER(coerceVector(getAttrib(Bin, R_DimSymbol), INTSXP));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; p = Bdims[1];</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if(p == 0) error(_("no right-hand side in 'b'"));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int p2 = Bdims[0];</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if(p2 != n)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error(_("'b' (%d x %d) must be compatible with 'a' (%d x %d)"),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p2, p, n, n);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PROTECT(B = allocMatrix(REALSXP, n, p));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SEXP Bindn = &nbsp;getAttrib(Bin, R_DimNamesSymbol);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; // This is somewhat odd, but Matrix relies on dropping NULL dimnames</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!isNull(Adn) || !isNull(Bindn)) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // rownames(ans) = colnames(A), colnames(ans) = colnames(Bin)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bdn = allocVector(VECSXP, 2);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!isNull(Adn)) SET_VECTOR_ELT(Bdn, 0, VECTOR_ELT(Adn, 1));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!isNull(Bindn)) SET_VECTOR_ELT(Bdn, 1, VECTOR_ELT(Bindn, 1));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!isNull(VECTOR_ELT(Bdn, 0)) || !isNull(VECTOR_ELT(Bdn, 1)))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setAttrib(B, R_DimNamesSymbol, Bdn);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; } else {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; p = 1;</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if(length(Bin) != n)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error(_("'b' (%d x %d) must be compatible with 'a' (%d x %d)"),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length(Bin), p, n, n); &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PROTECT(B = allocVector(REALSXP, n));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!isNull(Adn)) setAttrib(B, R_NamesSymbol, VECTOR_ELT(Adn, 1));</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; PROTECT(Bin = coerceVector(Bin, REALSXP));</font></div><div><font size="2"   >&nbsp; &nbsp; Memcpy(REAL(B), REAL(Bin), (size_t)n * p);</font></div><div><font size="2"   >&nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; int *ipiv = (int *) R_alloc(n, sizeof(int));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; /* work on a copy of A */</font></div><div><font size="2"   >&nbsp; &nbsp; if (!isReal(A)) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; A = coerceVector(A, REALSXP);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; avals = REAL(A);</font></div><div><font size="2"   >&nbsp; &nbsp; } else {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; avals = (double *) R_alloc((size_t)n * n, sizeof(double));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Memcpy(avals, REAL(A), (size_t)n * n);</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; PROTECT(A);</font></div><div><font size="2"   >&nbsp; &nbsp; int info;</font></div><div><font size="2"   >&nbsp; &nbsp; F77_CALL(dgesv)(&amp;n, &amp;p, avals, &amp;n, ipiv, REAL(B), &amp;n, &amp;info);</font></div><div><font size="2"   >&nbsp; &nbsp; if (info &lt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; error(_("argument %d of Lapack routine %s had invalid value"),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -info, "dgesv");</font></div><div><font size="2"   >&nbsp; &nbsp; if (info &gt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; error(_("Lapack routine %s: system is exactly singular: U[%d,%d] = 0"),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "dgesv", info, info);</font></div><div><font size="2"   >&nbsp; &nbsp; if(tol &gt; 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char one[2] = "1";</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; anorm = F77_CALL(dlange)(one, &amp;n, &amp;n, REAL(A), &amp;n, (double*) NULL);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; work = (double *) R_alloc(4*(size_t)n, sizeof(double));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; F77_CALL(dgecon)(one, &amp;n, avals, &amp;n, &amp;anorm, &amp;rcond, work, ipiv, &amp;info);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (rcond &lt; tol)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error(_("system is computationally singular: reciprocal condition number = %g"),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcond);</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; UNPROTECT(3); /* B, Bin, A */</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; return B;</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="等宽矩阵(a)相乘a * x = b的逆运算solve(a,b)=x - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">byfei163 - 2015-04-10 14:01:17</h5>
				<div><P>在不，问你个问题，后台报“too&nbsp;many&nbsp;notifications&nbsp;in&nbsp;the&nbsp;NOTIFY&nbsp;q”，这个问题见过没？现在发现没有这方面的参数设置，不知道怎么办才好！</P></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 byfei163 - 2015-04-10 14:01:17</h5>
				<div style="width:600px;">src/backend/commands/async.c<div><div>/*</div><div>&nbsp;* Test whether there is room to insert more notification messages.</div><div>&nbsp;*</div><div>&nbsp;* Caller must hold at least shared AsyncQueueLock.</div><div>&nbsp;*/</div><div>static bool</div><div>asyncQueueIsFull(void)</div><div>{</div></div></div>
			</div>
	</div>
</div>
</body>
</html>