<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.5 new feature - BRIN (block range index) index</h2>
	<h5 id="">2015-04-19 4:01:13&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201531931956500/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 9.5引入的一个全新的索引访问方法BRIN（block range index），这个索引存储了表的连续数据块区间以及对应的数据取值范围。</div><div>比如一张表有1000个数据块，我们建议一个BRIN在ID（假设这个表有ID字段）上的索引。</div><div>BRIN默认是每128个连续数据块区间存储一个字段取值的区间，所以这个索引的信息量是将1000个数据块划分为几个连续的128个块的区间，然后存储每个区间ID值的取值范围。</div><div>很显然，BRIN索引时lossy索引（即有损索引），那么我们并不能直接从索引中精确匹配要查询的记录，但是通过索引我们可以将查询范围缩小到最小128个连续的数据块（假设我们要找的值落在这个区间）。</div><div>以上是BRIN大概的原理，那么BRIN可以用在什么场景呢？</div><div>一个非常好的场景是流式日志数据，比如用户行为，大批量的数据按时间顺序不停的插入数据表。</div><div>我们如果要按照时间来访问这样的数据，以往我们需要创建BTREE索引，可以范围查询或者精确匹配。但是BTREE索引需要存储的信息量较大，如果数据量很大，索引也很庞大。</div><div>BRIN的话，索引可以变得很小，而且因为数据是按照时间顺序插入的，所以BRIN的信息量也很大，因为每个连续的数据块区间存储的时间范围和其他连续的数据块区间独立性很好，即不会出现大量数据交叉，如果有大量较差，那么使用BRIN检索还不如全表扫描。</div><div>BRIN可认为是全表扫描的切片，如果数据值分布和物理值分布的相关性很好，那么BRIN无疑是非常好的选择。</div><div>这里说到的相关性，大家可以参考统计学的知识，或者参考我之前写过的一篇文章。</div><div><a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201512810112541/"   >http://blog.163.com/digoal@126/blog/static/163877040201512810112541/</a></div><div>接下来我们测试一下BRIN对于相关性好和相关性差的数据，以及他们的性能。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create table t1(id int,info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><div><font size="2"   >postgres=# create table t2(id int,info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# insert into t1 select generate_series(1,10000000),md5(random()::text);</font></div><div><font size="2"   >INSERT 0 10000000</font></div></div><p></p></pre></div><div><div>以下数据ID和物理存储相关性非常差。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# insert into t2 select id,md5(random()::text) from generate_series(1,10000000) as t(id) order by random();</font></div><div><font size="2"   >INSERT 0 10000000</font></div></div><div><div><font size="2"   >postgres=# analyze t1;</font></div><div><font size="2"   >ANALYZE</font></div><div><font size="2"   >postgres=# analyze t2;</font></div><div><font size="2"   >ANALYZE</font></div></div><p></p></pre></div></div><div>查询他们的相关性。显然T2表的物理存储和实际值顺序相关性很差。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select correlation from pg_stats where tablename='t1' and attname='id';</font></div><div><font size="2"   >&nbsp;correlation&nbsp;</font></div><div><font size="2"   >-------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >postgres=# select correlation from pg_stats where tablename='t2' and attname='id';</font></div><div><font size="2"   >&nbsp;correlation&nbsp;</font></div><div><font size="2"   >-------------</font></div><div><font size="2"   >&nbsp; 0.00805771</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>创建索引，创建索引的速度明显比BTREE索引快，因为BRIN只需要存储值区间，瘦得很。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create index idx_t1_id on t1 using brin (id);</font></div><div><font size="2"   >CREATE INDEX</font></div></div><div><div><font size="2"   >postgres=# create index idx_t2_id on t2 using brin (id);</font></div><div><font size="2"   >CREATE INDEX</font></div></div><p></p></pre></div><div>我们看看索引的大小和表的大小，从BRIN的原理我们可以想象索引肯定很小，表650MB，索引才192K。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \di+</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp; Name &nbsp; &nbsp;| Type &nbsp;| &nbsp;Owner &nbsp; | Table | &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+-----------+-------+----------+-------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | idx_t1_id | index | postgres | t1 &nbsp; &nbsp;| 192 kB |&nbsp;</font></div><div><font size="2"   >&nbsp;public | idx_t2_id | index | postgres | t2 &nbsp; &nbsp;| 192 kB |&nbsp;</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   >postgres=# \dt+ t1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | Name | Type &nbsp;| &nbsp;Owner &nbsp; | &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+------+-------+----------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | t1 &nbsp; | table | postgres | 650 MB |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >postgres=# \dt+ t2</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | Name | Type &nbsp;| &nbsp;Owner &nbsp; | &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+------+-------+----------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | t2 &nbsp; | table | postgres | 650 MB |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>来看看实际的查询差别就知道，BRIN有多么适合流式数据了。</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain analyze select * from t1 where id&gt;=1000 and id&lt;=5000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Bitmap Heap Scan on t1 &nbsp;(cost=50.98..9767.60 rows=3803 width=37) (actual time=0.351..13.732 rows=4001 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Recheck Cond: ((id &gt;= 1000) AND (id &lt;= 5000))</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Index Recheck: 57567</font></div><div><font size="2"   >&nbsp; &nbsp;Heap Blocks: lossy=128</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_t1_id &nbsp;(cost=0.00..50.03 rows=3803 width=0) (actual time=0.104..0.104 rows=1280 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 1000) AND (id &lt;= 5000))</font></div><div><font size="2"   >&nbsp;Planning time: 0.111 ms</font></div><div><font size="2"   >&nbsp;Execution time: 14.019 ms</font></div><div><font size="2"   >(8 rows)</font></div><p></p></pre></div><div>对于相关性差的，还不如全表扫描。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain analyze select * from t2 where id&gt;=1000 and id&lt;=5000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Bitmap Heap Scan on t2 &nbsp;(cost=49.78..9549.73 rows=3686 width=37) (actual time=2.806..2268.044 rows=4001 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Recheck Cond: ((id &gt;= 1000) AND (id &lt;= 5000))</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Index Recheck: 9995999</font></div><div><font size="2"   >&nbsp; &nbsp;Heap Blocks: lossy=20791</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_t2_id &nbsp;(cost=0.00..48.86 rows=3686 width=0) (actual time=2.019..2.019 rows=208640 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 1000) AND (id &lt;= 5000))</font></div><div><font size="2"   >&nbsp;Planning time: 0.195 ms</font></div><div><font size="2"   >&nbsp;Execution time: 2268.590 ms</font></div><div><font size="2"   >(8 rows)</font></div><p></p></pre></div></div><div>t2全表扫描</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# set enable_bitmapscan=off;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >postgres=# explain analyze select * from t2 where id&gt;=1000 and id&lt;=5000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on t2 &nbsp;(cost=0.00..170791.00 rows=3686 width=37) (actual time=0.593..1881.929 rows=4001 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: ((id &gt;= 1000) AND (id &lt;= 5000))</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Filter: 9995999</font></div><div><font size="2"   >&nbsp;Planning time: 0.109 ms</font></div><div><font size="2"   >&nbsp;Execution time: 1882.397 ms</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div>接下来BRIN和BTREE索引对比一下。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create index idx_t1_id_bt on t1 using btree (id);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >postgres=# create index idx_t2_id_bt on t2 using btree (id);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >postgres=# set enable_bitmapscan=on;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >postgres=# drop index idx_t1_id;</font></div><div><font size="2"   >DROP INDEX</font></div><div><font size="2"   >postgres=# drop index idx_t2_id;</font></div><div><font size="2"   >DROP INDEX</font></div><div><font size="2"   >postgres=# explain analyze select * from t1 where id&gt;=1000 and id&lt;=5000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_t1_id_bt on t1 &nbsp;(cost=0.43..102.04 rows=3880 width=37) (actual time=0.023..1.048 rows=4001 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: ((id &gt;= 1000) AND (id &lt;= 5000))</font></div><div><font size="2"   >&nbsp;Planning time: 0.412 ms</font></div><div><font size="2"   >&nbsp;Execution time: 1.318 ms</font></div><div><font size="2"   >(4 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# explain analyze select * from t2 where id&gt;=1000 and id&lt;=5000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Bitmap Heap Scan on t2 &nbsp;(cost=53.05..10056.68 rows=3962 width=37) (actual time=1.932..8.304 rows=4001 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Recheck Cond: ((id &gt;= 1000) AND (id &lt;= 5000))</font></div><div><font size="2"   >&nbsp; &nbsp;Heap Blocks: exact=3642</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_t2_id_bt &nbsp;(cost=0.00..52.05 rows=3962 width=0) (actual time=1.143..1.143 rows=4001 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 1000) AND (id &lt;= 5000))</font></div><div><font size="2"   >&nbsp;Planning time: 0.379 ms</font></div><div><font size="2"   >&nbsp;Execution time: 8.621 ms</font></div><div><font size="2"   >(7 rows)</font></div><p></p></pre></div><div><br></div><div>我们看到btree索引查询性能是提高了，但是索引大小你看看有多大？</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \di+</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp; &nbsp; Name &nbsp; &nbsp; | Type &nbsp;| &nbsp;Owner &nbsp; | Table | &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+--------------+-------+----------+-------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | idx_t1_id_bt | index | postgres | t1 &nbsp; &nbsp;| 213 MB |&nbsp;</font></div><div><font size="2"   >&nbsp;public | idx_t2_id_bt | index | postgres | t2 &nbsp; &nbsp;| 213 MB |&nbsp;</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>接下调整brin索引的精度提高查询效率，我们了解到默认的brin是存储128个连续的数据块区间的，这个值越小，精度越高。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create index idx_t1_id on t1 using brin (id) with (pages_per_range=1);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >postgres=# create index idx_t2_id on t2 using brin (id) with (pages_per_range=1);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >postgres=# \di+</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp; &nbsp; Name &nbsp; &nbsp; | Type &nbsp;| &nbsp;Owner &nbsp; | Table | &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+--------------+-------+----------+-------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | idx_t1_id &nbsp; &nbsp;| index | postgres | t1 &nbsp; &nbsp;| 672 kB |&nbsp;</font></div><div><font size="2"   >&nbsp;public | idx_t1_id_bt | index | postgres | t1 &nbsp; &nbsp;| 213 MB |&nbsp;</font></div><div><font size="2"   >&nbsp;public | idx_t2_id &nbsp; &nbsp;| index | postgres | t2 &nbsp; &nbsp;| 672 kB |&nbsp;</font></div><div><font size="2"   >&nbsp;public | idx_t2_id_bt | index | postgres | t2 &nbsp; &nbsp;| 213 MB |&nbsp;</font></div><div><font size="2"   >(4 rows)</font></div></div><div><div><font size="2"   >postgres=# drop index idx_t1_id_bt;</font></div><div><font size="2"   >DROP INDEX</font></div><div><font size="2"   >postgres=# drop index idx_t2_id_bt;</font></div><div><font size="2"   >DROP INDEX</font></div></div><div><div><font size="2"   >postgres=# explain analyze select * from t1 where id&gt;=1000 and id&lt;=5000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Bitmap Heap Scan on t1 &nbsp;(cost=110.98..9827.60 rows=3803 width=37) (actual time=9.487..10.571 rows=4001 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Recheck Cond: ((id &gt;= 1000) AND (id &lt;= 5000))</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Index Recheck: 328</font></div><div><font size="2"   >&nbsp; &nbsp;Heap Blocks: lossy=9</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_t1_id &nbsp;(cost=0.00..110.03 rows=3803 width=0) (actual time=9.449..9.449 rows=90 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 1000) AND (id &lt;= 5000))</font></div><div><font size="2"   >&nbsp;Planning time: 0.141 ms</font></div><div><font size="2"   >&nbsp;Execution time: 10.853 ms</font></div><div><font size="2"   >(8 rows)</font></div></div><div><div><font size="2"   >postgres=# explain analyze select * from t2 where id&gt;=1000 and id&lt;=5000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Bitmap Heap Scan on t2 &nbsp;(cost=109.78..9609.73 rows=3686 width=37) (actual time=10.407..481.673 rows=4001 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Recheck Cond: ((id &gt;= 1000) AND (id &lt;= 5000))</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Index Recheck: 2125867 &nbsp;# 看看精度不高的后果，取4001条数据却额外扫描了<span style="line-height: 28px;"   >2125867条无用数据</span></font></div><div><font size="2"   >&nbsp; &nbsp;Heap Blocks: lossy=4428</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_t2_id &nbsp;(cost=0.00..108.86 rows=3686 width=0) (actual time=10.364..10.364 rows=44280 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 1000) AND (id &lt;= 5000))</font></div><div><font size="2"   >&nbsp;Planning time: 0.106 ms</font></div><div><font size="2"   >&nbsp;Execution time: 482.077 ms</font></div><div><font size="2"   >(8 rows)</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >精度提高后，扫描效率有一定的提升。（对于相关度不高的就不要用BRIN了，精度提高到1都于事无补的，无用功太多）当然相比btree还有差距，不过对于大数据场景，我们还要考虑数据的插入性能，对于btree插入性能好还是brin的插入性能好呢？</span></div><div><div>我这里简单的测试了一下，并未涉及并发处理，已经可以明显的了解到btree索引对数据插入带来的开销更大。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# \d t1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; Table "public.t1"</font></div><div><font size="2"   >&nbsp;Column | &nbsp;Type &nbsp; | Modifiers&nbsp;</font></div><div><font size="2"   >--------+---------+-----------</font></div><div><font size="2"   >&nbsp;id &nbsp; &nbsp; | integer |&nbsp;</font></div><div><font size="2"   >&nbsp;info &nbsp; | text &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >Indexes:</font></div><div><font size="2"   >&nbsp; &nbsp; "idx_t1_id" brin (id) WITH (pages_per_range=1)</font></div><div><font size="2"   >postgres=# \timing</font></div><div><font size="2"   >Timing is on.</font></div><div><font size="2"   >postgres=# insert into t1 select generate_series(1,1000000);</font></div><div><font size="2"   >INSERT 0 1000000</font></div><div><font size="2"   >Time: 2152.527 ms</font></div><div><font size="2"   >postgres=# drop index idx_t1_id;</font></div><div><font size="2"   >DROP INDEX</font></div><div><font size="2"   >Time: 9.527 ms</font></div></div><div><div><font size="2"   >postgres=# create index idx_t1_id_bt on t1 using btree (id);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >Time: 29659.752 ms</font></div><div><font size="2"   >postgres=# insert into t1 select generate_series(1,1000000);</font></div><div><font size="2"   >INSERT 0 1000000</font></div><div><font size="2"   >Time: 5407.971 ms</font></div></div><p></p></pre></div></div><div>最后，我们同样可以使用pageinspect来观测brin索引的内容。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create extension pageinspect;</font></div><div><font size="2"   >CREATE EXTENSION</font></div></div><div><div><font size="2"   >postgres=# select * from brin_page_items(get_raw_page('idx_t1_id',10),'idx_t1_id');</font></div><div><font size="2"   >&nbsp;itemoffset | blknum | attnum | allnulls | hasnulls | placeholder | &nbsp; &nbsp; &nbsp; &nbsp;value &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------+--------+--------+----------+----------+-------------+----------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; 2176 | &nbsp; &nbsp; &nbsp;1 | f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | {1046657 .. 1047137}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; 2177 | &nbsp; &nbsp; &nbsp;1 | f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | {1047138 .. 1047618}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 | &nbsp; 2178 | &nbsp; &nbsp; &nbsp;1 | f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | {1047619 .. 1048099}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 | &nbsp; 2179 | &nbsp; &nbsp; &nbsp;1 | f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | {1048100 .. 1048580}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5 | &nbsp; 2180 | &nbsp; &nbsp; &nbsp;1 | f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | {1048581 .. 1049061}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 | &nbsp; 2181 | &nbsp; &nbsp; &nbsp;1 | f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | {1049062 .. 1049542}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7 | &nbsp; 2182 | &nbsp; &nbsp; &nbsp;1 | f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp;| f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | {1049543 .. 1050023}</font></div></div><div><font size="2"   >。。。</font></div><p></p></pre></div><div>例如我们看到<span style="line-height: 28px;"   >2176</span><span style="line-height: 28px;"   >&nbsp;这个数据块的ID取值区间是</span><span style="line-height: 28px;"   >{1046657 .. 1047137}，我们使用ctid来验证一下.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select min(id),max(id) from t1 where ctid::text ~ E'^\\(2176,';</font></div><div><font size="2"   >&nbsp; &nbsp;min &nbsp; | &nbsp; max &nbsp;&nbsp;</font></div><div><font size="2"   >---------+---------</font></div><div><font size="2"   >&nbsp;1046657 | 1047137</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ># 完全正确</font></div><p></p></pre></div><div>其他还有几个pageinspect的函数：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# SELECT brin_page_type(get_raw_page('idx_t1_id', id)) from generate_series(0,10) t(id);</font></div><div><font size="2"   >&nbsp;brin_page_type&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp;meta</font></div><div><font size="2"   >&nbsp;revmap</font></div><div><font size="2"   >&nbsp;revmap</font></div><div><font size="2"   >&nbsp;revmap</font></div><div><font size="2"   >&nbsp;revmap</font></div><div><font size="2"   >&nbsp;revmap</font></div><div><font size="2"   >&nbsp;regular</font></div><div><font size="2"   >&nbsp;regular</font></div><div><font size="2"   >&nbsp;regular</font></div><div><font size="2"   >&nbsp;regular</font></div><div><font size="2"   >&nbsp;regular</font></div><div><font size="2"   >(11 rows)</font></div></div><div><div><font size="2"   >postgres=# SELECT * FROM brin_metapage_info(get_raw_page('idx_t1_id', 0));</font></div><div><font size="2"   >&nbsp; &nbsp;magic &nbsp; &nbsp;| version | pagesperrange | lastrevmappage&nbsp;</font></div><div><font size="2"   >------------+---------+---------------+----------------</font></div><div><font size="2"   >&nbsp;0xA8109CFA | &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >postgres=# SELECT * FROM brin_revmap_data(get_raw_page('idx_t1_id', 1)) limit 5;</font></div><div><font size="2"   >&nbsp; &nbsp;pages &nbsp;&nbsp;</font></div><div><font size="2"   >-----------</font></div><div><font size="2"   >&nbsp;(18,1105)</font></div><div><font size="2"   >&nbsp;(18,1106)</font></div><div><font size="2"   >&nbsp;(18,1107)</font></div><div><font size="2"   >&nbsp;(18,1108)</font></div><div><font size="2"   >&nbsp;(18,1109)</font></div><div><font size="2"   >(5 rows)</font></div></div><p></p></pre></div><div>截止目前，PostgreSQL可以支持btree,hash,gin,gist,spgist,brin共6种索引访问方法。用户可以根据实际应用场景选择合适的索引。</div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201512810112541/"   >http://blog.163.com/digoal@126/blog/static/163877040201512810112541/</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/brin.html"   >http://www.postgresql.org/docs/devel/static/brin.html</a></div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/sql-createindex.html"   >http://www.postgresql.org/docs/devel/static/sql-createindex.html</a></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >BRIN indexes accept a different parameter:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >pages_per_range</font></div><div><font size="2"   >Defines the number of table blocks that make up one block range for each entry of a BRIN index (see Section 60.1 for more details). The default is 128.</font></div><p></p></pre></div><div><br></div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL 9.5 new feature - BRIN (block range index) index - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>