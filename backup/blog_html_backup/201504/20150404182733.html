<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL dirty read extension pg_dirtyread used to recovery stand alone tablespace</h2>
	<h5 id="">2015-04-04 18:27:33&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402015345228317/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>在某些场景中, 我们可能遇到一个问题, 即$PGDATA可能被误删除了, 但是用户自建表空间目录还在.</div><div>或者$PGDATA所在的文件系统损坏了, 但是用户自建的表空间还能正常读取.</div><div>那么在这种情况下, 我们能不能从表空间中获取有用的数据呢?</div><div>这里需要用到脏读工具pg_dirtyread.</div><div>接下来来模拟一下 :&nbsp;</div><div>创建表空间, 以及测试数据.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 ~]# cd /data03</font></div><div><font size="2"   >[root@db-172-16-3-150 data03]# mkdir pgtbs</font></div><div><font size="2"   >[root@db-172-16-3-150 data03]# chown postgres:postgres pgtbs</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >[root@db-172-16-3-150 data03]# su - postgres</font></div><div><font size="2"   >-bash: unalias: vi: not found</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; psql</font></div><div><font size="2"   >psql (9.4.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# create tablespace tbs location '/data03/pgtbs';</font></div><div><font size="2"   >CREATE TABLESPACE</font></div><div><font size="2"   >postgres=# create database test;</font></div><div><font size="2"   >ERROR: &nbsp;database "test" already exists</font></div><div><font size="2"   >postgres=# \c test</font></div><div><font size="2"   >You are now connected to database "test" as user "postgres".</font></div><div><font size="2"   >test=# \dt</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | Name | Type &nbsp;| &nbsp;Owner &nbsp;&nbsp;</font></div><div><font size="2"   >--------+------+-------+----------</font></div><div><font size="2"   >&nbsp;public | test | table | postgres</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >test=# create table t1(id int, info text, crt_time timestamp) tablespace tbs;</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >test=# insert into t1 select generate_series(1,10000),md5(random()::text),clock_timestamp();</font></div><div><font size="2"   >INSERT 0 10000</font></div><div><font size="2"   >test=# create table t2 (like t1);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >test=# insert into t2 select * from t1;</font></div><div><font size="2"   >INSERT 0 10000</font></div><p></p></pre></div><div>测试数据的校验值如下, 用于后面我们恢复后校验值是否一致.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# select sum(hashtext(t1.*::text)) from t1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp;185323099056</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >test=# select sum(hashtext(t2.*::text)) from t2;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp;185323099056</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >test=# \q</font></div><p></p></pre></div><div>关闭数据库</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; pg_ctl stop -m fast</font></div><div><font size="2"   >waiting for server to shut down.... done</font></div><div><font size="2"   >server stopped</font></div><p></p></pre></div><div>将$PGDATA目录重名, 模拟删除$PGDATA</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; echo $PGDATA</font></div><div><font size="2"   >/data02/pgdata/pg_root</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; exit</font></div><div><font size="2"   >logout</font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# cd /data02/pgdata/</font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# ll</font></div><div><font size="2"   >total 4.0K</font></div><div><font size="2"   >drwx------. 19 postgres postgres 4.0K Apr &nbsp;4 17:28 pg_root</font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# mv pg_root pg_root_old</font></div><p></p></pre></div><div><br></div><div>新建一个$PGDATA空目录, 用于初始化一个新的数据库集群.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 pgdata]# mkdir pg_root</font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# chown postgres:postgres pg_root</font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# chmod 700 pg_root</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# su - postgres</font></div><div><font size="2"   >-bash: unalias: vi: not found</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; initdb -D $PGDATA -E UTF8 --locale=C -U postgres -W</font></div><div><font size="2"   >.....</font></div><p></p></pre></div><div><br></div><div>修改一下新建的数据库集群的配置文件</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; cd $PGDATA</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"   >total 108K</font></div><div><font size="2"   >drwx------ 5 postgres postgres 4.0K Apr &nbsp;4 17:30 base</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:30 global</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:29 pg_clog</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:29 pg_dynshmem</font></div><div><font size="2"   >-rw------- 1 postgres postgres 4.4K Apr &nbsp;4 17:29 pg_hba.conf</font></div><div><font size="2"   >-rw------- 1 postgres postgres 1.6K Apr &nbsp;4 17:29 pg_ident.conf</font></div><div><font size="2"   >drwx------ 4 postgres postgres 4.0K Apr &nbsp;4 17:29 pg_logical</font></div><div><font size="2"   >drwx------ 4 postgres postgres 4.0K Apr &nbsp;4 17:29 pg_multixact</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:30 pg_notify</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:29 pg_replslot</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:29 pg_serial</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:29 pg_snapshots</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:29 pg_stat</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:29 pg_stat_tmp</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:29 pg_subtrans</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:29 pg_tblspc</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:29 pg_twophase</font></div><div><font size="2"   >-rw------- 1 postgres postgres &nbsp; &nbsp;4 Apr &nbsp;4 17:29 PG_VERSION</font></div><div><font size="2"   >drwx------ 3 postgres postgres 4.0K Apr &nbsp;4 17:29 pg_xlog</font></div><div><font size="2"   >-rw------- 1 postgres postgres &nbsp; 88 Apr &nbsp;4 17:29 postgresql.auto.conf</font></div><div><font size="2"   >-rw------- 1 postgres postgres &nbsp;21K Apr &nbsp;4 17:29 postgresql.conf</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; vi postgresql.conf</font></div><div><font size="2"   >listen_addresses = '0.0.0.0' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# what IP address(es) to listen on;</font></div><div><font size="2"   >port = 1921 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # (change requires restart)</font></div><div><font size="2"   >max_connections = 40 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# (change requires restart)</font></div><div><font size="2"   >superuser_reserved_connections = 13 &nbsp; &nbsp; # (change requires restart)</font></div><div><font size="2"   >unix_socket_directories = '.' &nbsp; # comma-separated list of directories</font></div><div><font size="2"   >shared_buffers = 4096MB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # min 128kB</font></div><div><font size="2"   >maintenance_work_mem = 64MB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # min 1MB</font></div><div><font size="2"   >dynamic_shared_memory_type = posix &nbsp; &nbsp; &nbsp;# the default is the first option</font></div><div><font size="2"   >synchronous_commit = off &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# synchronization level;</font></div><div><font size="2"   >checkpoint_segments = 32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# in logfile segments, min 1, 16MB each</font></div><div><font size="2"   >log_destination = 'csvlog' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Valid values are combinations of</font></div><div><font size="2"   >logging_collector = on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Enable capturing of stderr and csvlog</font></div><div><font size="2"   >log_truncate_on_rotation = on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # If on, an existing log file with the</font></div><div><font size="2"   >log_min_duration_statement = 1s # -1 is disabled, 0 logs all statements</font></div><div><font size="2"   >log_checkpoints = on</font></div><div><font size="2"   >log_connections = on</font></div><div><font size="2"   >log_disconnections = on</font></div><div><font size="2"   >log_error_verbosity = verbose &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # terse, default, or verbose messages</font></div><div><font size="2"   >log_lock_waits = on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # log lock waits &gt;= deadlock_timeout</font></div><div><font size="2"   >log_timezone = 'PRC'</font></div><div><font size="2"   >datestyle = 'iso, mdy'</font></div><div><font size="2"   >timezone = 'PRC'</font></div><div><font size="2"   >lc_messages = 'C' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # locale for system error message</font></div><div><font size="2"   >lc_monetary = 'C' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # locale for monetary formatting</font></div><div><font size="2"   >lc_numeric = 'C' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# locale for number formatting</font></div><div><font size="2"   >lc_time = 'C' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # locale for time formatting</font></div><div><font size="2"   >default_text_search_config = 'pg_catalog.english'</font></div><div><font size="2"   >deadlock_timeout = 10ms</font></div><div><font size="2"   >wal_sync_method='open_sync'</font></div><p></p></pre></div><div><br></div><div>然后启动新的数据库集群,&nbsp;<span style="line-height: 28px;"   >为新的数据库集群创建表空间</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg_ctl start</font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# cd /data03/</font></div><div><font size="2"   >[root@db-172-16-3-150 data03]# ll</font></div><div><font size="2"   >total 32K</font></div><div><font size="2"   >drwxr-xr-x. 2 root &nbsp; &nbsp; root &nbsp; &nbsp; 4.0K Apr &nbsp;3 09:07 iso</font></div><div><font size="2"   >drwxr-xr-x. 2 root &nbsp; &nbsp; root &nbsp; &nbsp; 4.0K Apr &nbsp;2 10:39 kvmdisk</font></div><div><font size="2"   >drwx------. 2 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp;16K Feb 11 09:13 lost+found</font></div><div><font size="2"   >drwxr-xr-x. 2 postgres postgres 4.0K Feb 13 14:56 pgdata</font></div><div><font size="2"   >drwx------ &nbsp;3 postgres postgres 4.0K Apr &nbsp;4 17:20 pgtbs</font></div><div><font size="2"   >[root@db-172-16-3-150 data03]# mkdir pgtbs1</font></div><div><font size="2"   >[root@db-172-16-3-150 data03]# chown postgres:postgres pgtbs1</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; psql</font></div><div><font size="2"   >psql (9.4.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# create tablespace tbs location '/data03/pgtbs1';</font></div><div><font size="2"   >CREATE TABLESPACE</font></div><p></p></pre></div><div>创建两个新表, 注意表结构和需要恢复的表结构一致.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create table rt1(id int, info text, crt_time timestamp) tablespace tbs;</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# create table rt2(id int, info text, crt_time timestamp) tablespace tbs;</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>查看这两个表的数据文件路径.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select * from pg_relation_filepath('rt1');</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pg_relation_filepath &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------------</font></div><div><font size="2"   >&nbsp;pg_tblspc/16384/PG_9.4_201409291/12944/16385</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# select * from pg_relation_filepath('rt2');</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pg_relation_filepath &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------------</font></div><div><font size="2"   >&nbsp;pg_tblspc/16384/PG_9.4_201409291/12944/16391</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>退出数据库, 并关闭自动垃圾回收.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \q</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; cd $PGDATA</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; vi postgresql.conf</font></div><div><font size="2"   >autovacuum=off</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; pg_ctl stop -m fast</font></div><div><font size="2"   >waiting for server to shut down.... done</font></div><div><font size="2"   >server stopped</font></div><p></p></pre></div><div><br></div><div>来到需要恢复的表空间, 将数据文件, free space map文件拷贝到新集群对应的表空间目录下.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; cd /data03/pgtbs</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"   >total 4.0K</font></div><div><font size="2"   >drwx------ 3 postgres postgres 4.0K Apr &nbsp;4 17:22 PG_9.4_201409291</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; cd PG_9.4_201409291/</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"   >total 4.0K</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:23 94532</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; cd 94532/</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"   >total 896K</font></div><div><font size="2"   >-rw------- 1 postgres postgres 768K Apr &nbsp;4 17:24 94554</font></div><div><font size="2"   >-rw------- 1 postgres postgres &nbsp;96K Apr &nbsp;4 17:23 94554_fsm</font></div><div><font size="2"   >-rw------- 1 postgres postgres &nbsp; &nbsp;0 Apr &nbsp;4 17:22 94557</font></div><div><font size="2"   >-rw------- 1 postgres postgres &nbsp;32K Apr &nbsp;4 17:22 94559</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; pwd</font></div><div><font size="2"   >/data03/pgtbs/PG_9.4_201409291/94532</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; cd /data03/pgtbs1/PG_9.4_201409291/</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"   >total 4.0K</font></div><div><font size="2"   >drwx------ 2 postgres postgres 4.0K Apr &nbsp;4 17:33 12944</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; cd 12944/</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"   >total 64K</font></div><div><font size="2"   >-rw------- 1 postgres postgres &nbsp; 0 Apr &nbsp;4 17:33 16385</font></div><div><font size="2"   >-rw------- 1 postgres postgres &nbsp; 0 Apr &nbsp;4 17:33 16388</font></div><div><font size="2"   >-rw------- 1 postgres postgres 32K Apr &nbsp;4 17:33 16390</font></div><div><font size="2"   >-rw------- 1 postgres postgres &nbsp; 0 Apr &nbsp;4 17:33 16391</font></div><div><font size="2"   >-rw------- 1 postgres postgres &nbsp; 0 Apr &nbsp;4 17:33 16394</font></div><div><font size="2"   >-rw------- 1 postgres postgres 32K Apr &nbsp;4 17:33 16396</font></div><p></p></pre></div><div>拷贝前需要删除新表对应的数据文件, 使用需要恢复的数据文件覆盖之.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; rm -f 16385</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; cp /data03/pgtbs/PG_9.4_201409291/94532/94554* ./</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; mv 94554 16385</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; mv 94554_fsm 16385_fsm</font></div><p></p></pre></div><div>接下来我们要用单用户启动数据库, 并且查询一下需要恢复的表.</div><div>如果没有报错, 说明结构正确.</div><div>因为我们不知道需要恢复的数据文件的表结构, 所以这种操作非常繁琐, 特别是在这个表空间下有很多表的情况, 我们可能需要尝试多次.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; postgres --help</font></div><div><font size="2"   >postgres is the PostgreSQL server.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Usage:</font></div><div><font size="2"   >&nbsp; postgres [OPTION]...</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Options:</font></div><div><font size="2"   >&nbsp; -B NBUFFERS &nbsp; &nbsp; &nbsp; &nbsp;number of shared buffers</font></div><div><font size="2"   >&nbsp; -c NAME=VALUE &nbsp; &nbsp; &nbsp;set run-time parameter</font></div><div><font size="2"   >&nbsp; -C NAME &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print value of run-time parameter, then exit</font></div><div><font size="2"   >&nbsp; -d 1-5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; debugging level</font></div><div><font size="2"   >&nbsp; -D DATADIR &nbsp; &nbsp; &nbsp; &nbsp; database directory</font></div><div><font size="2"   >&nbsp; -e &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use European date input format (DMY)</font></div><div><font size="2"   >&nbsp; -F &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; turn fsync off</font></div><div><font size="2"   >&nbsp; -h HOSTNAME &nbsp; &nbsp; &nbsp; &nbsp;host name or IP address to listen on</font></div><div><font size="2"   >&nbsp; -i &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enable TCP/IP connections</font></div><div><font size="2"   >&nbsp; -k DIRECTORY &nbsp; &nbsp; &nbsp; Unix-domain socket location</font></div><div><font size="2"   >&nbsp; -l &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enable SSL connections</font></div><div><font size="2"   >&nbsp; -N MAX-CONNECT &nbsp; &nbsp; maximum number of allowed connections</font></div><div><font size="2"   >&nbsp; -o OPTIONS &nbsp; &nbsp; &nbsp; &nbsp; pass "OPTIONS" to each server process (obsolete)</font></div><div><font size="2"   >&nbsp; -p PORT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;port number to listen on</font></div><div><font size="2"   >&nbsp; -s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; show statistics after each query</font></div><div><font size="2"   >&nbsp; -S WORK-MEM &nbsp; &nbsp; &nbsp; &nbsp;set amount of memory for sorts (in kB)</font></div><div><font size="2"   >&nbsp; -V, --version &nbsp; &nbsp; &nbsp;output version information, then exit</font></div><div><font size="2"   >&nbsp; --NAME=VALUE &nbsp; &nbsp; &nbsp; set run-time parameter</font></div><div><font size="2"   >&nbsp; --describe-config &nbsp;describe configuration parameters, then exit</font></div><div><font size="2"   >&nbsp; -?, --help &nbsp; &nbsp; &nbsp; &nbsp; show this help, then exit</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Developer options:</font></div><div><font size="2"   >&nbsp; -f s|i|n|m|h &nbsp; &nbsp; &nbsp; forbid use of some plan types</font></div><div><font size="2"   >&nbsp; -n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do not reinitialize shared memory after abnormal exit</font></div><div><font size="2"   >&nbsp; -O &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allow system table structure changes</font></div><div><font size="2"   >&nbsp; -P &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; disable system indexes</font></div><div><font size="2"   >&nbsp; -t pa|pl|ex &nbsp; &nbsp; &nbsp; &nbsp;show timings after each query</font></div><div><font size="2"   >&nbsp; -T &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; send SIGSTOP to all backend processes if one dies</font></div><div><font size="2"   >&nbsp; -W NUM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait NUM seconds to allow attach from a debugger</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Options for single-user mode:</font></div><div><font size="2"   >&nbsp; --single &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selects single-user mode (must be first argument)</font></div><div><font size="2"   >&nbsp; DBNAME &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; database name (defaults to user name)</font></div><div><font size="2"   >&nbsp; -d 0-5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; override debugging level</font></div><div><font size="2"   >&nbsp; -E &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo statement before execution</font></div><div><font size="2"   >&nbsp; -j &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do not use newline as interactive query delimiter</font></div><div><font size="2"   >&nbsp; -r FILENAME &nbsp; &nbsp; &nbsp; &nbsp;send stdout and stderr to given file</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Options for bootstrapping mode:</font></div><div><font size="2"   >&nbsp; --boot &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selects bootstrapping mode (must be first argument)</font></div><div><font size="2"   >&nbsp; DBNAME &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; database name (mandatory argument in bootstrapping mode)</font></div><div><font size="2"   >&nbsp; -r FILENAME &nbsp; &nbsp; &nbsp; &nbsp;send stdout and stderr to given file</font></div><div><font size="2"   >&nbsp; -x NUM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; internal use</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Please read the documentation for the complete list of run-time</font></div><div><font size="2"   >configuration settings and how to set them on the command line or in</font></div><div><font size="2"   >the configuration file.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Report bugs to &lt;pgsql-bugs@postgresql.org&gt;.</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; postgres --single postgres&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >PostgreSQL stand-alone backend 9.4.1</font></div><div><font size="2"   >backend&gt; select * from rt1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1: id &nbsp;(typeid = 23, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2: info &nbsp; &nbsp; &nbsp; &nbsp;(typeid = 25, len = -1, typmod = -1, byval = f)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3: crt_time &nbsp; &nbsp;(typeid = 1114, len = 8, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ----</font></div><p></p></pre></div><div>退出单用户模式.</div><div>然后我们就可以启动数据库了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; pg_ctl start</font></div><div><font size="2"   >server starting</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; LOG: &nbsp;00000: redirecting log output to logging collector process</font></div><div><font size="2"   >HINT: &nbsp;Future log output will appear in directory "pg_log".</font></div><div><font size="2"   >LOCATION: &nbsp;SysLogger_Start, syslogger.c:645</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; psql</font></div><div><font size="2"   >psql (9.4.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><p></p></pre></div><div>直接查询这两张表是没有数据的, 因为MVCC, 这里涉及实际数据中行头部的xmin, xmax 信息, 以及当前数据库集群的pg_clog中的事务提交状态信息, 以及当前数据库集群控制文件的next xid信息等. 从而我们读不到数据是正常的.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select count(*) from rt1;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# select count(*) from rt2;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>接下来就是重点了, 既然数据文件已经覆盖了, 我们又因为pg_clog, xmin, xmax等导致数据无法读取, 那么怎么才能读出来呢?</div><div>要用到脏读工具pg_dirtyread.</div><div>克隆</div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; git clone https://github.com/omniti-labs/pgtreats</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >安装</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; cd pgtreats/</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"   >total 48K</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 autonomous_logging_tool</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 branding</font></div><div><font size="2"   >drwxrwxr-x 7 postgres postgres 4.0K Apr &nbsp;4 17:41 contrib</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 curo</font></div><div><font size="2"   >drwxrwxr-x 3 postgres postgres 4.0K Apr &nbsp;4 17:41 db-tests</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 functions</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 pg_log</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 pitr_clone</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 quickstats</font></div><div><font size="2"   >drwxrwxr-x 4 postgres postgres 4.0K Apr &nbsp;4 17:41 Sniffer-Postgres</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 table_growth</font></div><div><font size="2"   >drwxrwxr-x 7 postgres postgres 4.0K Apr &nbsp;4 17:41 tools</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; cd contrib/</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"   >total 20K</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 control</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 pg_dirtyread</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 pg_scoreboard</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 pg_stat_mem</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 scratch</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; cd pg_dirtyread/</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; ll</font></div><div><font size="2"   >total 20K</font></div><div><font size="2"   >-rw-rw-r-- 1 postgres postgres &nbsp;154 Apr &nbsp;4 17:41 Makefile</font></div><div><font size="2"   >-rw-rw-r-- 1 postgres postgres &nbsp; 88 Apr &nbsp;4 17:41 pg_dirtyread--1.0.sql</font></div><div><font size="2"   >-rw-rw-r-- 1 postgres postgres 3.6K Apr &nbsp;4 17:41 pg_dirtyread.c</font></div><div><font size="2"   >-rw-rw-r-- 1 postgres postgres &nbsp;152 Apr &nbsp;4 17:41 pg_dirtyread.control</font></div><div><font size="2"   >-rw-rw-r-- 1 postgres postgres &nbsp;960 Apr &nbsp;4 17:41 README.md</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; exit</font></div><div><font size="2"   >logout</font></div><div><font size="2"   >[root@db-172-16-3-150 data03]# cd /home/postgres/pgtreats/</font></div><div><font size="2"   >autonomous_logging_tool/ curo/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.git/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;quickstats/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tools/</font></div><div><font size="2"   >branding/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db-tests/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pg_log/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sniffer-Postgres/ &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >contrib/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; functions/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pitr_clone/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;table_growth/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >[root@db-172-16-3-150 data03]# cd /home/postgres/pgtreats/contrib/</font></div><div><font size="2"   >[root@db-172-16-3-150 contrib]# ll</font></div><div><font size="2"   >total 20K</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 control</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 pg_dirtyread</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 pg_scoreboard</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 pg_stat_mem</font></div><div><font size="2"   >drwxrwxr-x 2 postgres postgres 4.0K Apr &nbsp;4 17:41 scratch</font></div><p></p></pre></div><div>拷贝到postgresql源码的contrib目录下, 配置好pg_config路径后, 就可以编译安装了</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 contrib]# cp -R pg_dirtyread /opt/soft_bak/postgresql-9.4.1/contrib/</font></div><div><font size="2"   >[root@db-172-16-3-150 contrib]# cd /opt/soft_bak/postgresql-9.4.1/contrib/pg_dirtyread/</font></div><div><font size="2"   >[root@db-172-16-3-150 pg_dirtyread]# export PATH=/opt/pgsql/bin:$PATH</font></div><div><font size="2"   >[root@db-172-16-3-150 pg_dirtyread]# which pg_config</font></div><div><font size="2"   >/opt/pgsql/bin/pg_config</font></div><div><font size="2"   >[root@db-172-16-3-150 pg_dirtyread]# gmake clean</font></div><div><font size="2"   >rm -f pg_dirtyread.so pg_dirtyread.o</font></div><div><font size="2"   >[root@db-172-16-3-150 pg_dirtyread]# gmake</font></div><div><font size="2"   >gcc -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Wendif-labels -Wmissing-format-attribute -Wformat-security -fno-strict-aliasing -fwrapv -g -O2 -fpic -I. -I./ -I/opt/pgsql9.4.1/include/server -I/opt/pgsql9.4.1/include/internal -D_GNU_SOURCE -I/usr/include/libxml2 &nbsp; -c -o pg_dirtyread.o pg_dirtyread.c</font></div><div><font size="2"   >gcc -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Wendif-labels -Wmissing-format-attribute -Wformat-security -fno-strict-aliasing -fwrapv -g -O2 -fpic -L/opt/pgsql9.4.1/lib -Wl,--as-needed -Wl,-rpath,'/opt/pgsql9.4.1/lib',--enable-new-dtags &nbsp;-shared -o pg_dirtyread.so pg_dirtyread.o</font></div><div><font size="2"   >[root@db-172-16-3-150 pg_dirtyread]# gmake install</font></div><div><font size="2"   >/bin/mkdir -p '/opt/pgsql9.4.1/share/extension'</font></div><div><font size="2"   >/bin/mkdir -p '/opt/pgsql9.4.1/share/extension'</font></div><div><font size="2"   >/bin/mkdir -p '/opt/pgsql9.4.1/lib'</font></div><div><font size="2"   >/usr/bin/install -c -m 644 pg_dirtyread.control '/opt/pgsql9.4.1/share/extension/'</font></div><div><font size="2"   >/usr/bin/install -c -m 644 pg_dirtyread--1.0.sql '/opt/pgsql9.4.1/share/extension/'</font></div><div><font size="2"   >/usr/bin/install -c -m 755 &nbsp;pg_dirtyread.so '/opt/pgsql9.4.1/lib/'</font></div><p></p></pre></div><div>安装好之后, 创建这个扩展.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 pg_dirtyread]# su - postgres</font></div><div><font size="2"   >-bash: unalias: vi: not found</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; psql</font></div><div><font size="2"   >psql (9.4.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# create extension pg_dirtyread;</font></div><div><font size="2"   >CREATE EXTENSION</font></div><p></p></pre></div><div>现在我们来使用脏读工具读取数据吧</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select * from pg_relation_filepath('rt1');</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pg_relation_filepath &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------------</font></div><div><font size="2"   >&nbsp;pg_tblspc/16384/PG_9.4_201409291/12944/16385</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# select * from pg_relation_filepath('rt2');</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pg_relation_filepath &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------------</font></div><div><font size="2"   >&nbsp;pg_tblspc/16384/PG_9.4_201409291/12944/16391</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# select count(*) from rt1;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>已经读出数据了</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select count(*) from pg_dirtyread('rt1'::regclass) as t(id int, info text, crt_time timestamp);</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;10000</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>校验一下, 数据完全正确.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select sum(hashtext(t.*::text)) from pg_dirtyread('rt1'::regclass) as t(id int, info text, crt_time timestamp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp;185323099056</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# select * from pg_dirtyread('rt1'::regclass) as t(id int, info text, crt_time timestamp);</font></div><div><font size="2"   >&nbsp; id &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------+----------------------------------+----------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;1 | 53831c34cba80a1023252e759d8cb3f4 | 2015-04-04 17:23:15.519064</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;2 | 0b504a5d937e058cdcf0f18f2b260c69 | 2015-04-04 17:23:15.519222</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;3 | 6cd58d72286d8642289fb9dee979a47e | 2015-04-04 17:23:15.519231</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;4 | fdad49c2f5b639f6eb5d58477dbe6570 | 2015-04-04 17:23:15.519237</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;5 | ec4218b25163ec37e55fd5b2179ae8cc | 2015-04-04 17:23:15.519242</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;6 | cdd82952f7b6cd5bbbbc5abb5ba5d8f2 | 2015-04-04 17:23:15.519247</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;7 | eef311aad13be63ba5b5438c83cb85be | 2015-04-04 17:23:15.519252</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;8 | a7493052d3cc93b4fd296a27008fa908 | 2015-04-04 17:23:15.519257</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;9 | 311ada6d383bc37fb618c677b818e3d9 | 2015-04-04 17:23:15.519261</font></div><div><font size="2"   >&nbsp; &nbsp; 10 | 8f49cf44506464ce404e38b10b5d0145 | 2015-04-04 17:23:15.519266</font></div><div><font size="2"   >&nbsp; &nbsp; 11 | 109191b085d7576e83be7ed9fd0dd1bd | 2015-04-04 17:23:15.519271</font></div><div><font size="2"   >&nbsp; &nbsp; 12 | 1024828c11a43351311978fdf3092018 | 2015-04-04 17:23:15.519276</font></div><div><font size="2"   >&nbsp; &nbsp; ..................</font></div><p></p></pre></div><div><br></div><div>将这个数据恢复到另一张表.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# insert into rt2 select * from pg_dirtyread('rt1'::regclass) as t(id int, info text, crt_time timestamp);</font></div><div><font size="2"   >INSERT 0 10000</font></div><div><font size="2"   >postgres=# select * from rt2;</font></div><div><font size="2"   >&nbsp; id &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------+----------------------------------+----------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;1 | 53831c34cba80a1023252e759d8cb3f4 | 2015-04-04 17:23:15.519064</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;2 | 0b504a5d937e058cdcf0f18f2b260c69 | 2015-04-04 17:23:15.519222</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;3 | 6cd58d72286d8642289fb9dee979a47e | 2015-04-04 17:23:15.519231</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;4 | fdad49c2f5b639f6eb5d58477dbe6570 | 2015-04-04 17:23:15.519237</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;5 | ec4218b25163ec37e55fd5b2179ae8cc | 2015-04-04 17:23:15.519242</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;6 | cdd82952f7b6cd5bbbbc5abb5ba5d8f2 | 2015-04-04 17:23:15.519247</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;7 | eef311aad13be63ba5b5438c83cb85be | 2015-04-04 17:23:15.519252</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;8 | a7493052d3cc93b4fd296a27008fa908 | 2015-04-04 17:23:15.519257</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;9 | 311ada6d383bc37fb618c677b818e3d9 | 2015-04-04 17:23:15.519261</font></div><div><font size="2"   >&nbsp; &nbsp; 10 | 8f49cf44506464ce404e38b10b5d0145 | 2015-04-04 17:23:15.519266</font></div><div><font size="2"   >..................................</font></div><p></p></pre></div><div><br></div><div>好了, 问题又来了, 既然是脏读, 也就是说, 只要记录没有被垃圾回收掉, 就可以被读出来.</div><div>所以, 如果需要恢复的表里面有脏数据怎么办呢? 是不是也会一起读出来.</div><div>来实验一下.</div><div>关闭当前数据库, 回退到以前的数据库.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \q</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; pg_ctl stop -m fast</font></div><div><font size="2"   >waiting for server to shut down.... done</font></div><div><font size="2"   >server stopped</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; exit</font></div><div><font size="2"   >logout</font></div><div><font size="2"   >[root@db-172-16-3-150 ~]# cd /data02/</font></div><div><font size="2"   >[root@db-172-16-3-150 data02]# ll</font></div><div><font size="2"   >total 20K</font></div><div><font size="2"   >drwx------. 2 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp;16K Feb 11 09:13 lost+found</font></div><div><font size="2"   >drwxr-xr-x. 4 postgres postgres 4.0K Apr &nbsp;4 17:29 pgdata</font></div><div><font size="2"   >[root@db-172-16-3-150 data02]# cd pgdata/</font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# ll</font></div><div><font size="2"   >total 8.0K</font></div><div><font size="2"   >drwx------ &nbsp;19 postgres postgres 4.0K Apr &nbsp;4 17:52 pg_root</font></div><div><font size="2"   >drwx------. 19 postgres postgres 4.0K Apr &nbsp;4 17:28 pg_root_old</font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# mv pg_root pg_rootnew</font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# mv pg_root_old pg_root</font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# su - postgres</font></div><div><font size="2"   >-bash: unalias: vi: not found</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; pg_ctl start</font></div><div><font size="2"   >server starting</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; LOG: &nbsp;00000: redirecting log output to logging collector process</font></div><div><font size="2"   >HINT: &nbsp;Future log output will appear in directory "pg_log".</font></div><div><font size="2"   >LOCATION: &nbsp;SysLogger_Start, syslogger.c:645</font></div><p></p></pre></div><div><br></div><div>接下来我们要对t1, t2进行两笔更新操作.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; psql</font></div><div><font size="2"   >psql (9.4.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# \dt</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | Name | Type &nbsp;| &nbsp;Owner &nbsp;&nbsp;</font></div><div><font size="2"   >--------+------+-------+----------</font></div><div><font size="2"   >&nbsp;public | t &nbsp; &nbsp;| table | postgres</font></div><div><font size="2"   >&nbsp;public | tbl &nbsp;| table | postgres</font></div><div><font size="2"   >&nbsp;public | test | table | postgres</font></div><div><font size="2"   >(3 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# \c test</font></div><div><font size="2"   >You are now connected to database "test" as user "postgres".</font></div><div><font size="2"   >test=# \dt</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | Name | Type &nbsp;| &nbsp;Owner &nbsp;&nbsp;</font></div><div><font size="2"   >--------+------+-------+----------</font></div><div><font size="2"   >&nbsp;public | t1 &nbsp; | table | postgres</font></div><div><font size="2"   >&nbsp;public | t2 &nbsp; | table | postgres</font></div><div><font size="2"   >&nbsp;public | test | table | postgres</font></div><div><font size="2"   >(3 rows)</font></div><p></p></pre></div><div>更新</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# update t1 set info='new' where id=1;</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   >test=# update t2 set info='new' where id=2;</font></div><div><font size="2"   >UPDATE 1</font></div><p></p></pre></div><div>关闭数据库</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# \q</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; pg_ctl stop -m fast</font></div><div><font size="2"   >waiting for server to shut down.... done</font></div><div><font size="2"   >server stopped</font></div><p></p></pre></div><div><br></div><div>接下来又是重复恢复的过程.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; exit</font></div><div><font size="2"   >logout</font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# ll</font></div><div><font size="2"   >total 8.0K</font></div><div><font size="2"   >drwx------. 19 postgres postgres 4.0K Apr &nbsp;4 17:54 pg_root</font></div><div><font size="2"   >drwx------ &nbsp;19 postgres postgres 4.0K Apr &nbsp;4 17:52 pg_rootnew</font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# mv pg_root pg_rootold</font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# mv pg_rootnew pg_root</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >[root@db-172-16-3-150 pgdata]# su - postgres</font></div><div><font size="2"   >-bash: unalias: vi: not found</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; cd /data03/</font></div><div><font size="2"   >iso/ &nbsp; &nbsp; &nbsp; &nbsp;kvmdisk/ &nbsp; &nbsp;lost+found/ pgdata/ &nbsp; &nbsp; pgtbs/ &nbsp; &nbsp; &nbsp;pgtbs1/ &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; cd /data03/pgtbs1/PG_9.4_201409291/12944/</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; rm -f 16385*</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; cp /data03/pgtbs/PG_9.4_201409291/94532/94554* ./</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; mv 94554 16385</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; mv 94554_fsm 16385_fsm</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; pg_ctl start</font></div><div><font size="2"   >server starting</font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; LOG: &nbsp;00000: redirecting log output to logging collector process</font></div><div><font size="2"   >HINT: &nbsp;Future log output will appear in directory "pg_log".</font></div><div><font size="2"   >LOCATION: &nbsp;SysLogger_Start, syslogger.c:645</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; psql</font></div><div><font size="2"   >psql (9.4.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# select count(*) from rt1;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>但是请注意, 恢复数据时得到了意想不到的结果. 我们把更新前的数据也恢复了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select count(*) from pg_dirtyread('rt1'::regclass) as t(id int, info text, crt_time timestamp);</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;10001</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>这就是脏读恢复的弊端. 因为PostgreSQL的垃圾回收是有阈值的, 并不是产生一条垃圾马上就回收掉, 所以使用pg_dirtyread恢复表空间时, 恢复出来的数据可能是不一致的, 就如本例.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select * from pg_dirtyread('rt1'::regclass) as t(id int, info text, crt_time timestamp) where t.id=1;</font></div><div><font size="2"   >&nbsp;id | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----+----------------------------------+----------------------------</font></div><div><font size="2"   >&nbsp; 1 | 53831c34cba80a1023252e759d8cb3f4 | 2015-04-04 17:23:15.519064</font></div><div><font size="2"   >&nbsp; 1 | new &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 2015-04-04 17:23:15.519064</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div></div><div>这种情况我们可以通过人为观察来排除数据.&nbsp;</div><div><br></div><div>或者我们可以通过pageinspect插件读取xmin, t_infomask等数据来区分TUPLE是否为脏数据.</div><div>这里不再细说. 例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create extension pageinspect;</font></div><div><font size="2"   >CREATE EXTENSION</font></div></div><div><div><font size="2"   >postgres=# select * from heap_page_items(get_raw_page('rt1',1))</font></div><div><font size="2"   >postgres-# ;</font></div><div><font size="2"   >&nbsp;lp &nbsp;| lp_off | lp_flags | lp_len | &nbsp;t_xmin &nbsp;| t_xmax | t_field3 | t_ctid &nbsp;| t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"   >-----+--------+----------+--------+----------+--------+----------+---------+-------------+------------+--------+--------+-------</font></div><div><font size="2"   >&nbsp; &nbsp;1 | &nbsp;32696 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 72 | 98858591 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (1,1) &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp;2 | &nbsp;32624 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 72 | 98858591 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (1,2) &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp;3 | &nbsp;32552 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 72 | 98858591 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (1,3) &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div></div><p></p></pre></div><div>t_infomask的含义请参考源码htup_details.h详解.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* information stored in t_infomask:</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define HEAP_HASNULL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x0001 &nbsp;/* has null attribute(s) */</font></div><div><font size="2"   >#define HEAP_HASVARWIDTH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x0002 &nbsp;/* has variable-width attribute(s) */</font></div><div><font size="2"   >#define HEAP_HASEXTERNAL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x0004 &nbsp;/* has external stored attribute(s) */</font></div><div><font size="2"   >#define HEAP_HASOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0008 &nbsp;/* has an object-id field */</font></div><div><font size="2"   >#define HEAP_XMAX_KEYSHR_LOCK &nbsp; 0x0010 &nbsp;/* xmax is a key-shared locker */</font></div><div><font size="2"   >#define HEAP_COMBOCID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0020 &nbsp;/* t_cid is a combo cid */</font></div><div><font size="2"   >#define HEAP_XMAX_EXCL_LOCK &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0040 &nbsp;/* xmax is exclusive locker */</font></div><div><font size="2"   >#define HEAP_XMAX_LOCK_ONLY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0080 &nbsp;/* xmax, if valid, is only a locker */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp;/* xmax is a shared locker */</font></div><div><font size="2"   >#define HEAP_XMAX_SHR_LOCK &nbsp; &nbsp; &nbsp;(HEAP_XMAX_EXCL_LOCK | HEAP_XMAX_KEYSHR_LOCK)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define HEAP_LOCK_MASK &nbsp;(HEAP_XMAX_SHR_LOCK | HEAP_XMAX_EXCL_LOCK | \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;HEAP_XMAX_KEYSHR_LOCK)</font></div><div><font size="2"   >#define HEAP_XMIN_COMMITTED &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0100 &nbsp;/* t_xmin committed */</font></div><div><font size="2"   >#define HEAP_XMIN_INVALID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0200 &nbsp;/* t_xmin invalid/aborted */</font></div><div><font size="2"   >#define HEAP_XMIN_FROZEN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(HEAP_XMIN_COMMITTED|HEAP_XMIN_INVALID)</font></div><div><font size="2"   >#define HEAP_XMAX_COMMITTED &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0400 &nbsp;/* t_xmax committed */</font></div><div><font size="2"   >#define HEAP_XMAX_INVALID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0800 &nbsp;/* t_xmax invalid/aborted */</font></div><div><font size="2"   >#define HEAP_XMAX_IS_MULTI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x1000 &nbsp;/* t_xmax is a MultiXactId */</font></div><div><font size="2"   >#define HEAP_UPDATED &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x2000 &nbsp;/* this is UPDATEd version of row */</font></div><div><font size="2"   >#define HEAP_MOVED_OFF &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x4000 &nbsp;/* moved to another place by pre-9.0</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* VACUUM FULL; kept for binary</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* upgrade support */</font></div><div><font size="2"   >#define HEAP_MOVED_IN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x8000 &nbsp;/* moved from another place by pre-9.0</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* VACUUM FULL; kept for binary</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* upgrade support */</font></div><div><font size="2"   >#define HEAP_MOVED (HEAP_MOVED_OFF | HEAP_MOVED_IN)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define HEAP_XACT_MASK &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0xFFF0 &nbsp;/* visibility-related bits */</font></div><p></p></pre></div><div><br></div><div><br></div><div>附上脏读源码如下</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >#include "postgres.h"</font></div><div><font size="2"   >#include "funcapi.h"</font></div><div><font size="2"   >#include "utils/tqual.h"</font></div><div><font size="2"   >#include "utils/rel.h"</font></div><div><font size="2"   >#include "catalog/pg_type.h"</font></div><div><font size="2"   >#include "access/tupconvert.h"</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >typedef struct</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; Relation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rel;</font></div><div><font size="2"   >&nbsp; &nbsp; HeapScanDesc &nbsp; &nbsp; &nbsp; &nbsp;scan;</font></div><div><font size="2"   >&nbsp; &nbsp; TupleDesc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reltupdesc;</font></div><div><font size="2"   >&nbsp; &nbsp; TupleConversionMap &nbsp;*map;</font></div><div><font size="2"   >} pg_dirtyread_ctx;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >PG_MODULE_MAGIC;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >PG_FUNCTION_INFO_V1(pg_dirtyread);</font></div><div><font size="2"   >Datum pg_dirtyread(PG_FUNCTION_ARGS);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Datum</font></div><div><font size="2"   >pg_dirtyread(PG_FUNCTION_ARGS)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; FuncCallContext &nbsp; &nbsp; *funcctx;</font></div><div><font size="2"   >&nbsp; &nbsp; MemoryContext &nbsp; &nbsp; &nbsp; oldcontext;</font></div><div><font size="2"   >&nbsp; &nbsp; pg_dirtyread_ctx &nbsp; &nbsp;*usr_ctx;</font></div><div><font size="2"   >&nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;</font></div><div><font size="2"   >&nbsp; &nbsp; HeapTuple &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuplein, tupleout;</font></div><div><font size="2"   >&nbsp; &nbsp; TupleDesc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdesc;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; if (SRF_IS_FIRSTCALL())</font></div><div><font size="2"   >&nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; relid = PG_GETARG_OID(0);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (OidIsValid(relid))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usr_ctx = (pg_dirtyread_ctx *) palloc(sizeof(pg_dirtyread_ctx));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usr_ctx-&gt;rel = heap_open(relid, AccessShareLock);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usr_ctx-&gt;reltupdesc = RelationGetDescr(usr_ctx-&gt;rel);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get_call_result_type(fcinfo, NULL, &amp;tupdesc);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;tuple_desc = BlessTupleDesc(tupdesc);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usr_ctx-&gt;map = convert_tuples_by_position(usr_ctx-&gt;reltupdesc, funcctx-&gt;tuple_desc, "Error converting tuple descriptors!");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usr_ctx-&gt;scan = heap_beginscan(usr_ctx-&gt;rel, SnapshotAny, 0, NULL);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = (void *) usr_ctx;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();</font></div><div><font size="2"   >&nbsp; &nbsp; usr_ctx = (pg_dirtyread_ctx *) funcctx-&gt;user_fctx;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; if ((tuplein = heap_getnext(usr_ctx-&gt;scan, ForwardScanDirection)) != NULL)</font></div><div><font size="2"   >&nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; tupleout = do_convert_tuple(tuplein, usr_ctx-&gt;map);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, HeapTupleGetDatum(tupleout));</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; heap_endscan(usr_ctx-&gt;scan);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; heap_close(usr_ctx-&gt;rel, AccessShareLock);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_DONE(funcctx);</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>最后需要注意的是, 如果你的数据中有一些变长自动超出TOAST阈值, 可能会有一些存在TOAST里面, 请同时恢复TOAST数据, 否则可能导致数据缺失.</div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://raw.githubusercontent.com/omniti-labs/pgtreats/master/contrib/pg_dirtyread/pg_dirtyread.c"   >https://raw.githubusercontent.com/omniti-labs/pgtreats/master/contrib/pg_dirtyread/pg_dirtyread.c</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.depesz.com/2012/04/04/lets-talk-dirty/"   >http://www.depesz.com/2012/04/04/lets-talk-dirty/</a></div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://dba.stackexchange.com/questions/58704/how-do-i-access-a-old-saved-tablespace-after-reinstalling-postgres"   >http://dba.stackexchange.com/questions/58704/how-do-i-access-a-old-saved-tablespace-after-reinstalling-postgres</a></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL dirty read extension pg_dirtyread used to recovery stand alone tablespace - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>