<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">矩阵行列, 和, 数学期望计算 - rowSums,rowMeans,colSums,colMeans</h2>
	<h5 id="">2015-04-10 15:12:17&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020153103105190/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><span style="line-height: 28px;"   >rowSums</span></div><div><span style="line-height: 28px;"   >rowMeans</span></div><div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >colSums</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >colMeans</span></div></div><div>在R中很容易计算一个矩阵的各行和和各列和以及各行的平均值和各列的平均值。例如：</div><div><br></div><div>&gt; A=matrix(1:12,3,4)</div><div><br></div><div>&gt; A</div><div>&nbsp; &nbsp; &nbsp;[,1] [,2] [,3] [,4]</div><div>[1,] &nbsp; &nbsp;1 &nbsp; &nbsp;4 &nbsp; &nbsp;7 &nbsp; 10</div><div>[2,] &nbsp; &nbsp;2 &nbsp; &nbsp;5 &nbsp; &nbsp;8 &nbsp; 11</div><div>[3,] &nbsp; &nbsp;3 &nbsp; &nbsp;6 &nbsp; &nbsp;9 &nbsp; 12</div><div><br></div><div>&gt; rowSums(A)</div><div>[1] 22 26 30</div><div><br></div><div>&gt; rowMeans(A)</div><div>[1] 5.5 6.5 7.5</div><div><br></div><div>&gt; colSums(A)</div><div>[1] &nbsp;6 15 24 33</div><div><br></div><div>&gt; colMeans(A)</div><div>[1] &nbsp;2 &nbsp;5 &nbsp;8 11</div><div><br></div><div>除此之外, 使用apply函数, 也可以计算. 而且更灵活.</div><div><div>&gt; args(apply)</div><div>function (X, MARGIN, FUN, ...)</div><div>其中：x为矩阵，MARGIN用来指定是对行运算还是对列运算，MARGIN＝1表示对行运算，MARGIN＝2表示对列运算，FUN用来指定运算函数, ...用来给定FUN中需要的其它的参数，例如：</div><div>计算每行的sum.</div><div>&gt; apply(A,1,sum)</div><div>[1] 22 26 30</div><div><span style="line-height: 28px;"   >计算每行的数学期望.</span></div><div>&gt; apply(A,1,mean)</div><div>[1] 5.5 6.5 7.5</div><div><span style="line-height: 28px;"   >计算每列的sum.</span></div><div>&gt; apply(A,2,sum)</div><div>[1] 6 15 24 33</div><div><span style="line-height: 28px;"   >计算每列的数学期望.</span></div><div>&gt; apply(A,2,mean)</div><div>[1] 2 5 8 11</div><div><br></div><div>apply()函数功能强大，我们可以对矩阵的行或者列进行其它运算，例如：</div><div>计算每一列的方差(var函数求方差)</div><div>&gt; A=matrix(rnorm(100),20,5)</div><div>&gt; apply(A,2,var)</div><div>[1] 0.4641787 1.4331070 0.3186012 1.3042711 0.5238485</div><div>还可以使用类似lambda风格.</div><div>&gt; apply(A,2, function(x,a) x*a,a=2)&nbsp;</div><div>&nbsp; [,1] [,2] [,3] [,4]</div><div>[1,] &nbsp; 2 &nbsp; 8 &nbsp; 14 &nbsp; 20</div><div>[2,] &nbsp; 4 &nbsp; 10 &nbsp; 16 &nbsp; 22</div><div>[3,] &nbsp; 6 &nbsp; 12 &nbsp; 18 &nbsp; 24</div><div>注意：apply(A,2,function(x,a)x*a,a=2)与A*2效果相同，此处旨在说明如何应用alpply函数。</div></div><div><br></div><div>[参考]</div><div>1.&nbsp;&gt; help("apply")</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >apply &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; package:base &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; R Documentation</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Apply Functions Over Array Margins</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Description:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;Returns a vector or array or list of values obtained by applying a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;function to margins of an array or matrix.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Usage:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;apply(X, MARGIN, FUN, ...)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >Arguments:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;X: an array, including a matrix.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; MARGIN: a vector giving the subscripts which the function will be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; applied over. &nbsp;E.g., for a matrix ‘1’ indicates rows, ‘2’</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indicates columns, ‘c(1, 2)’ indicates rows and columns.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Where ‘X’ has named dimnames, it can be a character vector</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selecting dimension names.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;FUN: the function to be applied: see ‘Details’. &nbsp;In the case of</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; functions like ‘+’, ‘%*%’, etc., the function name must be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backquoted or quoted.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;...: optional arguments to ‘FUN’.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Details:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;If ‘X’ is not an array but an object of a class with a non-null</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;‘dim’ value (such as a data frame), ‘apply’ attempts to coerce it</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;to an array via ‘as.matrix’ if it is two-dimensional (e.g., a data</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;frame) or via ‘as.array’.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;‘FUN’ is found by a call to ‘match.fun’ and typically is either a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;function or a symbol (e.g., a backquoted name) or a character</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;string specifying a function to be searched for from the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;environment of the call to ‘apply’.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;Arguments in ‘...’ cannot have the same name as any of the other</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;arguments, and care may be needed to avoid partial matching to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;‘MARGIN’ or ‘FUN’. &nbsp;In general-purpose code it is good practice to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name the first three arguments if ‘...’ is passed through: this</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;both avoids partial matching to ‘MARGIN’ or ‘FUN’ and ensures that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;a sensible error message is given if arguments named ‘X’, ‘MARGIN’</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;or ‘FUN’ are passed through ‘...’.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Value:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;If each call to ‘FUN’ returns a vector of length ‘n’, then ‘apply’</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;returns an array of dimension ‘c(n, dim(X)[MARGIN])’ if ‘n &gt; 1’.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;If ‘n’ equals ‘1’, ‘apply’ returns a vector if ‘MARGIN’ has length</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;1 and an array of dimension ‘dim(X)[MARGIN]’ otherwise. &nbsp;If ‘n’ is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;‘0’, the result has length 0 but not necessarily the ‘correct’</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;dimension.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;If the calls to ‘FUN’ return vectors of different lengths, ‘apply’</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;returns a list of length ‘prod(dim(X)[MARGIN])’ with ‘dim’ set to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;‘MARGIN’ if this has length greater than one.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;In all cases the result is coerced by ‘as.vector’ to one of the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;basic vector types before the dimensions are set, so that (for</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;example) factor results will be coerced to a character array.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >References:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;Language_. &nbsp;Wadsworth &amp; Brooks/Cole.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >See Also:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;‘lapply’ and there, ‘simplify2array’; ‘tapply’, and convenience</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;functions ‘sweep’ and ‘aggregate’.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Examples:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;## Compute row and column sums for a matrix:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;x &lt;- cbind(x1 = 3, x2 = c(4:1, 2:5))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;dimnames(x)[[1]] &lt;- letters[1:8]</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;apply(x, 2, mean, trim = .2)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;col.sums &lt;- apply(x, 2, sum)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;row.sums &lt;- apply(x, 1, sum)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;rbind(cbind(x, Rtot = row.sums), Ctot = c(col.sums, sum(col.sums)))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;stopifnot( apply(x, 2, is.vector))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;## Sort the columns of a matrix</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;apply(x, 2, sort)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;##- function with extra args:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;cave &lt;- function(x, c1, c2) c(mean(x[c1]), mean(x[c2]))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;apply(x, 1, cave, &nbsp;c1 = "x1", c2 = c("x1","x2"))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;ma &lt;- matrix(c(1:4, 1, 6:8), nrow = 2)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;ma</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;apply(ma, 1, table) &nbsp;#--&gt; a list of length 2</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;apply(ma, 1, stats::quantile) # 5 x n matrix with rownames</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;stopifnot(dim(ma) == dim(apply(ma, 1:2, sum)))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;## Example with different lengths for each call</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;z &lt;- array(1:24, dim = 2:4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;zseq &lt;- apply(z, 1:2, function(x) seq_len(max(x)))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;zseq &nbsp; &nbsp; &nbsp; &nbsp; ## a 2 x 3 matrix</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;typeof(zseq) ## list</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;dim(zseq) ## 2 3</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;zseq[1,]</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;apply(z, 3, function(x) seq_len(max(x)))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;# a list without a dim attribute</font></div><div></div><p></p></pre></div><div><br></div><div><br></div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="矩阵行列, 和, 数学期望计算 - rowSums,rowMeans,colSums,colMeans - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>