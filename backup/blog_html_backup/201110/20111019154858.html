<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Don't Confuse PostgreSQL Per-Column Privilege and Table level Privilege</h2>
	<h5 id="">2011-10-19 15:48:58&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020119193364585/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">今天一位兄弟问我一个比较奇怪的问题，一开始我也觉得很奇怪。<wbr><div>情况是这样的：</div><div>1. &nbsp;把用户A表test的SELECT权限给了用户B, 假设test表有10列。</div><div>2. &nbsp;通过REVOKE SELECT (column_name1,... ) ON test FROM USER_B; 从用户B那里回收test表的其中某些列的查询权限。</div><div>3. &nbsp;但是用户B还是可以查询这些看似被回收了查询权限的列。</div><div><br></div><div>下面来看一个测试 :&nbsp;</div><div>首先创建一个digoal用户的测试表 :&nbsp;</div><div><div>digoal=&gt; create table column_privilege_test&nbsp;</div><div>digoal-&gt; (id int,info text);</div><div>CREATE TABLE</div><div>权限赋予给test用户 :&nbsp;</div><div>digoal=&gt; grant select on column_privilege_test to test;</div><div>GRANT</div><div>插入测试数据 :&nbsp;</div><div>digoal=&gt; insert into column_privilege_test select generate_series(1,100000),'digoal';</div><div>INSERT 0 100000</div><div>连接到test用户下面，测试查询权限。</div><div>digoal=&gt; \c digoal test</div><div>You are now connected to database "digoal" as user "test".</div><div>digoal=&gt; select * from digoal.column_privilege_test limit 1;</div><div>&nbsp;id | &nbsp;info &nbsp;</div><div>----+--------</div><div>&nbsp; 1 | digoal</div><div>(1 row)</div></div><div>连接到digoal用户，回收id列的查询权限。</div><div><div>digoal=&gt; \c digoal digoal</div><div>You are now connected to database "digoal" as user "digoal".</div><div>digoal=&gt; revoke select (id) on column_privilege_test from test;</div><div>REVOKE</div><div>再次到test 用户下查询，id列的查询还是依旧正常。</div><div>digoal=&gt; \c digoal test</div><div>You are now connected to database "digoal" as user "test".</div><div>digoal=&gt; select * from digoal.column_privilege_test limit 1;</div><div>&nbsp;id | &nbsp;info &nbsp;</div><div>----+--------</div><div>&nbsp; 1 | digoal</div><div>(1 row)</div></div><div>来看看这个表的权限情况，显然赋予的时表级别的查询权限，不能通过列级别的权限来回收。</div><div><div>digoal=&gt; \c digoal digoal</div><div>You are now connected to database "digoal" as user "digoal".</div><div>digoal=&gt; \dp+ column_privilege_test&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Access privileges</div><div>&nbsp;Schema | &nbsp; &nbsp; &nbsp; &nbsp; Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Type &nbsp;| &nbsp; Access privileges &nbsp; | Column access privileges&nbsp;</div><div>--------+-----------------------+-------+-----------------------+--------------------------</div><div>&nbsp;digoal | column_privilege_test | table | digoal=arwdDxt/digoal+|&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; | test=r/digoal &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</div><div>(1 row)</div></div><div><br></div><div>下面来看一个列级别可以回收的例子：</div><div>digoal=&gt; grant select(id,info) on column_privilege_test to test;</div><div>这里看到的权限是列级别的了。</div><div><div>digoal=&gt; \dp+ column_privilege_test&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Access privileges</div><div>&nbsp;Schema | &nbsp; &nbsp; &nbsp; &nbsp; Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Type &nbsp;| &nbsp; Access privileges &nbsp; | Column access privileges&nbsp;</div><div>--------+-----------------------+-------+-----------------------+--------------------------</div><div>&nbsp;digoal | column_privilege_test | table | digoal=arwdDxt/digoal | id: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +</div><div>&nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; test=r/digoal &nbsp; &nbsp; &nbsp; &nbsp; +</div><div>&nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | info: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +</div><div>&nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; test=r/digoal</div><div>(1 row)</div></div><div>test用户查询当然是没有问题的。</div><div><div>digoal=&gt; \c digoal test</div><div>You are now connected to database "digoal" as user "test".</div><div>digoal=&gt; select * from digoal.column_privilege_test limit 1;</div><div>&nbsp;id | &nbsp;info &nbsp;</div><div>----+--------</div><div>&nbsp; 1 | digoal</div><div>(1 row)</div><div>然后回收掉id的权限。</div><div>digoal=&gt; \c digoal digoal</div><div>You are now connected to database "digoal" as user "digoal".</div><div>digoal=&gt; revoke select(id) on column_privilege_test from test;</div><div>REVOKE</div><div>digoal=&gt; \dp+ column_privilege_test&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Access privileges</div><div>&nbsp;Schema | &nbsp; &nbsp; &nbsp; &nbsp; Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Type &nbsp;| &nbsp; Access privileges &nbsp; | Column access privileges&nbsp;</div><div>--------+-----------------------+-------+-----------------------+--------------------------</div><div>&nbsp;digoal | column_privilege_test | table | digoal=arwdDxt/digoal | info: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +</div><div>&nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; test=r/digoal</div><div>(1 row)</div><div>现在test用户查询id就报错了。只能查询info列。</div><div>digoal=&gt; \c digoal test</div><div>You are now connected to database "digoal" as user "test".</div><div>digoal=&gt; select * from digoal.column_privilege_test limit 1;</div><div>ERROR: &nbsp;permission denied for relation column_privilege_test</div><div>digoal=&gt; select info from digoal.column_privilege_test limit 1;</div><div>&nbsp; info &nbsp;</div><div>--------</div><div>&nbsp;digoal</div><div>(1 row)</div></div><div><br></div><div><br></div><div>从语法部分也可以看出这两部分权限的控制是分开处理的 :&nbsp;</div><div><div>Command: &nbsp; &nbsp; GRANT</div><div>Description: define access privileges</div><div>Syntax:</div><div>GRANT { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER }</div><div>&nbsp; &nbsp; [, ...] | ALL [ PRIVILEGES ] }</div><div>&nbsp; &nbsp; ON { [ TABLE ] table_name [, ...]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| ALL TABLES IN SCHEMA schema_name [, ...] }</div><div>&nbsp; &nbsp; TO { [ GROUP ] role_name | PUBLIC } [, ...] [ WITH GRANT OPTION ]</div><div><br></div><div>GRANT { { SELECT | INSERT | UPDATE | REFERENCES } ( column [, ...] )</div><div>&nbsp; &nbsp; [, ...] | ALL [ PRIVILEGES ] ( column [, ...] ) }</div><div>&nbsp; &nbsp; ON [ TABLE ] table_name [, ...]</div><div>&nbsp; &nbsp; TO { [ GROUP ] role_name | PUBLIC } [, ...] [ WITH GRANT OPTION ]</div></div><div><br></div><div><div>Command: &nbsp; &nbsp; REVOKE</div><div>Description: remove access privileges</div><div>Syntax:</div><div>REVOKE [ GRANT OPTION FOR ]</div><div>&nbsp; &nbsp; { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER }</div><div>&nbsp; &nbsp; [, ...] | ALL [ PRIVILEGES ] }</div><div>&nbsp; &nbsp; ON { [ TABLE ] table_name [, ...]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| ALL TABLES IN SCHEMA schema_name [, ...] }</div><div>&nbsp; &nbsp; FROM { [ GROUP ] role_name | PUBLIC } [, ...]</div><div>&nbsp; &nbsp; [ CASCADE | RESTRICT ]</div><div><br></div><div>REVOKE [ GRANT OPTION FOR ]</div><div>&nbsp; &nbsp; { { SELECT | INSERT | UPDATE | REFERENCES } ( column [, ...] )</div><div>&nbsp; &nbsp; [, ...] | ALL [ PRIVILEGES ] ( column [, ...] ) }</div><div>&nbsp; &nbsp; ON [ TABLE ] table_name [, ...]</div><div>&nbsp; &nbsp; FROM { [ GROUP ] role_name | PUBLIC } [, ...]</div><div>&nbsp; &nbsp; [ CASCADE | RESTRICT ]</div></div></div>
	</div>
</div>
</body>
</html>