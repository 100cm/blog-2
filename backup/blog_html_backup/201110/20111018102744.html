<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.1 nearest-neighbor search use gist index</h2>
	<h5 id="">2011-10-18 10:27:44&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402011918101412105/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">PostgreSQL 9.1 新增了gist索引按近邻来排序的操作符(order by operator)。<div>例如：</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; &nbsp;create table gist_test (id serial primary key,location point);</font></div><div><font size="2"  >NOTICE: &nbsp;CREATE TABLE will create implicit sequence "gist_test_id_seq" for serial column "gist_test.id"</font></div><div><font size="2"  >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "gist_test_pkey" for table "gist_test"</font></div><div><font size="2"  >CREATE TABLE</font></div><div><font size="2"  >Time: 40.290 ms</font></div><div><div><font size="2"  >digoal=&gt; insert into gist_test (location) select cast ('(1,'||generate_series(1,1000000)||')' as point);</font></div><div><font size="2"  >INSERT 0 1000000</font></div><div><font size="2"  >Time: 11143.666 ms</font></div></div><div><div><font size="2"  >digoal=&gt; create index idx_gist_test_1 on gist_test using gist (location point_ops);</font></div><div><font size="2"  >CREATE INDEX</font></div><div><font size="2"  >Time: 14874.948 ms</font></div></div><p></p></pre></div><div>那么以下操作将按索引扫描输出结果。效率非常之高。</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select * from gist_test order by location &lt;-&gt; cast ('(1,2)' as point) limit 10;</font></div><div><font size="2"  >&nbsp;id | location&nbsp;</font></div><div><font size="2"  >----+----------</font></div><div><font size="2"  >&nbsp; 2 | (1,2)</font></div><div><font size="2"  >&nbsp; 3 | (1,3)</font></div><div><font size="2"  >&nbsp; 1 | (1,1)</font></div><div><font size="2"  >&nbsp; 4 | (1,4)</font></div><div><font size="2"  >&nbsp; 5 | (1,5)</font></div><div><font size="2"  >&nbsp; 6 | (1,6)</font></div><div><font size="2"  >&nbsp; 7 | (1,7)</font></div><div><font size="2"  >&nbsp; 8 | (1,8)</font></div><div><font size="2"  >&nbsp; 9 | (1,9)</font></div><div><font size="2"  >&nbsp;10 | (1,10)</font></div><div><font size="2"  >(10 rows)</font></div><div><font size="2"  >Time: 0.716 ms</font></div><div><font size="2"  >digoal=&gt; explain verbose select * from gist_test order by location &lt;-&gt; cast ('(1,2)' as point) limit 10;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >---------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Limit &nbsp;(cost=0.00..0.50 rows=10 width=20)</font></div><div><font size="2"  >&nbsp; &nbsp;Output: id, location, ((location &lt;-&gt; '(1,2)'::point))</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_gist_test_1 on digoal.gist_test &nbsp;(cost=0.00..50374.43 rows=1000000 width=20)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, location, (location &lt;-&gt; '(1,2)'::point)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Order By: (gist_test.location &lt;-&gt; '(1,2)'::point)</font></div><div><font size="2"  >(5 rows)</font></div><div><font size="2"  >Time: 0.465 ms</font></div><p></p></pre></div><div><br></div><div>如果没有索引的话，效率是这样的 :</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; drop index idx_gist_test_1 ;</font></div><div><font size="2"  >DROP INDEX</font></div><div><font size="2"  >Time: 60.281 ms</font></div><div><font size="2"  >digoal=&gt; explain verbose select * from gist_test order by location &lt;-&gt; cast ('(1,2)' as point) limit 10;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >---------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Limit &nbsp;(cost=40479.64..40479.67 rows=10 width=20)</font></div><div><font size="2"  >&nbsp; &nbsp;Output: id, location, ((location &lt;-&gt; '(1,2)'::point))</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Sort &nbsp;(cost=40479.64..42979.64 rows=1000000 width=20)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, location, ((location &lt;-&gt; '(1,2)'::point))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Key: ((gist_test.location &lt;-&gt; '(1,2)'::point))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on digoal.gist_test &nbsp;(cost=0.00..18870.00 rows=1000000 width=20)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, location, (location &lt;-&gt; '(1,2)'::point)</font></div><div><font size="2"  >(7 rows)</font></div><div><font size="2"  >Time: 0.613 ms</font></div><div><font size="2"  >digoal=&gt; select * from gist_test order by location &lt;-&gt; cast ('(1,2)' as point) limit 10;</font></div><div><font size="2"  >&nbsp;id | location&nbsp;</font></div><div><font size="2"  >----+----------</font></div><div><font size="2"  >&nbsp; 2 | (1,2)</font></div><div><font size="2"  >&nbsp; 3 | (1,3)</font></div><div><font size="2"  >&nbsp; 1 | (1,1)</font></div><div><font size="2"  >&nbsp; 4 | (1,4)</font></div><div><font size="2"  >&nbsp; 5 | (1,5)</font></div><div><font size="2"  >&nbsp; 6 | (1,6)</font></div><div><font size="2"  >&nbsp; 7 | (1,7)</font></div><div><font size="2"  >&nbsp; 8 | (1,8)</font></div><div><font size="2"  >&nbsp; 9 | (1,9)</font></div><div><font size="2"  >&nbsp;10 | (1,10)</font></div><div><font size="2"  >(10 rows)</font></div><div><font size="2"  >Time: 437.322 ms</font></div><p></p></pre></div><div>效果立竿见影。</div><div><br></div><div>&lt;-&gt;操作符的使用场景 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=&gt; create or replace function get_type(i_oid oid) returns text as $$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >declare</font></div><div><font size="2"  >v_type text;</font></div><div><font size="2"  >begin</font></div><div><font size="2"  >select typname into v_type from pg_type where oid=i_oid limit 1;</font></div><div><font size="2"  >return v_type;</font></div><div><font size="2"  >end;</font></div><div><font size="2"  >$$ language plpgsql;</font></div></div><div><font size="2"  ><br></font></div><div><div><font size="2"  >digoal=&gt; select oprname,get_type(oprleft),get_type(oprright) from pg_operator where oprname='&lt;-&gt;';</font></div><div><font size="2"  >&nbsp;oprname | get_type | get_type&nbsp;</font></div><div><font size="2"  >---------+----------+----------</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | point &nbsp; &nbsp;| point</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | point &nbsp; &nbsp;| lseg</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | point &nbsp; &nbsp;| path</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | point &nbsp; &nbsp;| box</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | point &nbsp; &nbsp;| line</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | point &nbsp; &nbsp;| circle</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | lseg &nbsp; &nbsp; | lseg</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | lseg &nbsp; &nbsp; | box</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | lseg &nbsp; &nbsp; | line</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | path &nbsp; &nbsp; | path</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | box &nbsp; &nbsp; &nbsp;| box</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | polygon &nbsp;| polygon</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | line &nbsp; &nbsp; | box</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | line &nbsp; &nbsp; | line</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | circle &nbsp; | polygon</font></div><div><font size="2"  >&nbsp;&lt;-&gt; &nbsp; &nbsp; | circle &nbsp; | circle</font></div><div><font size="2"  >(16 rows)</font></div></div><p></p></pre></div><div><br></div><div>另外, postgis 2.0也增加了&lt;-&gt; operator.</div><div>目前使用的是KNN算法.</div><div>raw结果有一点点的误差, 如果可以接受的话, 不需要重排因为会增加开销. 我测试了陌陌发现也未修正这个结果, 但是误差并不算大.</div><div>例如以下order by geometry &lt;-&gt; geometry的结果有一定误差 :&nbsp;</div><div><div><pre class="prettyprint"  ><div><font size="2"  >&nbsp; user_id &nbsp;| st_distance_sphere&nbsp;</font></div><div><font size="2"  >-----------+--------------------</font></div><div><font size="2"  >&nbsp;105137620 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"  >&nbsp;302151638 | &nbsp; 17.1253091983443</font></div><div><font size="2"  >&nbsp;284707523 | &nbsp; 297.073719657173</font></div><div><font size="2"  >&nbsp;305881734 | &nbsp; 468.361916333953</font></div><div><font size="2"  >&nbsp;304983707 | &nbsp; 493.019043438912</font></div><div><font size="2"  >&nbsp;283249783 | &nbsp; 861.119017114206</font></div><div><font size="2"  >&nbsp;295055791 | &nbsp; 861.135253407573</font></div><div><font size="2"  >&nbsp;303738892 | &nbsp; 734.735620683819</font></div><div><font size="2"  >&nbsp;283827579 | &nbsp; 734.735620683819</font></div><div><font size="2"  >&nbsp;283394455 | &nbsp; 772.808877940454</font></div><div><font size="2"  >&nbsp;300115846 | &nbsp; 943.892953926387</font></div><div><font size="2"  >&nbsp;277775985 | &nbsp; 1082.41544076904</font></div><p></p></pre></div></div><div>符号介绍 :&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >&lt;-&gt; : </font></p><p><font size="2"  >Returns the distance between two points.&nbsp;</font></p><p><font size="2"  >For point / point checks it uses floating point accuracy (as opposed to the double precision accuracy of the underlying point geometry).&nbsp;</font></p><p><font size="2"  >For other geometry types the distance between the floating point bounding box centroids is returned.&nbsp;</font></p><p><font size="2"  >Useful for doing distance ordering and nearest neighbor limits using KNN gist functionality.</font></p></pre></div><div>创建符号的SQL如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgis/postgis.sql.in.c</font></div><div><font size="2"  ><br></font></div><div><div><font size="2"  >#if POSTGIS_PGSQL_VERSION &gt;= 91</font></div><div><font size="2"  >CREATE OPERATOR &lt;-&gt; (</font></div><div><font size="2"  >&nbsp; &nbsp; LEFTARG = geometry, RIGHTARG = geometry, PROCEDURE = geometry_distance_centroid,</font></div><div><font size="2"  >&nbsp; &nbsp; COMMUTATOR = '&lt;-&gt;'</font></div><div><font size="2"  >);</font></div></div><p></p></pre></div><div><wbr><div>使用到如下函数 :&nbsp;</div></div></div><div>-- Availability: 2.0.0</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >CREATE OR REPLACE FUNCTION geometry_distance_centroid(geom1 geometry, geom2 geometry)&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; RETURNS float8&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; AS 'MODULE_PATHNAME' ,'gserialized_distance_centroid_2d'</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LANGUAGE 'c' IMMUTABLE STRICT;</font></div><p></p></pre></div><div><br></div><div>源码 :&nbsp;</div><div>postgis/gserialized_gist_2d.c</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/***********************************************************************</font></div><div><font size="2"  >* GiST 2-D Index Operator Functions</font></div><div><font size="2"  >*/</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >PG_FUNCTION_INFO_V1(gserialized_distance_centroid_2d);</font></div><div><font size="2"  >Datum gserialized_distance_centroid_2d(PG_FUNCTION_ARGS)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; BOX2DF b1, b2;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; Datum gs1 = PG_GETARG_DATUM(0);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; Datum gs2 = PG_GETARG_DATUM(1); &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; POSTGIS_DEBUG(3, "entered function");</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* Must be able to build box for each argument (ie, not empty geometry). */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if ( (gserialized_datum_get_box2df_p(gs1, &amp;b1) == LW_SUCCESS) &amp;&amp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(gserialized_datum_get_box2df_p(gs2, &amp;b2) == LW_SUCCESS) )</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; double distance = box2df_distance_leaf_centroid(&amp;b1, &amp;b2);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; POSTGIS_DEBUGF(3, "got boxes %s and %s", box2df_to_string(&amp;b1), box2df_to_string(&amp;b2));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(distance);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(MAXFLOAT);</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>PostGIS 附近用户信息查询测试数据如下 :&nbsp;</div><div><div>测试环境 :&nbsp;</div><div>CentOS 5.x 64bit</div><div>PostgreSQL 9.1</div><div>PostGIS 2.0.1</div><div>MEM 8GB*12</div><div>CPU 2 * Intel(R) Xeon(R) CPU E5504 &nbsp;@ 2.00GHz</div></div><div><br></div><div>场景一, 77W数据量测试结果 :&nbsp;</div><div><div><img title="PostgreSQL 9.1 nearest-neighbor search use gist index - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL 9.1 nearest-neighbor search use gist index - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img3.ph.126.net/OAZj3d6KZ1HpIao7T3f_BQ==/2804616667962656523.jpg"  ></div>&nbsp;</div><div>场景二, 2475W数据量测试结果 :&nbsp;</div><div><div><div><img title="PostgreSQL 9.1 nearest-neighbor search use gist index - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL 9.1 nearest-neighbor search use gist index - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img6.ph.126.net/sce0qZ6SibZR-X0Jw1pyTQ==/6597462292307252406.jpg"  ></div>&nbsp;</div>测试小结 :&nbsp;</div><div><div>1. 瓶颈: CPU.</div><div>2. 数据量对性能影响较大 . 数据分布稀疏的地域, 取出数据速度明显慢过数据密集地区 .&nbsp;</div><div>3. 排序的结果与实际的距离存在一定误差, 约10%.</div><div>4. 未来读请求扩展: 1. SQL 2. CPU 3. 数据复制.</div><div>5. 未来写请求扩展: 1. SQL 2. CPU 3. 分库.</div><div>6. 更新优化, 对应用户上传的位置与数据库中存储的位置相差10米是可以考虑不更新数据库记录. 这样可以减少更新的请求数.</div><div>7. 请求优化, 将计算距离的运算放到应用端. 不在数据库中直接完成, 减少DB的运算开销. &nbsp;请求响应速度会有 12.7% 的性能提升.</div><div>8. 增加一个point类型的列, 将geometry转成point, cast(replace(substr(ST_AsText(lonlat),6),' ',',') as point) . 对于非边界用户, 使用point来下来取附近用户信息(<span style="line-height: 22px;"  >因为point取的速度要明显快于geometry</span>), 对于边界用户使用geometry来取附近用户信息. 需要应用程序在取到位置信息后进行判别, 针对边界和非边界地理信息分别采用不同的方法.</div><div>&nbsp;</div><div>详细测试数据 :&nbsp;</div><div>一、数据量773632 :&nbsp;</div><div>每次读取10条附近用户信息</div><div>1. 同时取出skyid和距离</div><div>&nbsp; &nbsp;平均响应时间1.50毫秒 每秒处理5318次请求. CPU使用率100%.</div><div>2. 取出skyid,和地理位置. 距离交给程序计算.</div><div>&nbsp; &nbsp;平均响应时间1.21毫秒, 每秒处理6568次请求. CPU使用率100%.</div><div>每次读取40条附近用户信息</div><div>1. 同时取出skyid和距离</div><div>&nbsp; &nbsp;平均响应时间2.36毫秒 每秒处理3380次请求. CPU使用率100%.</div><div>2. 取出skyid,和地理位置. 距离交给程序计算.</div><div>&nbsp; &nbsp;平均响应时间1.91毫秒, 每秒处理4167次请求. CPU使用率100%.</div><div>每次读取120条附近用户信息</div><div>1. 同时取出skyid和距离</div><div>&nbsp; &nbsp;平均响应时间3.78毫秒 每秒处理2109次请求. CPU使用率100%.</div><div>2. 取出skyid,和地理位置. 距离交给程序计算.</div><div>&nbsp; &nbsp;平均响应时间2.85毫秒, 每秒处理2795次请求. CPU使用率100%.</div><div>地理位置更新测试 :&nbsp;</div><div>平均响应时间0.23毫秒, 每秒处理33621次请求. CPU使用率90%.</div><div>&nbsp;</div><div>二、数据量24756224 :&nbsp;</div><div><div>每次读取10条附近用户信息</div><div>1. 同时取出skyid和距离</div><div>&nbsp; &nbsp;平均响应时间5.98毫秒 每秒处理1336次请求. CPU使用率100%.</div><div>2. 取出skyid,和地理位置. 距离交给程序计算.</div><div>&nbsp; &nbsp;平均响应时间5.97毫秒, 每秒处理1338次请求. CPU使用率100%.</div><div>每次读取40条附近用户信息</div><div>1. 同时取出skyid和距离</div><div>&nbsp; &nbsp;平均响应时间13.5毫秒 每秒处理593次请求. CPU使用率100%.</div><div>2. 取出skyid,和地理位置. 距离交给程序计算.</div><div>&nbsp; &nbsp;平均响应时间14.0毫秒, 每秒处理571次请求. CPU使用率100%.</div><div>每次读取120条附近用户信息</div><div>1. 同时取出skyid和距离</div><div>&nbsp; &nbsp;平均响应时间17.7毫秒 每秒处理451次请求. CPU使用率100%.</div><div>2. 取出skyid,和地理位置. 距离交给程序计算.</div><div>&nbsp; &nbsp;平均响应时间17.8毫秒, 每秒处理449次请求. CPU使用率100%.</div><div>地理位置更新测试 :&nbsp;</div><div>平均响应时间0.71毫秒, 每秒处理11100次请求. CPU使用率90%</div></div></div><div><br></div><div>还有一种优化方式, 把geometry转成point, 对point来排序. 如下 :&nbsp;</div><div><div>中国经纬度范围, 没有涉及跨正负区域, 离边界也还有一段距离, 使用point来度量距离可行 :</div><div>最北点位于黑龙江省北部漠河已被黑龙江主航道中心线处，纬度为北纬53度。</div><div>最南点位于南海南部的曾母暗沙，纬度为北纬4度。</div><div>最东点位于黑龙江与乌苏里江主航道中心线的交汇处，精度为东经135度。</div><div>最西点位于帕米尔高原上，经度为东经73度。</div><div><br></div><div>如果把几何类型转存为point类型, 在距离排序时与使用geometry类型排序得到的结果一致. 取附近用户信息的性能有大幅提升.</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >urslbs_test=&gt; alter table test1 add column col1 point;</font></div><div><font size="2"  >urslbs_test=&gt; update test1 set col1 = cast(replace(substr(ST_AsText(lonlat),6),' ',',') as point);</font></div><div><font size="2"  >urslbs_test=&gt; create index idx_test1_col1 on test1 using gist(col1);</font></div></div><div><div><font size="2"  >urslbs_test=&gt; select cast(replace(substr(ST_AsText('0101000020E61000002FC786C9AF2A5D40866BFF14D8254440'::geometry(Point,4326)),6),' ',',') as point);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;replace &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >--------------------------</font></div><div><font size="2"  >&nbsp;(116.6669792,40.2956568)</font></div><div><font size="2"  >(1 row)</font></div></div><div><div><font size="2"  >urslbs_test=&gt; select point_distance(col1,'(116.6669792,40.2956568)'::point), st_distance_sphere('0101000020E61000002FC786C9AF2A5D40866BFF14D8254440'::geometry(Point,4326), lonlat) from test1 order by col1 &lt;-&gt; '(116.6669792,40.2956568)'::point limit 10;</font></div><div><font size="2"  >&nbsp; &nbsp; point_distance &nbsp; &nbsp;| st_distance_sphere&nbsp;</font></div><div><font size="2"  >----------------------+--------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"  >&nbsp;0.000154592140808128 | &nbsp; 17.1253091983443</font></div><div><font size="2"  >&nbsp; 0.00336883988488212 | &nbsp; 297.073719657173</font></div><div><font size="2"  >&nbsp; 0.00490960806990255 | &nbsp; 468.361916333953</font></div><div><font size="2"  >&nbsp; &nbsp;0.0049619458693147 | &nbsp; 493.019043438912</font></div><div><font size="2"  >&nbsp; 0.00786551161781989 | &nbsp; 861.135253407573</font></div><div><font size="2"  >&nbsp; 0.00786595648666547 | &nbsp; 861.119017114206</font></div><div><font size="2"  >&nbsp; 0.00792924406107087 | &nbsp; 734.735620683819</font></div><div><font size="2"  >&nbsp; 0.00792924406107087 | &nbsp; 734.735620683819</font></div><div><font size="2"  >&nbsp; 0.00817754802614712 | &nbsp; 772.808877940454</font></div><div><font size="2"  >(10 rows)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >urslbs_test=&gt; select st_distance_sphere('0101000020E61000002FC786C9AF2A5D40866BFF14D8254440'::geometry(Point,4326), lonlat) from test1 order by lonlat &lt;-&gt; '0101000020E61000002FC786C9AF2A5D40866BFF14D8254440'::geometry(Point,4326) limit 10;</font></div><div><font size="2"  >&nbsp;st_distance_sphere&nbsp;</font></div><div><font size="2"  >--------------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0</font></div><div><font size="2"  >&nbsp; &nbsp;17.1253091983443</font></div><div><font size="2"  >&nbsp; &nbsp;297.073719657173</font></div><div><font size="2"  >&nbsp; &nbsp;468.361916333953</font></div><div><font size="2"  >&nbsp; &nbsp;493.019043438912</font></div><div><font size="2"  >&nbsp; &nbsp;861.135253407573</font></div><div><font size="2"  >&nbsp; &nbsp;861.119017114206</font></div><div><font size="2"  >&nbsp; &nbsp;734.735620683819</font></div><div><font size="2"  >&nbsp; &nbsp;734.735620683819</font></div><div><font size="2"  >&nbsp; &nbsp;772.808877940454</font></div><div><font size="2"  >(10 rows)</font></div></div><p></p></pre></div><div><br></div><div><div><img title="PostgreSQL 9.1 nearest-neighbor search use gist index - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL 9.1 nearest-neighbor search use gist index - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img0.ph.126.net/ibBTTwCWgQtKl8wvAZepmA==/6597433705004934320.jpg"  ></div>&nbsp;</div><div>具体测试数据如下 :&nbsp;</div><div><br></div><div>一、数据量773632 :&nbsp;</div><div><br></div><div>读测试(取出skyid,和地理位置. 距离交给程序计算.) :&nbsp;</div><div>每次读取10条附近用户信息</div><div>&nbsp; &nbsp;平均响应时间0.40毫秒, 每秒处理19573次请求. CPU使用率100%.</div><div>每次读取40条附近用户信息</div><div>&nbsp; &nbsp;平均响应时间0.66毫秒, 每秒处理12004次请求. CPU使用率100%.</div><div>每次读取120条附近用户信息</div><div>&nbsp; &nbsp;平均响应时间1.24毫秒, 每秒处理6444次请求. CPU使用率100%.</div><div><br></div><div>二、数据量24756224 :&nbsp;</div><div><br></div><div>读测试(取出skyid,和地理位置. 距离交给程序计算.) :&nbsp;</div><div>每次读取10条附近用户信息</div><div>&nbsp; &nbsp;平均响应时间3.34毫秒, 每秒处理2390次请求. CPU使用率100%.</div><div>每次读取40条附近用户信息</div><div>&nbsp; &nbsp;平均响应时间4.73毫秒, 每秒处理1689次请求. CPU使用率100%.</div><div>每次读取120条附近用户信息</div><div>&nbsp; &nbsp;平均响应时间7.38毫秒, 每秒处理1082次请求. CPU使用率100%.</div></div><div><br></div>【参考】<div><a rel="nofollow" href="http://www.postgis.org/documentation/manual-2.0/geometry_distance_centroid.html"  >http://www.postgis.org/documentation/manual-2.0/geometry_distance_centroid.html</a> </div><a rel="nofollow" href="http://en.wikipedia.org/wiki/Nearest_neighbor_search"  >http://en.wikipedia.org/wiki/Nearest_neighbor_search</a> <div><a rel="nofollow" href="http://en.wikipedia.org/wiki/KNN"  >http://en.wikipedia.org/wiki/KNN</a> </div></div>
	</div>
</div>
</body>
</html>