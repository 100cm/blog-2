<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">How many xlogs | WAL can be generated by PostgreSQL?</h2>
	<h5 id="">2012-10-14 17:16:36&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012914112949546/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">PostgreSQL和Oracle类似, 都记录了redo日志, PostgreSQL里面叫做xlog或者WAL.<wbr><div>XLOG可以用来做基于物理文件备份的还原操作. 这一点和Oracle使用RMAN进行还原时需要用到的archive log非常类似.</div><div>这里就不阐述PostgreSQL如何做物理备份和还原了, 有兴趣的朋友可以参考一下PostgreSQL Manual, 关于PITR的章节.</div><div>下面主要是要说一下PostgreSQL到底能产生多少个XLOG文件呢? 数据库还原时又是如何来定位需要的XLOG文件的呢?</div><div>首先回答第一个问题.</div><div><span style="line-height: 22px;"  >1. PostgreSQL到底能产生多少个XLOG文件呢?</span></div><div><span style="line-height: 22px;"  >在源码中是这么定义的, 如下, 理论上最多可以产生0xFFFFFFFF</span><span style="line-height: 22px;"  >FFFFFFFF</span><span style="line-height: 22px;"  >FFFFFFFF个XLOG文件. 基本上任何一个数据库都不可能达到这么多个XLOG. (</span><span style="line-height: 22px;"  >但是实际上并不是这样, 要看log和seg是怎么来的, 还有TLI什么时候会变化. 看问题2里面的描述</span><span style="line-height: 22px;"  >)</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >src/include/access/xlog_internal.h</font></div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* These macros encapsulate knowledge about the exact layout of XLog file</font></div><div><font size="2"  >&nbsp;* names, timeline history file names, and archive-status file names.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >#define MAXFNAMELEN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 64</font></div><div><font size="2"  >#define XLogFileName(fname, tli, log, seg) &nbsp; &nbsp; &nbsp;\</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; snprintf(fname, MAXFNAMELEN, "%08X%08X%08X", tli, log, seg)</font></div><p></p></pre></div><div><br></div><div>接下来要说说第二个问题,</div><div>2.&nbsp;<span style="line-height: 22px;"  >数据库还原时又是如何来定位需要的XLOG文件的呢?</span></div><div>把XLOG想象为内存的话, 那么要查找内存中的数据需要寻址. 而寻址是有上限的, 比如64位的机器, 寻址的上限是2 ^ 64. 字节.</div><div>同样, XLOG的寻址也有上限, 它是这么定义的.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >src/include/access/xlogdefs.h</font></div><div><font size="2"  >00017 /*</font></div><div><font size="2"  >00018 &nbsp;* Pointer to a location in the XLOG. &nbsp;These pointers are 64 bits wide,</font></div><div><font size="2"  >00019 &nbsp;* because we don't want them ever to overflow.</font></div><div><font size="2"  >00020 &nbsp;*/</font></div><div><font size="2"  >00021 typedef uint64 XLogRecPtr;</font></div><p></p></pre></div><div>uint64是无符号64位整型. 定义如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >src/include/c.h</font></div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* 64-bit integers</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >#ifdef HAVE_LONG_INT_64</font></div><div><font size="2"  >/* Plain "long int" fits, use it */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >#ifndef HAVE_INT64</font></div><div><font size="2"  >typedef long int int64;</font></div><div><font size="2"  >#endif</font></div><div><font size="2"  >#ifndef HAVE_UINT64</font></div><div><font size="2"  >typedef unsigned long int uint64;</font></div><div><font size="2"  >#endif</font></div><div><font size="2"  >#elif defined(HAVE_LONG_LONG_INT_64)</font></div><div><font size="2"  >/* We have working support for "long long int", use that */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >#ifndef HAVE_INT64</font></div><div><font size="2"  >typedef long long int int64;</font></div><div><font size="2"  >#endif</font></div><div><font size="2"  >#ifndef HAVE_UINT64</font></div><div><font size="2"  >typedef unsigned long long int uint64;</font></div><div><font size="2"  >#endif</font></div><div><font size="2"  >#else</font></div><div><font size="2"  >/* neither HAVE_LONG_INT_64 nor HAVE_LONG_LONG_INT_64 */</font></div><div><font size="2"  >#error must have a working 64-bit integer datatype</font></div><div><font size="2"  >#endif</font></div><p></p></pre></div><div>也就是说, xlog的寻址上限是 2^64 和 64位机器的内存寻址空间一样. &nbsp;那么可以计算出最多能产生多少个XLOG文件.</div><div>默认的XLOG是16MB一个, 如下是编译的时候的默认值.</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >&nbsp; --with-wal-segsize=SEGSIZE</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set WAL segment size in MB [16]</font></div></div><div><font size="2"  >(2^64) /16/1024/1024 =&nbsp;1099511627776 (0x10000000000) 个XLOG文件.&nbsp;</font></div><p></p></pre></div><div>这个数字显然和XLOG文件名能够容纳的xlog文件个数有较大差别, 文件名中包含了TLI, LOG, SEG三部分信息. 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >src/include/access/xlog_internal.h</font></div><div><div style="line-height: 22px;"  ><font size="2"  >00108 /*</font></div><div style="line-height: 22px;"  ><font size="2"  >00109 &nbsp;* The XLOG is split into WAL segments (physical files) of the size indicated</font></div><div style="line-height: 22px;"  ><font size="2"  >00110 &nbsp;* by XLOG_SEG_SIZE.</font></div><div style="line-height: 22px;"  ><font size="2"  >00111 &nbsp;*/</font></div><div style="line-height: 22px;"  ><font size="2"  >00112 #define XLogSegSize &nbsp; &nbsp; ((uint32) XLOG_SEG_SIZE)</font></div><div style="line-height: 22px;"  ><font size="2"  >00113 #define XLogSegmentsPerXLogId &nbsp; (UINT64CONST(0x100000000) / XLOG_SEG_SIZE)</font></div></div><div style="line-height: 22px;"  ><font size="2"  >...</font></div><div><div><font size="2"  >#define XLogFileName<span> </span>(<span> </span> <span> </span>fname,</font></div><div><font size="2"  >&nbsp;<span> </span>tli,</font></div><div><font size="2"  >&nbsp;<span> </span>logSegNo<span> </span>&nbsp;</font></div><div><font size="2"  >)<span>   </span></font></div><div><font size="2"  >Value:</font></div><div><font size="2"  >snprintf(fname, MAXFNAMELEN, "%08X%08X%08X", tli, &nbsp; &nbsp; &nbsp; \</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(uint32) ((logSegNo) / XLogSegmentsPerXLogId), \</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(uint32) ((logSegNo) % XLogSegmentsPerXLogId))</font></div></div><p></p></pre></div><div><pre class="prettyprint"  ><div><font size="2"  >src/include/c.h</font></div><div><font size="2"  >#define UINT64CONST(x) ((uint64) x)</font></div><p></p></pre></div><div><pre class="prettyprint"  ><div><font size="2"  >src/include/access/xlogdefs.h</font></div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* TimeLineID (TLI) - identifies different database histories to prevent</font></div><div><font size="2"  >&nbsp;* confusion after restoring a prior state of a database installation.</font></div><div><font size="2"  >&nbsp;* TLI does not change in a normal stop/restart of the database (including</font></div><div><font size="2"  >&nbsp;* crash-and-recover cases); but we must assign a new TLI after doing</font></div><div><font size="2"  >&nbsp;* a recovery to a prior state, a/k/a point-in-time recovery. &nbsp;This makes</font></div><div><font size="2"  >&nbsp;* the new WAL logfile sequence we generate distinguishable from the</font></div><div><font size="2"  >&nbsp;* sequence that was generated in the previous incarnation.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >typedef uint32 TimeLineID;</font></div><p></p></pre></div><div>如果取<span style="line-height: 22px;"  >XLOG_SEG_SIZE=16MB, 那么</span></div><div><pre class="prettyprint"  ><p><font size="2"  ><span style="line-height: 22px;"  >XLogSegmentsPerXLogId =&nbsp;</span><span style="line-height: 22px;"  >UINT64CONST(0x100000000) / 16MB = 256</span></font></p></pre></div><div>因此可以得出xlog文件名中的最后两个部分LOG和SEG的最大值分别可以 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><span style="line-height: 22px;"  ><font size="2"  >LOG = (uint32) ((logSegNo) / XLogSegmentsPerXLogId) = 2^32</font></span></div><div><span style="line-height: 22px;"  ><font size="2"  >SEG = (uint32) ((logSegNo) % XLogSegmentsPerXLogId)) = 255</font></span></div><p></p></pre></div><div>也就是说在同一个时间线(TLI)里面, 当<span style="line-height: 22px;"  >XLOG_SEG_SIZE=16MB时.&nbsp;</span>最多可以产生 2^32 * 256 个 XLOG 文件.&nbsp;</div><div>这样的话, 如果我们的数据库平均1天产生10TB的XLOG数据量, 那么需要</div><div><pre class="prettyprint"  ><p><font size="2"  >&nbsp;((<span style="line-height: 22px;"  >2^32 * 256) *16 * 1024 * 1024) / (10*1024*1024*1024*1024) = 1677721天 = 4712年.&nbsp;</span></font></p></pre></div><div><span style="line-height: 22px;"  >才能达到XLOG的限制. 这在目前来看也是足够用的.</span></div><div>跟进这个规则，可以推算出当前数据库已经经历了多少个xlog文件. 例如 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal@db-192-168-xxx-xxx-&gt; cd $PGDATA/pg_xlog</font></div><div><font size="2"  ><span style="line-height: 22px;"  >digoal</span>@db-192-168-xxx-xxx-&gt; ll | tail -n 5</font></div><div><font size="2"  >-rw------- 1&nbsp;<span style="line-height: 22px;"  >digoal digoal&nbsp;</span>64M Oct 14 13:43 000000020000180F0000000A</font></div><div><font size="2"  >-rw------- 1&nbsp;<span style="line-height: 22px;"  >digoal digoal&nbsp;</span>64M Oct 14 13:36 000000020000180F0000000B</font></div><div><font size="2"  >-rw------- 1&nbsp;<span style="line-height: 22px;"  >digoal digoal&nbsp;</span>64M Oct 14 13:30 000000020000180F0000000C</font></div><div><font size="2"  >-rw------- 1&nbsp;<span style="line-height: 22px;"  >digoal digoal&nbsp;</span>56 Jun 17 &nbsp;2011 00000002.history</font></div><div><font size="2"  >drwx------ 2&nbsp;<span style="line-height: 22px;"  >digoal digoal&nbsp;</span>2.0K Oct 15 09:08 archive_status</font></div><p></p></pre></div><div>这里的xlog文件时64MB的, 所以 :&nbsp;</div><div>XLogSegmentsPerXLogId = UINT64CONST(0x100000000) / 64MB = 64 . &nbsp;</div><div>所以SEG最大值是63转换成16进制就是3F. 从xlog文件的SEG段就能看出规律 .&nbsp;</div><div>注意以上代码取自PostgreSQL 9.3 devel. 低于9.3的版本, SEG最大值还要减1 .&nbsp;</div><div>从xlog的文件名<span style="line-height: 22px;"  >000000020000180F0000000C读到3个信息,&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  ><span style="line-height: 22px;"  >时间线:&nbsp;</span><span style="line-height: 22px;"  >00000002</span></font></div><div><font size="2"  ><span style="line-height: 22px;"  >LOG:&nbsp;</span><span style="line-height: 22px;"  >0000180F</span></font></div><div><font size="2"  ><span style="line-height: 22px;"  >SEG:&nbsp;</span><span style="line-height: 22px;"  >0000000C</span></font></div><p></p></pre></div><div>共经历(0x180F * 64) + 0xc = 394176&nbsp;+ 12 = &nbsp;394188 个xlog文件.&nbsp;</div><div>折合&nbsp;<span style="line-height: 22px;"  >394188 * 64MB = 24TB .&nbsp;</span></div><div><span style="line-height: 22px;"  >低于9.3 devel的版本, XLogFileName代码如下 :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* These macros encapsulate knowledge about the exact layout of XLog file</font></div><div><font size="2"  >&nbsp;* names, timeline history file names, and archive-status file names.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >#define MAXFNAMELEN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 64</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >#define XLogFileName(fname, tli, log, seg) &nbsp; &nbsp; &nbsp;\</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; snprintf(fname, MAXFNAMELEN, "%08X%08X%08X", tli, log, seg)</font></div><p></p></pre></div><div><br></div><div>下面通过几个例子来验证一下前面的限制情况.</div><div>1. 控制文件, 在控制文件中记录了XLogRecPtr的信息, 分别是</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >Latest checkpoint location</font></div><div><font size="2"  >Prior checkpoint location</font></div><div><font size="2"  >Latest checkpoint's REDO location</font></div><div><font size="2"  >Minimum recovery ending location</font></div><div><font size="2"  >Backup start location</font></div><p></p></pre></div><div>以上5个location都是<span style="line-height: 22px;"  >XLogRecPtr类型的数据. 源码如下 :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >src/include/catalog/pg_control.h</font></div><div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Body of CheckPoint XLOG records. &nbsp;This is declared here because we keep</font></div><div><font size="2"  >&nbsp;* a copy of the latest one in pg_control for possible disaster recovery.</font></div><div><font size="2"  >&nbsp;* Changing this struct requires a PG_CONTROL_VERSION bump.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >typedef struct CheckPoint</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;redo; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* next RecPtr available when we began to</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* create CheckPoint (i.e. REDO start point) */</font></div><div><font size="2"  >.....</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Contents of pg_control.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* NOTE: try to keep this under 512 bytes so that it will fit on one physical</font></div><div><font size="2"  >&nbsp;* sector of typical disk drives. &nbsp;This reduces the odds of corruption due to</font></div><div><font size="2"  >&nbsp;* power failure midway through a write.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >typedef struct ControlFileData</font></div><div><font size="2"  >{</font></div><div><font size="2"  >.....</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;checkPoint; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* last check point record ptr */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;prevCheckPoint; /* previous check point record ptr */</font></div><div><font size="2"  >.....</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* These two values determine the minimum point we must recover up to</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* before starting up:</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* minRecoveryPoint is updated to the latest replayed LSN whenever we</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* flush a data change during archive recovery. That guards against</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* starting archive recovery, aborting it, and restarting with an earlier</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* stop location. If we've already flushed data changes from WAL record X</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to disk, we mustn't start up until we reach X again. Zero when not</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* doing archive recovery.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* backupStartPoint is the redo pointer of the backup start checkpoint, if</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we are recovering from an online backup and haven't reached the end of</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* backup yet. It is reset to zero when the end of backup is reached, and</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we mustn't start up before that. A boolean would suffice otherwise, but</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we use the redo pointer as a cross-check when we see an end-of-backup</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* record, to make sure the end-of-backup record corresponds the base</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* backup we're recovering from.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* backupEndPoint is the backup end location, if we are recovering from an</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* online backup which was taken from the standby and haven't reached the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* end of backup yet. It is initialized to the minimum recovery point in</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* pg_control which was backed up last. It is reset to zero when the end</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* of backup is reached, and we mustn't start up before that.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If backupEndRequired is true, we know for sure that we're restoring</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* from a backup, and must see a backup-end record before we can safely</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* start up. If it's false, but backupStartPoint is set, a backup_label</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* file was found at startup but it may have been a leftover from a stray</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* pg_start_backup() call, not accompanied by pg_stop_backup().</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;minRecoveryPoint;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;backupStartPoint;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;backupEndPoint;</font></div></div><p></p></pre></div><div><br></div><div>下面使用pg_resetxlog修改控制文件中TLI,LOG,SEG的值, 使它到达XLOG的上限, 再次切换日志, 看看会发生什么?</div><div>首先查看当前数据库的WAL segments的SIZE :&nbsp;</div><div>pg_controldata</div><div><pre class="prettyprint"  ><p><font size="2"  >Bytes per WAL segment: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16777216</font></p></pre></div><div>所以SEG最大可以到255. 接下来就使用pg_resetxlog来修改控制文件,</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal@db-172-16-3-33-&gt; pg_resetxlog -f -l 4294967295,4294967295,254 $PGDATA</font></div><div><font size="2"  >Transaction log reset</font></div><p></p></pre></div><div>启动数据库</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal@db-172-16-3-33-&gt; pg_ctl start</font></div><div><font size="2"  >server starting</font></div><div><font size="2"  >digoal@db-172-16-3-33-&gt; LOG: &nbsp;could not create IPv6 socket: Address family not supported by protocol</font></div><div><font size="2"  >LOG: &nbsp;database system was shut down at 2012-10-14 16:13:21 CST</font></div><div><font size="2"  >LOG: &nbsp;autovacuum launcher started</font></div><div><font size="2"  >LOG: &nbsp;database system is ready to accept connections</font></div><p></p></pre></div><div>执行CHECKPOINT</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal@db-172-16-3-33-&gt; psql postgres postgres</font></div><div><font size="2"  >psql (9.1.3)</font></div><div><font size="2"  >Type "help" for help.</font></div><div><font size="2"  >postgres=# checkpoint;</font></div><div><font size="2"  >CHECKPOINT</font></div><div><font size="2"  >postgres=# \q</font></div><p></p></pre></div><div>查看控制文件,&nbsp;<span style="line-height: 22px;"  >Latest checkpoint's TimeLineID达到最大</span><span style="line-height: 22px;"  >4294967295</span><span style="line-height: 22px;"  >. LOG也达到了最大0xFFFFFFFE, SEG=254(离最大只差1).</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal@db-172-16-3-33-&gt; pg_controldata&nbsp;</font></div><div><font size="2"  >pg_control version number: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;903</font></div><div><font size="2"  >Catalog version number: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 201105231</font></div><div><font size="2"  >Database system identifier: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5758179757924416507</font></div><div><font size="2"  >Database cluster state: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in production</font></div><div><font size="2"  >pg_control last modified: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sun 14 Oct 2012 04:13:44 PM CST</font></div><div><font size="2"  >Latest checkpoint location: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FFFFFFFF/FE000078</font></div><div><font size="2"  >Prior checkpoint location: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFFFFFFF/FE000020</font></div><div><font size="2"  >Latest checkpoint's REDO location: &nbsp; &nbsp;FFFFFFFF/FE000078</font></div><div><font size="2"  >Latest checkpoint's TimeLineID: &nbsp; &nbsp; &nbsp; 4294967295</font></div><div><font size="2"  >Latest checkpoint's NextXID: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0/1857</font></div><div><font size="2"  >Latest checkpoint's NextOID: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;33060</font></div><div><font size="2"  >Latest checkpoint's NextMultiXactId: &nbsp;1</font></div><div><font size="2"  >Latest checkpoint's NextMultiOffset: &nbsp;0</font></div><div><font size="2"  >Latest checkpoint's oldestXID: &nbsp; &nbsp; &nbsp; &nbsp;1670</font></div><div><font size="2"  >Latest checkpoint's oldestXID's DB: &nbsp; 1</font></div><div><font size="2"  >Latest checkpoint's oldestActiveXID: &nbsp;0</font></div><div><font size="2"  >Time of latest checkpoint: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sun 14 Oct 2012 04:13:44 PM CST</font></div><div><font size="2"  >Minimum recovery ending location: &nbsp; &nbsp; 0/0</font></div><div><font size="2"  >Backup start location: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0/0</font></div><div><font size="2"  >Current wal_level setting: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;minimal</font></div><div><font size="2"  >Current max_connections setting: &nbsp; &nbsp; &nbsp;100</font></div><div><font size="2"  >Current max_prepared_xacts setting: &nbsp; 0</font></div><div><font size="2"  >Current max_locks_per_xact setting: &nbsp; 64</font></div><div><font size="2"  >Maximum data alignment: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8</font></div><div><font size="2"  >Database block size: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8192</font></div><div><font size="2"  >Blocks per segment of large relation: 131072</font></div><div><font size="2"  >WAL block size: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 16384</font></div><div><font size="2"  >Bytes per WAL segment: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16777216</font></div><div><font size="2"  >Maximum length of identifiers: &nbsp; &nbsp; &nbsp; &nbsp;64</font></div><div><font size="2"  >Maximum columns in an index: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;32</font></div><div><font size="2"  >Maximum size of a TOAST chunk: &nbsp; &nbsp; &nbsp; &nbsp;1996</font></div><div><font size="2"  >Date/time type storage: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 64-bit integers</font></div><div><font size="2"  >Float4 argument passing: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;by value</font></div><div><font size="2"  >Float8 argument passing: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;by value</font></div><p></p></pre></div></div><div>进入数据库, 执行切换日志的操作 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal@db-172-16-3-33-&gt; psql postgres postgres</font></div><div><font size="2"  >psql (9.1.3)</font></div><div><font size="2"  >Type "help" for help.</font></div><p></p></pre></div><div>-- 第一次切换日志成功</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >postgres=# select pg_switch_xlog();</font></div><div><font size="2"  >&nbsp; pg_switch_xlog &nbsp;&nbsp;</font></div><div><font size="2"  >-------------------</font></div><div><font size="2"  >&nbsp;FFFFFFFF/FE0000F0</font></div><div><font size="2"  >(1 row)</font></div></div><div><font size="2"  >postgres=# \set VERBOSITY verbose</font></div><div><div><font size="2"  >postgres=# checkpoint;</font></div><div><font size="2"  >CHECKPOINT</font></div></div><p></p></pre></div><div><div>-- 第二次切换失败, 因为已经到达上限.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# select pg_switch_xlog();</font></div><div><font size="2"  >ERROR: &nbsp;xlog flush request FFFFFFFF/FF000148 is not satisfied --- flushed only to FFFFFFFF/20</font></div><div><font size="2"  >STATEMENT: &nbsp;select pg_switch_xlog();</font></div><div><font size="2"  >PANIC: &nbsp;xlog write request FFFFFFFF/4000 is past end of log 0/0</font></div><div><font size="2"  >WARNING: &nbsp;AbortTransaction while in COMMIT state</font></div><div><font size="2"  >WARNING: &nbsp;01000: AbortTransaction while in COMMIT state</font></div><div><font size="2"  >LOCATION: &nbsp;AbortTransaction, xact.c:2236</font></div><div><font size="2"  >ERROR: &nbsp;XX000: xlog flush request FFFFFFFF/FF000148 is not satisfied --- flushed only to FFFFFFFF/20</font></div><div><font size="2"  >LOCATION: &nbsp;XLogFlush, xlog.c:2145</font></div><div><font size="2"  >postgres=# LOG: &nbsp;WAL writer process (PID 14966) was terminated by signal 6: Aborted</font></div><div><font size="2"  >LOG: &nbsp;terminating any other active server processes</font></div><div><font size="2"  >WARNING: &nbsp;terminating connection because of crash of another server process</font></div><div><font size="2"  >DETAIL: &nbsp;The postmaster has commanded this server process to roll back the current transaction and exit, because another server process exited abnormally and possibly corrupted shared memory.</font></div><div><font size="2"  >HINT: &nbsp;In a moment you should be able to reconnect to the database and repeat your command.</font></div><div><font size="2"  >WARNING: &nbsp;terminating connection because of crash of another server process</font></div><div><font size="2"  >DETAIL: &nbsp;The postmaster has commanded this server process to roll back the current transaction and exit, because another server process exited abnormally and possibly corrupted shared memory.</font></div><div><font size="2"  >HINT: &nbsp;In a moment you should be able to reconnect to the database and repeat your command.</font></div><div><font size="2"  >LOG: &nbsp;all server processes terminated; reinitializing</font></div><div><font size="2"  >LOG: &nbsp;database system was interrupted; last known up at 2012-10-14 16:20:24 CST</font></div><div><font size="2"  >LOG: &nbsp;database system was not properly shut down; automatic recovery in progress</font></div><div><font size="2"  >LOG: &nbsp;could not open file "pg_xlog/FFFFFFFF0000000000000000" (log file 0, segment 0): No such file or directory</font></div><div><font size="2"  >LOG: &nbsp;redo is not required</font></div><div><font size="2"  >LOG: &nbsp;autovacuum launcher started</font></div><div><font size="2"  >LOG: &nbsp;database system is ready to accept connections</font></div><p></p></pre></div></div><div>这些错误和TLI的值都没有关系, 时间线是在恢复结束后打开数据库时才会用到的, 自增长的一个值. 用来区分数据库是否是从备份中恢复过来的.</div><div>XLOG文件</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal@db-172-16-3-33-&gt; pwd</font></div><div><font size="2"  >/home/digoal/pg_root/pg_xlog</font></div><div><font size="2"  >digoal@db-172-16-3-33-&gt; ll</font></div><div><font size="2"  >total 33M</font></div><div><font size="2"  >drwx------ 2 digoal digoal 4.0K Jun 26 11:18 archive_status</font></div><div><font size="2"  >-rw------- 1 digoal digoal &nbsp;16M Oct 14 16:20 FFFFFFFF0000000000000000</font></div><div><font size="2"  >-rw------- 1 digoal digoal &nbsp;16M Oct 14 16:20 FFFFFFFFFFFFFFFF000000FF</font></div><p></p></pre></div><div>显然, 文件名被rotate了(&nbsp;<span style="line-height: 22px;"  >FFFFFFFF | 000000FF -&gt;&nbsp;</span><span style="line-height: 22px;"  >00000000 | 00000000&nbsp;</span>).</div><div><br></div><div>2. 系统函数</div><div>在PostgreSQL中有一些系统函数</div><div>可以用来查看当前插入或者写入的XLogRecPtr,&nbsp;</div><div>STANDBY库上查看接收到的XLOG的XLogRecPtr或者是</div><div>已经APPLY的XLOG的XLogRecPtr.&nbsp;</div><div>又或者是比较两个XLogRecPtr之间的数据量.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg_current_xlog_insert_location()</font></div><div><font size="2"  >pg_current_xlog_location()</font></div><div><font size="2"  >pg_start_backup(label text [, fast boolean ])</font></div><div><font size="2"  >pg_stop_backup()</font></div><div><font size="2"  >pg_xlogfile_name(location text)</font></div><div><font size="2"  >pg_xlog_location_diff(location text, location text)</font></div><p></p></pre></div><div>源码如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >src/backend/access/transam/xlogfuncs.c</font></div><div><div><font size="2"  >pg_current_xlog_insert_location()</font></div><div><font size="2"  >00192 /*</font></div><div><font size="2"  >00193 &nbsp;* Report the current WAL insert location (same format as pg_start_backup etc)</font></div><div><font size="2"  >00194 &nbsp;*</font></div><div><font size="2"  >00195 &nbsp;* This function is mostly for debugging purposes.</font></div><div><font size="2"  >00196 &nbsp;*/</font></div><div><font size="2"  >00197 Datum</font></div><div><font size="2"  >00198 pg_current_xlog_insert_location(PG_FUNCTION_ARGS)</font></div><div><font size="2"  >00199 {</font></div><div><font size="2"  >00200 &nbsp; &nbsp; XLogRecPtr &nbsp;current_recptr;</font></div><div><font size="2"  >00201 &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;location[MAXFNAMELEN];</font></div><div><font size="2"  >00202&nbsp;</font></div><div><font size="2"  >00203 &nbsp; &nbsp; if (RecoveryInProgress())</font></div><div><font size="2"  >00204 &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >00205 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),</font></div><div><font size="2"  >00206 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("recovery is in progress"),</font></div><div><font size="2"  >00207 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("WAL control functions cannot be executed during recovery.")));</font></div><div><font size="2"  >00208&nbsp;</font></div><div><font size="2"  >00209 &nbsp; &nbsp; current_recptr = GetXLogInsertRecPtr();</font></div><div><font size="2"  >00210&nbsp;</font></div><div><font size="2"  >00211 &nbsp; &nbsp; snprintf(location, sizeof(location), "%X/%X",</font></div><div><font size="2"  >00212 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(uint32) (current_recptr &gt;&gt; 32), (uint32) current_recptr);</font></div><div><font size="2"  >00213 &nbsp; &nbsp; PG_RETURN_TEXT_P(cstring_to_text(location));</font></div><div><font size="2"  >00214 }</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >pg_current_xlog_location()</font></div><div><font size="2"  >/*</font></div><div><font size="2"  >00167 &nbsp;* Report the current WAL write location (same format as pg_start_backup etc)</font></div><div><font size="2"  >00168 &nbsp;*</font></div><div><font size="2"  >00169 &nbsp;* This is useful for determining how much of WAL is visible to an external</font></div><div><font size="2"  >00170 &nbsp;* archiving process. &nbsp;Note that the data before this point is written out</font></div><div><font size="2"  >00171 &nbsp;* to the kernel, but is not necessarily synced to disk.</font></div><div><font size="2"  >00172 &nbsp;*/</font></div><div><font size="2"  >00173 Datum</font></div><div><font size="2"  >00174 pg_current_xlog_location(PG_FUNCTION_ARGS)</font></div><div><font size="2"  >00175 {</font></div><div><font size="2"  >00176 &nbsp; &nbsp; XLogRecPtr &nbsp;current_recptr;</font></div><div><font size="2"  >00177 &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;location[MAXFNAMELEN];</font></div><div><font size="2"  >00178&nbsp;</font></div><div><font size="2"  >00179 &nbsp; &nbsp; if (RecoveryInProgress())</font></div><div><font size="2"  >00180 &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >00181 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),</font></div><div><font size="2"  >00182 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("recovery is in progress"),</font></div><div><font size="2"  >00183 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("WAL control functions cannot be executed during recovery.")));</font></div><div><font size="2"  >00184&nbsp;</font></div><div><font size="2"  >00185 &nbsp; &nbsp; current_recptr = GetXLogWriteRecPtr();</font></div><div><font size="2"  >00186&nbsp;</font></div><div><font size="2"  >00187 &nbsp; &nbsp; snprintf(location, sizeof(location), "%X/%X",</font></div><div><font size="2"  >00188 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(uint32) (current_recptr &gt;&gt; 32), (uint32) current_recptr);</font></div><div><font size="2"  >00189 &nbsp; &nbsp; PG_RETURN_TEXT_P(cstring_to_text(location));</font></div><div><font size="2"  >00190 }</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >pg_start_backup(label text [, fast boolean ])</font></div><div><font size="2"  >00038 /*</font></div><div><font size="2"  >00039 &nbsp;* pg_start_backup: set up for taking an on-line backup dump</font></div><div><font size="2"  >00040 &nbsp;*</font></div><div><font size="2"  >00041 &nbsp;* Essentially what this does is to create a backup label file in $PGDATA,</font></div><div><font size="2"  >00042 &nbsp;* where it will be archived as part of the backup dump. &nbsp;The label file</font></div><div><font size="2"  >00043 &nbsp;* contains the user-supplied label string (typically this would be used</font></div><div><font size="2"  >00044 &nbsp;* to tell where the backup dump will be stored) and the starting time and</font></div><div><font size="2"  >00045 &nbsp;* starting WAL location for the dump.</font></div><div><font size="2"  >00046 &nbsp;*/</font></div><div><font size="2"  >00047 Datum</font></div><div><font size="2"  >00048 pg_start_backup(PG_FUNCTION_ARGS)</font></div><div><font size="2"  >00049 {</font></div><div><font size="2"  >00050 &nbsp; &nbsp; text &nbsp; &nbsp; &nbsp; *backupid = PG_GETARG_TEXT_P(0);</font></div><div><font size="2"  >00051 &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;fast = PG_GETARG_BOOL(1);</font></div><div><font size="2"  >00052 &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *backupidstr;</font></div><div><font size="2"  >00053 &nbsp; &nbsp; XLogRecPtr &nbsp;startpoint;</font></div><div><font size="2"  >00054 &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;startxlogstr[MAXFNAMELEN];</font></div><div><font size="2"  >00055&nbsp;</font></div><div><font size="2"  >00056 &nbsp; &nbsp; backupidstr = text_to_cstring(backupid);</font></div><div><font size="2"  >00057&nbsp;</font></div><div><font size="2"  >00058 &nbsp; &nbsp; startpoint = do_pg_start_backup(backupidstr, fast, NULL);</font></div><div><font size="2"  >00059&nbsp;</font></div><div><font size="2"  >00060 &nbsp; &nbsp; snprintf(startxlogstr, sizeof(startxlogstr), "%X/%X",</font></div><div><font size="2"  >00061 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(uint32) (startpoint &gt;&gt; 32), (uint32) startpoint);</font></div><div><font size="2"  >00062 &nbsp; &nbsp; PG_RETURN_TEXT_P(cstring_to_text(startxlogstr));</font></div><div><font size="2"  >00063 }</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >pg_stop_backup()</font></div><div><font size="2"  >00065 /*</font></div><div><font size="2"  >00066 &nbsp;* pg_stop_backup: finish taking an on-line backup dump</font></div><div><font size="2"  >00067 &nbsp;*</font></div><div><font size="2"  >00068 &nbsp;* We write an end-of-backup WAL record, and remove the backup label file</font></div><div><font size="2"  >00069 &nbsp;* created by pg_start_backup, creating a backup history file in pg_xlog</font></div><div><font size="2"  >00070 &nbsp;* instead (whence it will immediately be archived). The backup history file</font></div><div><font size="2"  >00071 &nbsp;* contains the same info found in the label file, plus the backup-end time</font></div><div><font size="2"  >00072 &nbsp;* and WAL location. Before 9.0, the backup-end time was read from the backup</font></div><div><font size="2"  >00073 &nbsp;* history file at the beginning of archive recovery, but we now use the WAL</font></div><div><font size="2"  >00074 &nbsp;* record for that and the file is for informational and debug purposes only.</font></div><div><font size="2"  >00075 &nbsp;*</font></div><div><font size="2"  >00076 &nbsp;* Note: different from CancelBackup which just cancels online backup mode.</font></div><div><font size="2"  >00077 &nbsp;*/</font></div><div><font size="2"  >00078 Datum</font></div><div><font size="2"  >00079 pg_stop_backup(PG_FUNCTION_ARGS)</font></div><div><font size="2"  >00080 {</font></div><div><font size="2"  >00081 &nbsp; &nbsp; XLogRecPtr &nbsp;stoppoint;</font></div><div><font size="2"  >00082 &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;stopxlogstr[MAXFNAMELEN];</font></div><div><font size="2"  >00083&nbsp;</font></div><div><font size="2"  >00084 &nbsp; &nbsp; stoppoint = do_pg_stop_backup(NULL, true);</font></div><div><font size="2"  >00085&nbsp;</font></div><div><font size="2"  >00086 &nbsp; &nbsp; snprintf(stopxlogstr, sizeof(stopxlogstr), "%X/%X",</font></div><div><font size="2"  >00087 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(uint32) (stoppoint &gt;&gt; 32), (uint32) stoppoint);</font></div><div><font size="2"  >00088 &nbsp; &nbsp; PG_RETURN_TEXT_P(cstring_to_text(stopxlogstr));</font></div><div><font size="2"  >00089 }</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >pg_xlogfile_name(location text)</font></div><div><font size="2"  >/*</font></div><div><font size="2"  >00345 &nbsp;* Compute an xlog file name given a WAL location,</font></div><div><font size="2"  >00346 &nbsp;* such as is returned by pg_stop_backup() or pg_xlog_switch().</font></div><div><font size="2"  >00347 &nbsp;*/</font></div><div><font size="2"  >00348 Datum</font></div><div><font size="2"  >00349 pg_xlogfile_name(PG_FUNCTION_ARGS)</font></div><div><font size="2"  >00350 {</font></div><div><font size="2"  >00351 &nbsp; &nbsp; text &nbsp; &nbsp; &nbsp; *location = PG_GETARG_TEXT_P(0);</font></div><div><font size="2"  >00352 &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *locationstr;</font></div><div><font size="2"  >00353 &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp;hi,</font></div><div><font size="2"  >00354 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lo;</font></div><div><font size="2"  >00355 &nbsp; &nbsp; XLogSegNo &nbsp; xlogsegno;</font></div><div><font size="2"  >00356 &nbsp; &nbsp; XLogRecPtr &nbsp;locationpoint;</font></div><div><font size="2"  >00357 &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;xlogfilename[MAXFNAMELEN];</font></div><div><font size="2"  >00358&nbsp;</font></div><div><font size="2"  >00359 &nbsp; &nbsp; if (RecoveryInProgress())</font></div><div><font size="2"  >00360 &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >00361 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),</font></div><div><font size="2"  >00362 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("recovery is in progress"),</font></div><div><font size="2"  >00363 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("pg_xlogfile_name() cannot be executed during recovery.")));</font></div><div><font size="2"  >00364&nbsp;</font></div><div><font size="2"  >00365 &nbsp; &nbsp; locationstr = text_to_cstring(location);</font></div><div><font size="2"  >00366&nbsp;</font></div><div><font size="2"  >00367 &nbsp; &nbsp; validate_xlog_location(locationstr);</font></div><div><font size="2"  >00368&nbsp;</font></div><div><font size="2"  >00369 &nbsp; &nbsp; if (sscanf(locationstr, "%X/%X", &amp;hi, &amp;lo) != 2)</font></div><div><font size="2"  >00370 &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >00371 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_INVALID_PARAMETER_VALUE),</font></div><div><font size="2"  >00372 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not parse transaction log location \"%s\"",</font></div><div><font size="2"  >00373 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locationstr)));</font></div><div><font size="2"  >00374 &nbsp; &nbsp; locationpoint = ((uint64) hi) &lt;&lt; 32 | lo;</font></div><div><font size="2"  >00375&nbsp;</font></div><div><font size="2"  >00376 &nbsp; &nbsp; XLByteToPrevSeg(locationpoint, xlogsegno);</font></div><div><font size="2"  >00377 &nbsp; &nbsp; XLogFileName(xlogfilename, ThisTimeLineID, xlogsegno);</font></div><div><font size="2"  >00378&nbsp;</font></div><div><font size="2"  >00379 &nbsp; &nbsp; PG_RETURN_TEXT_P(cstring_to_text(xlogfilename));</font></div><div><font size="2"  >00380 }</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >pg_xlog_location_diff(location text, location text)</font></div><div><font size="2"  >00499 /*</font></div><div><font size="2"  >00500 &nbsp;* Compute the difference in bytes between two WAL locations.</font></div><div><font size="2"  >00501 &nbsp;*/</font></div><div><font size="2"  >00502 Datum</font></div><div><font size="2"  >00503 pg_xlog_location_diff(PG_FUNCTION_ARGS)</font></div><div><font size="2"  >00504 {</font></div><div><font size="2"  >00505 &nbsp; &nbsp; text &nbsp; &nbsp; &nbsp; *location1 = PG_GETARG_TEXT_P(0);</font></div><div><font size="2"  >00506 &nbsp; &nbsp; text &nbsp; &nbsp; &nbsp; *location2 = PG_GETARG_TEXT_P(1);</font></div><div><font size="2"  >00507 &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *str1,</font></div><div><font size="2"  >00508 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*str2;</font></div><div><font size="2"  >00509 &nbsp; &nbsp; XLogRecPtr &nbsp;loc1,</font></div><div><font size="2"  >00510 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc2;</font></div><div><font size="2"  >00511 &nbsp; &nbsp; Numeric &nbsp; &nbsp; result;</font></div><div><font size="2"  >00512 &nbsp; &nbsp; uint64 &nbsp; &nbsp; &nbsp;bytes1,</font></div><div><font size="2"  >00513 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes2;</font></div><div><font size="2"  >00514 &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp;hi,</font></div><div><font size="2"  >00515 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lo;</font></div><div><font size="2"  >00516&nbsp;</font></div><div><font size="2"  >00517 &nbsp; &nbsp; /*</font></div><div><font size="2"  >00518 &nbsp; &nbsp; &nbsp;* Read and parse input</font></div><div><font size="2"  >00519 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >00520 &nbsp; &nbsp; str1 = text_to_cstring(location1);</font></div><div><font size="2"  >00521 &nbsp; &nbsp; str2 = text_to_cstring(location2);</font></div><div><font size="2"  >00522&nbsp;</font></div><div><font size="2"  >00523 &nbsp; &nbsp; validate_xlog_location(str1);</font></div><div><font size="2"  >00524 &nbsp; &nbsp; validate_xlog_location(str2);</font></div><div><font size="2"  >00525&nbsp;</font></div><div><font size="2"  >00526 &nbsp; &nbsp; if (sscanf(str1, "%X/%X", &amp;hi, &amp;lo) != 2)</font></div><div><font size="2"  >00527 &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >00528 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_INVALID_PARAMETER_VALUE),</font></div><div><font size="2"  >00529 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not parse transaction log location \"%s\"", str1)));</font></div><div><font size="2"  >00530 &nbsp; &nbsp; loc1 = ((uint64) hi) &lt;&lt; 32 | lo;</font></div><div><font size="2"  >00531&nbsp;</font></div><div><font size="2"  >00532 &nbsp; &nbsp; if (sscanf(str2, "%X/%X", &amp;hi, &amp;lo) != 2)</font></div><div><font size="2"  >00533 &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >00534 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_INVALID_PARAMETER_VALUE),</font></div><div><font size="2"  >00535 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not parse transaction log location \"%s\"", str2)));</font></div><div><font size="2"  >00536 &nbsp; &nbsp; loc2 = ((uint64) hi) &lt;&lt; 32 | lo;</font></div><div><font size="2"  >00537&nbsp;</font></div><div><font size="2"  >00538 &nbsp; &nbsp; bytes1 = (uint64) loc1;</font></div><div><font size="2"  >00539 &nbsp; &nbsp; bytes2 = (uint64) loc2;</font></div><div><font size="2"  >00540&nbsp;</font></div><div><font size="2"  >00541 &nbsp; &nbsp; /*</font></div><div><font size="2"  >00542 &nbsp; &nbsp; &nbsp;* result = bytes1 - bytes2.</font></div><div><font size="2"  >00543 &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >00544 &nbsp; &nbsp; &nbsp;* XXX: this won't handle values higher than 2^63 correctly.</font></div><div><font size="2"  >00545 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >00546 &nbsp; &nbsp; result = DatumGetNumeric(DirectFunctionCall2(numeric_sub,</font></div><div><font size="2"  >00547 &nbsp; &nbsp; &nbsp; &nbsp;DirectFunctionCall1(int8_numeric, Int64GetDatum((int64) bytes1)),</font></div><div><font size="2"  >00548 &nbsp; &nbsp; &nbsp; &nbsp;DirectFunctionCall1(int8_numeric, Int64GetDatum((int64) bytes2))));</font></div><div><font size="2"  >00549&nbsp;</font></div><div><font size="2"  >00550 &nbsp; &nbsp; PG_RETURN_NUMERIC(result);</font></div><div><font size="2"  >00551 }</font></div></div><p></p></pre></div><div>注意到, 输出的LOCATION格式如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >00211 &nbsp; &nbsp; snprintf(location, sizeof(location), "%X/%X",</font></div><div><font size="2"  >00212 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(uint32) (current_recptr &gt;&gt; 32), (uint32) current_recptr);</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >recptr&nbsp;是 uint64的类型, 右移32位后转换成uint32相当于去uint64的高32位数字.</span></div><div><span style="line-height: 22px;"  >recptr直接转换成uint32相当于取的recptr的低32位数字,&nbsp;</span></div><div><span style="line-height: 22px;"  >所以输出的 :&nbsp;</span></div><div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >digoal=# select pg_current_xlog_insert_location();</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp;pg_current_xlog_insert_location&nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  >---------------------------------</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp;0/C1F1EA8</font></div><div style="line-height: 22px;"  ><font size="2"  >(1 row)</font></div><p></p></pre></div><div style="line-height: 22px;"  >recptr就是 :&nbsp;</div><div style="line-height: 22px;"  >0x000000000<span style="line-height: 22px;"  >C1F1EA8</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  ><br></span></div><div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >digoal=# select pg_xlogfile_name('0/C1F1EA8');</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp;pg_xlogfile_name &nbsp; &nbsp;&nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  >--------------------------</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp;00000001000000000000000C</font></div><div style="line-height: 22px;"  ><font size="2"  >(1 row)</font></div><p></p></pre></div><div>在这里<span style="line-height: 22px;"  >0/C1F1EA8经过</span></div><div><pre class="prettyprint"  ><p><font size="2"  >locationpoint = ((uint64) hi) &lt;&lt; 32 | lo;&nbsp;</font></p></pre></div><div>后还原成XLogRecPtr类型, 也就是<span style="line-height: 22px;"  >0x000000000</span><span style="line-height: 22px;"  >C1F1EA8</span></div></div></div><div><span style="line-height: 22px;"  >然后返回文件名, 还需要用到时间线ID.xlogsegno.</span></div><div><span style="line-height: 22px;"  ><div><pre class="prettyprint"  ><p></p><div><font size="2"  >00376 &nbsp; &nbsp; XLByteToPrevSeg(locationpoint, xlogsegno);</font></div><div><font size="2"  >00377 &nbsp; &nbsp; XLogFileName(xlogfilename, ThisTimeLineID, xlogsegno);</font></div><div><font size="2"  >00378&nbsp;</font></div><div><font size="2"  >00379 &nbsp; &nbsp; PG_RETURN_TEXT_P(cstring_to_text(xlogfilename));</font></div><p></p></pre></div><div><br></div></span></div></div>
	</div>
</div>
</body>
</html>