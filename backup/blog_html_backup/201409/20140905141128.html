<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">performance for return distinct values case - By reduce sparse column's IO scan</h2>
	<h5 id="">2014-09-05 14:11:28&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020148515013557/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>今天一位以前的同事问到一个SQL调优的问题 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >select distinct plugin_type from tbl&nbsp;</font></div><div><font size="2"   >&nbsp; where status=1&nbsp;</font></div><div><font size="2"   >&nbsp; and &nbsp; imsi=$1 &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; and plugin_type in &nbsp; ( &nbsp; &nbsp;$2 &nbsp; ) ;</font></div><p></p></pre></div><div>这个SQL执行时间挺长的, 如何缩短, plugin_type上已有索引, 执行时间需要1000多毫秒.&nbsp;</div><div>假设PG用了最优的索引, 可能也要扫描较多的数据块来聚合最终的结果. (例如假设本例返回的count(*)结果集很大但是count(distinct plugin_type)结果集很小时)</div><div>我们这里要讲的优化方法是减少IO的扫描.&nbsp;</div><div>优化手段其实挺简单, 因为最终要得到的是唯一的plugin_type字段的值, 并且这个字段已经圈定范围了plugin_type in &nbsp; ( &nbsp; &nbsp;$2 &nbsp; ).&nbsp;</div><div>那么只需要改成函数来操作即可, 每一个值只判断一次.</div><div>这个优化方法适合稀疏列/非连续列的优化, 不适合连续列的优化.</div><div><br></div><div>测试如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create table t (id int, c1 int, c2 int, c3 int);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# insert into t select 1,1,1,generate_series(1,10) from generate_series(1,1000000);</font></div><div><font size="2"   >INSERT 0 10000000</font></div><div><font size="2"   >Time: 19097.897 ms</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# create index idx_t_1 on t(c3);</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# explain analyze select count(distinct c3) from t where c3 in (1,2,3,100,200,300);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >------</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=165792.60..165792.61 rows=1 width=4) (actual time=6260.045..6260.046 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Heap Scan on t &nbsp;(cost=51817.60..158302.60 rows=2996000 width=4) (actual time=497.106..3092.664 rows=3000000 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Recheck Cond: (c3 = ANY ('{1,2,3,100,200,300}'::integer[]))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rows Removed by Index Recheck: 5968706</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_t_1 &nbsp;(cost=0.00..51068.60 rows=2996000 width=0) (actual time=494.466..494.466 rows=3000000 loo</font></div><div><font size="2"   >ps=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (c3 = ANY ('{1,2,3,100,200,300}'::integer[]))</font></div><div><font size="2"   >&nbsp;Total runtime: 6260.158 ms</font></div><div><font size="2"   >(7 rows)</font></div><div><font size="2"   >Time: 6260.905 ms</font></div></div><div><font size="2"   >扫描的行比较多, 所以比较慢, 因此可以有优化空间. </font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# do language plpgsql $$</font></div><div><font size="2"   >declare&nbsp;</font></div><div><font size="2"   >&nbsp;i int;</font></div><div><font size="2"   >&nbsp;v int := null;</font></div><div><font size="2"   >&nbsp;c int := 0;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; foreach i in array array[1,2,3,100,200,300] loop</font></div><div><font size="2"   >&nbsp; &nbsp; execute 'select c3 from t where c3=$1 limit 1' into v using i;</font></div><div><font size="2"   >&nbsp; &nbsp; if v is not null then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; c := c+1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; raise notice '%, %', clock_timestamp(),v;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; end if;</font></div><div><font size="2"   >&nbsp; end loop;&nbsp;</font></div><div><font size="2"   >&nbsp; raise notice '%, count: %', clock_timestamp(), c;&nbsp;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$;</font></div><div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 13:49:53.966491+08, 1</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 13:49:53.966679+08, 2</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 13:49:53.966821+08, 3</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 13:49:53.967225+08, count: 3</font></div><div><font size="2"   >DO</font></div><div><font size="2"   >Time: 1.894 ms</font></div></div></div><p></p></pre></div><div>这里用动态SQL, 是因为plan cache机制会导致最后几个值走全表扫描. 所以改用动态SQL.</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012112452432251/"   >http://blog.163.com/digoal@126/blog/static/1638770402012112452432251/</a></div><div><br></div><div>这种方法可以拓展到非连续类型列(如int)的优化, 不适合连续类型列(如numeric)没有办法.</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# explain analyze select count(distinct c3) from t where id=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=204055.00..204055.01 rows=1 width=4) (actual time=16591.637..16591.637 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on t &nbsp;(cost=0.00..179055.00 rows=10000000 width=4) (actual time=0.012..2612.126 rows=10000000 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"   >&nbsp;Total runtime: 16591.679 ms</font></div><div><font size="2"   >(4 rows)</font></div><div><font size="2"   >Time: 16592.360 ms</font></div></div><div><div><font size="2"   >postgres=# select count(distinct c3) from t where id=1;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp; 10</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 14951.048 ms</font></div><div><font size="2"   >postgres=# select min(c3), max(c3) from t;</font></div><div><font size="2"   >&nbsp;min | max&nbsp;</font></div><div><font size="2"   >-----+-----</font></div><div><font size="2"   >&nbsp; &nbsp;1 | &nbsp;10</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 0.847 ms</font></div><div><div><font size="2"   >postgres=# do language plpgsql $$</font></div><div><font size="2"   >declare&nbsp;</font></div><div><font size="2"   >&nbsp;i int;</font></div><div><font size="2"   >&nbsp;v int := null;</font></div><div><font size="2"   >&nbsp;c int := 0;&nbsp;</font></div><div><font size="2"   >&nbsp; v_min int;&nbsp;</font></div><div><font size="2"   >&nbsp; v_max int;</font></div><div><font size="2"   >begin&nbsp;</font></div><div><font size="2"   >&nbsp; select min(c3),max(c3) into v_min, v_max from t;</font></div><div><font size="2"   >&nbsp; for i in v_min..v_max loop</font></div><div><font size="2"   >&nbsp; &nbsp; execute 'select c3 from t where c3=$1 and id=1 limit 1' into v using i;</font></div><div><font size="2"   >&nbsp; &nbsp; if v is not null then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; c := c+1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; raise notice '%, %', clock_timestamp(),v;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; end if;</font></div><div><font size="2"   >&nbsp; end loop;&nbsp;</font></div><div><font size="2"   >&nbsp; raise notice '%, count: %', clock_timestamp(), c;&nbsp;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$;</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 14:08:59.170962+08, 1</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 14:08:59.171145+08, 2</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 14:08:59.171287+08, 3</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 14:08:59.171438+08, 4</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 14:08:59.171577+08, 5</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 14:08:59.171716+08, 6</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 14:08:59.171855+08, 7</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 14:08:59.171994+08, 8</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 14:08:59.172132+08, 9</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 14:08:59.172271+08, 10</font></div><div><font size="2"   >NOTICE: &nbsp;2014-09-05 14:08:59.172328+08, count: 10</font></div><div><font size="2"   >DO</font></div><div><font size="2"   >Time: 2.763 ms</font></div></div></div><p></p></pre></div><wbr><div>类似的优化案例</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020129851138327/"   >http://blog.163.com/digoal@126/blog/static/16387704020129851138327/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201411152640383"   >http://blog.163.com/digoal@126/blog/static/163877040201411152640383</a></div>
<div><br></div><a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="performance for return distinct values case - By reduce sparse columns IO scan - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>