<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">column based storage's logical address for variable length type</h2>
	<h5 id="">2014-09-05 16:50:34&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402014854949612/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>最近VLDB的大会在杭州召开, 很多数据库专家远道而来参加这次大会, PG社区也来了几位兄弟.</div><div>昨天晚上和galy, 光标还有aida, thomas, jeef, 还有一位伯克利大学的朋友, 浙大的老师一起小聚了一下.&nbsp;</div><div>在跟thomas和jeff davis聊天中学到了不少东西, jeff和thomas 都是teradata Aster产品的研发人员, 对PG内核非常了解.&nbsp;</div><div>目前基于pg改的并支持列存储的产品有aster, paraccel, greenplum, 华为改过的PG-XC(据说性能已超越GreenPlum), citusDB, 等. 产品还是很多的.</div><div><br></div><div>我们知道PostgreSQL是行存储的, 并且目前一行不能跨数据块存储, 也就是说行的宽度收到了限制, 目前的限制大概是1600多个列.</div><div>参看代码 :&nbsp;</div><div>src/include/access/htup_details.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* MaxTupleAttributeNumber limits the number of (user) columns in a tuple.</font></div><div><font size="2"   >&nbsp;* The key limit on this value is that the size of the fixed overhead for</font></div><div><font size="2"   >&nbsp;* a tuple, plus the size of the null-values bitmap (at 1 bit per column),</font></div><div><font size="2"   >&nbsp;* plus MAXALIGN alignment, must fit into t_hoff which is uint8. &nbsp;On most</font></div><div><font size="2"   >&nbsp;* machines the upper limit without making t_hoff wider would be a little</font></div><div><font size="2"   >&nbsp;* over 1700. &nbsp;We use round numbers here and for MaxHeapAttributeNumber</font></div><div><font size="2"   >&nbsp;* so that alterations in HeapTupleHeaderData layout won't change the</font></div><div><font size="2"   >&nbsp;* supported max number of columns.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define MaxTupleAttributeNumber 1664 &nbsp; &nbsp;/* 8 * 208 */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* MaxHeapAttributeNumber limits the number of (user) columns in a table.</font></div><div><font size="2"   >&nbsp;* This should be somewhat less than MaxTupleAttributeNumber. &nbsp;It must be</font></div><div><font size="2"   >&nbsp;* at least one less, else we will fail to do UPDATEs on a maximal-width</font></div><div><font size="2"   >&nbsp;* table (because UPDATE has to form working tuples that include CTID).</font></div><div><font size="2"   >&nbsp;* In practice we want some additional daylight so that we can gracefully</font></div><div><font size="2"   >&nbsp;* support operations that add hidden "resjunk" columns, for example</font></div><div><font size="2"   >&nbsp;* SELECT * FROM wide_table ORDER BY foo, bar, baz.</font></div><div><font size="2"   >&nbsp;* In any case, depending on column data types you will likely be running</font></div><div><font size="2"   >&nbsp;* into the disk-block-based limit on overall tuple size if you have more</font></div><div><font size="2"   >&nbsp;* than a thousand or so columns. &nbsp;TOAST won't help.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define MaxHeapAttributeNumber &nbsp;1600 &nbsp; &nbsp;/* 8 * 200 */</font></div><p></p></pre></div><div>那么如果使用列存储的话, 其实理论上就不存在宽度的限制了.</div><div>行存储的优势在于如果每次要查询的都是整行或者多列的话, 可以减少IO的次数, 因为一行就在一个数据块里面.</div><div>但是行存储可能不适合基于单列或少量列的大量数据的聚合操作, 例如全表的聚合, 那么需要扫描全表.</div><div>列存储的优势在这里就得到了体现, 当我们的每次操作更关注在少量列或单列上时, 显然可以减少大量的IO.&nbsp;</div><div><span style="line-height: 28px;"   >但是如果将行打散成列存储后, 如何能快速的取出行的数据呢, 或者说属于同一行的列和列之间怎么联系起来.</span></div><div>其实我们可以想象一个逻辑地址, 把文件的访问通过逻辑地址来定位.</div><div>例如我们在根据条件定位到了某一列的某条记录的时候, 这条记录在这个列对应的文件其实有一个逻辑地址,&nbsp;</div><div>对于定长字段比较好理解, 比如4字节的定长字段, 我们访问第100条记录的话, 逻辑地址就是这个文件的位移量99*4字节.</div><div>那么通过这个位移量就能在其他列的文件中找到这条记录中的其他列的值.</div><div>但是对于变长字段的话, 因为变长字段每条记录占用的空间可能不一样, 如果直接通过这个位移量去读取文件的话, 显然不能读到对应的列的值, 所以对于变长字段, 我们同样需要一个定长的类型来存储偏移量.&nbsp;</div><div>这张图说明变长字段有一个定长类型来存储真实的偏移量, 从而定位到对应的数据.</div><div><div><img title="column based storages logical address for variable length type - 德哥@Digoal - PostgreSQL research"   alt="column based storages logical address for variable length type - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img0.ph.126.net/WjHWAX8E4I1vEGM-n85OzQ==/6619341474188436699.png"   ></div>列存储还要考虑列值例如是否为空的问题, 例如用1个比特位来记录是否为空, 从而区分真实值是空还是0.</div><div>这个有点类似postgresql的info mask里的比特位 .</div><div>如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp;* Following the fixed header fields, the nulls bitmap is stored (beginning</font></div><div><font size="2"   >&nbsp;* at t_bits). &nbsp;The bitmap is *not* stored if t_infomask shows that there</font></div><div><font size="2"   >&nbsp;* are no nulls in the tuple. &nbsp;If an OID field is present (as indicated by</font></div><div><font size="2"   >&nbsp;* t_infomask), then it is stored just before the user data, which begins at</font></div><div><font size="2"   >&nbsp;* the offset shown by t_hoff. &nbsp;Note that t_hoff must be a multiple of</font></div><div><font size="2"   >&nbsp;* MAXALIGN.</font></div></div><div><div><font size="2"   >struct HeapTupleHeaderData</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; union</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleFields t_heap;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumTupleFields t_datum;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t_choice;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerData t_ctid; &nbsp; &nbsp; &nbsp; &nbsp; /* current TID of this or newer tuple */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Fields below here must match MinimalTupleData! */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t_infomask2; &nbsp; &nbsp;/* number of attributes + various flags */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t_infomask; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* various flag bits, see below */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t_hoff; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* sizeof header incl. bitmap, padding */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* ^ - 23 bytes - ^ */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bits8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t_bits[1]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* bitmap of NULLs -- VARIABLE LENGTH */ &nbsp;用于存储是否为空比特位.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* MORE DATA FOLLOWS AT END OF STRUCT */</font></div><div><font size="2"   >};</font></div></div><p></p></pre></div><div>参考部分是monetdb的gdk头文件, 因为monetdb是列存储的数据库, 我们可以学习一下是否和前面的原理类似.</div><div>另外这里的偏移量, 需要注意位数问题, 位数决定了可以存储多大的文件. 例如32位, 最大能定位4G的文件. 那么一个列就可能要拆成多个文件来存储, 同时便宜量里面可能还要存储文件名等信息.</div><div><br></div>[参考]<div>1.&nbsp;<a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Column-oriented_DBMS"   >http://en.wikipedia.org/wiki/Column-oriented_DBMS</a><br><wbr><div>2. monetdb src</div><div>gdk/gdk.h</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* @t The Goblin Database Kernel</font></div><div><font size="2"   >&nbsp;* @v Version 3.05</font></div><div><font size="2"   >&nbsp;* @a Martin L. Kersten, Peter Boncz, Niels Nes</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @+ The Inner Core</font></div><div><font size="2"   >&nbsp;* The innermost library of the MonetDB database system is formed by</font></div><div><font size="2"   >&nbsp;* the library called GDK, an abbreviation of Goblin Database Kernel.</font></div><div><font size="2"   >&nbsp;* Its development was originally rooted in the design of a pure</font></div><div><font size="2"   >&nbsp;* active-object-oriented programming language, before development</font></div><div><font size="2"   >&nbsp;* was shifted towards a re-usable database kernel engine.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* GDK is a C library that provides ACID properties on a DSM model</font></div><div><font size="2"   >&nbsp;* @tex</font></div><div><font size="2"   >&nbsp;* [@cite{Copeland85}]</font></div><div><font size="2"   >&nbsp;* @end tex</font></div><div><font size="2"   >&nbsp;* , using main-memory</font></div><div><font size="2"   >&nbsp;* database algorithms</font></div><div><font size="2"   >&nbsp;* @tex</font></div><div><font size="2"   >&nbsp;* [@cite{Garcia-Molina92}]</font></div><div><font size="2"   >&nbsp;* @end tex</font></div><div><font size="2"   >&nbsp;* &nbsp;built on virtual-memory</font></div><div><font size="2"   >&nbsp;* OS primitives and multi-threaded parallelism.</font></div><div><font size="2"   >&nbsp;* Its implementation has undergone various changes over its decade</font></div><div><font size="2"   >&nbsp;* of development, many of which were driven by external needs to</font></div><div><font size="2"   >&nbsp;* obtain a robust and fast database system.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The coding scheme explored in GDK has also laid a foundation to</font></div><div><font size="2"   >&nbsp;* communicate over time experiences and to provide (hopefully)</font></div><div><font size="2"   >&nbsp;* helpful advice near to the place where the code-reader needs it.</font></div><div><font size="2"   >&nbsp;* Of course, over such a long time the documentation diverges from</font></div><div><font size="2"   >&nbsp;* reality. Especially in areas where the environment of this package</font></div><div><font size="2"   >&nbsp;* is being described.</font></div><div><font size="2"   >&nbsp;* Consider such deviations as historic landmarks, e.g. crystallization</font></div><div><font size="2"   >&nbsp;* of brave ideas and mistakes rectified at a later stage.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @+ Short Outline</font></div><div><font size="2"   >&nbsp;* The facilities provided in this implementation are:</font></div></div><div><div><font size="2"   >&nbsp;* @itemize</font></div><div><font size="2"   >&nbsp;* @item</font></div><div><font size="2"   >&nbsp;* GDK or Goblin Database Kernel routines for session management</font></div><div><font size="2"   >&nbsp;* @item</font></div><div><font size="2"   >&nbsp;* &nbsp;BAT routines that define the primitive operations on the</font></div><div><font size="2"   >&nbsp;* database tables (BATs).</font></div><div><font size="2"   >&nbsp;* @item</font></div><div><font size="2"   >&nbsp;* &nbsp;BBP routines to manage the BAT Buffer Pool (BBP).</font></div><div><font size="2"   >&nbsp;* @item</font></div><div><font size="2"   >&nbsp;* &nbsp;ATOM routines to manipulate primitive types, define new types</font></div><div><font size="2"   >&nbsp;* using an ADT interface.</font></div><div><font size="2"   >&nbsp;* @item</font></div><div><font size="2"   >&nbsp;* &nbsp;HEAP routines for manipulating heaps: linear spaces of memory</font></div><div><font size="2"   >&nbsp;* that are GDK's vehicle of mass storage (on which BATs are built).</font></div><div><font size="2"   >&nbsp;* @item</font></div><div><font size="2"   >&nbsp;* &nbsp;DELTA routines to access inserted/deleted elements within a</font></div><div><font size="2"   >&nbsp;* transaction.</font></div><div><font size="2"   >&nbsp;* @item</font></div><div><font size="2"   >&nbsp;* &nbsp;HASH routines for manipulating GDK's built-in linear-chained</font></div><div><font size="2"   >&nbsp;* hash tables, for accelerating lookup searches on BATs.</font></div><div><font size="2"   >&nbsp;* @item</font></div><div><font size="2"   >&nbsp;* &nbsp;TM routines that provide basic transaction management primitives.</font></div><div><font size="2"   >&nbsp;* @item</font></div><div><font size="2"   >&nbsp;* &nbsp;TRG routines that provided active database support. [DEPRECATED]</font></div><div><font size="2"   >&nbsp;* @item</font></div><div><font size="2"   >&nbsp;* &nbsp;ALIGN routines that implement BAT alignment management.</font></div><div><font size="2"   >&nbsp;* @end itemize</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The Binary Association Table (BAT) is the lowest level of storage</font></div><div><font size="2"   >&nbsp;* considered in the Goblin runtime system</font></div><div><font size="2"   >&nbsp;* @tex</font></div><div><font size="2"   >&nbsp;* [@cite{Goblin}]</font></div><div><font size="2"   >&nbsp;* @end tex</font></div><div><font size="2"   >&nbsp;* . &nbsp;A BAT is a</font></div><div><font size="2"   >&nbsp;* self-descriptive main-memory structure that represents the</font></div><div><font size="2"   >&nbsp;* @strong{binary relationship} between two atomic types. &nbsp;The</font></div><div><font size="2"   >&nbsp;* association can be defined over:</font></div><div><font size="2"   >&nbsp;* @table @code</font></div></div><div><div><font size="2"   >&nbsp;* @item void:</font></div><div><font size="2"   >&nbsp;* &nbsp;virtual-OIDs: a densely ascending column of OIDs (takes zero-storage).</font></div><div><font size="2"   >&nbsp;* @item bit:</font></div><div><font size="2"   >&nbsp;* &nbsp;Booleans, implemented as one byte values.</font></div><div><font size="2"   >&nbsp;* @item bte:</font></div><div><font size="2"   >&nbsp;* &nbsp;Tiny (1-byte) integers (8-bit @strong{integer}s).</font></div><div><font size="2"   >&nbsp;* @item sht:</font></div><div><font size="2"   >&nbsp;* &nbsp;Short integers (16-bit @strong{integer}s).</font></div><div><font size="2"   >&nbsp;* @item int:</font></div><div><font size="2"   >&nbsp;* &nbsp;This is the C @strong{int} type (32-bit).</font></div><div><font size="2"   >&nbsp;* @item oid:</font></div><div><font size="2"   >&nbsp;* &nbsp;Unique @strong{long int} values uses as object identifier. Highest</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bit cleared always. &nbsp;Thus, oids-s are 31-bit numbers on</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;32-bit systems, and 63-bit numbers on 64-bit systems.</font></div><div><font size="2"   >&nbsp;* @item wrd:</font></div><div><font size="2"   >&nbsp;* &nbsp;Machine-word sized integers</font></div><div><font size="2"   >&nbsp;* &nbsp;(32-bit on 32-bit systems, 64-bit on 64-bit systems).</font></div><div><font size="2"   >&nbsp;* @item ptr:</font></div><div><font size="2"   >&nbsp;* Memory pointer values. DEPRECATED. &nbsp;Can only be stored in transient</font></div><div><font size="2"   >&nbsp;* BATs.</font></div><div><font size="2"   >&nbsp;* @item flt:</font></div><div><font size="2"   >&nbsp;* &nbsp;The IEEE @strong{float} type.</font></div><div><font size="2"   >&nbsp;* @item dbl:</font></div><div><font size="2"   >&nbsp;* &nbsp;The IEEE @strong{double} type.</font></div><div><font size="2"   >&nbsp;* @item lng:</font></div><div><font size="2"   >&nbsp;* &nbsp;Longs: the C @strong{long long} type (64-bit integers).</font></div><div><font size="2"   >&nbsp;* @item str:</font></div><div><font size="2"   >&nbsp;* &nbsp;UTF-8 strings (Unicode). A zero-terminated byte sequence.</font></div><div><font size="2"   >&nbsp;* @item bat:</font></div><div><font size="2"   >&nbsp;* &nbsp;Bat descriptor. This allows for recursive administered tables, but</font></div><div><font size="2"   >&nbsp;* &nbsp;severely complicates transaction management. Therefore, they CAN</font></div><div><font size="2"   >&nbsp;* &nbsp;ONLY BE STORED IN TRANSIENT BATs.</font></div><div><font size="2"   >&nbsp;* @end table</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This model can be used as a back-end model underlying other -higher</font></div><div><font size="2"   >&nbsp;* level- models, in order to achieve @strong{better performance} and</font></div><div><font size="2"   >&nbsp;* @strong{data independence} in one go. The relational model and the</font></div><div><font size="2"   >&nbsp;* object-oriented model can be mapped on BATs by vertically splitting</font></div></div><div><div><font size="2"   >&nbsp;* every table (or class) for each attribute. Each such a column is</font></div><div><font size="2"   >&nbsp;* then stored in a BAT with type @strong{bat[oid,attribute]}, where</font></div><div><font size="2"   >&nbsp;* the unique object identifiers link tuples in the different BATs.</font></div><div><font size="2"   >&nbsp;* Relationship attributes in the object-oriented model hence are</font></div><div><font size="2"   >&nbsp;* mapped to @strong{bat[oid,oid]} tables, being equivalent to the</font></div><div><font size="2"   >&nbsp;* concept of @emph{join indexes} @tex [@cite{Valduriez87}] @end tex .</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The set of built-in types can be extended with user-defined types</font></div><div><font size="2"   >&nbsp;* through an ADT interface. &nbsp;They are linked with the kernel to</font></div><div><font size="2"   >&nbsp;* obtain an enhanced library, or they are dynamically loaded upon</font></div><div><font size="2"   >&nbsp;* request.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Types can be derived from other types. They represent something</font></div><div><font size="2"   >&nbsp;* different than that from which they are derived, but their internal</font></div><div><font size="2"   >&nbsp;* storage management is equal. This feature facilitates the work of</font></div><div><font size="2"   >&nbsp;* extension programmers, by enabling reuse of implementation code,</font></div><div><font size="2"   >&nbsp;* but is also used to keep the GDK code portable from 32-bits to</font></div><div><font size="2"   >&nbsp;* 64-bits machines: the @strong{oid} and @strong{ptr} types are</font></div><div><font size="2"   >&nbsp;* derived from @strong{int} on 32-bits machines, but is derived from</font></div><div><font size="2"   >&nbsp;* @strong{lng} on 64 bits machines. This requires changes in only two</font></div><div><font size="2"   >&nbsp;* lines of code each.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* To accelerate lookup and search in BATs, GDK supports one built-in</font></div><div><font size="2"   >&nbsp;* search accelerator: hash tables. We choose an implementation</font></div><div><font size="2"   >&nbsp;* efficient for main-memory: bucket chained hash</font></div><div><font size="2"   >&nbsp;* @tex</font></div><div><font size="2"   >&nbsp;* [@cite{LehCar86,Analyti92}]</font></div><div><font size="2"   >&nbsp;* @end tex</font></div><div><font size="2"   >&nbsp;* . Alternatively, when the table is sorted, it will resort to</font></div><div><font size="2"   >&nbsp;* merge-scan operations or binary lookups.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* BATs are built on the concept of heaps, which are large pieces of</font></div><div><font size="2"   >&nbsp;* main memory. They can also consist of virtual memory, in case the</font></div><div><font size="2"   >&nbsp;* working set exceeds main-memory. In this case, GDK supports</font></div><div><font size="2"   >&nbsp;* operations that cluster the heaps of a BAT, in order to improve</font></div><div><font size="2"   >&nbsp;* performance of its main-memory.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;*</font></div></div><div><div><font size="2"   >&nbsp;* @- Rationale</font></div><div><font size="2"   >&nbsp;* The rationale for choosing a BAT as the building block for both</font></div><div><font size="2"   >&nbsp;* relational and object-oriented system is based on the following</font></div><div><font size="2"   >&nbsp;* observations:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @itemize</font></div><div><font size="2"   >&nbsp;* @item -</font></div><div><font size="2"   >&nbsp;* Given the fact that CPU speed and main-memory increase in current</font></div><div><font size="2"   >&nbsp;* workstation hardware for the last years has been exceeding IO</font></div><div><font size="2"   >&nbsp;* access speed increase, traditional disk-page oriented algorithms do</font></div><div><font size="2"   >&nbsp;* no longer take best advantage of hardware, in most database</font></div><div><font size="2"   >&nbsp;* operations.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Instead of having a disk-block oriented kernel with a large memory</font></div><div><font size="2"   >&nbsp;* cache, we choose to build a main-memory kernel, that only under</font></div><div><font size="2"   >&nbsp;* large data volumes slowly degrades to IO-bound performance,</font></div><div><font size="2"   >&nbsp;* comparable to traditional systems</font></div><div><font size="2"   >&nbsp;* @tex</font></div><div><font size="2"   >&nbsp;* [@cite{boncz95,boncz96}]</font></div><div><font size="2"   >&nbsp;* @end tex</font></div><div><font size="2"   >&nbsp;* .</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @item -</font></div><div><font size="2"   >&nbsp;* Traditional (disk-based) relational systems move too much data</font></div><div><font size="2"   >&nbsp;* around to save on (main-memory) join operations.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The fully decomposed store (DSM</font></div><div><font size="2"   >&nbsp;* @tex</font></div><div><font size="2"   >&nbsp;* [@cite{Copeland85})]</font></div><div><font size="2"   >&nbsp;* @end tex</font></div><div><font size="2"   >&nbsp;* assures that only those attributes of a relation that are needed,</font></div><div><font size="2"   >&nbsp;* will have to be accessed.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @item -</font></div><div><font size="2"   >&nbsp;* The data management issues for a binary association is much</font></div><div><font size="2"   >&nbsp;* easier to deal with than traditional @emph{struct}-based approaches</font></div><div><font size="2"   >&nbsp;* encountered in relational systems.</font></div><div><font size="2"   >&nbsp;*</font></div></div><div><div><font size="2"   >&nbsp;* @item -</font></div><div><font size="2"   >&nbsp;* Object-oriented systems often maintain a double cache, one with the</font></div><div><font size="2"   >&nbsp;* disk-based representation and a C pointer-based main-memory</font></div><div><font size="2"   >&nbsp;* structure. &nbsp;This causes expensive conversions and replicated</font></div><div><font size="2"   >&nbsp;* storage management. &nbsp;GDK does not do such `pointer swizzling'. It</font></div><div><font size="2"   >&nbsp;* used virtual-memory (@strong{mmap()}) and buffer management advice</font></div><div><font size="2"   >&nbsp;* (@strong{madvise()}) OS primitives to cache only once. Tables take</font></div><div><font size="2"   >&nbsp;* the same form in memory as on disk, making the use of this</font></div><div><font size="2"   >&nbsp;* technique transparent</font></div><div><font size="2"   >&nbsp;* @tex</font></div><div><font size="2"   >&nbsp;* [@cite{oo7}]</font></div><div><font size="2"   >&nbsp;* @end tex</font></div><div><font size="2"   >&nbsp;* .</font></div><div><font size="2"   >&nbsp;* @end itemize</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* A RDBMS or OODBMS based on BATs strongly depends on our ability to</font></div><div><font size="2"   >&nbsp;* efficiently support tuples and to handle small joins, respectively.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The remainder of this document describes the Goblin Database kernel</font></div><div><font size="2"   >&nbsp;* implementation at greater detail. It is organized as follows:</font></div><div><font size="2"   >&nbsp;* @table @code</font></div><div><font size="2"   >&nbsp;* @item @strong{GDK Interface}:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* It describes the global interface with which GDK sessions can be</font></div><div><font size="2"   >&nbsp;* started and ended, and environment variables used.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @item @strong{Binary Association Tables}:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* As already mentioned, these are the primary data structure of GDK.</font></div><div><font size="2"   >&nbsp;* This chapter describes the kernel operations for creation,</font></div><div><font size="2"   >&nbsp;* destruction and basic manipulation of BATs and BUNs (i.e. tuples:</font></div><div><font size="2"   >&nbsp;* Binary UNits).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @item @strong{BAT Buffer Pool:}</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* All BATs are registered in the BAT Buffer Pool. This directory is</font></div><div><font size="2"   >&nbsp;* used to guide swapping in and out of BATs. Here we find routines</font></div><div><font size="2"   >&nbsp;* that guide this swapping process.</font></div></div><div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @item @strong{GDK Extensibility:}</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Atoms can be defined using a unified ADT interface. &nbsp;There is also</font></div><div><font size="2"   >&nbsp;* an interface to extend the GDK library with dynamically linked</font></div><div><font size="2"   >&nbsp;* object code.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @item @strong{GDK Utilities:}</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Memory allocation and error handling primitives are</font></div><div><font size="2"   >&nbsp;* provided. Layers built on top of GDK should use them, for proper</font></div><div><font size="2"   >&nbsp;* system monitoring. &nbsp;Thread management is also included here.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @item @strong{Transaction Management:}</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* For the time being, we just provide BAT-grained concurrency and</font></div><div><font size="2"   >&nbsp;* global transactions. Work is needed here.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @item @strong{BAT Alignment:}</font></div><div><font size="2"   >&nbsp;* Due to the mapping of multi-ary datamodels onto the BAT model, we</font></div><div><font size="2"   >&nbsp;* expect many correspondences among BATs, e.g.</font></div><div><font size="2"   >&nbsp;* @emph{bat(oid,attr1),.. &nbsp;bat(oid,attrN)} vertical</font></div><div><font size="2"   >&nbsp;* decompositions. Frequent activities will be to jump from one</font></div><div><font size="2"   >&nbsp;* attribute to the other (`bunhopping'). If the head columns are</font></div><div><font size="2"   >&nbsp;* equal lists in two BATs, merge or even array lookups can be used</font></div><div><font size="2"   >&nbsp;* instead of hash lookups. The alignment interface makes these</font></div><div><font size="2"   >&nbsp;* relations explicitly manageable.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* In GDK, complex data models are mapped with DSM on binary tables.</font></div><div><font size="2"   >&nbsp;* Usually, one decomposes @emph{N}-ary relations into @emph{N} BATs</font></div><div><font size="2"   >&nbsp;* with an @strong{oid} in the head column, and the attribute in the</font></div><div><font size="2"   >&nbsp;* tail column. &nbsp;There may well be groups of tables that have the same</font></div><div><font size="2"   >&nbsp;* sets of @strong{oid}s, equally ordered. The alignment interface is</font></div><div><font size="2"   >&nbsp;* intended to make this explicit. &nbsp;Implementations can use this</font></div><div><font size="2"   >&nbsp;* interface to detect this situation, and use cheaper algorithms</font></div><div><font size="2"   >&nbsp;* (like merge-join, or even array lookup) instead.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @item @strong{BAT Iterators:}</font></div></div><div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Iterators are C macros that generally encapsulate a complex</font></div><div><font size="2"   >&nbsp;* for-loop. &nbsp;They would be the equivalent of cursors in the SQL</font></div><div><font size="2"   >&nbsp;* model. The macro interface (instead of a function call interface)</font></div><div><font size="2"   >&nbsp;* is chosen to achieve speed when iterating main-memory tables.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @item @strong{Common BAT Operations:}</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* These are much used operations on BATs, such as aggregate functions</font></div><div><font size="2"   >&nbsp;* and relational operators. They are implemented in terms of BAT- and</font></div><div><font size="2"   >&nbsp;* BUN-manipulation GDK primitives.</font></div><div><font size="2"   >&nbsp;* @end table</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @+ Interface Files</font></div><div><font size="2"   >&nbsp;* In this section we summarize the user interface to the GDK library.</font></div><div><font size="2"   >&nbsp;* It consist of a header file (gdk.h) and an object library</font></div><div><font size="2"   >&nbsp;* (gdklib.a), which implements the required functionality. The header</font></div><div><font size="2"   >&nbsp;* file must be included in any program that uses the library. The</font></div><div><font size="2"   >&nbsp;* library must be linked with such a program.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @- Database Context</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The MonetDB environment settings are collected in a configuration</font></div><div><font size="2"   >&nbsp;* file. Amongst others it contains the location of the database</font></div><div><font size="2"   >&nbsp;* directory. &nbsp;First, the database directory is closed for other</font></div><div><font size="2"   >&nbsp;* servers running at the same time. &nbsp;Second, performance enhancements</font></div><div><font size="2"   >&nbsp;* may take effect, such as locking the code into memory (if the OS</font></div><div><font size="2"   >&nbsp;* permits) and preloading the data dictionary. &nbsp;An error at this</font></div><div><font size="2"   >&nbsp;* stage normally lead to an abort.</font></div><div><font size="2"   >&nbsp;*/</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* @+ Binary Association Tables</font></div><div><font size="2"   >&nbsp;* Having gone to the previous preliminary definitions, we will now</font></div><div><font size="2"   >&nbsp;* introduce the structure of Binary Association Tables (BATs) in</font></div><div><font size="2"   >&nbsp;* detail. They are the basic storage unit on which GDK is modeled.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The BAT holds an unlimited number of binary associations, called</font></div><div><font size="2"   >&nbsp;* BUNs (@strong{Binary UNits}). &nbsp;The two attributes of a BUN are</font></div><div><font size="2"   >&nbsp;* called @strong{head} (left) and @strong{tail} (right) in the</font></div><div><font size="2"   >&nbsp;* remainder of this document.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp;@c image{http://monetdb.cwi.nl/projects/monetdb-mk/imgs/bat1,,,,feps}</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The above figure shows what a BAT looks like. It consists of two</font></div><div><font size="2"   >&nbsp;* columns, called head and tail, such that we have always binary</font></div><div><font size="2"   >&nbsp;* tuples (BUNs). The overlooking structure is the @strong{BAT</font></div><div><font size="2"   >&nbsp;* record}. &nbsp;It points to a heap structure called the @strong{BUN</font></div><div><font size="2"   >&nbsp;* heap}. &nbsp;This heap contains the atomic values inside the two</font></div><div><font size="2"   >&nbsp;* columns. If they are fixed-sized atoms, these atoms reside directly</font></div><div><font size="2"   >&nbsp;* in the BUN heap. If they are variable-sized atoms (such as string</font></div><div><font size="2"   >&nbsp;* or polygon), however, the columns has an extra heap for storing</font></div><div><font size="2"   >&nbsp;* those (such @strong{variable-sized atom heaps} are then referred to</font></div><div><font size="2"   >&nbsp;* as @strong{Head Heap}s and @strong{Tail Heap}s). The BUN heap then</font></div><div><font size="2"   >&nbsp;* contains integer byte-offsets (fixed-sized, of course) into a head-</font></div><div><font size="2"   >&nbsp;* or tail-heap.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The BUN heap contains a contiguous range of BUNs. It starts after</font></div><div><font size="2"   >&nbsp;* the @strong{first} pointer, and finishes at the end in the</font></div><div><font size="2"   >&nbsp;* @strong{free} area of the BUN. All BUNs after the @strong{inserted}</font></div><div><font size="2"   >&nbsp;* pointer have been added in the last transaction (and will be</font></div><div><font size="2"   >&nbsp;* deleted on a transaction abort). All BUNs between the</font></div><div><font size="2"   >&nbsp;* @strong{deleted} pointer and the @strong{first} have been deleted</font></div><div><font size="2"   >&nbsp;* in this transaction (and will be reinserted at a transaction</font></div><div><font size="2"   >&nbsp;* abort).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The location of a certain BUN in a BAT may change between</font></div><div><font size="2"   >&nbsp;* successive library routine invocations. &nbsp;Therefore, one should</font></div><div><font size="2"   >&nbsp;* avoid keeping references into the BAT storage area for long</font></div></div><div><div><font size="2"   >&nbsp;* periods.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Passing values between the library routines and the enclosing C</font></div><div><font size="2"   >&nbsp;* program is primarily through value pointers of type ptr. Pointers</font></div><div><font size="2"   >&nbsp;* into the BAT storage area should only be used for retrieval. Direct</font></div><div><font size="2"   >&nbsp;* updates of data stored in a BAT is forbidden. The user should</font></div><div><font size="2"   >&nbsp;* adhere to the interface conventions to guarantee the integrity</font></div><div><font size="2"   >&nbsp;* rules and to maintain the (hidden) auxiliary search structures.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* @- GDK variant record type</font></div><div><font size="2"   >&nbsp;* When manipulating values, MonetDB puts them into value records.</font></div><div><font size="2"   >&nbsp;* The built-in types have a direct entry in the union. Others should</font></div><div><font size="2"   >&nbsp;* be represented as a pointer of memory in pval or as a string, which</font></div><div><font size="2"   >&nbsp;* is basically the same. In such cases the len field indicates the</font></div><div><font size="2"   >&nbsp;* size of this piece of memory.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef struct {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; union { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* storage is first in the record */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int ival;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oid oval;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sht shval;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bte btval;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wrd wval;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flt fval;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr pval;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct BAT *Bval; /* this field is only used by mel */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bat bval;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str sval;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbl dval;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lng lval;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; } val;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int len, vtype;</font></div><div><font size="2"   >} *ValPtr, ValRecord;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* definition of VALptr lower down in file after include of gdk_atoms.h */</font></div><div><font size="2"   >#define VALnil(v,t) VALset(v,t,ATOMextern(t)?ATOMnil(t):ATOMnilptr(t))</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* interface definitions */</font></div></div><div><div><font size="2"   >gdk_export ptr VALconvert(int typ, ValPtr t);</font></div><div><font size="2"   >gdk_export int VALformat(char **buf, const ValRecord *res);</font></div><div><font size="2"   >gdk_export ValPtr VALcopy(ValPtr dst, const ValRecord *src);</font></div><div><font size="2"   >gdk_export ValPtr VALinit(ValPtr d, int tpe, const void *s);</font></div><div><font size="2"   >gdk_export void VALempty(ValPtr v);</font></div><div><font size="2"   >gdk_export void VALclear(ValPtr v);</font></div><div><font size="2"   >gdk_export ValPtr VALset(ValPtr v, int t, ptr p);</font></div><div><font size="2"   >gdk_export void *VALget(ValPtr v);</font></div><div><font size="2"   >gdk_export int VALcmp(const ValRecord *p, const ValRecord *q);</font></div><div><font size="2"   >gdk_export int VALisnil(const ValRecord *v);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* @- The BAT record</font></div><div><font size="2"   >&nbsp;* The elements of the BAT structure are introduced in the remainder.</font></div><div><font size="2"   >&nbsp;* Instead of using the underlying types hidden beneath it, one should</font></div><div><font size="2"   >&nbsp;* use a @emph{BAT} type that is supposed to look like this:</font></div><div><font size="2"   >&nbsp;* @verbatim</font></div><div><font size="2"   >&nbsp;* typedef struct {</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // static BAT properties</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bat &nbsp; &nbsp;batCacheid; &nbsp; &nbsp; &nbsp; // bat id: index in BBPcache</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp;batPersistence; &nbsp; // persistence mode</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit &nbsp; &nbsp;batCopiedtodisk; &nbsp;// BAT is saved on disk?</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit &nbsp; &nbsp;batSet; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // all tuples in the BAT are unique?</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // dynamic BAT properties</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp;batHeat; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// heat of BAT in the BBP</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sht &nbsp; &nbsp;batDirty; &nbsp; &nbsp; &nbsp; &nbsp; // BAT modified after last commit?</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit &nbsp; &nbsp;batDirtydesc; &nbsp; &nbsp; // BAT descriptor specific dirty flag</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Heap* &nbsp;batBuns; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Heap where the buns are stored</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // DELTA status</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BUN &nbsp; &nbsp;batDeleted; &nbsp; &nbsp; &nbsp; // first deleted BUN</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BUN &nbsp; &nbsp;batFirst; &nbsp; &nbsp; &nbsp; &nbsp; // empty BUN before the first alive BUN</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BUN &nbsp; &nbsp;batInserted; &nbsp; &nbsp; &nbsp;// first inserted BUN</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BUN &nbsp; &nbsp;batCount; &nbsp; &nbsp; &nbsp; &nbsp; // Tuple count</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Head properties</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp;htype; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Head type number</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str &nbsp; &nbsp;hident; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // name for head column</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit &nbsp; &nbsp;hkey; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // head values should be unique?</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit &nbsp; &nbsp;hsorted; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// are head values currently ordered?</font></div></div><div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit &nbsp; &nbsp;hvarsized; &nbsp; &nbsp; &nbsp; &nbsp;// for speed: head type is varsized?</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit &nbsp; &nbsp;hnonil; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // head has no nils</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oid &nbsp; &nbsp;halign; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// alignment OID for head.</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Head storage</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp;hloc; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // byte-offset in BUN for head elements</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Heap &nbsp; *hheap; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // heap for varsized head values</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Hash &nbsp; *hhash; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // linear chained hash table on head</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Imprints *himprints; &nbsp; &nbsp; // column imprints index on head</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Tail properties</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp;ttype; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Tail type number</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str &nbsp; &nbsp;tident; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // name for tail column</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit &nbsp; &nbsp;tkey; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // tail values should be unique?</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit &nbsp; &nbsp;tnonil; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // tail has no nils</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit &nbsp; &nbsp;tsorted; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// are tail values currently ordered?</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bit &nbsp; &nbsp;tvarsized; &nbsp; &nbsp; &nbsp; &nbsp;// for speed: tail type is varsized?</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oid &nbsp; &nbsp;talign; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // alignment OID for head.</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Tail storage</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp;tloc; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // byte-offset in BUN for tail elements</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Heap &nbsp; *theap; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // heap for varsized tail values</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Hash &nbsp; *thash; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // linear chained hash table on tail</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Imprints *timprints; &nbsp; &nbsp; // column imprints index on tail</font></div><div><font size="2"   >&nbsp;* &nbsp;} BAT;</font></div><div><font size="2"   >&nbsp;* @end verbatim</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The internal structure of the @strong{BAT} record is in fact much</font></div><div><font size="2"   >&nbsp;* more complex, but GDK programmers should refrain of making use of</font></div><div><font size="2"   >&nbsp;* that.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The reason for this complex structure is to allow for a BAT to</font></div><div><font size="2"   >&nbsp;* exist in two incarnations at the time: the @emph{normal view} and</font></div><div><font size="2"   >&nbsp;* the @emph{reversed view}. Each bat @emph{b} has a</font></div><div><font size="2"   >&nbsp;* BATmirror(@emph{b}) which has the negative @strong{cacheid} of b in</font></div><div><font size="2"   >&nbsp;* the BBP.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Since we don't want to pay cost to keep both views in line with</font></div><div><font size="2"   >&nbsp;* each other under BAT updates, we work with shared pieces of memory</font></div><div><font size="2"   >&nbsp;* between the two views. An update to one will thus automatically</font></div><div><font size="2"   >&nbsp;* update the other. &nbsp;In the same line, we allow @strong{synchronized</font></div></div><div><div><font size="2"   >&nbsp;* BATs} (BATs with identical head columns, and marked as such in the</font></div><div><font size="2"   >&nbsp;* @strong{BAT Alignment} interface) now to be clustered horizontally.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp;@c image{http://monetdb.cwi.nl/projects/monetdb-mk/imgs/bat2,,,,feps}</font></div><div><font size="2"   >&nbsp;*/</font></div></div><p></p></pre></div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="column based storages logical address for variable length type - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>