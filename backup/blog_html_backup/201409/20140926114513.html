<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">query slow in function & loop</h2>
	<h5 id="">2014-09-26 11:45:13&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402014826113946641/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>一位朋友对proxy返回慢的疑惑. 数据节点5000万记录, 直接查询需要8秒.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >db3=&gt; explain analyze select * from user_infosingle;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >---------------</font></div><div><font size="2"   >&nbsp;Seq Scan on user_infosingle &nbsp;(cost=0.00..1461539.00 rows=50000000 width=126) (actual time=0.029..6182.157 rows=500</font></div><div><font size="2"   >00000 loops=1)</font></div><div><font size="2"   >&nbsp;Total runtime: 8216.026 ms</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>在代理节点查询2000万条需要72秒, (当然如果走索引的话因为扫描问题会变慢, 就看是不是索引了)</div><div>这里除了走索引会变慢, 另外还有慢的原因是函数自身的开销.(即使是全表, 在函数中返回也比直接查询慢)</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >db3=&gt; \c proxy proxy</font></div><div><font size="2"   >You are now connected to database "proxy" as user "proxy".</font></div><div><font size="2"   >proxy=&gt; explain analyze select * from digoal.dquery('select * from user_info where userid &gt;=29000000 and userid &lt;=49000000') as (userid int,engname text,cnname text,occupation text,birthday date,signname text,email text,qq numeric,crt_time timestamp without time zone,mod_time timestamp without time zone);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;Function Scan on dquery &nbsp;(cost=0.25..10.25 rows=1000 width=216) (actual time=67987.856..71008.713 rows=20000001 lo</font></div><div><font size="2"   >ops=1)</font></div><div><font size="2"   >&nbsp;Total runtime: 72601.779 ms</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>他的场景</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >数据节点：create or replace function digoal.dquery(q text)</font></div><div><font size="2"   >returns setof record as $x$</font></div><div><font size="2"   >declare &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; ret record; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >begin &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; for ret in execute q loop &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return next ret; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; end loop; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; return; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >end; &nbsp; &nbsp;</font></div><div><font size="2"   >$x$ language plpgsql;</font></div><div><font size="2"   >create or replace function digoal.ddlExec(query text)&nbsp;</font></div><div><font size="2"   >returns integer as $x$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; &nbsp;ret integer;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >execute query;</font></div><div><font size="2"   >&nbsp; &nbsp;return 1;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$x$ language plpgsql;</font></div><div><font size="2"   >create or replace function digoal.dmlExec(query text) returns integer as $x$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; &nbsp;ret integer;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   ><span>	</span>execute query;</font></div><div><font size="2"   >&nbsp; &nbsp;return 1;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$x$ language plpgsql;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >代理节点：\c proxy postgres&nbsp;</font></div><div><font size="2"   >CREATE OR REPLACE FUNCTION digoal.dquery(query text) RETURNS setof</font></div><div><font size="2"   >record AS $$</font></div><div><font size="2"   >CLUSTER 'cluster_srv1';</font></div><div><font size="2"   >RUN ON ALL;</font></div><div><font size="2"   >$$ LANGUAGE plproxy;</font></div><div><font size="2"   >CREATE OR REPLACE FUNCTION digoal.ddlexec(query text) RETURNS setof integer</font></div><div><font size="2"   >AS $$</font></div><div><font size="2"   >CLUSTER 'cluster_srv1';</font></div><div><font size="2"   >RUN ON ALL;</font></div><div><font size="2"   >$$ LANGUAGE plproxy;</font></div><div><font size="2"   >CREATE OR REPLACE FUNCTION digoal.dmlexec(query text) RETURNS setof integer</font></div><div><font size="2"   >AS $$</font></div><div><font size="2"   >CLUSTER 'cluster_srv1';</font></div><div><font size="2"   >RUN ON ANY;</font></div><div><font size="2"   >$$ LANGUAGE plproxy;</font></div><p></p></pre></div><div>为了说明这个慢的问题, 我创建2个函数, 一个是直接返回QUERY, 一个是在循环中返回.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create or replace function f1(q text) returns setof record as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; return query execute q;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# create or replace function f2(q text) returns setof record as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; res record;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; for res in execute q loop&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; return next res;&nbsp;</font></div><div><font size="2"   >&nbsp; end loop;&nbsp;</font></div><div><font size="2"   >&nbsp; return;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div></div><p></p></pre></div><div>直接查询1000万条记录, 返回需要2.3秒</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain analyze select generate_series(1,10000000);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Result &nbsp;(cost=0.00..5.01 rows=1000 width=0) (actual time=0.010..1599.016 rows=10000000 loops=1)</font></div><div><font size="2"   >&nbsp;Total runtime: 2373.759 ms</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>通过f1函数查询需要6.2秒</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain analyze select * from f1('select generate_series(1,10000000)') as t(id int);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >--------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Function Scan on f1 t &nbsp;(cost=0.25..10.25 rows=1000 width=4) (actual time=3567.414..5397.201 rows=10000000 loops=1)</font></div><div><font size="2"   >&nbsp;Total runtime: 6218.298 ms</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>通过f2查询需要8.4秒.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain analyze select * from f2('select generate_series(1,10000000)') as t(id int);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >--------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Function Scan on f2 t &nbsp;(cost=0.25..10.25 rows=1000 width=4) (actual time=5807.632..7639.567 rows=10000000 loops=1)</font></div><div><font size="2"   >&nbsp;Total runtime: 8447.196 ms</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >另外, proxy还需要经过一层网络传输, 也会拖慢查询, 包括dblink或fdw的开销. (更大的返回数据量甚至可能导致内存溢出)</span></div><div>并且dblink的开销(在大数据量返回的情况下)远超想象.</div><div><br></div><div>我们来看看使用dblink后带来的额外开销, 10000万的查询变成了17秒 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create extension dblink;</font></div><div><font size="2"   >CREATE EXTENSION</font></div><div><font size="2"   >postgres=# SELECT dblink_connect('myconn', 'dbname=postgres');</font></div><div><font size="2"   >&nbsp;dblink_connect&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp;OK</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >postgres=# explain analyze SELECT * FROM dblink('myconn','select * from generate_series(1,10000000)') AS t(a int);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Function Scan on dblink t &nbsp;(cost=0.00..10.00 rows=1000 width=4) (actual time=14572.580..16627.163 rows=10000000 loops=1)</font></div><div><font size="2"   >&nbsp;Total runtime: 17449.628 ms</font></div><div><font size="2"   >(2 rows)</font></div></div><p></p></pre></div><div>透过dblink执行远程函数f1和f2</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# explain analyze SELECT * FROM dblink('myconn','select * from f1($$select * from generate_series(1,10000000)$$) as t(a int)') AS t(a int);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Function Scan on dblink t &nbsp;(cost=0.00..10.00 rows=1000 width=4) (actual time=19037.371..21097.883 rows=10000000 loops=1)</font></div><div><font size="2"   >&nbsp;Total runtime: 21922.628 ms</font></div><div><font size="2"   >(2 rows)</font></div></div><div><div><font size="2"   >postgres=# explain analyze SELECT * FROM dblink('myconn','select * from f2($$select * from generate_series(1,10000000)$$) as t(a int)') AS t(a int);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Function Scan on dblink t &nbsp;(cost=0.00..10.00 rows=1000 width=4) (actual time=20984.230..23028.411 rows=10000000 loops=1)</font></div><div><font size="2"   >&nbsp;Total runtime: 23847.770 ms</font></div><div><font size="2"   >(2 rows)</font></div></div><p></p></pre></div><div>dblink是在接收到所有结果集后, 才开始返回数据的.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# \set FETCH_COUNT 1</font></div><div><font size="2"   >postgres=# SELECT * FROM dblink('myconn','select * from f2($$select * from generate_series(1,10000000)$$) as t(a int)') AS t(a int);</font></div></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >.... 这里需要等待所有结果返回, 23秒后才开始返回第一条记录.</span></div></div><div><br></div><div>小数据量可能没有什么感觉</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain analyze SELECT * FROM dblink('myconn','select * from generate_series(1,10)') AS t(a int);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Function Scan on dblink t &nbsp;(cost=0.00..10.00 rows=1000 width=4) (actual time=0.371..0.373 rows=10 loops=1)</font></div><div><font size="2"   >&nbsp;Total runtime: 0.392 ms</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>要让dblink使用游标, 使用dblink_open和dblink_fetch接口.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >dblink_open -- opens a cursor in a remote database</font></div><div><font size="2"   >dblink_fetch -- returns rows from an open cursor in a remote database</font></div><p></p></pre></div><wbr><div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><div><font size="2"   >postgres=# SELECT dblink_connect('myconn', 'hostaddr=127.0.0.1 port=1921 dbname=postgres user=postgres');</font></div><div><font size="2"   >&nbsp;dblink_connect&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp;OK</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >postgres=# SELECT * FROM dblink_open('myconn','cur1', 'select * from t1') ;</font></div><div><font size="2"   >&nbsp;dblink_open&nbsp;</font></div><div><font size="2"   >-------------</font></div><div><font size="2"   >&nbsp;OK</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >postgres=# SELECT * FROM dblink_fetch('myconn','cur1',1) as t(id int);</font></div><div><font size="2"   >&nbsp; id &nbsp;&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;10909</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# SELECT * FROM dblink_fetch('myconn','cur1',1) as t(id int);</font></div><div><font size="2"   >&nbsp; id &nbsp;&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;10910</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# SELECT * FROM dblink_fetch('myconn','cur1',1) as t(id int);</font></div><div><font size="2"   >&nbsp; id &nbsp;&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;10911</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div><br></div><div><a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="query slow in function  loop - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a><br></div></div>
	</div>
</div>
</body>
</html>