PostgreSQL research

Don't Let your Query scan too many child tables

2011-11-15 17:09:12   查看原文>>

今天在给项目组实现一个PLPROXY的需求，建立了2级子表。
父表
table
第一级子表
table_256_0
第二级子表
table_256_0_201111 check (create_time >='?' and <'?')
...
table_256_0_201212 check (create_time >='?' and <'?')
...
table_256_255
第二级子表
table_256_255_201111 check (create_time >='?' and <'?')
...
table_256_255_201212 check (create_time >='?' and <'?')

第一级子表继承table, 根据userid的HASH取模分区。
第二级子表继承第一级子表, 根据create_time按照时间分区。
因此查询条件如果带上userid=?和日期的话可以直接落到一个表，查询非常快。
查询条件如果没有日期也没有userid那必须遍历所有子表。子表越多，速度越慢。
例如:
遍历897个表, 按照每个表的PK查询。
大概需要耗费150ms 。
而落到单表上仅仅需要0.几毫秒。

来看个例子 : 
digoal=> select * from tbl_amc_mpbean_tradetail where order_id='a';
 ----------+-------------------------+--------+----------+----------+---------+--------+------------+-------------+--------+---------
+---------------+---------+--------------+-------------------+----------------------------+--------
 abc      | 20111115155055000000100 |      2 | a        | a        | a       | a      | a          | a           | a      | a       
| a             | a       | a            | a                 | 2011-11-15 15:50:55.027624 | a
(1 row)

Time: 155.607 ms
digoal=> select * from tbl_amc_mpbean_tradetail_64_41 where order_id='a';
 ----------+-------------------------+--------+----------+----------+---------+--------+------------+-------------+--------+---------
+---------------+---------+--------------+-------------------+----------------------------+--------
 abc      | 20111115155055000000100 |      2 | a        | a        | a       | a      | a          | a           | a      | a       
| a             | a       | a            | a                 | 2011-11-15 15:50:55.027624 | a
(1 row)

Time: 1.815 ms
digoal=> select * from tbl_amc_mpbean_tradetail_64_41_201111 where order_id='a';
 ----------+-------------------------+--------+----------+----------+---------+--------+------------+-------------+--------+---------
+---------------+---------+--------------+-------------------+----------------------------+--------
 abc      | 20111115155055000000100 |      2 | a        | a        | a       | a      | a          | a           | a      | a       
| a             | a       | a            | a                 | 2011-11-15 15:50:55.027624 | a
(1 row)

Time: 0.396 ms
digoal=> select 155.607/1.815;
      ?column?       
---------------------
 85.7338842975206612
(1 row)

Time: 0.210 ms
接近表的个数的比例64 .

比较容易接受的解决办法：
1. 分区分布到多个数据库, 减少单库的子表个数, 同时使用并发查询有效的提高了整体响应速度。
2. 在时间字段上创建约束，查询时带上时间条件，规避查询包含未来日期的子表。










