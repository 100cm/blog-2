PostgreSQL research

PostgreSQL SQL inject by exec_simple_query@src/backend/tcop/postgres.c

2014-03-14 17:35:22   查看原文>>

SQL注入大家可以参考以下几篇文章, 本文不做介绍,
1. http://blog.163.com/digoal@126/blog/static/163877040201342184212205/
2. http://blog.163.com/digoal@126/blog/static/1638770402011101705842393
3. http://blog.163.com/digoal@126/blog/static/1638770402012910234402/
本文要说的是从数据库角度介绍一下带来SQL注入的exec_simple_query函数, 以及告诫各位不要使用这个接口, 改为使用prepared statement. 如果是libpq的话, 那么就是告诫大家不要使用PQsendQuery或PQexec, 改为使用绑定变量的接口PQsendPrepare或PQexecParams等(区分同步和异步模式). 包括SPI接口的使用也要注意. 目前大部分第三方驱动都是通过封
装libpq的接口函数来实现的. 所以本文基本上适合所有的驱动.
下面来介绍一下使用exec_simple_query接口为什么会被注入.
exec_simple_query字符串中可以提交多个SQL, 也没有参数以及不检查参数类型, 也就是SQL注入的惯用手法.
例如 : 

select name,pwd from user where id=123; 
这句注入完全可以变成
select name,pwd from user where id= 123 or 1=1;



顺便提一下, 在pgbouncer这个连接池中可以通过配置关闭PQexec接口的使用 : 

==== disable_pqexec ====

Disable Simple Query protocol (PQexec).  Unlike Extended Query protocol, Simple Query
allows multiple queries in one packet, which allows some classes of SQL-injection
attacks.  Disabling it can improve security.  Obviously this means only clients that
exclusively use Extended Query protocol will stay working.

Default: 0


pgbouncer开启disable_pqexec的话过滤首字符为Q的客户端请求, 也就是我们前面提到的exec_simple_query.

        /* one-packet queries */
        case 'Q':               /* Query */
                if (cf_disable_pqexec) {
                        slog_error(client, "Client used 'Q' packet type.");
                        disconnect_client(client, true, "PQexec disallowed");
                        return false;
                }



我们来看看这个函数 : 
exec_simple_query@src/backend/tcop/postgres.c

/*
 * exec_simple_query
 *
 * Execute a "simple Query" protocol message.
 */
static void
exec_simple_query(const char *query_string)
{
        CommandDest dest = whereToSendOutput;
        MemoryContext oldcontext;
        List       *parsetree_list;
        ListCell   *parsetree_item;
        bool            save_log_statement_stats = log_statement_stats;
        bool            was_logged = false;
        bool            isTopLevel;
        char            msec_str[32];


        /*
         * Report query to various monitoring facilities.
         */
        debug_query_string = query_string;

        pgstat_report_activity(STATE_RUNNING, query_string);

        TRACE_POSTGRESQL_QUERY_START(query_string);

        /*
         * We use save_log_statement_stats so ShowUsage doesn't report incorrect
         * results because ResetUsage wasn't called.
         */
        if (save_log_statement_stats)
                ResetUsage();

        /*
         * Start up a transaction command.      All queries generated by the
         * query_string will be in this same command block, *unless* we find a
         * BEGIN/COMMIT/ABORT statement; we have to force a new xact command after
...
略


我们可以修改这个函数的末尾部分, 把这个函数的调用打印出来, 从而追述到对应的应用程序, 责令修改填补漏洞.

        /*
         * Emit duration logging if appropriate.
         */
        switch (check_log_duration(msec_str, was_logged))
        {
                case 1:
                        ereport(LOG,
                                        (errmsg("duration: %s ms", msec_str),
                                         errhidestmt(true)));
                        break;
                case 2:
                        ereport(LOG,
                                        (errmsg("duration: %s ms  statement: %s",
                                                        msec_str, query_string),
                                         errhidestmt(true),
                                         errdetail_execute(parsetree_list)));
                        break;
// 添加如下
                default:
                        ereport(LOG,
                                        (errmsg("duration: %s ms  statement: %s",
                                                        msec_str, query_string),
                                         errhidestmt(true),
                                         errdetail_execute(parsetree_list)));
                        break;
        }


重新编译安装.

gmake
gmake install


重启数据库

pg_ctl restart -m fast


那么此时即使log_statemnet=none, 调用了exec_simple_query函数也会记录到CSVLOG.
如下 : 

pg93@db-172-16-3-150-> psql
psql (9.3.3)
Type "help" for help.
digoal=# show log_statement;
 log_statement 
---------------
 ddl
(1 row)
digoal=# \dt


输出, 调用exec_simple_query被记录到csvlog : 

? ms  statement: show log_statement;",,,,,,,,"exec_simple_query, postgres.c:1132","psql"
2014-03-14 09:03:04.311 UTC,"postgres","digoal",1944,"[local]",5322c5b5.798,4,"SELECT",2014-03-14 09:02:45 UTC,2/0,0,LOG,00000,"duration: ??
? ms  statement: SELECT n.nspname as ""Schema"",
  c.relname as ""Name"",
  CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'm' THEN 'materialized view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 's' THEN 'special' WHEN 'f' THEN 'foreign table' END as ""Type"",
  pg_catalog.pg_get_userbyid(c.relowner) as ""Owner""
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind IN ('r','')
      AND n.nspname <> 'pg_catalog'
      AND n.nspname <> 'information_schema'
      AND n.nspname !~ '^pg_toast'
  AND pg_catalog.pg_table_is_visible(c.oid)
ORDER BY 1,2;",,,,,,,,"exec_simple_query, postgres.c:1132","psql"
2014-03-14 09:03:59.167 UTC,"postgres","digoal",1944,"[local]",5322c5b5.798,5,"SELECT",2014-03-14 09:02:45 UTC,2/0,0,LOG,00000,"duration: ??
? ms  statement: select 1;",,,,,,,,"exec_simple_query, postgres.c:1132","psql"


显然psql调用的是这个函数, 因此被记录下来.
我们使用pgbench, 选择-M prepared或者extended都不会被记录, 因为没有调用这个函数.
以下是pgbench.c 中三种模式调用的接口.

                if (querymode == QUERY_SIMPLE)
                {
                        char       *sql;

                        sql = pg_strdup(command->argv[0]);
                        sql = assignVariables(st, sql);

                        if (debug)
                                fprintf(stderr, "client %d sending %s\n", st->id, sql);
                        r = PQsendQuery(st->con, sql);
                        free(sql);
                }
                else if (querymode == QUERY_EXTENDED)
                {
                        const char *sql = command->argv[0];
                        const char *params[MAX_ARGS];

                        getQueryParams(st, command, params);

                        if (debug)
                                fprintf(stderr, "client %d sending %s\n", st->id, sql);
                        r = PQsendQueryParams(st->con, sql, command->argc - 1,
                                                                  NULL, params, NULL, NULL, 0);
                }
                else if (querymode == QUERY_PREPARED)
                {
                        char            name[MAX_PREPARE_NAME];
                        const char *params[MAX_ARGS];

                        if (!st->prepared[st->use_file])
                        {
                                int                     j;

                                for (j = 0; commands[j] != NULL; j++)
                                {
                                        PGresult   *res;
                                        char            name[MAX_PREPARE_NAME];
                                        if (commands[j]->type != SQL_COMMAND)
                                                continue;
                                        preparedStatementName(name, st->use_file, j);
                                        res = PQprepare(st->con, name,
                                                  commands[j]->argv[0], commands[j]->argc - 1, NULL);
                                        if (PQresultStatus(res) != PGRES_COMMAND_OK)
                                                fprintf(stderr, "%s", PQerrorMessage(st->con));
                                        PQclear(res);
                                }
                                st->prepared[st->use_file] = true;
                        }

                        getQueryParams(st, command, params);
                        preparedStatementName(name, st->use_file, st->state);

                        if (debug)
                                fprintf(stderr, "client %d sending %s\n", st->id, name);
                        r = PQsendQueryPrepared(st->con, name, command->argc - 1,
                                                                        params, NULL, NULL, 0);
                }


backend process接收客户端消息时, 如何解析客户端使用的什么查询接口?
这部分的定义在PostgresMain@postgres.c函数中, 如下, 第一个字符为Q, 说明是simple query, 也就是我们提到的存在SQL注入风险的调用. pgbouncer正是通过这个来判断是否为简单调用的.

                switch (firstchar)
                {
                        case 'Q':                       /* simple query */
                                {
                                        const char *query_string;

                                        /* Set statement_timestamp() */
                                        SetCurrentStatementStartTimestamp();

                                        query_string = pq_getmsgstring(&input_message);
                                        pq_getmsgend(&input_message);

                                        if (am_walsender)
                                                exec_replication_command(query_string);
                                        else
                                                exec_simple_query(query_string);

                                        send_ready_for_query = true;
                                }
                                break;

                        case 'P':                       /* parse */
                                {
                                        const char *stmt_name;
                                        const char *query_string;
                                        int                     numParams;
                                        Oid                *paramTypes = NULL;

                                        forbidden_in_wal_sender(firstchar);

                                        /* Set statement_timestamp() */
                                        SetCurrentStatementStartTimestamp();

                                        stmt_name = pq_getmsgstring(&input_message);
                                        query_string = pq_getmsgstring(&input_message);
                                        numParams = pq_getmsgint(&input_message, 2);
                                        if (numParams > 0)
                                        {
                                                int                     i;

                                                paramTypes = (Oid *) palloc(numParams * sizeof(Oid));
                                                for (i = 0; i < numParams; i++)
                                                        paramTypes[i] = pq_getmsgint(&input_message, 4);
                                        }
                                        pq_getmsgend(&input_message);

                                        exec_parse_message(query_string, stmt_name,
                                                                           paramTypes, numParams);
                                }
                                break;

                        case 'B':                       /* bind */
                                forbidden_in_wal_sender(firstchar);

                                /* Set statement_timestamp() */
                                SetCurrentStatementStartTimestamp();

                                /*
                                 * this message is complex enough that it seems best to put
                                 * the field extraction out-of-line
                                 */
                                exec_bind_message(&input_message);
                                break;

                        case 'E':                       /* execute */
                                {
                                        const char *portal_name;
                                        int                     max_rows;

                                        forbidden_in_wal_sender(firstchar);

                                        /* Set statement_timestamp() */
                                        SetCurrentStatementStartTimestamp();

                                        portal_name = pq_getmsgstring(&input_message);
                                        max_rows = pq_getmsgint(&input_message, 4);
                                        pq_getmsgend(&input_message);

                                        exec_execute_message(portal_name, max_rows);
                                }
                                break;

                        case 'F':                       /* fastpath function call */
                                forbidden_in_wal_sender(firstchar);

                                /* Set statement_timestamp() */
                                SetCurrentStatementStartTimestamp();

                                /* Report query to various monitoring facilities. */
                                pgstat_report_activity(STATE_FASTPATH, NULL);
                                set_ps_display("<FASTPATH>", false);

                                /* start an xact for this function invocation */
                                start_xact_command();

                                /*
                                 * Note: we may at this point be inside an aborted
                                 * transaction.  We can't throw error for that until we've
                                 * finished reading the function-call message, so
                                 * HandleFunctionRequest() must check for it after doing so.
                                 * Be careful not to do anything that assumes we're inside a
                                 * valid transaction here.
                                 */

                                /* switch back to message context */
                                MemoryContextSwitchTo(MessageContext);

                                if (HandleFunctionRequest(&input_message) == EOF)
                                {
                                        /* lost frontend connection during F message input */

                                        /*
                                         * Reset whereToSendOutput to prevent ereport from
                                         * attempting to send any more messages to client.
                                         */
                                        if (whereToSendOutput == DestRemote)
                                                whereToSendOutput = DestNone;

                                        proc_exit(0);
                                }

                                /* commit the function-invocation transaction */
                                finish_xact_command();

                                send_ready_for_query = true;
                                break;

                        case 'C':                       /* close */
                                {
                                        int                     close_type;
                                        const char *close_target;

                                        forbidden_in_wal_sender(firstchar);

                                        close_type = pq_getmsgbyte(&input_message);
                                        close_target = pq_getmsgstring(&input_message);
                                        pq_getmsgend(&input_message);

                                        switch (close_type)
                                        {
                                                case 'S':
                                                        if (close_target[0] != '\0')
                                                                DropPreparedStatement(close_target, false);
                                                        else
                                                        {
                                                                /* special-case the unnamed statement */
                                                                drop_unnamed_stmt();
                                                        }
                                                        break;
                                                case 'P':
                                                        {
                                                                Portal          portal;

                                                                portal = GetPortalByName(close_target);
                                                                if (PortalIsValid(portal))
                                                                        PortalDrop(portal, false);
                                                        }
                                                        break;
                                                default:
                                                        ereport(ERROR,
                                                                        (errcode(ERRCODE_PROTOCOL_VIOLATION),
                                                                   errmsg("invalid CLOSE message subtype %d",
                                                                                  close_type)));
                                                        break;
                                        }

                                        if (whereToSendOutput == DestRemote)
                                                pq_putemptymessage('3');                /* CloseComplete */
                                }
                                break;

                        case 'D':                       /* describe */
                                {
                                        int                     describe_type;
                                        const char *describe_target;

                                        forbidden_in_wal_sender(firstchar);

                                        /* Set statement_timestamp() (needed for xact) */
                                        SetCurrentStatementStartTimestamp();

                                        describe_type = pq_getmsgbyte(&input_message);
                                        describe_target = pq_getmsgstring(&input_message);
                                        pq_getmsgend(&input_message);

                                        switch (describe_type)
                                        {
                                                case 'S':
                                                        exec_describe_statement_message(describe_target);
                                                        break;
                                                case 'P':
                                                        exec_describe_portal_message(describe_target);
                                                        break;
                                                default:
                                                        ereport(ERROR,
                                                                        (errcode(ERRCODE_PROTOCOL_VIOLATION),
                                                                errmsg("invalid DESCRIBE message subtype %d",
                                                                           describe_type)));
                                                        break;
                                        }
                                }
                                break;

                        case 'H':                       /* flush */
                                pq_getmsgend(&input_message);
                                if (whereToSendOutput == DestRemote)
                                        pq_flush();
                                break;

                        case 'S':                       /* sync */
                                pq_getmsgend(&input_message);
                                finish_xact_command();
                                send_ready_for_query = true;
                                break;

                                /*
                                 * 'X' means that the frontend is closing down the socket. EOF
                                 * means unexpected loss of frontend connection. Either way,
                                 * perform normal shutdown.
                                 */
                        case 'X':
                        case EOF:

                                /*
                                 * Reset whereToSendOutput to prevent ereport from attempting
                                 * to send any more messages to client.
                                 */
                                if (whereToSendOutput == DestRemote)
                                        whereToSendOutput = DestNone;

                                /*
                                 * NOTE: if you are tempted to add more code here, DON'T!
                                 * Whatever you had in mind to do should be set up as an
                                 * on_proc_exit or on_shmem_exit callback, instead. Otherwise
                                 * it will fail to be called during other backend-shutdown
                                 * scenarios.
                                 */
                                proc_exit(0);

                        case 'd':                       /* copy data */
                        case 'c':                       /* copy done */
                        case 'f':                       /* copy fail */

                                /*
                                 * Accept but ignore these messages, per protocol spec; we
                                 * probably got here because a COPY failed, and the frontend
                                 * is still sending data.
                                 */
                                break;

                        default:
                                ereport(FATAL,
                                                (errcode(ERRCODE_PROTOCOL_VIOLATION),
                                                 errmsg("invalid frontend message type %d",
                                                                firstchar)));
                }
        }                                                       /* end of input-reading loop */
}



[参考]
1. src/backend/tcop/postgres.c
2. http://www.postgresql.org/docs/9.3/static/libpq-async.html
3. contrib/pgbench/pgbench.c
4. http://blog.163.com/digoal@126/blog/static/163877040201342184212205/
5. http://blog.163.com/digoal@126/blog/static/1638770402011101705842393
6. http://blog.163.com/digoal@126/blog/static/1638770402012910234402/
7. http://www.postgresql.org/docs/9.3/static/spi-spi-execute.html

评论

瑞瑞 - 2014-03-17 10:17:47

怒踩！

