PostgreSQL research

PostgreSQL Why psql -c "multi sql" only return the last sql result. but psql -f return all sql result

2014-03-26 17:48:20   查看原文>>

在使用psql时, 有-c和-f两种方式在命令行执行SQL.

man psql
       -f filename, --file=filename
           Use the file filename as the source of commands instead of reading commands interactively. After the file
           is processed, psql terminates. This is in many ways equivalent to the meta-command \i.

           If filename is - (hyphen), then standard input is read.

           Using this option is subtly different from writing psql < filename. In general, both will do what you
           expect, but using -f enables some nice features such as error messages with line numbers. There is also a
           slight chance that using this option will reduce the start-up overhead. On the other hand, the variant
           using the shell's input redirection is (in theory) guaranteed to yield exactly the same output you would
           have received had you entered everything by hand.
       -c command, --command=command
           Specifies that psql is to execute one command string, command, and then exit. This is useful in shell
           scripts. Start-up files (psqlrc and ~/.psqlrc) are ignored with this option.

           command must be either a command string that is completely parsable by the server (i.e., it contains no
           psql-specific features), or a single backslash command. Thus you cannot mix SQL and psql meta-commands with
           this option. To achieve that, you could pipe the string into psql, for example: echo '\x \\ SELECT * FROM
           foo;' | psql. (\\ is the separator meta-command.)

           If the command string contains multiple SQL commands, they are processed in a single transaction, unless
           there are explicit BEGIN/COMMIT commands included in the string to divide it into multiple transactions.
           This is different from the behavior when the same string is fed to psql's standard input. Also, only the
           result of the last SQL command is returned.

           Because of these legacy behaviors, putting more than one command in the -c string often has unexpected
           results. It's better to feed multiple commands to psql's standard input, either using echo as illustrated
           above, or via a shell here-document, for example:

               psql <<EOF
               \x
               SELECT * FROM foo;
               EOF


但是实际使用时, 有一定的区别, 例如 : 

pg93@db-172-16-3-150-> psql -c "select 1;select 2;"
 ?column? 
----------
        2
(1 row)


但是, 使用psql -f则可以看到两个返回. 如下 : 

pg93@db-172-16-3-150-> echo "select 1;select 2;"|psql -f -
 ?column? 
----------
        1
(1 row)

 ?column? 
----------
        2
(1 row)


注意, 两种方式都会执行这两个查询, 只是-c只返回最后一条SQL的结果.

原因是psql -c直接把字符串提交给SendQuery.
psql -f 调用的是MainLoop, 分号将隔开这两句查询, 分两次递交给SendQuery, 看如下部分的解释.
SendQuery最后通过PQexecFinish把查询结果返回给客户端, 因为PQexecFinish这个函数只保存最后一个查询的结果, 所以使用psql -c我们只能看到最后一次调用的结果.

[参考]
1. psql 代码 : 
-f 对应代码 : 

src/bin/psql/startup.c
process_file(options.action_string, options.single_txn, false)

src/bin/psql/command.c
process_file
          MainLoop(fd)



-c 对应代码 : 

src/bin/psql/startup.c
SendQuery(options.action_string)



2. psql -f通过MainLoop完成调用.
MainLoop中遇到分号则将当前的query_buf递交给SendQuery, 所以能返回多个结果.
src/bin/psql/mainloop.c

MainLoop(fd)

                        /*
                         * Send command if semicolon found, or if end of line and we're in
                         * single-line mode.
                         */
                        if (scan_result == PSCAN_SEMICOLON ||
                                (scan_result == PSCAN_EOL && pset.singleline))
                                /* execute query */
                                success = SendQuery(query_buf->data);



3. psql -c 直接使用SendQuery.
src/bin/psql/common.c

/*
 * SendQuery: send the query string to the backend
 * (and print out results)
 *
 * Note: This is the "front door" way to send a query. That is, use it to
 * send queries actually entered by the user. These queries will be subject to
 * single step mode.
 * To send "back door" queries (generated by slash commands, etc.) in a
 * controlled way, use PSQLexec().
 *
 * Returns true if the query executed successfully, false otherwise.
 */
bool
SendQuery(const char *query)
{
...
results = PQexec(pset.db, query);
...




4. 
src/interfaces/libpq/libpq-fe.h:
extern PGresult *PQexec(PGconn *conn, const char *query);

5. psql用到的简单SQL调用. 由于历史原因, PQexecFinish只返回最后一个SQL的结果, 但是对错误则做合并处理.
src/interfaces/libpq/fe-exec.c

/*
 * PQexec
 *        send a query to the backend and package up the result in a PGresult
 *
 * If the query was not even sent, return NULL; conn->errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */
PGresult *
PQexec(PGconn *conn, const char *query)
{
        if (!PQexecStart(conn))
                return NULL;
        if (!PQsendQuery(conn, query))
                return NULL;
        return PQexecFinish(conn);
}

/*
 * PQsendQuery
 *       Submit a query, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *                      0 if error (conn->errorMessage is set)
 */
int
PQsendQuery(PGconn *conn, const char *query)
{
        if (!PQsendQueryStart(conn))
                return 0;

        /* check the argument */
        if (!query)
        {
                printfPQExpBuffer(&conn->errorMessage,
                                                libpq_gettext("command string is a null pointer\n"));
                return 0;
        }

        /* construct the outgoing Query message */
        if (pqPutMsgStart('Q', false, conn) < 0 ||
                pqPuts(query, conn) < 0 ||
                pqPutMsgEnd(conn) < 0)
        {
                pqHandleSendFailure(conn);
                return 0;
        }

        /* remember we are using simple query protocol */
        conn->queryclass = PGQUERY_SIMPLE;

        /* and remember the query text too, if possible */
        /* if insufficient memory, last_query just winds up NULL */
        if (conn->last_query)
                free(conn->last_query);
        conn->last_query = strdup(query);
        /*
         * Give the data a push.  In nonblock mode, don't complain if we're unable
         * to send it all; PQgetResult() will do any additional flushing needed.
         */
        if (pqFlush(conn) < 0)
        {
                pqHandleSendFailure(conn);
                return 0;
        }

        /* OK, it's launched! */
        conn->asyncStatus = PGASYNC_BUSY;
        return 1;
}


/*
 * Common code for PQexec and sibling routines: wait for command result
 */
static PGresult *
PQexecFinish(PGconn *conn)
{
        PGresult   *result;
        PGresult   *lastResult;

        /*
         * For backwards compatibility, return the last result if there are more
         * than one --- but merge error messages if we get more than one error
         * result.
         *
         * We have to stop if we see copy in/out/both, however. We will resume
         * parsing after application performs the data transfer.
         *
         * Also stop if the connection is lost (else we'll loop infinitely).
         */
        lastResult = NULL;
        while ((result = PQgetResult(conn)) != NULL)
        {
                if (lastResult)
                {
                        if (lastResult->resultStatus == PGRES_FATAL_ERROR &&
                                result->resultStatus == PGRES_FATAL_ERROR)
                        {
                                pqCatenateResultError(lastResult, result->errMsg);
                                PQclear(result);
                                result = lastResult;

                                /*
                                 * Make sure PQerrorMessage agrees with concatenated result
                                 */
                                resetPQExpBuffer(&conn->errorMessage);
                                appendPQExpBufferStr(&conn->errorMessage, result->errMsg);
                        }
                        else
                                PQclear(lastResult);
                }
                lastResult = result;
                if (result->resultStatus == PGRES_COPY_IN ||
                        result->resultStatus == PGRES_COPY_OUT ||
                        result->resultStatus == PGRES_COPY_BOTH ||
                        conn->status == CONNECTION_BAD)
                        break;
        }

        return lastResult;
}



6. sql返回结果数据结构.
src/interfaces/libpq/libpq-int.h

struct pg_result
{
        int                     ntups;
        int                     numAttributes;
        PGresAttDesc *attDescs;
        PGresAttValue **tuples;         /* each PGresTuple is an array of
                                                                 * PGresAttValue's */
        int                     tupArrSize;             /* allocated size of tuples array */
        int                     numParameters;
        PGresParamDesc *paramDescs;
        ExecStatusType resultStatus;
        char            cmdStatus[CMDSTATUS_LEN];               /* cmd status from the query */
        int                     binary;                 /* binary tuple values if binary == 1,
                                                                 * otherwise text */

        /*
         * These fields are copied from the originating PGconn, so that operations
         * on the PGresult don't have to reference the PGconn.
         */
        PGNoticeHooks noticeHooks;
        PGEvent    *events;
        int                     nEvents;
        int                     client_encoding;        /* encoding id */

        /*
         * Error information (all NULL if not an error result).  errMsg is the
         * "overall" error message returned by PQresultErrorMessage.  If we have
         * per-field info then it is stored in a linked list.
         */
        char       *errMsg;                     /* error message, or NULL if no error */
        PGMessageField *errFields;      /* message broken into fields */

        /* All NULL attributes in the query result point to this null string */
        char            null_field[1];

        /*
         * Space management information.  Note that attDescs and error stuff, if
         * not null, point into allocated blocks.  But tuples points to a
         * separately malloc'd block, so that we can realloc it.
         */
        PGresult_data *curBlock;        /* most recently allocated block */
        int                     curOffset;              /* start offset of free space in block */
        int                     spaceLeft;              /* number of free bytes remaining in block */
};


