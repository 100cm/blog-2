PostgreSQL research

PostgreSQL upgrade to 9.3.3 attention, upgrade standby nodes first (freeze MultiXact fix)

2014-02-25 9:18:43   查看原文>>

如果你有系统要升级到9.3.3, 并且使用了流复制或者log shipping这类的技术做了standby节点的话, 请务必先升级standby节点.
原因是9.3.3修改了xlog的个数, 用于修复multixact id wrapped的bug.
所以必须先升级standby, 使之兼容新的xlog格式后再升级master, 这样master产生的新的xlog格式才能被standby所解析.
如下 : 

  • Rework tuple freezing protocol (?lvaro Herrera, Andres Freund)

    The logic for tuple freezing was unable to handle some cases involving freezing of multixact IDs, with the practical effect that shared row-level locks might be forgotten once old enough.

    Fixing this required changing the WAL record format for tuple freezing. While this is no issue for standalone servers, when using replication it means that standby servers must be upgraded to 9.3.3 or later before their masters are. An older standby will be unable to interpret freeze records generated by a newer
    master, and will fail with a PANIC message. (In such a case, upgrading the standby should be sufficient to let it resume execution.)

PostgreSQL 9.3.3 新增autovacuum freeze multixact 的参数以及配置建议 : 

  • Create separate GUC parameters to control multixact freezing (?lvaro Herrera)

    9.3 requires multixact tuple labels to be frozen before they grow too old, in the same fashion as plain transaction ID labels have been frozen for some time. Previously, the transaction ID freezing parameters were used for multixact IDs too; but since the consumption rates of transaction IDs and multixact IDs can
    be quite different, this did not work very well. Introduce new settings vacuum_multixact_freeze_min_age, vacuum_multixact_freeze_table_age, and autovacuum_multixact_freeze_max_age to control when to freeze multixacts.

23.1.5.1. Multixacts and Wraparound

Multixact IDs are used to support row locking by multiple transactions. Since there is only limited space in a tuple header to store lock information, that information is encoded as a"multiple transaction ID", or multixact ID for short, whenever there is more than one transaction concurrently locking a row.
Information about which transaction IDs are included in any particular multixact ID is stored separately in the pg_multixact subdirectory, and only the multixact ID appears in the xmax field in the tuple header. Like transaction IDs, multixact IDs are implemented as a 32-bit counter and corresponding storage, all of
which requires careful aging management, storage cleanup, and wraparound handling.

During a VACUUM table scan, either partial or of the whole table, any multixact ID older than vacuum_multixact_freeze_min_age is replaced by a different value, which can be the zero value, a single transaction ID, or a newer multixact ID. For each table, pg_class.relminmxid stores the oldest possible multixact ID
still appearing in any tuple of that table. If this value is older than vacuum_multixact_freeze_table_age, a whole-table scan is forced. Whole-table VACUUM scans, regardless of what causes them, enable advancing the value for that table. Eventually, as all tables in all databases are scanned and their oldest multixact
values are advanced, on-disk storage for older multixacts can be removed.

As a safety device, a whole-table vacuum scan will occur for any table whose multixact-age is greater than autovacuum_multixact_freeze_max_age. This will occur even if autovacuum is nominally disabled.


multixact id 在行的头部xmax以32比特位表示, 同时在t_infomask掩码中包含一位来表示.
src/include/access/htup_details.h

typedef struct HeapTupleFields
{
        TransactionId t_xmin;           /* inserting xact ID */
        TransactionId t_xmax;           /* deleting or locking xact ID */
...
/*
 * information stored in t_infomask:
 */
#define HEAP_XMAX_IS_MULTI              0x1000  /* t_xmax is a MultiXactId */


