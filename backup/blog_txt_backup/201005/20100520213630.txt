PostgreSQL research

[From My Companion]分布散列

2010-05-20 21:36:30   查看原文>>

做了一个简单的内存数据库，存储{ID : 数据}的映射信息，首选当然hash，使用了开链hash，由于32位系统单进程可用内存有限（由于某些原因没有用64位系统），于是做成分布式的
开m个进程p[0]、p[1]……p[m - 1]，首先根据i = ID % m，将数据存储到p[i]维护的hash中，存在一个问题，反例说明：
假设m = 2，则偶数ID存到p[0]，假设p[0]的hash表大小为n，n如果为偶数的话，i = 偶数ID % n，则只有偶数位置的链表被使用，奇数位置的链表永远为空，p[1]的情况刚好相反，n为偶数时只利用到奇数位置的链表
问题：m和n需要满足什么条件以避免这个情况？
对于p[i]，其容纳的ID为km + i，相应的链表位置为(km + i) % n，可以看出这个数列是以n个数为一个循环（但不一定是最小循环节），因为((k + n)m + i) % n = (km + i + nm) % n = (km + i) % n，若某种情况下其任意连续n个数中0、1……n – 1各出现一次（换句话说，此时n为最小循环节），则得到上面问题的解
假设最小循环节大小为s，则((k + s)m + i) % n = (km + i) % n，于是得到sm % n = 0，即sm整除n，hash表的大小n是大于1的正整数
若s < n，则m和n必不互素；
上述推论逆反一下，当m和n互素时，s必定不小于n，而且肯定是n的正整数倍；
当m和n不互素的时候，存在一个大于1的公约数g，则存在s = n / g，s < n；
于是，避免hash表中空闲链表的充要条件就是m和n互素，一般的应用中，n的规则是固定的，某些hash表的n是素数，则m只要小于n就可以了，实际上几乎不可能出现m >= n的情况，大部分hash表的实现都使用素数n，不会出现这个问题，但是某些实现（比如Python虚拟机的dict）的n为2的幂，则m必须为奇数，开4个进程还不如3个好，如果改用开放定址hash，感
觉情况也不会有太大好转
具体一些，对应到数据库，如果按id分布到两个库db[0]和db[1]，每个库有两个表，则db[0]的tbl[1]和db[1]的tbl[0]都不会有数据，若每个库有三张表，则会平均分布
