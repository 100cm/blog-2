PostgreSQL research

[From 0xCCCE]linux下的网络地址绑定

2010-06-02 23:35:36   查看原文>>

系统环境：
CentOS 5.2
eth0 192.168.1.2
eth0:1 192.168.1.3
sysctl net.ipv4.ip_local_port_range = 10000 10000
如果对一个socket做绑定，会出现什么情况？Python代码为例：
sk1.bind((“”, 0)) # 绑定0.0.0.0:10000
sk2.bind((“”, 0)) # 失败，提示Address already in used
这是正常的
sk1.bind((“192.168.1.2″, 0)) # 绑定192.168.1.2:10000
sk2.bind((“192.168.1.3″, 0)) # 失败，提示Address already in used
这就有点奇怪了，192.168.1.3:10000我们没有使用，但是分配不到，再试试：
sk1.bind((“192.168.1.2″, 10000)) # 绑定192.168.1.2:10000
sk2.bind((“192.168.1.3″, 0)) # 失败，提示Address already in used
再来
sk1.bind((“192.168.1.2″, 0)) # 绑定192.168.1.2:10000
sk2.bind((“192.168.1.3″, 10000)) # 成功
再来
sk1.bind((“192.168.1.2″, 10000)) # 绑定192.168.1.2:10000
sk2.bind((“192.168.1.3″, 10000)) # 成功
结论：当端口为0，要求系统自动分配时，如果这个端口只要被某个IP在使用，则无法分配，如果指定端口号，则可以分配成功，参考了linux相关源码，没看出什么头绪，还要继续研究
上面的例子是eth0和eth0:1，如果是eth0和lo，情况也是一样，暂时没有条件测试eth0和eth1的情况
实际问题：
在一台机器向远端建立很多连接（需要说明，一般来讲这种做法从架构上讲是有问题的，但是因为某些特殊原因可能会碰到），由于tcp连接客户端需要绑定一个端口，一般采用自动分配，于是连接数受到端口数限制，6万多连接后出现无法绑定的异常
通过给eth0配置别名的办法增加IP，可以增加连接数，但是根据上面的实验，必须在程序中采用手工指定端口的办法进行绑定，关键在于绑定的时候怎么确定端口号，保证多个进程之间的端口不会冲突以及在系统资源足够的情况下保证端口绑定成功
比较好的办法是每个应用进程自己维护一份当前自己在用的{PORT : IPlist}表，以及系统所有IP的列表
1 初始化，表为空
2 建立连接的时候，查一下表，假如有某个端口对应的IP没有满，则用此端口的一个可用IP进行绑定，并将其记录到表中，如果所有端口的IPlist都是满的，则用eth0的IP和0端口进行绑定，并在表中加入绑定好的端口号和eth0的IP的映射，简单地讲，就是先让系统分配一个可用端口（同时绑定了eth0的IP，也阻止了对其他进程自动分配此端口），然后手工绑定
此端口的其他所有IP
3 连接断开的时候将此连接的IP从相应PORT的IPlist中剔除，假如此时IPlist为空，则将此PORT从表中剔除，即此进程已失去对此PORT的控制，归还系统供其他进程分配
不过，这个办法我目前还没有实践过，从理论上讲应该没问题的，可以找机会试试看

