<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.2 devel adding cascading replication support</h2>
	<h5 id="">2012-01-12 16:19:47&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012012361519/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">今天一位QQ群里的网友说PostgreSQL支持级联复制。我一开始表示怀疑，后来查到9.2的手册里确实有级联复制的说明，于是把9.2的开发版本下载过来测试了一下，以下是测试过程。<div>测试环境如图 :&nbsp;</div><div><div><img title="PostgreSQL 9.2 devel adding cascading replication support - 德哥@Digoal - The Heart,The World."  alt="PostgreSQL 9.2 devel adding cascading replication support - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img6.ph.126.net/HKEwGcnBqEhBQ-WRLVYd-A==/2837549240237320886.jpg"  ></div>主节点在杭州IDC，</div><div>第一个standby 节点在北京1号机房</div><div>第二个和第三个standby 节点在北京的2号机房。</div><div>这样做的好处是节约了跨地域复制的带宽，9.1和9.0的版本三个standby都需要直连到master节点进行复制。而9.2的standby节点可以同时启用walreceiver和walsender进程，也就是说支持向下发送流数据。</div><div>从TOP输出的结果也可以验证, 如下是其中的一个级联standby节点的top截取 :&nbsp;</div><div>说明它的下面还有一个standby, IP地址是172.16.3.150</div><div><pre class="prettyprint"  ><p>&nbsp; 349 pg92 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 1231m 2852 1612 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.38 postgres: wal receiver process &nbsp; streaming 0/8000078 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   362 pg92 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 1225m 2692 1328 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.08 postgres: wal sender process replica 172.16.3.150(26943) streaming 0/80</p></pre></div><div><br></div><div>配置方面和9.1差不多，来看看主节点的配置文件 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  ># REPLICATION</font></div><div><font size="2"  >#------------------------------------------------------------------------------</font></div><div><font size="2"  ># - Sending Server(s) -</font></div><div><font size="2"  ># Set these on the master and on any standby that will send replication data</font></div><div><font size="2"  >max_wal_senders = 64 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# max number of walsender processes</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # (change requires restart)</font></div><div><font size="2"  >wal_keep_segments = 64 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# in logfile segments, 16MB each; 0 disables</font></div><div><font size="2"  >#replication_timeout = 60s &nbsp; &nbsp; &nbsp;# in milliseconds; 0 disables</font></div><div><font size="2"  ># - Master Server -</font></div><div><font size="2"  ># These settings are ignored on a standby server</font></div><div><font size="2"  >#synchronous_standby_names = '' # standby servers that provide sync rep</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # comma-separated list of application_name</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # from standby(s); '*' = all</font></div><div><font size="2"  >#vacuum_defer_cleanup_age = 0 &nbsp; # number of xacts by which cleanup is delayed</font></div><div><font size="2"  ># - Standby Servers -</font></div><div><font size="2"  ># These settings are ignored on a master server</font></div><div><font size="2"  >hot_standby = on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# "on" allows queries during recovery</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # (change requires restart)</font></div><div><font size="2"  >#max_standby_archive_delay = 30s &nbsp; &nbsp; &nbsp; &nbsp;# max delay before canceling queries</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # when reading WAL from archive;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # -1 allows indefinite delay</font></div><div><font size="2"  >#max_standby_streaming_delay = 30s &nbsp; &nbsp; &nbsp;# max delay before canceling queries</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # when reading streaming WAL;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # -1 allows indefinite delay</font></div><div><font size="2"  >#wal_receiver_status_interval = 10s &nbsp; &nbsp; # send replies at least this often</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 0 disables</font></div><div><font size="2"  >hot_standby_feedback = on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # send info from standby to prevent</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # query conflicts</font></div><p></p></pre></div><div>与9.1相比少了wal_sender_delay参数. 先不管, 9.2的手册上也没说为啥少了这个.</div><div><br></div><div>主节点上还需要新建一个replica角色用于复制 :&nbsp;</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >postgres=# create role replica nosuperuser nocreatedb nocreaterole noinherit login replication connection limit 64 encrypted password 'replica123';</font></p></pre></div><div><br></div><div>接下来是standby1的配置 :&nbsp;</div><div>postgresql.conf与主节点一致 .&nbsp;</div><div>新建一个~/.pgpass</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >*:*:replication:replica:replica123</font></div></div><div><font size="2"  >chmod 400 ~/.pgpass</font></div><p></p></pre></div><div>新建recovery.conf</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >recovery_target_timeline = 'latest'</font></div><div><font size="2"  >standby_mode = on</font></div><div><font size="2"  >primary_conninfo = 'host=172.16.3.33 port=1919 user=replica keepalives_idle=60' &nbsp; &nbsp; &nbsp; &nbsp; # e.g. 'host=localhost port=5432'</font></div><div><font size="2"  >trigger_file = '/pgdata1919/.trigger.1919.pg92'</font></div><p></p></pre></div><div>然后是新建standby1节点 :&nbsp;</div><div>新建PGDATA目录并修改目录权限为700, 然后</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg_basebackup -D $PGDATA -F p -P -v -h 172.16.3.33 -p 1919 -U replica</font></div><div><font size="2"  >pg_ctl start -D $PGDATA</font></div><p></p></pre></div><div><br></div><div><div style="line-height: 22px;"  >接下来是standby2的配置 :&nbsp;</div><div style="line-height: 22px;"  >postgresql.conf与主节点一致 .&nbsp;</div><div style="line-height: 22px;"  >新建一个~/.pgpass</div><div><div><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><div style="line-height: 22px;"  ><font size="2"  >*:*:replication:replica:replica123</font></div></div><div style="line-height: 22px;"  ><font size="2"  >chmod 400 ~/.pgpass</font></div><p></p></pre></div></div><div style="line-height: 22px;"  >新建recovery.conf</div><div><div><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >recovery_target_timeline = 'latest'</font></div><div style="line-height: 22px;"  ><font size="2"  >standby_mode = on</font></div><div style="line-height: 22px;"  ><font size="2"  >primary_conninfo = 'host=172.16.3.39 port=1919 user=replica keepalives_idle=60' &nbsp; &nbsp; &nbsp; &nbsp; # e.g. 'host=localhost port=5432'</font></div><div style="line-height: 22px;"  ><font size="2"  >trigger_file = '/pgdata1919/.trigger.1919.pg92'</font></div><p></p></pre></div></div><div style="line-height: 22px;"  >然后是新建standby1节点 :&nbsp;</div><div style="line-height: 22px;"  >新建PGDATA目录并修改目录权限为700, 然后</div><div style="line-height: 22px;"  >(值得一提的是, pg_basebackup需要在主库上获得一个start backup的标签, 所以必须连到master操作. )</div><div style="line-height: 22px;"  >(如果数据库很大的话，可以考虑关闭某个standby节点, 直接复制standby的数据过去来建立基准库)</div><div><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >pg_basebackup -D $PGDATA -F p -P -v -h 172.16.3.33 -p 1919 -U replica</font></div><div style="line-height: 22px;"  ><font size="2"  >pg_ctl start -D $PGDATA</font></div><p></p></pre></div></div><div><br></div><div><div style="line-height: 22px;"  >接下来是standby2的配置 :&nbsp;</div><div style="line-height: 22px;"  >postgresql.conf与主节点一致 .&nbsp;</div><div style="line-height: 22px;"  >新建一个~/.pgpass</div><div><div><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><div style="line-height: 22px;"  ><font size="2"  >*:*:replication:replica:replica123</font></div></div><div style="line-height: 22px;"  ><font size="2"  >chmod 400 ~/.pgpass</font></div><p></p></pre></div></div><div style="line-height: 22px;"  >新建recovery.conf</div><div><div><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >recovery_target_timeline = 'latest'</font></div><div style="line-height: 22px;"  ><font size="2"  >standby_mode = on</font></div><div style="line-height: 22px;"  ><font size="2"  >primary_conninfo = 'host=172.16.3.40 port=1919 user=replica keepalives_idle=60' &nbsp; &nbsp; &nbsp; &nbsp; # e.g. 'host=localhost port=5432'</font></div><div style="line-height: 22px;"  ><font size="2"  >trigger_file = '/pgdata1919/.trigger.1919.pg92'</font></div><p></p></pre></div></div><div style="line-height: 22px;"  >然后是新建standby1节点 :&nbsp;</div><div style="line-height: 22px;"  >新建PGDATA目录并修改目录权限为700, 然后</div><div style="line-height: 22px;"  >(值得一提的是, pg_basebackup需要在主库上获得一个start backup的标签, 所以必须连到master操作. )</div><div style="line-height: 22px;"  >(如果数据库很大的话，可以考虑关闭某个standby节点, 直接复制standby的数据过去来建立基准库)</div><div><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >pg_basebackup -D $PGDATA -F p -P -v -h 172.16.3.33 -p 1919 -U replica</font></div><div style="line-height: 22px;"  ><font size="2"  >pg_ctl start -D $PGDATA</font></div><p></p></pre></div></div><div><br></div><div>至此，整个环境都搭建好了。</div><div>在主库新建一个测试表看看standby3会不会复制过去,</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# create table cascading_test (id int,info text);</font></div><div><font size="2"  >CREATE TABLE</font></div><div><font size="2"  >postgres=# insert into cascading_test select generate_series(1,10000),'digoal';</font></div><div><font size="2"  >INSERT 0 10000</font></div><p></p></pre></div><div>连接到standby3 ， 数据已经复制过去了。</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-150-&gt; psql -h 127.0.0.1 -p 1919 -U pg92 postgres</font></div><div><font size="2"  >psql (9.2devel)</font></div><div><font size="2"  >Type "help" for help.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >postgres=# \dt</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"  >&nbsp;Schema | &nbsp; &nbsp; &nbsp;Name &nbsp; &nbsp; &nbsp;| Type &nbsp;| Owner&nbsp;</font></div><div><font size="2"  >--------+----------------+-------+-------</font></div><div><font size="2"  >&nbsp;public | cascading_test | table | pg92</font></div><div><font size="2"  >&nbsp;public | test &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | table | pg92</font></div><div><font size="2"  >(2 rows)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >postgres=# select count(*) from cascading_test ;</font></div><div><font size="2"  >&nbsp;count&nbsp;</font></div><div><font size="2"  >-------</font></div><div><font size="2"  >&nbsp;10000</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div>【注意】</div><div>1. 如果在环境中配置了同步流复制，那么同步流复制的备选standby节点中只会选择直连master的节点，级联节点不在备选的角色中，如本例中只有standby1会成为备选角色。</div><div>例如我们把master的配置文件修改一下,</div><div><pre class="prettyprint"  ><p><font size="2"  >synchronous_standby_names = '*'</font></p></pre></div><div>通过查看master的视图可以看出这一点 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# select * from pg_stat_replication;</font></div><div><font size="2"  >&nbsp;procpid | usesysid | usename | application_name | client_addr | client_hostname | client_port | &nbsp; &nbsp; &nbsp; &nbsp; backend_start &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; s</font></div><div><font size="2"  >tate &nbsp; | sent_location | write_location | flush_location | replay_location | sync_priority | sync_state&nbsp;</font></div><div><font size="2"  >---------+----------+---------+------------------+-------------+-----------------+-------------+-------------------------------+----</font></div><div><font size="2"  >-------+---------------+----------------+----------------+-----------------+---------------+------------</font></div><div><font size="2"  >&nbsp; &nbsp;14977 | &nbsp; &nbsp;16384 | replica | walreceiver &nbsp; &nbsp; &nbsp;| 172.16.3.39 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; 38560 | 2012-01-12 16:09:18.166834+08 | str</font></div><div><font size="2"  >eaming | 0/70CEC08 &nbsp; &nbsp; | 0/70CEC08 &nbsp; &nbsp; &nbsp;| 0/70CEC08 &nbsp; &nbsp; &nbsp;| 0/70CEC08 &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | sync</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>同时, sync_state也不会传递, 如master配置了synchronous_standby_names = '*', standby1也配置了synchronous_standby_names = '*'</div><div>那么standby2会不会是<span style="line-height: 22px;"  >sync_state = sync的呢？答案是不会. 因为同步止于与master节点直连的节点。</span></div><div><span style="line-height: 22px;"  ><br></span></div><div>2. 不管是同步还是异步复制，在pg_stat_replication视图中都只能看到与之直连的standby的信息。</div><div>例如在本例中的MASTER节点查看<span style="line-height: 22px;"  >pg_stat_replication视图的时候，只能查看到与之直连的standby1的信息。</span></div><div><span style="line-height: 22px;"  >在standby1节点查看</span><span style="line-height: 22px;"  >pg_stat_replication的信息也只能查看到与之直连的standby2节点的信息。</span></div><div><br></div><div>&nbsp;【小结】</div><div>级联复制非常在异地建立多个STANDBY的环境. 可以大大降低网络带宽的开销。</div><div>同时级联复制还可以降低主库对网络带宽的需求，因为9.1和9.0的版本如果standby很多或者pg_xlog生成很频繁的话，主库的网络开销很快就会成为瓶颈。<br><div><br></div><div>&nbsp;【参考】<wbr><div><a rel="nofollow" href="http://www.postgresql.org/ftp/snapshot/dev/"  >http://www.postgresql.org/ftp/snapshot/dev/</a> </div><div><a rel="nofollow" href="http://www.postgresql.org/docs/devel/static/index.html"  >http://www.postgresql.org/docs/devel/static/index.html</a> </div></div></div></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">晴天 - 2012-01-12 17:22:47</h5>
				<div><IMG src="http://b.bst.126.net/common/portrait/face/preview/face0.gif"  >,重要参考资料</div>
			</div>
	</div>
</div>
</body>
</html>