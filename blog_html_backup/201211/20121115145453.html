<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL partial index use caveat in prepared statement</h2>
	<h5 id="">2012-11-15 14:54:53&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020121015265329/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">最近开发的同事反映的一个问题.<div>环境是这样的,</div><div>主机A跨广域网抽取主机B上的PostgreSQL的数据.</div><div>一共抽取两个表, 假设为T1和 T2.</div><div>其中T1表 60GB左右, T2表 30GB左右.</div><div>抽取的规则是按照时间分段抽取, 例如 :</div><div><pre class="prettyprint"   ><p><font size="2"   >select * from t1 where create_time&gt;=$1::timestamp with time zone and create_time &lt;$2::timestamp with time zone order by create_time limit $3 offset $4;</font></p></pre></div><div>以及</div><div><pre class="prettyprint"   ><p><font size="2"   >select * from t2 where create_time&gt;=$1::timestamp with time zone and create_time &lt;$2::timestamp with time zone order by create_time limit $3 offset $4;</font></p></pre></div><div>在t1和t2的表中, create_time上都有索引.</div><div>但是t1 表抽取每次耗时约2秒, 而t2表每次耗时需要600秒. 这样分段抽取的话, 总的时间就非常的长.</div><div>从时间上来看, t1表应该是走了索引, 而t2表应该是全表扫描.</div><div>但是奇怪的是, 在psql或者pgadmin客户端中执行同样的SQL, t2 表是很快的.</div><div>为了更清晰的知晓执行计划, 最好是在数据库上启用auto_explain的插件, 但是需要重启数据库, 这个操作也只是为了印证. 对解决问题没有用, 所以这里就不重启数据库来加载auto_explain了.</div><div>那么到底有多少种原因会造成有索引确不走索引的情况呢?</div><div>1. 客户端设置了连接参数, 如enable_indexscan=off. 经过检查并没有这个参数.</div><div>2. t2 表的统计信息未更新. 但是如果是这个问题, 在psql或者pgadmin中都会很慢. 所以排除.&nbsp;</div><div>&nbsp; &nbsp; 并且如果是这个问题执行analyze后就可以排除.</div><div>3. 禁用用户的全表扫描都无效, &nbsp;alter user digoal set enable_seqscan=off;</div><div>&nbsp; &nbsp; t2表的抽取依旧很慢, t1表依旧很快. (这个操作只对重新连接的会话生效, 长连接无效.)</div><div><br></div><div>一开始没有仔细看索引的信息, 只是关心有没有建索引. 原来T2表建的是partial index. 如下 :&nbsp;<br><pre class="prettyprint"   ><p><font size="2"   >"idx_t2_create_time" btree (create_time) WHERE create_time &gt; '2011-04-15 00:00:00+08'::timestamp with time zone</font></p></pre><wbr></div><div>所以在执行prepared statement的时候, optimalize后才取传递的参数值, 所以不能使用这个索引.</div><div>而T1表是全量索引, 所以自然优先选择索引. 就出现了本文出现的问题.</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; prepare p_t2 (timestamp with time zone, timestamp with time zone, bigint, bigint) as SELECT * from digoal.t2 where create_time&gt;=$1 and create_time&lt;$2 order by create_time limit $3 offset $4;</font></div><div><font size="2"   >PREPARE</font></div><div><font size="2"   >digoal=&gt; explain execute p_t2('2012-11-10', '2012-11-11', 10, 10);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >---------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Limit &nbsp;(cost=10006153796.86..10006153975.12 rows=71304 width=161)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Sort &nbsp;(cost=10006153618.60..10006155401.21 rows=713042 width=161)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Key: create_time</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on t2 &nbsp;(cost=10000000000.00..10005958957.99 rows=713042 width=161)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: ((create_time &gt;= $1) AND (create_time &lt; $2))</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div>T1 的话执行prepared statement就没有这个问题 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; prepare p_t1(timestamp with time zone, timestamp with time zone, bigint, bigint) as SELECT * from digoal.t1 where create_time&gt;=$1 and create_time&lt;$2 order by create_time limit $3 offset $4;</font></div><div><font size="2"   >PREPARE</font></div><div><font size="2"   >digoal=&gt; explain execute p_t1('2012-11-10', '2012-11-11', 10, 10);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Limit &nbsp;(cost=11730.96..23461.92 rows=158179 width=152)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_t1 on t1 &nbsp;(cost=0.00..117309.44 rows=1581788 width=152)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((create_time &gt;= $1) AND (create_time &lt; $2))</font></div><div><font size="2"   >(3 rows)</font></div><p></p></pre></div><div><br></div><div>注意PostgreSQL 9.2优化了这个问题, 有兴趣的朋友可参考 :&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020124219333824/"   >http://blog.163.com/digoal@126/blog/static/16387704020124219333824/</a></div><div>测试如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; create table t1 (id int, create_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=&gt; insert into t1 select generate_series(1,1000000),clock_timestamp();</font></div><div><font size="2"   >INSERT 0 1000000</font></div><div><font size="2"   >digoal=&gt; create index idx_t1 on t1(create_time) where create_time&gt;'2012-11-15 14:45:00';</font></div><div><font size="2"   >CREATE INDEX</font></div></div><div><div><font size="2"   >digoal=&gt; explain select * from t1 where create_time&gt;='2012-11-15 14:45:01' and create_time&lt;'2012-11-15 14:45:02' order by create_time limit 10 offset 10;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >------------------------------</font></div><div><font size="2"   >&nbsp;Limit &nbsp;(cost=7.07..14.13 rows=10 width=12)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_t1 on t1 &nbsp;(cost=0.00..3533.52 rows=5000 width=12)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((create_time &gt;= '2012-11-15 14:45:01'::timestamp without time zone) AND (create_time &lt; '2012-11-15 14:45:02'::</font></div><div><font size="2"   >timestamp without time zone))</font></div><div><font size="2"   >(3 rows)</font></div></div><div><div><font size="2"   >digoal=&gt; prepare p_t1(timestamp, timestamp, bigint, bigint) as select * from t1 where create_time&gt;=$1 and create_time&lt;$2 order by create_time limit $3 offset $4;&nbsp;</font></div><div><font size="2"   >PREPARE</font></div></div><div><div><font size="2"   >digoal=&gt; explain execute &nbsp;p_t1('2012-11-15 14:45:01', '2012-11-15 14:45:02', 10, 10);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >------------------------------</font></div><div><font size="2"   >&nbsp;Limit &nbsp;(cost=7.07..14.13 rows=10 width=12)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_t1 on t1 &nbsp;(cost=0.00..3533.52 rows=5000 width=12)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((create_time &gt;= '2012-11-15 14:45:01'::timestamp without time zone) AND (create_time &lt; '2012-11-15 14:45:02'::</font></div><div><font size="2"   >timestamp without time zone))</font></div><div><font size="2"   >(3 rows)</font></div></div><p></p></pre></div><div><br></div><div>PostgreSQL 9.1以及以下版本都有 这个问题, 测试如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg91@db-172-16-3-150-&gt; psql</font></div><div><font size="2"   >psql (9.1.3)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# create table t1 (id int, create_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# &nbsp;insert into t1 select generate_series(1,1000000),clock_timestamp();</font></div><div><font size="2"   >INSERT 0 1000000</font></div><div><font size="2"   >postgres=# create index idx_t1 on t1(create_time) where create_time&gt;'2012-11-15 14:45:00';</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >postgres=# explain select * from t1 where create_time&gt;='2012-11-15 14:45:01' and create_time&lt;'2012-11-15 14:45:02' order by create_time limit 10 offset 10;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >------------------------------</font></div><div><font size="2"   >&nbsp;Limit &nbsp;(cost=7.07..14.13 rows=10 width=12)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_t1 on t1 &nbsp;(cost=0.00..3533.28 rows=5000 width=12)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((create_time &gt;= '2012-11-15 14:45:01'::timestamp without time zone) AND (create_time &lt; '2012-11-15 14:45:02'::</font></div><div><font size="2"   >timestamp without time zone))</font></div><div><font size="2"   >(3 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# &nbsp;prepare p_t1(timestamp, timestamp, bigint, bigint) as select * from t1 where create_time&gt;=$1 and create_time&lt;$2 order by create_time limit $3 offset $4;&nbsp;</font></div><div><font size="2"   >PREPARE</font></div><div><font size="2"   >postgres=# explain execute &nbsp;p_t1('2012-11-15 14:45:01', '2012-11-15 14:45:02', 10, 10);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Limit &nbsp;(cost=20714.44..20715.69 rows=500 width=12)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Sort &nbsp;(cost=20713.19..20725.69 rows=5000 width=12)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Key: create_time</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on t1 &nbsp;(cost=0.00..20406.00 rows=5000 width=12)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: ((create_time &gt;= $1) AND (create_time &lt; $2))</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>