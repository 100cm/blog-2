<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">get PostgreSQL's next oid</h2>
	<h5 id="">2012-11-26 16:24:56&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012102641616240/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>今天在群里聊到的话题, 怎么取PostgreSQL的oid.</div><div>首先解释一下什么是oid :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. OIDs are not added to user-created tables, unless WITH OIDS is specified when the table is created, or the default_with_oids configuration variable is enabled. Type oid represents an object identifier.</font></div><div><font size="2"  >The oid type is currently implemented as an unsigned four-byte integer. Therefore, it is not large enough to provide database-wide uniqueness in large databases, or even in large individual tables. So, using a user-created table's OID column as a primary key is discouraged. OIDs are best used only for references to system tables.</font></div><p></p></pre></div><div>所以说oid是一个集群范围内的概念, 而不是某个数据库或者某个表上的, oid的产生也是非常严格的. 类似序列.&nbsp;</div><div>可以参考&nbsp;<span style="line-height: 22px;"  >src/backend/access/transam/varsup.c 的</span>GetNewObjectId函数.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* GetNewObjectId -- allocate a new OID</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* OIDs are generated by a cluster-wide counter. &nbsp;Since they are only 32 bits</font></div><div><font size="2"  >&nbsp;* wide, counter wraparound will occur eventually, and therefore it is unwise</font></div><div><font size="2"  >&nbsp;* to assume they are unique unless precautions are taken to make them so.</font></div><div><font size="2"  >&nbsp;* Hence, this routine should generally not be used directly. &nbsp;The only</font></div><div><font size="2"  >&nbsp;* direct callers should be GetNewOid() and GetNewRelFileNode() in</font></div><div><font size="2"  >&nbsp;* catalog/catalog.c.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >Oid<br>GetNewObjectId(void)<br>{<br>        Oid                     result;<br><br>        /* safety check, we should never get this far in a HS slave */<br>        if (RecoveryInProgress())<br>                elog(ERROR, "cannot assign OIDs during recovery");<br><br>        LWLockAcquire(OidGenLock, LW_EXCLUSIVE);<br><br>        /*<br>         * Check for wraparound of the OID counter.  We *must* not return 0<br>         * (InvalidOid); and as long as we have to check that, it seems a good<br>         * idea to skip over everything below FirstNormalObjectId too. (This<br>         * basically just avoids lots of collisions with bootstrap-assigned OIDs<br>         * right after a wrap occurs, so as to avoid a possibly large number of<br>         * iterations in GetNewOid.)  Note we are relying on unsigned comparison.<br>         *<br>         * During initdb, we start the OID generator at FirstBootstrapObjectId, so<br>         * we only enforce wrapping to that point when in bootstrap or standalone<br>         * mode.  The first time through this routine after normal postmaster<br>         * start, the counter will be forced up to FirstNormalObjectId. This<br>         * mechanism leaves the OIDs between FirstBootstrapObjectId and<br>         * FirstNormalObjectId available for automatic assignment during initdb,<br>         * while ensuring they will never conflict with user-assigned OIDs.<br>         */<br>        if (ShmemVariableCache-&gt;nextOid &lt; ((Oid) FirstNormalObjectId))<br>        {<br>                if (IsPostmasterEnvironment)<br>                {<br>                        /* wraparound in normal environment */<br>                        ShmemVariableCache-&gt;nextOid = FirstNormalObjectId;<br>                        ShmemVariableCache-&gt;oidCount = 0;<br>                }<br>                else<br>                {<br>                        /* we may be bootstrapping, so don't enforce the full range */</font></div><div><font size="2"  >                        if (ShmemVariableCache-&gt;nextOid &lt; ((Oid) FirstBootstrapObjectId))<br>                        {<br>                                /* wraparound in standalone environment? */<br>                                ShmemVariableCache-&gt;nextOid = FirstBootstrapObjectId;<br>                                ShmemVariableCache-&gt;oidCount = 0;<br>                        }<br>                }<br>        }<br><br>        /* If we run out of logged for use oids then we must log more */<br>        if (ShmemVariableCache-&gt;oidCount == 0)<br>        {<br>                XLogPutNextOid(ShmemVariableCache-&gt;nextOid + VAR_OID_PREFETCH);<br>                ShmemVariableCache-&gt;oidCount = VAR_OID_PREFETCH;<br>        }<br><br>        result = ShmemVariableCache-&gt;nextOid;<br><br>        (ShmemVariableCache-&gt;nextOid)++;<br>        (ShmemVariableCache-&gt;oidCount)--;<br><br>        LWLockRelease(OidGenLock);<br><br>        return result;<br>}</font></div><p></p></pre></div><div>oid的信息存储在共享内存中, 数据结构如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* VariableCache is a data structure in shared memory that is used to track</font></div><div><font size="2"  >&nbsp;* OID and XID assignment state. &nbsp;For largely historical reasons, there is</font></div><div><font size="2"  >&nbsp;* just one struct with different fields that are protected by different</font></div><div><font size="2"  >&nbsp;* LWLocks.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Note: xidWrapLimit and oldestXidDB are not "active" values, but are</font></div><div><font size="2"  >&nbsp;* used just to generate useful messages when xidWarnLimit or xidStopLimit</font></div><div><font size="2"  >&nbsp;* are exceeded.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >typedef struct VariableCacheData</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* These fields are protected by OidGenLock.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextOid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* next OID to assign */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;oidCount; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* OIDs available before must do XLOG work */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* These fields are protected by XidGenLock.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId nextXid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* next XID to assign */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId oldestXid; &nbsp; &nbsp; &nbsp; &nbsp;/* cluster-wide minimum datfrozenxid */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidVacLimit; &nbsp; &nbsp; &nbsp;/* start forcing autovacuums here */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidWarnLimit; /* start complaining here */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidStopLimit; /* refuse to advance nextXid beyond here */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidWrapLimit; /* where the world ends */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestXidDB; &nbsp; &nbsp;/* database with minimum datfrozenxid */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* These fields are protected by ProcArrayLock.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId latestCompletedXid; &nbsp; &nbsp; &nbsp; /* newest XID that has committed or</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* aborted */</font></div><div><font size="2"  >} VariableCacheData;</font></div><p></p></pre></div><div><br></div><div>在PostgreSQL中没有提供直接查找nextoid的函数或视图, 通过pg_controldata可以看到最后一次checkpoint时的nextoid. 但是看不到系统当前的nextoid.</div><div>如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.2.0@db-172-16-3-150-&gt; pg_controldata | grep OID</font></div><div><font size="2"  >Latest checkpoint's NextOID: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;65890</font></div><p></p></pre></div><div>注意这里的oid有prefetch的概念, 不是每次都去fetch的, 注意到 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >src/backend/access/transam/varsup.c:#define VAR_OID_PREFETCH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8192</font></div><div><font size="2"  >src/backend/access/transam/varsup.c: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XLogPutNextOid(ShmemVariableCache-&gt;nextOid + VAR_OID_PREFETCH);</font></div><div><font size="2"  >src/backend/access/transam/varsup.c: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ShmemVariableCache-&gt;oidCount = VAR_OID_PREFETCH;</font></div><p></p></pre></div><div>前面从<span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >pg_controldata就能看出来, 实际获取的值比pg_controldata的小. 因为已经prefetch了还没消耗完.</span></div><div>那么要怎么查询呢 ?&nbsp;</div><div>需要借组C函数, 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.2.0@db-172-16-3-150-&gt; cat test.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include "postgres.h"</font></div><div><font size="2"  >#include "access/transam.h"</font></div><div><font size="2"  >#include "fmgr.h"</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >PG_MODULE_MAGIC;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >PG_FUNCTION_INFO_V1(getoid);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Datum getoid() {</font></div><div><font size="2"  >&nbsp; return GetNewObjectId();</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div><br></div><div>假设我的源码放在<span style="line-height: 22px;"  >&nbsp;</span><span style="line-height: 22px;"  >/home/pg9.2.0/postgresql-9.2.0, 这里要用到这里的头文件.</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.2.0@db-172-16-3-150-&gt; gcc -O3 -Wall -Wextra -Werror -I /home/pg9.2.0/postgresql-9.2.0/src/include -g -fPIC -c ./test.c -o test.o</font></div><div><font size="2"  >pg9.2.0@db-172-16-3-150-&gt; gcc -O3 -Wall -Wextra -Werror -I /home/pg9.2.0/postgresql-9.2.0/src/include -g -shared test.o -o libtest.so</font></div><p></p></pre></div><div>拷贝到$PGHOME/lib下面</div><div><pre class="prettyprint"  ><p><font size="2"  >pg9.2.0@db-172-16-3-150-&gt; cp libtest.so /home/pg9.2.0/pgsql9.2.0/lib/</font></p></pre></div><div>接下来在数据库中创建一个函数来获取nextoid :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg9.2.0@db-172-16-3-150-&gt; psql digoal postgres</font></div><div><font size="2"  >psql (9.2.0)</font></div><div><font size="2"  >Type "help" for help.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >digoal=# create or replace function getoid() returns int as '$libdir/libtest.so', 'getoid' language C&nbsp;</font><span style="font-size: 12px; line-height: normal;"  >STRICT</span><span style="font-size: small;"  >;</span></div><div><font size="2"  >CREATE FUNCTION</font></div><div><font size="2"  >digoal=# select getoid();</font></div><div><font size="2"  >&nbsp;getoid&nbsp;</font></div><div><font size="2"  >--------</font></div><div><font size="2"  >&nbsp; 57720</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>看一下这个nextoid是不是对的, 创建一个表, 查看它的oid.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# create table oid_test(id int);</font></div><div><font size="2"  >CREATE TABLE</font></div><div><font size="2"  >digoal=# select oid from pg_class where relname='oid_test';</font></div><div><font size="2"  >&nbsp; oid &nbsp;</font></div><div><font size="2"  >-------</font></div><div><font size="2"  >&nbsp;57721</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>看起来这个nextoid获取后就消耗掉了, 类似sequence的nextval()函数.</div><div><br></div>【参考】<wbr><div>1.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/xfunc-c.html"  >http://www.postgresql.org/docs/9.2/static/xfunc-c.html</a></div><div>2.&nbsp;src/backend/catalog/catalog.c</div><div>3.&nbsp;src/backend/access/transam/varsup.c</div><div>4.&nbsp;src/include/access/transam.h</div><div>5. pg_controldata</div><div>6.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/catalog-pg-database.html"  >http://www.postgresql.org/docs/9.2/static/catalog-pg-database.html</a></div><div>7.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/datatype-oid.html"  >http://www.postgresql.org/docs/9.2/static/datatype-oid.html</a></div></div>
	</div>
</div>
</body>
</html>