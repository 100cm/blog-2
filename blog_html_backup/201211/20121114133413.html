<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">choose bigint or text or timestamp(tz) type store datetime type?</h2>
	<h5 id="">2012-11-14 13:34:13&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020121014111255592/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">群里一位兄弟纠结于用什么存储datetime类型, 是bigint存储秒呢(他认为效率高), 还是text存储（他说兼容性好）. 还是用timestamp(tz)来存储呢?<div><br></div><div>一、首先用BIGINT和timestamp(tz)来比较, BIGINT效率高吗?</div><div>分2个方面：</div><div>1. insert ，和存储消耗的空间有关.</div><div>BIGINT在PostgreSQL中消耗8个字节, 并且是有符号类型, 所以实际上正数可用的只有2^63-1.</div><div>timestamp(tz)类型有两种可能, 存储为double或者long int 如下 :&nbsp;</div><div>实际占用多少空间和你的机器以及系统有关, 我用的intel x86, rhel 5.x 64bit上占用8字节.</div><div>所以和BIGINT一致. 所以insert 没有效率上的差别.</div><div><div>src/include/datatype/timestamp.h:</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >#ifdef HAVE_INT64_TIMESTAMP</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >typedef int64 Timestamp;</font></div><div><font size="2"   >typedef int64 TimestampTz;</font></div><div><font size="2"   >typedef int64 TimeOffset;</font></div><div><font size="2"   >typedef int32 fsec_t; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fractional seconds (in microseconds) */</font></div><div><font size="2"   >#else</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >typedef double Timestamp;</font></div><div><font size="2"   >typedef double TimestampTz;</font></div><div><font size="2"   >typedef double TimeOffset;</font></div><div><font size="2"   >typedef double fsec_t; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* fractional seconds (in seconds) */</font></div><div><font size="2"   >#endif</font></div><p></p></pre></div><div>c.h:</div><div><pre class="prettyprint"   ><p><font size="2"   >typedef long int int64;</font></p></pre></div></div><div><span style="line-height: 22px;"   >可用通过pg_controldata来查看</span>你的PostgreSQL用的是long int还是double存储timestamp(tz) :&nbsp;</div><div>pg9.2.0@db-172-16-3-150-&gt; pg_controldata&nbsp;</div><div><pre class="prettyprint"   ><p><font size="2"   >Date/time type storage: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 64-bit integers</font></p></pre></div><div><br></div><div>2. select，和operator息息相关, 比如=, &lt;, &gt;, &gt;=, &lt;=, order by等等.<br><div>以下测试一下=这个操作符的查询效率.&nbsp;</div><div>从结果来看 timestamp(6) 相比 int8 效率低9%左右 :&nbsp;</div><div>测试表 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table time_int_test (c1 bigint, c2 timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>测试数据 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; insert into time_int_test select generate_series(1,10000000),clock_timestamp();</font></div><div><font size="2"   >INSERT 0 10000000</font></div><p></p></pre></div><div>索引 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create index idx_time_int_test_1 on time_int_test (c1);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >digoal=&gt; create index idx_time_int_test_2 on time_int_test (c2);</font></div><div><font size="2"   >CREATE INDEX</font></div><p></p></pre></div><div>用于查询的测试记录 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select ctid,cmin,cmax,xmin,xmax,* from time_int_test where c1=5000000;</font></div><div><font size="2"   >&nbsp; &nbsp;ctid &nbsp; &nbsp;| cmin | cmax | &nbsp; xmin &nbsp; &nbsp;| xmax | &nbsp; c1 &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------+------+------+-----------+------+---------+----------------------------</font></div><div><font size="2"   >&nbsp;(27027,5) | &nbsp; &nbsp;0 | &nbsp; &nbsp;0 | 171985501 | &nbsp; &nbsp;0 | 5000000 | 2012-11-14 10:25:45.824705</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=&gt; select ctid,cmin,cmax,xmin,xmax,* from time_int_test where c2=timestamp '2012-11-14 10:25:45.824705';</font></div><div><font size="2"   >&nbsp; &nbsp;ctid &nbsp; &nbsp;| cmin | cmax | &nbsp; xmin &nbsp; &nbsp;| xmax | &nbsp; c1 &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------+------+------+-----------+------+---------+----------------------------</font></div><div><font size="2"   >&nbsp;(27027,5) | &nbsp; &nbsp;0 | &nbsp; &nbsp;0 | 171985501 | &nbsp; &nbsp;0 | 5000000 | 2012-11-14 10:25:45.824705</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>确认一下都是走索引扫描的 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; explain select ctid,cmin,cmax,xmin,xmax,* from time_int_test where c2=timestamp '2012-11-14 10:25:45.824705';</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_time_int_test_2 on time_int_test &nbsp;(cost=0.00..35204.99 rows=50000 width=38)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (c2 = '2012-11-14 10:25:45.824705'::timestamp without time zone)</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   >digoal=&gt; explain select ctid,cmin,cmax,xmin,xmax,* from time_int_test where c1=5000000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_time_int_test_1 on time_int_test &nbsp;(cost=0.00..35204.99 rows=50000 width=38)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (c1 = 5000000)</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>确认timestamp(tz)和bigint的存储消耗一致8字节 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select pg_column_size(c1),pg_column_size(c2),c1,c2 from time_int_test limit 1;</font></div><div><font size="2"   >&nbsp;pg_column_size | pg_column_size | c1 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------+----------------+----+----------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 | &nbsp;1 | 2012-11-14 10:25:35.024625</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>确认存储格式都是plain的.</div><div><div><pre class="prettyprint"   ><div><font size="2"   >digoal=&gt; \d+ time_int_test&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Table "digoal.time_int_test"</font></div><div><font size="2"   >&nbsp;Column | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Modifiers | Storage | Stats target | Description&nbsp;</font></div><div><font size="2"   >--------+-----------------------------+-----------+---------+--------------+-------------</font></div><div><font size="2"   >&nbsp;c1 &nbsp; &nbsp; | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | plain &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;c2 &nbsp; &nbsp; | timestamp without time zone | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | plain &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >Indexes:</font></div><div><font size="2"   >&nbsp; &nbsp; "idx_time_int_test_1" btree (c1)</font></div><div><font size="2"   >&nbsp; &nbsp; "idx_time_int_test_2" btree (c2)</font></div><div><font size="2"   >Has OIDs: no</font></div><p></p></pre></div></div><div><br></div><div>bigint对应的测试脚本 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg9.2.0@db-172-16-3-150-&gt; vi pgbench.sql&nbsp;</font></div><div><font size="2"   >select * from time_int_test where c1 = :var;</font></div><div><font size="2"   >结果 :&nbsp;</font></div><div><font size="2"   >pg9.2.0@db-172-16-3-150-&gt; pgbench -M prepared -D var=5000000 -f ./pgbench.sql -n -r -c 8 -j 8 -T 60 -U digoal digoal</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 8</font></div><div><font size="2"   >number of threads: 8</font></div><div><font size="2"   >duration: 60 s</font></div><div><font size="2"   >number of transactions actually processed: 6986211</font></div><div><font size="2"   >tps = 116436.248413 (including connections establishing)</font></div><div><font size="2"   >tps = 116450.599662 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.066672 &nbsp; &nbsp; &nbsp; &nbsp;select * from time_int_test where c1 = :var;</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >timestamp(tz)对应的测试脚本 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg9.2.0@db-172-16-3-150-&gt; vi pgbench.sql&nbsp;</font></div><div><font size="2"   >select * from time_int_test where c2 = :var;</font></div><div><font size="2"   >结果 :&nbsp;</font></div><div><font size="2"   >pg9.2.0@db-172-16-3-150-&gt; pgbench -M prepared -D var='2012-11-14 10:25:45.824705' -f ./pgbench.sql -n -r -c 8 -j 8 -T 60 -U digoal digoal</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 8</font></div><div><font size="2"   >number of threads: 8</font></div><div><font size="2"   >duration: 60 s</font></div><div><font size="2"   >number of transactions actually processed: 6347205</font></div><div><font size="2"   >tps = 105783.421348 (including connections establishing)</font></div><div><font size="2"   >tps = 105794.996279 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.073562 &nbsp; &nbsp; &nbsp; &nbsp;select * from time_int_test where c2 = :var;</font></div><p></p></pre></div></div><div>虽然timestamp(tz)类型的=操作比bigint的效率低了9%, 但是已经有10.58W每秒的qps了, 为了这9%的性能可能你将丢失更多的其他特性, 在做数据转换( int8 to timestamp(tz) )时带来的损耗绝对比这里损耗掉的9%还要多, 那真是得不偿失.</div><div><br></div><div><span style="line-height: 22px;"   >二、接下来text和timestamp(tz)来比较?</span><wbr></div></div><div><span style="line-height: 22px;"   >略, text虽然灵活, 但是太不推荐使用了.&nbsp;</span></div><div>格式得程序来保证, 而且排序什么都成问题, 函数支持也非常少, 还要考虑编码和collate的问题.</div><div><span style="line-height: 22px;"   >所以就不测试了.&nbsp;</span></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >三、timestamp(tz)存储datetime独有的好处.</span></div><div><span style="line-height: 22px;"   >1. timestamp(tz)类型系统自带的function非常多, 给使用带来了很多便利.</span></div><div><span style="line-height: 22px;"   >2. constraint, 时间格式自然只能存时间, 如果是text或者bigint, 在程序中不加约束的话, 可能存进去的就不是时间值了, 这个对后期的处理也是非常麻烦的.</span></div><div><span style="line-height: 22px;"   >3. time zone, 可以存储时区, 但是bigint 是无法做到的.</span></div><div><span style="line-height: 22px;"   >4. 时间可以精确到microsecond, bigint也是无法做到的.</span></div><div>5. others...</div><div>所以在数据库的使用中, 类型的选择还是遵循存储的值来选择合适的类型比较普遍, 除非是非常特殊的场景.</div><div><br></div><div>【参考】</div><div>1.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/datatype-datetime.html"   >http://www.postgresql.org/docs/9.2/static/datatype-datetime.html</a></div><div>2.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/functions-datetime.html"   >http://www.postgresql.org/docs/9.2/static/functions-datetime.html</a></div></div>
	</div>
</div>
</body>
</html>