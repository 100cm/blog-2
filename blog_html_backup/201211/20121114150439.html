<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL cann't wakeup prepared transaction yet, so use advisory lock</h2>
	<h5 id="">2012-11-14 15:04:39&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012101423358264/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>群里聊到的一个话题, 对于以下场景在一个事务中怎么实现?</div><div>场景 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >lock table a</font></div><div><font size="2"   >lock table b</font></div><div><font size="2"   >modify a</font></div><div><font size="2"   >release a's lock</font></div><div><font size="2"   >modify b</font></div><div><font size="2"   >release b's lock</font></div><p></p></pre></div><div>在一个事务中是不可能做到将a的lock先释放掉的. 肯定是要等到最终事务结束的时候a,b一起释放的.</div><div>那么用2PC能不能做到呢, 就目前的情况来看还无法实现. 因为无法唤醒prepared transaction. 只能rollback或者commit.</div><div><br></div><div>一、 prepared transaction 虽然无法实现上面的场景, 但是这里还是要列举一下整个过程, 可能以后PostgreSQL 会实现唤醒prepared transaction的能力. 那就顺理成章了.</div><div>要使用prepared transaction 首先需要修改一下配置文件postgresql.conf, 把max_prepared_transactions 改成一个正数值, 以便开启.</div><div>max_prepared_transactions = 100</div><div>改好后重启数据库.</div><div>创建测试表 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table a (id int, info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=&gt; create table b (id int, info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>插入测试数据 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; insert into a select generate_series(1,100),'digoal';</font></div><div><font size="2"   >INSERT 0 100</font></div><div><font size="2"   >digoal=&gt; insert into b select generate_series(1,100),'digoal';</font></div><div><font size="2"   >INSERT 0 100</font></div><p></p></pre></div><div>锁定b表 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=&gt; select * from b where id=1 for update;</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;</font></div><div><font size="2"   >----+--------</font></div><div><font size="2"   >&nbsp; 1 | digoal</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=&gt; prepare transaction 'b';</font></div><div><font size="2"   >PREPARE TRANSACTION</font></div><p></p></pre></div></div><div>开启另一个事务对a表进行修改, 修改后提交顺便释放a的锁.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=&gt; update a set info='newval' where id=1;</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   >digoal=&gt; end;</font></div><div><font size="2"   >COMMIT</font></div><p></p></pre></div><div>接下来就是难点了, 被锁的b表如何唤醒到可操作的情况.&nbsp;</div><div>查看当前的prepared transaction.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select * from pg_prepared_xacts ;</font></div><div><font size="2"   >&nbsp;transaction | gid | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prepared &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| owner &nbsp;| database&nbsp;</font></div><div><font size="2"   >-------------+-----+-------------------------------+--------+----------</font></div><div><font size="2"   >&nbsp; &nbsp;171985519 | b &nbsp; | 2012-11-14 14:38:13.413092+08 | digoal | digoal</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>目的是要唤醒<span style="line-height: 22px;"   >171985519这个事务.</span></div><div><span style="line-height: 22px;"   >PostgreSQL &nbsp;9.2 开始增加了transaction id export的能力, 也就是其他事务可以导入这个transaction id, 能看到这个tid一样的范围.&nbsp;</span></div><div><span style="line-height: 22px;"   >这和唤醒(wakeup) prepared transaction要做的类似, 也要导入tid, 同时还要将锁对象等信息传递过来. 目前还不支持. 但是如果能实现的话确实是一个非常不错的能力. 目前应该还没有数据库实现.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=&gt; select * from b where id=1 for update;</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;</font></div><div><font size="2"   >----+--------</font></div><div><font size="2"   >&nbsp; 1 | digoal</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=&gt; select * from pg_export_snapshot();</font></div><div><font size="2"   >&nbsp;pg_export_snapshot&nbsp;</font></div><div><font size="2"   >--------------------</font></div><div><font size="2"   >&nbsp;0A404A71-1</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=&gt; prepare transaction 'b';</font></div><div><font size="2"   >ERROR: &nbsp;cannot PREPARE a transaction that has exported snapshots</font></div></pre></div><div><br></div><div>二、 Advisory Lock</div><div>既然2PC的路子走不通, 那么在PostgreSQL中有没有其他路子能够实现这个场景呢?</div><div>那就是advisory lock. 这个需要配合程序一起来实现它.</div><div><div>-- 程序设计时假设定义a表的advisory lock id=1; b表的advisory lock id=2;</div><div>-- 注意advisory lock id必须唯一, 如果多次申请了, 也需要多次释放.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select pg_advisory_lock(1);</font></div><div><font size="2"   >&nbsp;pg_advisory_lock&nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=&gt; select pg_advisory_lock(2);</font></div><div><font size="2"   >&nbsp;pg_advisory_lock&nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>-- 这两个锁获得以后其他会话如果要获得这两个锁就处于等待状态了.</div><div>-- 所以程序设计的时候需要定义好这样的规则.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; update a set info='newval_a' where id=1;</font></div><div><font size="2"   >UPDATE 1</font></div><p></p></pre></div><div>-- 会话A在update a后释放这个advisory lock 1.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select pg_advisory_unlock(1);</font></div><div><font size="2"   >&nbsp;pg_advisory_unlock&nbsp;</font></div><div><font size="2"   >--------------------</font></div><div><font size="2"   >&nbsp;t</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>-- 然后update b</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; update b set info='newval_b' where id=1;</font></div><div><font size="2"   >UPDATE 1</font></div><p></p></pre></div><div>-- 最好释放advisory lock 2.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select pg_advisory_unlock(2);</font></div><div><font size="2"   >&nbsp;pg_advisory_unlock&nbsp;</font></div><div><font size="2"   >--------------------</font></div><div><font size="2"   >&nbsp;t</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>其他会话只要遵循这个执行流程, 就能达到本文开始是提到的场景的目的.</div></div><div><br></div>【参考】<wbr><div><div>1. prepared transaction</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020111141103578/"   >http://blog.163.com/digoal@126/blog/static/16387704020111141103578/</a></div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/sql-prepare-transaction.html"   >http://www.postgresql.org/docs/9.2/static/sql-prepare-transaction.html</a></div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/sql-commit-prepared.html"   >http://www.postgresql.org/docs/9.2/static/sql-commit-prepared.html</a></div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/sql-rollback-prepared.html"   >http://www.postgresql.org/docs/9.2/static/sql-rollback-prepared.html</a></div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/view-pg-prepared-xacts.html"   >http://www.postgresql.org/docs/9.2/static/view-pg-prepared-xacts.html</a></div><div><br></div><div>2. transaction snapshot</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012416105232835/"   >http://blog.163.com/digoal@126/blog/static/1638770402012416105232835/</a></div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/sql-set-transaction.html"   >http://www.postgresql.org/docs/9.2/static/sql-set-transaction.html</a></div><div><br></div><div>3. Advisory Locks</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201172492217830/"   >http://blog.163.com/digoal@126/blog/static/163877040201172492217830/</a></div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/explicit-locking.html#ADVISORY-LOCKS"   >http://www.postgresql.org/docs/9.2/static/explicit-locking.html#ADVISORY-LOCKS</a></div></div></div>
	</div>
</div>
</body>
</html>