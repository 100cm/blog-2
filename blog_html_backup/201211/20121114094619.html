<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL row lock and htup.t_infomask thinking</h2>
	<h5 id="">2012-11-14 9:46:19&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201210134586363/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>群里聊到的关于PostgreSQL范围锁的话题. 大概是这样的 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >BEGIN;</font></div><div><font size="2"  >update t set c1=? where c2&gt;? ;</font></div><p></p></pre></div><div>在COMMIT或者ROLLBACK之前, 这种SQL可能会锁上很多行?</div><div>1. 在这种情况下会不会升级成表锁?</div><div>2. 如果要锁的行数非常多会不会造成内存资源的开销非常大?</div><div>3. 如果这条SQL要更新100000行, 那么是不是需要100000个锁对象?&nbsp;</div><div>首先, 锁的管理非常复杂, 三言两语也讲不清楚, &nbsp;这里只涉及非常小的一部分（Regular Lock(a/k/a heavyweight locks)）, 未涉及到spin lock和lwlock. 所以需要深入研究的朋友情参考本文末尾的参考部分.</div><div>至于前面提到的两个问题,&nbsp;</div><div><span style="line-height: 22px;"  >1. 在这种情况下会不会升级成表锁? &nbsp;这个肯定是不会的.&nbsp;</span></div><div><span style="line-height: 22px;"  >2.&nbsp;</span><span style="line-height: 22px;"  >如果要锁的行数非常多会不会造成内存资源的开销非常大? &nbsp;</span></div><div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >A LOCK object exists for each&nbsp;<span style="line-height: 22px;"  >lockable object that currently has locks held or requested on it. &nbsp;</span></font></div><div style="line-height: 22px;"  ><font size="2"  ><span style="line-height: 22px;"  >A PROCLOCK&nbsp;</span><span style="line-height: 22px;"  >struct exists for each backend that is holding or requesting lock(s) on each&nbsp;</span><span style="line-height: 22px;"  >LOCK object.</span></font></div><p></p></pre></div><div><span style="line-height: 22px;"  >从这句话来看, &nbsp;锁对象越多必然会增加内存的开销, 但是事实上并不是这样的, 因为lock hash table的size是有限的(等于</span>max_locks_per_transaction * (max_connections + max_prepared_transactions)<span style="line-height: 22px;"  >). 后面会讲到, 真是柳暗花明又一村的感觉. (第三个问题也在后面会有解释. 在lock hash table中理论上不会有100000个锁对象存在(见</span><span style="line-height: 19px; font-family: monospace; font-size: small; white-space: pre;"  >heap_lock_tuple</span><span style="line-height: 22px;"  >).)</span></div><div><span style="line-height: 22px;"  >但是有必要把大量的tuple lock自动升级成table lock锁吗? 我认为没必要, 这种场景应该人为来控制, 而不是让数据库来自动升锁级别, 包括Oracle也不会这么干. 但是MySQL锁的处理就比较差了, 可参看这里的测试:&nbsp;</span><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201042683410679/"  >http://blog.163.com/digoal@126/blog/static/163877040201042683410679/</a></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >LOCK对象的数据结构如下 :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >typedef struct LOCK</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* hash key */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG &nbsp; &nbsp; &nbsp; &nbsp; tag; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* unique identifier of lockable object */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* data */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKMASK &nbsp; &nbsp; &nbsp; &nbsp;grantMask; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* bitmask for lock types already granted */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKMASK &nbsp; &nbsp; &nbsp; &nbsp;waitMask; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* bitmask for lock types awaited */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; SHM_QUEUE &nbsp; &nbsp; &nbsp; procLocks; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* list of PROCLOCK objects assoc. with lock */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; PROC_QUEUE &nbsp; &nbsp; &nbsp;waitProcs; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* list of PGPROC objects waiting on lock */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; requested[MAX_LOCKMODES]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* counts of requested locks */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRequested; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* total of requested[] array */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; granted[MAX_LOCKMODES]; /* counts of granted locks */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGranted; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* total of granted[] array */</font></div><div><font size="2"  >} LOCK;</font></div><p></p></pre></div><div>从tag也就是LOCKTAG的数据结构能够看出tuple也在类型之中, 这也印证了PostgreSQL的锁粒度确实是到达了行级别的.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >typedef struct LOCKTAG</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;locktag_field1; /* a 32-bit ID field */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;locktag_field2; /* a 32-bit ID field */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;locktag_field3; /* a 32-bit ID field */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;locktag_field4; /* a 16-bit ID field */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag_type; &nbsp; /* see enum LockTagType */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locktag_lockmethodid; &nbsp; /* lockmethod indicator */</font></div><div><font size="2"  >} LOCKTAG;</font></div><p></p></pre></div><div>枚举<span style="line-height: 22px;"  >LockTagType定义如下 :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* LOCKTAG is the key information needed to look up a LOCK item in the</font></div><div><font size="2"  >&nbsp;* lock hashtable. &nbsp; &nbsp; &nbsp;A LOCKTAG value uniquely identifies a lockable object.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* The LockTagType enum defines the different kinds of objects we can lock.</font></div><div><font size="2"  >&nbsp;* We can handle up to 256 different LockTagTypes.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >typedef enum LockTagType</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_RELATION, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* whole relation */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* ID info for a relation is DB OID + REL OID; DB OID = 0 if shared */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_RELATION_EXTEND, &nbsp; &nbsp; &nbsp; &nbsp;/* the right to extend a relation */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* same ID info as RELATION */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_PAGE, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* one page of a relation */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* ID info for a page is RELATION info + BlockNumber */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_TUPLE, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* one physical tuple */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* ID info for a tuple is PAGE info + OffsetNumber */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_TRANSACTION, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* transaction (for waiting for xact done) */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* ID info for a transaction is its TransactionId */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_VIRTUALTRANSACTION, /* virtual transaction (ditto) */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* ID info for a virtual transaction is its VirtualTransactionId */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_OBJECT, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* non-relation database object */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* ID info for an object is DB OID + CLASS OID + OBJECT OID + SUBID */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: object ID has same representation as in pg_depend and</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* pg_description, but notice that we are constraining SUBID to 16 bits.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Also, we use DB OID = 0 for shared objects such as tablespaces.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_USERLOCK, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* reserved for old contrib/userlock code */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_ADVISORY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* advisory user locks */</font></div><div><font size="2"  >} LockTagType;</font></div><p></p></pre></div><div>以下这个macro则是用来设置tuple锁对象的值的.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >#define SET_LOCKTAG_TUPLE(locktag,dboid,reloid,blocknum,offnum) \</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ((locktag).locktag_field1 = (dboid), \</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field2 = (reloid), \</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field3 = (blocknum), \</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_field4 = (offnum), \</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_type = LOCKTAG_TUPLE, \</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(locktag).locktag_lockmethodid = DEFAULT_LOCKMETHOD)</font></div><p></p></pre></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >LOCK的锁信息存储在共享内存中的hash表中, 键值为LOCKTAG 进行检索.</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >为了减少冲突, hash表做了分区处理 :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >* The shared-memory hash tables for LOCKs and PROCLOCKs are organized </font><span style="font-size: small;"  >so that different partitions use different hash chains,&nbsp;</span></div><div><span style="font-size: small;"  >and thus there </span><span style="font-size: small;"  >is no conflict in working with objects in different partitions. &nbsp;</span></div><div><span style="font-size: small;"  >This </span><span style="font-size: small;"  >is supported directly by dynahash.c's "partitioned table" mechanism </span><span style="font-size: small;"  >for the LOCK table:&nbsp;</span></div><div><span style="font-size: small;"  >we need only ensure that the partition number is </span><span style="font-size: small;"  >taken from the low-order bits of the dynahash hash value for the LOCKTAG.</span></div><div><font size="2"  >To make it work for PROCLOCKs, we have to ensure that a PROCLOCK's hash </font><span style="font-size: small;"  >value has the same low-order bits as its associated LOCK. &nbsp;</span></div><div><span style="font-size: small;"  >This requires </span><span style="font-size: small;"  >a specialized hash function (see proclock_hash).</span></div><p></p></pre></div><div style="line-height: 22px;"  >除了共享的lock hash table之外, 每个bacnekd 还维护非共享的本地hash table. 包含了已经获得的锁信息以及请求中的锁信息.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >Each backend also maintains an unshared LOCALLOCK structure for each lockable</font></div><div><font size="2"  >object and lock mode that it is currently holding or requesting. &nbsp;The shared</font></div><div><font size="2"  >lock structures only allow a single lock grant to be made per lockable</font></div><div><font size="2"  >object/lock mode/backend. &nbsp;Internally to a backend, however, the same lock may</font></div><div><font size="2"  >be requested and perhaps released multiple times in a transaction, and it can</font></div><div><font size="2"  >also be held both transactionally and session-wide. &nbsp;The internal request</font></div><div><font size="2"  >counts are held in LOCALLOCK so that the shared data structures need not be</font></div><div><font size="2"  >accessed to alter them.</font></div><p></p></pre></div><div>数据结构如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Each backend also maintains a local hash table with information about each</font></div><div><font size="2"  >&nbsp;* lock it is currently interested in. &nbsp;In particular the local table counts</font></div><div><font size="2"  >&nbsp;* the number of times that lock has been acquired. &nbsp;This allows multiple</font></div><div><font size="2"  >&nbsp;* requests for the same lock to be executed without additional accesses to</font></div><div><font size="2"  >&nbsp;* shared memory. &nbsp;We also track the number of lock acquisitions per</font></div><div><font size="2"  >&nbsp;* ResourceOwner, so that we can release just those locks belonging to a</font></div><div><font size="2"  >&nbsp;* particular ResourceOwner.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >typedef struct LOCALLOCKTAG</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG &nbsp; &nbsp; &nbsp; &nbsp; lock; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* identifies the lockable object */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE &nbsp; &nbsp; &nbsp; &nbsp;mode; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* lock mode for this table entry */</font></div><div><font size="2"  >} LOCALLOCKTAG;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >typedef struct LOCALLOCKOWNER</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: if owner is NULL then the lock is held on behalf of the session;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* otherwise it is held on behalf of my current transaction.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Must use a forward struct reference to avoid circularity.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; struct ResourceOwnerData *owner;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int64 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nLocks; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* # of times held by this owner */</font></div><div><font size="2"  >} LOCALLOCKOWNER;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >typedef struct LOCALLOCK</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* tag */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCALLOCKTAG tag; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* unique identifier of locallock entry */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* data */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCK &nbsp; &nbsp; &nbsp; *lock; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* associated LOCK object in shared mem */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; PROCLOCK &nbsp; *proclock; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* associated PROCLOCK object in shmem */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hashcode; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* copy of LOCKTAG's hash value */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int64 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nLocks; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* total number of times lock is held */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numLockOwners; &nbsp;/* # of relevant ResourceOwners */</font></div></div><div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxLockOwners; &nbsp;/* allocated size of array */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;holdsStrongLockCount; &nbsp; /* bumped FastPathStrongRelatonLocks? */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCALLOCKOWNER *lockOwners; /* dynamically resizable array */</font></div><div><font size="2"  >} LOCALLOCK;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >#define LOCALLOCK_LOCKMETHOD(llock) ((llock).tag.lock.locktag_lockmethodid)</font></div></div><p></p></pre></div><div>因为不涉及冲突, 所以本地hash table不需要做分区处理. 另外就是数据结构相比LOCK和LOCKTAG简化了许多. 但是同样会消耗内存.</div><div style="line-height: 22px;"  >接下来看看PostgreSQL在哪里调用了&nbsp;SET_LOCKTAG_TUPLE 来请求tuple lock.</div></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LockTuple</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Obtain a tuple-level lock. &nbsp;This is used in a less-than-intuitive fashion</font></div><div><font size="2"  >&nbsp;* because we can't afford to keep a separate lock in shared memory for every</font></div><div><font size="2"  >&nbsp;* tuple. &nbsp;See heap_lock_tuple before using this!</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >void</font></div><div><font size="2"  >LockTuple(Relation relation, ItemPointer tid, LOCKMODE lockmode)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG &nbsp; &nbsp; &nbsp; &nbsp; tag;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_TUPLE(tag,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.dbId,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_lockInfo.lockRelId.relId,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetBlockNumber(tid),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetOffsetNumber(tid));</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; (void) LockAcquire(&amp;tag, lockmode, false, false);</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>注意到,&nbsp;<span style="line-height: 22px;"  >we can't afford to keep a separate lock in shared memory for every</span><span style="line-height: 22px;"  >&nbsp;tuple. 为什么呢?</span></div><div><span style="line-height: 22px;"  ><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp;* NOTES: because the shared-memory lock table is of finite size, but users</font></div><div><font size="2"  >&nbsp;* could reasonably want to lock large numbers of tuples, we do not rely on</font></div><div><font size="2"  >&nbsp;* the standard lock manager to store tuple-level locks over the long term.</font></div><p></p></pre></div><div>全文 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;heap_lock_tuple - lock a tuple in shared or exclusive mode</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Note that this acquires a buffer pin, which the caller must release.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Input parameters:</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;relation: relation containing tuple (caller must hold suitable lock)</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;tuple-&gt;t_self: TID of tuple to lock (rest of struct need not be valid)</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;cid: current command ID (used for visibility test, and stored into</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tuple's cmax if lock is successful)</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;mode: indicates if shared or exclusive tuple lock is desired</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;nowait: if true, ereport rather than blocking if lock not available</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Output parameters:</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;*tuple: all fields filled in</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;*buffer: set to buffer holding tuple (pinned but not locked at exit)</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;*ctid: set to tuple's t_ctid, but only in failure cases</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;*update_xmax: set to tuple's xmax, but only in failure cases</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Function result may be:</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;HeapTupleMayBeUpdated: lock was successfully acquired</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;HeapTupleSelfUpdated: lock failed because tuple updated by self</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp;HeapTupleUpdated: lock failed because tuple updated by other xact</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* In the failure cases, the routine returns the tuple's t_ctid and t_xmax.</font></div><div><font size="2"  >&nbsp;* If t_ctid is the same as t_self, the tuple was deleted; if different, the</font></div><div><font size="2"  >&nbsp;* tuple was updated, and t_ctid is the location of the replacement tuple.</font></div><div><font size="2"  >&nbsp;* (t_xmax is needed to verify that the replacement tuple matches.)</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* NOTES: because the shared-memory lock table is of finite size, but users</font></div><div><font size="2"  >&nbsp;* could reasonably want to lock large numbers of tuples, we do not rely on</font></div><div><font size="2"  >&nbsp;* the standard lock manager to store tuple-level locks over the long term.</font></div><div><font size="2"  >&nbsp;* Instead, a tuple is marked as locked by setting the current transaction's</font></div><div><font size="2"  >&nbsp;* XID as its XMAX, and setting additional infomask bits to distinguish this</font></div><div><font size="2"  >&nbsp;* usage from the more normal case of having deleted the tuple. &nbsp;When</font></div><div><font size="2"  >&nbsp;* multiple transactions concurrently share-lock a tuple, the first locker's</font></div><div><font size="2"  >&nbsp;* XID is replaced in XMAX with a MultiTransactionId representing the set of</font></div></div><div><div><font size="2"  >&nbsp;* XIDs currently holding share-locks.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* When it is necessary to wait for a tuple-level lock to be released, the</font></div><div><font size="2"  >&nbsp;* basic delay is provided by XactLockTableWait or MultiXactIdWait on the</font></div><div><font size="2"  >&nbsp;* contents of the tuple's XMAX. &nbsp;However, that mechanism will release all</font></div><div><font size="2"  >&nbsp;* waiters concurrently, so there would be a race condition as to which</font></div><div><font size="2"  >&nbsp;* waiter gets the tuple, potentially leading to indefinite starvation of</font></div><div><font size="2"  >&nbsp;* some waiters. &nbsp;The possibility of share-locking makes the problem much</font></div><div><font size="2"  >&nbsp;* worse --- a steady stream of share-lockers can easily block an exclusive</font></div><div><font size="2"  >&nbsp;* locker forever. &nbsp; &nbsp; &nbsp;To provide more reliable semantics about who gets a</font></div><div><font size="2"  >&nbsp;* tuple-level lock first, we use the standard lock manager. &nbsp;The protocol</font></div><div><font size="2"  >&nbsp;* for waiting for a tuple-level lock is really</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LockTuple()</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XactLockTableWait()</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mark tuple as locked by me</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;UnlockTuple()</font></div><div><font size="2"  >&nbsp;* When there are multiple waiters, arbitration of who is to get the lock next</font></div><div><font size="2"  >&nbsp;* is provided by LockTuple(). &nbsp;However, at most one tuple-level lock will</font></div><div><font size="2"  >&nbsp;* be held or awaited per backend at any time, so we don't risk overflow</font></div><div><font size="2"  >&nbsp;* of the lock table. &nbsp;Note that incoming share-lockers are required to</font></div><div><font size="2"  >&nbsp;* do LockTuple as well, if there is any conflict, to ensure that they don't</font></div><div><font size="2"  >&nbsp;* starve out waiting exclusive-lockers. &nbsp;However, if there is not any active</font></div><div><font size="2"  >&nbsp;* conflict for a tuple, we don't incur any extra overhead.</font></div><div><font size="2"  >&nbsp;*/</font></div></div></pre></div></span></div><div><br></div><div>在分析PostgreSQL怎么处理行锁前. 首先我们要分析的是tuple head 结构, 取自src/include/access/htup.h, 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >typedef struct HeapTupleHeaderData</font></div><div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; union</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleFields t_heap;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumTupleFields t_datum;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t_choice;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerData t_ctid; &nbsp; &nbsp; &nbsp; &nbsp; /* current TID of this or newer tuple */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* Fields below here must match MinimalTupleData! */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t_infomask2; &nbsp; &nbsp;/* number of attributes + various flags */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t_infomask; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* various flag bits, see below */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t_hoff; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* sizeof header incl. bitmap, padding */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* ^ - 23 bytes - ^ */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; bits8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t_bits[1]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* bitmap of NULLs -- VARIABLE LENGTH */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* MORE DATA FOLLOWS AT END OF STRUCT */</font></div><div><font size="2"  >} HeapTupleHeaderData;</font></div></div><p></p></pre></div><div>其中HeapTupleFields的数据结构如下(这里包含了cid和xmin,xmax的信息, MVCC与之息息相关) :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >typedef struct HeapTupleFields</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId t_xmin; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* inserting xact ID */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId t_xmax; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* deleting or locking xact ID */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; union</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommandId &nbsp; &nbsp; &nbsp; t_cid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* inserting or deleting command ID, or both */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId t_xvac; &nbsp; /* old-style VACUUM FULL xact ID */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t_field3;</font></div><div><font size="2"  >} HeapTupleFields;</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >其中t_infomask的允许值组合如下, 锁信息将存储在这里面 :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* information stored in t_infomask:</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >#define HEAP_HASNULL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x0001 &nbsp;/* has null attribute(s) */</font></div><div><font size="2"  >#define HEAP_HASVARWIDTH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x0002 &nbsp;/* has variable-width attribute(s) */</font></div><div><font size="2"  >#define HEAP_HASEXTERNAL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x0004 &nbsp;/* has external stored attribute(s) */</font></div><div><font size="2"  >#define HEAP_HASOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0008 &nbsp;/* has an object-id field */</font></div><div><font size="2"  >/* bit 0x0010 is available */</font></div><div><font size="2"  >#define HEAP_COMBOCID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0020 &nbsp;/* t_cid is a combo cid */</font></div><div><font size="2"  >#define HEAP_XMAX_EXCL_LOCK &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0040 &nbsp;/* xmax is exclusive locker */</font></div><div><font size="2"  >#define HEAP_XMAX_SHARED_LOCK &nbsp; 0x0080 &nbsp;/* xmax is shared locker */</font></div><div><font size="2"  >/* if either LOCK bit is set, xmax hasn't deleted the tuple, only locked it */</font></div><div><font size="2"  >#define HEAP_IS_LOCKED &nbsp;(HEAP_XMAX_EXCL_LOCK | HEAP_XMAX_SHARED_LOCK)</font></div><div><font size="2"  >#define HEAP_XMIN_COMMITTED &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0100 &nbsp;/* t_xmin committed */</font></div><div><font size="2"  >#define HEAP_XMIN_INVALID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0200 &nbsp;/* t_xmin invalid/aborted */</font></div><div><font size="2"  >#define HEAP_XMAX_COMMITTED &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0400 &nbsp;/* t_xmax committed */</font></div><div><font size="2"  >#define HEAP_XMAX_INVALID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0800 &nbsp;/* t_xmax invalid/aborted */</font></div><div><font size="2"  >#define HEAP_XMAX_IS_MULTI &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x1000 &nbsp;/* t_xmax is a MultiXactId */</font></div><div><font size="2"  >#define HEAP_UPDATED &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x2000 &nbsp;/* this is UPDATEd version of row */</font></div><div><font size="2"  >#define HEAP_MOVED_OFF &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x4000 &nbsp;/* moved to another place by pre-9.0</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* VACUUM FULL; kept for binary</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* upgrade support */</font></div><div><font size="2"  >#define HEAP_MOVED_IN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x8000 &nbsp;/* moved from another place by pre-9.0</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* VACUUM FULL; kept for binary</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* upgrade support */</font></div><div><font size="2"  >#define HEAP_MOVED (HEAP_MOVED_OFF | HEAP_MOVED_IN)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >#define HEAP_XACT_MASK &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0xFFE0 &nbsp;/* visibility-related bits */</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >因为行锁的信息在PostgreSQL的pg_locks里面无法检索到, 所以接下来我们看看PostgreSQL提供的pgrowlocks模块是怎么检索行锁信息的?</span></div><div>取自contrib/pgrowlocks/pgrowlocks.c :&nbsp;</div><div>截取pgrowlocks(PG_FUNCTION_ARGS)一段如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/* scan the relation */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; while ((tuple = heap_getnext(scan, ForwardScanDirection)) != NULL)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* must hold a buffer lock to call HeapTupleSatisfiesUpdate */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockBuffer(scan-&gt;rs_cbuf, BUFFER_LOCK_SHARE);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (HeapTupleSatisfiesUpdate(tuple-&gt;t_data,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GetCurrentCommandId(false),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scan-&gt;rs_cbuf) == HeapTupleBeingUpdated)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp;**values;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values = (char **) palloc(mydata-&gt;ncolumns * sizeof(char *));</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = 0;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values[i++] = (char *) DirectFunctionCall1(tidout, PointerGetDatum(&amp;tuple-&gt;t_self));</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tuple-&gt;t_data-&gt;t_infomask &amp; HEAP_XMAX_SHARED_LOCK)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values[i++] = pstrdup("Shared");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values[i++] = pstrdup("Exclusive");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values[i] = palloc(NCHARS * sizeof(char));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(values[i++], NCHARS, "%d", HeapTupleHeaderGetXmax(tuple-&gt;t_data));</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >显然pgrowlocks需要遍历全表, 通过</span>HeapTupleSatisfiesUpdate判断正在被更新/删除的行以及这个<span style="line-height: 22px;"  >tuple head的t_infomask信息是否带有</span><span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >HEAP_XMAX_SHARED_LOCK来判断是Shared LOCK还是Exclusive LOCK</span><span style="line-height: 22px;"  >.&nbsp;</span></div><div>所以在update和select ... for update时, 必定会涉及到tuple head的t_infomask部分信息的更新以及xmin, xmax的更新.&nbsp;</div><div>1. 对于update, 无疑是修改了"原tuple head"并且也新增了tuple以及tuple head (这又涉及到MVCC了).</div><div>2. 而对于select ... for update呢, 则只涉及到"原tuple head"的t_infomask信息的修改.</div><div>以上两点我们可以通过pgrowlocks以及pageinspect来观察.</div><div><br></div><div><span style="line-height: 22px;"  >为了更好的理解本文的意思, 建议读者可以去了解一下PostgreSQL的MVCC机制, 本文就不多介绍了. 我之前写过一些BLOG专门介绍MVCC, 有兴趣的朋友可以参考《</span><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201291575523922/"  >PostgreSQL XLOG fsync simple introduce</a><span style="line-height: 22px;"  >》的"</span>三、which tuples can be saw by client? must satisfied two factors below at the same time." 部分的介绍.&nbsp;</div><div><span style="line-height: 22px;"  ><br></span></div><div><span style="line-height: 22px;"  >接下来我们可以通过pgrowlocks和pageinspect来观察, 观察t_infomask时需要对照头文件中定义的常量解析出对应的常量名.</span></div><div>测试三种场景, 我这里用到的是PostgreSQL 9.2.0版本进行的测试 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1. select ... for share</font></div><div><font size="2"  >2. select ... for update</font></div><div><font size="2"  >3. update ...</font></div><p></p></pre></div><div>首先创建测试表 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; create table pg_lock_test (id int, info text);</font></div><div><font size="2"  >CREATE TABLE</font></div><p></p></pre></div><div>插入1000W条测试记录</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; insert into pg_lock_test select generate_series(1,10000000),'digoal';</font></div><div><font size="2"  >INSERT 0 10000000</font></div><p></p></pre></div><div>创建pgrowlocks以及pageinspect &nbsp;extension, 我这里以及创建了, 就不重复叙述了.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; \c digoal postgres</font></div><div><font size="2"  >You are now connected to database "digoal" as user "postgres".</font></div><div><font size="2"  >digoal=# \dx</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of installed extensions</font></div><div><font size="2"  >&nbsp; &nbsp; Name &nbsp; &nbsp; | Version | &nbsp; Schema &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Description &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >-------------+---------+------------+-------------------------------------------------------</font></div><div><font size="2"  >&nbsp;pageinspect | 1.0 &nbsp; &nbsp; | public &nbsp; &nbsp; | inspect the contents of database pages at a low level</font></div><div><font size="2"  >&nbsp;pgrowlocks &nbsp;| 1.0 &nbsp; &nbsp; | public &nbsp; &nbsp; | show row-level locking information</font></div><div><font size="2"  >&nbsp;plpgsql &nbsp; &nbsp; | 1.0 &nbsp; &nbsp; | pg_catalog | PL/pgSQL procedural language</font></div><div><font size="2"  >&nbsp;uuid-ossp &nbsp; | 1.0 &nbsp; &nbsp; | public &nbsp; &nbsp; | generate universally unique identifiers (UUIDs)</font></div><div><font size="2"  >(4 rows)</font></div><p></p></pre></div><div><br></div><div>先定位一条需要测试到的记录, 记住这里的ctid,xmin,xmax :&nbsp;</div><div>注意这里用到了全表扫描耗时是1376毫秒, 后面我们能注意到pgrowlocks差不多也需要耗时1376毫秒, 因为它也是需要遍历全表的.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select ctid,cmin,cmax,xmin,xmax,* from pg_lock_test where id=1;</font></div><div><font size="2"  >&nbsp;ctid &nbsp;| cmin | cmax | &nbsp; xmin &nbsp; &nbsp;| xmax | id | &nbsp;info &nbsp;</font></div><div><font size="2"  >-------+------+------+-----------+------+----+--------</font></div><div><font size="2"  >&nbsp;(0,1) | &nbsp; &nbsp;0 | &nbsp; &nbsp;0 | 171985481 | &nbsp; &nbsp;0 | &nbsp;1 | digoal</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 1376.308 ms</font></div><p></p></pre></div><div><br></div><div>一、 接下来测试<span style="line-height: 22px;"  >select ... for share</span></div><div><span style="line-height: 22px;"  >SESSION A :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=&gt; begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >Time: 0.181 ms</font></div><div><font size="2"  >digoal=&gt; select ctid,cmin,cmax,xmin,xmax,* from pg_lock_test where id=1 for share;</font></div><div><font size="2"  >&nbsp;ctid &nbsp;| cmin | cmax | &nbsp; xmin &nbsp; &nbsp;| xmax | id | &nbsp;info &nbsp;</font></div><div><font size="2"  >-------+------+------+-----------+------+----+--------</font></div><div><font size="2"  >&nbsp;(0,1) | &nbsp; &nbsp;0 | &nbsp; &nbsp;0 | 171985481 | &nbsp; &nbsp;0 | &nbsp;1 | digoal</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 1402.846 ms</font></div></div><div><div><font size="2"  >digoal=&gt; select * from pg_backend_pid();</font></div><div><font size="2"  >&nbsp;pg_backend_pid&nbsp;</font></div><div><font size="2"  >----------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1934</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 0.406 ms</font></div></div><p></p></pre></div><div>SESSION B :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from pgrowlocks('digoal.pg_lock_test');</font></div><div><font size="2"  >&nbsp;locked_row | lock_type | &nbsp;locker &nbsp; | multi | &nbsp; &nbsp;xids &nbsp; &nbsp; | &nbsp;pids &nbsp;</font></div><div><font size="2"  >------------+-----------+-----------+-------+-------------+--------</font></div><div><font size="2"  >&nbsp;(0,1) &nbsp; &nbsp; &nbsp;| Shared &nbsp; &nbsp;| 171985482 | f &nbsp; &nbsp; | {171985482} | {1934}</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 1171.961 ms</font></div><p></p></pre></div><div>我们看到,&nbsp;</div><div>1. pg<span style="line-height: 22px;"  >rowlocks('digoal.pg_lock_test') 的耗时为1171毫秒. 和遍历全表的时间差不多, 比SELECT时间略小是因为SELECT语句还加了判断需要耗费更多的资源, 并且pgrowlocks只需要看tuple head.</span></div><div>2. digoal.pg_lock_test的行锁有1条, 锁这行的事务的事务号为<span style="line-height: 22px;"  >171985482. pid=1934.</span></div><div><span style="line-height: 22px;"  >3. 锁类型为 Shared. 对pgrowlocks应代码里面的 "</span>tuple-&gt;t_data-&gt;t_infomask &amp; HEAP_XMAX_SHARED_LOCK<span style="line-height: 22px;"  >" . 一会我们从pageinspect的结果中就能看到.</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from heap_page_items(get_raw_page('digoal.pg_lock_test',0)) where lp=1;</font></div><div><div><font size="2"  >&nbsp;lp | lp_off | lp_flags | lp_len | &nbsp;t_xmin &nbsp; | &nbsp;t_xmax &nbsp; | t_field3 | t_ctid | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"  >----+--------+----------+--------+-----------+-----------+----------+--------+-------------+------------+--------+--------+-------</font></div><div><font size="2"  >&nbsp; 1 | &nbsp; 8152 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | 171985482 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (0,1) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; &nbsp;386 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 0.751 ms</font></div></div><p></p></pre></div><div>这里 lp=1 对应的是ctid(0,1)里面的1. 而<span style="line-height: 22px;"  >get_raw_page('digoal.pg_lock_test',0) 对应的是ctid(0,1)里的0号page.</span></div><div>t_infomask=386 转成16进制就是0x0182 包含了如下组合 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >HEAP_XMAX_SHARED_LOCK</font></div><div><font size="2"  >HEAP_HASVARWIDTH</font></div><div><font size="2"  >HEAP_XMIN_COMMITTED</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >接下来分析一下select ... for share会不会产生新的tuple版本.</span></div><div><span style="line-height: 22px;"  >从下面的t_xmin中没有</span><span style="line-height: 22px;"  >171985482</span><span style="line-height: 22px;"  >可以看出select ... for share 没有产生新的tuple版本.</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select max(ctid) from digoal.pg_lock_test;</font></div><div><font size="2"  >&nbsp; &nbsp; max &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >------------</font></div><div><font size="2"  >&nbsp;(54054,10)</font></div><div><font size="2"  >(1 row)</font></div><div><div><font size="2"  >digoal=# select * from heap_page_items(get_raw_page('digoal.pg_lock_test',54054));</font></div><div><font size="2"  >&nbsp;lp | lp_off | lp_flags | lp_len | &nbsp;t_xmin &nbsp; | t_xmax | t_field3 | &nbsp; t_ctid &nbsp; | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"  >----+--------+----------+--------+-----------+--------+----------+------------+-------------+------------+--------+--------+-------</font></div><div><font size="2"  >&nbsp; 1 | &nbsp; 8152 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,1) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 2 | &nbsp; 8112 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,2) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 3 | &nbsp; 8072 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,3) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 4 | &nbsp; 8032 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,4) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 5 | &nbsp; 7992 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,5) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 6 | &nbsp; 7952 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,6) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 7 | &nbsp; 7912 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,7) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 8 | &nbsp; 7872 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,8) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 9 | &nbsp; 7832 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,9) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp;10 | &nbsp; 7792 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,10) | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >(10 rows)</font></div></div><p></p></pre></div><div><br></div><div>回滚SESSION A后, pgrowlocks就看不到digoal.pg_lock_test的锁信息了.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from pgrowlocks('digoal.pg_lock_test');</font></div><div><font size="2"  >&nbsp;locked_row | lock_type | locker | multi | xids | pids&nbsp;</font></div><div><font size="2"  >------------+-----------+--------+-------+------+------</font></div><div><font size="2"  >(0 rows)</font></div><div><font size="2"  >Time: 1178.131 ms</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >再观察ctid(0,1)的tuple head信息.</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from heap_page_items(get_raw_page('digoal.pg_lock_test',0)) where lp=1;</font></div><div><font size="2"  >&nbsp;lp | lp_off | lp_flags | lp_len | &nbsp;t_xmin &nbsp; | &nbsp;t_xmax &nbsp; | t_field3 | t_ctid | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"  >----+--------+----------+--------+-----------+-----------+----------+--------+-------------+------------+--------+--------+-------</font></div><div><font size="2"  >&nbsp; 1 | &nbsp; 8152 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | 171985482 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (0,1) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; &nbsp;2434 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 0.689 ms</font></div><p></p></pre></div><div>t_xmax 变成了<span style="line-height: 22px;"  >171985482, t_infomask变更为2434 转成16进制就是982 是以下组合 :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >HEAP_XMIN_COMMITTED</font></div><div><font size="2"  >HEAP_XMAX_INVALID</font></div><div><font size="2"  >HEAP_HASVARWIDTH</font></div><div><font size="2"  >HEAP_XMAX_SHARED_LOCK</font></div><p></p></pre></div><div>说明这条记录的xmax是无效的(这里的t_xman记录了锁/回滚这条记录的事务ID, 回滚后t_xmax标记为无效, 所以锁也随之失效).</div><div><br></div><div><div>二、 接下来测试select ... for update, 这次我们取ID=2的记录.</div><div><br></div><div>SESSION A :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >Time: 0.174 ms</font></div><div><font size="2"  >digoal=&gt; select ctid,cmin,cmax,xmin,xmax,* from pg_lock_test where id=2 for update;</font></div><div><font size="2"  >&nbsp;ctid &nbsp;| cmin | cmax | &nbsp; xmin &nbsp; &nbsp;| &nbsp; xmax &nbsp; &nbsp;| id | &nbsp;info &nbsp;</font></div><div><font size="2"  >-------+------+------+-----------+-----------+----+--------</font></div><div><font size="2"  >&nbsp;(0,2) | &nbsp; &nbsp;0 | &nbsp; &nbsp;0 | 171985481 | 171985483 | &nbsp;2 | digoal</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 1231.744 ms</font></div><div><font size="2"  >digoal=&gt; select * from pg_backend_pid();</font></div><div><font size="2"  >&nbsp;pg_backend_pid&nbsp;</font></div><div><font size="2"  >----------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1934</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 0.373 ms</font></div><p></p></pre></div><div>SESSION B :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from pgrowlocks('digoal.pg_lock_test');</font></div><div><font size="2"  >&nbsp;locked_row | lock_type | &nbsp;locker &nbsp; | multi | &nbsp; &nbsp;xids &nbsp; &nbsp; | &nbsp;pids &nbsp;</font></div><div><font size="2"  >------------+-----------+-----------+-------+-------------+--------</font></div><div><font size="2"  >&nbsp;(0,2) &nbsp; &nbsp; &nbsp;| Exclusive | 171985490 | f &nbsp; &nbsp; | {171985490} | {1934}</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 1185.471 ms</font></div><p></p></pre></div><div>我们看到,&nbsp;</div><div>1. digoal.pg_lock_test的行锁有1条, 锁这行的事务的事务号为171985490. pid=1934.</div><div>2. 锁类型为 Exclusive.</div><div>查看ctid=(0,2)的tuple head信息</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from heap_page_items(get_raw_page('digoal.pg_lock_test',0)) where lp=2;</font></div><div><font size="2"  >&nbsp;lp | lp_off | lp_flags | lp_len | &nbsp;t_xmin &nbsp; | &nbsp;t_xmax &nbsp; | t_field3 | t_ctid | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"  >----+--------+----------+--------+-----------+-----------+----------+--------+-------------+------------+--------+--------+-------</font></div><div><font size="2"  >&nbsp; 2 | &nbsp; 8112 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | 171985490 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (0,2) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; &nbsp;322 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 0.697 ms</font></div><p></p></pre></div><div>t_infomask=322 转成16进制就是0x0142 包含了如下组合 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >HEAP_XMAX_EXCL_LOCK</font></div><div><font size="2"  >HEAP_HASVARWIDTH</font></div><div><font size="2"  >HEAP_XMIN_COMMITTED</font></div><p></p></pre></div><div>接下来分析一下select ... for update会不会产生新的tuple版本. 因为根据MVCC机制新的tuple SESSION B是看不到的, 所以我这里要检索整个块.</div><div>从下面的t_xmin中没有171985490可以看出select ... for update 没有产生新的tuple版本.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select max(ctid) from digoal.pg_lock_test;</font></div><div><font size="2"  >&nbsp; &nbsp; max &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >------------</font></div><div><font size="2"  >&nbsp;(54054,10)</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >digoal=# select * from heap_page_items(get_raw_page('digoal.pg_lock_test',54054));</font></div><div><font size="2"  >&nbsp;lp | lp_off | lp_flags | lp_len | &nbsp;t_xmin &nbsp; | t_xmax | t_field3 | &nbsp; t_ctid &nbsp; | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"  >----+--------+----------+--------+-----------+--------+----------+------------+-------------+------------+--------+--------+-------</font></div><div><font size="2"  >&nbsp; 1 | &nbsp; 8152 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,1) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 2 | &nbsp; 8112 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,2) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 3 | &nbsp; 8072 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,3) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 4 | &nbsp; 8032 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,4) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 5 | &nbsp; 7992 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,5) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 6 | &nbsp; 7952 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,6) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 7 | &nbsp; 7912 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,7) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 8 | &nbsp; 7872 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,8) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; 9 | &nbsp; 7832 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,9) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp;10 | &nbsp; 7792 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,10) | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >(10 rows)</font></div><div><font size="2"  >Time: 0.589 ms</font></div><div><font size="2"  >digoal=# select * from heap_page_items(get_raw_page('digoal.pg_lock_test',54055));</font></div><div><font size="2"  >ERROR: &nbsp;block number 54055 is out of range for relation "pg_lock_test"</font></div><div><font size="2"  >Time: 0.463 ms</font></div><p></p></pre></div><div>块超出,说明54054已经是最大块了, 没有遗漏. 说明select ... for update绝对不可能产生了新的tuple.</div></div><div><br></div><div><div>回滚SESSION A后, pgrowlocks就看不到digoal.pg_lock_test的锁信息了.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from pgrowlocks('digoal.pg_lock_test');</font></div><div><font size="2"  >&nbsp;locked_row | lock_type | locker | multi | xids | pids&nbsp;</font></div><div><font size="2"  >------------+-----------+--------+-------+------+------</font></div><div><font size="2"  >(0 rows)</font></div><div><font size="2"  >Time: 1178.131 ms</font></div><p></p></pre></div><div>再观察ctid(0,2)的tuple head信息.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from heap_page_items(get_raw_page('digoal.pg_lock_test',0)) where lp=2;</font></div><div><font size="2"  >&nbsp;lp | lp_off | lp_flags | lp_len | &nbsp;t_xmin &nbsp; | &nbsp;t_xmax &nbsp; | t_field3 | t_ctid | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"  >----+--------+----------+--------+-----------+-----------+----------+--------+-------------+------------+--------+--------+-------</font></div><div><font size="2"  >&nbsp; 2 | &nbsp; 8112 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | 171985490 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (0,2) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2370 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 0.689 ms</font></div><p></p></pre></div><div>t_xmax 变成了171985490, t_infomask变更为2370 转成16进制就是942 是以下组合 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >HEAP_XMIN_COMMITTED</font></div><div><font size="2"  >HEAP_XMAX_INVALID</font></div><div><font size="2"  >HEAP_HASVARWIDTH</font></div><div><font size="2"  >HEAP_XMAX_EXCL_LOCK</font></div><p></p></pre></div><div>说明这条记录的xmax是无效的(这里的t_xman记录了锁/回滚这条记录的事务ID, 回滚后t_xmax标记为无效, 所以锁也随之失效).</div></div><div><br></div><div>三、 最后要测试update. 这是会产生新的tuple的操作.&nbsp;<span style="line-height: 22px;"  >这次我们取ID=3的记录.</span></div><div><div>SESSION A :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >Time: 0.178 ms</font></div><div><font size="2"  >digoal=&gt; select ctid,cmin,cmax,xmin,xmax,* from pg_lock_test where id=3;</font></div><div><font size="2"  >&nbsp;ctid &nbsp;| cmin | cmax | &nbsp; xmin &nbsp; &nbsp;| &nbsp; xmax &nbsp; &nbsp;| id | &nbsp;info &nbsp;</font></div><div><font size="2"  >-------+------+------+-----------+-----------+----+--------</font></div><div><font size="2"  >&nbsp;(0,3) | &nbsp; &nbsp;0 | &nbsp; &nbsp;0 | 171985481 | 171985483 | &nbsp;3 | digoal</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 1242.763 ms</font></div><div><font size="2"  >digoal=&gt; select * from pg_backend_pid();</font></div><div><font size="2"  >&nbsp;pg_backend_pid&nbsp;</font></div><div><font size="2"  >----------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1934</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 0.294 ms</font></div><div><font size="2"  >digoal=&gt; update pg_lock_test set info='test' where id=3;</font></div><div><font size="2"  >UPDATE 1</font></div><div><font size="2"  >Time: 1227.698 ms</font></div><p></p></pre></div><div>-- 这里会话A看到的是自己修改过的但是尚未提交的id=3的记录, 所以xmin=171985491. ctid是在BLOCKs的最末端插入的=(54054,11) .</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; select ctid,cmin,cmax,xmin,xmax,* from pg_lock_test where id=3;</font></div><div><font size="2"  >&nbsp; &nbsp; ctid &nbsp; &nbsp;| cmin | cmax | &nbsp; xmin &nbsp; &nbsp;| xmax | id | info&nbsp;</font></div><div><font size="2"  >------------+------+------+-----------+------+----+------</font></div><div><font size="2"  >&nbsp;(54054,11) | &nbsp; &nbsp;0 | &nbsp; &nbsp;0 | 171985491 | &nbsp; &nbsp;0 | &nbsp;3 | test</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 1235.105 ms</font></div><p></p></pre></div><div><br></div><div>SESSION B :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from pgrowlocks('digoal.pg_lock_test');</font></div><div><font size="2"  >&nbsp;locked_row | lock_type | &nbsp;locker &nbsp; | multi | &nbsp; &nbsp;xids &nbsp; &nbsp; | &nbsp;pids &nbsp;</font></div><div><font size="2"  >------------+-----------+-----------+-------+-------------+--------</font></div><div><font size="2"  >&nbsp;(0,3) &nbsp; &nbsp; &nbsp;| Exclusive | 171985491 | f &nbsp; &nbsp; | {171985491} | {1934}</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 1182.028 ms</font></div><p></p></pre></div><div>我们看到,&nbsp;</div><div>1. digoal.pg_lock_test的行锁有1条, 锁这行的事务的事务号为171985491. pid=1934.</div><div>2. 锁类型为 Exclusive.</div><div>查看这里被锁的行ctid=(0,3)的tuple head信息</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from heap_page_items(get_raw_page('digoal.pg_lock_test',0)) where lp=3;</font></div><div><font size="2"  >&nbsp;lp | lp_off | lp_flags | lp_len | &nbsp;t_xmin &nbsp; | &nbsp;t_xmax &nbsp; | t_field3 | &nbsp; t_ctid &nbsp; | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"  >----+--------+----------+--------+-----------+-----------+----------+------------+-------------+------------+--------+--------+-------</font></div><div><font size="2"  >&nbsp; 3 | &nbsp; 8072 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | 171985491 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,11) | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; &nbsp;258 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 0.716 ms</font></div><p></p></pre></div><div>t_infomask=258 转成16进制就是0x0102 包含了如下组合 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >HEAP_HASVARWIDTH</font></div><div><font size="2"  >HEAP_XMIN_COMMITTED</font></div><p></p></pre></div><div>注意这里的t_ctid=54054,11 说明这条记录还指向了另一条tuple. 那就是update后新插入的tuple, tuple头信息如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from heap_page_items(get_raw_page('digoal.pg_lock_test',54054)) where lp=11;</font></div><div><font size="2"  >&nbsp;lp | lp_off | lp_flags | lp_len | &nbsp;t_xmin &nbsp; | t_xmax | t_field3 | &nbsp; t_ctid &nbsp; | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"  >----+--------+----------+--------+-----------+--------+----------+------------+-------------+------------+--------+--------+-------</font></div><div><font size="2"  >&nbsp;11 | &nbsp; 7752 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 33 | 171985491 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,11) | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp;10242 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 0.599 ms</font></div><p></p></pre></div><div>t_infomask=10242 转成16进制就是0x2802 包含了如下组合 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >HEAP_UPDATED</font></div><div><font size="2"  >HEAP_XMAX_INVALID</font></div><div><font size="2"  >HEAP_HASVARWIDTH</font></div><p></p></pre></div><div>说明还未提交.&nbsp;</div><div><br></div><div>回滚SESSION A后, pgrowlocks就看不到digoal.pg_lock_test的锁信息了.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from pgrowlocks('digoal.pg_lock_test');</font></div><div><font size="2"  >&nbsp;locked_row | lock_type | locker | multi | xids | pids&nbsp;</font></div><div><font size="2"  >------------+-----------+--------+-------+------+------</font></div><div><font size="2"  >(0 rows)</font></div><div><font size="2"  >Time: 1178.131 ms</font></div><p></p></pre></div><div>再观察ctid(0,3)的tuple head信息.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from heap_page_items(get_raw_page('digoal.pg_lock_test',0)) where lp=3;</font></div><div><font size="2"  >&nbsp;lp | lp_off | lp_flags | lp_len | &nbsp;t_xmin &nbsp; | &nbsp;t_xmax &nbsp; | t_field3 | &nbsp; t_ctid &nbsp; | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"  >----+--------+----------+--------+-----------+-----------+----------+------------+-------------+------------+--------+--------+-------</font></div><div><font size="2"  >&nbsp; 3 | &nbsp; 8072 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 35 | 171985481 | 171985491 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,11) | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp; 2306 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 0.711 ms</font></div><p></p></pre></div><div>t_xmax 变成了171985491, t_infomask变更为2306 转成16进制就是902 是以下组合 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >HEAP_XMIN_COMMITTED</font></div><div><font size="2"  >HEAP_XMAX_INVALID</font></div><div><font size="2"  >HEAP_HASVARWIDTH</font></div><p></p></pre></div><div>再观察ctid(54054,11)的tuple head信息.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# select * from heap_page_items(get_raw_page('digoal.pg_lock_test',54054)) where lp=11;</font></div><div><font size="2"  >&nbsp;lp | lp_off | lp_flags | lp_len | &nbsp;t_xmin &nbsp; | t_xmax | t_field3 | &nbsp; t_ctid &nbsp; | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"  >----+--------+----------+--------+-----------+--------+----------+------------+-------------+------------+--------+--------+-------</font></div><div><font size="2"  >&nbsp;11 | &nbsp; 7752 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 33 | 171985491 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (54054,11) | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | &nbsp; &nbsp; &nbsp;10754 | &nbsp; &nbsp; 24 | &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >Time: 0.624 ms</font></div><p></p></pre></div><div>t_xmax 变成了171985491, t_infomask变更为10754 转成16进制就是2A02 是以下组合 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >HEAP_UPDATED</font></div><div><font size="2"  >HEAP_XMIN_INVALID</font></div><div><font size="2"  >HEAP_XMAX_INVALID</font></div><div><font size="2"  >HEAP_HASVARWIDTH</font></div><p></p></pre></div></div><div><br></div>【参考】<div>1.&nbsp;src/include/access/htup.h</div><div>2.&nbsp;src/include/utils/tqual.h</div><div>3.&nbsp;<span style="line-height: 22px;"  >backend/storage/lmgr</span></div><div>4. src/include/access/heapam.h</div><div>5. src/include/storage/lmgr.h</div><div>6. src/include/storage/lock.h</div><div><span style="line-height: 22px;"  >7.&nbsp;src/backend/access/heap/heapam.c</span></div><div><span style="line-height: 22px;"  >8.&nbsp;contrib/pgrowlocks/pgrowlocks.c</span></div><div>9.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201291575523922/"  >http://blog.163.com/digoal@126/blog/static/163877040201291575523922/</a></div><div>10.&nbsp;src/tools/backend/index.html</div><div>11.&nbsp;<a target="_blank" rel="nofollow" href="http://momjian.us/main/writings/pgsql/locking.pdf"  >http://momjian.us/main/writings/pgsql/locking.pdf</a>&nbsp;讲得比较浅, 那几个视图还是比较有用的.</div><div>12. shared hash lock table :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >max_locks_per_transaction (integer)</font></div><div><font size="2"  >The shared lock table tracks locks on max_locks_per_transaction * (max_connections + max_prepared_transactions) objects (e.g., tables);&nbsp;</font></div><div><font size="2"  >hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction;&nbsp;</font></div><div><font size="2"  >individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is not the number of rows that can be locked; that value is unlimited. The default, 64, has historically proven sufficient, but you might need to raise this value if you have clients that touch many different tables in a single transaction. This parameter can only be set at server start.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Increasing this parameter might cause PostgreSQL to request more System V shared memory than your operating system's default configuration allows. See Section 17.4.1 for information on how to adjust those parameters, if necessary.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >When running a standby server, you must set this parameter to the same or higher value than on the master server. Otherwise, queries will not be allowed in the standby server.</font></div><p></p></pre></div><div><br><wbr></div></div>
	</div>
</div>
</body>
</html>