<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">why we need plan hint? how? - pg_hint_plan hook.</h2>
	<h5 id="">2015-02-18 9:46:32&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201511864547547/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>2014年三十, 迎接2015, 发一弹.</div><div><br></div><div>PostgreSQL优化器是基于成本的 (CBO) , (当然, 如果开启了GEQO的话, 在关联表数量超过一定阈值后, 会采用GEQO, 这主要是因为在关联表太多的情况下, 穷举法可能带来巨大的PLAN开销, 所以GEQO输出的执行计划不一定是最优的)</div><div>本文要谈的和GEQO没什么关系, 主要和CBO相关.</div><div>当PostgreSQL使用CBO时, 就一定能每次都输出最优的执行计划吗?</div><div>1. 首选我们看看CBO考察了哪些因素, 它是如何计算成本的?</div><div>成本和扫描方式, 关联方式, 操作符, 成本因子, 数据集等都有关, 具体的计算方法可参考代码:</div><div>src/backend/optimizer/path/costsize.c</div><div>我们这里简单的列举一下, 哪些因素会影响成本计算的结果, 具体算法见costsize.c :</div><div>&nbsp; -- &nbsp;表有多少个数据块, 影响扫描数据块的成本; 例如全表扫描, 索引扫描, 都需要扫描数据块.</div><div>&nbsp; -- &nbsp;表有多少条记录, 影响全表扫描的 CPU处理记录的COST.</div><div>&nbsp; -- &nbsp;成本因子, 影响成本的计算结果; 例如连续或随机扫描单个数据块的成本因子, CPU从HEAP块处理一条记录的成本因子, 从INDEX块处理一条索引记录的成本因子, 执行一个操作符或函数的成本因子.</div><div>&nbsp; -- &nbsp;内存大小, 影响索引扫描的计算成本.</div><div>&nbsp; -- &nbsp;数据存储物理顺序和索引顺序的离散度, 影响索引扫描的计算成本.&nbsp;</div><div>&nbsp; -- &nbsp;列统计信息(列宽, 空值比例, 唯一值比例, 高频值及其比例, bucket, 物理顺序和索引顺序的离散度, 数组的话还有数组的统计信息, 等), 影响选择性, 即结果集行数, 最终影响索引扫描的计算成本.</div><div>&nbsp; -- &nbsp;创建函数或操作符时设置的成本.</div><div><br></div><div>2. 然后我们看看哪些因素CBO没有考虑进去, 还有哪些因素CBO考虑进去了, 但是可能会随时发生变化的.&nbsp;</div><div>&nbsp;PostgreSQL是否能动态的跟上这些变化?</div><div>2.1 PostgreSQL开启自动analyze, 可以适时更新的因素如下 :&nbsp;</div><div>&nbsp; -- &nbsp;表有多少数据块, 记录数, 更新pg_class.relpages, pg_class.reltuples</div><div>&nbsp; -- &nbsp;列统计信息,&nbsp;<span style="line-height: 28px;"   >数据存储物理顺序和索引顺序的离散度,&nbsp;</span><span style="line-height: 28px;"   >更新pg_statistic</span></div><div><span style="line-height: 28px;"   >2.2 静态配置因素 :&nbsp;</span></div><div><span style="line-height: 28px;"   >&nbsp; -- &nbsp;实际可用作缓存的内存, 因为数据库所在的操作系统中可能还运行了其他程序, 可用作缓存的内存可能会发生变化. 即使没有运行其他程序, 当数据库会话中有大量使用了work_mem时, 也会造成可用做缓存的内存发生变化.</span></div><div>&nbsp; -- &nbsp;<span style="line-height: 28px;"   >创建函数或操作符时设置的成本, 当函数因为内部SQL或处理逻辑等变化, 可能导致函数本身的处理时间发生变化.&nbsp;</span></div><div><span style="line-height: 28px;"   >2.3 未考虑的因素 :&nbsp;</span></div><div><span style="line-height: 28px;"   >&nbsp; -- &nbsp;块设备的的预读, 一般情况下一次读取时, 会预读128KB的数据.&nbsp;</span></div><div><div>&nbsp; &nbsp; &nbsp; # blockdev --getra /dev/sda</div><div>&nbsp; &nbsp; &nbsp; 256</div></div><div>&nbsp; &nbsp; &nbsp; 这有什么影响呢? 如果你要读取的数据在连续的128KB数据块中, 那么之需要一次块设备的IO. 对数据库来说, 扫描数据时扫多少个数据块可不管这个, 都会计算成本, 因此对于不同的块设备预读配置, 或者对于不同的块设备(如机械盘和SSD), 扫描成本可能不一样. PostgreSQL块设备的性能反映在成本计算方面, 就是seq_page_cost,&nbsp;random_page_cost.</div><div>&nbsp; &nbsp; &nbsp; 这两个参数可以针对表空间设置, 也就是说, 不同的表空间, 可以设置不同的值, 例如我们有在SSD建立的表空间, 也有在普通机械盘上创建的表空间, 当然需要设置不同的<span style="line-height: 28px;"   >seq_page_cost,&nbsp;random_page_cost</span><span style="line-height: 28px;"   >值.</span></div><div><span style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; 但是对于预读, 如果发生变更, 对实际的性能有细微的影响, 一般应该不会一天到晚变更块设备的read ahead吧.</span></div><div><span style="line-height: 28px;"   >2.4 g</span><span style="line-height: 28px;"   >eneric plan cache, 即执行计划缓存.</span></div><div><span style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; PostgreSQL 通过</span>choose_custom_plan选择重新规划执行计划还是使用缓存的执行计划, 当cached plan成本大于custom的平均成本时, 会选择custom plan , 所以当统计信息正确的情况下, 可以及时发现缓存执行计划的问题并及时规划新的执行计划.</div><div>&nbsp; &nbsp; &nbsp; 详见 : &nbsp;src/backend/utils/cache/plancache.c</div><div>2.5 采样精度参数default_statistics_target , 影响bucket个数, 采样的精度.</div><div><br></div><div>经过一番分析, PostgreSQL使用了CBO, 就一定能"每次"都输出最优的执行计划吗?</div><div>1. 首选要确保人为设置成本因子准确, 另外需要打开自动analyze(适时更新 列统计信息, 块, 离散度等),&nbsp;</div><div>2. 影响成本的因素还有一些是静态配置的 : 如可用作BUFFER的内存, 函数的成本.</div><div>3. 还有没考虑的: 预读 (甚微).</div><div>大多数情况下, 如果我们设置了合理的配置, 很少需要使用hint的. 除了以上2,3提到的两点.&nbsp;</div><div>同时hint也有比较严重的弊端, 如果将hint写在程序代码中, 一旦需要变更执行计划, 还需要改程序代码, 不灵活.</div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >当然, 我们不排除另一种用HINT的出发点, 例如调试. 我就想看看不同执行计划下执行效率是否和想象的一样.</span></div><div><span style="line-height: 28px;"   >(我们也可以使用开关来控制执行计划, 但是有HINT不是更直接一点嘛)</span></div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >长远来看, 如果仅仅从性能角度来将, 不断改进数据库本身的优化器是比较靠谱的. 但是对于例如调试这样的需求, 有HINT更方便也是对的.</span></div><div><br></div><div>好了还是进入主题, 大多数Oracle用户在接触到PostgreSQL后, 会问PG有没有SQL hint?</div><div>为了让数据库按照用户的想法输出执行计划, 一般来说PostgreSQL提供了一些开关, 如关闭全表扫描, 让它去走索引.</div><div>关闭索引扫描, 让它去走bitmap或全表扫描, 关闭嵌套循环, 让他去走hash join或merge join等.</div><div>但是仅仅有这些开关, 还不是非常的好用, 到底有没有直接点的HINT呢?</div><div>有一个插件可以解决你的问题, pg_hint_plan.</div><div>pg_hint_plan利用PostgreSQL 开放的hook接口, 所以不需要改PG代码就实现了注入HINT的功能.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Module load callbacks</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >_PG_init(void)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >...</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div></div><div>由于不同PostgreSQL 版本, plan部分的代码可能不一致, 所以pg_hint_plan也是分版本发布的源码.</div><div>例如我要在PostgreSQL 9.4.1中测试一下这个工具.</div><div><br></div><div>接下来测试一下 :&nbsp;</div><div>安装</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># wget&nbsp;http://iij.dl.sourceforge.jp/pghintplan/62456/pg_hint_plan94-1.1.3.tar.gz</font></div><div><font size="2"   ># tar -zxvf&nbsp;pg_hint_plan94-1.1.3.tar.gz</font></div><div><font size="2"   ># cd&nbsp;pg_hint_plan94-1.1.3</font></div><div><div><font size="2"   >[root@db-172-16-3-150 pg_hint_plan94-1.1.3]# export PATH=/opt/pgsql/bin:$PATH</font></div><div><font size="2"   >[root@db-172-16-3-150 pg_hint_plan94-1.1.3]# which psql</font></div><div><font size="2"   >/opt/pgsql/bin/psql</font></div><div><font size="2"   >[root@db-172-16-3-150 pg_hint_plan94-1.1.3]# psql -V</font></div><div><font size="2"   >psql (PostgreSQL) 9.4.1</font></div></div><div><font size="2"   ># gmake clean</font></div><div><font size="2"   ># gmake</font></div><div><font size="2"   ># gmake install</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-150 pg_hint_plan94-1.1.3]# ll -rt /opt/pgsql/lib|tail -n 1</font></div><div><font size="2"   >-rwxr-xr-x 1 root root &nbsp;78K Feb 18 09:31 pg_hint_plan.so</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-150 pg_hint_plan94-1.1.3]# su - postgres</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >$ vi $PGDATA/postgresql.conf</font></div><div><font size="2"   >shared_preload_libraries = 'pg_hint_plan'</font></div><div><div><font size="2"   >pg_hint_plan.enable_hint = on</font></div><div><font size="2"   >pg_hint_plan.debug_print = on</font></div><div><font size="2"   >pg_hint_plan.message_level = log</font></div></div><div><font size="2"   ><br></font></div><div><span style="line-height: 28px;"   ><font size="2"   >$ pg_ctl restart -m fast</font></span></div><div><font size="2"   ><br></font></div><div><span style="line-height: 28px;"   ><font size="2"   >postgres@db-172-16-3-150-&gt; psql</font></span></div><div><font size="2"   >psql (9.4.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >postgres=# create extension pg_hint_plan;</font></div><div><font size="2"   >CREATE EXTENSION</font></div></div><p></p></pre></div><div><br></div><div>用法举例 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create table a(id int primary key, info text, crt_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# create table b(id int primary key, info text, crt_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# insert into a select generate_series(1,100000), 'a_'||md5(random()::text), clock_timestamp();</font></div><div><font size="2"   >INSERT 0 100000</font></div><div><font size="2"   >postgres=# insert into b select generate_series(1,100000), 'b_'||md5(random()::text), clock_timestamp();</font></div><div><font size="2"   >INSERT 0 100000</font></div></div><div><div><font size="2"   >postgres=# analyze a;</font></div><div><font size="2"   >ANALYZE</font></div><div><font size="2"   >postgres=# analyze b;</font></div><div><font size="2"   >ANALYZE</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# explain select a.*,b.* from a,b where a.id=b.id and a.id&lt;10;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Nested Loop &nbsp;(cost=0.58..83.35 rows=9 width=94)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Scan using a_pkey on a &nbsp;(cost=0.29..8.45 rows=9 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id &lt; 10)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Scan using b_pkey on b &nbsp;(cost=0.29..8.31 rows=1 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = a.id)</font></div><div><font size="2"   >(5 rows)</font></div></div><div><font size="2"   >在没有pg_hint_plan时, 我们需要使用开关来改变PostgreSQL的执行计划</font></div><div><div><font size="2"   >postgres=# set enable_nestloop=off;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >postgres=# explain select a.*,b.* from a,b where a.id=b.id and a.id&lt;10;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Hash Join &nbsp;(cost=8.56..1616.65 rows=9 width=94)</font></div><div><font size="2"   >&nbsp; &nbsp;Hash Cond: (b.id = a.id)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on b &nbsp;(cost=0.00..1233.00 rows=100000 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Hash &nbsp;(cost=8.45..8.45 rows=9 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using a_pkey on a &nbsp;(cost=0.29..8.45 rows=9 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id &lt; 10)</font></div><div><font size="2"   >(6 rows)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# set enable_nestloop=on;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >postgres=# explain select a.*,b.* from a,b where a.id=b.id and a.id&lt;10;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Nested Loop &nbsp;(cost=0.58..83.35 rows=9 width=94)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Scan using a_pkey on a &nbsp;(cost=0.29..8.45 rows=9 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id &lt; 10)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Scan using b_pkey on b &nbsp;(cost=0.29..8.31 rows=1 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id = a.id)</font></div><div><font size="2"   >(5 rows)</font></div></div><p></p></pre></div><div>使用pg_hint_plan来改变PostgreSQL的执行计划 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# /*+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; HashJoin(a b)</font></div><div><font size="2"   >&nbsp; SeqScan(b)</font></div><div><font size="2"   >*/ explain select a.*,b.* from a,b where a.id=b.id and a.id&lt;10;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Hash Join &nbsp;(cost=8.56..1616.65 rows=9 width=94)</font></div><div><font size="2"   >&nbsp; &nbsp;Hash Cond: (b.id = a.id)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on b &nbsp;(cost=0.00..1233.00 rows=100000 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Hash &nbsp;(cost=8.45..8.45 rows=9 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using a_pkey on a &nbsp;(cost=0.29..8.45 rows=9 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id &lt; 10)</font></div><div><font size="2"   >(6 rows)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# /*+ SeqScan(a) */ explain select * from a where id&lt;10;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on a &nbsp;(cost=0.00..1483.00 rows=10 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (id &lt; 10)</font></div><div><font size="2"   >(2 rows)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# /*+ BitmapScan(a) */ explain select * from a where id&lt;10;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >---------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Bitmap Heap Scan on a &nbsp;(cost=4.36..35.17 rows=9 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp;Recheck Cond: (id &lt; 10)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on a_pkey &nbsp;(cost=0.00..4.36 rows=9 width=0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (id &lt; 10)</font></div><div><font size="2"   >(4 rows)</font></div></div><p></p></pre></div><div><br></div><div>目前pg_hint_plan支持的HINT</div><div><a target="_blank" rel="nofollow" href="http://pghintplan.sourceforge.jp/hint_list.html"   >http://pghintplan.sourceforge.jp/hint_list.html</a></div><div><p style="color: rgb(32, 32, 32); font-family: 'Lucida Grande', Verdana, Arial, Helvetica, メイリオ, Meiryo, 'ヒラギノ角ゴ Pro W3', 'Hiragino Kaku Gothic Pro', Osaka, 'ＭＳ Ｐゴシック', sans-serif; font-size: medium; line-height: normal;"   >The available hints are listed below.</p><table style="border: 1px solid rgb(170, 170, 170); border-collapse: collapse; color: rgb(32, 32, 32); font-family: 'Lucida Grande', Verdana, Arial, Helvetica, メイリオ, Meiryo, 'ヒラギノ角ゴ Pro W3', 'Hiragino Kaku Gothic Pro', Osaka, 'ＭＳ Ｐゴシック', sans-serif; line-height: normal; background: rgb(249, 249, 249);"   ><thead><tr></tr><tr><th style="border: 1px solid rgb(170, 170, 170); padding: 0.2em; text-align: center; background: rgb(242, 242, 242);"   >Group</th><th style="border: 1px solid rgb(170, 170, 170); padding: 0.2em; text-align: center; background: rgb(242, 242, 242);"   >Format</th><th style="border: 1px solid rgb(170, 170, 170); padding: 0.2em; text-align: center; background: rgb(242, 242, 242);"   >Description</th></tr></thead><tbody><tr><td rowspan="10"   nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Scan method</td><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >SeqScan(table)</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces sequential scan on the table</td></tr><tr><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >TidScan(table)</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces TID scan on the table.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >IndexScan(table[ index...])</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces index scan on the table. Restricts to specified indexes if any.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >IndexOnlyScan(table[ index...])</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces index only scan on the table. Rstricts to specfied indexes if any. Index scan may be used if index only scan is not available. Available for PostgreSQL 9.2 and later.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >BitmapScan(table[ index...])</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces bitmap scan on the table. Restoricts to specfied indexes if any.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >NoSeqScan(table)</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces not to do sequential scan on the table.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >NoTidScan(table)</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces not to do TID scan on the table.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >NoIndexScan(table)</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces not to do index scan and index only scan (For PostgreSQL 9.2 and later) on the table.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >NoIndexOnlyScan(table)</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces not to do index only scan on the table. Available for PostgreSQL 9.2 and later.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >NoBitmapScan(table)</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces not to do bitmap scan on the table.</td></tr><tr><td rowspan="6"   nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Join method</td><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >NestLoop(table table[ table...])</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces nested loop for the joins consist of the specifiled tables.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >HashJoin(table table[ table...])</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces hash join for the joins consist of the specifiled tables.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >MergeJoin(table table[ table...])</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces merge join for the joins consist of the specifiled tables.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >NoNestLoop(table table[ table...])</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces not to do nested loop for the joins consist of the specifiled tables.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >NoHashJoin(table table[ table...])</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces not to do hash join for the joins consist of the specifiled tables.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >NoMergeJoin(table table[ table...])</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces not to do merge join for the joins consist of the specifiled tables.</td></tr><tr><td rowspan="2"   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Join order</td><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Leading(table table[ table...])</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces join order as specified.</td></tr><tr><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Leading(&lt;join pair&gt;)</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Forces join order and directions as specified. A join pair is a pair of tables and/or other join pairs enclosed by parentheses, which can make a nested structure.</td></tr><tr><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Row number correction</td><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Rows(table table[ table...] correction)</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Corrects row number of a result of the joins consist of the specfied tables. The available correction methods are absolute (#&lt;n&gt;), addition (+&lt;n&gt;), subtract (-&lt;n&gt;) and multiplication (*&lt;n&gt;). &lt;n&gt; should be a string that strtod() can read.</td></tr><tr><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >GUC</td><td nowrap=""   style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Set(GUC-param value)</td><td style="border: 1px solid rgb(170, 170, 170); padding: 0.2em;"   >Set the GUC parameter to the value while planner is running.</td></tr></table></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a target="_blank" rel="nofollow" href="http://pghintplan.sourceforge.jp/pg_hint_plan-en.html"   >http://pghintplan.sourceforge.jp/pg_hint_plan-en.html</a></div><div>2.&nbsp;<a target="_blank" rel="nofollow" href="http://pghintplan.sourceforge.jp/pg_hint_plan.html"   >http://pghintplan.sourceforge.jp/pg_hint_plan.html</a></div><div>3.&nbsp;<a target="_blank" rel="nofollow" href="http://pghintplan.sourceforge.jp/"   >http://pghintplan.sourceforge.jp/</a></div><div>4.&nbsp;<a target="_blank" rel="nofollow" href="http://pghintplan.sourceforge.jp/hint_list.html"   >http://pghintplan.sourceforge.jp/hint_list.html</a></div><div>5. src/backend/utils/cache/plancache.c</div><div><span style="line-height: 28px;"   >6. src/backend/optimizer/path/costsize.c</span></div><div><span style="line-height: 28px;"   ><br></span></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="why we need plan hint? how? - pg_hint_plan hook. - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>