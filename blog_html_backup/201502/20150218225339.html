<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL dbms_stats used for FIX object's Statistics.</h2>
	<h5 id="">2015-02-18 22:53:39&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020151181022920/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">dbms_stats这个名字对于Oracle的用户应该比较熟悉, 但是PG的用户可能并不了解这是个啥?<div>PostgreSQL统计信息是随用户配置的阈值伴随着对象数据的变更而变更的, 也就是说, 不需要人为的干预, 数据发生变化时, 会自动收集统计信息. 这么做的目的是让数据库的统计信息适时更新, 所以一般情况下, PG很少因为数据突然变化导致统计信息不准确从而执行计划不优的情况.</div><div>但是如果数据分布, 数据使用比较有规律的话, 实际上我们并不需要过多的进行analyze.&nbsp;</div><div>那么PostgreSQL能否有计划的收集统计信息, 并将统计信息保存起来, 未来可以直接导入使用呢?</div><div>通过dbms_stats插件, 可以实现这样的功能.</div><div>dbms_stats可以备份统计信息, 还原统计信息.&nbsp;</div><div><br></div><div>dbms_stats应用场景举例, 当我们使用pg_upgrade升级数据块大版本时, 最后一步是生成统计信息, 但是如果有了dbms_stats, 我们可以导出统计信息, 并导入到新库中(假设统计信息相关字段, 统计信息表在跨版本时未发生定义上的变化). 从而大大的减少统计信息的生成时间.</div><div><br></div><div>测试 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >wget http://sourceforge.jp/frs/redir.php?m=jaist&amp;f=%2Fpgdbmsstats%2F62363%2Fpg_dbms_stats-1.3.6.tar.gz</font></div><div><font size="2"   >tar -zxvf pg_dbms_stats-1.3.6.tar.gz&nbsp;</font></div><div><font size="2"   >cd pg_dbms_stats-1.3.6</font></div><div><font size="2"   >export PATH=/opt/pgsql/bin:$PATH</font></div><div><div><font size="2"   >gmake clean</font></div><div><font size="2"   >gmake</font></div><div><font size="2"   >gmake install</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >su - postgres</font></div><div><font size="2"   >cd $PGDATA</font></div><div><font size="2"   >vi postgresql.conf</font></div><div><font size="2"   >shared_preload_libraries = 'pg_hint_plan, pg_dbms_stats'</font></div><div><font size="2"   >pg_dbms_stats.use_locked_stats = on</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >pg_ctl restart -m fast</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres@db-172-16-3-150-&gt; psql</font></div><div><font size="2"   >psql (9.4.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# create extension pg_dbms_stats; &nbsp;</font></div></div><p></p></pre></div><div>为了使用dbms_stats管理的统计信息, 首先需要生成合理的统计信息, 然后备份, 然后锁定.</div><div>还原统计信息时自动锁定.</div><div>创建测试表</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create table a(id int, info text, crt_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div></div><div><div><font size="2"   >postgres=# insert into a select g.id,'a_'||md5(random()::text), clock_timestamp() from generate_series(1,100000) g(id);</font></div><div><font size="2"   >INSERT 0 100000</font></div></div><p></p></pre></div><div><div>生成最新的统计信息, 更新pg_catalog.pg_class, pg_catalog.pg_statistic</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# analyze a;</font></div><div><font size="2"   >ANALYZE</font></div><p></p></pre></div></div><div>备份当前a表的统计信息</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select * from dbms_stats.backup_table_stats('public','a','comment');</font></div><div><font size="2"   >&nbsp;backup_table_stats&nbsp;</font></div><div><font size="2"   >--------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>查看备份离散</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select * from dbms_stats.backup_history;</font></div><div><font size="2"   >&nbsp;id | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| unit | comment&nbsp;</font></div><div><font size="2"   >----+-------------------------------+------+---------</font></div><div><font size="2"   >&nbsp; 4 | 2015-02-18 22:39:37.444274+08 | t &nbsp; &nbsp;| comment</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>查看当前是否锁定了A表的统计信息</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# &nbsp; select * from dbms_stats.relation_stats_locked ;</font></div><div><font size="2"   >&nbsp;relid | relname | relpages | reltuples | relallvisible | curpages | last_analyze | last_autoanalyze&nbsp;</font></div><div><font size="2"   >-------+---------+----------+-----------+---------------+----------+--------------+------------------</font></div><div><font size="2"   >(0 rows)</font></div><p></p></pre></div><div>未锁定A表的统计信息, 所以会使用系统的统计信息pg_catalog.pg_class, pg_catalog.statistic</div><div>注意评估行数为1</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain select * from a where id=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on a &nbsp;(cost=0.00..1483.00 rows=1 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>接下来重新生成A的记录, ID值全部一样, 都为1.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# truncate a;</font></div><div><font size="2"   >TRUNCATE TABLE</font></div><div><font size="2"   >postgres=# insert into a select 1,'a_'||md5(random()::text), clock_timestamp() from generate_series(1,100000) g(id);</font></div><div><font size="2"   >INSERT 0 100000</font></div><div><font size="2"   >postgres=# analyze a;</font></div><div><font size="2"   >ANALYZE</font></div><p></p></pre></div><div>我们看到执行计划输出, 评估行数变成了100000.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain select * from a where id=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on a &nbsp;(cost=0.00..1483.00 rows=100000 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div></div><div>接下来是关键操作, 我们要把A表的统计信息还原到之前, 即表中的所有ID唯一的情况</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# SELECT dbms_stats.restore_table_stats('public.a', '2015-02-18 22:39:37.444274+08');</font></div><div><font size="2"   >&nbsp;restore_table_stats&nbsp;</font></div><div><font size="2"   >---------------------</font></div><div><font size="2"   >&nbsp;a</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>可以看到还原后, 自动锁定了A表的统计信息,&nbsp;dbms_stats.relation_stats_locked这个表有个触发器, 在删除, 新增, 修改时触发, 用于干预PostgreSQL backend是否使用dbms_stats 中的统计信息.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \d dbms_stats.relation_stats_locked</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Table "dbms_stats.relation_stats_locked"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; Column &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Modifiers&nbsp;</font></div><div><font size="2"   >------------------+--------------------------+-----------</font></div><div><font size="2"   >&nbsp;relid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| not null</font></div><div><font size="2"   >&nbsp;relname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relpages &nbsp; &nbsp; &nbsp; &nbsp; | integer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;reltuples &nbsp; &nbsp; &nbsp; &nbsp;| real &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >&nbsp;relallvisible &nbsp; &nbsp;| integer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;curpages &nbsp; &nbsp; &nbsp; &nbsp; | integer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;last_analyze &nbsp; &nbsp; | timestamp with time zone |&nbsp;</font></div><div><font size="2"   >&nbsp;last_autoanalyze | timestamp with time zone |&nbsp;</font></div><div><font size="2"   >Indexes:</font></div><div><font size="2"   >&nbsp; &nbsp; "relation_stats_locked_pkey" PRIMARY KEY, btree (relid)</font></div><div><font size="2"   >Referenced by:</font></div><div><font size="2"   >&nbsp; &nbsp; TABLE "dbms_stats.column_stats_locked" CONSTRAINT "column_stats_locked_starelid_fkey" FOREIGN KEY (starelid) REFERENCES dbms_stats.relation_stats_locked(relid) ON DELETE CASCADE</font></div><div><font size="2"   >Triggers:</font></div><div><font size="2"   >&nbsp; &nbsp; invalidate_relation_cache BEFORE INSERT OR DELETE OR UPDATE ON dbms_stats.relation_stats_locked FOR EACH ROW EXECUTE PROCEDURE dbms_stats.invalidate_relation_cache()</font></div><p></p></pre></div><div><br></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# &nbsp; select * from dbms_stats.relation_stats_locked ;</font></div><div><font size="2"   >&nbsp;relid | relname &nbsp;| relpages | reltuples | relallvisible | curpages | &nbsp; &nbsp; &nbsp; &nbsp; last_analyze &nbsp; &nbsp; &nbsp; &nbsp; | last_autoanalyze&nbsp;</font></div><div><font size="2"   >-------+----------+----------+-----------+---------------+----------+------------------------------+------------------</font></div><div><font size="2"   >&nbsp;16566 | public.a | &nbsp; &nbsp; &nbsp;233 | &nbsp; &nbsp;100000 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp;233 | 2015-02-18 22:37:04.35998+08 |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div>接下来看执行计划, 评估的行数变成了1, 显然用了锁定的统计信息即dbms_stats.relation_stats_backup .</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain select * from a where id=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on a &nbsp;(cost=0.00..1483.00 rows=1 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>接下来解锁统计信息, 解锁后, 会使用系统的统计信息og_catalog.statistic , pg_catalog.pg_class.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# select dbms_stats.unlock_table_stats('public.a');</font></div><div><font size="2"   >&nbsp;unlock_table_stats&nbsp;</font></div><div><font size="2"   >--------------------</font></div><div><font size="2"   >&nbsp;a</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# &nbsp; select * from dbms_stats.relation_stats_locked ;</font></div><div><font size="2"   >&nbsp;relid | relname | relpages | reltuples | relallvisible | curpages | last_analyze | last_autoanalyze&nbsp;</font></div><div><font size="2"   >-------+---------+----------+-----------+---------------+----------+--------------+------------------</font></div><div><font size="2"   >(0 rows)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# explain select * from a where id=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on a &nbsp;(cost=0.00..1483.00 rows=100000 width=47)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"   >(2 rows)</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >也就是说, 有对象在</span><span style="line-height: 28px;"   >dbms_stats.relation_stats_locked时, 将使用dbms_stats中锁定的指定备份集的统计信息.</span></div><div>不在<span style="line-height: 28px;"   >dbms_stats.relation_stats_locked的对象, 将使用系统的统计信息pg_catalog.statistic和pg_catalog.pg_class</span></div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >[其他]</span></div><div><span style="line-height: 28px;"   >用法详解</span></div><div><a target="_blank" rel="nofollow" href="http://pgdbmsstats.sourceforge.jp/pg_dbms_stats-en.html"   >http://pgdbmsstats.sourceforge.jp/pg_dbms_stats-en.html</a></div><div>对象的统计信息被锁定时, 优化器使用锁定中记录的dbms_stats中的统计信息,&nbsp;</div><div>对象的统计信息未锁定时, 优化器照样使用数据库原始的统计信息pg_catalog.statistic , pg_catalog.pg_class.</div><div><div><img title="PostgreSQL dbms_stats used for FIX objects Statistics. - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL dbms_stats used for FIX objects Statistics. - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/1FihLicQtqMyiA9pIm3uRw==/6630591677163823127.png"   ></div></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a target="_blank" rel="nofollow" href="http://pgdbmsstats.sourceforge.jp/pg_dbms_stats-en.html"   >http://pgdbmsstats.sourceforge.jp/pg_dbms_stats-en.html</a></div><div>2.&nbsp;<a target="_blank" rel="nofollow" href="http://pgdbmsstats.sourceforge.jp/objects-en.html"   >http://pgdbmsstats.sourceforge.jp/objects-en.html</a></div><div>3 .<a target="_blank" rel="nofollow" href="http://sourceforge.jp/projects/pgdbmsstats/releases/"   >http://sourceforge.jp/projects/pgdbmsstats/releases/</a></div><div>4. pg_dbms_stats代码</div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL dbms_stats used for FIX objects Statistics. - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>