<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL pg_current_xlog_insert_location() & pg_current_xlog_location() diff</h2>
	<h5 id="">2014-04-09 17:08:02&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402014395222222/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">francs问到这两个函数的差别.<div>答案是pg_current_xlog_insert_location指写入wal buffer的位置.</div><div>pg_current_xlog_location返回已经fsync到wal文件的位置.</div><div>使用异步提交可以看到这个差异.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >synchronous_commit = off</font></div><div><font size="2"   >wal_writer_delay = 10000ms&nbsp;</font></div><p></p></pre></div><div><br></div><div>然后开启一个窗口执行一个大批量的写入操作.</div><div><br></div><div>在另外的窗口查看这两个函数的结果, fsync明显要小于insert.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select pg_current_xlog_insert_location(),pg_current_xlog_location();</font></div><div><font size="2"   >&nbsp;pg_current_xlog_insert_location | pg_current_xlog_location&nbsp;</font></div><div><font size="2"   >---------------------------------+--------------------------</font></div><div><font size="2"   >&nbsp;4/FCD58288 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 4/FCD50048</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div><wbr><div>答案在对应的源代码可以找到 &nbsp;:&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select prosrc, proname from pg_proc where proname ~ 'pg_current_xlog';</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;prosrc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------------------+---------------------------------</font></div><div><font size="2"   >&nbsp;pg_current_xlog_location &nbsp; &nbsp; &nbsp; &nbsp;| pg_current_xlog_location</font></div><div><font size="2"   >&nbsp;pg_current_xlog_insert_location | pg_current_xlog_insert_location</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 28px;"   >backend/access/transam/xlogfuncs.c</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Report the current WAL write location (same format as pg_start_backup etc)</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This is useful for determining how much of WAL is visible to an external</font></div><div><font size="2"   >&nbsp;* archiving process. &nbsp;Note that the data before this point is written out</font></div><div><font size="2"   >&nbsp;* to the kernel, but is not necessarily synced to disk.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >Datum</font></div><div><font size="2"   >pg_current_xlog_location(PG_FUNCTION_ARGS)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;current_recptr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;location[MAXFNAMELEN];</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (RecoveryInProgress())</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("recovery is in progress"),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("WAL control functions cannot be executed during recovery.")));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; current_recptr = GetXLogWriteRecPtr();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; snprintf(location, sizeof(location), "%X/%X",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(uint32) (current_recptr &gt;&gt; 32), (uint32) current_recptr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(cstring_to_text(location));</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Report the current WAL insert location (same format as pg_start_backup etc)</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This function is mostly for debugging purposes.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >Datum</font></div><div><font size="2"   >pg_current_xlog_insert_location(PG_FUNCTION_ARGS)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;current_recptr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;location[MAXFNAMELEN];</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (RecoveryInProgress())</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("recovery is in progress"),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("WAL control functions cannot be executed during recovery.")));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; current_recptr = GetXLogInsertRecPtr();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; snprintf(location, sizeof(location), "%X/%X",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(uint32) (current_recptr &gt;&gt; 32), (uint32) current_recptr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(cstring_to_text(location));</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><br></div><div>src/backend/access/transam/xlog.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Get latest WAL insert pointer</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >XLogRecPtr</font></div><div><font size="2"   >GetXLogInsertRecPtr(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogCtlInsert *Insert = &amp;XLogCtl-&gt;Insert;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;current_recptr;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockAcquire(WALInsertLock, LW_SHARED);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; INSERT_RECPTR(current_recptr, Insert, Insert-&gt;curridx);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(WALInsertLock);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return current_recptr;</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Get latest WAL write pointer</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >XLogRecPtr</font></div><div><font size="2"   >GetXLogWriteRecPtr(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* use volatile pointer to prevent code rearrangement */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; volatile XLogCtlData *xlogctl = XLogCtl;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;xlogctl-&gt;info_lck);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogwrtResult = xlogctl-&gt;LogwrtResult;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;xlogctl-&gt;info_lck);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return LogwrtResult.Write;</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*----------</font></div><div><font size="2"   >&nbsp;* Shared-memory data structures for XLOG control</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* LogwrtRqst indicates a byte position that we need to write and/or fsync</font></div><div><font size="2"   >&nbsp;* the log up to (all records before that point must be written or fsynced).</font></div><div><font size="2"   >&nbsp;* LogwrtResult indicates the byte positions we have already written/fsynced.</font></div><div><font size="2"   >&nbsp;* These structs are identical but are declared separately to indicate their</font></div><div><font size="2"   >&nbsp;* slightly different functions.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* To read XLogCtl-&gt;LogwrtResult, you must hold either info_lck or</font></div><div><font size="2"   >&nbsp;* WALWriteLock. &nbsp;To update it, you need to hold both locks. &nbsp;The point of</font></div><div><font size="2"   >&nbsp;* this arrangement is that the value can be examined by code that already</font></div><div><font size="2"   >&nbsp;* holds WALWriteLock without needing to grab info_lck as well. &nbsp;In addition</font></div><div><font size="2"   >&nbsp;* to the shared variable, each backend has a private copy of LogwrtResult,</font></div><div><font size="2"   >&nbsp;* which is updated when convenient.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The request bookkeeping is simpler: there is a shared XLogCtl-&gt;LogwrtRqst</font></div><div><font size="2"   >&nbsp;* (protected by info_lck), but we don't need to cache any copies of it.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* info_lck is only held long enough to read/update the protected variables,</font></div><div><font size="2"   >&nbsp;* so it's a plain spinlock. &nbsp;The other locks are held longer (potentially</font></div><div><font size="2"   >&nbsp;* over I/O operations), so we use LWLocks for them. &nbsp;These locks are:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* WALInsertLock: must be held to insert a record into the WAL buffers.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* WALWriteLock: must be held to write WAL buffers to disk (XLogWrite or</font></div><div><font size="2"   >&nbsp;* XLogFlush).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* ControlFileLock: must be held to read/update control file or create</font></div><div><font size="2"   >&nbsp;* new log file.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* CheckpointLock: must be held to do a checkpoint or restartpoint (ensures</font></div><div><font size="2"   >&nbsp;* only one checkpointer at a time; currently, with all checkpoints done by</font></div><div><font size="2"   >&nbsp;* the checkpointer, this is just pro forma).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;*----------</font></div><div><font size="2"   >&nbsp;*/</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Shared state data for XLogInsert.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef struct XLogCtlInsert</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;PrevRecord; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* start of previously-inserted record */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curridx; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* current block index in cache */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogPageHeader currpage; &nbsp; &nbsp; &nbsp; &nbsp;/* points to header of block in cache */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *currpos; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* current insertion point in cache */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;RedoRecPtr; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* current redo point for insertions */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;forcePageWrites; &nbsp; &nbsp; &nbsp; &nbsp;/* forcing full-page writes for PITR? */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* fullPageWrites is the master copy used by all backends to determine</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* whether to write full-page to WAL, instead of using process-local one.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* This is required because, when full_page_writes is changed by SIGHUP,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we must WAL-log it before it actually affects WAL-logging by backends.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Checkpointer sets at startup or after SIGHUP.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fullPageWrites;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* exclusiveBackup is true if a backup started with pg_start_backup() is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* in progress, and nonExclusiveBackups is a counter indicating the number</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* of streaming base backups currently in progress. forcePageWrites is set</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to true when either of these is non-zero. lastBackupStart is the latest</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* checkpoint redo location used as a starting point for an online backup.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exclusiveBackup;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nonExclusiveBackups;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;lastBackupStart;</font></div><div><font size="2"   >} XLogCtlInsert;</font></div></div><p></p></pre></div><div><br></div><div><br></div><div><br></div><div><br></div></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL pg_current_xlog_insert_location()  pg_current_xlog_location() diff - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>