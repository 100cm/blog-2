<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">attention : update TABLE use WHERE CURRENT OF</h2>
	<h5 id="">2011-11-25 14:22:40&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402011102521151980/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>当需要按ROW来处理数据时，游标会比较适合。</div><div><div>例如前段时间提到的案例 :&nbsp;</div><div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201110314133817/"  >http://blog.163.com/digoal@126/blog/static/163877040201110314133817/</a></div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201110982243362/"  >http://blog.163.com/digoal@126/blog/static/163877040201110982243362/</a></div></div></div><div><br></div><div>语法 :&nbsp;</div><div><div>[ WITH [ RECURSIVE ] with_query [, ...] ]</div><div>UPDATE [ ONLY ] table [ [ AS ] alias ]</div><div>&nbsp; &nbsp; SET { column = { expression | DEFAULT } |</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( column [, ...] ) = ( { expression | DEFAULT } [, ...] ) } [, ...]</div><div>&nbsp; &nbsp; [ FROM from_list ]</div><div>&nbsp; &nbsp; [ WHERE condition | WHERE CURRENT OF cursor_name ]</div><div>&nbsp; &nbsp; [ RETURNING * | output_expression [ [ AS ] output_name ] [, ...] ]</div></div><div><br></div><div>游标定位行使用的是tuple_tableoid和tuple_tid。</div><div><br></div><div>如果需要更新游标定位到的记录，有一个需要注意的问题。</div><div>1. 定义游标的SQL 带了 FOR UPDATE .</div><div>2. 定义游标的SQL 没有带 FOR UPDATE .&nbsp;</div><div>在更新这两种游标的时候数据库处理是不一样的 :&nbsp;</div><div>&nbsp; 当更新没有for update打开的游标时，更新可能会报这样的错误 :&nbsp;</div><div>&nbsp; "cursor \"%s\" is not a simply updatable scan of table \"%s\"",cursor_name, table_name</div><div><br></div><div>原因是,</div><div>以下摘自src/backend/executor/execCurrent.c</div><div><div>/*</div><div>&nbsp;* execCurrentOf</div><div>&nbsp;*</div><div>&nbsp;* Given a CURRENT OF expression and the OID of a table, determine which row</div><div>&nbsp;* of the table is currently being scanned by the cursor named by CURRENT OF,</div><div>&nbsp;* and return the row's TID into *current_tid.</div><div>&nbsp;*</div><div>&nbsp;* Returns TRUE if a row was identified. &nbsp;Returns FALSE if the cursor is valid</div><div>&nbsp;* for the table but is not currently scanning a row of the table (this is a</div><div>&nbsp;* legal situation in inheritance cases). &nbsp;Raises error if cursor is not a</div><div>&nbsp;* valid updatable scan of the specified table.</div><div>&nbsp;*/</div></div><div><div>&nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We have two different strategies depending on whether the cursor uses</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* FOR UPDATE/SHARE or not. &nbsp;The reason for supporting both is that the</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* FOR UPDATE code is able to identify a target table in many cases where</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the other code can't, while the non-FOR-UPDATE case allows use of WHERE</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* CURRENT OF with an insensitive cursor.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div></div><div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Without FOR UPDATE, we dig through the cursor's plan to find the</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* scan node. &nbsp;Fail if it's not there or buried underneath</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* aggregation.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div></div><div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanstate = search_plan_tree(queryDesc-&gt;planstate, table_oid);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!scanstate)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_INVALID_CURSOR_STATE),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("cursor \"%s\" is not a simply updatable scan of table \"%s\"",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cursor_name, table_name)));</div></div><div><div><div>/*</div><div>&nbsp;* search_plan_tree</div><div>&nbsp;*</div><div>&nbsp;* Search through a PlanState tree for a scan node on the specified table.</div><div>&nbsp;* Return NULL if not found or multiple candidates.</div><div>&nbsp;*/</div><div>static ScanState *</div><div>search_plan_tree(PlanState *node, Oid table_oid)</div><div>{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (node == NULL)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; switch (nodeTag(node))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* scan nodes can all be treated alike</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case T_SeqScanState:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case T_IndexScanState:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case T_BitmapHeapScanState:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case T_TidScanState:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanState &nbsp;*sstate = (ScanState *) node;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (RelationGetRelid(sstate-&gt;ss_currentRelation) == table_oid)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return sstate;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* For Append, we must look through the members; watch out for</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* multiple matches (possible if it was from UNION ALL)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case T_AppendState:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AppendState *astate = (AppendState *) node;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanState &nbsp;*result = NULL;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; astate-&gt;as_nplans; i++)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanState &nbsp;*elem = search_plan_tree(astate-&gt;appendplans[i],</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_oid);</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!elem)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (result)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL; &nbsp; &nbsp;/* multiple matches */</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = elem;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return result;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Similarly for MergeAppend</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case T_MergeAppendState:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MergeAppendState *mstate = (MergeAppendState *) node;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanState &nbsp;*result = NULL;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; mstate-&gt;ms_nplans; i++)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanState &nbsp;*elem = search_plan_tree(mstate-&gt;mergeplans[i],</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_oid);</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!elem)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (result)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL; &nbsp; &nbsp;/* multiple matches */</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = elem;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return result;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Result and Limit can be descended through (these are safe</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* because they always return their input's current row)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case T_ResultState:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case T_LimitState:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return search_plan_tree(node-&gt;lefttree, table_oid);</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* SubqueryScan too, but it keeps the child in a different place</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case T_SubqueryScanState:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return search_plan_tree(((SubqueryScanState *) node)-&gt;subplan,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_oid);</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Otherwise, assume we can't descend through it */</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return NULL;</div><div>}</div></div><div>以下摘自src/backend/commands/explain.c</div><div>/*</div><div>&nbsp;* ExplainNode -</div><div>&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;Appends a description of a plan tree to es-&gt;str</div><div>&nbsp;*</div><div>&nbsp;* planstate points to the executor state node for the current plan node.</div><div>&nbsp;* We need to work from a PlanState node, not just a Plan node, in order to</div><div>&nbsp;* get at the instrumentation data (if any) as well as the list of subplans.</div><div>&nbsp;*</div><div>&nbsp;* ancestors is a list of parent PlanState nodes, most-closely-nested first.</div><div>&nbsp;* These are needed in order to interpret PARAM_EXEC Params.</div><div>&nbsp;*</div><div>&nbsp;* relationship describes the relationship of this plan node to its parent</div><div>&nbsp;* (eg, "Outer", "Inner"); it can be null at top level. &nbsp;plan_name is an</div><div>&nbsp;* optional name to be attached to the node.</div><div>&nbsp;*</div><div>&nbsp;* In text format, es-&gt;indent is controlled in this function since we only</div><div>&nbsp;* want it to change at plan-node boundaries. &nbsp;In non-text formats, es-&gt;indent</div><div>&nbsp;* corresponds to the nesting depth of logical output groups, and therefore</div><div>&nbsp;* is controlled by ExplainOpenGroup/ExplainCloseGroup.</div><div>&nbsp;*/</div></div><div><br></div><div>这个问题TOM LANE在PG nabble也做过解释，如下 :&nbsp;</div><div><a rel="nofollow" href="http://postgresql.1045698.n5.nabble.com/quot-ORDER-BY-quot-clause-prevents-quot-UPDATE-WHERE-CURRENT-OF-quot-td1994821.html"  >http://postgresql.1045698.n5.nabble.com/quot-ORDER-BY-quot-clause-prevents-quot-UPDATE-WHERE-CURRENT-OF-quot-td1994821.html</a></div><div><br></div><div><div>After playing around with this for awhile I realized that there really&nbsp;</div><div>would be a functional loss if we remove support for WHERE CURRENT OF&nbsp;</div><div>with non-FOR-UPDATE cursors. &nbsp;Namely, that a non-FOR-UPDATE cursor is&nbsp;</div><div>insensitive to subsequent updates, which sometimes is handy. &nbsp;There are&nbsp;</div><div>examples of both cases in the portals.sql regression test.&nbsp;</div><div><br></div><div>So what I now propose is:&nbsp;</div><div><br></div><div>1. If the cursor includes FOR UPDATE/FOR SHARE, use the ExecRowMark&nbsp;</div><div>technique to get the target row identity. &nbsp;In this path we fail if there&nbsp;</div><div>is not exactly one FOR UPDATE reference to the UPDATE's target table.&nbsp;</div><div>(An interesting property here is that you can update from a self-join,&nbsp;</div><div>if you mark only one arm of the join as FOR UPDATE. &nbsp;See example in&nbsp;</div><div>attached regression test additions.)&nbsp;</div><div><br></div><div>2. If the cursor doesn't have FOR UPDATE/SHARE, use the existing code.&nbsp;</div><div>In this path we fail if the plan is "too complicated". &nbsp;However, it&nbsp;</div><div>shouldn't fail for any case that is simply updatable according to the&nbsp;</div><div>SQL spec.&nbsp;</div><div><br></div><div>We should revise the documentation to make it very clear that FOR UPDATE&nbsp;</div><div>is the preferred way, but that sometimes you might need the other.&nbsp;</div><div><br></div><div>Attached is a draft patch that is code-complete but lacks documentation.&nbsp;</div><div>The patch is against CVS HEAD, ie, it assumes the SELECT FOR UPDATE&nbsp;</div><div>inheritance fixes I made earlier today.&nbsp;</div></div><div><br></div><div>所以在有需求使用where current of来更新ROW记录时，最好是用for update 来定义游标.</div><div><br></div><div>【参考】</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201110314133817/"  >http://blog.163.com/digoal@126/blog/static/163877040201110314133817/</a></div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201110982243362/"  >http://blog.163.com/digoal@126/blog/static/163877040201110982243362/</a></div><div>src/backend/executor/execCurrent.c</div><div>src/backend/commands/explain.c</div></div>
	</div>
</div>
</body>
</html>