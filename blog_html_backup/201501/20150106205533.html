<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL return result "row by row" or "once all"? please see pg driver</h2>
	<h5 id="">2015-01-06 20:55:33&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020150683828221/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>在PostgreSQL中, 执行一条SQL语句时, 数据是一次性返回还是逐条返回显示的呢?</div><div>这里有一个问题, 如果是逐条返回, 可能返回到中途时出现异常例如网络中断, 那么客户端需要有处理这种异常的能力.</div><div>而如果是一次性返回所有结果集的话, 即数据库驱动将所有数据保存到本地后返回给客户端, 那么不会出现上述问题, 但是其他问题又来了, 如果结果集很大的话, 要等到第一条数据的显示可能要很久, 或者有可能导致本地的内存溢出.</div><div>我们来看看以下几种客户端的返回形态.</div><div>1. psql</div><div>默认情况下是一次性返回, 除非你设置了FETCH_COUNT, 那么是逐条返回的.(使用游标, autocommit=false的模式)</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \set FETCH_COUNT 1</font></div><div><font size="2"   >postgres=# select * from mod;</font></div><div><font size="2"   >&nbsp; &nbsp; id &nbsp; &nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;17718227</font></div><div><font size="2"   >&nbsp;17718228</font></div><div><font size="2"   >&nbsp;17718229</font></div><div><font size="2"   >&nbsp;17718230</font></div><div><font size="2"   >&nbsp;17718231</font></div><div><font size="2"   >&nbsp;17718232</font></div><p></p></pre></div><div>迅速就能看到结果.</div><div>而<span style="line-height: 28px;"   >postgres=# \set FETCH_COUNT 10000000, 要等很久才能看到结果, 因为需要LOAD</span><span style="line-height: 28px;"   >10000000条后才返回.</span></div><div><span style="line-height: 28px;"   >而不设置</span><span style="line-height: 28px;"   >FETCH_COUNT</span><span style="line-height: 28px;"   >&nbsp;的话, 需要返回所有结果集才返回.</span></div><div><span style="line-height: 28px;"   >具体可以见 :&nbsp;</span></div><div><span style="line-height: 28px;"   >src/bin/psql/startup.c&nbsp;</span></div><div><span style="line-height: 28px;"   >src/bin/psql/common.c</span></div><div><br></div><div>2. jdbc</div><div>如果要逐条返回, 可参见</div><div><a target="_blank" rel="nofollow" href="http://jdbc.postgresql.org/documentation/93/query.html"   >http://jdbc.postgresql.org/documentation/93/query.html</a></div><div>逐条返回使用游标接收数据, 必须使用autocommit=false模式.</div><div>例子</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >// make sure autocommit is off</font></div><div><font size="2"   >conn.setAutoCommit(false);</font></div><div><font size="2"   >Statement st = conn.createStatement();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >// Turn use of the cursor on.</font></div><div><font size="2"   >st.setFetchSize(50);</font></div><div><font size="2"   >ResultSet rs = st.executeQuery("SELECT * FROM mytable");</font></div><div><font size="2"   >while (rs.next())</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp;System.out.print("a row was returned.");</font></div><div><font size="2"   >}</font></div><div><font size="2"   >rs.close();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >// Turn the cursor off.</font></div><div><font size="2"   >st.setFetchSize(0);</font></div><div><font size="2"   >rs = st.executeQuery("SELECT * FROM mytable");</font></div><div><font size="2"   >while (rs.next())</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp;System.out.print("many rows were returned.");</font></div><div><font size="2"   >}</font></div><div><font size="2"   >rs.close();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >// Close the statement.</font></div><div><font size="2"   >st.close();</font></div><p></p></pre></div><div><br></div><div>3. dblink</div><div>使用的是逐行返回模式, 详见dblink.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Execute the given SQL command and store its results into a tuplestore</font></div><div><font size="2"   >&nbsp;* to be returned as the result of the current function.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This is equivalent to PQexec followed by materializeResult, but we make</font></div><div><font size="2"   >&nbsp;* use of libpq's single-row mode to avoid accumulating the whole result</font></div><div><font size="2"   >&nbsp;* inside libpq before it gets transferred to the tuplestore.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static void</font></div><div><font size="2"   >materializeQueryResult(FunctionCallInfo fcinfo,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PGconn *conn,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const char *conname,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const char *sql,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bool fail)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >..................</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Execute query, and send any result rows to sinfo-&gt;tuplestore.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static PGresult *</font></div><div><font size="2"   >storeQueryResult(storeInfo *sinfo, PGconn *conn, const char *sql)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;first = true;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestlevel = -1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PGresult &nbsp; *res;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!PQsendQuery(conn, sql))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "could not send query: %s", PQerrorMessage(conn));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!PQsetSingleRowMode(conn)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* shouldn't fail */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "failed to set single-row mode for dblink query");</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >....</font></div><div><font size="2"   >for (;;)<br>        {<br>                CHECK_FOR_INTERRUPTS();<br><br>                sinfo-&gt;cur_res = PQgetResult(conn);<br>                if (!sinfo-&gt;cur_res)<br>                        break;<br><br>                if (PQresultStatus(sinfo-&gt;cur_res) == PGRES_SINGLE_TUPLE)<br>                {<br>                        /* got one row from possibly-bigger resultset */<br><br>                        /*<br>                         * Set GUCs to ensure we read GUC-sensitive data types correctly.<br>                         * We shouldn't do this until we have a row in hand, to ensure<br>                         * libpq has seen any earlier ParameterStatus protocol messages.<br>                         */<br>                        if (first &amp;&amp; nestlevel &lt; 0)<br>                                nestlevel = applyRemoteGucs(conn);<br><br>                        storeRow(sinfo, sinfo-&gt;cur_res, first);<br><br>                        PQclear(sinfo-&gt;cur_res);<br>                        sinfo-&gt;cur_res = NULL;<br>                        first = false;<br>                }<br>                else<br>                {<br>                        /* if empty resultset, fill tuplestore header */<br>                        if (first &amp;&amp; PQresultStatus(sinfo-&gt;cur_res) == PGRES_TUPLES_OK)<br>                                storeRow(sinfo, sinfo-&gt;cur_res, first);<br><br>                        /* store completed result at last_res */<br>                        PQclear(sinfo-&gt;last_res);<br>                        sinfo-&gt;last_res = sinfo-&gt;cur_res;<br>                        sinfo-&gt;cur_res = NULL;<br>                        first = true;<br>                }</font></div><p></p></pre></div><div><br></div><div>4. pgadmin</div><div>参见src, 下载源码太慢还没来得及看.</div><div>如果使用libpq的话, 使用了PQsetSingleRowMode那么就是逐条返回的.</div><div>使用jdbc的话, 参考jdbc api. 看看是否调用了setFetchSize.</div><div><br></div><div>5. libpq</div><div>如果要逐条返回, 参见</div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/libpq-single-row-mode.html"   >http://www.postgresql.org/docs/9.4/static/libpq-single-row-mode.html</a></div><div>设置当前连接使用逐条返回模式</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >int PQsetSingleRowMode(PGconn *conn);</font></div><div></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://jdbc.postgresql.org/documentation/93/query.html"   >http://jdbc.postgresql.org/documentation/93/query.html</a></div><div><br></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/libpq-single-row-mode.html"   >http://www.postgresql.org/docs/9.4/static/libpq-single-row-mode.html</a></div><div><br></div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/libpq-async.html"   >http://www.postgresql.org/docs/9.4/static/libpq-async.html</a></div><div><br></div><div>4. man psql</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FETCH_COUNT</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If this variable is set to an integer value &gt; 0, the results of SELECT queries are fetched and displayed in</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;groups of that many rows, rather than the default behavior of collecting the entire result set before display.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Therefore only a limited amount of memory is used, regardless of the size of the result set. Settings of 100 to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1000 are commonly used when enabling this feature. Keep in mind that when using this feature, a query might fail</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;after having already displayed some rows.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Tip</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Although you can use any output format with this feature, the default aligned format tends to look bad</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;because each group of FETCH_COUNT rows will be formatted separately, leading to varying column widths across</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the row groups. The other output formats work better.</font></div><p></p></pre></div><div><br></div><div>5. src/bin/psql/common.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (pset.fetch_count &lt;= 0 || !is_select_command(query))</font></div><div><font size="2"   >.......</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Fetch-in-segments mode */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OK = ExecQueryUsingCursor(query, &amp;elapsed_msec);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResetCancelConn();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; results = NULL; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* PQclear(NULL) does nothing */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><div><font size="2"   >........</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; for (;;)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pset.timing)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(before);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* get fetch_count tuples at a time */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; results = PQexec(pset.db, fetch_cmd);</font></div></div><p></p></pre></div><div><br></div><div>6.&nbsp;<span style="line-height: 28px;"   >src/bin/psql/startup.c</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >static void</font></div><div><font size="2"   >fetch_count_hook(const char *newval)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pset.fetch_count = ParseVariableNum(newval, -1, -1, false);</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   >....</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SetVariableAssignHook(pset.vars, "FETCH_COUNT", fetch_count_hook);</font></div><p></p></pre></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL return result row by row or once all? please see pg driver - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">Freya - 2015-01-07 17:58:53</h5>
				<div>德哥v5啊,发现好久没写blog了，向德哥学习....</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 Freya - 2015-01-07 17:58:53</h5>
				<div style="width:600px;">老了, 写不动了.<img src="http://b.bst.126.net/common/portrait/face/preview/face1.gif"  ></div>
			</div>
			<div id="">
				<h5 id="">xmarker - 2015-01-07 15:55:20</h5>
				<div>德哥，我用psql测试，设置了fetch_count怎么返回数据速度也是很快呢？<div><div>postgres:/home/postgres@db164&gt;psql</div><div>psql (9.3.5)</div><div>Type "help" for help.</div><div><br></div><div>postgres=# \timing on</div><div>Timing is on.</div><div>postgres=# select * from t6;</div><div>&nbsp;id | &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp; &nbsp;</div><div>----+----------------</div><div>&nbsp; 1 | aaa</div><div>&nbsp; 2 |&nbsp;</div><div>&nbsp; 3 | 中华人民共和国</div><div>&nbsp; &nbsp; | bbb</div><div>&nbsp; 5 | bbb</div><div>(5 rows)</div><div><br></div><div>Time: 1.176 ms</div><div>postgres=# \set FETCH_COUNT 10000000;</div><div>postgres=# select * from t6;</div><div>&nbsp;id | &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp; &nbsp;</div><div>----+----------------</div><div>&nbsp; 1 | aaa</div><div>&nbsp; 2 |&nbsp;</div><div>&nbsp; 3 | 中华人民共和国</div><div>&nbsp; &nbsp; | bbb</div><div>&nbsp; 5 | bbb</div><div>(5 rows)</div><div><br></div><div>Time: 0.360 ms</div></div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 xmarker - 2015-01-07 15:55:20</h5>
				<div style="width:600px;">HI, 那是因为你总共就5条记录啊.</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 xmarker - 2015-01-07 15:55:20</h5>
				<div style="width:600px;">你搞1亿条试试, 设置fetch_count=1和=1000000000<div>差别就出来了.</div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">xmarker 回复 德哥@Digoal - 2015-01-07 15:55:20</h5>
				<div style="width:600px;">知道了，多谢！<img src="http://b.bst.126.net/common/portrait/face/preview/face0.gif"  ></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 xmarker - 2015-01-07 15:55:20</h5>
				<div style="width:600px;"><img src="http://b.bst.126.net/common/portrait/face/preview/face0.gif"  >嘿嘿</div>
			</div>
	</div>
</div>
</body>
</html>