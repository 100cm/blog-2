<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL Why checkpointer impact performance so much ? - 1</h2>
	<h5 id="">2015-05-06 15:19:43&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201542103933969/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>检查点，通俗的理解就是数据库处于数据一致性，完整性的点。</div><div>因此在这个点之前提交的事务确保数据已经写入数据文件，事务状态已经写入pg_clog文件。</div><div><span style="line-height: 28px;"   >通常创建检查点会需要一个漫长的过程，那么怎么保证数据的一致性和完整性呢？</span></div><div>从数据恢复（XLOG）的角度来看，<span style="line-height: 28px;"   >检查点在XLOG文件中分为两个位置，一个是逻辑位置，一个是物理位置。</span></div><div>逻辑位置即开始位置，也是一致性位置，在这个位置之前已提交的事务，确保它们的事务状态和脏数据都已经写入持久化存储。</div><div>物理位置即结束位置，因为做检查点时，需要将逻辑位置之前已提交事务的<span style="line-height: 28px;"   >事务状态和脏数据都写入持久化存储，这个需要一个过程，这些刷脏页面和CLOG的动作同样会产生XLOG，所以这一系列动作完成后，就是检查点结束的位置，即物理位置</span><span style="line-height: 28px;"   >。</span></div><div><span style="line-height: 28px;"   >从逻辑角度来看，这两个XLOG位置实际是同一个位置，所以在做数据恢复时，先找到检查点的XLOG物理位置，然后根据这里的结束检查点时写入的XLOG信息找到逻辑位置，从逻辑位置开始，读取XLOG并实施xlog replay恢复，至少要恢复到XLOG物理位置才能确保数据库的一致性和完整性。</span></div><div>如图：</div><div>创建检查点示意图：</div><div><div><img title="PostgreSQL Why checkpointer impact performance so much ? - 1 - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL Why checkpointer impact performance so much ? - 1 - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img0.ph.126.net/QiFzTQOxIStbW77QlaV--Q==/2438980673215988805.png"   ></div><br></div><div>数据恢复示意图：</div><div><div><img title="PostgreSQL Why checkpointer impact performance so much ? - 1 - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL Why checkpointer impact performance so much ? - 1 - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img1.ph.126.net/Ic604T-KbwCczYZ5r3Uyvw==/2814749767124526178.png"   ></div></div><div><span style="line-height: 28px;"   >当然，检查点不仅仅是刷脏数据这么简单，还有其他一些操作，见下面的分析。</span></div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >checkpointer process 介绍，挑选了一些关键步骤进行讲解：</span></div><div><span style="line-height: 28px;"   >CheckpointerMain@src/</span><span style="line-height: 28px;"   >backend/postmaster/checkpointer.c</span></div><div>接收检查点请求：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp;365 &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp;366 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Process any requests or signals received recently.</font></div><div><font size="2"   >&nbsp;367 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp;368 &nbsp; &nbsp; &nbsp; &nbsp; AbsorbFsyncRequests();</font></div></div><div><font size="2"   >......<br></font><div><font size="2"   >&nbsp;388 &nbsp; &nbsp; &nbsp; &nbsp; if (checkpoint_requested)</font></div><div><font size="2"   >&nbsp;389 &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp;390 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkpoint_requested = false;</font></div><div><font size="2"   >&nbsp;391 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_checkpoint = true;</font></div><div><font size="2"   >&nbsp;392 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BgWriterStats.m_requested_checkpoints++;</font></div><div><font size="2"   >&nbsp;393 &nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >超时(</span>checkpoint_timeout参数<span style="line-height: 28px;"   >)触发检查点：</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp;407 &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp;408 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Force a checkpoint if too much time has elapsed since the last one.</font></div><div><font size="2"   >&nbsp;409 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note that we count a timed checkpoint in stats only when this</font></div><div><font size="2"   >&nbsp;410 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* occurs without an external request, but we set the CAUSE_TIME flag</font></div><div><font size="2"   >&nbsp;411 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* bit even if there is also an external request.</font></div><div><font size="2"   >&nbsp;412 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp;413 &nbsp; &nbsp; &nbsp; &nbsp; now = (pg_time_t) time(NULL);</font></div><div><font size="2"   >&nbsp;414 &nbsp; &nbsp; &nbsp; &nbsp; elapsed_secs = now - last_checkpoint_time;</font></div><div><font size="2"   >&nbsp;415 &nbsp; &nbsp; &nbsp; &nbsp; if (elapsed_secs &gt;= CheckPointTimeout)</font></div><div><font size="2"   >&nbsp;416 &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp;417 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!do_checkpoint)</font></div><div><font size="2"   >&nbsp;418 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BgWriterStats.m_timed_checkpoints++;</font></div><div><font size="2"   >&nbsp;419 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_checkpoint = true;</font></div><div><font size="2"   >&nbsp;420 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= CHECKPOINT_CAUSE_TIME;</font></div><div><font size="2"   >&nbsp;421 &nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><div><font size="2"   >......</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >进入检查点，记录检查点的逻辑位置（即开始位置的XLOG OFFSET），调用</span><span style="line-height: 28px;"   >CreateCheckPoint创建检查点。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp;423 &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp;424 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Do a checkpoint if requested.</font></div><div><font size="2"   >&nbsp;425 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp;426 &nbsp; &nbsp; &nbsp; &nbsp; if (do_checkpoint)</font></div><div><font size="2"   >&nbsp;427 &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp;428 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;ckpt_performed = false;</font></div><div><font size="2"   >&nbsp;429 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;do_restartpoint;</font></div><div><font size="2"   >&nbsp;430&nbsp;</font></div><div><font size="2"   >&nbsp;431 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* use volatile pointer to prevent code rearrangement */</font></div><div><font size="2"   >&nbsp;432 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; volatile CheckpointerShmemStruct *cps = CheckpointerShmem;</font></div><div><font size="2"   >&nbsp;433&nbsp;</font></div><div><font size="2"   >&nbsp;434 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp;435 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check if we should perform a checkpoint or a restartpoint. As a</font></div><div><font size="2"   >&nbsp;436 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* side-effect, RecoveryInProgress() initializes TimeLineID if</font></div><div><font size="2"   >&nbsp;437 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* it's not set yet.</font></div><div><font size="2"   >&nbsp;438 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp;439 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_restartpoint = RecoveryInProgress();</font></div><div><font size="2"   >&nbsp;440&nbsp;</font></div><div><font size="2"   >&nbsp;441 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp;442 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Atomically fetch the request flags to figure out what kind of a</font></div><div><font size="2"   >&nbsp;443 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* checkpoint we should perform, and increase the started-counter</font></div><div><font size="2"   >&nbsp;444 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to acknowledge that we've started a new checkpoint.</font></div><div><font size="2"   >&nbsp;445 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp;446 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;cps-&gt;ckpt_lck);</font></div><div><font size="2"   >&nbsp;447 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= cps-&gt;ckpt_flags;</font></div><div><font size="2"   >&nbsp;448 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cps-&gt;ckpt_flags = 0;</font></div><div><font size="2"   >&nbsp;449 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cps-&gt;ckpt_started++;</font></div><div><font size="2"   >&nbsp;450 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;cps-&gt;ckpt_lck);</font></div><div><font size="2"   >&nbsp;451&nbsp;</font></div><div><font size="2"   >&nbsp;452 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp;453 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The end-of-recovery checkpoint is a real checkpoint that's</font></div><div><font size="2"   >&nbsp;454 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* performed while we're still in recovery.</font></div><div><font size="2"   >&nbsp;455 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp;456 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (flags &amp; CHECKPOINT_END_OF_RECOVERY)</font></div><div><font size="2"   >&nbsp;457 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_restartpoint = false;</font></div><div><font size="2"   >&nbsp;458&nbsp;</font></div><div><font size="2"   >&nbsp;459 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp;460 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We will warn if (a) too soon since last checkpoint (whatever</font></div><div><font size="2"   >&nbsp;461 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* caused it) and (b) somebody set the CHECKPOINT_CAUSE_XLOG flag</font></div><div><font size="2"   >&nbsp;462 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* since the last checkpoint start. &nbsp;Note in particular that this</font></div><div><font size="2"   >&nbsp;463 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* implementation will not generate warnings caused by</font></div><div><font size="2"   >&nbsp;464 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* CheckPointTimeout &lt; CheckPointWarning.</font></div><div><font size="2"   >&nbsp;465 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp;466 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!do_restartpoint &amp;&amp;</font></div><div><font size="2"   >&nbsp;467 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_CAUSE_XLOG) &amp;&amp;</font></div><div><font size="2"   >&nbsp;468 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsed_secs &lt; CheckPointWarning)</font></div><div><font size="2"   >&nbsp;469 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,</font></div><div><font size="2"   >&nbsp;470 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg_plural("checkpoints are occurring too frequently (%d second apart)",</font></div><div><font size="2"   >&nbsp;471 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "checkpoints are occurring too frequently (%d seconds apart)",</font></div><div><font size="2"   >&nbsp;472 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;elapsed_secs,</font></div><div><font size="2"   >&nbsp;473 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;elapsed_secs),</font></div><div><font size="2"   >&nbsp;474 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("Consider increasing the configuration parameter \"max_wal_size\".")));</font></div><div><font size="2"   >&nbsp;475&nbsp;</font></div><div><font size="2"   >&nbsp;476 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp;477 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Initialize checkpointer-private variables used during</font></div><div><font size="2"   >&nbsp;478 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* checkpoint</font></div><div><font size="2"   >&nbsp;479 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp;480 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_active = true;</font></div><div><font size="2"   >&nbsp;481 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!do_restartpoint)</font></div><div><font size="2"   >&nbsp;482 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_start_recptr = GetInsertRecPtr(); &nbsp; &nbsp; // 记录检查点开始前的XLOG位置,用于检查点调度判断</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// &nbsp;不要和逻辑位置混淆，这还不是。</font></div><div><font size="2"   >&nbsp;483 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_start_time = now;</font></div><div><font size="2"   >&nbsp;484 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_cached_elapsed = 0;</font></div><div><font size="2"   >&nbsp;485&nbsp;</font></div><div><font size="2"   >&nbsp;486 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp;487 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Do the checkpoint.</font></div><div><font size="2"   >&nbsp;488 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp;489 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!do_restartpoint)</font></div><div><font size="2"   >&nbsp;490 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp;491 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CreateCheckPoint(flags); &nbsp; &nbsp;// 创建检查点</font></div><div><font size="2"   >&nbsp;492 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_performed = true;</font></div><div><font size="2"   >&nbsp;493 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp;494 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp;495 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_performed = CreateRestartPoint(flags);</font></div><div><font size="2"   >&nbsp;496&nbsp;</font></div><div><font size="2"   >&nbsp;497 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp;498 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* After any checkpoint, close all smgr files. &nbsp;This is so we</font></div><div><font size="2"   >&nbsp;499 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* won't hang onto smgr references to deleted files indefinitely.</font></div><div><font size="2"   >&nbsp;500 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp;501 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smgrcloseall();</font></div><div><font size="2"   >&nbsp;502&nbsp;</font></div><div><font size="2"   >&nbsp;503 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp;504 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Indicate checkpoint completion to any waiting backends.</font></div><div><font size="2"   >&nbsp;505 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp;506 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;cps-&gt;ckpt_lck);</font></div><div><font size="2"   >&nbsp;507 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cps-&gt;ckpt_done = cps-&gt;ckpt_started;</font></div><div><font size="2"   >&nbsp;508 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;cps-&gt;ckpt_lck);</font></div><div><font size="2"   >&nbsp;509&nbsp;</font></div><div><font size="2"   >&nbsp;510 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ckpt_performed)</font></div><div><font size="2"   >&nbsp;511 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp;512 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp;513 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note we record the checkpoint start time not end time as</font></div><div><font size="2"   >&nbsp;514 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* last_checkpoint_time. &nbsp;This is so that time-driven</font></div><div><font size="2"   >&nbsp;515 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* checkpoints happen at a predictable spacing.</font></div><div><font size="2"   >&nbsp;516 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp;517 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_checkpoint_time = now;</font></div><div><font size="2"   >&nbsp;518 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp;519 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp;520 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp;521 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp;522 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We were not able to perform the restartpoint (checkpoints</font></div><div><font size="2"   >&nbsp;523 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* throw an ERROR in case of error). &nbsp;Most likely because we</font></div><div><font size="2"   >&nbsp;524 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* have not received any new checkpoint WAL records since the</font></div><div><font size="2"   >&nbsp;525 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* last restartpoint. Try again in 15 s.</font></div><div><font size="2"   >&nbsp;526 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp;527 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_checkpoint_time = now - CheckPointTimeout + 15;</font></div><div><font size="2"   >&nbsp;528 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp;529&nbsp;</font></div><div><font size="2"   >&nbsp;530 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_active = false;</font></div><div><font size="2"   >&nbsp;531 &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >记录检查点开始前的XLOG位置, 用于检查点调度,和逻辑位置无关。</span></div><div><span style="line-height: 28px;"   >GetInsertRecPtr@src/</span><span style="line-height: 28px;"   >backend/access/transam/xlog.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* GetInsertRecPtr -- Returns the current insert position.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* NOTE: The value *actually* returned is the position of the last full</font></div><div><font size="2"   >&nbsp;* xlog page. It lags behind the real insert position by at most 1 page.</font></div><div><font size="2"   >&nbsp;* For that, we don't need to scan through WAL insertion locks, and an</font></div><div><font size="2"   >&nbsp;* approximation is enough for the current usage of this function.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >XLogRecPtr</font></div><div><font size="2"   >GetInsertRecPtr(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* use volatile pointer to prevent code rearrangement */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; volatile XLogCtlData *xlogctl = XLogCtl;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;recptr;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;xlogctl-&gt;info_lck);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; recptr = xlogctl-&gt;LogwrtRqst.Write; &nbsp; &nbsp;// &nbsp; 写入并返回XLOG位置</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;xlogctl-&gt;info_lck);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return recptr;</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>检查点调度</div><div>IsCheckpointOnSchedule@src/backend/postmaster/checkpointer.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* IsCheckpointOnSchedule -- are we on schedule to finish this checkpoint</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in time?</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Compares the current progress against the time/segments elapsed since last</font></div><div><font size="2"   >&nbsp;* checkpoint, and returns true if the progress we've made this far is greater</font></div><div><font size="2"   >&nbsp;* than the elapsed time/segments.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static bool</font></div><div><font size="2"   >IsCheckpointOnSchedule(double progress)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;recptr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct timeval now;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;elapsed_xlogs,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsed_time;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(ckpt_active);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Scale progress according to checkpoint_completion_target. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; progress *= CheckPointCompletionTarget; &nbsp; //&nbsp;<span style="line-height: 28px;"   >checkpoint_completion_target 参数控制系数，所以系数越大，progress越大。</span></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check against the cached value first. Only do the more expensive</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* calculations once we reach the target previously calculated. Since</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* neither time or WAL insert pointer moves backwards, a freshly</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* calculated value can only be greater than or equal to the cached value.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (progress &lt; ckpt_cached_elapsed)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;  // 返回false，checkpointer不休息</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check progress against WAL segments written and checkpoint_segments.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We compare the current WAL insert location against the location</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* computed before calling CreateCheckPoint. The code in XLogInsert that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* actually triggers a checkpoint when checkpoint_segments is exceeded</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* compares against RedoRecptr, so this is not completely accurate.</font></div></div>ca<div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* However, it's good enough for our purposes, we're only calculating an</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* estimate anyway.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!RecoveryInProgress())</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = GetInsertRecPtr();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsed_xlogs = (((double) (recptr - ckpt_start_recptr)) / XLogSegSize) / CheckPointSegments;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;<span style="line-height: 28px;"   >CheckPointSegments由参数</span>checkpoint_segments控制.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;<span style="line-height: 28px;"   >checkpoint_completion_target</span><span style="line-height: 28px;"   >&nbsp;是0-1的范围</span></font></div><div><font size="2"   ><span style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;</span><span style="line-height: 28px;"   >checkpoint_segments是触发检查点的XLOG个数，</span></font></div><div><font size="2"   ><span style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;假设</span><span style="line-height: 28px;"   >checkpoint_completion_target</span><span style="line-height: 28px;"   >&nbsp;= 0.1, progress传入参数=1, 那么</span></font></div><div><font size="2"   ><span style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;</span><span style="line-height: 28px;"   >checkpoint_segments=100, 那么每产生 0.1×100=10个XLOG文件后, checkpointer要休息一下，以免对性能造成太大影响</span></font></div><div><font size="2"   ><span style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //   checkpointer休息多久由</span>CheckpointWriteDelay函数来控制。</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (progress &lt; elapsed_xlogs)  // 未达到休息点</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_cached_elapsed = elapsed_xlogs;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;  // 返回false，checkpointer不休息</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check progress against time elapsed and checkpoint_timeout.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; gettimeofday(&amp;now, NULL);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; elapsed_time = ((double) ((pg_time_t) now.tv_sec - ckpt_start_time) +</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; now.tv_usec / 1000000.0) / CheckPointTimeout;  //  另一个判断依据是检查点耗时和<span style="line-height: 21px;"   >checkpoint_timeout参数。</span></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (progress &lt; elapsed_time)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_cached_elapsed = elapsed_time;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* It looks like we're on schedule. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >检查点调度的另一个函数，处理延迟逻辑，每次100毫秒：</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* CheckpointWriteDelay -- control rate of checkpoint</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This function is called after each page write performed by BufferSync().</font></div><div><font size="2"   >&nbsp;* It is responsible for throttling BufferSync()'s write rate to hit</font></div><div><font size="2"   >&nbsp;* checkpoint_completion_target.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The checkpoint request flags should be passed in; currently the only one</font></div><div><font size="2"   >&nbsp;* examined is CHECKPOINT_IMMEDIATE, which disables delays between writes.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 'progress' is an estimate of how much of the work has been done, as a</font></div><div><font size="2"   >&nbsp;* fraction between 0.0 meaning none, and 1.0 meaning all done.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >CheckpointWriteDelay(int flags, double progress)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; static int &nbsp; &nbsp; &nbsp;absorb_counter = WRITES_PER_ABSORB;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Do nothing if checkpoint is being executed by non-checkpointer process */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!AmCheckpointerProcess())</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Perform the usual duties and take a nap, unless we're behind schedule,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* in which case we just try to catch up as quickly as possible.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!(flags &amp; CHECKPOINT_IMMEDIATE) &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !shutdown_requested &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !ImmediateCheckpointRequested() &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IsCheckpointOnSchedule(progress)) &nbsp; // &nbsp;<span style="line-height: 28px;"   >IsCheckpointOnSchedule 即判断是否达到调度位置</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (got_SIGHUP)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; got_SIGHUP = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* update shmem copies of config variables */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UpdateSharedMemoryConfig();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AbsorbFsyncRequests();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; absorb_counter = WRITES_PER_ABSORB;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CheckArchiveTimeout();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Report interim activity statistics to the stats collector.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_send_bgwriter();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* This sleep used to be connected to bgwriter_delay, typically 200ms.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* That resulted in more frequent wakeups if not much work to do.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Checkpointer and bgwriter are no longer related so take the Big</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Sleep.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_usleep(100000L); &nbsp;// 休息<span style="line-height: 28px;"   >100000微秒即100毫秒</span><span style="line-height: 28px;"   >，虽然checkpointer休息了，但是bgwriter同样会在一定的时间后被唤醒，由</span><span style="line-height: 28px;"   >bgwriter_delay控制。</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else if (--absorb_counter &lt;= 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Absorb pending fsync requests after each WRITES_PER_ABSORB write</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* operations even when we don't sleep, to prevent overflow of the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* fsync request queue.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AbsorbFsyncRequests();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; absorb_counter = WRITES_PER_ABSORB;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >检查点调度的小结：</span></div><div><span style="line-height: 28px;"   >如果我们开启了检查点调度，默认是开启的，调度系数设置为0.5。</span></div><div><span style="line-height: 28px;"   >这个调度值到底是什么用意呢？</span></div><div><span style="line-height: 28px;"   >检查点的任务之一是刷脏块，例如有1000个脏块需要刷新，那么当刷到100个脏块时，progress=(100/1000)*0.5=0.05</span></div><div>如果这个时候，XLOG经历了10个文件，checkpoint_segments为100，也就是0.1</div><div>0.05&lt;0.1, 返回false, 不休息。什么情况能休息？ 当xlog经历个数比值小于等于0.05时才能休息，也就是发生在XLOG 5个或以内时。</div><div>如果调大<span style="line-height: 28px;"   >调度系数到1，那么</span><span style="line-height: 28px;"   >progress=(100/1000)*1=0.1，</span><span style="line-height: 28px;"   >当xlog经历个数比值小于等于0.1时才能休息，也就是发生在XLOG</span><span style="line-height: 28px;"   >&nbsp;10个或以内时</span><span style="line-height: 28px;"   >。</span></div><div><span style="line-height: 28px;"   >现在可以理解为，</span><span style="line-height: 28px;"   >调度系数就是休息区间系数，休息区间为</span><span style="line-height: 28px;"   >checkpoint_segments和</span>checkpoint_timeout<span style="line-height: 28px;"   >。</span></div><div><span style="line-height: 28px;"   >调度系数</span><span style="line-height: 28px;"   >越大，checkpointer休息区间越大，checkpointer可以经常休息，慢悠悠的fsync；</span></div><div><span style="line-height: 28px;"   >调度系数</span><span style="line-height: 28px;"   >越小，checkpointer休息区间越小，checkpointer只能在最初的小范围内休息，超过后就要快马加鞭了。</span></div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >创建检查点的函数：</span></div><div><span style="line-height: 28px;"   >CreateCheckPoint@src/</span><span style="line-height: 28px;"   >backend/access/transam/xlog.c</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Perform a checkpoint --- either during shutdown, or on-the-fly</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* flags is a bitwise OR of the following:</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;CHECKPOINT_IS_SHUTDOWN: checkpoint is for database shutdown.</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;CHECKPOINT_END_OF_RECOVERY: checkpoint is for end of WAL recovery.</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;CHECKPOINT_IMMEDIATE: finish the checkpoint ASAP,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ignoring checkpoint_completion_target parameter.</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;CHECKPOINT_FORCE: force a checkpoint even if no XLOG activity has occurred</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;since the last one (implied by CHECKPOINT_IS_SHUTDOWN or</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CHECKPOINT_END_OF_RECOVERY).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: flags contains other bits, of interest here only for logging purposes.</font></div><div><font size="2"   >&nbsp;* In particular note that this routine is synchronous and does not pay</font></div><div><font size="2"   >&nbsp;* attention to CHECKPOINT_WAIT.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* If !shutdown then we are writing an online checkpoint. This is a very special</font></div><div><font size="2"   >&nbsp;* kind of operation and WAL record because the checkpoint action occurs over</font></div><div><font size="2"   >&nbsp;* a period of time yet logically occurs at just a single LSN. The logical &nbsp;逻辑位置是检查点开始时的位置。</font></div><div><font size="2"   >&nbsp;* position of the WAL record (redo ptr) is the same or earlier than the</font></div><div><font size="2"   >&nbsp;* physical position. When we replay WAL we locate the checkpoint via its</font></div><div><font size="2"   >&nbsp;* physical position then read the redo ptr and actually start replay at the</font></div><div><font size="2"   >&nbsp;* earlier logical position. Note that we don't write *anything* to WAL at &nbsp;逻辑位置不写任何东西，在<span style="line-height: 28px;"   >GetInsertRecPtr这里。</span></font></div><div><font size="2"   >&nbsp;* the logical position, so that location could be any other kind of WAL record.</font></div><div><font size="2"   >&nbsp;* All of this mechanism allows us to continue working while we checkpoint. &nbsp;</font></div><div><font size="2"   >&nbsp;* As a result, timing of actions is critical here and be careful to note that</font></div><div><font size="2"   >&nbsp;* this function will likely take minutes to execute on a busy system.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >CreateCheckPoint(int flags)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* use volatile pointer to prevent code rearrangement */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; volatile XLogCtlData *xlogctl = XLogCtl;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shutdown;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPoint &nbsp; &nbsp; &nbsp;checkPoint;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;recptr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogCtlInsert *Insert = &amp;XLogCtl-&gt;Insert;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecData rdata;</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;freespace;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo &nbsp; &nbsp; &nbsp; _logSegNo;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;curInsert;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId *vxids;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nvxids;</font></div></div><div><font size="2"   >......</font></div><p></p></pre></div><div>获取检查点排他锁，确保同一时刻只有一个检查点在干活</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Acquire CheckpointLock to ensure only one checkpoint happens at a time.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* (This is just pro forma, since in the present system structure there is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* only one process that is allowed to issue checkpoints at any given</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* time.)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockAcquire(CheckpointLock, LW_EXCLUSIVE);</font></div></div><div><font size="2"   >......</font></div><p></p></pre></div><div>判断是否为关机检查点，如果是，先写控制文件。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (shutdown)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWLockAcquire(ControlFileLock, LW_EXCLUSIVE);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ControlFile-&gt;state = DB_SHUTDOWNING;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ControlFile-&gt;time = (pg_time_t) time(NULL);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UpdateControlFile();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(ControlFileLock);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><div><font size="2"   >......</font></div><p></p></pre></div><div>获取XLOG插入排他锁，计算checkpoint的逻辑XLOG位置，即开始位置。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We must block concurrent insertions while examining insert state to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* determine the checkpoint REDO pointer.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; WALInsertLockAcquireExclusive();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; curInsert = XLogBytePosToRecPtr(Insert-&gt;CurrBytePos);</font></div></div><div><font size="2"   >.....</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >计算checkpoint的逻辑XLOG位置，即开始位置，检查点执行fsync时依赖这个位置信息。</span></div><div><span style="line-height: 28px;"   >fsync的内容需要确保在这个XLOG位置前的已提交事务，它们的脏数据必须写入数据文件，CLOG完整。</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Compute new REDO record ptr = location of next XLOG record.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* NB: this is NOT necessarily where the checkpoint record itself will be,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* since other backends may insert more XLOG records while we're off doing</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the buffer flush work. &nbsp;Those XLOG records are logically after the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* checkpoint, even though physically before it. &nbsp;Got that?</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; freespace = INSERT_FREESPACE(curInsert);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (freespace == 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (curInsert % XLogSegSize == 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curInsert += SizeOfXLogLongPHD;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curInsert += SizeOfXLogShortPHD;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; checkPoint.redo = curInsert;</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Here we update the shared RedoRecPtr for future XLogInsert calls; this</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* must be done while holding all the insertion locks.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: if we fail to complete the checkpoint, RedoRecPtr will be left</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* pointing past where it really needs to point. &nbsp;This is okay; the only</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* consequence is that XLogInsert might back up whole buffers that it</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* didn't really need to. &nbsp;We can't postpone advancing RedoRecPtr because</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* XLogInserts that happen while we are dumping buffers must assume that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* their buffer changes are not included in the checkpoint.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; RedoRecPtr = xlogctl-&gt;Insert.RedoRecPtr = checkPoint.redo;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Now we can release the WAL insertion locks, allowing other xacts to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* proceed while we are flushing disk buffers.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div></div><p></p></pre></div><div><div>释放XLOG插入排他锁。</div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; WALInsertLockRelease();</font></div></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >获得检查点的其他数据，例如XID,OID,MXID等，后面需要刷到控制文件中。</span></div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Get the other info we need for the checkpoint record.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockAcquire(XidGenLock, LW_SHARED);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; checkPoint.nextXid = ShmemVariableCache-&gt;nextXid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; checkPoint.oldestXid = ShmemVariableCache-&gt;oldestXid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; checkPoint.oldestXidDB = ShmemVariableCache-&gt;oldestXidDB;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(XidGenLock);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Increase XID epoch if we've wrapped around since last checkpoint */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; checkPoint.nextXidEpoch = ControlFile-&gt;checkPointCopy.nextXidEpoch;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (checkPoint.nextXid &lt; ControlFile-&gt;checkPointCopy.nextXid)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkPoint.nextXidEpoch++;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockAcquire(OidGenLock, LW_SHARED);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; checkPoint.nextOid = ShmemVariableCache-&gt;nextOid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!shutdown)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkPoint.nextOid += ShmemVariableCache-&gt;oidCount;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(OidGenLock);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; MultiXactGetCheckptMulti(shutdown,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;checkPoint.nextMulti,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;checkPoint.nextMultiOffset,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;checkPoint.oldestMulti,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;checkPoint.oldestMultiDB);</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >在checkpoint开始Fsync数据据前，务必等待已提交事务的clog 以及clog的XLOG都已经写完整。</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* In some cases there are groups of actions that must all occur on one</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* side or the other of a checkpoint record. Before flushing the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* checkpoint record we must explicitly wait for any backend currently</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* performing those groups of actions.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* One example is end of transaction, so we must wait for any transactions</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* that are currently in commit critical sections. &nbsp;If an xact inserted</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* its commit record into XLOG just before the REDO point, then a crash</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* restart from the REDO point would not replay that record, which means</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* that our flushing had better include the xact's update of pg_clog. &nbsp;So</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we wait till he's out of his commit critical section before proceeding.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* See notes in RecordTransactionCommit().</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Because we've already released the insertion locks, this test is a bit</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* fuzzy: it is possible that we will wait for xacts we didn't really need</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to wait for. &nbsp;But the delay should be short and it seems better to make</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* checkpoint take a bit longer than to hold off insertions longer than</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* necessary. (In fact, the whole reason we have this issue is that xact.c &nbsp; &nbsp;// &nbsp;根源在这里，因为提交写clog的XLOG和写CLOG分两部分完成，分别由2个锁来保护，但实际上这两部分信息应该在检查点的同一边，要么检查点前，要么检查点后。</font></div><div><font size="2"   >// &nbsp;所以这里才需要等待，就是等它们到同一面，即那些在检查点前写XLOG的但是没有更新CLOG的，必须等它们的CLOG完成。</font></div><div><font size="2"   >// 为什么呢？因为RECOVERY时检查点之前的XLOG是不会去replay的，如果clog的xlog在这之前，但是CLOG未写成功，那么在恢复时又不会去replay这些xlog，将导致这些CLOG缺失。</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* does commit record XLOG insertion and clog update as two separate steps</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* protected by different locks, but again that seems best on grounds of</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* minimizing lock contention.)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* A transaction that has not yet set delayChkpt when we look cannot be at</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* risk, since he's not inserted his commit record yet; and one that's</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* already cleared it is not at risk either, since he's done fixing clog</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* and we will correctly flush the update below. &nbsp;So we cannot miss any</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* xacts we need to wait for.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; vxids = GetVirtualXIDsDelayingChkpt(&amp;nvxids);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (nvxids &gt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_usleep(10000L); &nbsp; &nbsp; &nbsp;/* wait for 10 msec */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } while (HaveVirtualXIDsDelayingChkpt(vxids, nvxids));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pfree(vxids);</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >执行检查点最重要也是最拖累性能的任务，fsync：</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointGuts(checkPoint.redo, flags);</font></div><div></div><p></p></pre><div>CheckPointGuts<span style="line-height: 28px;"   >函数内容后面叙述。</span></div><div><br></div><div><span style="line-height: 28px;"   >Fsync完成后，写入一段XLOG，表示检查点完成</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Now insert the checkpoint record into XLOG.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rdata.data = (char *) (&amp;checkPoint);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rdata.len = sizeof(checkPoint);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rdata.buffer = InvalidBuffer;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rdata.next = NULL;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; recptr = XLogInsert(RM_XLOG_ID,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shutdown ? XLOG_CHECKPOINT_SHUTDOWN :</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLOG_CHECKPOINT_ONLINE,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;rdata);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogFlush(recptr);</font></div><p></p></pre></div><div>更新控制文件，控制文件中写入检查点的XLOG逻辑位置，物理位置等信息。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Select point at which we can truncate the log, which we base on the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* prior checkpoint's earliest info.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(ControlFile-&gt;checkPointCopy.redo, _logSegNo);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Update the control file.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockAcquire(ControlFileLock, LW_EXCLUSIVE);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (shutdown)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ControlFile-&gt;state = DB_SHUTDOWNED;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ControlFile-&gt;prevCheckPoint = ControlFile-&gt;checkPoint;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ControlFile-&gt;checkPoint = ProcLastRecPtr; &nbsp; &nbsp;// &nbsp;包含检查点的 xlog 结束位置, &nbsp;<span style="line-height: 28px;"   >ProcLastRecPtr是</span><span style="line-height: 28px;"   >XLogInsert中更新的一个全局变量,表示XLOG位置。</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ControlFile-&gt;checkPointCopy = checkPoint; &nbsp; &nbsp;// 包含检查点的 xlog 逻辑位置，在前面记录了，请看前面的代码</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ControlFile-&gt;time = (pg_time_t) time(NULL);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* crash recovery should always recover to the end of WAL */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ControlFile-&gt;minRecoveryPoint = InvalidXLogRecPtr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ControlFile-&gt;minRecoveryPointTLI = 0;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Persist unloggedLSN value. It's reset on crash recovery, so this goes</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* unused on non-shutdown checkpoints, but seems useful to store it always</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* for debugging purposes.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;XLogCtl-&gt;ulsn_lck);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ControlFile-&gt;unloggedLSN = XLogCtl-&gt;unloggedLSN;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;XLogCtl-&gt;ulsn_lck);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; UpdateControlFile();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(ControlFileLock);</font></div><p></p></pre></div><div>释放检查点排他锁</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(CheckpointLock);</font></div><div></div><p></p></pre></div><div><div style="line-height: 28px;"   ><br></div><div style="line-height: 28px;"   >Fsync涉及的函数<span style="line-height: 28px;"   >CheckPointGuts</span><span style="line-height: 28px;"   >如下：</span></div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >/*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* Flush all data in shared memory to disk, and fsync</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* This is the common code shared between regular checkpoints and</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* recovery restartpoints.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 28px;"   ><font size="2"   >static void</font></div><div style="line-height: 28px;"   ><font size="2"   >CheckPointGuts(XLogRecPtr checkPointRedo, int flags)</font></div><div style="line-height: 28px;"   ><font size="2"   >{</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointCLOG(); &nbsp; //&nbsp;src/backend/access/transam/clog.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointSUBTRANS(); &nbsp;//&nbsp;src/backend/access/transam/subtrans.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointMultiXact(); &nbsp;//&nbsp;src/backend/access/transam/multixact.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointPredicate(); &nbsp;//&nbsp;src/backend/storage/lmgr/predicate.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointRelationMap(); &nbsp;//&nbsp;src/backend/utils/cache/relmapper.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointReplicationSlots(); &nbsp;// &nbsp;src/backend/replication/slot.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointSnapBuild(); &nbsp;//&nbsp;src/backend/replication/logical/snapbuild.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointLogicalRewriteHeap(); &nbsp;//&nbsp;src/backend/access/heap/rewriteheap.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointBuffers(flags); &nbsp; &nbsp; &nbsp; /* performs all required fsyncs */ &nbsp;//&nbsp;src/backend/storage/buffer/bufmgr.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* We deliberately delay 2PC checkpointing as long as possible */ &nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointTwoPhase(checkPointRedo); &nbsp;// &nbsp;src/backend/access/transam/twophase.c</font></div><div style="line-height: 28px;"   ><font size="2"   >}</font></div><p></p></pre></div><div style="line-height: 28px;"   >最后，回答一个问题，为什么检查点会带来巨大的性能损耗呢？</div><div style="line-height: 28px;"   >需要分析CheckPointGuts函数内调用的这些函数来回答这个问题，整个检查点的过程只有这里是重量级任务，而且涉及到大量的排他锁。例如<span style="line-height: 28px;"   >BufferSync里面需要将所有检查点逻辑位置前所有已提交事务的buffer脏数据刷入数据文件</span><span style="line-height: 28px;"   >(这个说法并不严谨，也可能包含检查点开始后某一个时间差内产生的脏数据，见BufferSync@src/backend/storage/buffer/bufmgr.c)</span><span style="line-height: 28px;"   >。</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >内容太多，放到下一篇文章进行讲解。</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><br></span></div><div style="line-height: 28px;"   >如果你要跟踪这里面的开销，在linux下面可以使用systemtap跟踪这些函数，或者探针。</div><div style="line-height: 28px;"   >方法参考：</div><div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015380712956/"   >http://blog.163.com/digoal@126/blog/static/1638770402015380712956/</a></div></div></div><div style="line-height: 28px;"   ><a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://blog.163.com/digoal@126/blog/#m=0&amp;t=1&amp;c=fks_084068084086080075085082085095085080082075083081086071084"   >http://blog.163.com/digoal@126/blog/#m=0&amp;t=1&amp;c=fks_084068084086080075085082085095085080082075083081086071084</a></div></div></div></div><div><br></div><div>[其他]</div><div><span style="line-height: 28px;"   >根据XLOG切换个数触发检查点，</span></div><div>判断经过N个XLOG后是否要做检查点。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Check whether we've consumed enough xlog space that a checkpoint is needed.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* new_segno indicates a log file that has just been filled up (or read</font></div><div><font size="2"   >&nbsp;* during recovery). We measure the distance from RedoRecPtr to new_segno</font></div><div><font size="2"   >&nbsp;* and see if that exceeds CheckPointSegments.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: it is caller's responsibility that RedoRecPtr is up-to-date.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static bool</font></div><div><font size="2"   >XLogCheckpointNeeded(XLogSegNo new_segno)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo &nbsp; &nbsp; &nbsp; old_segno;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(RedoRecPtr, old_segno);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (new_segno &gt;= old_segno + (uint64) (CheckPointSegments - 1)) &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//&nbsp;<span style="line-height: 28px;"   >CheckPointSegments取决于参数</span>checkpoint_segments</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>在写XLOG(<span style="line-height: 28px;"   >XLogWrite@</span>src/backend/access/transam/xlog.c<span style="line-height: 28px;"   >)和读XLOG(XLogPageRead@</span>src/backend/access/transam/xlog.c<span style="line-height: 28px;"   >)时会触发这个检查。</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Write and/or fsync the log at least as far as WriteRqst indicates.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* If flexible == TRUE, we don't have to write as far as WriteRqst, but</font></div><div><font size="2"   >&nbsp;* may stop at any convenient boundary (such as a cache or logfile boundary).</font></div><div><font size="2"   >&nbsp;* This option allows us to avoid uselessly issuing multiple writes when a</font></div><div><font size="2"   >&nbsp;* single one would do.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Must be called with WALWriteLock held. WaitXLogInsertionsToFinish(WriteRqst)</font></div><div><font size="2"   >&nbsp;* must be called before grabbing the lock, to make sure the data is ready to</font></div><div><font size="2"   >&nbsp;* write.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static void</font></div><div><font size="2"   >XLogWrite(XLogwrtRqst WriteRqst, bool flexible)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >......</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Request a checkpoint if we've consumed too much xlog since</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the last one. &nbsp;For speed, we first check using the local</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* copy of RedoRecPtr, which might be out of date; if it looks</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* like a checkpoint is needed, forcibly update RedoRecPtr and</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* recheck.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (IsUnderPostmaster &amp;&amp; XLogCheckpointNeeded(openLogSegNo))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (void) GetRedoRecPtr();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (XLogCheckpointNeeded(openLogSegNo))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RequestCheckpoint(CHECKPOINT_CAUSE_XLOG);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><div><font size="2"   >......</font></div><p></p></pre></div><div><br></div><wbr><div>[参考]</div><div><span style="line-height: 28px;"   >1. src/backend/postmaster/checkpointer.c</span></div>2. src/backend/access/transam/xlog.c<div>3. src/backend/storage/buffer/bufmgr.c</div>4. src/backend/storage/buffer<div>5. src/include/storage/buf_internals.h</div><div>6. src/backend/storage/smgr/smgr.c</div><div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><div style="line-height: 28px;"   >7.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015380712956/"   >http://blog.163.com/digoal@126/blog/static/1638770402015380712956/</a></div></div></div><div style="line-height: 28px;"   >8.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://blog.163.com/digoal@126/blog/#m=0&amp;t=1&amp;c=fks_084068084086080075085082085095085080082075083081086071084"   >http://blog.163.com/digoal@126/blog/#m=0&amp;t=1&amp;c=fks_084068084086080075085082085095085080082075083081086071084</a></div></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL Why checkpointer impact performance so much ? - 1 - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>