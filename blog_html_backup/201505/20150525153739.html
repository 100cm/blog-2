<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby</h2>
	<h5 id="">2015-05-25 15:37:39&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020154252564681/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>PostgreSQL 9.5 允许pg_receivexlog实时反馈wal的flush位置，并且可以将pg_receivexlog作为sync standby角色来使用。</div><div>这样的话，我们可以利用pg_receivexlog来担任sync standby的第三者角色，从而实现更轻量级的数据0丢失以及高可用（以前我们需要改一下pg_receivexlog来实现这个功能，现在9.5已经添加了，看样子市场需求蛮大）。</div><div>以往，我们使用同步流复制的话，如果只配置了一台standby，当standby或网络异常时，主节点会hang住，因为需要等待sync standby返回wal的flush位置来返回事务提交状态。</div><div><div><img title="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img1.ph.126.net/kYsBz7zgLg4pq4zmCctJeA==/6630699429304488502.png"   ></div><div>为了避免primary hang住，我们需要将sync状态改为async状态，但是这样需要一个后台进程来完成监护，当primary出现异常时，有数据丢失的风险，同时在修改synchronous_standby_names = ''前，primary 的写事务也是会hang住的。</div><div><br></div><div>所以为了避免sync standby带来的单点故障，我们往往需要配置多台standby，请注意，每台standby都需要和primary同样的存储空间，并且需要有足够强的io能力，如果你不需要读负载均衡的话，这样的搭配有点浪费。</div>&nbsp;<div><img title="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img0.ph.126.net/1LSeBE2Hp78phOwRKkw2kA==/6630901739443996227.png"   ></div>&nbsp;</div><div>现在好了，PostgreSQL 9.5允许pg_receivexlog这个工具作为sync standby角色来使用，那么我们只需要一台standby即可，另外再开一个pg_receivexlog来避免standby的单点故障，当standby发生故障时，pg_receivexlog会向主节点回报wal flush位置，所以不会导致primary hang住。</div><div>使用pg_receivexlog的好处，不需要和primary一样大的存储空间，只需要放xlog的空间即可。<br><div><img title="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/23gOUD--KR15FdxNxCTUiA==/6630593876188216589.png"   ></div>&nbsp;我们可以把pg_receivexlog配置在数据库主机本地，这样来避免流复制网络问题导致的primary hang住。</div><div><div><img title="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img1.ph.126.net/hJ1XyvHot1DQORBaol2Sjg==/6630298107560016673.png"   ></div>&nbsp;这样的同步流复制HA，确保0数据丢失的同时还能提供非常好的可用性。</div><div><span style="line-height: 28px;"   >(当然，这么做其实没有意义，因为本地不需要放多份wal，只是为了避免standby return wal flush lsn异常)</span><br><div><img title="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img1.ph.126.net/_XX67tt-FXqNJ4FU8PcjpA==/6630766499513784244.png"   ></div></div><div>如果可以的话，可以用性能较好的云硬盘来放wal。但是要和sync standby流复制走不同的数据链路，否则也无法避免链路问题导致的primary hang。</div><div><div><img title="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/ciSIkZumx1sXPGUnJdEpoA==/6630062812071673283.png"   ></div>&nbsp;<div><img title="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/gAbFe_gnCrRpKnMhCi-rFw==/6630310202187922475.png"   ></div></div><div><br></div><div>相关参数：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >pg_receivexlog can perform one of the two following actions in order to control physical replication slots:</font></div><div><font size="2"   >--create-slot</font></div><div><font size="2"   >Create a new physical replication slot with the name specified in --slot, then start to stream WAL.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >--drop-slot</font></div><div><font size="2"   >Drop the replication slot with the name specified in --slot, then exit.</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >-S slotname</font></div><div><font size="2"   >--slot=slotname</font></div><div><font size="2"   >Require pg_receivexlog to use an existing replication slot (see Section 25.2.6). When this option is used, pg_receivexlog will report a flush position to the server, indicating when each segment has been synchronized to disk so that the server can remove that segment if it is not otherwise needed. --synchronous option must be specified when making pg_receivexlog run as synchronous standby by using replication slot. Otherwise WAL data cannot be flushed frequently enough for this to work correctly.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >--synchronous</font></div><div><font size="2"   >Flush the WAL data to disk immediately after it has been received. Also send a status packet back to the server immediately after flushing, regardless of --status-interval.</font></div><p></p></pre></div></div><wbr><div><br></div><div>小测：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg_hba.conf</font></div><div><div><font size="2"   ># replication privilege.</font></div><div><font size="2"   >local &nbsp; replication &nbsp; &nbsp; postgres &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;trust</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgresql.conf</font></div><div><font size="2"   >synchronous_standby_names = '*'</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >pg95@db-172-16-3-150-&gt; pg_receivexlog --create-slot -S xlogsync_node1 --synchronous -D /data03/pgdata95/sync</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# select * from pg_stat_replication ;</font></div><div><font size="2"   >-[ RECORD 1 ]----+-----------------------------</font></div><div><font size="2"   >pid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 3851</font></div><div><font size="2"   >usesysid &nbsp; &nbsp; &nbsp; &nbsp; | 10</font></div><div><font size="2"   >usename &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| postgres</font></div><div><font size="2"   >application_name | pg_receivexlog</font></div><div><font size="2"   >client_addr &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >client_hostname &nbsp;|&nbsp;</font></div><div><font size="2"   >client_port &nbsp; &nbsp; &nbsp;| -1</font></div><div><font size="2"   >backend_start &nbsp; &nbsp;| 2015-05-25 15:07:42.50071+08</font></div><div><font size="2"   >backend_xmin &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >state &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| streaming</font></div><div><font size="2"   >sent_location &nbsp; &nbsp;| 1/8A77B690</font></div><div><font size="2"   >write_location &nbsp; | 1/8A77B690</font></div><div><font size="2"   >flush_location &nbsp; | 1/8A77B690</font></div><div><font size="2"   >replay_location &nbsp;|&nbsp;</font></div><div><font size="2"   >sync_priority &nbsp; &nbsp;| 1</font></div><div><font size="2"   >sync_state &nbsp; &nbsp; &nbsp; | sync</font></div></div><div><div><font size="2"   >postgres=# select * from pg_replication_slots ;</font></div><div><font size="2"   >-[ RECORD 1 ]+---------------</font></div><div><font size="2"   >slot_name &nbsp; &nbsp;| xlogsync_node1</font></div><div><font size="2"   >plugin &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >slot_type &nbsp; &nbsp;| physical</font></div><div><font size="2"   >datoid &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >database &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >active &nbsp; &nbsp; &nbsp; | t</font></div><div><font size="2"   >active_pid &nbsp; | 3851</font></div><div><font size="2"   >xmin &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >catalog_xmin |&nbsp;</font></div><div><font size="2"   >restart_lsn &nbsp;| 1/8A77BBD0</font></div></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/app-pgreceivexlog.html"   >http://www.postgresql.org/docs/devel/static/app-pgreceivexlog.html</a></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL 9.5 new feature - pg_receivexlog run as synchronous standby - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>