<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.5 new feature - At promotion, archive last segment from old timeline with .partial suffix.</h2>
	<h5 id="">2015-05-28 16:34:41&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402015428112955340/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>PostgreSQL 9.5的一个小改进，standby在promote时，会将当前的xlog文件归档，归档文件名加.partial后缀，例如：</div><div>当前时间线是3，promote后时间线变为4.</div><div><div>$ cat 00000004.history</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >1 &nbsp; &nbsp; &nbsp; 1/8B935658 &nbsp; &nbsp; &nbsp;no recovery target specified</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >2 &nbsp; &nbsp; &nbsp; 1/8B9357D8 &nbsp; &nbsp; &nbsp;no recovery target specified</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >3 &nbsp; &nbsp; &nbsp; 1/8F000098 &nbsp; &nbsp; &nbsp;no recovery target specified</font></div><p></p></pre></div></div><div>从这个history文件分析，首先要将老的时间线下面的<span style="line-height: 28px;"   >00000003000000010000008F XLOG文件中截至</span><span style="line-height: 28px;"   >1/8F000098位置的数据内容拷贝到新时间线的XLOG文件</span>00000004000000010000008F中。(所以新的时间线文件包含了老的时间线文件中promote时的内容)</div><div><span style="line-height: 28px;"   >接下来需要将00000003000000010000008F这个文件重命名为</span><span style="line-height: 28px;"   >00000003000000010000008F.partial</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >-rw------- 1 pg95 pg95 &nbsp;16M May 28 16:05 00000003000000010000008F.partial</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >如果开启了归档，需要将</span><span style="line-height: 28px;"   >00000003000000010000008F.partial这个文件归档，归档结果如下。</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >pg95@db-172-16-3-150-&gt; cd archive_status/</font></div><div><font size="2"   >pg95@db-172-16-3-150-&gt; ll</font></div><div><font size="2"   >total 0</font></div><div><font size="2"   >-rw------- 1 pg95 pg95 0 May 28 16:05 00000003000000010000008F.partial.done</font></div><div><font size="2"   >-rw------- 1 pg95 pg95 0 May 28 16:05 00000004.history.done</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >$&nbsp;ll /data03/pgdata95/arch</font></div><div><div><font size="2"   >-rw------- &nbsp;1 pg95 pg95 &nbsp;16M May 28 16:05 00000003000000010000008F.partial</font></div><div><font size="2"   >-rw------- &nbsp;1 pg95 pg95 &nbsp; 85 May 28 11:16 00000003.history</font></div><div><font size="2"   >-rw------- &nbsp;1 pg95 pg95 &nbsp;128 May 28 16:05 00000004.history</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >在standby节点归档promote之前，老时间线的这个文件有什么好处呢？</span></div><div>此前，standby也会归档这个文件，但是归档名就是用的XLOG的名字</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; cat 00000002.history&nbsp;</font></div><div><font size="2"   >1 &nbsp; &nbsp; &nbsp; 1D6/F581CC50 &nbsp; &nbsp;no recovery target specified</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres@db-172-16-3-150-&gt; ll /data02/pgdata/arch/</font></div><div><font size="2"   >total 17M</font></div><div><font size="2"   >-rw------- &nbsp; 1 postgres postgres &nbsp;16M May 28 16:24 00000001000001D6000000F5</font></div><div><font size="2"   >-rw------- &nbsp; 1 postgres postgres &nbsp; 44 May 28 16:24 00000002.history</font></div></div><p></p></pre></div><div><br></div><div>这样就有一个小问题，当主节点和备节点的归档目标路径是一致的时候，STANDBY归档了这个文件。假设原来的主节点还在运行，当发生XLOG切换时，主节点也要归档这个文件，而主节点的归档必须处理文件已存在的问题。</div><div>并且需要注意主节点的这一个归档文件信息量可能比STANDBY上的归档的信息量大，因为STANDBY中可能只包含了部分信息，（当主节点没有将所有数据发送给STANDBY时）。</div><div><br></div><div>PostgreSQL 9.5的这个补丁，可以避免以上问题。也使得归档文件名更加清晰，容易理解。</div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 28px;"   ><font size="2"   >At promotion, archive last segment from old timeline with .partial suffix.</font></span></div><div><font size="2"   ><br></font></div><div><font size="2"   >Previously, we would archive the possible-incomplete WAL segment with its</font></div><div><font size="2"   >normal filename, but that causes trouble if the server owning that timeline</font></div><div><font size="2"   >is still running, and tries to archive the same segment later. It's not nice</font></div><div><font size="2"   >for the standby to trip up the master's archival like that. And it's pretty</font></div><div><font size="2"   >confusing, anyway, to have an incomplete segment in the archive that's</font></div><div><font size="2"   >indistinguishable from a normal, complete segment.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >To avoid such confusion, add a .partial suffix to the file. Or to be more</font></div><div><font size="2"   >precise, make a copy of the old segment under the .partial suffix, and</font></div><div><font size="2"   >archive that instead of the original file. pg_receivexlog also uses the</font></div><div><font size="2"   >.partial suffix for the same purpose, to tell apart incompletely streamed</font></div><div><font size="2"   >files from complete ones.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >There is no automatic mechanism to use the .partial files at recovery, so</font></div><div><font size="2"   >they will go unused, unless the administrator manually copies to them to</font></div><div><font size="2"   >the pg_xlog directory (and removes the .partial suffix). Recovery won't</font></div><div><font size="2"   >normally need the WAL - when recovering to the new timeline, it will find</font></div><div><font size="2"   >the same WAL on the first segment on the new timeline instead - but it</font></div><div><font size="2"   >nevertheless feels better to archive the file with the .partial suffix, for</font></div><div><font size="2"   >debugging purposes if nothing else.</font></div><p></p></pre></div></div><div><br></div><div>图:</div><div><div><img title="PostgreSQL 9.5 new feature - At promotion, archive last segment from old timeline with .partial suffix. - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - At promotion, archive last segment from old timeline with .partial suffix. - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/jTLTTj72D0VrVlaZEfKWIA==/6630781892676620009.png"   ></div>&nbsp;<div><img title="PostgreSQL 9.5 new feature - At promotion, archive last segment from old timeline with .partial suffix. - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - At promotion, archive last segment from old timeline with .partial suffix. - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/9ayTj28hCKhOI5bdDDqCQw==/6630753305374296431.png"   ></div>&nbsp;</div><div><br></div>[参考]<div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=de7688442f5aaa03da60416a6aa3474738718803"   >http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=de7688442f5aaa03da60416a6aa3474738718803</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://git.postgresql.org/gitweb/?p=postgresql.git;a=blobdiff;f=src/backend/access/transam/xlog.c;h=6f7e3bd96b38e732a5ff1b757b90ec0d963d9498;hp=5097173c60952bf8dbef001c828d9759a8cb9c8d;hb=de7688442f5aaa03da60416a6aa3474738718803;hpb=179cdd098196338880bdbb39c39a788abdad4dd8"   >http://git.postgresql.org/gitweb/?p=postgresql.git;a=blobdiff;f=src/backend/access/transam/xlog.c;h=6f7e3bd96b38e732a5ff1b757b90ec0d963d9498;hp=5097173c60952bf8dbef001c828d9759a8cb9c8d;hb=de7688442f5aaa03da60416a6aa3474738718803;hpb=179cdd098196338880bdbb39c39a788abdad4dd8</a></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >diff --git a/src/backend/access/transam/xlog.c b/src/backend/access/transam/xlog.c</font></div><div><font size="2"   >index 5097173..6f7e3bd 100644 (file)</font></div><div><font size="2"   >--- a/src/backend/access/transam/xlog.c</font></div><div><font size="2"   >+++ b/src/backend/access/transam/xlog.c</font></div><div><font size="2"   >@@ -3020,24 +3020,22 @@ XLogFileInit(XLogSegNo logsegno, bool *use_existent, bool use_lock)</font></div><div><font size="2"   >&nbsp;}</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >&nbsp;/*</font></div><div><font size="2"   >- * Create a new XLOG file segment by copying a pre-existing one.</font></div><div><font size="2"   >+ * Copy a WAL segment file in pg_xlog directory.</font></div><div><font size="2"   >&nbsp; *</font></div><div><font size="2"   >- * destsegno: identify segment to be created.</font></div><div><font size="2"   >+ * dstfname &nbsp; &nbsp; &nbsp; &nbsp;destination filename</font></div><div><font size="2"   >+ * srcfname &nbsp; &nbsp; &nbsp; &nbsp;source filename</font></div><div><font size="2"   >+ * upto &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;how much of the source file to copy? (the rest is filled with</font></div><div><font size="2"   >+ * &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zeros)</font></div><div><font size="2"   >&nbsp; *</font></div><div><font size="2"   >- * srcTLI, srclog, srcseg: identify segment to be copied (could be from</font></div><div><font size="2"   >- * &nbsp; &nbsp; a different timeline)</font></div><div><font size="2"   >+ * If dstfname is not given, the file is created with a temporary filename,</font></div><div><font size="2"   >+ * which is returned. &nbsp;Both filenames are relative to the pg_xlog directory.</font></div><div><font size="2"   >&nbsp; *</font></div><div><font size="2"   >- * upto: how much of the source file to copy? (the rest is filled with zeros)</font></div><div><font size="2"   >- *</font></div><div><font size="2"   >- * Currently this is only used during recovery, and so there are no locking</font></div><div><font size="2"   >- * considerations. &nbsp;But we should be just as tense as XLogFileInit to avoid</font></div><div><font size="2"   >- * emplacing a bogus file.</font></div><div><font size="2"   >+ * NB: Any existing file with the same name will be overwritten!</font></div><div><font size="2"   >&nbsp; */</font></div><div><font size="2"   >-static void</font></div><div><font size="2"   >-XLogFileCopy(XLogSegNo destsegno, TimeLineID srcTLI, XLogSegNo srcsegno,</font></div><div><font size="2"   >- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int upto)</font></div><div><font size="2"   >+static char *</font></div><div><font size="2"   >+XLogFileCopy(char *dstfname, char *srcfname, int upto)</font></div><div><font size="2"   >&nbsp;{</font></div><div><font size="2"   >- &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;path[MAXPGPATH];</font></div><div><font size="2"   >+ &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;srcpath[MAXPGPATH];</font></div><div><font size="2"   >&nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;tmppath[MAXPGPATH];</font></div><div><font size="2"   >&nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;buffer[XLOG_BLCKSZ];</font></div><div><font size="2"   >&nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; srcfd;</font></div><div><font size="2"   >@@ -3047,12 +3045,12 @@ XLogFileCopy(XLogSegNo destsegno, TimeLineID srcTLI, XLogSegNo srcsegno,</font></div><div><font size="2"   >&nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* Open the source file</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >- &nbsp; XLogFilePath(path, srcTLI, srcsegno);</font></div><div><font size="2"   >- &nbsp; srcfd = OpenTransientFile(path, O_RDONLY | PG_BINARY, 0);</font></div><div><font size="2"   >+ &nbsp; snprintf(srcpath, MAXPGPATH, XLOGDIR "/%s", srcfname);</font></div><div><font size="2"   >+ &nbsp; srcfd = OpenTransientFile(srcpath, O_RDONLY | PG_BINARY, 0);</font></div><div><font size="2"   >&nbsp; &nbsp; if (srcfd &lt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode_for_file_access(),</font></div><div><font size="2"   >- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not open file \"%s\": %m", path)));</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not open file \"%s\": %m", srcpath)));</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* Copy into a temp file name.</font></div><div><font size="2"   >@@ -3094,10 +3092,12 @@ XLogFileCopy(XLogSegNo destsegno, TimeLineID srcTLI, XLogSegNo srcsegno,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (errno != 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode_for_file_access(),</font></div><div><font size="2"   >- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not read file \"%s\": %m", path)));</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not read file \"%s\": %m",</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcpath)));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("not enough data in file \"%s\"", path)));</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("not enough data in file \"%s\"",</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcpath)));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; errno = 0;</font></div><div><font size="2"   >@@ -3131,10 +3131,24 @@ XLogFileCopy(XLogSegNo destsegno, TimeLineID srcTLI, XLogSegNo srcsegno,</font></div><div><font size="2"   >&nbsp; &nbsp; CloseTransientFile(srcfd);</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; /*</font></div><div><font size="2"   >- &nbsp; &nbsp;* Now move the segment into place with its final name.</font></div><div><font size="2"   >+ &nbsp; &nbsp;* Now move the segment into place with its final name. &nbsp;(Or just return</font></div><div><font size="2"   >+ &nbsp; &nbsp;* the path to the file we created, if the caller wants to handle the</font></div><div><font size="2"   >+ &nbsp; &nbsp;* rest on its own.)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >- &nbsp; if (!InstallXLogFileSegment(&amp;destsegno, tmppath, false, 0, false))</font></div><div><font size="2"   >- &nbsp; &nbsp; &nbsp; elog(ERROR, "InstallXLogFileSegment should not have failed");</font></div><div><font size="2"   >+ &nbsp; if (dstfname)</font></div><div><font size="2"   >+ &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;dstpath[MAXPGPATH];</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; snprintf(dstpath, MAXPGPATH, XLOGDIR "/%s", dstfname);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (rename(tmppath, dstpath) &lt; 0)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode_for_file_access(),</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not rename file \"%s\" to \"%s\": %m",</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmppath, dstpath)));</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; return NULL;</font></div><div><font size="2"   >+ &nbsp; }</font></div><div><font size="2"   >+ &nbsp; else</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; return pstrdup(tmppath);</font></div><div><font size="2"   >&nbsp;}</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >&nbsp;/*</font></div><div><font size="2"   >@@ -3577,7 +3591,8 @@ RemoveOldXlogFiles(XLogSegNo segno, XLogRecPtr PriorRedoPtr, XLogRecPtr endptr)</font></div><div><font size="2"   >&nbsp; &nbsp; while ((xlde = ReadDir(xldir, XLOGDIR)) != NULL)</font></div><div><font size="2"   >&nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Ignore files that are not XLOG segments */</font></div><div><font size="2"   >- &nbsp; &nbsp; &nbsp; if (!IsXLogFileName(xlde-&gt;d_name))</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (!IsXLogFileName(xlde-&gt;d_name) &amp;&amp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !IsPartialXLogFileName(xlde-&gt;d_name))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >@@ -5189,25 +5204,79 @@ exitArchiveRecovery(TimeLineID endTLI, XLogRecPtr endOfLog)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* of the old timeline up to the switch point, to the starting WAL segment</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;* on the new timeline.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >- &nbsp; &nbsp;* Notify the archiver that the last WAL segment of the old timeline is</font></div><div><font size="2"   >- &nbsp; &nbsp;* ready to copy to archival storage if its .done file doesn't exist</font></div><div><font size="2"   >- &nbsp; &nbsp;* (e.g., if it's the restored WAL file, it's expected to have .done file).</font></div><div><font size="2"   >- &nbsp; &nbsp;* Otherwise, it is not archived for a while.</font></div><div><font size="2"   >+ &nbsp; &nbsp;* What to do with the partial segment on the old timeline? If we don't</font></div><div><font size="2"   >+ &nbsp; &nbsp;* archive it, and the server that created the WAL never archives it</font></div><div><font size="2"   >+ &nbsp; &nbsp;* either (e.g. because it was hit by a meteor), it will never make it to</font></div><div><font size="2"   >+ &nbsp; &nbsp;* the archive. That's OK from our point of view, because the new segment</font></div><div><font size="2"   >+ &nbsp; &nbsp;* that we created with the new TLI contains all the WAL from the old</font></div><div><font size="2"   >+ &nbsp; &nbsp;* timeline up to the switch point. But if you later try to do PITR to the</font></div><div><font size="2"   >+ &nbsp; &nbsp;* "missing" WAL on the old timeline, recovery won't find it in the</font></div><div><font size="2"   >+ &nbsp; &nbsp;* archive. It's physically present in the new file with new TLI, but</font></div><div><font size="2"   >+ &nbsp; &nbsp;* recovery won't look there when it's recovering to the older timeline.</font></div><div><font size="2"   >+ &nbsp; &nbsp;* On the other hand, if we archive the partial segment, and the original</font></div><div><font size="2"   >+ &nbsp; &nbsp;* server on that timeline is still running and archives the completed</font></div><div><font size="2"   >+ &nbsp; &nbsp;* version of the same segment later, it will fail. (We used to do that in</font></div><div><font size="2"   >+ &nbsp; &nbsp;* 9.4 and below, and it caused such problems).</font></div><div><font size="2"   >+ &nbsp; &nbsp;*</font></div><div><font size="2"   >+ &nbsp; &nbsp;* As a compromise, we archive the last segment with the .partial suffix.</font></div><div><font size="2"   >+ &nbsp; &nbsp;* Archive recovery will never try to read .partial segments, so they will</font></div><div><font size="2"   >+ &nbsp; &nbsp;* normally go unused. But in the odd PITR case, the administrator can</font></div><div><font size="2"   >+ &nbsp; &nbsp;* copy them manually to the pg_xlog directory (removing the suffix). They</font></div><div><font size="2"   >+ &nbsp; &nbsp;* can be useful in debugging, too.</font></div><div><font size="2"   >+ &nbsp; &nbsp;*</font></div><div><font size="2"   >+ &nbsp; &nbsp;* If a .done file already exists for the old timeline, however, there is</font></div><div><font size="2"   >+ &nbsp; &nbsp;* already a complete copy of the file in the archive, and there is no</font></div><div><font size="2"   >+ &nbsp; &nbsp;* need to archive the partial one. (In particular, if it was restored</font></div><div><font size="2"   >+ &nbsp; &nbsp;* from the archive to begin with, it's expected to have .done file).</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; if (endLogSegNo == startLogSegNo)</font></div><div><font size="2"   >&nbsp; &nbsp; {</font></div><div><font size="2"   >- &nbsp; &nbsp; &nbsp; XLogFileCopy(startLogSegNo, endTLI, endLogSegNo,</font></div><div><font size="2"   >- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;endOfLog % XLOG_SEG_SIZE);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *tmpfname;</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; XLogFileName(xlogfname, endTLI, endLogSegNo);</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* Make a copy of the file on the new timeline.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* Writing WAL isn't allowed yet, so there are no locking</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* considerations. But we should be just as tense as XLogFileInit to</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* avoid emplacing a bogus file.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; tmpfname = XLogFileCopy(NULL, xlogfname, endOfLog % XLOG_SEG_SIZE);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (!InstallXLogFileSegment(&amp;endLogSegNo, tmpfname, false, 0, false))</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "InstallXLogFileSegment should not have failed");</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >- &nbsp; &nbsp; &nbsp; /* Create .ready file only when neither .ready nor .done files exist */</font></div><div><font size="2"   >- &nbsp; &nbsp; &nbsp; if (XLogArchivingActive())</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* Make a .partial copy for the archive (unless the original file was</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* already archived)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (XLogArchivingActive() &amp;&amp; XLogArchiveIsBusy(xlogfname))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(xlogfname, endTLI, endLogSegNo);</font></div><div><font size="2"   >- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogArchiveCheckDone(xlogfname);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;partialfname[MAXFNAMELEN];</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(partialfname, MAXFNAMELEN, "%s.partial", xlogfname);</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Make sure there's no .done or .ready file for it. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogArchiveCleanup(partialfname);</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We copy the whole segment, not just upto the switch point.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The portion after the switch point might be garbage, but it</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* might also be valid WAL, if we stopped recovery at user's</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* request before reaching the end. Better to preserve the</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* file as it is, garbage and all, than lose the evidence if</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* something goes wrong.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (void) XLogFileCopy(partialfname, xlogfname, XLOG_SEG_SIZE);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogArchiveNotify(partialfname);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* The switch happened at a segment boundary, so just create the next</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* segment on the new timeline.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;use_existent = true;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; fd;</font></div><p></p></pre></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL 9.5 new feature - At promotion, archive last segment from old timeline with .partial suffix. - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>