<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">use PostgreSQL async Notification as a chat group</h2>
	<h5 id="">2015-05-25 10:06:58&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020154259823696/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 提供了一个很有意思的异步消息通信功能。</div><div>利用这个功能，可以实现很多有趣的想法，例如离线聊天组，数据逻辑复制，审计日志等。</div><div>notify就是往一个指定的通道发消息。</div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >postgres=# \h notify</font></div><div style="line-height: 28px;"   ><font size="2"   >Command: &nbsp; &nbsp; NOTIFY</font></div><div style="line-height: 28px;"   ><font size="2"   >Description: generate a notification</font></div><div style="line-height: 28px;"   ><font size="2"   >Syntax:</font></div><div style="line-height: 28px;"   ><font size="2"   >NOTIFY channel [ , payload ]</font></div><p></p></pre></div></div><div>listen就是监听一个指定的通道。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \h listen</font></div><div><font size="2"   >Command: &nbsp; &nbsp; LISTEN</font></div><div><font size="2"   >Description: listen for a notification</font></div><div><font size="2"   >Syntax:</font></div><div><font size="2"   >LISTEN channel</font></div><p></p></pre></div><div>一个客户端可以往多个通道发消息，也可以监听来自多个通道的消息。</div><div>例子：</div><div>1. 大伙首先要加到一个聊天组（channel）</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >session A:</font></div><div><div><font size="2"   >postgres=# listen cnpug;</font></div><div><font size="2"   >LISTEN</font></div></div><div><font size="2"   ><br></font></div><div><span style="line-height: 28px;"   ><font size="2"   >session B:</font></span></div><div><div><font size="2"   >postgres=# listen cnpug;</font></div><div><font size="2"   >LISTEN</font></div></div><p></p></pre></div><div>2. 大伙往这个聊天组发消息，自己发的消息会立即收到。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SESSION A:</font></div><div><div><font size="2"   >postgres=# notify cnpug, 'hello, every body.';</font></div><div><font size="2"   >NOTIFY</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello, every body." received from server process with PID 45729.</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >3. 大伙可以随时去取聊天组的历史消息，不是自己发的消息，要使用listen去获取。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SESSION B:</font></div><div><div><font size="2"   >postgres=# listen cnpug;</font></div><div><font size="2"   >LISTEN</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello, every body." received from server process with PID 45729.</font></div></div><div><div><font size="2"   >postgres=# notify cnpug, 'hello';</font></div><div><font size="2"   >NOTIFY</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >SESSION A:</font></div><div><div><font size="2"   >postgres=# listen cnpug;</font></div><div><font size="2"   >LISTEN</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >如果很长时间没有接收消息，会有很多堆积的。</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 28px;"   ><font size="2"   >SESSION B:</font></span></div><div><div><font size="2"   >postgres=# notify cnpug, 'hello';</font></div><div><font size="2"   >NOTIFY</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >postgres=# notify cnpug, 'hello';</font></div><div><font size="2"   >NOTIFY</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >postgres=# notify cnpug, 'hello';</font></div><div><font size="2"   >NOTIFY</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >postgres=# notify cnpug, 'hello';</font></div><div><font size="2"   >NOTIFY</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >postgres=# notify cnpug, 'hello';</font></div><div><font size="2"   >NOTIFY</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >postgres=# notify cnpug, 'hello';</font></div><div><font size="2"   >NOTIFY</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >postgres=# notify cnpug, 'hello';</font></div><div><font size="2"   >NOTIFY</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >postgres=# notify cnpug, 'hello';</font></div><div><font size="2"   >NOTIFY</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >postgres=# notify cnpug, 'hello';</font></div><div><font size="2"   >NOTIFY</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >postgres=# notify cnpug, 'hello';</font></div><div><font size="2"   >NOTIFY</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >postgres=# notify cnpug, 'hello1';</font></div><div><font size="2"   >NOTIFY</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello1" received from server process with PID 46882.</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >SESSION A:</font></div><div><div><font size="2"   >postgres=# listen cnpug;</font></div><div><font size="2"   >LISTEN</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello" received from server process with PID 46882.</font></div><div><font size="2"   >Asynchronous notification "cnpug" with payload "hello1" received from server process with PID 46882.</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >4. 如果有新的小伙伴要加入聊天组，只能看到加入后大家发的消息，以前的消息是看不到的。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# listen cnpug;</font></div><div><font size="2"   >LISTEN</font></div><p></p></pre></div><div>以前发的消息不会显示，即使还在队列里面也不会显示。</div><div>5. 退出聊天组</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >unlisten cnpug;</font></div><div></div><p></p></pre></div><div><br></div><div>除此之外，异步消息还可以用于审计，数据复制等场景。</div><div>例如tcn插件就是一个类似审计或数据复制的场景。</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# create table tcndata</font></div><div><font size="2"   >test-# &nbsp; (</font></div><div><font size="2"   >test(# &nbsp; &nbsp; a int not null,</font></div><div><font size="2"   >test(# &nbsp; &nbsp; b date not null,</font></div><div><font size="2"   >test(# &nbsp; &nbsp; c text,</font></div><div><font size="2"   >test(# &nbsp; &nbsp; primary key (a, b)</font></div><div><font size="2"   >test(# &nbsp; );</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>创建触发器，当发生dml操作时，调用<span style="line-height: 28px;"   >triggered_change_notification函数发出notify.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# create trigger tcndata_tcn_trigger</font></div><div><font size="2"   >test-# &nbsp; after insert or update or delete on tcndata</font></div><div><font size="2"   >test-# &nbsp; for each row execute procedure triggered_change_notification();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><p></p></pre></div><div>监听tcn通道</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# listen tcn;</font></div><div><font size="2"   >LISTEN</font></div><p></p></pre></div><div>现在你会发现每当执行DML时，我们可以从tcn通道接收到<span style="line-height: 28px;"   >triggered_change_notification函数发出的异步消息。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >test=# insert into tcndata values (1, date '2012-12-22', 'one'),</font></div><div><font size="2"   >test-# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(1, date '2012-12-23', 'another'),</font></div><div><font size="2"   >test-# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(2, date '2012-12-23', 'two');</font></div><div><font size="2"   >INSERT 0 3</font></div><div><font size="2"   >Asynchronous notification "tcn" with payload ""tcndata",I,"a"='1',"b"='2012-12-22'" received from server process with PID 22770.</font></div><div><font size="2"   >Asynchronous notification "tcn" with payload ""tcndata",I,"a"='1',"b"='2012-12-23'" received from server process with PID 22770.</font></div><div><font size="2"   >Asynchronous notification "tcn" with payload ""tcndata",I,"a"='2',"b"='2012-12-23'" received from server process with PID 22770.</font></div><div><font size="2"   >test=# update tcndata set c = 'uno' where a = 1;</font></div><div><font size="2"   >UPDATE 2</font></div><div><font size="2"   >Asynchronous notification "tcn" with payload ""tcndata",U,"a"='1',"b"='2012-12-22'" received from server process with PID 22770.</font></div><div><font size="2"   >Asynchronous notification "tcn" with payload ""tcndata",U,"a"='1',"b"='2012-12-23'" received from server process with PID 22770.</font></div><div><font size="2"   >test=# delete from tcndata where a = 1 and b = date '2012-12-22';</font></div><div><font size="2"   >DELETE 1</font></div><div><font size="2"   >Asynchronous notification "tcn" with payload ""tcndata",D,"a"='1',"b"='2012-12-22'" received from server process with PID 22770.</font></div><p></p></pre></div></div><div>使用这个方法，可以用于审计或数据异步复制。</div><div><br></div><div>异步消息的代码见：</div><div>src/backend/commands/async.c</div><div>注意允许的队列长度限制，超出的话会报队列满的错误。</div><div>另外需要注意一条消息的长度，和数据块的大小接近。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*-------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;* Async Notification Model as of 9.0:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 1. Multiple backends on same machine. Multiple backends listening on</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;several channels. (Channels are also called "conditions" in other</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;parts of the code.)</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 2. There is one central queue in disk-based storage (directory pg_notify/),</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;with actively-used pages mapped into shared memory by the slru.c module.</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;All notification messages are placed in the queue and later read out</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;by listening backends.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;There is no central knowledge of which backend listens on which channel;</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;every backend has its own list of interesting channels.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;Although there is only one queue, notifications are treated as being</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;database-local; this is done by including the sender's database OID</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;in each notification message. &nbsp;Listening backends ignore messages</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;that don't match their database OID. &nbsp;This is important because it</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;ensures senders and receivers have the same database encoding and won't</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;misinterpret non-ASCII text in the channel name or payload string.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;Since notifications are not expected to survive database crashes,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;we can simply clean out the pg_notify data at any reboot, and there</font></div></div><div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;is no need for WAL support or fsync'ing.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 3. Every backend that is listening on at least one channel registers by</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;entering its PID into the array in AsyncQueueControl. It then scans all</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;incoming notifications in the central queue and first compares the</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;database OID of the notification with its own database OID and then</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;compares the notified channel with the list of channels that it listens</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;to. In case there is a match it delivers the notification event to its</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;frontend. &nbsp;Non-matching events are simply skipped.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 4. The NOTIFY statement (routine Async_Notify) stores the notification in</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;a backend-local list which will not be processed until transaction end.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;Duplicate notifications from the same transaction are sent out as one</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;notification only. This is done to save work when for example a trigger</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;on a 2 million row table fires a notification for each row that has been</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;changed. If the application needs to receive every single notification</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;that has been sent, it can easily add some unique string into the extra</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;payload parameter.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;When the transaction is ready to commit, PreCommit_Notify() adds the</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;pending notifications to the head of the queue. The head pointer of the</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;queue always points to the next free position and a position is just a</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;page number and the offset in that page. This is done before marking the</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;transaction as committed in clog. If we run into problems writing the</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;notifications, we can still call elog(ERROR, ...) and the transaction</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;will roll back.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;Once we have put all of the notifications into the queue, we return to</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;CommitTransaction() which will then do the actual transaction commit.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;After commit we are called another time (AtCommit_Notify()). Here we</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;make the actual updates to the effective listen state (listenChannels).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;Finally, after we are out of the transaction altogether, we check if</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;we need to signal listening backends. &nbsp;In SignalBackends() we scan the</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;list of listening backends and send a PROCSIG_NOTIFY_INTERRUPT signal</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;to every listening backend (we don't know which backend is listening on</font></div></div><div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;which channel so we must signal them all). We can exclude backends that</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;are already up to date, though. &nbsp;We don't bother with a self-signal</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;either, but just process the queue directly.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 5. Upon receipt of a PROCSIG_NOTIFY_INTERRUPT signal, the signal handler</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;can call inbound-notify processing immediately if this backend is idle</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;(ie, it is waiting for a frontend command and is not within a transaction</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;block). &nbsp;Otherwise the handler may only set a flag, which will cause the</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;processing to occur just before we next go idle.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;Inbound-notify processing consists of reading all of the notifications</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;that have arrived since scanning last time. We read every notification</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;until we reach either a notification from an uncommitted transaction or</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;the head pointer's position. Then we check if we were the laziest</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;backend: if our pointer is set to the same position as the global tail</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;pointer is set, then we move the global tail pointer ahead to where the</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;second-laziest backend is (in general, we take the MIN of the current</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;head position and all active backends' new tail pointers). Whenever we</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;move the global tail pointer we also truncate now-unused pages (i.e.,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;delete files in pg_notify/ that are no longer used).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* An application that listens on the same channel it notifies will get</font></div><div><font size="2"   >&nbsp;* NOTIFY messages for its own NOTIFYs. &nbsp;These can be ignored, if not useful,</font></div><div><font size="2"   >&nbsp;* by comparing be_pid in the NOTIFY message to the application's own backend's</font></div><div><font size="2"   >&nbsp;* PID. &nbsp;(As of FE/BE protocol 2.0, the backend's PID is provided to the</font></div><div><font size="2"   >&nbsp;* frontend during startup.) &nbsp;The above design guarantees that notifies from</font></div><div><font size="2"   >&nbsp;* other backends will never be missed by ignoring self-notifies.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The amount of shared memory used for notify management (NUM_ASYNC_BUFFERS)</font></div><div><font size="2"   >&nbsp;* can be varied without affecting anything but performance. &nbsp;The maximum</font></div><div><font size="2"   >&nbsp;* amount of notification data that can be queued at one time is determined</font></div><div><font size="2"   >&nbsp;* by slru.c's wraparound limit; see QUEUE_MAX_PAGE below.</font></div><div><font size="2"   >&nbsp;*-------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;*/</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Maximum size of a NOTIFY payload, including terminating NULL. &nbsp;This</font></div><div><font size="2"   >&nbsp;* must be kept small enough so that a notification message fits on one</font></div><div><font size="2"   >&nbsp;* SLRU page. &nbsp;The magic fudge factor here is noncritical as long as it's</font></div><div><font size="2"   >&nbsp;* more than AsyncQueueEntryEmptySize --- we make it significantly bigger</font></div><div><font size="2"   >&nbsp;* than that, so changes in that data structure won't affect user-visible</font></div><div><font size="2"   >&nbsp;* restrictions.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define NOTIFY_PAYLOAD_MAX_LENGTH &nbsp; &nbsp; &nbsp; (BLCKSZ - NAMEDATALEN - 128)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Struct representing an entry in the global notify queue</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This struct declaration has the maximal length, but in a real queue entry</font></div><div><font size="2"   >&nbsp;* the data area is only big enough for the actual channel and payload strings</font></div><div><font size="2"   >&nbsp;* (each null-terminated). &nbsp;AsyncQueueEntryEmptySize is the minimum possible</font></div><div><font size="2"   >&nbsp;* entry size, if both channel and payload strings are empty (but note it</font></div><div><font size="2"   >&nbsp;* doesn't include alignment padding).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The "length" field should always be rounded up to the next QUEUEALIGN</font></div><div><font size="2"   >&nbsp;* multiple so that all fields are properly aligned.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef struct AsyncQueueEntry</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* total allocated length of entry */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* sender's database OID */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* sender's XID */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcPid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* sender's PID */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data[NAMEDATALEN + NOTIFY_PAYLOAD_MAX_LENGTH];</font></div><div><font size="2"   >} AsyncQueueEntry;</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* slru.c currently assumes that all filenames are four characters of hex</font></div><div><font size="2"   >&nbsp;* digits. That means that we can use segments 0000 through FFFF.</font></div><div><font size="2"   >&nbsp;* Each segment contains SLRU_PAGES_PER_SEGMENT pages which gives us</font></div><div><font size="2"   >&nbsp;* the pages from 0 to SLRU_PAGES_PER_SEGMENT * 0x10000 - 1.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* It's of course possible to enhance slru.c, but this gives us so much</font></div><div><font size="2"   >&nbsp;* space already that it doesn't seem worth the trouble.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The most data we can have in the queue at a time is QUEUE_MAX_PAGE/2</font></div><div><font size="2"   >&nbsp;* pages, because more than that would confuse slru.c into thinking there</font></div><div><font size="2"   >&nbsp;* was a wraparound condition. &nbsp;With the default BLCKSZ this means there</font></div><div><font size="2"   >&nbsp;* can be up to 8GB of queued-and-not-read data.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: it's possible to redefine QUEUE_MAX_PAGE with a smaller multiple of</font></div><div><font size="2"   >&nbsp;* SLRU_PAGES_PER_SEGMENT, for easier testing of queue-full behaviour.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define QUEUE_MAX_PAGE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(SLRU_PAGES_PER_SEGMENT * 0x10000 - 1)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >// src/include/access/slru.h:#define SLRU_PAGES_PER_SEGMENT &nbsp; &nbsp; &nbsp; &nbsp;32</font></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/tcn.html"   >http://www.postgresql.org/docs/devel/static/tcn.html</a></div><div><span style="color: rgb(51, 51, 51); font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; line-height: 28px;"   >2.&nbsp;</span><a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/libpq-notify.html"   >http://www.postgresql.org/docs/9.4/static/libpq-notify.html</a></div><div><font color="#333333"   face="Hiragino Sans GB W3, Hiragino Sans GB, Arial, Helvetica, simsun, u5b8bu4f53"   >3.&nbsp;</font><a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/libpq-example.html#LIBPQ-EXAMPLE-2"   >http://www.postgresql.org/docs/9.4/static/libpq-example.html#LIBPQ-EXAMPLE-2</a></div><div><font color="#333333"   face="Hiragino Sans GB W3, Hiragino Sans GB, Arial, Helvetica, simsun, u5b8bu4f53"   >4.&nbsp;contrib/tcn/tcn.c</font></div><div><font color="#333333"   face="Hiragino Sans GB W3, Hiragino Sans GB, Arial, Helvetica, simsun, u5b8bu4f53"   >5.&nbsp;</font><a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/sql-notify.html"   >http://www.postgresql.org/docs/9.4/static/sql-notify.html</a></div><div><font color="#333333"   face="Hiragino Sans GB W3, Hiragino Sans GB, Arial, Helvetica, simsun, u5b8bu4f53"   >6.&nbsp;</font><a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/sql-listen.html"   >http://www.postgresql.org/docs/9.4/static/sql-listen.html</a></div><div><font color="#333333"   face="Hiragino Sans GB W3, Hiragino Sans GB, Arial, Helvetica, simsun, u5b8bu4f53"   >7.&nbsp;</font><a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/sql-unlisten.html"   >http://www.postgresql.org/docs/9.4/static/sql-unlisten.html</a></div><div>8.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/contrib-dblink-get-notify.html"   >http://www.postgresql.org/docs/9.4/static/contrib-dblink-get-notify.html</a></div><div>9.&nbsp;src/backend/commands/async.c</div><div>10.&nbsp;src/include/commands/async.h</div><div><a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/contrib-dblink-get-notify.html"   ><font color="#000000"   ><br></font></a><span style="line-height: 28px;"   >
</span><a style="line-height: 28px;" rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="use PostgreSQL async Notification as a chat group - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div></div>
	</div>
</div>
</body>
</html>