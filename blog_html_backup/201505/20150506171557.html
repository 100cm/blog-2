<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL Why checkpointer impact performance so much ? - 2</h2>
	<h5 id="">2015-05-06 17:15:57&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402015463252387/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>接着上一篇讲解检查点最重的操作<span style="line-height: 28px;"   >CheckPointGuts@</span><span style="line-height: 28px;"   >src/backend/access/transam/xlog.c。</span></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201542103933969/"   >http://blog.163.com/digoal@126/blog/static/163877040201542103933969/</a></div><div><br></div><div>检查点最重量级的函数如下：</div><div><span style="line-height: 28px;"   >CheckPointGuts@</span>src/backend/access/transam/xlog.c</div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >static void</font></div><div style="line-height: 28px;"   ><font size="2"   >CheckPointGuts(XLogRecPtr checkPointRedo, int flags)</font></div><div style="line-height: 28px;"   ><font size="2"   >{</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointCLOG(); &nbsp; // src/backend/access/transam/clog.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointSUBTRANS(); &nbsp;// src/backend/access/transam/subtrans.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointMultiXact(); &nbsp;// src/backend/access/transam/multixact.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointPredicate(); &nbsp;// src/backend/storage/lmgr/predicate.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointRelationMap(); &nbsp;// src/backend/utils/cache/relmapper.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointReplicationSlots(); &nbsp;// &nbsp;src/backend/replication/slot.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointSnapBuild(); &nbsp; // src/backend/replication/logical/snapbuild.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointLogicalRewriteHeap(); &nbsp;// src/backend/access/heap/rewriteheap.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointBuffers(flags); &nbsp; &nbsp; &nbsp; // src/backend/storage/buffer/bufmgr.c</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckPointTwoPhase(checkPointRedo); &nbsp;// &nbsp;src/backend/access/transam/twophase.c</font></div><div style="line-height: 28px;"   ><font size="2"   >}</font></div><p></p></pre></div></div><div style="line-height: 28px;"   >分解到每个调用：</div><div style="line-height: 28px;"   >1. 将commit log在buffer中的脏数据刷到pg_clog<span style="line-height: 28px;"   >目录下对应的文件中。</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >CheckPointCLOG@src/backend/access/transam/clog.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Perform a checkpoint --- either during shutdown, or on-the-fly</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >CheckPointCLOG(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Flush dirty CLOG pages to disk */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_CLOG_CHECKPOINT_START(true);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SimpleLruFlush(ClogCtl, true);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_CLOG_CHECKPOINT_DONE(true);</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >2. 将subtrans log在buffer中的脏数据刷到pg_subtrans</span><span style="line-height: 28px;"   >目录下对应的文件中。</span></div><div><div><span style="line-height: 28px;"   >CheckPointSUBTRANS@src/backend/access/transam/subtrans.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Perform a checkpoint --- either during shutdown, or on-the-fly</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >CheckPointSUBTRANS(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Flush dirty SUBTRANS pages to disk</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* This is not actually necessary from a correctness point of view. We do</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* it merely to improve the odds that writing of dirty pages is done by</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the checkpoint process and not by backends.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_SUBTRANS_CHECKPOINT_START(true);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SimpleLruFlush(SubTransCtl, true);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_SUBTRANS_CHECKPOINT_DONE(true);</font></div><div><font size="2"   >}</font></div><p></p></pre></div></div><div><span style="line-height: 28px;"   >3. 将</span><span style="line-height: 28px;"   >MultiXact</span><span style="line-height: 28px;"   >&nbsp;log在buffer中的脏数据刷到</span><span style="line-height: 28px;"   >pg_multixact</span><span style="line-height: 28px;"   >目录下对应的文件中。</span></div><div><span style="line-height: 28px;"   >CheckPointMultiXact@src/backend/access/transam/multixact.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Perform a checkpoint --- either during shutdown, or on-the-fly</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >CheckPointMultiXact(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_START(true);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Flush dirty MultiXact pages to disk */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SimpleLruFlush(MultiXactOffsetCtl, true);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SimpleLruFlush(MultiXactMemberCtl, true);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_DONE(true);</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >4. Flush dirty SLRU(simple least recent used) pages to disk</span></div><div><span style="line-height: 28px;"   >CheckPointPredicate@src/backend/storage/lmgr/predicate.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Perform a checkpoint --- either during shutdown, or on-the-fly</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We don't have any data that needs to survive a restart, but this is a</font></div><div><font size="2"   >&nbsp;* convenient place to truncate the SLRU.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >CheckPointPredicate(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tailPage;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockAcquire(OldSerXidLock, LW_EXCLUSIVE);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Exit quickly if the SLRU is currently not in use. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (oldSerXidControl-&gt;headPage &lt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(OldSerXidLock);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (TransactionIdIsValid(oldSerXidControl-&gt;tailXid))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* We can truncate the SLRU up to the page containing tailXid */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tailPage = OldSerXidPage(oldSerXidControl-&gt;tailXid);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The SLRU is no longer needed. Truncate to head before we set head</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* invalid.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* XXX: It's possible that the SLRU is not needed again until XID</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* wrap-around has happened, so that the segment containing headPage</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* that we leave behind will appear to be new again. In that case it</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* won't be removed until XID horizon advances enough to make it</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* current again.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tailPage = oldSerXidControl-&gt;headPage;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldSerXidControl-&gt;headPage = -1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(OldSerXidLock);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Truncate away pages that are no longer required */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SimpleLruTruncate(OldSerXidSlruCtl, tailPage);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Flush dirty SLRU pages to disk</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* This is not actually necessary from a correctness point of view. We do</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* it merely as a debugging aid.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We're doing this after the truncation to avoid writing pages right</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* before deleting the file in which they sit, which would be completely</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* pointless.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SimpleLruFlush(OldSerXidSlruCtl, true);</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>前面4个调用，全部用到了SimpleLruFlush来完成刷缓存的动作。</div><div>SimpleLruFlush@src/backend/access/transam/slru.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Flush dirty pages to disk during checkpoint or database shutdown</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >SimpleLruFlush(SlruCtl ctl, bool checkpoint)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SlruShared &nbsp; &nbsp; &nbsp;shared = ctl-&gt;shared;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SlruFlushData fdata;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageno = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ok;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Find and write dirty pages</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; fdata.num_files = 0;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockAcquire(shared-&gt;ControlLock, LW_EXCLUSIVE); &nbsp;// 注意每次都要获取排他锁</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; for (slotno = 0; slotno &lt; shared-&gt;num_slots; slotno++)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SlruInternalWritePage(ctl, slotno, &amp;fdata); &nbsp; // 这个可能会是比较重的操作</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* When called during a checkpoint, we cannot assert that the slot is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* clean now, since another process might have re-dirtied it already.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* That's okay.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(checkpoint ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shared-&gt;page_status[slotno] == SLRU_PAGE_EMPTY ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(shared-&gt;page_status[slotno] == SLRU_PAGE_VALID &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !shared-&gt;page_dirty[slotno]));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(shared-&gt;ControlLock);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Now fsync and close any files that were open</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ok = true;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; fdata.num_files; i++)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ctl-&gt;do_fsync &amp;&amp; pg_fsync(fdata.fd[i]))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slru_errcause = SLRU_FSYNC_FAILED;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slru_errno = errno;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageno = fdata.segno[i] * SLRU_PAGES_PER_SEGMENT;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ok = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (CloseTransientFile(fdata.fd[i]))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slru_errcause = SLRU_CLOSE_FAILED;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slru_errno = errno;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageno = fdata.segno[i] * SLRU_PAGES_PER_SEGMENT;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ok = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!ok)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SlruReportIOError(ctl, pageno, InvalidTransactionId);</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div style="line-height: 28px;"   ><br></div><div style="line-height: 28px;"   >5. 将rel mapper文件缓存写入文件, 什么是rel mapper文件呢？</div><div style="line-height: 28px;"   >rel mapper存储了一些数据库全局对象和文件ID的映射关系，一般的对象这种关系存储在全局对象pg_class.relfilenode中。</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* For most tables, the physical file underlying the table is specified by</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* pg_class.relfilenode. &nbsp;However, that obviously won't work for pg_class</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* itself, nor for the other "nailed" catalogs for which we have to be able</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* to set up working Relation entries without access to pg_class. &nbsp;It also</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* does not work for shared catalogs, since there is no practical way to</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* update other databases' pg_class entries when relocating a shared catalog.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* Therefore, for these special catalogs (henceforth referred to as "mapped</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* catalogs") we rely on a separately maintained file that shows the mapping</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* from catalog OIDs to filenode numbers. &nbsp;Each database has a map file for</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* its local mapped catalogs, and there is a separate map file for shared</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* catalogs. &nbsp;Mapped catalogs have zero in their pg_class.relfilenode entries.</font></div><p></p></pre></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >rel mapping文件名：</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >每个数据库有一个pg_filenode.map文件，全局还有一个pg_filenode.map文件。</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >这些文件分别放在表空间/database_oid/目录和global/目录下。</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >/*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* The map file is critical data: we have no automatic method for recovering</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* from loss or corruption of it. &nbsp;We use a CRC so that we can detect</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* corruption. &nbsp;To minimize the risk of failed updates, the map file should</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* be kept to no more than one standard-size disk sector (ie 512 bytes),</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* and we use overwrite-in-place rather than playing renaming games.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* The struct layout below is designed to occupy exactly 512 bytes, which</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* might make filesystem updates a bit more efficient.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* Entries in the mappings[] array are in no particular order. &nbsp;We could</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* speed searching by insisting on OID order, but it really shouldn't be</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* worth the trouble given the intended size of the mapping sets.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 28px;"   ><font size="2"   >#define RELMAPPER_FILENAME &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"pg_filenode.map"</font></div><p></p></pre></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >CheckPointRelationMap@src/backend/utils/cache/relmapper.c</span></div></span></div></div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >/*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* CheckPointRelationMap</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* This is called during a checkpoint. &nbsp;It must ensure that any relation map</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* updates that were WAL-logged before the start of the checkpoint are</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* securely flushed to disk and will not need to be replayed later. &nbsp;This</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* seems unlikely to be a performance-critical issue, so we use a simple</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* method: we just take and release the RelationMappingLock. &nbsp;This ensures</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* that any already-logged map update is complete, because write_relmap_file</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* will fsync the map file before the lock is released.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 28px;"   ><font size="2"   >void</font></div><div style="line-height: 28px;"   ><font size="2"   >CheckPointRelationMap(void)</font></div><div style="line-height: 28px;"   ><font size="2"   >{</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockAcquire(RelationMappingLock, LW_SHARED);  // 隐式fsync, 加锁前会自动完成fsync.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(RelationMappingLock);</font></div><div style="line-height: 28px;"   ><font size="2"   >}</font></div><p></p></pre></div><div style="line-height: 28px;"   ><br></div><div style="line-height: 28px;"   >6. 将流复制replication slots信息刷到pg_replslot目录下对应的文件中。</div><div><div style="line-height: 28px;"   >CheckPointReplicationSlots@src/backend/replication/slot.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Flush all replication slots to disk.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This needn't actually be part of a checkpoint, but it's a convenient</font></div><div><font size="2"   >&nbsp;* location.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >CheckPointReplicationSlots(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, "performing replication slot checkpoint");</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Prevent any slot from being created/dropped while we're active. As we</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* explicitly do *not* want to block iterating over replication_slots or</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* acquiring a slot we cannot take the control lock - but that's OK,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* because holding ReplicationSlotAllocationLock is strictly stronger, and</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* enough to guarantee that nobody can change the in_use bits on us.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockAcquire(ReplicationSlotAllocationLock, LW_SHARED);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; max_replication_slots; i++)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReplicationSlot *s = &amp;ReplicationSlotCtl-&gt;replication_slots[i];</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;path[MAXPGPATH];</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!s-&gt;in_use)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* save the slot to disk, locking is handled in SaveSlotToPath() */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(path, "pg_replslot/%s", NameStr(s-&gt;data.name));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SaveSlotToPath(s, path, LOG);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(ReplicationSlotAllocationLock);</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div style="line-height: 28px;"   ><br></div><div style="line-height: 28px;"   >7. 逻辑复制相关的脏数据，刷入<span style="line-height: 28px;"   >pg_logical/snapshots目录下对应的文件。</span></div><div style="line-height: 28px;"   >CheckPointSnapBuild@src/backend/replication/logical/snapbuild.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Remove all serialized snapshots that are not required anymore because no</font></div><div><font size="2"   >&nbsp;* slot can need them. This doesn't actually have to run during a checkpoint,</font></div><div><font size="2"   >&nbsp;* but it's a convenient point to schedule this.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* NB: We run this during checkpoints even if logical decoding is disabled so</font></div><div><font size="2"   >&nbsp;* we cleanup old slots at some point after it got disabled.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >CheckPointSnapBuild(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;cutoff;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;redo;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; DIR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*snap_dir;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct dirent *snap_de;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;path[MAXPGPATH];</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We start of with a minimum of the last redo pointer. No new replication</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* slot will start before that, so that's a safe upper bound for removal.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; redo = GetRedoRecPtr();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* now check for the restart ptrs from existing slots */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; cutoff = ReplicationSlotsComputeLogicalRestartLSN();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* don't start earlier than the restart lsn */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (redo &lt; cutoff)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cutoff = redo;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; snap_dir = AllocateDir("pg_logical/snapshots");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; while ((snap_de = ReadDir(snap_dir, "pg_logical/snapshots")) != NULL)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hi;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lo;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;lsn;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct stat statbuf;</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (strcmp(snap_de-&gt;d_name, ".") == 0 ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(snap_de-&gt;d_name, "..") == 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, MAXPGPATH, "pg_logical/snapshots/%s", snap_de-&gt;d_name);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (lstat(path, &amp;statbuf) == 0 &amp;&amp; !S_ISREG(statbuf.st_mode))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, "only regular files expected: %s", path);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* temporary filenames from SnapBuildSerialize() include the LSN and</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* everything but are postfixed by .$pid.tmp. We can just remove them</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the same as other files because there can be none that are</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* currently being written that are older than cutoff.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We just log a message if a file doesn't fit the pattern, it's</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* probably some editors lock/state file or similar...</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (sscanf(snap_de-&gt;d_name, "%X-%X.snap", &amp;hi, &amp;lo) != 2)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("could not parse file name \"%s\"", path)));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsn = ((uint64) hi) &lt;&lt; 32 | lo;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* check whether we still need it */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (lsn &lt; cutoff || cutoff == InvalidXLogRecPtr)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, "removing snapbuild snapshot %s", path);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* It's not particularly harmful, though strange, if we can't</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* remove the file here. Don't prevent the checkpoint from</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* completing, that'd be cure worse than the disease.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (unlink(path) &lt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode_for_file_access(),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not remove file \"%s\": %m",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FreeDir(snap_dir);</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >8. 逻辑复制相关的脏数据，刷入</span><span style="line-height: 28px;"   >pg_logical/mappings目录下对应的文件。</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >CheckPointLogicalRewriteHeap@src/backend/access/heap/rewriteheap.c</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/* ---</font></div><div><font size="2"   >&nbsp;* Perform a checkpoint for logical rewrite mappings</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This serves two tasks:</font></div><div><font size="2"   >&nbsp;* 1) Remove all mappings not needed anymore based on the logical restart LSN</font></div><div><font size="2"   >&nbsp;* 2) Flush all remaining mappings to disk, so that replay after a checkpoint</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;only has to deal with the parts of a mapping that have been written out</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;after the checkpoint started.</font></div><div><font size="2"   >&nbsp;* ---</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >CheckPointLogicalRewriteHeap(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;cutoff;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;redo;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; DIR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*mappings_dir;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct dirent *mapping_de;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;path[MAXPGPATH];</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We start of with a minimum of the last redo pointer. No new decoding</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* slot will start before that, so that's a safe upper bound for removal.</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; redo = GetRedoRecPtr();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* now check for the restart ptrs from existing slots */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; cutoff = ReplicationSlotsComputeLogicalRestartLSN();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* don't start earlier than the restart lsn */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (cutoff != InvalidXLogRecPtr &amp;&amp; redo &lt; cutoff)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cutoff = redo;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; mappings_dir = AllocateDir("pg_logical/mappings");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; while ((mapping_de = ReadDir(mappings_dir, "pg_logical/mappings")) != NULL)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct stat statbuf;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;lsn;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId rewrite_xid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId create_xid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hi,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lo;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (strcmp(mapping_de-&gt;d_name, ".") == 0 ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(mapping_de-&gt;d_name, "..") == 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, MAXPGPATH, "pg_logical/mappings/%s", mapping_de-&gt;d_name);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (lstat(path, &amp;statbuf) == 0 &amp;&amp; !S_ISREG(statbuf.st_mode))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Skip over files that cannot be ours. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (strncmp(mapping_de-&gt;d_name, "map-", 4) != 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (sscanf(mapping_de-&gt;d_name, LOGICAL_REWRITE_FORMAT,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;dboid, &amp;relid, &amp;hi, &amp;lo, &amp;rewrite_xid, &amp;create_xid) != 6)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "could not parse filename \"%s\"", mapping_de-&gt;d_name);</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsn = ((uint64) hi) &lt;&lt; 32 | lo;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (lsn &lt; cutoff || cutoff == InvalidXLogRecPtr)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, "removing logical rewrite file \"%s\"", path);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (unlink(path) &lt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode_for_file_access(),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not remove file \"%s\": %m", path)));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = OpenTransientFile(path, O_RDONLY | PG_BINARY, 0);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The file cannot vanish due to concurrency since this function</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* is the only one removing logical mappings and it's run while</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* CheckpointLock is held exclusively.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (fd &lt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode_for_file_access(),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not open file \"%s\": %m", path)));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We could try to avoid fsyncing files that either haven't</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* changed or have only been created since the checkpoint's start,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* but it's currently not deemed worth the effort.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (pg_fsync(fd) != 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode_for_file_access(),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("could not fsync file \"%s\": %m", path)));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CloseTransientFile(fd);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FreeDir(mappings_dir);</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div style="line-height: 28px;"   ><br></div><div>9. 将预提交（2PC）事务状态相关脏数据刷入pg_twophase<span style="line-height: 28px;"   >目录下对应的文件。</span></div><div><span style="line-height: 28px;"   >如果没有开启2PC（</span>#max_prepared_transactions = 0<span style="line-height: 28px;"   >），这里不需要操作。</span></div><div style="line-height: 28px;"   >CheckPointTwoPhase(checkPointRedo)@src/backend/access/transam/twophase.c</div></div></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >/*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* CheckPointTwoPhase -- handle 2PC component of checkpointing.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* We must fsync the state file of any GXACT that is valid and has a PREPARE</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* LSN &lt;= the checkpoint's redo horizon. &nbsp;(If the gxact isn't valid yet or</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* has a later LSN, this checkpoint is not responsible for fsyncing it.)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* This is deliberately run as late as possible in the checkpoint sequence,</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* because GXACTs ordinarily have short lifespans, and so it is quite</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* possible that GXACTs that were valid at checkpoint start will no longer</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* exist if we wait a little bit.</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* If a GXACT remains valid across multiple checkpoints, it'll be fsynced</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* each time. &nbsp;This is considered unusual enough that we don't bother to</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* expend any extra code to avoid the redundant fsyncs. &nbsp;(They should be</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;* reasonably cheap anyway, since they won't cause I/O.)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;*/</font></div><div style="line-height: 28px;"   ><font size="2"   >void</font></div><div style="line-height: 28px;"   ><font size="2"   >CheckPointTwoPhase(XLogRecPtr redo_horizon)</font></div><div style="line-height: 28px;"   ><font size="2"   >{</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId *xids;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;path[MAXPGPATH];</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;</font></div><div style="line-height: 28px;"   ><font size="2"   >......</font></div></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (max_prepared_xacts &lt;= 0)</font></span></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* nothing to do */</font></div><div style="line-height: 28px;"   ><font size="2"   >......</font></div></div><p></p></pre></div></div><div><br></div><div>10. 将shared buffer中的在检查点之前(这个说法并不严谨，也可能包含检查点开始后某一个时间差内产生的脏数据，见BufferSync@src/backend/storage/buffer/bufmgr.c)产生的脏数据块刷入缓存，但是同样可能需要全扫描整个缓存内存区。</div><div>原因下一篇再讲。</div><div><span style="line-height: 28px;"   >CheckPointBuffers(flags)@src/backend/storage/buffer/bufmgr.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* CheckPointBuffers</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Flush all dirty blocks in buffer pool to disk at checkpoint time.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: temporary relations do not participate in checkpoints, so they don't</font></div><div><font size="2"   >&nbsp;* need to be flushed.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >CheckPointBuffers(int flags)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_CHECKPOINT_START(flags);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckpointStats.ckpt_write_t = GetCurrentTimestamp();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; BufferSync(flags);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckpointStats.ckpt_sync_t = GetCurrentTimestamp();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_CHECKPOINT_SYNC_START();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; smgrsync();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; CheckpointStats.ckpt_sync_end_t = GetCurrentTimestamp();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_CHECKPOINT_DONE();</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>[小结]</div><div>1. 从锁冲突角度来分析，可能会带来较大影响的有刷commit log，刷buffer。</div><div>2. 从数量级和IO层面分析，主观判断除了<span style="line-height: 28px;"   >CheckPointBuffers(flags)@src/backend/storage/buffer/bufmgr.c，其他几个刷缓存的动作应该都很快，不会有太大的冲突或影响。</span></div><div><span style="line-height: 28px;"   >但是这些都只是主观判断，还需要有测试数据来提供支撑。</span></div><div>跟踪锁冲突的次数和耗时，跟踪每个刷缓存函数的耗时。</div><div>跟踪的内容将留到后面的篇幅来讲。</div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201542103933969/"   >http://blog.163.com/digoal@126/blog/static/163877040201542103933969/</a></div><div><br></div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL Why checkpointer impact performance so much ? - 2 - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>