<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL why not DirectIO for datafile?</h2>
	<h5 id="">2015-05-03 10:26:03&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402015411109272/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL目前仅仅支持xlog使用DirectIO，对于数据文件不支持DirectIO，这么多年了，为什么PG社区不加入这块的支持呢？</div><div>DirectIO是直接写块设备的，可以旁路kernel cache，这对于XLOG来说，有好处也有坏处，如果你的文件在写入后要立即读取，那么无疑是写缓存更好。因此建议有流复制的主节点或上游节点不要使用DirectIO。同样对于standby节点来说，XLOG也是需要立即读取用来恢复的，因此standby节点也不需要开启DirectIO。这一点在代码中有体现。</div><div><div>src/backend/access/transam/xlog.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Return the (possible) sync flag used for opening a file, depending on the</font></div><div><font size="2"   >&nbsp;* value of the GUC wal_sync_method.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static int</font></div><div><font size="2"   >get_sync_bit(int method)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; o_direct_flag = 0;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* If fsync is disabled, never open in sync mode */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!enableFsync)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Optimize writes by bypassing kernel cache with O_DIRECT when using</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* O_SYNC/O_FSYNC and O_DSYNC. &nbsp;But only if archiving and streaming are</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* disabled, otherwise the archive command or walsender process will read</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the WAL soon after writing it, which is guaranteed to cause a physical</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* read if we bypassed the kernel cache. We also skip the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* posix_fadvise(POSIX_FADV_DONTNEED) call in XLogFileClose() for the same</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* reason.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Never use O_DIRECT in walreceiver process for similar reasons; the WAL</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* written by walreceiver is normally read by the startup process soon</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* after its written. Also, walreceiver performs unaligned writes, which</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* don't work with O_DIRECT, so it is required for correctness too.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!XLogIsNeeded() &amp;&amp; !AmWalReceiverProcess())   // 对于standby节点,不使用O_DIRECT</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; o_direct_flag = PG_O_DIRECT;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; switch (method)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* enum values for all sync options are defined even if they are</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* not supported on the current platform. &nbsp;But if not, they are</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* not included in the enum option array, and therefore will never</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* be seen here.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case SYNC_METHOD_FSYNC:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case SYNC_METHOD_FSYNC_WRITETHROUGH:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case SYNC_METHOD_FDATASYNC:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"   >#ifdef OPEN_SYNC_FLAG</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case SYNC_METHOD_OPEN:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return OPEN_SYNC_FLAG | o_direct_flag;</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >#ifdef OPEN_DATASYNC_FLAG</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case SYNC_METHOD_OPEN_DSYNC:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return OPEN_DATASYNC_FLAG | o_direct_flag;</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* can't happen (unless we are out of sync with option array) */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "unrecognized wal_sync_method: %d", method);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* silence warning */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div></div><div><br></div><div>那么对于数据文件来说，DirectIO有什么好处呢？</div><div>首先，PostgreSQL管理了自己的基于LRU算法的SHARED BUFFER，数据块在读写时会用到SHARED BUFFER，同时还会产生kernel cache。那么问题来了，数据块可能同时在数据库和系统的两处缓存中存在，出现了双重缓存的情况。这不仅仅浪费内存空间，而且降低了使用效率。</div><div>使用DirectIO可以避免出现双重缓存，但是对应用程序来说会增加文件操作的复杂度，例如open手册中提到的：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >The O_DIRECT flag may impose alignment restrictions on the length and address of userspace buffers and the file</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;offset of I/Os. &nbsp;In Linux alignment restrictions vary by file system and kernel version &nbsp;and &nbsp;might &nbsp;be &nbsp;absent</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;entirely. &nbsp;However there is currently no file system-independent interface for an application to discover these</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;restrictions for a given file or file system. &nbsp;Some file systems provide their own interfaces for doing so, for</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;example the XFS_IOC_DIOINFO operation in xfsctl(3).</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Under Linux 2.4, transfer sizes, and the alignment of the user buffer and the file offset must all be multiples</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;of the logical block size of the file system. &nbsp;Under Linux 2.6, alignment to 512-byte boundaries suffices.</font></div></div><p></p></pre></div><div>使用O_DIRECT 后需要考虑BUFFER对齐，打开文件的OFFSET必须为文件系统逻辑块大小的倍数。</div><div>某些文件系统提供了O_direct的接口。</div><div>根据Greg Smith提供的一些信息，使用O_DIRECT并不一定能带来性能的提升。这也许是PG社区目前并未考虑使用O_DIRECT的原因。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >As Tom already mentioned this isn't working because of alignment&nbsp;</font></div><div><font size="2"   >issues. &nbsp;I'm not sure what you expect to achieve though. &nbsp;You should be&nbsp;</font></div><div><font size="2"   >warned that other than the WAL, every experiment I've ever seen that&nbsp;</font></div><div><font size="2"   >tries to add more direct I/O to the database has failed to improve&nbsp;</font></div><div><font size="2"   >anything; the result is neither barely noticeable, or a major&nbsp;</font></div><div><font size="2"   >performance drop. &nbsp;This is particularly futile if you're doing your&nbsp;</font></div><div><font size="2"   >research on Linux/ext3, where even if your code works delivers a speed&nbsp;</font></div><div><font size="2"   >up no one will trust it enough to ever merge and deploy it, due to the&nbsp;</font></div><div><font size="2"   >generally poor quality of that area of the kernel so far.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >This particular area is magnetic for drawing developer attention as it&nbsp;</font></div><div><font size="2"   >seems like there's a big win just under the surface if things were&nbsp;</font></div><div><font size="2"   >improved a bit. &nbsp;There isn't. &nbsp;On operating systems like Solaris where&nbsp;</font></div><div><font size="2"   >it's possible to prototype here by use mounting options to silently&nbsp;</font></div><div><font size="2"   >covert parts of the database to direct I/O, experiments in that area&nbsp;</font></div><div><font size="2"   >have all been disappointing. &nbsp;One of the presentations from Jignesh Shah&nbsp;</font></div><div><font size="2"   >at Sun covered his experiments in this area, can't seem to find it at&nbsp;</font></div><div><font size="2"   >the moment but I remember the results were not positive in any way.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >--&nbsp;</font></div><div><font size="2"   >Greg Smith &nbsp;2ndQuadrant US &nbsp;Baltimore, MD</font></div><div><font size="2"   >PostgreSQL Training, Services and Support</font></div><div><font size="2"   >greg(at)2ndQuadrant(dot)com &nbsp; www.2ndQuadrant.us</font></div><p></p></pre></div><wbr><div>所以不要指望简单的修改PostgreSQL里面的md.c, &nbsp;fd.c的一些打开数据文件的接口，就可以实现O_DIRECT。</div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/message-id/flat/011c01c7249a$4fa27980$19527c0a@OPERAO"   >http://www.postgresql.org/message-id/flat/011c01c7249a$4fa27980$19527c0a@OPERAO</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/message-id/flat/AANLkTilt3jl5V7-8QHEuryWNWoyfKA6VRRwDbyW3BYIB@mail.gmail.com#AANLkTilt3jl5V7-8QHEuryWNWoyfKA6VRRwDbyW3BYIB@mail.gmail.com"   >http://www.postgresql.org/message-id/flat/AANLkTilt3jl5V7-8QHEuryWNWoyfKA6VRRwDbyW3BYIB@mail.gmail.com#AANLkTilt3jl5V7-8QHEuryWNWoyfKA6VRRwDbyW3BYIB@mail.gmail.com</a></div><div>3.&nbsp;<span style="line-height: 28px;"   >man 8 raw</span></div><div>4. man 3 xfsctl</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;XFS_IOC_DIOINFO</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Get information required to perform direct I/O on the specified file descriptor. &nbsp; Direct &nbsp;I/O &nbsp;is &nbsp;per-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; formed &nbsp;directly to and from a user’s data buffer. &nbsp;Since the kernel’s buffer cache is no longer between</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the two, the user’s data buffer must conform to the same type of constraints as required for accessing a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; raw &nbsp;disk partition. &nbsp;The final argument points to a variable of type struct dioattr, which contains the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; following members: d_mem is the memory alignment requirement of the user’s data buffer. &nbsp;d_miniosz spec-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ifies &nbsp;block &nbsp;size, minimum I/O request size, and I/O alignment. &nbsp;The size of all I/O requests must be a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multiple of this amount and the value of the seek pointer at the time of the I/O request must also be an</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; integer &nbsp;multiple &nbsp;of &nbsp;this amount. &nbsp;d_maxiosz is the maximum I/O request size which can be performed on</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the file descriptor. &nbsp;If an I/O request does not meet these constraints, the read(2) &nbsp;or &nbsp;write(2) &nbsp;will</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fail &nbsp;with &nbsp;EINVAL. &nbsp; All &nbsp;I/O requests are kept consistent with any data brought into the cache with an</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; access through a non-direct I/O file descriptor.</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >5. man 2 open</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;sys/types.h&gt;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;sys/stat.h&gt;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;fcntl.h&gt;</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;int open(const char *pathname, int flags);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;int open(const char *pathname, int flags, mode_t mode);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >The full list of file creation flags &nbsp;and &nbsp;file &nbsp;status</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;flags is as follows:</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;O_DIRECT (Since Linux 2.4.10)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Try &nbsp;to &nbsp;minimize &nbsp;cache effects of the I/O to and from this file. &nbsp;In general this will degrade perfor-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mance, but it is useful in special situations, such as when applications do their own caching. &nbsp;File I/O</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is &nbsp;done &nbsp;directly &nbsp;to/from user space buffers. &nbsp;The I/O is synchronous, that is, at the completion of a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read(2) or write(2), data is guaranteed to have been transferred. &nbsp;See NOTES below for &nbsp;further &nbsp;discus-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sion.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A semantically similar (but deprecated) interface for block devices is described in raw(8).</font></div></div><div><font size="2"   >NOTE</font></div><div><div><font size="2"   >&nbsp; &nbsp;O_DIRECT</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;The O_DIRECT flag may impose alignment restrictions on the length and address of userspace buffers and the file</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;offset of I/Os. &nbsp;In Linux alignment restrictions vary by file system and kernel version &nbsp;and &nbsp;might &nbsp;be &nbsp;absent</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;entirely. &nbsp;However there is currently no file system-independent interface for an application to discover these</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;restrictions for a given file or file system. &nbsp;Some file systems provide their own interfaces for doing so, for</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;example the XFS_IOC_DIOINFO operation in xfsctl(3).</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Under Linux 2.4, transfer sizes, and the alignment of the user buffer and the file offset must all be multiples</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;of the logical block size of the file system. &nbsp;Under Linux 2.6, alignment to 512-byte boundaries suffices.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;O_DIRECT I/Os should never be run concurrently with the fork(2) system call, if the memory buffer is a &nbsp;private</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;mapping &nbsp;(i.e., &nbsp;any &nbsp;mapping &nbsp;created with the mmap(2) MAP_PRIVATE flag; this includes memory allocated on the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;heap and statically allocated buffers). &nbsp;Any such I/Os, whether submitted via an asynchronous I/O interface &nbsp;or</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;from &nbsp;another thread in the process, should be completed before fork(2) is called. &nbsp;Failure to do so can result</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;in data corruption and undefined behavior in parent and child processes. &nbsp;This restriction does not apply &nbsp;when</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;the &nbsp;memory &nbsp;buffer &nbsp;for the O_DIRECT I/Os was created using shmat(2) or mmap(2) with the MAP_SHARED flag. &nbsp;Nor</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;does this restriction apply when the memory buffer has been advised as MADV_DONTFORK with madvise(2), &nbsp;ensuring</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;that it will not be available to the child after fork(2).</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;The &nbsp;O_DIRECT &nbsp;flag &nbsp;was &nbsp;introduced in SGI IRIX, where it has alignment restrictions similar to those of Linux</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;2.4. &nbsp;IRIX has also a fcntl(2) call to query appropriate alignments, and sizes. &nbsp;FreeBSD 4.x introduced a &nbsp;flag</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;of the same name, but without alignment restrictions.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;O_DIRECT &nbsp;support was added under Linux in kernel version 2.4.10. &nbsp;Older Linux kernels simply ignore this flag.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Some file systems may not implement the flag and open() will fail with EINVAL if it is used.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Applications should avoid mixing O_DIRECT and normal I/O to the same file, and especially to &nbsp;overlapping &nbsp;byte</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;regions &nbsp;in the same file. &nbsp;Even when the file system correctly handles the coherency issues in this situation,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;overall I/O throughput is likely to be slower than using either &nbsp;mode &nbsp;alone. &nbsp; Likewise, &nbsp;applications &nbsp;should</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;avoid mixing mmap(2) of files with direct I/O to the same files.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;The &nbsp;behaviour &nbsp;of O_DIRECT with NFS will differ from local file systems. &nbsp;Older kernels, or kernels configured</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;in certain ways, may not support this combination. &nbsp;The NFS protocol does not support passing the flag &nbsp;to &nbsp;the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;server, so O_DIRECT I/O will only bypass the page cache on the client; the server may still cache the I/O. &nbsp;The</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;client asks the server to make the I/O synchronous to preserve the synchronous &nbsp;semantics &nbsp;of &nbsp;O_DIRECT. &nbsp; Some</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;servers &nbsp;will &nbsp;perform poorly under these circumstances, especially if the I/O size is small. &nbsp;Some servers may</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;also be configured to lie to clients about the I/O having reached stable storage; this will avoid &nbsp;the &nbsp;perfor-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;mance penalty at some risk to data integrity in the event of server power failure. &nbsp;The Linux NFS client places</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;no alignment restrictions on O_DIRECT I/O.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;In summary, O_DIRECT is a potentially powerful tool that should be used with caution. &nbsp;It is &nbsp;recommended &nbsp;that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;applications treat use of O_DIRECT as a performance option which is disabled by default.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "The &nbsp;thing &nbsp;that has always disturbed me about O_DIRECT is that the whole interface is just stupid, and</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; was probably designed by a deranged monkey on some serious mind-controlling substances." ― Linus</font></div></div><p></p></pre></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL why not DirectIO for datafile? - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>