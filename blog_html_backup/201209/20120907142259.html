<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL general public partition table trigger</h2>
	<h5 id="">2012-09-07 14:22:59&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020128772037884/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>触发器在数据库中的使用非常广泛, 例如用来跟踪用户行为, 用户登录过滤(Oracle中), 数据复制, 数据分区等等.&nbsp;</div><div>以前写过一些类似的应用场景案例分享, 感兴趣的朋友可以参考本文的末尾部分, 有相关的链接.&nbsp;</div><div>特别是在数据分区应用场景中, PostgreSQL目前没有将分区这部分代码作为COMMAND来实现.&nbsp;</div><div>因此DBA可能经常需要写繁琐的触发器, 例如昨天我们这边一位同事写的触发器, 我看了之后第一感觉就是太繁琐, 维护麻烦, 如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE OR REPLACE FUNCTION digoal.p_insert_info_trigger()</font></div><div><font size="2"   >&nbsp;RETURNS trigger</font></div><div><font size="2"   >&nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >AS $function$</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >IF ( NEW.createtime &gt;= DATE '2012-09-01' AND NEW.createtime &lt; DATE '2012-09-02' ) THEN</font></div><div><font size="2"   >INSERT INTO tbl_rop_info_20120901 VALUES (NEW.*);</font></div><div><font size="2"   >ELSIF ( NEW.createtime &gt;= DATE '2012-09-02' AND NEW.createtime &lt; DATE '2012-09-03' ) THEN</font></div><div><font size="2"   >INSERT INTO tbl_rop_info_20120902 VALUES (NEW.*);</font></div><div><font size="2"   >-- 中间略去几千行类似代码.&nbsp;</font></div><div><font size="2"   >ELSIF ( NEW.createtime &gt;= DATE '2015-06-19' AND NEW.createtime &lt; DATE '2015-06-20' ) THEN</font></div><div><font size="2"   >INSERT INTO tbl_rop_info_20150619 VALUES (NEW.*);</font></div><div><font size="2"   >ELSE</font></div><div><font size="2"   >RAISE EXCEPTION 'Date out of range. Fix the p_insert_info_trigger() function!';</font></div><div><font size="2"   >END IF;</font></div><div><font size="2"   >RETURN NULL;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$function$;</font></div><p></p></pre></div><div>能不能写一个通用的触发器呢? 减轻一下DBA维护这类代码的工作量.</div><div>当然是有的, 下面是例子 :&nbsp;</div><div>本例使用的是按照时间月份分区的通用触发器, 如果想改成hash取模或者按天分区的. 可以稍微修改一下这个触发器.</div><div>关于这个通用触发器的调优, 以后有时间再阐述.</div><div>为了更加通用, 我这里使用了2个触发器函数的参数, 第1个是子表的前缀, 第2个是分区字段.</div><div><div>我们定一个规则，表按照月分区，分区表名为tbl_yyyymm。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create or replace function general_trg_insert() returns trigger as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; v_partition_column name;</font></div><div><font size="2"   >&nbsp; v_subtable_prefix name;</font></div><div><font size="2"   >&nbsp; v_subtable_suffix name;</font></div><div><font size="2"   >&nbsp; v_subtable name;</font></div><div><font size="2"   >&nbsp; v_sql text;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; v_subtable_prefix := TG_ARGV[0];</font></div><div><font size="2"   >&nbsp; v_partition_column := TG_ARGV[1];</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; -- &nbsp;按分区字段值计算分区后缀</font></div><div><font size="2"   >&nbsp; execute $_$select to_char((('$_$||replace(NEW::text,$_$'$_$,$_$''$_$)||$_$'::$_$||TG_TABLE_SCHEMA||'.'||TG_TABLE_NAME||').'||v_partition_column||')::timestamp, $_$yyyymm$_$)' into v_subtable_suffix;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; -- &nbsp;拼接子表的表名</font></div><div><font size="2"   >&nbsp; v_subtable := v_subtable_prefix||'_'||v_subtable_suffix;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; -- &nbsp;生成动态SQL, 数据插入对应子表</font></div><div><font size="2"   >&nbsp; v_sql := 'insert into '||TG_TABLE_SCHEMA||'.'||v_subtable||$_$ select ('$_$||replace(NEW::text,$_$'$_$,$_$''$_$)||$_$'::$_$||TG_TABLE_SCHEMA||'.'||TG_TABLE_NAME||').*';</font></div><div><font size="2"   >&nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; -- 以下为DEBUG, 正式可以删掉raise notice.</font></div><div><font size="2"   >&nbsp; -- raise notice 'v_sql: %', v_sql;</font></div><div><font size="2"   >&nbsp; -- &nbsp;执行动态SQL</font></div><div><font size="2"   >&nbsp; execute v_sql;</font></div><div><font size="2"   >&nbsp; RETURN NULL;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >测试：</span></div><div>创建父表：</div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table rmt.tbl_login_log(id int primary key,info text,crt_time timestamp(6));</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >创建测试子表，子表的命名规则：前缀_后缀。</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table tbl_login_log_201504 (like tbl_login_log including all) inherits (tbl_login_log);</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >在父表上创建触发器，创建触发器时指定2个参数，分别表示父表的表名，以及分区字段名。</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create trigger tg_tbl_login_log_insert before insert on rmt.tbl_login_log for each row execute procedure general_trg_insert('tbl_login_log','crt_time');</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >插入测试数据：</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; insert into rmt.tbl_login_log values (1,E'I\'m digoal.zhou', now());</font></div><div><font size="2"   >NOTICE: &nbsp;v_sql: insert into rmt.tbl_login_log_201504 select ('(1,"I''m digoal.zhou","2015-04-19 18:22:18.21593")'::rmt.tbl_login_log).*</font></div><div><font size="2"   >INSERT 0 0</font></div><p></p></pre></div><div>查看子表是否有数据。</div><div>注意检查逃逸字符是否正常，这个在写触发器函数的时候一定要注意。</div><div>本例使用replace将单引号替换成两个单引号规避了这个问题。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select tableoid::regclass,* from rmt.tbl_login_log;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tableoid &nbsp; &nbsp; &nbsp; &nbsp; | id | &nbsp; &nbsp; &nbsp;info &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------------------+----+-----------------+---------------------------</font></div><div><font size="2"   >&nbsp;rmt.tbl_login_log_201504 | &nbsp;1 | I'm digoal.zhou | 2015-04-19 18:22:18.21593</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>CPU单核插入速度 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; insert into rmt.tbl_login_log select generate_series(2,100000),'digoal',now();</font></div><div><font size="2"   >INSERT 0 0</font></div><div><font size="2"   >Time: 19803.455 ms</font></div><p></p></pre></div><div><br></div><div>直接插入子表的速度 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; truncate rmt.tbl_login_log_201504 ;</font></div><div><font size="2"   >TRUNCATE TABLE</font></div><div><font size="2"   >Time: 30.486 ms</font></div><div><font size="2"   >digoal=&gt; insert into rmt.tbl_login_log_201504 select generate_series(2,100000),'digoal',now();</font></div><div><font size="2"   >INSERT 0 99999</font></div><div><font size="2"   >Time: 431.048 ms</font></div><p></p></pre></div><div>说明通用触发器比直接插入子表的速度下降45倍. 所以对于插入请求较多的表不适合使用.</div><div><br></div><div>使用非通用触发器的性能测试如下 :&nbsp;</div><div>触发器函数 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE OR REPLACE FUNCTION p_insert_info_trigger()</font></div><div><font size="2"   >&nbsp;RETURNS trigger</font></div><div><font size="2"   >&nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >AS $function$</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >IF ( NEW.crt_time &gt;= DATE '2015-04-01' AND NEW.crt_time &lt; DATE '2015-05-01' ) THEN</font></div><div><font size="2"   >INSERT INTO rmt.tbl_login_log_201504 VALUES (NEW.*);</font></div><div><font size="2"   >ELSE</font></div><div><font size="2"   >RAISE EXCEPTION 'Date out of range. Fix the p_insert_info_trigger() function!';</font></div><div><font size="2"   >END IF;</font></div><div><font size="2"   >RETURN NULL;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$function$;</font></div><p></p></pre></div><div>删除原触发器 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; drop trigger tg_tbl_login_log_insert on rmt.tbl_login_log;</font></div><div><font size="2"   >DROP TRIGGER</font></div><div><font size="2"   >Time: 0.937 ms</font></div><p></p></pre></div><div>创建触发器 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create trigger tg_tbl_login_log_insert before insert on rmt.tbl_login_log for each row execute procedure p_insert_info_trigger();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >Time: 1.006 ms</font></div><p></p></pre></div><div>删除表记录 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; truncate rmt.tbl_login_log_201504 ;</font></div><div><font size="2"   >TRUNCATE TABLE</font></div><div><font size="2"   >Time: 22.200 ms</font></div><p></p></pre></div><div>插入同样的数据 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; insert into rmt.tbl_login_log select generate_series(2,100000),'digoal',now();</font></div><div><font size="2"   >INSERT 0 0</font></div><div><font size="2"   >Time: 2734.205 ms</font></div><p></p></pre></div><div>结果使用非通用触发器的性能是通用触发器的7倍.&nbsp;</div><div><br></div><div>通用触发器插入一个没有创建好子表的情况，将报错如下：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; insert into rmt.tbl_login_log values (1,E'I\'m digoal.zhou', '2012-01-01'::timestamp);</font></div><div><font size="2"   >ERROR: &nbsp;relation "rmt.tbl_login_log_201201" does not exist</font></div><div><font size="2"   >LINE 1: insert into rmt.tbl_login_log_201201 select ('(1,"I''m digoa...</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >QUERY: &nbsp;insert into rmt.tbl_login_log_201201 select ('(1,"I''m digoal.zhou","2012-01-01 00:00:00")'::rmt.tbl_login_log).*</font></div><div><font size="2"   >CONTEXT: &nbsp;PL/pgSQL function general_trg_insert() line 24 at EXECUTE statement</font></div><div><font size="2"   >Time: 0.849 ms</font></div><p></p></pre></div><div>正因为是通用触发器，所以当然是为了通用而设计的，下面使用这个通用触发器再建立一个分区表的使用。</div><div>表结构与前面一个不一样，分区字段也不一样，schema也不一样。看看能不能正常使用？</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table rmt.tbl_logout_log</font></div><div><font size="2"   >(userid int primary key,&nbsp;</font></div><div><font size="2"   >firstname text,&nbsp;</font></div><div><font size="2"   >lastname text,&nbsp;</font></div><div><font size="2"   >age int,&nbsp;</font></div><div><font size="2"   >email text,&nbsp;</font></div><div><font size="2"   >ctime timestamp(6));</font></div><p></p></pre></div><div>分区字段换成ctime，命名为t_yyyymm。</div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table rmt.t_201504 (like rmt.tbl_logout_log including all) inherits(rmt.tbl_logout_log);</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >创建触发器, 注意触发器函数的2个参数的变化：</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create trigger tg_tbl_logout_log_insert before insert on rmt.tbl_logout_log for each row execute procedure general_trg_insert('t','ctime');</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >插入测试数据：</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; insert into rmt.tbl_logout_log values (1,'zhou','digoal',30,'digoal@126.com',now());</font></div><div><font size="2"   >INSERT 0 0</font></div><div><font size="2"   >Time: 3.919 ms</font></div><p></p></pre></div><div>查看数据。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select tableoid::regclass,* from rmt.tbl_logout_log ;</font></div><div><font size="2"   >&nbsp; &nbsp;tableoid &nbsp; | userid | firstname | lastname | age | &nbsp; &nbsp; email &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctime &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------+--------+-----------+----------+-----+----------------+----------------------------</font></div><div><font size="2"   >&nbsp;rmt.t_201504 | &nbsp; &nbsp; &nbsp;1 | zhou &nbsp; &nbsp; &nbsp;| digoal &nbsp; | &nbsp;30 | digoal@126.com | 2015-04-19 18:36:58.234009</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div><br></div><div><p></p></div><div>【其他】</div><div>1. 下面两个触发器函数中的变量:&nbsp;<span style="line-height: 22px;"   >( 类似C里面 main(int argc, char *argv[]) )</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >TG_NARGS&nbsp;</font></div><div><font size="2"   >Data type integer; the number of arguments given to the trigger procedure in the CREATE TRIGGER statement.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >TG_ARGV[]</font></div><div><font size="2"   >Data type array of text; the arguments from the CREATE TRIGGER statement. The index counts from 0. Invalid indexes (less than 0 or greater than or equal to tg_nargs) result in a null value.</font></div><p></p></pre></div><div>2. NEW在触发器中是一个TG_TABLE_NAME类型的变量. 所以在动态SQL中可以把它转成TG_TABLE_NAME的类型.&nbsp;</div><div>&nbsp; &nbsp; 这样才能方便的取出它存储的单项值. 为后面拼装INSERT的动态SQL提供可能.</div><div>&nbsp; &nbsp; 如下 :&nbsp;</div><div><pre class="prettyprint"   ><p><font size="2"   >&nbsp; &nbsp; execute 'select quote_nullable(($_$'||NEW||'$_$::'||TG_TABLE_NAME||').'||v_attname||')' into v_values_tmp;</font></p></pre></div><div>3. 其他你可能需要了解但是本文未详细描述的如, 游标, plpgsql函数语法, 字符串封装函数, 触发器变量等 请参考如下URL.</div><div><a rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/plpgsql-cursors.html"   >http://www.postgresql.org/docs/9.2/static/plpgsql-cursors.html</a> </div><div><a rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE"   >http://www.postgresql.org/docs/9.2/static/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE</a> </div><div><a rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/functions-string.html"   >http://www.postgresql.org/docs/9.2/static/functions-string.html</a> </div><div><a rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/plpgsql-trigger.html"   >http://www.postgresql.org/docs/9.2/static/plpgsql-trigger.html</a> </div><div><a rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/sql-createtrigger.html"   >http://www.postgresql.org/docs/9.2/static/sql-createtrigger.html</a> </div><div><br></div><div>4. 字符串封装, 特别提一下 :&nbsp;</div><div><div><img title="PostgreSQL general public partition table trigger - 德哥@Digoal - The Heart,The World."   alt="PostgreSQL general public partition table trigger - 德哥@Digoal - The Heart,The World."   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/OLvCyLS3NdqPW_whuPALZQ==/6597771255074575462.jpg"   ></div>&nbsp;</div><div>拼装时, 如果是表名, 列名. 使用quote_ident封装(双引号封装), 如果是值, 可以使用quote_literal或者quote_nullable.</div><div><br></div><div>【小结】</div><div>1. 权衡维护量和性能, 通用的触发器要用到动态SQL(增加15%左右CPU开销).&nbsp;</div><div>&nbsp; &nbsp; IF ELSIF写的触发器虽然没有动态SQL, 但是当条件命中在末端时, 上千个判断带来的CPU开销比动态SQL性能更烂.</div><div>&nbsp; &nbsp; 通用触发器的性能比非通用触发器要查25倍。 所以还有很大的优化空间。</div><div>2. IF ELSIF也可有优化手段, 参考《<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402011210114036419/"   >PostgreSQL partition table's arithmetic tuning example</a>》</div><div>3. 通用触发器简化了触发器的编写和维护工作, 但是也带来了巨大的性能损失, 当然还有很大的优化空间.</div><div><br></div>【参考】<div><div>trigger 在分区表方面的应用案例:</div><div>1. PostgreSQL Partition Table Example</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012325111528424/"   >http://blog.163.com/digoal@126/blog/static/1638770402012325111528424/</a></div><div>2. PostgreSQL partition table's arithmetic tuning example</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402011210114036419/"   >http://blog.163.com/digoal@126/blog/static/1638770402011210114036419/</a></div><div>3. execute plan difference between Oracle and PostgreSQL's partition table</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201212432441676/"   >http://blog.163.com/digoal@126/blog/static/163877040201212432441676/</a></div><div>4. Compare Oracle's &amp; PostgreSQL's Partition Table write performance</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201123084853271/"   >http://blog.163.com/digoal@126/blog/static/163877040201123084853271/</a></div><div>5. Partition Table monitor on PostgreSQL</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201082964624615/"   >http://blog.163.com/digoal@126/blog/static/163877040201082964624615/</a></div><div>6. how many performance decreased use dynamic SQL</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402011109103953350/"   >http://blog.163.com/digoal@126/blog/static/1638770402011109103953350/</a></div><div><br></div><div>trigger 在其他方面的应用案例:</div><div>1. implement PostgreSQL table have one and only one row</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201251931517556/"   >http://blog.163.com/digoal@126/blog/static/163877040201251931517556/</a></div><div>2. table level replication use trigger -- one(rw) to many(ro|rw)</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012731203716/"   >http://blog.163.com/digoal@126/blog/static/1638770402012731203716/</a></div><div>3. table level replication use trigger -- multi master replication &amp; performance tuning</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012731944439/"   >http://blog.163.com/digoal@126/blog/static/1638770402012731944439/</a></div><div>4. USE hstore store table's trace record</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201252575529358/"   >http://blog.163.com/digoal@126/blog/static/163877040201252575529358/</a></div><div>5. Use timetravel function trace tuple's DML.&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020120133019990/"   >http://blog.163.com/digoal@126/blog/static/16387704020120133019990/</a></div><wbr></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL general public partition table trigger - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>