<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL Subplan or subquery BUG? - NO, non exists column can used in subquery</h2>
	<h5 id="">2015-06-02 22:29:12&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201552101244474/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>一个看似诡异的查询，实际上是SQL标准中的correlated subqueries。</div><div>概念：</div><div><a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Correlated_subquery"   >http://en.wikipedia.org/wiki/Correlated_subquery</a></div><div><span style="color: rgb(37, 37, 37); font-family: sans-serif; font-size: 14px; line-height: 22.3999996185303px;"   >In a&nbsp;</span><a title="SQL" style="text-decoration: none; color: rgb(11, 0, 128); font-family: sans-serif; font-size: 14px; line-height: 22.3999996185303px; background-image: none; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;" rel="nofollow" href="http://en.wikipedia.org/wiki/SQL"   >SQL</a><span style="color: rgb(37, 37, 37); font-family: sans-serif; font-size: 14px; line-height: 22.3999996185303px;"   >&nbsp;</span><a title="Database" style="text-decoration: none; color: rgb(11, 0, 128); font-family: sans-serif; font-size: 14px; line-height: 22.3999996185303px; background-image: none; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;" rel="nofollow" href="http://en.wikipedia.org/wiki/Database"   >database</a><span style="color: rgb(37, 37, 37); font-family: sans-serif; font-size: 14px; line-height: 22.3999996185303px;"   >&nbsp;</span><a title="Query language" style="text-decoration: none; color: rgb(11, 0, 128); font-family: sans-serif; font-size: 14px; line-height: 22.3999996185303px; background-image: none; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;" rel="nofollow" href="http://en.wikipedia.org/wiki/Query_language"   >query</a><span style="color: rgb(37, 37, 37); font-family: sans-serif; font-size: 14px; line-height: 22.3999996185303px;"   >, a&nbsp;</span><b style="color: rgb(37, 37, 37); font-family: sans-serif; font-size: 14px; line-height: 22.3999996185303px;"   >correlated subquery</b><span style="color: rgb(37, 37, 37); font-family: sans-serif; font-size: 14px; line-height: 22.3999996185303px;"   >&nbsp;(also known as a&nbsp;</span><b style="color: rgb(37, 37, 37); font-family: sans-serif; font-size: 14px; line-height: 22.3999996185303px;"   >synchronized subquery</b><span style="color: rgb(37, 37, 37); font-family: sans-serif; font-size: 14px; line-height: 22.3999996185303px;"   >) is a subquery (a query nested inside another query) that uses values from the outer query. The subquery is evaluated once for each row processed by the outer query.</span></div><div>例子，当使用子查询进行＝或in的匹配时，如果subquery中查询了一个本身不存在的列，并且列名在outer table中存在，就会转换为subplan。(correlated subqueries输出的是outer table的列)。</div><div>例如：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create table table1 (c1 int, c2 int, c3 int, c4 text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# create table table2 (id int);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# insert into table1 values (1,2,3,'test');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into table1 values (2,3,4,'test');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into table2 values (100);</font></div><div><font size="2"   >INSERT 0 1</font></div><p></p></pre></div><div>c1列在table2中并不存在，转换为<span style="line-height: 28px;"   >correlated subquries。执行计划如下：</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain (analyze,verbose) select * from table1 where c1 = (select c1 from table2 limit 1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on public.table1 &nbsp;(cost=0.00..116.59 rows=23 width=44) (actual time=0.020..0.023 rows=2 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: table1.c1, table1.c2, table1.c3, table1.c4</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (table1.c1 = (SubPlan 1))</font></div><div><font size="2"   >&nbsp; &nbsp;SubPlan 1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;-&gt; &nbsp;Limit &nbsp;(cost=0.00..0.01 rows=1 width=0) (actual time=0.003..0.003 rows=1 loops=2)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: (table1.c1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.table2 &nbsp;(cost=0.00..112.30 rows=10230 width=0) (actual time=0.002..0.002 rows=1 loops=2)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: table1.c1</font></div><div><font size="2"   >&nbsp;Planning time: 0.169 ms</font></div><div><font size="2"   >&nbsp;Execution time: 0.070 ms</font></div><div><font size="2"   >(10 rows)</font></div><p></p></pre></div><div><div>c2在table2 不存在，但是在outer table table1中存在，同样这个subquery是correlated subquery：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain select * from table1 where c1 = (select c2 from table2 where id=1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on table1 &nbsp;(cost=0.00..576322.75 rows=22 width=44)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (c1 = (SubPlan 1))</font></div><div><font size="2"   >&nbsp; &nbsp;SubPlan 1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on table2 &nbsp;(cost=0.00..130.38 rows=48 width=0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (id = 1)</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div></div><div>使用in和=一样，优化器还是用了subplan。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain (analyze,verbose) select * from table1 where c1 in (select c1 from table2 limit 1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on public.table1 &nbsp;(cost=0.00..97.34 rows=2270 width=44) (actual time=0.018..0.022 rows=2 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: table1.c1, table1.c2, table1.c3, table1.c4</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (SubPlan 1)</font></div><div><font size="2"   >&nbsp; &nbsp;SubPlan 1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;-&gt; &nbsp;Limit &nbsp;(cost=0.00..0.01 rows=1 width=0) (actual time=0.003..0.003 rows=1 loops=2)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: (table1.c1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.table2 &nbsp;(cost=0.00..112.30 rows=10230 width=0) (actual time=0.002..0.002 rows=1 loops=2)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: table1.c1</font></div><div><font size="2"   >&nbsp;Planning time: 0.102 ms</font></div><div><font size="2"   >&nbsp;Execution time: 0.069 ms</font></div><div><font size="2"   >(10 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><span style="line-height: 21px;"   >对于correlated subquery, outer table处理每行时，subquery也处理一次。</span></font></div><div><font size="2"   >postgres=# select * from table1 where c1 in (select c1 from table2 limit 1);</font></div><div><font size="2"   >&nbsp;c1 | c2 | c3 | &nbsp;c4 &nbsp;</font></div><div><font size="2"   >----+----+----+------</font></div><div><font size="2"   >&nbsp; 1 | &nbsp;2 | &nbsp;3 | test</font></div><div><font size="2"   >&nbsp; 2 | &nbsp;3 | &nbsp;4 | test</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# select * from table1 where c1 = (select c1 from table2 limit 1);</font></div><div><font size="2"   >&nbsp;c1 | c2 | c3 | &nbsp;c4 &nbsp;</font></div><div><font size="2"   >----+----+----+------</font></div><div><font size="2"   >&nbsp; 1 | &nbsp;2 | &nbsp;3 | test</font></div><div><font size="2"   >&nbsp; 2 | &nbsp;3 | &nbsp;4 | test</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >所以</font></div><div><font size="2"   >postgres=# select * from table1 where c1 = (select c1 from table2 limit 1);<br> c1 | c2 | c3 |  c4  <br>----+----+----+------<br>  1 |  2 |  3 | test<br>  2 |  3 |  4 | test<br>(2 rows)<br>这样是查不到结果的，因为table2.id = 100, 没有=1的。<br>postgres=# select * from table1 where c1 = (select c1 from table2 where id=1);<br> c1 | c2 | c3 | c4 <br>----+----+----+----<br>(0 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><span style="line-height: 21px;"   >同样的，如果有多行返回，则不要使用=</span></font></div><div><font size="2"   >postgres=# insert into table2 values (1);<br>INSERT 0 1<br>postgres=# insert into table2 values (1);<br>INSERT 0 1<br>postgres=# select * from table1 where c1 = (select c1 from table2 where id=1);<br>ERROR:  more than one row returned by a subquery used as an expression</font></div><div><font size="2"   ><br>postgres=# select * from table1 where c1 in (select c1 from table2 where id=1);<br> c1 | c2 | c3 |  c4  <br>----+----+----+------<br>  1 |  2 |  3 | test<br>  2 |  3 |  4 | test<br>(2 rows)</font></div><p></p></pre></div><div>如果在subquery中加上修饰，将报错，因为没有自动使用<span style="line-height: 28px;"   >correlated column</span><span style="line-height: 28px;"   >：</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain (analyze,verbose) select * from table1 where c1 = (select table2.c1 from table2 limit 1);</font></div><div><font size="2"   >ERROR: &nbsp;column table2.c1 does not exist</font></div><div><font size="2"   >LINE 1: ...,verbose) select * from table1 where c1 = (select table2.c1 ...</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><p></p></pre></div><div>单独查询不存在的列也会报错的，因为没有correlated column：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain select c1 from table2 limit 1;</font></div><div><font size="2"   >ERROR: &nbsp;column "c1" does not exist</font></div><div><font size="2"   >LINE 1: explain select c1 from table2 limit 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><p></p></pre></div><div>把subquery放在select子句中，也可能生成correlated subqueries。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 21px;"   >postgres=# explain (analyze,verbose) select (select c1 from table2 limit 1) from table1;<br>                                                        QUERY PLAN                                                         <br>---------------------------------------------------------------------------------------------------------------------------<br> Seq Scan on public.table1  (cost=0.00..105.24 rows=4540 width=4) (actual time=0.013..0.017 rows=2 loops=1)<br>   Output: (SubPlan 1)<br>   SubPlan 1<br>     -&gt;  Limit  (cost=0.00..0.01 rows=1 width=0) (actual time=0.002..0.002 rows=1 loops=2)<br>           Output: (table1.c1)<br>           -&gt;  Seq Scan on public.table2  (cost=0.00..112.30 rows=10230 width=0) (actual time=0.001..0.001 rows=1 loops=2)<br>                 Output: table1.c1<br> Planning time: 0.100 ms<br> Execution time: 0.070 ms<br>(9 rows)</span></font></div><div><font size="2"   ><span style="line-height: 21px;"   ><br>对于使用correlated column的情况，不管有没有写表的alias, 执行计划完全一致，仅仅当subquery不存在c1列时<br>postgres=# explain (analyze,verbose) select (select table1.c1 from table2 limit 1) from table1;<br>                                                        QUERY PLAN                                                         <br>---------------------------------------------------------------------------------------------------------------------------<br> Seq Scan on public.table1  (cost=0.00..105.24 rows=4540 width=4) (actual time=0.012..0.015 rows=2 loops=1)<br>   Output: (SubPlan 1)<br>   SubPlan 1<br>     -&gt;  Limit  (cost=0.00..0.01 rows=1 width=0) (actual time=0.002..0.002 rows=1 loops=2)<br>           Output: (table1.c1)<br>           -&gt;  Seq Scan on public.table2  (cost=0.00..112.30 rows=10230 width=0) (actual time=0.001..0.001 rows=1 loops=2)<br>                 Output: table1.c1<br> Planning time: 0.059 ms<br> Execution time: 0.049 ms</span></font></div><div><font size="2"   ><span style="line-height: 21px;"   ><br></span></font></div><p></p></pre></div><div><br></div><div>如果使用的字段名与查询条件字段名不一致，不会转换为subplan：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain select * from table1 where c1 = (select id from table2 limit 1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on table1 &nbsp;(cost=0.01..66.76 rows=23 width=44)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (c1 = $0)</font></div><div><font size="2"   >&nbsp; &nbsp;InitPlan 1 (returns $0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;-&gt; &nbsp;Limit &nbsp;(cost=0.00..0.01 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on table2 &nbsp;(cost=0.00..112.30 rows=10230 width=4)</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >当子查询的表真实存在查询列时，也不会转换为subquery</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# alter table table2 add column c1 int;</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >postgres=# explain select * from table1 where c1 = (select c1 from table2 limit 1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on table1 &nbsp;(cost=0.01..66.76 rows=23 width=44)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (c1 = $0)</font></div><div><font size="2"   >&nbsp; &nbsp;InitPlan 1 (returns $0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;-&gt; &nbsp;Limit &nbsp;(cost=0.00..0.01 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on table2 &nbsp;(cost=0.00..100.90 rows=9090 width=4)</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div><div style="line-height: 28px;"   >对于系统表，同样适用：</div><div style="line-height: 28px;"   ><pre class="prettyprint"   style="line-height: 28px;"   ><p style="line-height: 28px;"   ></p><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >postgres=# explain select tablename from tt;</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >ERROR: &nbsp;column "tablename" does not exist</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >LINE 1: explain select tablename from tt;</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >postgres=# \d tt</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; Table "public.tt"</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;Column | &nbsp;Type &nbsp; | Modifiers&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >--------+---------+-----------</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;id &nbsp; &nbsp; | integer |&nbsp;</font></div></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >postgres=# explain (analyze, verbose) select * from pg_tables where tablename in (select tablename from tt);</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >----------------------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;Nested Loop Left Join &nbsp;(cost=0.00..32052.66 rows=51 width=199) (actual time=0.045..0.802 rows=102 loops=1)</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp;Output: n.nspname, c.relname, pg_get_userbyid(c.relowner), t.spcname, c.relhasindex, c.relhasrules, c.relhastriggers</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp;Join Filter: (t.oid = c.reltablespace)</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp;Rows Removed by Join Filter: 296</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp;-&gt; &nbsp;Nested Loop Left Join &nbsp;(cost=0.00..32049.20 rows=51 width=139) (actual time=0.033..0.637 rows=102 loops=1)</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: c.relname, c.relowner, c.relhasindex, c.relhasrules, c.relhastriggers, c.reltablespace, n.nspname</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Join Filter: (n.oid = c.relnamespace)</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rows Removed by Join Filter: 918</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on pg_catalog.pg_class c &nbsp;(cost=0.00..32040.43 rows=51 width=79) (actual time=0.020..0.341 rows=102 loops=1)</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: c.relname, c.relnamespace, c.reltype, c.reloftype, c.relowner, c.relam, c.relfilenode, c.reltablespace, c.rel</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >pages, c.reltuples, c.relallvisible, c.reltoastrelid, c.relhasindex, c.relisshared, c.relpersistence, c.relkind, c.relnatts, c.relch</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >ecks, c.relhasoids, c.relhaspkey, c.relhasrules, c.relhastriggers, c.relhassubclass, c.relispopulated, c.relreplident, c.relfrozenxi</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >d, c.relminmxid, c.relacl, c.reloptions</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: ((c.relkind = 'r'::"char") AND (SubPlan 1))</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rows Removed by Filter: 389</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SubPlan 1</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.tt &nbsp;(cost=0.00..106.30 rows=9630 width=0) (actual time=0.001..0.001 rows=1 loops=102)</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: c.relname</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Materialize &nbsp;(cost=0.00..1.15 rows=10 width=68) (actual time=0.000..0.001 rows=10 loops=102)</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: n.nspname, n.oid</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on pg_catalog.pg_namespace n &nbsp;(cost=0.00..1.10 rows=10 width=68) (actual time=0.003..0.005 rows=10 loops</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >=1)</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: n.nspname, n.oid</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp;-&gt; &nbsp;Materialize &nbsp;(cost=0.00..1.04 rows=3 width=68) (actual time=0.000..0.000 rows=3 loops=102)</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: t.spcname, t.oid</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on pg_catalog.pg_tablespace t &nbsp;(cost=0.00..1.03 rows=3 width=68) (actual time=0.002..0.003 rows=3 loops=1)</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: t.spcname, t.oid</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;Planning time: 0.367 ms</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;Execution time: 0.887 ms</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >(25 rows)</font></div></div></pre></div></div><div><br></div><div>这并不是BUG，SQL标准就是这样的。</div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/features-sql-standard.html"   >http://www.postgresql.org/docs/9.4/static/features-sql-standard.html</a></div><div><table border="1"   style="margin: 2ex 0px 2ex 2ex; -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border-spacing: 0px; border-collapse: collapse; border: 2px solid rgb(167, 198, 223); color: rgb(0, 0, 0); font-family: verdana, sans-serif; font-size: 12.1599998474121px; line-height: normal; background-color: rgb(224, 236, 239);"   ><tbody><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >E061-13</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Core</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Correlated subqueries</td></tr></table></div><div><br></div><div>其实在Oracle中也是这么处理的，如下：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >SQL&gt; create table t1(c1 int,c2 int,c3 int,c4 varchar(10));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Table created.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SQL&gt; create table t2(id int);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Table created.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SQL&gt; insert into t1 values (1,2,3,'test');</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >1 row created.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SQL&gt; insert into t1 values (2,3,4,'t');</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >1 row created.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SQL&gt; insert into t2 values (100);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >1 row created.</font></div></div><div><div><font size="2"   >SQL&gt; set autotrace on</font></div><div><font size="2"   >SQL&gt; select * from t1 where c1=(select c1 from t2); &nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; C1 &nbsp; &nbsp; &nbsp; &nbsp; C2 &nbsp; &nbsp; &nbsp; &nbsp; C3 C4</font></div><div><font size="2"   >---------- ---------- ---------- ----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 test</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 t</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Execution Plan</font></div><div><font size="2"   >----------------------------------------------------------</font></div><div><font size="2"   >Plan hash value: 895956251</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >---------------------------------------------------------------------------</font></div><div><font size="2"   >| Id &nbsp;| Operation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Name | Rows &nbsp;| Bytes | Cost (%CPU)| Time &nbsp; &nbsp; |</font></div><div><font size="2"   >---------------------------------------------------------------------------</font></div><div><font size="2"   >| &nbsp; 0 | SELECT STATEMENT &nbsp; | &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 1 | &nbsp; &nbsp;46 | &nbsp; &nbsp; 4 &nbsp; (0)| 00:00:01 |</font></div><div><font size="2"   >|* &nbsp;1 | &nbsp;FILTER &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|</font></div><div><font size="2"   >| &nbsp; 2 | &nbsp; TABLE ACCESS FULL| T1 &nbsp; | &nbsp; &nbsp; 2 | &nbsp; &nbsp;92 | &nbsp; &nbsp; 2 &nbsp; (0)| 00:00:01 |</font></div><div><font size="2"   >| &nbsp; 3 | &nbsp; TABLE ACCESS FULL| T2 &nbsp; | &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; 2 &nbsp; (0)| 00:00:01 |</font></div><div><font size="2"   >---------------------------------------------------------------------------</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Predicate Information (identified by operation id):</font></div><div><font size="2"   >---------------------------------------------------</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp;1 - filter("C1"= (SELECT /*+ */ :B1 FROM "T2" "T2"))</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Note</font></div><div><font size="2"   >-----</font></div><div><font size="2"   >&nbsp; &nbsp;- dynamic sampling used for this statement</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Statistics</font></div><div><font size="2"   >----------------------------------------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp;recursive calls</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp;db block gets</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 &nbsp;consistent gets</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp;physical reads</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp;redo size</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 763 &nbsp;bytes sent via SQL*Net to client</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 487 &nbsp;bytes received via SQL*Net from client</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp;SQL*Net roundtrips to/from client</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp;sorts (memory)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp;sorts (disk)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp;rows processed</font></div></div><p></p></pre></div><div><br></div><div>[参考]</div><div>1.&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* pull_varnos</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Create a set of all the distinct varnos present in a parsetree.</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Only varnos that reference level-zero rtable entries are considered.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* NOTE: this is used on not-yet-planned expressions. &nbsp;It may therefore find</font></div><div><font size="2"   >&nbsp;* bare SubLinks, and if so it needs to recurse into them to look for uplevel</font></div><div><font size="2"   >&nbsp;* references to the desired rtable level! &nbsp; &nbsp; &nbsp;But when we find a completed</font></div><div><font size="2"   >&nbsp;* SubPlan, we only need to look at the parameters passed to the subplan.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >Relids</font></div><div><font size="2"   >pull_varnos(Node *node)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pull_varnos_context context;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; context.varnos = NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; context.sublevels_up = 0;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Must be prepared to start with a Query or a bare expression tree; if</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* it's a Query, we don't want to increment sublevels_up.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; query_or_expression_tree_walker(node,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pull_varnos_walker,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (void *) &amp;context,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return context.varnos;</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Convert a SubLink (as created by the parser) into a SubPlan.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We are given the SubLink's contained query, type, and testexpr. &nbsp;We are</font></div><div><font size="2"   >&nbsp;* also told if this expression appears at top level of a WHERE/HAVING qual.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: we assume that the testexpr has been AND/OR flattened (actually,</font></div><div><font size="2"   >&nbsp;* it's been through eval_const_expressions), but not converted to</font></div><div><font size="2"   >&nbsp;* implicit-AND form; and any SubLinks in it should already have been</font></div><div><font size="2"   >&nbsp;* converted to SubPlans. &nbsp;The subquery is as yet untouched, however.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The result is whatever we need to substitute in place of the SubLink</font></div><div><font size="2"   >&nbsp;* node in the executable expression. &nbsp;This will be either the SubPlan</font></div><div><font size="2"   >&nbsp;* node (if we have to do the subplan as a subplan), or a Param node</font></div><div><font size="2"   >&nbsp;* representing the result of an InitPlan, or a row comparison expression</font></div><div><font size="2"   >&nbsp;* tree containing InitPlan Param nodes.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static Node *</font></div><div><font size="2"   >make_subplan(PlannerInfo *root, Query *orig_subquery, SubLinkType subLinkType,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Node *testexpr, bool isTopQual)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Query &nbsp; &nbsp; &nbsp;*subquery;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;simple_exists = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tuple_fraction;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Plan &nbsp; &nbsp; &nbsp; *plan;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PlannerInfo *subroot;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; List &nbsp; &nbsp; &nbsp; *plan_params;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Node &nbsp; &nbsp; &nbsp; *result;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Copy the source Query node. &nbsp;This is a quick and dirty kluge to resolve</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the fact that the parser can generate trees with multiple links to the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* same sub-Query node, but the planner wants to scribble on the Query.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Try to clean this up when we do querytree redesign...</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; subquery = (Query *) copyObject(orig_subquery);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If it's an EXISTS subplan, we might be able to simplify it.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (subLinkType == EXISTS_SUBLINK)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; simple_exists = simplify_EXISTS_query(subquery);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* For an EXISTS subplan, tell lower-level planner to expect that only the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* first tuple will be retrieved. &nbsp;For ALL and ANY subplans, we will be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* able to stop evaluating if the test condition fails or matches, so very</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* often not all the tuples will be retrieved; for lack of a better idea,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* specify 50% retrieval. &nbsp;For EXPR and ROWCOMPARE subplans, use default</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* behavior (we're only expecting one row out, anyway).</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* NOTE: if you change these numbers, also change cost_subplan() in</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* path/costsize.c.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* XXX If an ANY subplan is uncorrelated, build_subplan may decide to hash</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* its output. &nbsp;In that case it would've been better to specify full</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* retrieval. &nbsp;At present, however, we can only check hashability after</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we've made the subplan :-(. &nbsp;(Determining whether it'll fit in work_mem</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* is the really hard part.) &nbsp;Therefore, we don't want to be too</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* optimistic about the percentage of tuples retrieved, for fear of</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* selecting a plan that's bad for the materialization case.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (subLinkType == EXISTS_SUBLINK)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = 1.0; &nbsp; /* just like a LIMIT 1 */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else if (subLinkType == ALL_SUBLINK ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;subLinkType == ANY_SUBLINK)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = 0.5; &nbsp; /* 50% */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_fraction = 0.0; &nbsp; /* default behavior */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* plan_params should not be in use in current query level */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(root-&gt;plan_params == NIL);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Generate the plan for the subquery.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; plan = subquery_planner(root-&gt;glob, subquery,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; false, tuple_fraction,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;subroot);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Isolate the params needed by this specific subplan */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; plan_params = root-&gt;plan_params;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; root-&gt;plan_params = NIL;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* And convert to SubPlan or InitPlan format. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; result = build_subplan(root, plan, subroot, plan_params,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;subLinkType, testexpr, true, isTopQual);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If it's a correlated EXISTS with an unimportant targetlist, we might be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* able to transform it to the equivalent of an IN and then implement it</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* by hashing. &nbsp;We don't have enough information yet to tell which way is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* likely to be better (it depends on the expected number of executions of</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the EXISTS qual, and we are much too early in planning the outer query</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to be able to guess that). &nbsp;So we generate both plans, if possible, and</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* leave it to the executor to decide which to use.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (simple_exists &amp;&amp; IsA(result, SubPlan))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node &nbsp; &nbsp; &nbsp; *newtestexpr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List &nbsp; &nbsp; &nbsp; *paramIds;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Make a second copy of the original subquery */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subquery = (Query *) copyObject(orig_subquery);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* and re-simplify */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; simple_exists = simplify_EXISTS_query(subquery);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(simple_exists);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* See if it can be converted to an ANY query */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subquery = convert_EXISTS_to_ANY(root, subquery,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;newtestexpr, &amp;paramIds);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (subquery)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Generate the plan for the ANY subquery; we'll need all rows */</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = subquery_planner(root-&gt;glob, subquery,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; false, 0.0,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;subroot);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Isolate the params needed by this specific subplan */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan_params = root-&gt;plan_params;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;plan_params = NIL;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Now we can check if it'll fit in work_mem */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (subplan_is_hashable(plan))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubPlan &nbsp; &nbsp;*hashplan;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlternativeSubPlan *asplan;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* OK, convert to SubPlan format. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashplan = (SubPlan *) build_subplan(root, plan, subroot,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;plan_params,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ANY_SUBLINK, newtestexpr,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;false, true);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Check we got what we expected */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(IsA(hashplan, SubPlan));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(hashplan-&gt;parParam == NIL);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(hashplan-&gt;useHashTable);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* build_subplan won't have filled in paramIds */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashplan-&gt;paramIds = paramIds;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Leave it to the executor to decide which plan to use */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; asplan = makeNode(AlternativeSubPlan);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; asplan-&gt;subplans = list_make2(result, hashplan);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Node *) asplan;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return result;</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><br></div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL Subplan or subquery BUG? non exists column can used in subquery - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>