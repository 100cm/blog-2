<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">阿里云RDS for PostgreSQL试用报告 - 3</h2>
	<h5 id="">2015-06-11 21:40:36&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201551185457509/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>上一篇测试中用了16个最低配置的RDS实例，测试中发现这16个实例实际上是分布在8台主机上（通过 inet_server_addr() IP区分）。测试使用plproxy做数据水平拆分，在16个实例中创建了32个DB，将6400万数据拆分到32个库。</div><div><div style="line-height: 28px;"   ><a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015599230431/"   >http://blog.163.com/digoal@126/blog/static/1638770402015599230431/</a></div><div style="line-height: 28px;"   ><a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020155104492068/"   >http://blog.163.com/digoal@126/blog/static/16387704020155104492068/</a></div></div><div><br></div><div>接下来要做的是单个RDS实例（同样的配置）承载6400万数据的测试。</div><div><span style="line-height: 28px;"   >创建测试表，生成测试数据。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create table userinfo(userid int,info text);</font></div><div><font size="2"   >create table session (userid int,last_login timestamp);</font></div><div><font size="2"   >create table login_log (userid int,db_user name,client_addr inet,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;client_port int,server_addr inet,server_port int,login_time timestamp);</font></div><div><font size="2"   >create table tbl_small (userid int primary key,info text);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >set synchronous_commit=off;</font></div><div><font size="2"   >insert into userinfo select generate_series(1,32000000);</font></div><div><font size="2"   >insert into session select generate_series(1,32000000);</font></div><div><font size="2"   >insert into tbl_small select generate_series(1,500000);</font></div><div><font size="2"   >set maintenance_work_mem='10GB';</font></div><div><font size="2"   >alter table userinfo add constraint pk_userinfo primary key (userid);</font></div><div><font size="2"   >alter table session add constraint pk_session primary key (userid);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=&gt; \dt+</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp; &nbsp; &nbsp;Name &nbsp; &nbsp; &nbsp; | Type &nbsp;| Owner &nbsp;| &nbsp;Size &nbsp; | Description&nbsp;</font></div><div><font size="2"   >--------+-----------------+-------+--------+---------+-------------</font></div><div><font size="2"   >&nbsp;public | ha_health_check | table | aurora | 40 kB &nbsp; |&nbsp;</font></div><div><font size="2"   >&nbsp;public | session &nbsp; &nbsp; &nbsp; &nbsp; | table | digoal | 1106 MB |&nbsp;</font></div><div><font size="2"   >&nbsp;public | userinfo &nbsp; &nbsp; &nbsp; &nbsp;| table | digoal | 1106 MB |&nbsp;</font></div><div><font size="2"   >(3 rows)</font></div><div><font size="2"   >postgres=&gt; \di+</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp; &nbsp; &nbsp; &nbsp; Name &nbsp; &nbsp; &nbsp; &nbsp; | Type &nbsp;| Owner &nbsp;| &nbsp; &nbsp; &nbsp;Table &nbsp; &nbsp; &nbsp;| &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+----------------------+-------+--------+-----------------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | ha_health_check_pkey | index | aurora | ha_health_check | 16 kB &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;public | pk_session &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | index | digoal | session &nbsp; &nbsp; &nbsp; &nbsp; | 686 MB |&nbsp;</font></div><div><font size="2"   >&nbsp;public | pk_userinfo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| index | digoal | userinfo &nbsp; &nbsp; &nbsp; &nbsp;| 686 MB |&nbsp;</font></div><div><font size="2"   >(3 rows)</font></div><p></p></pre></div><div><br></div><div>测试中发现一个小小的问题，阿里云RDS限制了数据库进程的内存使用（包括shared buffers,work_mem,maintenance_work_mem, wal_buffers等限制），但是并不会限制OS层缓存的使用，也就是说我们的数据表对应的数据文件如果是热数据的话，可能被缓存好OS层缓存中，假如RDS能提供pgfincore插件就更完美了，不过在云环境中使用会造成内存争抢的情况。</div><div>下面我们看一个测试，实例只有256MB的shared buffer, 下面的查询却飞快。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=&gt; explain (analyze,verbose,timing,buffers,costs) select count(userid) from session;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=541593.00..541593.01 rows=1 width=4) (actual time=6574.761..6574.761 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: count(userid)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=20229 read=121364</font></div><div><font size="2"   >&nbsp; &nbsp;I/O Timings: read=227.803</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.session &nbsp;(cost=0.00..461593.00 rows=32000000 width=4) (actual time=0.029..3295.744 rows=32000001 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: userid, last_login</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=20229 read=121364</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;I/O Timings: read=227.803</font></div><div><font size="2"   >&nbsp;Planning time: 0.044 ms</font></div><div><font size="2"   >&nbsp;Execution time: 6574.794 ms</font></div><div><font size="2"   >(10 rows)</font></div><div><font size="2"   >postgres=&gt; explain (analyze,verbose,timing,buffers,costs) select count(userid) from userinfo;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=541593.00..541593.01 rows=1 width=4) (actual time=6653.383..6653.383 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: count(userid)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=64 read=141529</font></div><div><font size="2"   >&nbsp; &nbsp;I/O Timings: read=265.700</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.userinfo &nbsp;(cost=0.00..461593.00 rows=32000000 width=4) (actual time=0.029..3358.069 rows=32000001 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: userid, info</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=64 read=141529</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;I/O Timings: read=265.700</font></div><div><font size="2"   >&nbsp;Planning time: 0.046 ms</font></div><div><font size="2"   >&nbsp;Execution time: 6653.417 ms</font></div><div><font size="2"   >(10 rows)</font></div><p></p></pre></div><div><br></div><div>分析这里的I/O Timings，单位毫秒，每次IO请求只需要0.0019毫秒。</div><div>这已经是内存级别的速度了。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=&gt; select 265.700/141529;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ?column? &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------</font></div><div><font size="2"   >&nbsp;0.00187735375788707615</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >postgres=&gt; select 227.803/121364;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ?column? &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------</font></div><div><font size="2"   >&nbsp;0.00187702284038100260</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>离散扫描测试：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=&gt; set enable_seqscan=off;</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >postgres=&gt; explain (analyze,verbose,timing,buffers,costs) select count(userid) from userinfo;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >--------------------------</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=1052572.56..1052572.57 rows=1 width=4) (actual time=10343.801..10343.801 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: count(userid)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared read=229028</font></div><div><font size="2"   >&nbsp; &nbsp;I/O Timings: read=674.634</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using pk_userinfo on public.userinfo &nbsp;(cost=0.56..972572.56 rows=32000000 width=4) (actual time=0.082..7277.8</font></div><div><font size="2"   >18 rows=32000001 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: userid</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heap Fetches: 32000001</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared read=229028</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;I/O Timings: read=674.634</font></div><div><font size="2"   >&nbsp;Planning time: 0.035 ms</font></div><div><font size="2"   >&nbsp;Execution time: 10343.851 ms</font></div><div><font size="2"   >(11 rows)</font></div><div><font size="2"   >postgres=&gt; explain (analyze,verbose,timing,buffers,costs) select count(userid) from session;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >------------------------</font></div><div><font size="2"   >&nbsp;Aggregate &nbsp;(cost=1052572.56..1052572.57 rows=1 width=4) (actual time=10321.901..10321.901 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: count(userid)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared read=229028</font></div><div><font size="2"   >&nbsp; &nbsp;I/O Timings: read=633.969</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Index Only Scan using pk_session on public.session &nbsp;(cost=0.56..972572.56 rows=32000000 width=4) (actual time=0.080..7268.908</font></div><div><font size="2"   >&nbsp;rows=32000001 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: userid</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heap Fetches: 32000001</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared read=229028</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;I/O Timings: read=633.969</font></div><div><font size="2"   >&nbsp;Planning time: 0.056 ms</font></div><div><font size="2"   >&nbsp;Execution time: 10321.935 ms</font></div><div><font size="2"   >(11 rows)</font></div><p></p></pre></div><div><div style="line-height: 28px;"   >分析这里的I/O Timings，单位毫秒，每次IO请求只需要0.0028毫秒。</div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=&gt; select 633.969/229028;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ?column? &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------</font></div><div><font size="2"   >&nbsp;0.00276808512496288663</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >postgres=&gt; select 674.634/229028;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ?column? &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------</font></div><div><font size="2"   >&nbsp;0.00294563983443072463</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>如果这些数据不是在内存中，那么有这样IOPS能力的块设备，那也是怪兽级别的了(8K的数据块，离散读IOPS达到36万，未考虑read ahead，考虑的话一般默认预读是256个扇区，真实IOPS能力会略低)。</div><div><span style="line-height: 28px;"   >我个人的判断还是倾向阿里的RDS未限制OS层CACHE，也就是随你用。</span></div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >创建测试函数：</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 28px;"   ><font size="2"   >CREATE OR REPLACE FUNCTION query_pk(IN i_userid int, OUT userid int, OUT info text)</font></span></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;RETURNS record</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;STRICT</font></div><div><font size="2"   >&nbsp; &nbsp; AS $function$</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; declare</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; begin</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; select t.userid,t.info into userid,info from userinfo t where t.userid=i_userid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; end;</font></div><div><font size="2"   >&nbsp; &nbsp; $function$;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CREATE OR REPLACE FUNCTION insert_log(IN i_userid int)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;RETURNS void</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;STRICT</font></div><div><font size="2"   >&nbsp; &nbsp; AS $function$</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; declare</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; begin</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; set synchronous_commit=off;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; insert into login_log (userid,db_user,client_addr,client_port,server_addr,server_port,login_time)</font></div><div><font size="2"   ><span>	</span> &nbsp; &nbsp;values (i_userid,current_user,inet_client_addr(),inet_client_port(),inet_server_addr(),inet_server_port(),now());</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; end;</font></div><div><font size="2"   >&nbsp; &nbsp; $function$;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CREATE OR REPLACE FUNCTION query_insert(IN i_userid int, OUT userid int, OUT info text)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;RETURNS record</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;STRICT</font></div><div><font size="2"   >&nbsp; &nbsp; AS $function$</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; declare</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; begin</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; set synchronous_commit=off;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; select t.userid,t.info into userid,info from userinfo t where t.userid=i_userid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; insert into login_log (userid,db_user,client_addr,client_port,server_addr,server_port,login_time)</font></div><div><font size="2"   ><span>	</span> &nbsp; &nbsp;values (i_userid,current_user,inet_client_addr(),inet_client_port(),inet_server_addr(),inet_server_port(),now());</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; end;</font></div><div><font size="2"   >&nbsp; &nbsp; $function$;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CREATE OR REPLACE FUNCTION update_pk(IN i_userid int)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;RETURNS void</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;STRICT</font></div><div><font size="2"   >&nbsp; &nbsp; AS $function$</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; declare</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; begin</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; set synchronous_commit=off;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; update session t set last_login=now() where t.userid=i_userid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; end;</font></div><div><font size="2"   >&nbsp; &nbsp; $function$;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CREATE OR REPLACE FUNCTION query_update_insert(IN i_userid int, OUT userid int, OUT info text)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;RETURNS record</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;STRICT</font></div><div><font size="2"   >&nbsp; &nbsp; AS $function$</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; declare</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; begin</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; set synchronous_commit=off;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; select t.userid,t.info into userid,info from userinfo t where t.userid=i_userid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; insert into login_log (userid,db_user,client_addr,client_port,server_addr,server_port,login_time)</font></div><div><font size="2"   ><span>	</span> &nbsp; &nbsp;values (i_userid,current_user,inet_client_addr(),inet_client_port(),inet_server_addr(),inet_server_port(),now());</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; update session t set last_login=now() where t.userid=i_userid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; end;</font></div><div><font size="2"   >&nbsp; &nbsp; $function$;</font></div><div><font size="2"   ><br></font></div><div><span style="line-height: 28px;"   ><font size="2"   >CREATE OR REPLACE FUNCTION query_smalltbl(IN i_userid int, OUT userid int, OUT info text)</font></span></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;RETURNS record</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;STRICT</font></div><div><font size="2"   >&nbsp; &nbsp; AS $function$</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; declare</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; begin</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; select t.userid,t.info into userid,info from tbl_small t where t.userid=i_userid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; end;</font></div><div><font size="2"   >&nbsp; &nbsp; $function$;</font></div><p></p></pre></div><div><br></div><div>测试结果：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >vi test.sql</font></div><div><font size="2"   >\setrandom id 1 32000000</font></div><div><font size="2"   >select query_pk(:id);</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./test.sql -P 1 -c 88 -j 88 -T 20 -h xxxx.pg.rds.aliyuncs.com -p 3433 -U digoal postgres</font></div><div><font size="2"   >progress: 1.1 s, 1938.5 tps, lat 30.861 ms stddev 63.730</font></div><div><font size="2"   >progress: 2.1 s, 3397.7 tps, lat 26.197 ms stddev 43.067</font></div><div><font size="2"   >progress: 3.0 s, 3293.2 tps, lat 25.744 ms stddev 36.761</font></div><div><font size="2"   >progress: 4.2 s, 3477.7 tps, lat 26.012 ms stddev 44.032</font></div><div><font size="2"   >progress: 5.1 s, 3448.3 tps, lat 25.291 ms stddev 39.993</font></div><div><font size="2"   >progress: 6.0 s, 3581.1 tps, lat 24.386 ms stddev 53.515</font></div><div><font size="2"   >progress: 7.0 s, 3669.4 tps, lat 23.736 ms stddev 43.620</font></div><div><font size="2"   >progress: 8.1 s, 3635.0 tps, lat 24.333 ms stddev 54.772</font></div><div><font size="2"   >progress: 9.0 s, 3625.6 tps, lat 24.457 ms stddev 39.071</font></div><div><font size="2"   >progress: 10.0 s, 3708.4 tps, lat 23.017 ms stddev 41.434</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >vi test.sql</font></div><div><font size="2"   >\setrandom id 1 32000000</font></div><div><font size="2"   >select insert_log(:id);</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./test.sql -P 1 -c 88 -j 88 -T 20 -h xxxx.pg.rds.aliyuncs.com -p 3433 -U digoal postgres</font></div><div><font size="2"   >progress: 1.1 s, 2194.8 tps, lat 26.288 ms stddev 51.427</font></div><div><font size="2"   >progress: 2.0 s, 3841.0 tps, lat 22.859 ms stddev 37.456</font></div><div><font size="2"   >progress: 3.0 s, 3745.8 tps, lat 23.536 ms stddev 46.164</font></div><div><font size="2"   >progress: 4.0 s, 3843.2 tps, lat 22.481 ms stddev 37.077</font></div><div><font size="2"   >progress: 5.0 s, 3676.9 tps, lat 24.256 ms stddev 45.177</font></div><div><font size="2"   >progress: 6.1 s, 3838.0 tps, lat 22.898 ms stddev 38.825</font></div><div><font size="2"   >progress: 7.0 s, 3890.9 tps, lat 22.836 ms stddev 38.612</font></div><div><font size="2"   >progress: 8.0 s, 3590.9 tps, lat 24.565 ms stddev 43.551</font></div><div><font size="2"   >progress: 9.0 s, 3675.0 tps, lat 24.210 ms stddev 38.266</font></div><div><font size="2"   >progress: 10.1 s, 3812.7 tps, lat 22.507 ms stddev 36.516</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >vi test.sql</font></div><div><font size="2"   >\setrandom id 1 32000000</font></div><div><font size="2"   >select query_insert(:id);</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./test.sql -P 1 -c 88 -j 88 -T 20 -h xxxx.pg.rds.aliyuncs.com -p 3433 -U digoal postgres</font></div><div><font size="2"   >progress: 1.1 s, 1269.2 tps, lat 45.745 ms stddev 89.929</font></div><div><font size="2"   >progress: 2.1 s, 2700.4 tps, lat 33.356 ms stddev 58.091</font></div><div><font size="2"   >progress: 3.0 s, 2654.6 tps, lat 35.314 ms stddev 54.011</font></div><div><font size="2"   >progress: 4.0 s, 2673.0 tps, lat 31.859 ms stddev 48.704</font></div><div><font size="2"   >progress: 5.0 s, 2762.7 tps, lat 31.759 ms stddev 51.929</font></div><div><font size="2"   >progress: 6.1 s, 2667.7 tps, lat 32.047 ms stddev 55.966</font></div><div><font size="2"   >progress: 7.1 s, 2688.7 tps, lat 32.407 ms stddev 58.218</font></div><div><font size="2"   >progress: 8.2 s, 2785.4 tps, lat 30.795 ms stddev 65.419</font></div><div><font size="2"   >progress: 9.0 s, 2789.9 tps, lat 35.547 ms stddev 58.010</font></div><div><font size="2"   >progress: 10.0 s, 2879.6 tps, lat 30.196 ms stddev 53.233</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >vi test.sql</font></div><div><font size="2"   >\setrandom id 1 32000000</font></div><div><font size="2"   >select update_pk(:id);</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./test.sql -P 1 -c 88 -j 88 -T 20 -h xxxx.pg.rds.aliyuncs.com -p 3433 -U digoal postgres</font></div><div><font size="2"   >progress: 2.5 s, 282.4 tps, lat 218.387 ms stddev 495.226</font></div><div><font size="2"   >progress: 5.8 s, 94.8 tps, lat 787.358 ms stddev 1325.987</font></div><div><font size="2"   >progress: 5.8 s, 15727.4 tps, lat 150.434 ms stddev 668.515</font></div><div><font size="2"   >progress: 5.9 s, 945.4 tps, lat 769.080 ms stddev 1374.084</font></div><div><font size="2"   >progress: 16.1 s, 93.2 tps, lat 833.108 ms stddev 1856.263</font></div><div><font size="2"   >progress: 16.2 s, 2598.5 tps, lat 665.837 ms stddev 1693.883</font></div><div><font size="2"   >progress: 17.2 s, 71.7 tps, lat 1571.432 ms stddev 1858.991</font></div><div><font size="2"   >progress: 22.2 s, 29.9 tps, lat 3003.451 ms stddev 2389.133</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >vi test.sql</font></div><div><font size="2"   >\setrandom id 1 32000000</font></div><div><font size="2"   >select query_update_insert(:id);</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./test.sql -P 1 -c 88 -j 88 -T 20 -h xxxx.pg.rds.aliyuncs.com -p 3433 -U digoal postgres</font></div><div><font size="2"   >progress: 5.7 s, 144.2 tps, lat 563.075 ms stddev 1426.395</font></div><div><font size="2"   >progress: 5.8 s, 1292.3 tps, lat 133.407 ms stddev 609.956</font></div><div><font size="2"   >progress: 5.8 s, 1028.1 tps, lat 29.967 ms stddev 37.131</font></div><div><font size="2"   >progress: 11.3 s, 25.5 tps, lat 2265.784 ms stddev 2573.469</font></div><div><font size="2"   >progress: 11.3 s, 6079.0 tps, lat 9.619 ms stddev 9.293</font></div><div><font size="2"   >progress: 11.3 s, 4787.2 tps, lat 624.805 ms stddev 1740.448</font></div><div><font size="2"   >progress: 16.9 s, 98.1 tps, lat 867.968 ms stddev 1989.390</font></div><div><font size="2"   >progress: 17.1 s, 1313.4 tps, lat 870.720 ms stddev 2098.172</font></div><div><font size="2"   >progress: 17.1 s, 13863.8 tps, lat 65.169 ms stddev 56.996</font></div><div><font size="2"   >progress: 17.1 s, 11670.3 tps, lat 20.520 ms stddev 35.188</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=&gt; \timing</font></div><div><font size="2"   >Timing is on.</font></div><div><font size="2"   >postgres=&gt; select count(*) from login_log;</font></div><div><font size="2"   >&nbsp; count &nbsp;</font></div><div><font size="2"   >--------</font></div><div><font size="2"   >&nbsp;140456</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 28.747 ms</font></div><div><font size="2"   >postgres=&gt; select count(*) from userinfo;</font></div><div><font size="2"   >&nbsp; count &nbsp;&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;32000001</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 3141.289 ms</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >vi test.sql</font></div><div><font size="2"   >\setrandom id 1 32000000</font></div><div><font size="2"   >select query_smalltbl(:id);</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./test.sql -P 1 -c 88 -j 88 -T 20 -h xxxx.pg.rds.aliyuncs.com -p 3433 -U digoal postgres</font></div><div><font size="2"   >progress: 1.0 s, 2420.4 tps, lat 23.557 ms stddev 45.623</font></div><div><font size="2"   >progress: 2.0 s, 4337.3 tps, lat 19.923 ms stddev 37.168</font></div><div><font size="2"   >progress: 3.0 s, 4555.2 tps, lat 20.154 ms stddev 35.738</font></div><div><font size="2"   >progress: 4.0 s, 4362.4 tps, lat 20.094 ms stddev 40.591</font></div><div><font size="2"   >progress: 5.1 s, 4203.5 tps, lat 20.386 ms stddev 36.220</font></div><div><font size="2"   >progress: 6.0 s, 4484.5 tps, lat 19.888 ms stddev 36.724</font></div><div><font size="2"   >progress: 7.0 s, 4551.6 tps, lat 19.634 ms stddev 39.959</font></div><div><font size="2"   >progress: 8.0 s, 4041.8 tps, lat 21.195 ms stddev 40.362</font></div><div><font size="2"   >progress: 9.1 s, 4557.6 tps, lat 19.758 ms stddev 37.218</font></div><div><font size="2"   >progress: 10.0 s, 4349.1 tps, lat 20.254 ms stddev 34.562</font></div><p></p></pre></div><div><br></div><div>测试结果与使用plproxy分布式处理的对比：</div><div>性能提升非常明显。</div><div><div><img title="阿里云RDS for PostgreSQL试用报告 - 3 - 德哥@Digoal - PostgreSQL research"   alt="阿里云RDS for PostgreSQL试用报告 - 3 - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img1.ph.126.net/RCbwMIJKyWWYlRz889MG2g==/6630572985467527246.png"   ></div></div><div><br></div><div>再报几个阿里云RDS for PostgreSQL的问题：</div><div>1. 当容量超出时（例如执行一个大的插入，我在生成测试数据时遇到），数据库会被KILL掉，数据库重启并恢复。</div><div>恢复时间有点长，约30分钟，(恢复过程中建议不要限制IOPS，尽快恢复才是王道)并且恢复后，还会有很长一段时间处于recovery状态，不清楚这个时间是否是切换到standby了，难道需要后台人工处理？未做自动化吗？</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=&gt; select pg_is_in_recovery();</font></div><div><font size="2"   >&nbsp;pg_is_in_recovery&nbsp;</font></div><div><font size="2"   >-------------------</font></div><div><font size="2"   >&nbsp;t</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>同时这点过于暴力，是不是可以给用户提个醒，和用户协商一下呢？给用户一个时间窗口，让用户自己处理。</div><div><br></div><div>2. 容量计算方法有点不合常理，容量包括了数据，XLOG，日志，。。。而实际上对用户来说应该只关注数据，至于xlog不应该让用户买单，因为xlog是用于保障可靠性和数据恢复的。归档后就可以复用，同时最低配置的RDS配置了</div><div>wal_keep_segments=80</div><div>checkpoint_segments=64</div><div>那么xlog最多会有64*2+<span style="line-height: 28px;"   >1=129个xlog文件，即129*16MB =&nbsp;</span>2064MB。</div><div>什么情况下会有这么多呢？当checkpoint周期拉很长时，例如配置了&nbsp;checkpoint_completion_target = 0.9，这个周期就非常长，接近整个检查点的周期。</div><div>用户可通过我之前写的文章了解这里的含义：</div><div><div style="line-height: 28px; color: rgb(51, 51, 51); font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53;"   ><a style="line-height: 28px; text-decoration: none; color: rgb(85, 108, 136);" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201542103933969/"   >http://blog.163.com/digoal@126/blog/static/163877040201542103933969/</a></div><div style="line-height: 28px; color: rgb(51, 51, 51); font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53;"   ><a style="line-height: 28px; text-decoration: none; color: rgb(85, 108, 136);" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015463252387/"   >http://blog.163.com/digoal@126/blog/static/1638770402015463252387/</a></div><div style="line-height: 28px; color: rgb(51, 51, 51); font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53;"   ><a style="line-height: 28px; text-decoration: none; color: rgb(85, 108, 136);" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020154651655783/"   >http://blog.163.com/digoal@126/blog/static/16387704020154651655783/</a></div><div style="line-height: 28px; color: rgb(51, 51, 51); font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53;"   ><a style="line-height: 28px; text-decoration: none; color: rgb(85, 108, 136);" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020154653422892/"   >http://blog.163.com/digoal@126/blog/static/16387704020154653422892/</a></div><div style="line-height: 28px; color: rgb(51, 51, 51); font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53;"   ><a style="line-height: 28px; text-decoration: none; color: rgb(85, 108, 136);" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020154811421484/"   >http://blog.163.com/digoal@126/blog/static/16387704020154811421484/</a></div><div style="line-height: 28px; color: rgb(51, 51, 51); font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53;"   ><a style="line-height: 28px; text-decoration: none; color: rgb(85, 108, 136);" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020154129958753/"   >http://blog.163.com/digoal@126/blog/static/16387704020154129958753/</a></div></div><div><br></div><div>实际上RDS的可用空间在最紧张时就变成了5GB-2064MB = 3056MB。</div><div>当然，空下来之后，xlog会回收掉一些，差不多一半，所以闲下来后还可以加1G左右的可用空间，即4GB左右，这是你能使用的最大空间了。</div><div>对于更高配置的RDS，<span style="line-height: 28px;"   >wal_keep_segments和</span><span style="line-height: 28px;"   >checkpoint_segments配置会更大，这种计算空间的方法，对用户来说浪费空间更多。</span></div><div><span style="line-height: 28px;"   >建议阿里云不计XLOG的空间，只计它的IOPS。</span></div><div><br></div><div>3. OS层缓存，这个已经说了，阿里云RDS目前可能没有限制OS层缓存，所以尽情享受吧。</div><div><br></div><div>4. IOPS限制间隔，在测试UPDATE时，性能非常不稳，可能是IOPS限制间隔或者手段造成的，当然也可能是FPW造成的，因为没有RDS所在服务器的权限，没有办法调试，所以基本靠猜。</div><div><br></div><div>5. 为什么<span style="line-height: 28px;"   >我们的plproxy没有看到所有测试的线性性能提升(目测某些只有5到8倍的性能提升，某些有超过16倍的性能提升)</span>，因为阿里云RDS并没有限制CPU的使用率，只限制了共享内存和IOPS，那么有些节点所在的机器可能CPU资源较空，有些较忙，我们的测试虽然是随机的分发到各个节点，但是因测试线程是共享的，所以单个实例如果比较慢，对总体测试结果有一定的影响。</div><div>而对于IO类的测试，性能提升是达到16倍的。</div><div>排除这些影响，使用plproxy应该是线性提升的，我在以前的分享中有数据可供查看，有兴趣的朋友可以看我以前的一些分享。</div><div><br></div><div>先写到这里，下一篇来讲讲如何增加或减少数据节点。</div><div><br></div><div>[参考]</div><div>1.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015599230431/"   >http://blog.163.com/digoal@126/blog/static/1638770402015599230431/</a></div><div>2.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020155104492068/"   >http://blog.163.com/digoal@126/blog/static/16387704020155104492068/</a></div><div><br></div><wbr><a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="阿里云RDS for PostgreSQL试用报告 - 3 - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>