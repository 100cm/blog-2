<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal) & exponential distribution</h2>
	<h5 id="">2015-06-18 12:36:19&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201551891133433/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 9.5 对pgbench的功能增强。</div><div><div style="line-height: 28px;"   ><ul style="line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em; font-size: 12.1599998474121px; font-family: verdana, sans-serif;"   ><li style="line-height: 1.5em; font-size: 1em; margin-top: 0.2em; margin-bottom: 0.1em;"   ><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em; font-size: 1em;"   >Allow counting of pgbench transactions that take over a specified amount of time (Fabien Coelho)</p><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em; font-size: 1em;"   >This is controlled by new&nbsp;<tt style="line-height: 21.2800006866455px;"   >--latency-limit</tt>&nbsp;option.</p></li><li style="line-height: 1.5em; font-size: 1em; margin-top: 0.2em; margin-bottom: 0.1em;"   ><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em; font-size: 1em;"   >Allow pgbench to generate Gaussian/exponential distributions using&nbsp;<tt style="line-height: 21.2800006866455px;"   >\setrandom</tt>&nbsp;(Kondo Mitsumasa, Fabien Coelho)</p></li><li style="line-height: 1.5em; font-size: 1em; margin-top: 0.2em; margin-bottom: 0.1em;"   ><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em; font-size: 1em;"   >Allow&nbsp;<span style="line-height: 21.2800006866455px;"   >pgbench</span>'s&nbsp;<tt style="line-height: 21.2800006866455px;"   >\set</tt>&nbsp;command to handle multi-operator expressions (Robert Haas, Fabien Coelho)</p></li></ul></div><wbr style="line-height: 28px;"   ></div><div>1. 允许在\set中使用更复杂的表达式（正负，加减乘除余，括号）。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >\set varname expression</font></div><div><font size="2"   >Sets variable varname to an integer value calculated from expression. The expression may contain integer constants such as 5432, references to variables :variablename, and expressions composed of unary (-) or binary operators (+, -, *, /, %) with their usual associativity, and parentheses.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Examples:</font></div><div><font size="2"   >\set ntellers 10 * :scale</font></div><div><font size="2"   >\set aid (1021 * :<span style="line-height: 28px;"   >ntellers</span>) % (100000 * :scale) + 1</font></div><p></p></pre></div><div><br></div><div>2. 允许设置--latency-limit，执行时间超过限制的SQL将分开统计和显示为late，与--rate同时使用时，超出限制并且未发送到数据库执行的SQL记为skipped。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >-L limit</font></div><div><font size="2"   >--latency-limit=limit</font></div><div><font size="2"   >Transaction which last more than limit milliseconds are counted and reported separately, as late.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >When throttling is used (--rate=...), transactions that lag behind schedule by more than limit ms, and thus have no hope of meeting the latency limit, are not sent to the server at all. They are counted and reported separately as skipped.</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >-R rate</font></div><div><font size="2"   >--rate=rate</font></div><div><font size="2"   >Execute transactions targeting the specified rate instead of running as fast as possible (the default). The rate is given in transactions per second. If the targeted rate is above the maximum possible rate, the rate limit won't impact the results.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The rate is targeted by starting transactions along a Poisson-distributed schedule time line. The expected start time schedule moves forward based on when the client first started, not when the previous transaction ended. That approach means that when transactions go past their original scheduled end time, it is possible for later ones to catch up again.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >When throttling is active, the transaction latency reported at the end of the run is calculated from the scheduled start times, so it includes the time each transaction had to wait for the previous transaction to finish. The wait time is called the schedule lag time, and its average and maximum are also reported separately. The transaction latency with respect to the actual transaction start time, i.e. the time spent executing the transaction in the database, can be computed by subtracting the schedule lag time from the reported latency.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >If --latency-limit is used together with --rate, a transaction can lag behind so much that it is already over the latency limit when the previous transaction ends, because the latency is calculated from the scheduled start time. Such transactions are not sent to the server, but are skipped altogether and counted separately.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >A high schedule lag time is an indication that the system cannot process transactions at the specified rate, with the chosen number of clients and threads. When the average transaction execution time is longer than the scheduled interval between each transaction, each successive transaction will fall further behind, and the schedule lag time will keep increasing the longer the test run is. When that happens, you will have to reduce the specified transaction rate.</font></div></div><p></p></pre></div><div><br></div><div>3. 可以生成正态分布或指数分布的测试数据。(原来只能生成概率一致的随机分布值)</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >\setrandom varname min max [ uniform | { gaussian | exponential } threshold ]</font></div><div><font size="2"   >Sets variable varname to a random integer value between the limits min and max inclusive. Each limit can be either an integer constant or a :variablename reference to a variable having an integer value.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >高斯分布（正态分布）的概率峰值出现在min,max的数学期望值即<span style="line-height: 28px;"   >(max + min) / 2.0</span><span style="line-height: 28px;"   >。</span></font></div><div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >约67%的值分布在以min,max数学期望为中心的&nbsp;<span style="line-height: 28px;"   >1.0 / threshold 这个区间。</span></font></div><div style="line-height: 28px;"   ><font size="2"   ><span style="line-height: 28px;"   >约95%的值分布在</span><span style="line-height: 28px;"   >以min,max数学期望为中心的&nbsp;</span><span style="line-height: 28px;"   >2.0 / threshold 这个区间。</span></font></div></div></div><div style="line-height: 28px;"   ><font size="2"   >所以threshold越大，数据数据越集中在<span style="line-height: 28px;"   >min,max的数学期望附近。</span></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >By default, or when uniform is specified, all values in the range are drawn with equal probability. Specifying gaussian or exponential options modifies this behavior; each requires a mandatory threshold which determines the precise shape of the distribution.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >For a Gaussian distribution, the interval is mapped onto a standard normal distribution (the classical bell-shaped Gaussian curve) truncated at -threshold on the left and +threshold on the right.&nbsp;</font></div><div><font size="2"   >To be precise, if PHI(x) is the cumulative distribution function of the standard normal distribution,&nbsp;</font></div><div><font size="2"   >with mean mu defined as (max + min) / 2.0,&nbsp;</font></div><div><font size="2"   >then value i between min and max inclusive is drawn with probability:&nbsp;</font></div><div><font size="2"   >在min,max区间取i值的概率如下，(其中PHI(x)是正态分布的积分函数)：</font></div><div><font size="2"   >(PHI(2.0 * threshold * (i - min - mu + 0.5) / (max - min + 1)) - PHI(2.0 * threshold * (i - min - mu - 0.5) / (max - min + 1))) / (2.0 * PHI(threshold) - 1.0).&nbsp;</font></div><div><font size="2"   >Intuitively, the larger the threshold, the more frequently values close to the middle of the interval are drawn, and the less frequently values close to the min and max bounds.&nbsp;</font></div><div><font size="2"   >About 67% of values are drawn from the middle 1.0 / threshold and 95% in the middle 2.0 / threshold;&nbsp;</font></div><div><font size="2"   >约67%的值分布在以min,max数学期望为中心的&nbsp;<span style="line-height: 28px;"   >1.0 / threshold 这个区间。</span></font></div><div><font size="2"   ><span style="line-height: 28px;"   >约95%的值分布在</span><span style="line-height: 28px;"   >以min,max数学期望为中心的&nbsp;</span><span style="line-height: 28px;"   >2.0 / threshold 这个区间。</span></font></div><div><font size="2"   >for instance, if threshold is 4.0, 67% of values are drawn from the middle quarter and 95% from the middle half of the interval.&nbsp;</font></div><div><font size="2"   >The minimum threshold is 2.0 for performance of the Box-Muller transform. (性能考虑，2.0为最小threshold值)。</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >指数分布：</font></div><div><font size="2"   >For an exponential distribution, the threshold parameter controls the distribution by truncating a quickly-decreasing exponential distribution at threshold, and then projecting onto integers between the bounds.&nbsp;</font></div><div><font size="2"   >To be precise, value i between min and max inclusive is drawn with probability:&nbsp;</font></div><div><font size="2"   >在<span style="line-height: 21px;"   >min,max区间取i值的概率如下：</span></font></div><div><font size="2"   >(exp(-threshold*(i-min)/(max+1-min)) - exp(-threshold*(i+1-min)/(max+1-min))) / (1.0 - exp(-threshold)).&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Intuitively, the larger the threshold, the more frequently values close to min are accessed, and the less frequently values close to max are accessed. (threshold越大，随机值接近min的概率越大，反之，threshold越小，随机值接近max的概率越大)</font></div><div><font size="2"   >The closer to 0 the threshold, the flatter (more uniform) the access distribution.&nbsp;</font></div><div><font size="2"   ><span style="line-height: 21px;"   >注意上面这句话，threshold 越接近0，则越趋于随机分布，而不是指数分布。看后面的图。</span></font></div><div><font size="2"   >A crude approximation of the distribution is that the most frequent 1% values in the range, close to min, are drawn threshold% of the time.&nbsp;</font></div><div><font size="2"   >The threshold value must be strictly positive.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Example:</font></div><div><font size="2"   >\setrandom aid 1 :naccounts gaussian 5.0</font></div><p></p></pre></div><div><br></div><div>例子：</div><div>生成高斯分布的一组数据。</div><div><div style="line-height: 28px;"   >约67%的值分布在以min,max数学期望为中心的&nbsp;<span style="line-height: 28px;"   >1.0 / 100 这个区间。</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >约95%的值分布在</span><span style="line-height: 28px;"   >以min,max数学期望为中心的&nbsp;</span><span style="line-height: 28px;"   >2.0 / 100 这个区间。</span></div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create table test(id int);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# \q</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >pg95@db-172-16-3-150-&gt; vi test.sql</font></div><div><font size="2"   >\setrandom id 1 50000 gaussian 100.0</font></div><div><font size="2"   >insert into test values (:id);</font></div><p></p></pre></div><div><div style="line-height: 28px;"   ><br></div></div><div><span style="line-height: 28px;"   >--latency-limit=0.2 表示响应时间超过0.2毫秒的请求另外显示。</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg95@db-172-16-3-150-&gt; pgbench -M prepared -n -r -f ./test.sql -P 2 -c 16 -j 16 -T 10 --latency-limit=0.2</font></div><div><font size="2"   >progress: 2.0 s, 93423.3 tps, lat 0.164 ms stddev 0.122</font></div><div><font size="2"   >progress: 4.0 s, 95957.7 tps, lat 0.164 ms stddev 0.109</font></div><div><font size="2"   >progress: 6.0 s, 95074.0 tps, lat 0.166 ms stddev 0.116</font></div><div><font size="2"   >progress: 8.0 s, 95760.4 tps, lat 0.165 ms stddev 0.111</font></div><div><font size="2"   >progress: 10.0 s, 95711.8 tps, lat 0.165 ms stddev 0.108</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 16</font></div><div><font size="2"   >number of threads: 16</font></div><div><font size="2"   >duration: 10 s</font></div><div><font size="2"   >number of transactions actually processed: 951872</font></div><p></p></pre></div><div>这里显示了请求响应时间超过0.2毫秒的占比。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >number of transactions above the 0.2 ms latency limit: 175929 (18.482 %)</font></div><div><font size="2"   >latency average: 0.165 ms</font></div><div><font size="2"   >latency stddev: 0.113 ms</font></div><div><font size="2"   >tps = 95165.492751 (including connections establishing)</font></div><div><font size="2"   >tps = 95694.059134 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; -0.002321 &nbsp; &nbsp; &nbsp; \setrandom id 1 50000 gaussian 100.0</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.160266 &nbsp; &nbsp; &nbsp; &nbsp;insert into test values (:id);</font></div><p></p></pre></div></div><div><br></div><div>使用R来绘制一下正态分布：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&gt; install.packages("RPostgreSQL")</font></div><div><div><font size="2"   >&gt; library(RPostgreSQL)</font></div></div><p></p></pre></div><div><div>载入需要的程辑包：DBI</div><div>警告信息：</div><div>1: 程辑包‘RPostgreSQL’是用R版本3.1.3 来建造的&nbsp;</div><div>2: 程辑包‘DBI’是用R版本3.1.3 来建造的&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >&gt; drv &lt;- dbDriver("PostgreSQL")</font></div></div><div><div><font size="2"   >&gt; con &lt;- dbConnect(drv, host='172.16.3.150', port='1922', dbname='postgres', user='postgres')</font></div></div><div><div><font size="2"   >&gt; rs &lt;- dbGetQuery(con, 'with t (cnt) as (select count(*) as cnt from test) select id,count(*)/(t.cnt::numeric) from test, t group by id,t.cnt')</font></div><div><font size="2"   >&gt; plot(rs)</font></div></div><p></p></pre></div></div><div><div><img title="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/goslz7GPbev05lM3qHM58A==/6630744509281552490.png"   ></div><div><div style="line-height: 28px;"   >约67%的值分布在以min,max数学期望为中心的&nbsp;<span style="line-height: 28px;"   >1.0 / 100 这个区间</span><span style="line-height: 28px;"   >(24750 至 25250)</span><span style="line-height: 28px;"   >。</span></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >约95%的值分布在</span><span style="line-height: 28px;"   >以min,max数学期望为中心的&nbsp;</span><span style="line-height: 28px;"   >2.0 / 100 这个区间(24500 至 25500)。</span></div></div><div><br></div><div>修改一下threshold, 改为5，将有95%的数据分布在2/5的区间内<span style="line-height: 28px;"   >(15000 至 35000)</span><span style="line-height: 28px;"   >。</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# truncate test;</font></div><div><font size="2"   >TRUNCATE TABLE</font></div></div><div><div><font size="2"   >pg95@db-172-16-3-150-&gt; vi test.sql</font></div><div><font size="2"   >\setrandom id 1 50000 gaussian 5.0</font></div><div><font size="2"   >insert into test values (:id);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >pg95@db-172-16-3-150-&gt; pgbench -M prepared -n -r -f ./test.sql -P 2 -c 16 -j 16 -T 10 --latency-limit=0.2</font></div><div><font size="2"   >progress: 2.0 s, 93514.9 tps, lat 0.163 ms stddev 0.119</font></div><div><font size="2"   >progress: 4.0 s, 94764.7 tps, lat 0.167 ms stddev 0.117</font></div><div><font size="2"   >progress: 6.0 s, 95041.7 tps, lat 0.166 ms stddev 0.112</font></div><div><font size="2"   >progress: 8.0 s, 95312.3 tps, lat 0.166 ms stddev 0.112</font></div><div><font size="2"   >progress: 10.0 s, 95035.6 tps, lat 0.166 ms stddev 0.112</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 16</font></div><div><font size="2"   >number of threads: 16</font></div><div><font size="2"   >duration: 10 s</font></div><div><font size="2"   >number of transactions actually processed: 947354</font></div><div><font size="2"   >number of transactions above the 0.2 ms latency limit: 176537 (18.635 %)</font></div><div><font size="2"   >latency average: 0.166 ms</font></div><div><font size="2"   >latency stddev: 0.114 ms</font></div><div><font size="2"   >tps = 94726.249444 (including connections establishing)</font></div><div><font size="2"   >tps = 95332.979889 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; -0.002318 &nbsp; &nbsp; &nbsp; \setrandom id 1 50000 gaussian 5.0</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.160983 &nbsp; &nbsp; &nbsp; &nbsp;insert into test values (:id);</font></div></div><p></p></pre></div></div><div>重新绘制曲线：</div><div><div><img title="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/jtTi0JhiEArBkZhlvXZ6fg==/1054123787799556358.png"   ></div><br></div><div>指数分布例子：</div><div>threshold越大，越多的值分布在min附近。</div><div>threshold越小，当趋近于0时，接近随机分布，而不是曲线反转。</div><div>threshold不能小于0。</div><div><pre class="prettyprint"   ><div><div><font size="2"   >postgres=# truncate test;</font></div><div><font size="2"   >TRUNCATE TABLE</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >pg95@db-172-16-3-150-&gt; vi test.sql</font></div><div><font size="2"   >\setrandom id 1 50000 exponential 50000</font></div><div><font size="2"   >insert into test values (:id);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >pg95@db-172-16-3-150-&gt; pgbench -M prepared -n -r -f ./test.sql -P 2 -c 16 -j 16 -T 10</font></div><div><font size="2"   >progress: 2.0 s, 94095.8 tps, lat 0.162 ms stddev 0.112</font></div><div><font size="2"   >progress: 4.0 s, 95611.9 tps, lat 0.165 ms stddev 0.108</font></div><div><font size="2"   >progress: 6.0 s, 94929.7 tps, lat 0.166 ms stddev 0.121</font></div><div><font size="2"   >progress: 8.0 s, 96159.4 tps, lat 0.164 ms stddev 0.102</font></div><div><font size="2"   >progress: 10.0 s, 95586.2 tps, lat 0.165 ms stddev 0.109</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 16</font></div><div><font size="2"   >number of threads: 16</font></div><div><font size="2"   >duration: 10 s</font></div><div><font size="2"   >number of transactions actually processed: 952791</font></div><div><font size="2"   >latency average: 0.164 ms</font></div><div><font size="2"   >latency stddev: 0.111 ms</font></div><div><font size="2"   >tps = 95271.583072 (including connections establishing)</font></div><div><font size="2"   >tps = 95879.681335 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; -0.002375 &nbsp; &nbsp; &nbsp; \setrandom id 1 50000 exponential 1.0</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.160051 &nbsp; &nbsp; &nbsp; &nbsp;insert into test values (:id);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# analyze test;</font></div><div><font size="2"   >ANALYZE</font></div><div><font size="2"   >从most_common_vals和most_common_freqs可以观察到，threshold越大，越多的值分布在min附近 。</font></div><div><font size="2"   >postgres=# select * from pg_stats where attname='id' and tablename='test';</font></div><div><font size="2"   >-[ RECORD 1 ]----------+-----------------------------------------------</font></div><div><font size="2"   >schemaname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | public</font></div><div><font size="2"   >tablename &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| test</font></div><div><font size="2"   >attname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| id</font></div><div><font size="2"   >inherited &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| f</font></div><div><font size="2"   >null_frac &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 0</font></div><div><font size="2"   >avg_width &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 4</font></div><div><font size="2"   >n_distinct &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 11</font></div><div><font size="2"   >most_common_vals &nbsp; &nbsp; &nbsp; | {1,2,3,4,5}</font></div><div><font size="2"   >most_common_freqs &nbsp; &nbsp; &nbsp;| {0.632533,0.231967,0.0867,0.0306333,0.0112333}</font></div><div><font size="2"   >histogram_bounds &nbsp; &nbsp; &nbsp; | {6,6,6,6,7,12}</font></div><div><font size="2"   >correlation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 0.458732</font></div><div><font size="2"   >most_common_elems &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >most_common_elem_freqs |&nbsp;</font></div><div><font size="2"   >elem_count_histogram &nbsp; |&nbsp;</font></div></div><p></p></pre></div><div>如图：</div><div><div><img title="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img0.ph.126.net/hPweiTQt7AUJ1dRoVJVJEg==/6630254127095147499.png"   ></div><div><span style="line-height: 28px;"   >再提供几张图，threshold分别是1,10,100,1000,10000：</span></div></div><div>注意纵坐标的概率值。</div><div><div><img title="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   src="http://img2.ph.126.net/l22FROAtY1mXZJV-P6rXtA==/6630344287048636994.png"   style="line-height: 28px; margin: 0px 10px 0px 0px;"   ></div><div><br></div><div><img title="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   src="http://img0.ph.126.net/6gEnHM6Np3yf8ssHOTU7YQ==/6630792887793185280.png"   style="line-height: 28px; margin: 0px 10px 0px 0px;"   ></div><br><div><img title="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/yeFlwylMbYFloxZy5QPmLg==/2806024042846525487.png"   ></div><br><div><img title="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/JWcDRgiUUy8kzMMQmURBOQ==/2768306395967323742.png"   ></div><br><div><img title="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img1.ph.126.net/kEBxJEbcqqTY5DQ2irEVLg==/6630181559327722936.png"   ></div><div><div style="line-height: 28px;"   >threshold=0.000001：已经接近随机分布了。</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><img title="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   alt="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   src="http://img0.ph.126.net/i8JLG4ocvSnB69n0fSw8cw==/6630292610002120314.png"   style="line-height: 28px; margin: 0px 10px 0px 0px;"   ></div></div></div>可以看出，当threshold越来越小时，开始接近随机分布。</div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/pgbench.html"   >http://www.postgresql.org/docs/devel/static/pgbench.html</a></div><div>2.&nbsp;src/bin/pgbench/pgbench.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >产生一个随机值</font></div><div><div><font size="2"   >/* random number generator: uniform distribution from min to max inclusive */</font></div><div><font size="2"   >static int64</font></div><div><font size="2"   >getrand(TState *thread, int64 min, int64 max)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Odd coding is so that min and max have approximately the same chance of</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* being selected as do numbers between them.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* pg_erand48() is thread-safe and concurrent, which is why we use it</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* rather than random(), which in glibc is non-reentrant, and therefore</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* protected by a mutex, and therefore a bottleneck on machines with many</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* CPUs.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return min + (int64) ((max - min + 1) * pg_erand48(thread-&gt;random_state));</font></div><div><font size="2"   >}</font></div><div><font size="2"   >产生一个指数分布的随机值</font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* random number generator: exponential distribution from min to max inclusive.</font></div><div><font size="2"   >&nbsp;* the threshold is so that the density of probability for the last cut-off max</font></div><div><font size="2"   >&nbsp;* value is exp(-threshold).</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static int64</font></div><div><font size="2"   >getExponentialRand(TState *thread, int64 min, int64 max, double threshold)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cut,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uniform,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rand;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert(threshold &gt; 0.0);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; cut = exp(-threshold);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* erand in [0, 1), uniform in (0, 1] */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uniform = 1.0 - pg_erand48(thread-&gt;random_state);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* inner expresion in (cut, 1] (if threshold &gt; 0), rand in [0, 1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Assert((1.0 - cut) != 0.0);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rand = -log(cut + (1.0 - cut) * uniform) / threshold;</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* return int64 random number within between min and max */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return min + (int64) ((max - min + 1) * rand);</font></div><div><font size="2"   >}</font></div><div><font size="2"   >产生一个高斯分布（正态分布）的随机值</font></div><div><font size="2"   >/* random number generator: gaussian distribution from min to max inclusive */</font></div><div><font size="2"   >static int64</font></div><div><font size="2"   >getGaussianRand(TState *thread, int64 min, int64 max, double threshold)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stdev;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rand;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Get user specified random number from this loop, with -threshold &lt;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* stdev &lt;= threshold</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* This loop is executed until the number is in the expected range.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* As the minimum threshold is 2.0, the probability of looping is low:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* sqrt(-2 ln(r)) &lt;= 2 =&gt; r &gt;= e^{-2} ~ 0.135, then when taking the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* average sinus multiplier as 2/pi, we have a 8.6% looping probability in</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the worst case. For a 5.0 threshold value, the looping probability is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* about e^{-5} * 2 / pi ~ 0.43%.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; do</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* pg_erand48 generates [0,1), but for the basic version of the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Box-Muller transform the two uniformly distributed random numbers</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* are expected in (0, 1] (see</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* http://en.wikipedia.org/wiki/Box_muller)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rand1 = 1.0 - pg_erand48(thread-&gt;random_state);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rand2 = 1.0 - pg_erand48(thread-&gt;random_state);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Box-Muller basic form transform */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var_sqrt = sqrt(-2.0 * log(rand1));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stdev = var_sqrt * sin(2.0 * M_PI * rand2);</font></div></div></div><div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we may try with cos, but there may be a bias induced if the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* previous value fails the test. To be on the safe side, let us try</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* over.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; while (stdev &lt; -threshold || stdev &gt;= threshold);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* stdev is in [-threshold, threshold), normalization to [0,1) */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rand = (stdev + threshold) / (threshold * 2.0);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* return int64 random number within between min and max */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return min + (int64) ((max - min + 1) * rand);</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   >产生泊松分布随机值</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* random number generator: generate a value, such that the series of values</font></div><div><font size="2"   >&nbsp;* will approximate a Poisson distribution centered on the given value.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static int64</font></div><div><font size="2"   >getPoissonRand(TState *thread, int64 center)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Use inverse transform sampling to generate a value &gt; 0, such that the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* expected (i.e. average) value is the given argument.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uniform;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* erand in [0, 1), uniform in (0, 1] */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uniform = 1.0 - pg_erand48(thread-&gt;random_state);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return (int64) (-log(uniform) * ((double) center) + 0.5);</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><br></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL 9.5 new feature - pg_bench improve, gaussian (standard normal)  exponential distribution - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>