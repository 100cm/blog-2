<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">online DDL (or NOWAIT DDL) in PostgreSQL</h2>
	<h5 id="">2015-06-19 8:27:14&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201551831531324/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>为什么需要online DDL呢？或者nowait DDL呢？</div><div>PostgreSQL为了保证一个请求不至于无休止的等待锁，锁等待使用了队列机制，并且这个在等待队列中的锁也会和以后的会话将要请求的锁发生冲突。</div><div>虽然解决了无休止的等待问题，同时也带来一个比较棘手的问题。</div><div>例如，</div><div>当数据库中存在一个长事务时，如果你要对这个长事务持锁（假设是一个很小的锁）的对象执行DDL（获取AccessExclusive LOCK)，会进入等待，而后面发起的对这个对象的任何SQL都会等待，即会堵塞未来的SQL请求。</div><div>这种事情在高并发小事务应用的场景非常容易造成堵塞故障。</div><div><br></div><div>例子：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create table t1(id int);</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div><br></div><div>会话A：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >postgres=# insert into t1 values (1);</font></div><div><font size="2"   >INSERT 0 1</font></div><p></p></pre></div><div><br></div><div>会话B：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# alter table t1 add column info text;</font></div><div><font size="2"   >waiting......</font></div><p></p></pre></div><div><br></div><div>会话C，查看锁等待的情况：</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create or replace function f_lock_level(i_mode text) returns int as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; case i_mode</font></div><div><font size="2"   >&nbsp; &nbsp; when 'INVALID' then return 0;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'AccessShareLock' then return 1;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'RowShareLock' then return 2;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'RowExclusiveLock' then return 3;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ShareUpdateExclusiveLock' then return 4;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ShareLock' then return 5;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ShareRowExclusiveLock' then return 6;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'ExclusiveLock' then return 7;</font></div><div><font size="2"   >&nbsp; &nbsp; when 'AccessExclusiveLock' then return 8;</font></div><div><font size="2"   >&nbsp; &nbsp; else return 0;</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >end;&nbsp;</font></div><div><font size="2"   >$$ language plpgsql strict;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# with t_wait as &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >(select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.objid,a.objsubid,</font></div><div><font size="2"   >a.pid,a.virtualtransaction,a.virtualxid,a,transactionid,b.query,b.xact_start,b.query_start,</font></div><div><font size="2"   >b.usename,b.datname from pg_locks a,pg_stat_activity b where a.pid=b.pid and not a.granted),</font></div><div><font size="2"   >t_run as&nbsp;</font></div><div><font size="2"   >(select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.objid,a.objsubid,</font></div><div><font size="2"   >a.pid,a.virtualtransaction,a.virtualxid,a,transactionid,b.query,b.xact_start,b.query_start,</font></div><div><font size="2"   >b.usename,b.datname from pg_locks a,pg_stat_activity b where a.pid=b.pid and a.granted)&nbsp;</font></div><div><font size="2"   >select r.locktype,r.mode r_mode,r.usename r_user,r.datname r_db,r.relation::regclass,r.pid r_pid,</font></div><div><font size="2"   >r.page r_page,r.tuple r_tuple,r.xact_start r_xact_start,r.query_start r_query_start,</font></div><div><font size="2"   >now()-r.query_start r_locktime,r.query r_query,w.mode w_mode,w.pid w_pid,w.page w_page,</font></div><div><font size="2"   >w.tuple w_tuple,w.xact_start w_xact_start,w.query_start w_query_start,</font></div><div><font size="2"   >now()-w.query_start w_locktime,w.query w_query &nbsp;</font></div><div><font size="2"   >from t_wait w,t_run r where</font></div><div><font size="2"   >&nbsp; r.locktype is not distinct from w.locktype and</font></div><div><font size="2"   >&nbsp; r.database is not distinct from w.database and</font></div><div><font size="2"   >&nbsp; r.relation is not distinct from w.relation and</font></div><div><font size="2"   >&nbsp; r.page is not distinct from w.page and</font></div><div><font size="2"   >&nbsp; r.tuple is not distinct from w.tuple and</font></div><div><font size="2"   >&nbsp; r.classid is not distinct from w.classid and</font></div><div><font size="2"   >&nbsp; r.objid is not distinct from w.objid and</font></div><div><font size="2"   >&nbsp; r.objsubid is not distinct from w.objsubid and</font></div><div><font size="2"   >&nbsp; r.transactionid is not distinct from w.transactionid and</font></div><div><font size="2"   >&nbsp; r.pid &lt;&gt; w.pid</font></div><div><font size="2"   >&nbsp; order by f_lock_level(w.mode)+f_lock_level(r.mode) desc,r.xact_start;</font></div><p></p></pre></div><div>锁等待如下，会话B请求的锁与会话A持有的锁发生冲突，等待。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >-[ RECORD 1 ]-+-------------------------------------</font></div><div><font size="2"   >locktype &nbsp; &nbsp; &nbsp;| relation</font></div><div><font size="2"   >r_mode &nbsp; &nbsp; &nbsp; &nbsp;| RowExclusiveLock</font></div><div><font size="2"   >r_user &nbsp; &nbsp; &nbsp; &nbsp;| postgres</font></div><div><font size="2"   >r_db &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| postgres</font></div><div><font size="2"   >relation &nbsp; &nbsp; &nbsp;| t1</font></div><div><font size="2"   >r_pid &nbsp; &nbsp; &nbsp; &nbsp; | 16927</font></div><div><font size="2"   >r_page &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >r_tuple &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >r_xact_start &nbsp;| 2015-06-18 15:30:07.578806+08</font></div><div><font size="2"   >r_query_start | 2015-06-18 15:30:12.988851+08</font></div><div><font size="2"   >r_locktime &nbsp; &nbsp;| 00:07:22.879003</font></div><div><font size="2"   >r_query &nbsp; &nbsp; &nbsp; | insert into t1 values (1);</font></div><div><font size="2"   >w_mode &nbsp; &nbsp; &nbsp; &nbsp;| AccessExclusiveLock</font></div><div><font size="2"   >w_pid &nbsp; &nbsp; &nbsp; &nbsp; | 16881</font></div><div><font size="2"   >w_page &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >w_tuple &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >w_xact_start &nbsp;| 2015-06-18 15:30:26.749872+08</font></div><div><font size="2"   >w_query_start | 2015-06-18 15:30:26.749872+08</font></div><div><font size="2"   >w_locktime &nbsp; &nbsp;| 00:07:09.117982</font></div><div><font size="2"   >w_query &nbsp; &nbsp; &nbsp; | alter table t1 add column info text;</font></div><p></p></pre></div><div><br></div><div>会话D：</div><div>此时，虽然会话B没有获得AccessExclusive锁，但是，PostgreSQL将它放入队列了，并且未来的SQL请求也要判断请求的锁是否会与之发生冲突。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# insert into t1 values (1);</font></div><div><font size="2"   >waiting ......</font></div><p></p></pre></div><div><br></div><div>查看锁信息，此时会话D也在等待中，只是这里通过视图看到的等待并不是等待会话B的锁。</div><div>我们可以使用trace lock来跟踪。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >-[ RECORD 1 ]-+-------------------------------------</font></div><div><font size="2"   >locktype &nbsp; &nbsp; &nbsp;| relation</font></div><div><font size="2"   >r_mode &nbsp; &nbsp; &nbsp; &nbsp;| RowExclusiveLock</font></div><div><font size="2"   >r_user &nbsp; &nbsp; &nbsp; &nbsp;| postgres</font></div><div><font size="2"   >r_db &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| postgres</font></div><div><font size="2"   >relation &nbsp; &nbsp; &nbsp;| t1</font></div><div><font size="2"   >r_pid &nbsp; &nbsp; &nbsp; &nbsp; | 16927</font></div><div><font size="2"   >r_page &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >r_tuple &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >r_xact_start &nbsp;| 2015-06-18 15:30:07.578806+08</font></div><div><font size="2"   >r_query_start | 2015-06-18 15:30:12.988851+08</font></div><div><font size="2"   >r_locktime &nbsp; &nbsp;| 00:08:47.723949</font></div><div><font size="2"   >r_query &nbsp; &nbsp; &nbsp; | insert into t1 values (1);</font></div><div><font size="2"   >w_mode &nbsp; &nbsp; &nbsp; &nbsp;| AccessExclusiveLock</font></div><div><font size="2"   >w_pid &nbsp; &nbsp; &nbsp; &nbsp; | 16881</font></div><div><font size="2"   >w_page &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >w_tuple &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >w_xact_start &nbsp;| 2015-06-18 15:30:26.749872+08</font></div><div><font size="2"   >w_query_start | 2015-06-18 15:30:26.749872+08</font></div><div><font size="2"   >w_locktime &nbsp; &nbsp;| 00:08:33.962928</font></div><div><font size="2"   >w_query &nbsp; &nbsp; &nbsp; | alter table t1 add column info text;</font></div><div><font size="2"   >-[ RECORD 2 ]-+-------------------------------------</font></div><div><font size="2"   >locktype &nbsp; &nbsp; &nbsp;| relation</font></div><div><font size="2"   >r_mode &nbsp; &nbsp; &nbsp; &nbsp;| RowExclusiveLock</font></div><div><font size="2"   >r_user &nbsp; &nbsp; &nbsp; &nbsp;| postgres</font></div><div><font size="2"   >r_db &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| postgres</font></div><div><font size="2"   >relation &nbsp; &nbsp; &nbsp;| t1</font></div><div><font size="2"   >r_pid &nbsp; &nbsp; &nbsp; &nbsp; | 16927</font></div><div><font size="2"   >r_page &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >r_tuple &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >r_xact_start &nbsp;| 2015-06-18 15:30:07.578806+08</font></div><div><font size="2"   >r_query_start | 2015-06-18 15:30:12.988851+08</font></div><div><font size="2"   >r_locktime &nbsp; &nbsp;| 00:08:47.723949</font></div><div><font size="2"   >r_query &nbsp; &nbsp; &nbsp; | insert into t1 values (1);</font></div><div><font size="2"   >w_mode &nbsp; &nbsp; &nbsp; &nbsp;| RowExclusiveLock</font></div><div><font size="2"   >w_pid &nbsp; &nbsp; &nbsp; &nbsp; | 17205</font></div><div><font size="2"   >w_page &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >w_tuple &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >w_xact_start &nbsp;| 2015-06-18 15:38:41.204786+08</font></div><div><font size="2"   >w_query_start | 2015-06-18 15:38:41.204786+08</font></div><div><font size="2"   >w_locktime &nbsp; &nbsp;| 00:00:19.508014</font></div><div><font size="2"   >w_query &nbsp; &nbsp; &nbsp; | insert into t1 values (1);</font></div><p></p></pre></div></div><div><br></div><div><span style="line-height: 28px;"   >接下来我们打开锁DEBUG，需要修改一下头文件，打开LOCK_DEBUG宏定义，重新编译安装：</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># vi src/include/pg_config_manual.h</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Enable debugging print statements for lock-related operations.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define LOCK_DEBUG</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   ># gmake distclean</font></div><div><font size="2"   ># ./configure --prefix=/opt/pgsql9.5 --with-pgport=1922 --with-perl --with-python --with-tcl --with-openssl --with-pam --with-ldap --with-libxml --with-libxslt --enable-thread-safety --with-blocksize=32 --enable-debug</font></div><div><font size="2"   ># gmake &amp;&amp; gmake install</font></div><p></p></pre></div><div><br></div><div>在postgresql.conf参数中开启锁跟踪</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >$ vi postgresql.conf</font></div><div><div><font size="2"   >trace_locks = on</font></div><div><font size="2"   >trace_userlocks = on</font></div><div><font size="2"   >debug_deadlocks = on</font></div></div><p></p></pre></div><div><br></div><div>重启数据库</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >$ pg_ctl restart -m fast</font></div><div></div><p></p></pre></div><div>修改客户端的日志跟踪级别，同时开启代码定位：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# set client_min_messages=log;</font></div><div><font size="2"   >postgres=# \set VERBOSITY verbose</font></div><p></p></pre></div><div><br></div><div>会话A，测试一下锁获取和释放：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >postgres=# alter table t1 add column c1 int;</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [13181,16903] AccessExclusiveLock</font></div><div><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:724</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: new: lock(0x7f79f1a620c8) id(13181,16903,0,0,0,1) grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0 wait(0) type(AccessExclusiveLock)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: new: proclock(0x7f79f82739a8) lock(0x7f79f1a620c8) method(1) proc(0x7f7a0fec71b8) hold(0)</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   >LOG: &nbsp;00000: LockCheckConflicts: no conflict: proclock(0x7f79f82739a8) lock(0x7f79f1a620c8) method(1) proc(0x7f7a0fec71b8) hold(0)</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   >LOG: &nbsp;00000: GrantLock: lock(0x7f79f1a620c8) id(13181,16903,0,0,0,1) grantMask(100) req(0,0,0,0,0,0,0)=1 grant(0,0,0,0,0,0,0)=1 wait(0) type(AccessExclusiveLock)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [13181,16903] AccessExclusiveLock</font></div><div><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:724</font></div><div><font size="2"   >ALTER TABLE</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# rollback;</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll: lockmethod=1</font></div><div><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:1949</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll: proclock(0x7f79f82739a8) lock(0x7f79f1a620c8) method(1) proc(0x7f7a0fec71b8) hold(100)</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll: lock(0x7f79f1a620c8) id(13181,16903,0,0,0,1) grantMask(100) req(0,0,0,0,0,0,0)=1 grant(0,0,0,0,0,0,0)=1 wait(0) type(INVALID)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: UnGrantLock: updated: lock(0x7f79f1a620c8) id(13181,16903,0,0,0,1) grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0 wait(0) type(AccessExclusiveLock)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: UnGrantLock: updated: proclock(0x7f79f82739a8) lock(0x7f79f1a620c8) method(1) proc(0x7f7a0fec71b8) hold(0)</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll: updated: lock(0x7f79f1a620c8) id(13181,16903,0,0,0,1) grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0 wait(0) type(INVALID)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: CleanUpLock: deleting: proclock(0x7f79f82739a8) lock(0x7f79f1a620c8) method(1) proc(0x7f7a0fec71b8) hold(0)</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   >LOG: &nbsp;00000: CleanUpLock: deleting: lock(0x7f79f1a620c8) id(13181,16903,0,0,0,1) grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0 wait(0) type(INVALID)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll done</font></div><div><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:2196</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll: lockmethod=2</font></div><div><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:1949</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll done</font></div><div><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:2196</font></div><div><font size="2"   >ROLLBACK</font></div></div><p></p></pre></div><div><br></div><div>会话A：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >postgres=# insert into t1 values (1);</font></div><div><font size="2"   >INSERT 0 1</font></div><p></p></pre></div><div><br></div><div>会话B：</div><div>执行DDL，等待。</div><div>输出的含义，请参考对应的代码，已经输出了代码对应的位置。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >postgres=# alter table t1 add column c1 int;</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [13181,16903] AccessExclusiveLock  --  请求AEL锁</font></div><div><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:724</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: new: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0 wait(0) type(RowExclusiveLock) </font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: new: proclock(0x7f79f8273960) lock(0x7f79f1a62020) method(1) proc(0x7f7a0fec6ed0) hold(0)</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   >LOG: &nbsp;00000: GrantLock: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(8) req(0,0,1,0,0,0,0)=1 grant(0,0,1,0,0,0,0)=1 wait(0) type(RowExclusiveLock)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: found: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(8) req(0,0,1,0,0,0,0)=1 grant(0,0,1,0,0,0,0)=1 wait(0) type(AccessExclusiveLock)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: new: proclock(0x7f79f8273918) lock(0x7f79f1a62020) method(1) proc(0x7f7a0fec71b8) hold(0)</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >LOG: &nbsp;00000: LockCheckConflicts: conflicting: proclock(0x7f79f8273918) lock(0x7f79f1a62020) method(1) proc(0x7f7a0fec71b8) hold(0)</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >LOG: &nbsp;00000: WaitOnLock: sleeping on lock: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(8) req(0,0,1,0,0,0,0)=2 grant(0,0,1,0,0,0,0)=1 wait(0) type(AccessExclusiveLock)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: DumpAllLocks: waiting on: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(8) req(0,0,1,0,0,0,0)=2 grant(0,0,1,0,0,0,0)=1 wait(1) type(INVALID)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: DumpAllLocks: proclock(0x7f79f8273960) lock(0x7f79f1a62020) method(1) proc(0x7f7a0fec6ed0) hold(8)</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   >LOG: &nbsp;00000: DumpAllLocks: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(8) req(0,0,1,0,0,0,0)=2 grant(0,0,1,0,0,0,0)=1 wait(1) type(INVALID)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: DumpAllLocks: proclock(0x7f79f8273918) lock(0x7f79f1a62020) method(1) proc(0x7f7a0fec71b8) hold(0)</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   >LOG: &nbsp;00000: DumpAllLocks: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(8) req(0,0,1,0,0,0,0)=2 grant(0,0,1,0,0,0,0)=1 wait(1) type(INVALID)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><p></p></pre></div><div><br></div><div>会话C：</div><div>执行DML，等待，这里可以清晰的看到等待的对象</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# insert into t1 values (1);</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [13181,16903] RowExclusiveLock</font></div><div><font size="2"   >LINE 1: insert into t1 values (1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:724</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: found: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(108) req(0,0,1,0,0,0,0)=3 grant(0,0,1,0,0,0,0)=2 wait(1) type(RowExclusiveLock)</font></div><div><font size="2"   >LINE 1: insert into t1 values (1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: new: proclock(0x7f79f82737b0) lock(0x7f79f1a62020) method(1) proc(0x7f7a0fec6be8) hold(0)</font></div><div><font size="2"   >LINE 1: insert into t1 values (1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   >LOG: &nbsp;00000: WaitOnLock: sleeping on lock: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(108) req(0,0,2,0,0,0,0)=4 grant(0,0,1,0,0,0,0)=2 wait(1) type(RowExclusiveLock)</font></div><div><font size="2"   >LINE 1: insert into t1 values (1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: DumpAllLocks: waiting on: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(108) req(0,0,2,0,0,0,0)=4 grant(0,0,1,0,0,0,0)=2 wait(2) type(INVALID)</font></div><div><font size="2"   >LINE 1: insert into t1 values (1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: DumpAllLocks: proclock(0x7f79f82737b0) lock(0x7f79f1a62020) method(1) proc(0x7f7a0fec6be8) hold(0)</font></div><div><font size="2"   >LINE 1: insert into t1 values (1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   >LOG: &nbsp;00000: DumpAllLocks: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(108) req(0,0,2,0,0,0,0)=4 grant(0,0,1,0,0,0,0)=2 wait(2) type(INVALID)</font></div><div><font size="2"   >LINE 1: insert into t1 values (1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: DumpAllLocks: proclock(0x7f79f8273960) lock(0x7f79f1a62020) method(1) proc(0x7f7a0fec6ed0) hold(108)</font></div><div><font size="2"   >LINE 1: insert into t1 values (1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   >LOG: &nbsp;00000: DumpAllLocks: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(108) req(0,0,2,0,0,0,0)=4 grant(0,0,1,0,0,0,0)=2 wait(2) type(INVALID)</font></div><div><font size="2"   >LINE 1: insert into t1 values (1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: DumpAllLocks: proclock(0x7f79f8273918) lock(0x7f79f1a62020) method(1) proc(0x7f7a0fec71b8) hold(0)</font></div><div><font size="2"   >LINE 1: insert into t1 values (1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   >LOG: &nbsp;00000: DumpAllLocks: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(108) req(0,0,2,0,0,0,0)=4 grant(0,0,1,0,0,0,0)=2 wait(2) type(INVALID)</font></div><div><font size="2"   >LINE 1: insert into t1 values (1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><p></p></pre></div><div><br></div><div>会话D：</div><div>使用LOCK 命令，同时使用 NOWAIT参数：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >postgres=# lock table t1 in access exclusive mode nowait;</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: lock [13181,16903] AccessExclusiveLock</font></div><div><font size="2"   >LOCATION: &nbsp;LockAcquireExtended, lock.c:724</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: found: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(108) req(0,0,1,0,0,0,0)=3 grant(0,0,1,0,0,0,0)=2 wait(1) type(AccessExclusiveLock)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: new: proclock(0x7f79f82737b0) lock(0x7f79f1a62020) method(1) proc(0x7f7a0fec6be8) hold(0)</font></div><div><font size="2"   >LOCATION: &nbsp;PROCLOCK_PRINT, lock.c:331</font></div><div><font size="2"   >LOG: &nbsp;00000: LockAcquire: conditional lock failed: lock(0x7f79f1a62020) id(13181,16903,0,0,0,1) grantMask(108) req(0,0,1,0,0,0,0)=3 grant(0,0,1,0,0,0,0)=2 wait(1) type(AccessExclusiveLock)</font></div><div><font size="2"   >LOCATION: &nbsp;LOCK_PRINT, lock.c:319</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll: lockmethod=1</font></div><div><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:1949</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll done</font></div><div><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:2196</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll: lockmethod=2</font></div><div><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:1949</font></div><div><font size="2"   >LOG: &nbsp;00000: LockReleaseAll done</font></div><div><font size="2"   >LOCATION: &nbsp;LockReleaseAll, lock.c:2196</font></div><div><font size="2"   >ERROR: &nbsp;55P03: could not obtain lock on relation "t1"</font></div><div><font size="2"   >LOCATION: &nbsp;RangeVarGetRelidExtended, namespace.c:391</font></div><p></p></pre></div><div><br></div><div>因为目前PostgreSQL DDL没有NOWAIT选项，（除了set tablespace)。</div><div>所以<span style="line-height: 28px;"   >要解决无休止等待的问题，需要另辟蹊径。</span></div><div><span style="line-height: 28px;"   >方法也比较多：</span></div><div><span style="line-height: 28px;"   >1. 使用</span>lock_timeout</div><div>在执行DDL前，设置本地会话的锁超时为1毫秒。那么影响也只有1毫秒。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# set lock_timeout='1ms';</font></div><div><font size="2"   >SET</font></div></div><div><div><font size="2"   >postgres=# alter table t1 add column cc int; &nbsp;-- 等待1毫秒后如果无法获得锁，立即返回。</font></div><div><font size="2"   >ERROR: &nbsp;canceling statement due to lock timeout</font></div></div><p></p></pre></div><div><br></div><div>2. 在事务中叠加lock nowait命令,<span style="line-height: 28px;"   >不需要执行下面的DDL。</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# \h lock</font></div><div><font size="2"   >Command: &nbsp; &nbsp; LOCK</font></div><div><font size="2"   >Description: lock a table</font></div><div><font size="2"   >Syntax:</font></div><div><font size="2"   >LOCK [ TABLE ] [ ONLY ] name [ * ] [, ...] [ IN lockmode MODE ] [ NOWAIT ]</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >where lockmode is one of:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE</font></div><div><font size="2"   >&nbsp; &nbsp; | SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE</font></div></div><div><font size="2"   >例如,</font></div><div><div><font size="2"   >postgres=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >postgres=# lock table t1 in access exclusive mode nowait; &nbsp;-- &nbsp;如果获得锁失败了，不需要执行下面的DDL。</font></div><div><font size="2"   >LOCK TABLE</font></div><div><font size="2"   >postgres=# alter table t1 add column cc1 int;</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >postgres=# end;</font></div><div><font size="2"   >COMMIT</font></div></div><p></p></pre></div><div>个人还是推荐第一种方法，更方便，但是不要在全局参数中这么设置，只需要在当前维护操作的会话中设置。</div><div><br></div><div>其他：</div><div>1. 如果要实现DDL的nowait，这里的一些锁函数需要调整一下，当使用nowait时LockAcquire传入dontWait=true；</div><div>或者增加一个GUC参数，控制是否NOWAIT(不过感觉和lock timeout有点冲突，没有必要)。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >LockRelationOid</font></div><div><font size="2"   >LockRelation</font></div><div><font size="2"   >LockRelationIdForSession</font></div><div><font size="2"   >LockRelationForExtension</font></div><div><font size="2"   >XactLockTableInsert</font></div><div><font size="2"   >XactLockTableWait</font></div><div><font size="2"   >SpeculativeInsertionLockAcquire</font></div><div><font size="2"   >SpeculativeInsertionWait</font></div><div><font size="2"   >LockDatabaseObject</font></div><div><font size="2"   >LockSharedObject</font></div><div><font size="2"   >LockSharedObjectForSession</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 28px;"   >2. 事件触发器行么？-- 不行，因为进入等待后你不能自己检测自己的状态。</span></div><div><span style="line-height: 28px;"   >例如，这样是行不通的。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE OR REPLACE FUNCTION online_ddl_command()</font></div><div><font size="2"   >&nbsp; RETURNS event_trigger</font></div><div><font size="2"   >&nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp; AS $$</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; raise notice 'event trigger';</font></div><div><font size="2"   >&nbsp; perform 1 from pg_stat_activity where pid=pg_backend_pid() and waiting;</font></div><div><font size="2"   >&nbsp; if found then</font></div><div><font size="2"   >&nbsp; &nbsp; RAISE EXCEPTION 'command % is waiting lock, I must abort it.', tg_tag;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$$;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CREATE EVENT TRIGGER online_ddl ON ddl_command_start</font></div><div><font size="2"   >&nbsp; &nbsp;EXECUTE PROCEDURE online_ddl_command();</font></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201422083228624"   >http://blog.163.com/digoal@126/blog/static/163877040201422083228624</a></div><div>2.&nbsp;src/include/pg_config_manual.h</div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/runtime-config-developer.html"   >http://www.postgresql.org/docs/devel/static/runtime-config-developer.html</a></div><div>4.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://dev.mysql.com/doc/refman/5.6/en/innodb-create-index-overview.html#innodb-online-ddl-summary-grid"   >http://dev.mysql.com/doc/refman/5.6/en/innodb-create-index-overview.html#innodb-online-ddl-summary-grid</a></div><div>5.&nbsp;src/backend/storage/lmgr/lock.c</div><div>如果要使用nowait, 在调用LockAcquire 时，dontWait传入true。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* LockAcquire -- Check for lock conflicts, sleep if conflict found,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;set lock if/when no conflicts.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Inputs:</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;locktag: unique identifier for the lockable object</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;lockmode: lock mode to acquire</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;sessionLock: if true, acquire lock for session not current transaction</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;dontWait: if true, don't wait to acquire lock</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Returns one of:</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LOCKACQUIRE_NOT_AVAIL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock not available, and dontWait=true</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LOCKACQUIRE_OK &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lock successfully acquired</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LOCKACQUIRE_ALREADY_HELD &nbsp; &nbsp; &nbsp; &nbsp;incremented count for lock already held</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* In the normal case where dontWait=false and the caller doesn't need to</font></div><div><font size="2"   >&nbsp;* distinguish a freshly acquired lock from one already taken earlier in</font></div><div><font size="2"   >&nbsp;* this same transaction, there is no need to examine the return value.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Side Effects: The lock is acquired and recorded in lock tables.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* NOTE: if we wait for the lock, there is no way to abort the wait</font></div><div><font size="2"   >&nbsp;* short of aborting the transaction.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >LockAcquireResult</font></div><div><font size="2"   >LockAcquire(const LOCKTAG *locktag,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE lockmode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool sessionLock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool dontWait)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return LockAcquireExtended(locktag, lockmode, sessionLock, dontWait, true);</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="online DDL (or NOWAIT DDL) in PostgreSQL - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>