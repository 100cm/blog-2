<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">table level replication use trigger -- one(rw) to many(ro|rw)</h2>
	<h5 id="">2012-08-31 15:53:53&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012731203716/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>本文在9.2下面测试, 较老版本可能系统表的字段名不一样, 需要修改触发器函数相关部分, 如pg_stat_activity的pid, 老版本是procpid.</div><div><br></div><wbr>数据同步是一个比较老的话题了, 在PostgreSQL中有比较多的同步手段, 例如流复制, slony, londiste, pgpool等.<div>不过这些都需要诸多的配置, 流复制的话更是需要将所有的物理数据都复制过去. 同时也不能实现双向同步(multi-master).</div><div>如果只想同步少量的数据(改动量不太大), 例如单表. 或者单表中的某些列, 甚至单表中某些符合条件的行同步到其他一个或多个节点.&nbsp;</div><div>甚至是需要双向可写的复制(oracle 物化视图无法实现). 这些简单的使用以上工具是无法实现的.</div><div>下面使用触发器和dblink来举个例子, 实现以上的功能, 同时是实时的同步(但是必须注意到使用触发器带来的开销, 所以不是所有场景都适用).</div><div>这里用到的同步表都需要有主键.</div><div>例如要将一个表同步到一个(或多个)远程节点 :&nbsp;</div><div><div><img title="table level replication use trigger -- one(rw) to many(ro|rw) - 德哥@Digoal - The Heart,The World."   alt="table level replication use trigger -- one(rw) to many(ro|rw) - 德哥@Digoal - The Heart,The World."   style="margin:0 10px 0 0;"   src="http://img3.ph.126.net/ogQ2fBH5SkRvp4H73MYQIQ==/6597404018192223723.jpg"   ></div>&nbsp;</div><div>源表信息如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >schema : digoal</font></div><div><font size="2"   >table_name : loc_test</font></div><div><font size="2"   >表结构 :&nbsp;</font></div><div><font size="2"   >digoal=&gt; \d loc_test</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Table "digoal.loc_test"</font></div><div><font size="2"   >&nbsp; &nbsp;Column &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Modifiers&nbsp;</font></div><div><font size="2"   >-------------+--------------------------------+-----------</font></div><div><font size="2"   >&nbsp;id &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| integer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| not null</font></div><div><font size="2"   >&nbsp;info &nbsp; &nbsp; &nbsp; &nbsp;| text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >&nbsp;create_time | timestamp(0) without time zone |&nbsp;</font></div><div><font size="2"   >&nbsp;modify_time | timestamp(0) without time zone |&nbsp;</font></div><div><font size="2"   >Indexes:</font></div><div><font size="2"   >&nbsp; &nbsp; "loc_test_pkey" PRIMARY KEY, btree (id)</font></div></div><p></p></pre></div><div><br></div><div>源表所在服务器上的用来记录同步错误的SQL的表如下 :&nbsp;</div><div>用于后续修复数据.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create table sync_err_rec(id serial8 primary key, nsp_name name, table_name name, dst_server text, dst_query text, create_time timestamp without time zone);</font></div><div><div><font size="2"   >digoal=&gt; \d sync_err_rec</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Table "digoal.sync_err_rec"</font></div><div><font size="2"   >&nbsp; &nbsp;Column &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Modifiers &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-------------+-----------------------------+-----------------------------------------------------------</font></div><div><font size="2"   >&nbsp;id &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| not null default nextval('sync_err_rec_id_seq'::regclass)</font></div><div><font size="2"   >&nbsp;nsp_name &nbsp; &nbsp;| name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;table_name &nbsp;| name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;dst_server &nbsp;| text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;dst_query &nbsp; | text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;create_time | timestamp without time zone |&nbsp;</font></div><div><font size="2"   >Indexes:</font></div><div><font size="2"   >&nbsp; &nbsp; "sync_err_rec_pkey" PRIMARY KEY, btree (id)</font></div></div><p></p></pre></div><div><br></div><div>远程表信息如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >schema : digoal</font></div><div><font size="2"   >table_name : rmt_digoal</font></div><div><font size="2"   >表结构 :&nbsp;</font></div><div><div><font size="2"   >digoal=&gt; \d rmt_test</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Table "digoal.rmt_test"</font></div><div><font size="2"   >&nbsp; &nbsp;Column &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Modifiers&nbsp;</font></div><div><font size="2"   >-------------+--------------------------------+-----------</font></div><div><font size="2"   >&nbsp;id &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| integer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| not null</font></div><div><font size="2"   >&nbsp;info &nbsp; &nbsp; &nbsp; &nbsp;| text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >&nbsp;create_time | timestamp(0) without time zone |&nbsp;</font></div><div><font size="2"   >&nbsp;modify_time | timestamp(0) without time zone |&nbsp;</font></div><div><font size="2"   >Indexes:</font></div><div><font size="2"   >&nbsp; &nbsp; "rmt_test_pkey" PRIMARY KEY, btree (id)</font></div></div><p></p></pre></div><div><br></div><div>步骤如下 :&nbsp;</div><div>1. 创建数据库连接 :&nbsp;</div><div>-- 回收<span style="line-height: 22px;"   >pg_user_mappings的public权限, 否则普通用户能查看到它的内容, 包含密码, 比较危险.</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# revoke all on pg_user_mappings from public;</font></div><div><font size="2"   >REVOKE</font></div><p></p></pre></div><div>-- 创建fdw.</div><div><pre class="prettyprint"   ><p><font size="2"   >CREATE FOREIGN DATA WRAPPER postgresql VALIDATOR postgresql_fdw_validator;</font></p></pre></div><div>-- 创建远程服务器. 指定远程IP, 端口, 库名, 连接参数.</div><div>-- 注意这里使用了客户端选项<span style="line-height: 22px;"   >application_name=aaa_bbb_digoal, 后面将被用于远程数据库表的触发器用来判断是什么客户端连上来的.</span></div><div><span style="line-height: 22px;"   >-- 以便允许源表这里连上来做DML操作, 但是拒绝其他做DML操作, 这样就可以控制目标表的只读.</span></div><div><pre class="prettyprint"   ><p><font size="2"   >CREATE SERVER dst_digoal FOREIGN DATA WRAPPER postgresql OPTIONS (hostaddr '192.168.20.47', port '1921', dbname 'digoal', options '-c application_name=aaa_bbb_digoal');</font></p></pre></div><div>-- 赋予server权限给操作源表的用户, 例如这里使用digoal操作源表.</div><div><pre class="prettyprint"   ><p><font size="2"   >GRANT USAGE ON FOREIGN SERVER dst_digoal TO digoal;</font></p></pre></div><div>-- 创建user mapping, 用户密码是连接远程数据库的用户密码.</div><div><pre class="prettyprint"   ><p><font size="2"   >CREATE USER MAPPING FOR digoal SERVER dst_digoal OPTIONS (user 'digoal', password 'DIGOAL321');</font></p></pre></div></div><div><br></div><div>2. 用于复制的触发器函数如下.</div><div>-- &nbsp;这个函数分两种情况, 大家可以根据自己的需要修改函数内容 :&nbsp;</div><div><div>-- 1.如果远程执行失败,允许本地成功,本地写sync_err_rec</div><div>-- 2.如果远程执行失败,保证本地也失败,本地不写sync_err_rec</div></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE OR REPLACE FUNCTION f_sync_loc_test()</font></div><div><font size="2"   >RETURNS trigger</font></div><div><font size="2"   >LANGUAGE plpgsql</font></div><div><font size="2"   >AS $BODY$</font></div><div><font size="2"   >DECLARE</font></div><div><font size="2"   >&nbsp; v_conn_name text := 'digoal'; &nbsp;-- 连接名</font></div><div><font size="2"   >&nbsp; v_dst_server text := 'dst_digoal'; &nbsp;-- foreign server</font></div><div><font size="2"   >&nbsp; v_conn_status text; &nbsp;-- 存储dblink_connect(v_conn_name, v_dst_server)的返回值</font></div><div><font size="2"   >&nbsp; v_nsp_name name := TG_TABLE_SCHEMA; &nbsp;-- 触发器变量, 触发这个触发器的表所在的schema</font></div><div><font size="2"   >&nbsp; v_table_name name := TG_TABLE_NAME; &nbsp;-- 触发器变量, 触发这个触发器的表名</font></div><div><font size="2"   >&nbsp; v_dst_nsp_name name := 'digoal'; &nbsp;-- 目标schema, 当需要复制到其他schema下时, 这里改成其schema名即可</font></div><div><font size="2"   >&nbsp; v_dst_table_name name := 'rmt_test'; &nbsp;-- 目标表名</font></div><div><font size="2"   >&nbsp; v_query text; &nbsp;-- 使用dblink_build_sql_insert, dblink_build_sql_update, dblink_build_sql_delete得到的SQL, 用于调用dblink_exec远程执行.</font></div><div><font size="2"   >&nbsp; v_query_upd1 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_query_upd2 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_dst_query text; &nbsp;-- v_query修改后的语句, 主要就是修改目标schema和目标表名</font></div><div><font size="2"   >&nbsp; v_dst_query_upd1 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_dst_query_upd2 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_pk_vector int2vector; &nbsp;-- dblink_build_sql_insert, dblink_build_sql_update, dblink_build_sql_delete要用到的被复制的表的PK列s的逻辑位置</font></div><div><font size="2"   >&nbsp; v_pk_cnt int; &nbsp;-- dblink_build_sql_insert, dblink_build_sql_update, dblink_build_sql_delete要用到的被复制的表的PK列个数</font></div><div><font size="2"   >&nbsp; v_pk_att_vals_array text[]; &nbsp;-- pk值</font></div><div><font size="2"   >&nbsp; v_exec_status text; &nbsp;-- 存储dblink_exec(v_conn_name, v_dst_query, true|false)的返回值.</font></div><div><font size="2"   >&nbsp; v_disconn_status text; &nbsp;-- 存储dblink_disconnect(v_conn_name)的返回值.</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; v_pk_vector := int2vector '1';</font></div><div><font size="2"   >&nbsp; v_pk_cnt := 1;</font></div><div><font size="2"   >&nbsp; -- v_pk_vector和v_pk_cnt也可以使用以下SQL得到.</font></div><div><font size="2"   >&nbsp; -- select string_agg(position::text,' ')::int2vector,count(*) into v_pk_vector,v_pk_cnt&nbsp;</font></div><div><font size="2"   >&nbsp; -- &nbsp;from dblink_get_pkey(v_nsp_name||'.'||v_table_name);</font></div><div><font size="2"   >&nbsp; case TG_OP</font></div><div><font size="2"   >&nbsp; when 'INSERT' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的insert语句, id是这个表的主键. 如果是多列值的则需要得到按v_pk_vector顺序的text[]</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||NEW.id||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query from dblink_build_sql_insert(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; when 'DELETE' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的delete语句, id是这个表的主键. 如果是多列值的则需要得到按v_pk_vector顺序的text[]</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||OLD.id||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query from dblink_build_sql_delete(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; when 'UPDATE' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的update语句, id是这个表的主键. 如果是多列值的则需要得到按v_pk_vector顺序的text[]</font></div><div><font size="2"   >    -- 这里没有使用dblink_build_sql_update来生成update语句, 因为主键也可能被更新. 所以只能拆成两部分.</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||OLD.id||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query_upd1 from dblink_build_sql_delete(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||NEW.id||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query_upd2 from dblink_build_sql_insert(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; when 'TRUNCATE' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的truncate语句. 注意这里是truncate table only. 如果是子表, 可以在子表上继续减这样的触发器.</font></div><div><font size="2"   >&nbsp; &nbsp; v_query := 'truncate table only '||v_table_name;</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >&nbsp; -- 将目标schema和目标表名替换现有表名.</font></div><div><font size="2"   >&nbsp; case TG_OP</font></div><div><font size="2"   >&nbsp; when 'UPDATE' then</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query_upd1 := regexp_replace(v_query_upd1, v_table_name, v_dst_nsp_name||'.'||v_dst_table_name, '');</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query_upd2 := regexp_replace(v_query_upd2, v_table_name, v_dst_nsp_name||'.'||v_dst_table_name, '');</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query := v_dst_query_upd1||';'||v_dst_query_upd2;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query := regexp_replace(v_query, v_table_name, v_dst_nsp_name||'.'||v_dst_table_name, '');</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >&nbsp; -- 如果想打印用于复制的SQL是否正确, 可以使用以下语句 :&nbsp;</font></div><div><font size="2"   >&nbsp; -- raise notice 'v_dst_query:%', v_dst_query;</font></div><div><font size="2"   >&nbsp; -- 判断连接是否存在, 不存在则创建.</font></div><div><font size="2"   >&nbsp; if ( dblink_get_connections() @&gt; ('{'||v_conn_name||'}')::text[] ) then&nbsp;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_conn_status from dblink_connect(v_conn_name, v_dst_server);</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 如果远程执行失败,确保本地成功,本地写sync_err_rec</font></div><div><font size="2"   >&nbsp; select * into v_exec_status from dblink_exec(v_conn_name, v_dst_query, false);</font></div><div><font size="2"   >&nbsp; if (v_exec_status = 'ERROR') then</font></div><div><font size="2"   >&nbsp; &nbsp; insert into sync_err_rec (nsp_name, table_name, dst_server, dst_query, create_time)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_nsp_name, v_table_name, v_dst_server, v_dst_query, clock_timestamp());</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 如果想要远程失败,本地失败,本地不写sync_err_rec. 使用以下SQL替换前面几条SQL.&nbsp;</font></div><div><font size="2"   >&nbsp; -- 不了解的话可以去查询dblink_exec的详解.</font></div><div><font size="2"   >&nbsp; -- select * into v_exec_status from dblink_exec(v_conn_name, v_dst_query, true);</font></div><div><font size="2"   >&nbsp; -- -------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp; -- 不建议每次断开连接, 因为频繁的连接还是会带来很大开销的, 除非你在本地建立pgbouncer, 让pgbouncer来维持长连接.</font></div><div><font size="2"   >&nbsp; -- 断开连接的语句如下.</font></div><div><font size="2"   >&nbsp; -- select * into v_disconn_status from dblink_disconnect(v_conn_name);</font></div><div><font size="2"   >&nbsp; return null;</font></div><div><font size="2"   >exception</font></div><div><font size="2"   >when others then</font></div><div><font size="2"   >&nbsp; raise notice 'v_conn_status:%, v_exec_status:%, v_disconn_status:%.', v_conn_status, v_exec_status, v_disconn_status;</font></div><div><font size="2"   >&nbsp; insert into sync_err_rec (nsp_name, table_name, dst_server, dst_query, create_time)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; values (v_nsp_name, v_table_name, v_dst_server, v_dst_query, clock_timestamp());</font></div><div><font size="2"   >&nbsp; -- 如果想要远程失败,本地失败,本地不写sync_err_rec. 同时还需要以下语句.</font></div><div><font size="2"   >&nbsp; -- raise;</font></div><div><font size="2"   >&nbsp; return null;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$BODY$;</font></div><p></p></pre></div><div><br></div><div>3. 创建DML以及truncate的复制触发器.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE TRIGGER loc_test_sync_dml AFTER DELETE or UPDATE or INSERT ON loc_test FOR EACH ROW EXECUTE PROCEDURE f_sync_loc_test();</font></div><div><font size="2"   >CREATE TRIGGER loc_test_sync_truncate AFTER TRUNCATE ON loc_test FOR EACH STATEMENT EXECUTE PROCEDURE f_sync_loc_test();</font></div><p></p></pre></div><div><br></div><div>4. -- 可选, 如果你不想远程表被复制程序以外的会话对这个表进行dml和truncate操作, 使用以下触发器来控制.</div><div><div>-- 远程表避免增删改和truncate, 无法避免drop.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE OR REPLACE FUNCTION f_rmt_test()</font></div><div><font size="2"   >RETURNS trigger</font></div><div><font size="2"   >LANGUAGE plpgsql</font></div><div><font size="2"   >AS $BODY$</font></div><div><font size="2"   >DECLARE</font></div><div><font size="2"   >v_application_name text;</font></div><div><font size="2"   >v_pg_backend_pid int;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; -- 获取会话的postgres pid</font></div><div><font size="2"   >&nbsp; select pg_backend_pid() into v_pg_backend_pid;</font></div><div><font size="2"   >&nbsp; -- 根据这个PID获取application_name, 这个就可以用来区分是不是复制程序连上来的会话.</font><span style="font-size: small; line-height: 19px;"   >9.1(含9.1)以前的版本pg_stat_activity.procpid.</span></div><div><font size="2"   >&nbsp; select application_name into v_application_name from pg_stat_activity where pid=v_pg_backend_pid;</font></div><div><font size="2"   >&nbsp; -- 如果不是复制程序连上来的会话, 返回一个错误就行.</font></div><div><font size="2"   >&nbsp; if (v_application_name &lt;&gt; 'aaa_bbb_digoal' ) then</font></div><div><font size="2"   >&nbsp; &nbsp; raise exception 'you cann''t modify this table.';</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; return null;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$BODY$;</font></div><p></p></pre></div></div><div>拒绝除复制程序以外的会话进行DML以及TRUNCATE的触发器 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create trigger trg_rmt_test_1 BEFORE INSERT OR DELETE OR UPDATE OR TRUNCATE ON rmt_test FOR EACH STATEMENT EXECUTE PROCEDURE f_rmt_test();</font></div><div></div><p></p></pre></div><div><br></div><div>5. 好了, 现在来测试一下从loc_test复制到rmt_test的情况.</div><div>本例使用到的触发器函数,&nbsp;<span style="line-height: 22px;"   >如果远程执行失败,允许本地成功,本地写sync_err_rec</span></div><div>源站 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; insert into loc_test values (1, 'digoal', now(), now());</font></div><div><font size="2"   >INSERT 0 1</font></div></div><div><font size="2"   >-- 插入测试</font></div><div><div><font size="2"   >digoal=&gt; select * from loc_test ;</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; create_time &nbsp; &nbsp; | &nbsp; &nbsp; modify_time &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+--------+---------------------+---------------------</font></div><div><font size="2"   >&nbsp; 1 | digoal | 2012-08-31 14:33:17 | 2012-08-31 14:33:17</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >-- 没有错误记录</font></div><div><font size="2"   >digoal=&gt; select * from sync_err_rec ;</font></div><div><font size="2"   >&nbsp;nsp_name | table_name | dst_server | dst_query | create_time&nbsp;</font></div><div><font size="2"   >----------+------------+------------+-----------+-------------</font></div><div><font size="2"   >(0 rows)</font></div></div><p></p></pre></div><div>目标站点 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select * from rmt_test ;</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; create_time &nbsp; &nbsp; | &nbsp; &nbsp; modify_time &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+--------+---------------------+---------------------</font></div><div><font size="2"   >&nbsp; 1 | digoal | 2012-08-31 14:33:17 | 2012-08-31 14:33:17</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>源站更新测试 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; update loc_test set info='DIGOAL';</font></div><div><font size="2"   >NOTICE: &nbsp;v_dst_query:DELETE FROM digoal.rmt_test WHERE id = '1';INSERT INTO digoal.rmt_test(id,info,create_time,modify_time) VALUES('1','DIGOAL','2012-08-31 14:59:41','2012-08-31 14:59:41')</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   >digoal=&gt; select * from loc_test ;</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; create_time &nbsp; &nbsp; | &nbsp; &nbsp; modify_time &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+--------+---------------------+---------------------</font></div><div><font size="2"   >&nbsp; 1 | DIGOAL | 2012-08-31 14:59:41 | 2012-08-31 14:59:41</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>目标站点 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select * from rmt_test ;</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; create_time &nbsp; &nbsp; | &nbsp; &nbsp; modify_time &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+--------+---------------------+---------------------</font></div><div><font size="2"   >&nbsp; 1 | DIGOAL | 2012-08-31 14:59:41 | 2012-08-31 14:59:41</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div><br></div><div>源站删除测试 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; delete from loc_test ;</font></div><div><font size="2"   >NOTICE: &nbsp;v_dst_query:DELETE FROM digoal.rmt_test WHERE id = '1'</font></div><div><font size="2"   >DELETE 1</font></div><div><font size="2"   >digoal=&gt; select * from loc_test ;</font></div><div><font size="2"   >&nbsp;id | info | create_time | modify_time&nbsp;</font></div><div><font size="2"   >----+------+-------------+-------------</font></div><div><font size="2"   >(0 rows)</font></div><p></p></pre></div><div>目标站点 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select * from rmt_test ;</font></div><div><font size="2"   >&nbsp;id | info | create_time | modify_time&nbsp;</font></div><div><font size="2"   >----+------+-------------+-------------</font></div><div><font size="2"   >(0 rows)</font></div><p></p></pre></div></div><div><br></div><div>源站批量插入测试 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; insert into loc_test select generate_series(1,100),'DIGOAL',now(),now();</font></div><div><font size="2"   >digoal=&gt; insert into loc_test select id+1000,'TEST',now(),now() from loc_test ;</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=&gt; select sum(hashtext(t.*::text)),count(*) from loc_test t;</font></div><div><font size="2"   >&nbsp; &nbsp; sum &nbsp; &nbsp; | count&nbsp;</font></div><div><font size="2"   >------------+-------</font></div><div><font size="2"   >&nbsp;8757913752 | &nbsp; 200</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div>目标站点 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select sum(hashtext(t.*::text)),count(*) from rmt_test t;</font></div><div><font size="2"   >&nbsp; &nbsp; sum &nbsp; &nbsp; | count&nbsp;</font></div><div><font size="2"   >------------+-------</font></div><div><font size="2"   >&nbsp;8757913752 | &nbsp; 200</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>源站truncate测试 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; truncate table loc_test ;</font></div><div><font size="2"   >NOTICE: &nbsp;v_dst_query:truncate table only digoal.rmt_test</font></div><div><font size="2"   >TRUNCATE TABLE</font></div><div><font size="2"   >digoal=&gt; select count(*) from loc_test ;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>目标站点 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select count(*) from rmt_test ;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div><br></div><div>如果网络发生异常, 或者用户更改密码了, 无法复制到远程数据库, &nbsp;将会记录到sync_err_rec表.&nbsp;</div><div>以下模拟远程用户修改密码, 无法复制的情况.</div><div>目标库修改连接的用户密码 :</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# alter role digoal encrypted password 'test';</font></div><div><font size="2"   >ALTER ROLE</font></div><p></p></pre></div><div>源站测试插入失败测试 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; insert into loc_test values (1,'DIGOAL',now(),now());</font></div><div><font size="2"   >NOTICE: &nbsp;v_dst_query:INSERT INTO digoal.rmt_test(id,info,create_time,modify_time) VALUES('1','DIGOAL','2012-08-31 15:40:29','2012-08-31 15:40:29')</font></div><div><font size="2"   >NOTICE: &nbsp;v_conn_status:&lt;NULL&gt;, v_exec_status:&lt;NULL&gt;, v_disconn_status:&lt;NULL&gt;.</font></div><div><font size="2"   >INSERT 0 1</font></div><p></p></pre></div><div>查看源站loc_test表, 记录已经插入 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select * from loc_test ;</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; create_time &nbsp; &nbsp; | &nbsp; &nbsp; modify_time &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+--------+---------------------+---------------------</font></div><div><font size="2"   >&nbsp; 1 | DIGOAL | 2012-08-31 15:08:07 | 2012-08-31 15:08:07</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>查看错误记录表, 记录已经插入 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select * from sync_err_rec ;</font></div><div><font size="2"   >&nbsp;id | nsp_name | table_name | dst_server | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dst_query &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp;create_time &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+----------+------------+------------+------------------------------------------------------------------------------------------</font></div><div><font size="2"   >-------------------------------------+----------------------------</font></div><div><font size="2"   >&nbsp; 7 | digoal &nbsp; | loc_test &nbsp; | dst_digoal | INSERT INTO digoal.rmt_test(id,info,create_time,modify_time) VALUES('1','DIGOAL','2012-08</font></div><div><font size="2"   >-31 15:40:29','2012-08-31 15:40:29') | 2012-08-31 15:40:29.301519</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>查看远程表 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select * from rmt_test ;</font></div><div><font size="2"   >&nbsp;id | info | create_time | modify_time&nbsp;</font></div><div><font size="2"   >----+------+-------------+-------------</font></div><div><font size="2"   >(0 rows)</font></div><p></p></pre></div><div><br></div><div>源站更新失败测试 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><div><font size="2"   >digoal=&gt; update loc_test set id=2;</font></div><div><font size="2"   >NOTICE: &nbsp;v_dst_query:DELETE FROM digoal.rmt_test WHERE id = '1';INSERT INTO digoal.rmt_test(id,info,create_time,modify_time) VALUES('2','DIGOAL','2012-08-31 15:40:29','2012-08-31 15:40:29')</font></div><div><font size="2"   >NOTICE: &nbsp;v_conn_status:&lt;NULL&gt;, v_exec_status:&lt;NULL&gt;, v_disconn_status:&lt;NULL&gt;.</font></div><div><font size="2"   >UPDATE 1</font></div></div><div><div><font size="2"   >digoal=&gt; select * from loc_test ;</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; create_time &nbsp; &nbsp; | &nbsp; &nbsp; modify_time &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+--------+---------------------+---------------------</font></div><div><font size="2"   >&nbsp; 2 | DIGOAL | 2012-08-31 15:40:29 | 2012-08-31 15:40:29</font></div><div><font size="2"   >(1 row)</font></div></div></div><div><div><font size="2"   >digoal=&gt; select * from sync_err_rec ;</font></div><div><font size="2"   >&nbsp;id | nsp_name | table_name | dst_server | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dst_query&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp;create_time &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+----------+------------+------------+------------------------------------------------------------------------------------------</font></div><div><font size="2"   >--------------------------------------------------------------------------------+----------------------------</font></div><div><font size="2"   >&nbsp; 7 | digoal &nbsp; | loc_test &nbsp; | dst_digoal | INSERT INTO digoal.rmt_test(id,info,create_time,modify_time) VALUES('1','DIGOAL','2012-08</font></div><div><font size="2"   >-31 15:40:29','2012-08-31 15:40:29') &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 2012-08-31 15:40:29.301519</font></div><div><font size="2"   >&nbsp; 8 | digoal &nbsp; | loc_test &nbsp; | dst_digoal | DELETE FROM digoal.rmt_test WHERE id = '1';INSERT INTO digoal.rmt_test(id,info,create_tim</font></div><div><font size="2"   >e,modify_time) VALUES('2','DIGOAL','2012-08-31 15:40:29','2012-08-31 15:40:29') | 2012-08-31 15:41:14.607253</font></div><div><font size="2"   >(2 rows)</font></div></div><p></p></pre></div><div><br></div><div>目标站点表目前仍无记录 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select * from rmt_test ;</font></div><div><font size="2"   >&nbsp;id | info | create_time | modify_time&nbsp;</font></div><div><font size="2"   >----+------+-------------+-------------</font></div><div><font size="2"   >(0 rows)</font></div><p></p></pre></div><div><br></div><div>6. 接下来要写个函数来处理<span style="line-height: 22px;"   >sync_err_rec里面的错误记录, 必须按照create_time顺序处理.</span></div><div><div><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >create or replace function deal_sync_err_rec (i_dst_server text, i_dst_query text, i_id int8) returns boolean as $$</font></div><div style="line-height: 22px;"   ><font size="2"   >declare</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; v_conn_name text := 'digoal'; &nbsp;-- 连接名</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; v_conn_status text; &nbsp;-- 存储dblink_connect(v_conn_name, v_dst_server)的返回值</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; v_exec_status text; &nbsp;-- 存储dblink_exec(v_conn_name, v_dst_query, true|false)的返回值.</font></div><div style="line-height: 22px;"   ><font size="2"   >begin</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;&nbsp;-- 删除sync_err_rec中对应的记录.</font></div><div style="line-height: 22px;"   ><font size="2"   >  delete from sync_err_rec where id=i_id;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; if ( dblink_get_connections() @&gt; ('{'||v_conn_name||'}')::text[] ) then&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; else</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; select * into v_conn_status from dblink_connect(v_conn_name, i_dst_server);</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; end if;</font></div><div style="line-height: 22px;"   ><font size="2"   >  -- 这里使用的是true, 所以远程异常, 本地也异常. 确保到这一步还可以回退, 只要这一步执行成功, 那本地删除的sync_err_rec和远程都执行成功.</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; select * into v_exec_status from dblink_exec(v_conn_name, i_dst_query, true);</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; -- raise notice 'v_conn_status:%, v_exec_status:%.', v_conn_status, v_exec_status;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; return true;</font></div><div style="line-height: 22px;"   ><font size="2"   >END;</font></div><div style="line-height: 22px;"   ><font size="2"   >$$ language plpgsql;</font></div><p></p></pre></div><div style="line-height: 22px;"   >处理 :&nbsp;</div><div style="line-height: 22px;"   >先把密码修改回来,</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# alter role digoal encrypted password 'DIGOAL321';</font></div><div><font size="2"   >ALTER ROLE</font></div><p></p></pre></div><div style="line-height: 22px;"   >然后使用以下SQL进行处理 :&nbsp;</div><div style="line-height: 22px;"   >注意一次只处理一条, 因为远端和本地未使用跨库事务. 只能一条一条来. 直到<span style="line-height: 22px;"   >sync_err_rec</span><span style="line-height: 22px;"   >&nbsp;表没记录为止.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >处理顺序按照</span><span style="line-height: 22px;"   >create_time</span><span style="line-height: 22px;"   >&nbsp;排序, 所以</span><span style="line-height: 22px;"   >create_time</span><span style="line-height: 22px;"   >&nbsp;使用了timestamp without time zone类型以及clock_timestamp()进行插入, 精确到秒后面6位. 基本能满足唯一且顺序需求.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >下一篇BLOG将针对deal_sync_err_rec函数进行优化, 改成批量处理.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select deal_sync_err_rec(dst_server,dst_query,id) from&nbsp;</font></div><div><font size="2"   >digoal-&gt; (select dst_server,dst_query,id from sync_err_rec order by create_time limit 1) t;</font></div><div><font size="2"   >&nbsp;deal_sync_err_rec&nbsp;</font></div><div><font size="2"   >-------------------</font></div><div><font size="2"   >&nbsp;t</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=&gt; select deal_sync_err_rec(dst_server,dst_query,id) from&nbsp;</font></div><div><font size="2"   >(select dst_server,dst_query,id from sync_err_rec order by create_time limit 1) t;</font></div><div><font size="2"   >&nbsp;deal_sync_err_rec&nbsp;</font></div><div><font size="2"   >-------------------</font></div><div><font size="2"   >&nbsp;t</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=&gt; select deal_sync_err_rec(dst_server,dst_query,id) from&nbsp;</font></div><div><font size="2"   >(select dst_server,dst_query,id from sync_err_rec order by create_time limit 1) t;</font></div><div><font size="2"   >&nbsp;deal_sync_err_rec&nbsp;</font></div><div><font size="2"   >-------------------</font></div><div><font size="2"   >(0 rows)</font></div><p></p></pre></div></div><div>查看修复后的目标站点数据 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select * from rmt_test ;</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; create_time &nbsp; &nbsp; | &nbsp; &nbsp; modify_time &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+--------+---------------------+---------------------</font></div><div><font size="2"   >&nbsp; 2 | DIGOAL | 2012-08-31 15:40:29 | 2012-08-31 15:40:29</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>与源站数据一致.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select * from loc_test ;</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; create_time &nbsp; &nbsp; | &nbsp; &nbsp; modify_time &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+--------+---------------------+---------------------</font></div><div><font size="2"   >&nbsp; 2 | DIGOAL | 2012-08-31 15:40:29 | 2012-08-31 15:40:29</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div>【小结】</div><div>1. 本文所举的例子都是一对一的复制, 如果要实现一对多个目标站点, 只要增加触发器即可. 本文不再举例.</div><div>如 :&nbsp;</div><div>新增触发器函数 :</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE OR REPLACE FUNCTION f_sync_loc_test1()</font></div><div><font size="2"   >略去内容....</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$BODY$;</font></div><p></p></pre></div><div>新增触发器 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE TRIGGER loc_test_sync_dml1 AFTER DELETE or UPDATE or INSERT ON loc_test FOR EACH ROW EXECUTE PROCEDURE f_sync_loc_test1();</font></div><div><font size="2"   >CREATE TRIGGER loc_test_sync_truncate1 AFTER TRUNCATE ON loc_test FOR EACH STATEMENT EXECUTE PROCEDURE f_sync_loc_test1();</font></div><p></p></pre></div><div>2. CREATE SERVER里面用到的option来自如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >src/backend/tcop/postgres.c</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Parse command-line options. &nbsp;CAUTION: keep this in sync with</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* postmaster/postmaster.c (the option sets should not conflict) and with</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the common help() function in main/main.c.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres --help</font></div><div><font size="2"   >-c NAME=VALUE &nbsp; &nbsp; &nbsp;set run-time parameter</font></div><p></p></pre></div><div>3. 初始化操作(原始数据同步)需要避免有其他会话修改源表. 可以考虑使用 lock table in exclusive mode ;</div><div><br></div><div>4. 如果要针对列或者行级别的过滤, 只需要调整触发器即可.</div><div><br></div><div>5. 触发器函数参数传递不是通过普通的函数参数传递, 而是通过以下数据结构.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >src/include/commands/trigger.h&nbsp;</font></div><div><font size="2"   >typedef struct TriggerData</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; NodeTag &nbsp; &nbsp; &nbsp; &nbsp; type;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TriggerEvent tg_event;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Relation &nbsp; &nbsp; &nbsp; &nbsp;tg_relation;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple &nbsp; &nbsp; &nbsp; tg_trigtuple;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple &nbsp; &nbsp; &nbsp; tg_newtuple;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Trigger &nbsp; &nbsp;*tg_trigger;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Buffer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tg_trigtuplebuf;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Buffer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tg_newtuplebuf;</font></div><div><font size="2"   >} TriggerData;</font></div><p></p></pre></div><div><br></div><div>先写到这里, 下次再讲multi-master复制. 感兴趣的朋友也可以自己写一个玩玩.</div><div>也要利用<span style="line-height: 22px;"   >application_name.</span></div><div><span style="line-height: 22px;"   >下一篇讲(deal_sync_err_rec的优化以及multi master replication) :&nbsp;</span></div><wbr></div><a href="http://blog.163.com/digoal@126/blog/static/1638770402012731944439/"   >http://blog.163.com/digoal@126/blog/static/1638770402012731944439/</a><div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   >6. 最近由于项目组需求, 开发了一个可以用作多表使用的通用触发器函数如下 :&nbsp;</div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201321125220134/"   >http://blog.163.com/digoal@126/blog/static/163877040201321125220134/</a></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >值请使用quote_literal来解析, 本文的例子中OLD,NEW暂未修改, 请使用时自行修改或参考上文.</span></div><div><br></div><div>【注意】</div><div>1. 本文前面所写触发器存在严重漏洞, 当数据复制遇到错误时, 将记录到错误表, 后续正常的数据可远程执行, 从而导致错误数据和正常数据在本地执行顺序和远端执行顺序不一致.</div><div>解决办法请参见下一篇BLOG末尾部分. (一旦遇到错误, 则后续的操作不再直接提交到远端, 而是统统记录到错误表)</div><div><a style="line-height: 22px; " href="http://blog.163.com/digoal@126/blog/static/1638770402012731944439/"   >http://blog.163.com/digoal@126/blog/static/1638770402012731944439/</a> </div><br><div>2. pg_user_mappings回收public权限后, 使用普通用户执行pg_dump可能会报错:</div><div>需要使用超级用户执行pg_dump .</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg_dump -F p -f ./1.sql -t loc_test -h 127.0.0.1 -U local local</font></div><div><font size="2"   >pg_dump: SQL command failed</font></div><div><font size="2"   >pg_dump: Error message from server: ERROR: &nbsp;permission denied for relation pg_user_mappings</font></div><div><font size="2"   >pg_dump: The command was: SELECT usename, array_to_string(ARRAY(SELECT option_name || ' ' || quote_literal(option_value) FROM pg_options_to_table(umoptions)), ', ') AS umoptions</font></div><div><font size="2"   >FROM pg_user_mappings WHERE srvid = 164409694</font></div><p></p></pre></div></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="table level replication use trigger -- one(rw) to many(ro|rw) - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>