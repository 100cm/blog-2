<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">fork and page sharing</h2>
	<h5 id="">2012-08-15 15:09:08&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201271514638648/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">使用fork()创建子进程, 主进程的内存空间里面的内容当时的值应该是子进程未来能见到的值, 不会因为主进程的改变而改变。<div>换句话说, 子进程和主进程有各自的内存空间。<br><div>如果是全盘拷贝来实现的话, 显然代价是很大的, 通常系统会使用cow(COPY ON WRITE)的机制来降低fork的开销.</div><div>cow :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >When a fork() system call is issued, a copy of all the pages corresponding to the parent process is created, loaded into a separate memory location by the OS for the child process. But this is not needed in certain cases. Consider the case when a child executes an "exec" system call (which is used to execute any executable file from within a C program) or exits very soon after the fork(). When the child is needed just to execute a command for the parent process, there is no need for copying the parent process' pages, since exec replaces the address space of the process which invoked it with the command to be executed.</font></div><div><font size="2"  >In such cases, a technique called copy-on-write (COW) is used. With this technique, when a fork occurs, the parent process's pages are not copied for the child process. Instead, the pages are shared between the child and the parent process. Whenever a process (parent or child) modifies a page, a separate copy of that particular page alone is made for that process (parent or child) which performed the modification. This process will then use the newly copied page rather than the shared one in all future references. The other process (the one which did not modify the shared page) continues to use the original copy of the page (which is now no longer shared). This technique is called copy-on-write since the page is copied when some process writes to it.</font></div><p></p></pre></div><div><br></div><div>例1 :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat a.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;time.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >typedef struct test {</font></div><div><font size="2"  >&nbsp; char text[9999999999];</font></div><div><font size="2"  >} test;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >long int i;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >char* now()</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; time_t t;</font></div><div><font size="2"  >&nbsp; time (&amp;t);</font></div><div><font size="2"  >&nbsp; return asctime(localtime (&amp;t));</font></div><div><font size="2"  >}</font></div><div><font size="2"  >&nbsp;</font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; test * t1 = malloc(sizeof(test));</font></div><div><font size="2"  >&nbsp; t1-&gt;text[0] = 'h';</font></div><div><font size="2"  >&nbsp; t1-&gt;text[1] = 'e';</font></div><div><font size="2"  >&nbsp; t1-&gt;text[2] = 'l';</font></div><div><font size="2"  >&nbsp; t1-&gt;text[3] = 'l';</font></div><div><font size="2"  >&nbsp; t1-&gt;text[4] = 'o';</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "time:%s, this is master process, t1 inited. t1-&gt;text:%s\n", now(), t1-&gt;text);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+0:%p, *((t1-&gt;text)+0):%c\n", (t1-&gt;text)+0, *((t1-&gt;text)+0));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+1:%p, *((t1-&gt;text)+1):%c\n", (t1-&gt;text)+1, *((t1-&gt;text)+1));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+2:%p, *((t1-&gt;text)+2):%c\n", (t1-&gt;text)+2, *((t1-&gt;text)+2));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+3:%p, *((t1-&gt;text)+3):%c\n", (t1-&gt;text)+3, *((t1-&gt;text)+3));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+4:%p, *((t1-&gt;text)+4):%c\n", (t1-&gt;text)+4, *((t1-&gt;text)+4));</font></div><div><font size="2"  >&nbsp; for(i=6;i&lt;9999999999;i++) {</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[i]='m';</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "time:%s, this is master process, t1 filled 10G 'm' data, t1-&gt;text:%s\n", now(), t1-&gt;text);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+5:%p, *((t1-&gt;text)+5):%c\n", (t1-&gt;text)+5, *((t1-&gt;text)+5));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+6:%p, *((t1-&gt;text)+6):%c\n", (t1-&gt;text)+6, *((t1-&gt;text)+6));</font></div><div><font size="2"  >&nbsp; pid_t pid = fork();</font></div><div><font size="2"  >&nbsp; if (pid == -1) {</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "error: %s\n", strerror(errno));</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; if (!pid) {</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "time:%s, this is child process, now t1 not modified, t1-&gt;text:%s\n", now(), t1-&gt;text);</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+0:%p, *((t1-&gt;text)+0):%c\n", (t1-&gt;text)+0, *((t1-&gt;text)+0));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+1:%p, *((t1-&gt;text)+1):%c\n", (t1-&gt;text)+1, *((t1-&gt;text)+1));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+2:%p, *((t1-&gt;text)+2):%c\n", (t1-&gt;text)+2, *((t1-&gt;text)+2));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+3:%p, *((t1-&gt;text)+3):%c\n", (t1-&gt;text)+3, *((t1-&gt;text)+3));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+4:%p, *((t1-&gt;text)+4):%c\n", (t1-&gt;text)+4, *((t1-&gt;text)+4));</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[0]='w';</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[1]='o';</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[2]='r';</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[3]='l';</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[4]='d';</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "time:%s, this is child process, t1 [0-4] modified, but[5-6] not, t1-&gt;text:%s\n", now(), t1-&gt;text);</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+0:%p, *((t1-&gt;text)+0):%c\n", (t1-&gt;text)+0, *((t1-&gt;text)+0));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+1:%p, *((t1-&gt;text)+1):%c\n", (t1-&gt;text)+1, *((t1-&gt;text)+1));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+2:%p, *((t1-&gt;text)+2):%c\n", (t1-&gt;text)+2, *((t1-&gt;text)+2));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+3:%p, *((t1-&gt;text)+3):%c\n", (t1-&gt;text)+3, *((t1-&gt;text)+3));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+4:%p, *((t1-&gt;text)+4):%c\n", (t1-&gt;text)+4, *((t1-&gt;text)+4));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+5:%p, *((t1-&gt;text)+5):%c\n", (t1-&gt;text)+5, *((t1-&gt;text)+5));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+6:%p, *((t1-&gt;text)+6):%c\n", (t1-&gt;text)+6, *((t1-&gt;text)+6));</font></div><div><font size="2"  >&nbsp; &nbsp; //free(t1);</font></div><div><font size="2"  >&nbsp; &nbsp; sleep(10);</font></div><div><font size="2"  >&nbsp; &nbsp; return 0;</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "time:%s, this is master process, t1.text:%s\n", now(), t1-&gt;text);</font></div><div><font size="2"  >&nbsp; //free(t1);</font></div><div><font size="2"  >&nbsp; sleep(20);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+0:%p, *((t1-&gt;text)+0):%c\n", (t1-&gt;text)+0, *((t1-&gt;text)+0));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+1:%p, *((t1-&gt;text)+1):%c\n", (t1-&gt;text)+1, *((t1-&gt;text)+1));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+2:%p, *((t1-&gt;text)+2):%c\n", (t1-&gt;text)+2, *((t1-&gt;text)+2));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+3:%p, *((t1-&gt;text)+3):%c\n", (t1-&gt;text)+3, *((t1-&gt;text)+3));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+4:%p, *((t1-&gt;text)+4):%c\n", (t1-&gt;text)+4, *((t1-&gt;text)+4));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+5:%p, *((t1-&gt;text)+5):%c\n", (t1-&gt;text)+5, *((t1-&gt;text)+5));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+6:%p, *((t1-&gt;text)+6):%c\n", (t1-&gt;text)+6, *((t1-&gt;text)+6));</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>结果 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o abcde &amp;&amp; ./abcde</font></div><div><font size="2"  >time:Wed Aug 15 14:20:53 2012</font></div><div><font size="2"  >, this is master process, t1 inited. t1-&gt;text:hello</font></div><div><font size="2"  >this master process, (t1-&gt;text)+0:0x2b1f68a7b010, *((t1-&gt;text)+0):h</font></div><div><font size="2"  >this master process, (t1-&gt;text)+1:0x2b1f68a7b011, *((t1-&gt;text)+1):e</font></div><div><font size="2"  >this master process, (t1-&gt;text)+2:0x2b1f68a7b012, *((t1-&gt;text)+2):l</font></div><div><font size="2"  >this master process, (t1-&gt;text)+3:0x2b1f68a7b013, *((t1-&gt;text)+3):l</font></div><div><font size="2"  >this master process, (t1-&gt;text)+4:0x2b1f68a7b014, *((t1-&gt;text)+4):o</font></div><div><font size="2"  >time:Wed Aug 15 14:21:13 2012</font></div><div><font size="2"  >, this is master process, t1 filled 10G 'm' data, t1-&gt;text:hello</font></div><div><font size="2"  >this master process, (t1-&gt;text)+5:0x2b1f68a7b015, *((t1-&gt;text)+5):</font></div><div><font size="2"  >this master process, (t1-&gt;text)+6:0x2b1f68a7b016, *((t1-&gt;text)+6):m</font></div><div><font size="2"  >time:Wed Aug 15 14:21:13 2012</font></div><div><font size="2"  >, this is child process, now t1 not modified, t1-&gt;text:hello</font></div><div><font size="2"  >this child process, (t1-&gt;text)+0:0x2b1f68a7b010, *((t1-&gt;text)+0):h</font></div><div><font size="2"  >this child process, (t1-&gt;text)+1:0x2b1f68a7b011, *((t1-&gt;text)+1):e</font></div><div><font size="2"  >this child process, (t1-&gt;text)+2:0x2b1f68a7b012, *((t1-&gt;text)+2):l</font></div><div><font size="2"  >this child process, (t1-&gt;text)+3:0x2b1f68a7b013, *((t1-&gt;text)+3):l</font></div><div><font size="2"  >this child process, (t1-&gt;text)+4:0x2b1f68a7b014, *((t1-&gt;text)+4):o</font></div><div><font size="2"  >time:Wed Aug 15 14:21:13 2012</font></div><div><font size="2"  >, this is child process, t1 [0-4] modified, but[5-6] not, t1-&gt;text:world</font></div><div><font size="2"  >this child process, (t1-&gt;text)+0:0x2b1f68a7b010, *((t1-&gt;text)+0):w</font></div><div><font size="2"  >this child process, (t1-&gt;text)+1:0x2b1f68a7b011, *((t1-&gt;text)+1):o</font></div><div><font size="2"  >this child process, (t1-&gt;text)+2:0x2b1f68a7b012, *((t1-&gt;text)+2):r</font></div><div><font size="2"  >this child process, (t1-&gt;text)+3:0x2b1f68a7b013, *((t1-&gt;text)+3):l</font></div><div><font size="2"  >this child process, (t1-&gt;text)+4:0x2b1f68a7b014, *((t1-&gt;text)+4):d</font></div><div><font size="2"  >this child process, (t1-&gt;text)+5:0x2b1f68a7b015, *((t1-&gt;text)+5):</font></div><div><font size="2"  >this child process, (t1-&gt;text)+6:0x2b1f68a7b016, *((t1-&gt;text)+6):m</font></div><div><font size="2"  >time:Wed Aug 15 14:21:13 2012</font></div><div><font size="2"  >, this is master process, t1.text:hello</font></div><div><font size="2"  >this master process, (t1-&gt;text)+0:0x2b1f68a7b010, *((t1-&gt;text)+0):h</font></div><div><font size="2"  >this master process, (t1-&gt;text)+1:0x2b1f68a7b011, *((t1-&gt;text)+1):e</font></div><div><font size="2"  >this master process, (t1-&gt;text)+2:0x2b1f68a7b012, *((t1-&gt;text)+2):l</font></div><div><font size="2"  >this master process, (t1-&gt;text)+3:0x2b1f68a7b013, *((t1-&gt;text)+3):l</font></div><div><font size="2"  >this master process, (t1-&gt;text)+4:0x2b1f68a7b014, *((t1-&gt;text)+4):o</font></div><div><font size="2"  >this master process, (t1-&gt;text)+5:0x2b1f68a7b015, *((t1-&gt;text)+5):</font></div><div><font size="2"  >this master process, (t1-&gt;text)+6:0x2b1f68a7b016, *((t1-&gt;text)+6):m</font></div><p></p></pre></div></div><div><br></div><div>本例观察父进程和子进程的heap内存区域的共享是否与cow有关.</div><div>从时间差来看, 写10GB数据耗费20秒, fork()进程则花了0秒. 显然拷贝10GB数据不可能只要0秒.&nbsp;</div><div>从ps的输出来看, 子进程的rss瞬间达到10G, 显然不是慢慢拷贝而来.&nbsp;<span style="line-height: 22px;"  >所以COW成立.&nbsp;</span></div><div>但是这里有个非常怪异的问题, 父进程存储t1的内存区域地址和子进程的一致, 如果是COW的话, 子进程在修改t1-&gt;test[0]到t1-&gt;test[4]后, 子进程看到的t1-&gt;test[0]到t1-&gt;test[4]的存储地址应该会变. 它应该将这些内存区域拷贝到另一个地方去了.</div><div>为什么地址还是<span style="line-height: 22px;"  >0x2b1f68a7b010 -&nbsp;</span><span style="line-height: 22px;"  >0x2b1f68a7b014呢?</span></div><div><span style="line-height: 22px;"  >这个可以参考</span><a rel="nofollow" href="http://en.wikipedia.org/wiki/Virtual_memory"  >http://en.wikipedia.org/wiki/Virtual_memory</a></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >In computing, virtual memory is a memory management technique developed for multitasking kernels. This technique virtualizes a computer architecture's various forms of computer data storage (such as random-access memory and disk storage), allowing a program to be designed as though there is only one kind of memory, "virtual" memory, which behaves like directly addressable read/write memory (RAM).</font></div><div><font size="2"  >Most modern operating systems that support virtual memory also run each process in its own dedicated address space. Each program thus appears to have sole access to the virtual memory. However, some older operating systems (such as OS/VS1 and OS/VS2 SVS) and even modern ones (such as IBM i) are single address space operating systems that run all processes in a single address space composed of virtualized memory.</font></div><p></p></pre></div><div style="line-height: 22px;"  >看了就明白为什么了.</div></div><div><br></div><div>还有一个问题, stack区域的page sharing又是怎么样运作的呢?</div><div>把上面的代码稍微修改一下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; // test * t1 = malloc(sizeof(test));</font></div><div><font size="2"  >&nbsp; test t2;</font></div><div><font size="2"  >&nbsp; test * t1 = &amp;t2;</font></div><p></p></pre></div><div>修改stack限制,&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >&nbsp;[root@db-172-16-3-150 zzz]# ulimit -s 10240000</font></p></pre></div><div>重新编译执行, 结果</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o abcde &amp;&amp; ./abcde</font></div><div><font size="2"  >time:Wed Aug 15 14:50:09 2012</font></div><div><font size="2"  >, this is master process, t1 inited. t1-&gt;text:hello</font></div><div><font size="2"  >this master process, (t1-&gt;text)+0:0x7ffd38a24180, *((t1-&gt;text)+0):h</font></div><div><font size="2"  >this master process, (t1-&gt;text)+1:0x7ffd38a24181, *((t1-&gt;text)+1):e</font></div><div><font size="2"  >this master process, (t1-&gt;text)+2:0x7ffd38a24182, *((t1-&gt;text)+2):l</font></div><div><font size="2"  >this master process, (t1-&gt;text)+3:0x7ffd38a24183, *((t1-&gt;text)+3):l</font></div><div><font size="2"  >this master process, (t1-&gt;text)+4:0x7ffd38a24184, *((t1-&gt;text)+4):o</font></div><div><font size="2"  >time:Wed Aug 15 14:50:29 2012</font></div><div><font size="2"  >, this is master process, t1 filled 10G 'm' data, t1-&gt;text:hello</font></div><div><font size="2"  >this master process, (t1-&gt;text)+5:0x7ffd38a24185, *((t1-&gt;text)+5):</font></div><div><font size="2"  >this master process, (t1-&gt;text)+6:0x7ffd38a24186, *((t1-&gt;text)+6):m</font></div><div><font size="2"  >time:Wed Aug 15 14:50:29 2012</font></div><div><font size="2"  >, this is child process, now t1 not modified, t1-&gt;text:hello</font></div><div><font size="2"  >this child process, (t1-&gt;text)+0:0x7ffd38a24180, *((t1-&gt;text)+0):h</font></div><div><font size="2"  >this child process, (t1-&gt;text)+1:0x7ffd38a24181, *((t1-&gt;text)+1):e</font></div><div><font size="2"  >this child process, (t1-&gt;text)+2:0x7ffd38a24182, *((t1-&gt;text)+2):l</font></div><div><font size="2"  >this child process, (t1-&gt;text)+3:0x7ffd38a24183, *((t1-&gt;text)+3):l</font></div><div><font size="2"  >this child process, (t1-&gt;text)+4:0x7ffd38a24184, *((t1-&gt;text)+4):o</font></div><div><font size="2"  >time:Wed Aug 15 14:50:29 2012</font></div><div><font size="2"  >, this is child process, t1 [0-4] modified, but[5-6] not, t1-&gt;text:world</font></div><div><font size="2"  >this child process, (t1-&gt;text)+0:0x7ffd38a24180, *((t1-&gt;text)+0):w</font></div><div><font size="2"  >this child process, (t1-&gt;text)+1:0x7ffd38a24181, *((t1-&gt;text)+1):o</font></div><div><font size="2"  >this child process, (t1-&gt;text)+2:0x7ffd38a24182, *((t1-&gt;text)+2):r</font></div><div><font size="2"  >this child process, (t1-&gt;text)+3:0x7ffd38a24183, *((t1-&gt;text)+3):l</font></div><div><font size="2"  >this child process, (t1-&gt;text)+4:0x7ffd38a24184, *((t1-&gt;text)+4):d</font></div><div><font size="2"  >this child process, (t1-&gt;text)+5:0x7ffd38a24185, *((t1-&gt;text)+5):</font></div><div><font size="2"  >this child process, (t1-&gt;text)+6:0x7ffd38a24186, *((t1-&gt;text)+6):m</font></div><div><font size="2"  >time:Wed Aug 15 14:50:29 2012</font></div><div><font size="2"  >, this is master process, t1.text:hello</font></div><div><font size="2"  >this master process, (t1-&gt;text)+0:0x7ffd38a24180, *((t1-&gt;text)+0):h</font></div><div><font size="2"  >this master process, (t1-&gt;text)+1:0x7ffd38a24181, *((t1-&gt;text)+1):e</font></div><div><font size="2"  >this master process, (t1-&gt;text)+2:0x7ffd38a24182, *((t1-&gt;text)+2):l</font></div><div><font size="2"  >this master process, (t1-&gt;text)+3:0x7ffd38a24183, *((t1-&gt;text)+3):l</font></div><div><font size="2"  >this master process, (t1-&gt;text)+4:0x7ffd38a24184, *((t1-&gt;text)+4):o</font></div><div><font size="2"  >this master process, (t1-&gt;text)+5:0x7ffd38a24185, *((t1-&gt;text)+5):</font></div><div><font size="2"  >this master process, (t1-&gt;text)+6:0x7ffd38a24186, *((t1-&gt;text)+6):m</font></div><p></p></pre></div><div>从结果来看, 与heap一致. 也是COW机制.</div><div><br></div><div>即是COW, 那么当主进程比子进程先退出的话, 会怎么样呢? 主进程的内存stack区域与heap区域会不会释放掉呢?</div><div>如果释放掉, 势必会造成子进程无法访问共享的内存部分. 所以主进程退出并不会马上释放这些内存. 即使主进程主动free()了, 其实这个操作内核并不会马上释放这部分内存, 需要等所有reference到这块物理内存区域的进程都不存在后才会释放掉 .&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;time.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >typedef struct test {</font></div><div><font size="2"  >&nbsp; char text[9999999999];</font></div><div><font size="2"  >} test;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >long int i;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >char* now()</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; time_t t;</font></div><div><font size="2"  >&nbsp; time (&amp;t);</font></div><div><font size="2"  >&nbsp; return asctime(localtime (&amp;t));</font></div><div><font size="2"  >}</font></div><div><font size="2"  >&nbsp;</font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; test * t1 = malloc(sizeof(test));</font></div><div><font size="2"  >&nbsp; t1-&gt;text[0] = 'h';</font></div><div><font size="2"  >&nbsp; t1-&gt;text[1] = 'e';</font></div><div><font size="2"  >&nbsp; t1-&gt;text[2] = 'l';</font></div><div><font size="2"  >&nbsp; t1-&gt;text[3] = 'l';</font></div><div><font size="2"  >&nbsp; t1-&gt;text[4] = 'o';</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "time:%s, this is master process, t1 inited. t1-&gt;text:%s\n", now(), t1-&gt;text);</font></div><div><font size="2"  >&nbsp; for(i=6;i&lt;9999999999;i++) {</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[i]='m';</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "time:%s, this is master process, t1 filled 10G 'm' data, t1-&gt;text:%s\n", now(), t1-&gt;text);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+5:%p, *((t1-&gt;text)+5):%c\n", (t1-&gt;text)+5, *((t1-&gt;text)+5));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+6:%p, *((t1-&gt;text)+6):%c\n", (t1-&gt;text)+6, *((t1-&gt;text)+6));</font></div><div><font size="2"  >&nbsp; pid_t pid = fork();</font></div><div><font size="2"  >&nbsp; if (pid == -1) {</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "error: %s\n", strerror(errno));</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; if (!pid) {</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "time:%s, this is child process, now t1 not modified, t1-&gt;text:%s\n", now(), t1-&gt;text);</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[0]='w';</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[1]='o';</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[2]='r';</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[3]='l';</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[4]='d';</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "time:%s, this is child process, t1 [0-4] modified, but[5-6] not, t1-&gt;text:%s\n", now(), t1-&gt;text);</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+5:%p, *((t1-&gt;text)+5):%c\n", (t1-&gt;text)+5, *((t1-&gt;text)+5));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+6:%p, *((t1-&gt;text)+6):%c\n", (t1-&gt;text)+6, *((t1-&gt;text)+6));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+9999999998:%p, *((t1-&gt;text)+9999999998):%c\n", (t1-&gt;text)+9999999998, *((t1-&gt;text)+9999999998));</font></div><div><font size="2"  >&nbsp; &nbsp; //free(t1);</font></div><div><font size="2"  >&nbsp; &nbsp; sleep(10);</font></div><div><font size="2"  >&nbsp; &nbsp; // after 10 second, parent free the heap.</font></div><div><font size="2"  >&nbsp; &nbsp; // 如果主进程已经free掉了t1的heap空间, 子进程应该只能看到被子进程modify的内存内容, 看不到未修改的部分, 因为已经free了.</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "time:%s, 10 second elapsed.", now());</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "time:%s, this is child process, t1 [0-4] modified, but[5-6] not, t1-&gt;text:%s\n", now(), t1-&gt;text);</font></div><div><font size="2"  >&nbsp; &nbsp; // 也就是这里应该看不到</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+9999999998:%p, *((t1-&gt;text)+9999999998):%c\n", (t1-&gt;text)+9999999998, *((t1-&gt;text)+9999999998));</font></div><div><font size="2"  >&nbsp; &nbsp; return 0;</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; // parent will wait a moment, and then free the t1 in heap memroy.</font></div><div><font size="2"  >&nbsp; sleep(5);</font></div><div><font size="2"  >&nbsp; free(t1);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "time:%s, parent had free(t1) called success.", now());</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>结果 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Werror -Wextra -g ./a.c -o abcd &amp;&amp; ./abcd</font></div><div><font size="2"  >time:Thu Aug 16 13:34:33 2012</font></div><div><font size="2"  >, this is master process, t1 inited. t1-&gt;text:hello</font></div><div><font size="2"  >time:Thu Aug 16 13:34:48 2012</font></div><div><font size="2"  >, this is master process, t1 filled 10G 'm' data, t1-&gt;text:hello</font></div><div><font size="2"  >this master process, (t1-&gt;text)+5:0x2b2aea2bc015, *((t1-&gt;text)+5):</font></div><div><font size="2"  >this master process, (t1-&gt;text)+6:0x2b2aea2bc016, *((t1-&gt;text)+6):m</font></div><div><font size="2"  >time:Thu Aug 16 13:34:48 2012</font></div><div><font size="2"  >, this is child process, now t1 not modified, t1-&gt;text:hello</font></div><div><font size="2"  >time:Thu Aug 16 13:34:48 2012</font></div><div><font size="2"  >, this is child process, t1 [0-4] modified, but[5-6] not, t1-&gt;text:world</font></div><div><font size="2"  >this child process, (t1-&gt;text)+5:0x2b2aea2bc015, *((t1-&gt;text)+5):</font></div><div><font size="2"  >this child process, (t1-&gt;text)+6:0x2b2aea2bc016, *((t1-&gt;text)+6):m</font></div><div><font size="2"  >this child process, (t1-&gt;text)+9999999998:0x2b2d3e37a40e, *((t1-&gt;text)+9999999998):m</font></div><div><font size="2"  >time:Thu Aug 16 13:34:53 2012</font></div><div><font size="2"  >, parent had free(t1) called success.</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]#&nbsp;</font></div><div><font size="2"  >[root@db-172-16-3-150 zzz]#&nbsp;</font></div><div><font size="2"  >time:Thu Aug 16 13:34:58 2012</font></div><div><font size="2"  >, 10 second elapsed.time:Thu Aug 16 13:34:58 2012</font></div><div><font size="2"  >, this is child process, t1 [0-4] modified, but[5-6] not, t1-&gt;text:world</font></div><div><font size="2"  >this child process, (t1-&gt;text)+9999999998:0x2b2d3e37a40e, *((t1-&gt;text)+9999999998):m</font></div><p></p></pre></div><div>即使t1被释放掉, 重新申请内存. 重新全部复写数据, 老的那部分内存亦将不会释放掉.&nbsp;</div><div>如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat a.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  >#include &lt;string.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;errno.h&gt;</font></div><div><font size="2"  >#include &lt;time.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >typedef struct test {</font></div><div><font size="2"  >&nbsp; char text[12999999999];</font></div><div><font size="2"  >} test;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >long int i;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >char* now()</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; time_t t;</font></div><div><font size="2"  >&nbsp; time (&amp;t);</font></div><div><font size="2"  >&nbsp; return asctime(localtime (&amp;t));</font></div><div><font size="2"  >}</font></div><div><font size="2"  >&nbsp;</font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; test * t1 = malloc(sizeof(test));</font></div><div><font size="2"  >&nbsp; t1-&gt;text[0] = 'h';</font></div><div><font size="2"  >&nbsp; t1-&gt;text[1] = 'e';</font></div><div><font size="2"  >&nbsp; t1-&gt;text[2] = 'l';</font></div><div><font size="2"  >&nbsp; t1-&gt;text[3] = 'l';</font></div><div><font size="2"  >&nbsp; t1-&gt;text[4] = 'o';</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this is master process, t1 inited. t1-&gt;text:%s, time:%s\n", t1-&gt;text, now());</font></div><div><font size="2"  >&nbsp; for(i=6;i&lt;12999999999;i++) {</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[i]='m';</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this is master process, t1 filled 19G 'm' data, t1-&gt;text:%s, time:%s\n", t1-&gt;text, now());</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+5:%p, *((t1-&gt;text)+5):%c\n", (t1-&gt;text)+5, *((t1-&gt;text)+5));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+6:%p, *((t1-&gt;text)+6):%c\n", (t1-&gt;text)+6, *((t1-&gt;text)+6));</font></div><div><font size="2"  >&nbsp; pid_t pid = fork();</font></div><div><font size="2"  >&nbsp; if (pid == -1) {</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "error: %s\n", strerror(errno));</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; if (!pid) {</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this is child process, now t1 not modified, t1-&gt;text:%s, time:%s\n", t1-&gt;text, now());</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[0]='w';</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[1]='o';</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[2]='r';</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[3]='l';</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[4]='d';</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this is child process, t1 [0-4] modified, but[5-6] not, t1-&gt;text:%s, time:%s\n", t1-&gt;text, now());</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+5:%p, *((t1-&gt;text)+5):%c\n", (t1-&gt;text)+5, *((t1-&gt;text)+5));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+6:%p, *((t1-&gt;text)+6):%c\n", (t1-&gt;text)+6, *((t1-&gt;text)+6));</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+12999999998:%p, *((t1-&gt;text)+12999999998):%c\n", (t1-&gt;text)+12999999998, *((t1-&gt;text)+12999999998));</font></div><div><font size="2"  >&nbsp; &nbsp; //free(t1);</font></div><div><font size="2"  >&nbsp; &nbsp; sleep(120);</font></div><div><font size="2"  >&nbsp; &nbsp; // after this sleep second, parent free the heap.</font></div><div><font size="2"  >&nbsp; &nbsp; // 如果主进程已经free掉了t1的heap空间, 子进程应该只能看到被子进程modify的内存内容, 看不到未修改的部分, 因为已经free了.</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "120 second elapsed. time:%s", now());</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this is child process, t1 [0-4] modified, but[5-6] not, t1-&gt;text:%s, time:%s\n", t1-&gt;text, now());</font></div><div><font size="2"  >&nbsp; &nbsp; // 也就是这里应该看不到</font></div><div><font size="2"  >&nbsp; &nbsp; fprintf(stdout, "this child process, (t1-&gt;text)+12999999998:%p, *((t1-&gt;text)+12999999998):%c\n", (t1-&gt;text)+12999999998, *((t1-&gt;text)+12999999998));</font></div><div><font size="2"  >&nbsp; &nbsp; return 0;</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; // parent will wait a moment, and then free the t1 in heap memroy.</font></div><div><font size="2"  >&nbsp; sleep(5);</font></div><div><font size="2"  >&nbsp; free(t1);</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "parent had free(t1) called success. time:%s", now());</font></div><div><font size="2"  >&nbsp; t1 = malloc(sizeof(test));</font></div><div><font size="2"  >&nbsp; for(i=0;i&lt;12999999999;i++) {</font></div><div><font size="2"  >&nbsp; &nbsp; t1-&gt;text[i]='x';</font></div><div><font size="2"  >&nbsp; }</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "parent had malloc(sizeof(test)) called success and filled all byte with 'x' success. time:%s", now());</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+0:%p, *((t1-&gt;text)+0):%c\n", (t1-&gt;text)+0, *((t1-&gt;text)+0));</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "this master process, (t1-&gt;text)+12999999998:%p, *((t1-&gt;text)+12999999998):%c\n", (t1-&gt;text)+12999999998, *((t1-&gt;text)+12999999998));</font></div><div><font size="2"  >&nbsp; sleep(150);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>结果 :&nbsp;</div><div><span style="line-height: 22px;"  >因为老的那个HEAP区域中的内存不能被使用.&nbsp;</span>如果你的内存不够, 那么复写的过程会用到SWAP, 变得很慢.&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Werror -Wextra -g ./a.c -o abcd &amp;&amp; ./abcd</font></div><div><font size="2"  >this is master process, t1 inited. t1-&gt;text:hello, time:Thu Aug 16 14:26:41 2012</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >this is master process, t1 filled 19G 'm' data, t1-&gt;text:hello, time:Thu Aug 16 14:27:00 2012</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >this master process, (t1-&gt;text)+5:0x2b01ec396015, *((t1-&gt;text)+5):</font></div><div><font size="2"  >this master process, (t1-&gt;text)+6:0x2b01ec396016, *((t1-&gt;text)+6):m</font></div><div><font size="2"  >this is child process, now t1 not modified, t1-&gt;text:hello, time:Thu Aug 16 14:27:00 2012</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >this is child process, t1 [0-4] modified, but[5-6] not, t1-&gt;text:world, time:Thu Aug 16 14:27:00 2012</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >this child process, (t1-&gt;text)+5:0x2b01ec396015, *((t1-&gt;text)+5):</font></div><div><font size="2"  >this child process, (t1-&gt;text)+6:0x2b01ec396016, *((t1-&gt;text)+6):m</font></div><div><font size="2"  >this child process, (t1-&gt;text)+12999999998:0x2b04f315a20e, *((t1-&gt;text)+12999999998):m</font></div><div><font size="2"  >parent had free(t1) called success. time:Thu Aug 16 14:27:06 2012</font></div><div><font size="2"  >parent had malloc(sizeof(test)) called success and filled all byte with 'x' success. time:Thu Aug 16 14:28:43 2012</font></div><div><font size="2"  >this master process, (t1-&gt;text)+0:0x2b01ec396010, *((t1-&gt;text)+0):x</font></div><div><font size="2"  >this master process, (t1-&gt;text)+12999999998:0x2b04f315a20e, *((t1-&gt;text)+12999999998):x</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >120 second elapsed. time:Thu Aug 16 14:29:00 2012</font></div><div><font size="2"  >this is child process, t1 [0-4] modified, but[5-6] not, t1-&gt;text:world, time:Thu Aug 16 14:29:00 2012</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >this child process, (t1-&gt;text)+12999999998:0x2b04f315a20e, *((t1-&gt;text)+12999999998):m</font></div><p></p></pre></div><div>// 注意看, 子进程看到的值都正常. 没有因为主进程free了这块heap区域而丢失数据, 并且主进程重新malloc()并且复写的数据也不是原来那块物理内存空间, 而是新的物理内存空间.</div><div>// 另外值得注意的是, 父进程在重新malloc()内存后, 虚拟内存的位置和原来居然是一样的(t1-&gt;text)+12999999998:0x2b04f315a20e. 但是显然映射到的物理内存是不一样的区域.</div><div>虚拟内存和物理内存借用网上一张图 :&nbsp;</div><div><div><img title="fork and page sharing - 德哥@Digoal - The Heart,The World."  alt="fork and page sharing - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img9.ph.126.net/AsBHCT2ezT6IZmIaZKyqfg==/6597232494378023369.gif"  ></div>&nbsp;</div><div><br></div><div>【参考】</div><div><a rel="nofollow" href="http://en.wikipedia.org/wiki/Fork_(operating_system)"  >http://en.wikipedia.org/wiki/Fork_(operating_system)</a> </div><div><a rel="nofollow" href="http://en.wikipedia.org/wiki/Virtual_memory"  >http://en.wikipedia.org/wiki/Virtual_memory</a>&nbsp;</div><div><a rel="nofollow" href="http://en.wikipedia.org/wiki/Memory_address"  >http://en.wikipedia.org/wiki/Memory_address</a> </div><div><br><wbr></div></div></div>
	</div>
</div>
</body>
</html>