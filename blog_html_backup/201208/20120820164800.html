<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">use setitimer raise signal interval-granuated by seconds and microseconds</h2>
	<h5 id="">2012-08-20 16:48:00&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201272041953707/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>在程序中如果要设置定时器, 简单的可以使用sleep, alarm. 他们的时间单位都是秒.</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;alarm - set an alarm clock for delivery of a signal</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;unistd.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;unsigned int alarm(unsigned int seconds);</font></div></div><div><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;sleep - Sleep for the specified number of seconds</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;unistd.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;unsigned int sleep(unsigned int seconds);</font></div></div><p></p></pre></div><div>如果要设置更细的时间间隔, 需要使用setitimer, 下面举个例子 :</div><div>程序间隔0秒1000微秒后触发SIGALRM信号.&nbsp;</div><div><div><pre class="prettyprint"  ><div><div><font size="2"  >[root@db-172-16-3-150 zzz]# cat d.c</font></div><div><font size="2"  >#include &lt;stdio.h&gt;</font></div><div><font size="2"  >#include &lt;signal.h&gt;</font></div><div><font size="2"  >#include &lt;sys/time.h&gt;</font></div><div><font size="2"  >#include &lt;unistd.h&gt;</font></div><div><font size="2"  >#include &lt;stdlib.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >// 自定义handler函数.</font></div><div><font size="2"  >void timeout (int sig) {</font></div><div><font size="2"  >&nbsp; fprintf(stdout, "sig:%i, time is up.\n", sig);</font></div><div><font size="2"  >&nbsp; exit(1);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >int main() {</font></div><div><font size="2"  >&nbsp; // 准备修改SIGALRM信号的处理函数</font></div><div><font size="2"  >&nbsp; struct sigaction action;</font></div><div><font size="2"  >&nbsp; action.sa_handler = timeout;</font></div><div><font size="2"  >&nbsp; sigemptyset(&amp;action.sa_mask);</font></div><div><font size="2"  >&nbsp; action.sa_flags=0;</font></div><div><font size="2"  >&nbsp; sigaction(SIGALRM, &amp;action, NULL);</font></div><div><font size="2"  >&nbsp; // 0秒, 0微秒</font></div><div><div><font size="2"  >&nbsp; struct timeval timeout_t1 = {0, 0};</font></div><div><font size="2"  >&nbsp; // 1秒, 1000微秒</font></div><div><font size="2"  >&nbsp; struct timeval timeout_t2 = {1, 1000};</font></div><div><font size="2"  ><span style="line-height: 22px;"  >&nbsp; // 设置时间间隔</span> </font></div><div><font size="2"  >&nbsp; struct itimerval timeout_it;</font></div><div><font size="2"  >&nbsp; // 设置next value</font></div><div><font size="2"  >&nbsp; timeout_it.it_interval = timeout_t1;</font></div><div><font size="2"  >&nbsp; // 设置current value, The element it_value is set to the amount of time remaining on the timer, or zero if the timer is disabled.</font></div><div><font size="2"  >&nbsp; // Timers decrement from it_value to zero, generate a signal, and reset to it_interval. &nbsp;</font></div><div><font size="2"  >&nbsp; // A timer which is &nbsp;set &nbsp;to zero (it_value is zero or the timer expires and it_interval is zero) stops.</font></div><div><font size="2"  >&nbsp; timeout_it.it_value = timeout_t2;</font></div></div><div><font size="2"  >&nbsp; // 配置计时器,&nbsp;</font></div><div><font size="2"  >&nbsp; setitimer(ITIMER_REAL, &amp;timeout_it, NULL);</font></div><div><font size="2"  >&nbsp; // 模拟等待100秒, 当1秒1000微秒到达后, 将触发SIGALRM信号, 调用<span style="line-height: 22px;"  >timeout函数. 退出.</span></font></div><div><span style="line-height: 22px;"  ><font size="2"  >&nbsp; // 所以程序不会sleep 100秒.</font></span></div><div><font size="2"  >&nbsp; sleep(100);</font></div><div><font size="2"  >&nbsp; return 0;</font></div><div><font size="2"  >}</font></div></div><div></div><p></p></pre></div></div><div><br></div>【参考】<div>1. man 7 time</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >TIME(7) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Linux Programmer’s Manual &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIME(7)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;time - overview of time</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp;Real time and process time</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Real &nbsp;time is defined as time measured from some fixed point, either from a standard point in the past (see the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;description of the Epoch and calendar time below), or from some point (e.g., the start) in the life of &nbsp;a &nbsp;pro-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;cess (elapsed time).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Process &nbsp;time &nbsp;is defined as the amount of CPU time used by a process. &nbsp;This is sometimes divided into user and</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;system components. &nbsp;User CPU time is the time spent executing code in user mode. &nbsp;System CPU time is &nbsp;the &nbsp;time</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;spent &nbsp;by &nbsp;the &nbsp;kernel &nbsp;executing &nbsp;in system mode on behalf of the process (e.g., executing system calls). &nbsp;The</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;time(1) command can be used to determine the amount of CPU time consumed during the execution of a program. &nbsp; A</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;program can determine the amount of CPU time it has consumed using times(2), getrusage(2), or clock(3).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp;The Hardware Clock</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Most computers have a (battery-powered) hardware clock which the kernel reads at boot time in order to initial-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;ize the software clock. &nbsp;For further details, see rtc(4) and hwclock(8).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp;The Software Clock, HZ, and Jiffies</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The accuracy of many system calls and timestamps is limited by the resolution of the software &nbsp;clock, &nbsp;a &nbsp;clock</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;maintained by the kernel which measures time in jiffies. &nbsp;The size of a jiffy is determined by the value of the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;kernel constant HZ. &nbsp;The value of HZ varies across kernel versions and hardware platforms. &nbsp;On x86 &nbsp;the &nbsp;situa-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;tion &nbsp;is &nbsp;as &nbsp;follows: &nbsp;on kernels up to and including 2.4.x, HZ was 100, giving a jiffy value of 0.01 seconds;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;starting with 2.6.0, HZ was raised to 1000, giving a jiffy of 0.001 seconds; since kernel 2.6.13, the HZ &nbsp;value</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;is &nbsp;a &nbsp;kernel &nbsp;configuration &nbsp;parameter and can be 100, 250 (the default) or 1000, yielding a jiffies value of,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;respectively, 0.01, 0.004, or 0.001 seconds.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp;The Epoch</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Unix systems represent time in seconds since the Epoch, which is defined as 0:00:00 UTC on &nbsp;the &nbsp;morning &nbsp;of &nbsp;1</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;January 1970.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;A &nbsp;program &nbsp;can determine the calendar time using gettimeofday(2), which returns time (in seconds and microsec-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;onds) that have elapsed since the Epoch; time(2) provides similar information, but only with &nbsp;accuracy &nbsp;to &nbsp;the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;nearest second. &nbsp;The system time can be changed using settimeofday(2).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp;Broken-down time</font></div></div><div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Certain &nbsp;library &nbsp;functions &nbsp;use &nbsp;a structure of type tm to represent broken-down time, which stores time value</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;separated out into distinct components (year, month, day, hour, &nbsp;minute, &nbsp;second, &nbsp;etc.). &nbsp; This &nbsp;structure &nbsp;is</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;described &nbsp;in ctime(3), which also describes functions that convert between calendar time and broken-down time.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Functions for converting between broken-down &nbsp;time &nbsp;and &nbsp;printable &nbsp;string &nbsp;representations &nbsp;of &nbsp;the &nbsp;time &nbsp;are</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;described in ctime(3), strftime(3), and strptime(3).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp;Sleeping and Setting Timers</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Various system calls and functions allow a program to sleep (suspend execution) for a specified period of time;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;see nanosleep(2) and sleep(3).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Various system calls allow a process to set a timer that expires at some point in the future, and optionally at</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;repeated intervals; see alarm(2), getitimer(2), and timer_create(3).</font></div></div><p></p></pre></div><div>2. man setitimer</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >GETITIMER(2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Linux Programmer’s Manual &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GETITIMER(2)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;getitimer, setitimer - get or set value of an interval timer</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;sys/time.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int getitimer(int which, struct itimerval *value);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int setitimer(int which, const struct itimerval *value,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;struct itimerval *ovalue);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The system provides each process with three interval timers, each decrementing in a distinct time domain. &nbsp;When</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;any timer expires, a signal is sent to the process, and the timer (potentially) restarts.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;ITIMER_REAL &nbsp; &nbsp;decrements in real time, and delivers SIGALRM upon expiration.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;ITIMER_VIRTUAL decrements only when the process is executing, and delivers SIGVTALRM upon expiration.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;ITIMER_PROF &nbsp; &nbsp;decrements both when the process executes and when the system is executing on behalf of the pro-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cess. &nbsp; Coupled with ITIMER_VIRTUAL, this timer is usually used to profile the time spent by the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; application in user and kernel space. &nbsp;SIGPROF is delivered upon expiration.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Timer values are defined by the following structures:</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct itimerval {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct timeval it_interval; /* next value */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct timeval it_value; &nbsp; &nbsp;/* current value */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct timeval {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; long tv_sec; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* seconds */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; long tv_usec; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* microseconds */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The function getitimer() fills the structure indicated by value with the current setting for &nbsp;the &nbsp;timer &nbsp;indi-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;cated by which (one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF). &nbsp;The element it_value is set to the amount</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;of time remaining on the timer, or zero if the timer is disabled. &nbsp;Similarly, it_interval is set to &nbsp;the &nbsp;reset</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;value. &nbsp; The &nbsp;function &nbsp;setitimer() sets the indicated timer to the value in value. &nbsp;If ovalue is non-zero, the</font></div></div><div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;old value of the timer is stored there.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Timers decrement from it_value to zero, generate a signal, and reset to it_interval. &nbsp;A timer which is &nbsp;set &nbsp;to</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;zero (it_value is zero or the timer expires and it_interval is zero) stops.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Both tv_sec and tv_usec are significant in determining the duration of a timer.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Timers &nbsp;will never expire before the requested time, but may expire some (short) time afterwards, which depends</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;on the system timer resolution and on the system load. &nbsp;(But see BUGS below.) &nbsp;Upon expiration, a &nbsp;signal &nbsp;will</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;be &nbsp;generated &nbsp;and &nbsp;the &nbsp;timer &nbsp;reset. &nbsp; If &nbsp;the &nbsp;timer &nbsp;expires &nbsp;while &nbsp;the process is active (always true for</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;ITIMER_VIRTUAL) the signal will be delivered immediately when generated. &nbsp;Otherwise the delivery will be offset</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;by a small time dependent on the system loading.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >RETURN VALUE</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;On success, zero is returned. &nbsp;On error, -1 is returned, and errno is set appropriately.</font></div></div><p></p></pre></div><div>3. man alarm</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >ALARM(2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Linux Programmer’s Manual &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ALARM(2)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;alarm - set an alarm clock for delivery of a signal</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;unistd.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;unsigned int alarm(unsigned int seconds);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;alarm() arranges for a SIGALRM signal to be delivered to the process in seconds seconds.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;If seconds is zero, no new alarm() is scheduled.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;In any event any previously set alarm() is cancelled.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >RETURN VALUE</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;alarm() &nbsp;returns &nbsp;the number of seconds remaining until any previously scheduled alarm was due to be delivered,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;or zero if there was no previously scheduled alarm.</font></div><p></p></pre></div><div>4. man sigaction</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >SIGACTION(2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Linux Programmer’s Manual &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SIGACTION(2)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >NAME</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;sigaction - examine and change a signal action</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SYNOPSIS</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;signal.h&gt;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >DESCRIPTION</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The sigaction() system call is used to change the action taken by a process on receipt of a specific signal.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;signum specifies the signal and can be any valid signal except SIGKILL and SIGSTOP.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;If &nbsp;act is non-null, the new action for signal signum is installed from act. &nbsp;If oldact is non-null, the previ-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;ous action is saved in oldact.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The sigaction structure is defined as something like</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct sigaction {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; void (*sa_handler)(int);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; void (*sa_sigaction)(int, siginfo_t *, void *);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sigset_t sa_mask;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int sa_flags;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; void (*sa_restorer)(void);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;On some architectures a union is involved: do not assign to both sa_handler and sa_sigaction.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The sa_restorer element is obsolete and should not be used. &nbsp;POSIX does not specify a sa_restorer element.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;sa_handler specifies the action to be associated with signum and may be SIG_DFL for the default action, SIG_IGN</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;to ignore this signal, or a pointer to a signal handling function. &nbsp;This function receives the signal number as</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;its only argument.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;If SA_SIGINFO is specified in sa_flags, then sa_sigaction (instead of sa_handler) specifies the signal-handling</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;function &nbsp;for signum. &nbsp;This function receives the signal number as its first argument, a pointer to a siginfo_t</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;as its second argument and a pointer to a ucontext_t (cast to void *) as its third argument.</font></div></div><div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;sa_mask gives a mask of signals which should be blocked during execution of the signal handler. &nbsp; In &nbsp;addition,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the signal which triggered the handler will be blocked, unless the SA_NODEFER flag is used.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;sa_flags &nbsp;specifies &nbsp;a &nbsp;set of flags which modify the behaviour of the signal handling process. It is formed by</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the bitwise OR of zero or more of the following:</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SA_NOCLDSTOP</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If signum is SIGCHLD, do not receive notification when child &nbsp;processes &nbsp;stop &nbsp;(i.e., &nbsp;when &nbsp;they</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;receive &nbsp;one of SIGSTOP, SIGTSTP, SIGTTIN or SIGTTOU) or resume (i.e., they receive SIGCONT) (see</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wait(2)).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SA_NOCLDWAIT</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(Linux 2.6 and later) If signum is SIGCHLD, do not transform children into zombies when they ter-</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;minate. &nbsp;See also waitpid(2).</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SA_RESETHAND</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Restore &nbsp;the &nbsp;signal &nbsp;action &nbsp;to &nbsp;the &nbsp;default &nbsp;state &nbsp;once &nbsp;the &nbsp;signal handler has been called.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SA_ONESHOT is an obsolete, non-standard synonym for this flag.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SA_ONSTACK</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Call the signal handler on an alternate signal stack provided by sigaltstack(2). &nbsp;If an alternate</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stack is not available, the default stack will be used.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SA_RESTART</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Provide behaviour compatible with BSD signal semantics by making certain system calls restartable</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;across signals.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SA_NODEFER</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Do not prevent the signal from being received from within its own signal handler. &nbsp; SA_NOMASK &nbsp;is</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;an obsolete, non-standard synonym for this flag.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SA_SIGINFO</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;The &nbsp;signal handler takes 3 arguments, not one. &nbsp;In this case, sa_sigaction should be set instead</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;of sa_handler. &nbsp;(The sa_sigaction field was added in Linux 2.1.86.)</font></div></div><p></p></pre></div><div><div><br></div><div>&nbsp; &nbsp; &nbsp;&nbsp;</div></div><div><br></div><div><br><wbr></div></div>
	</div>
</div>
</body>
</html>