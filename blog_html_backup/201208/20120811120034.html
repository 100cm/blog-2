<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory</h2>
	<h5 id="">2012-08-11 12:00:34&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201271195312138/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>本文测试环境 :&nbsp;</div><div>X86-64 bit 架构的服务器</div><div>CentOS x64 5.x</div><div>gcc version 4.1.2 20080704</div><div><br></div>指针和数组是C的比较难搞懂的知识点, 需要结合内存来学习, 非常感谢各位兄弟为我指点迷津.<div>下面总结一下 :&nbsp;</div><div>首先说明一下C程序在运行时, 不同的内容或变量分别存储在什么地方?</div><div>分了几块区域分别是, code, constants, global, heap, stack; （内存地址从低到高）</div><div>其中constants存储常量(常量值不允许修改), global存储在所有函数以外定义的全局变量(全局变量允许修改), heap是一块动态内存区域(可存放持久化内容, 不会自动释放内存), stack存放函数内的本地变量(函数执行完后本地变量占用的内存将自动释放); &nbsp;</div><div><br></div><div>如图 :&nbsp;</div><div><div><img title="char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory - 德哥@Digoal - The Heart,The World."   alt="char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory - 德哥@Digoal - The Heart,The World."   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/IBkHIcCZ_g5vGeks68Qcbg==/6597162125633603802.png"   ></div>接下来要介绍两个符号 * 和 &amp;.</div><div>1. * 用在定义变量类型, 或者 强制类型转换时, 表示要定义一个指针 或者 把这个变量类型转换成指针(并告知这个指针指向的是什么类型的数据) .</div><div>2. * 用在一个指针变量的前面, 表示这个指针指向地址存储的内容 (内容是什么类型的就取决于这个指针定义时：&nbsp;<span style="line-height: 22px;"   >告知这个指针指向的是什么类型的数据，指针的加减运算得到的内存地址也和指针</span><span style="line-height: 22px;"   >指向的是什么类型的数据相关，int * a，a+1 得到的地址则是在a指向的地址基础上加4字节.</span>).</div><div>3. &amp; 用在变量名的前面, 表示这个变量所在的地址 .&nbsp;</div><div><br></div><div>例1 ：&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 zzz]# cat b.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char * a = "hello";</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "&amp;a:%p, a:%p, a:%s\n", &amp;a, a, a);</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果 :&nbsp;</font></div><div><font size="2"   >[root@db-172-16-3-33 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./b.c -o b &amp;&amp; ./b</font></div><div><font size="2"   >&amp;a:0x7fff71b22230, a:0x400618, a:hello</font></div><p></p></pre></div><div><br></div><div>&amp;a 表示a的地址 .&nbsp;</div><div>a 表示a存储的内容, 因为a是指针, 所以它的内容读取出来就是一个地址 .&nbsp;</div><div>*a 表示a指针存储的这个地址 存储的内容 .&nbsp;</div><div>在内存中的图示 :&nbsp;</div><div><div><img title="char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory - 德哥@Digoal - The Heart,The World."   alt="char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory - 德哥@Digoal - The Heart,The World."   style="margin:0 10px 0 0;"   src="http://img0.ph.126.net/EFmwL8_NCTtX0S4bYsQrpA==/3062447746629554240.jpg"   ></div>&nbsp;</div><div>这个图包含了几块内容 :&nbsp;</div><div>1. 在64位的系统中 , 指针占用了8个字节. 因为指针中存储的是地址, 而且地址是64位的. 所以需要8个字节.</div><div>2. 在x86架构的机器中, 内存填充是从低位到高位的. 所以hello在内存中是这样存储的 :&nbsp;</div><div>地址: &nbsp;内容</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >0x400618 : 0x68 &nbsp;(ascii : h)</font></div><div><font size="2"   ><span style="line-height: 22px;"   >0x400619 : 0x65 &nbsp;(ascii : e)</span> </font></div><div><font size="2"   ><span style="line-height: 22px;"   >0x40061a : 0x6c &nbsp;(ascii : l)</span> </font></div><div><font size="2"   ><span style="line-height: 22px;"   >0x40061b : 0x6c &nbsp;(ascii : l)</span> </font></div><div><font size="2"   ><span style="line-height: 22px;"   >0x40061c : 0x6f &nbsp; (ascii : o)</span> </font></div><div><span style="line-height: 22px;"   ><font size="2"   >0x40061d : 0x68 &nbsp;(ascii : NULL)</font></span></div><p></p></pre></div><div><br></div><div>3. 那怎么来证明以上是正确的呢? 很简单, 按照每个字节来打印就知道了.</div><div>这里需要注意的是指针的加减法得到的地址和指针指向的地址存储的内容的类型是有关的, 反过来说, 要让指针加1刚好得到的是下一个字节那就告诉编译器, 这个指针指向的地址的内容是char类型就好了, 因为sizeof(char) = 1字节.</div><div>先来打印一下hello是不是按照上面说的这样存储的?</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 zzz]# cat b.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char * a = "hello";</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "&amp;a:%p, a:%p, a:%s\n", &amp;a, a, a);</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "sizeof(char *):%lu, sizeof(char):%lu\n", sizeof(char *), sizeof(char));</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a+0:%p, *(a+0):%x, *(a+0):%c\n", a+0, *(a+0), *(a+0));</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a+1:%p, *(a+1):%x, *(a+1):%c\n", a+1, *(a+1), *(a+1));</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a+2:%p, *(a+2):%x, *(a+2):%c\n", a+2, *(a+2), *(a+2));</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a+3:%p, *(a+3):%x, *(a+3):%c\n", a+3, *(a+3), *(a+3));</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a+4:%p, *(a+4):%x, *(a+4):%c\n", a+4, *(a+4), *(a+4));</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a+5:%p, *(a+5):%x, *(a+5):%c\n", a+5, *(a+5), *(a+5));</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果 :&nbsp;</font></div><div><font size="2"   >[root@db-172-16-3-33 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./b.c -o b &amp;&amp; ./b</font></div><div><font size="2"   >&amp;a:0x7ffffe249680, a:0x4006f8, a:hello</font></div><div><font size="2"   >sizeof(char *):8, sizeof(char):1</font></div><div><font size="2"   >a+0:0x4006f8, *(a+0):68, *(a+0):h</font></div><div><font size="2"   >a+1:0x4006f9, *(a+1):65, *(a+1):e</font></div><div><font size="2"   >a+2:0x4006fa, *(a+2):6c, *(a+2):l</font></div><div><font size="2"   >a+3:0x4006fb, *(a+3):6c, *(a+3):l</font></div><div><font size="2"   >a+4:0x4006fc, *(a+4):6f, *(a+4):o</font></div><div><font size="2"   >a+5:0x4006fd, *(a+5):0, *(a+5):</font></div><p></p></pre></div><div>解说 :&nbsp;</div><div>&nbsp; a 是一个指针, 这个指针指向的内容是char类型的, 所以这个指针的加减运算a+1 表示地址加1字节.</div><div>&nbsp; *a 把你带到它指向的<span style="line-height: 22px;"   >0x4006f8, 而fprintf 以16进制和char输出的正是</span><span style="line-height: 22px;"   >0x4006f8这个地址的</span><span style="line-height: 22px;"   >这个字节上的内容(1字节刚好用两个16进制数表示, 刚好可以转成char)</span></div><div><span style="line-height: 22px;"   >&nbsp; a+0这里只是为了说明指针的加减运算, 可以去掉+0.</span></div><div><span style="line-height: 22px;"   >&nbsp;&nbsp;</span><span style="line-height: 22px;"   >sizeof(char *):8 表示指针占用了8字节, sizeof(char):1 表示char占用了1字节.</span></div><div><br></div><div>4. 接下来打印 &amp;a 这个地址是不是也是按照从低到高存储的?</div><div>为了一个字节一个字节打出, &nbsp;我们需要再定义一个指针b , 用指针b来做加减运算, 但是这样能如愿吗?</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 zzz]# cat b.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char * a = "hello";</font></div><div><font size="2"   >&nbsp; char ** b = &amp;a;</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "sizeof(a):%lu, b:%p, &amp;a:%p, b+1:%p\n", sizeof(a), b, &amp;a, b+1);</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果 :&nbsp;</font></div><div><font size="2"   >[root@db-172-16-3-33 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./b.c -o b &amp;&amp; ./b</font></div><div><font size="2"   >sizeof(a):8, b:0x7fff3692b520, &amp;a:0x7fff3692b520, b+1:0x7fff3692b528</font></div><p></p></pre></div><div>解说 :&nbsp;</div><div><span style="line-height: 22px;"   >sizeof(a)=8&nbsp;</span>结果告诉我们, a这个变量占用了8字节, 因为它存储的是个内存地址, 在64位的操作系统中这个是可以理解的.</div><div>b这个指针指向a, 所以b和&amp;a 打印出来的值转成内存地址当然是一样的.</div><div>b+1 运算得到的地址当然应该是加8个字节 . 因为地址做加减运算得到的当然还是地址, 至于得到的结果和什么有关, 当然和这个做加减运算的指针定义时所告知的它指向什么类型的数据有关. char ** b, ( *b 表示 b是一个指针, 然后char *则是告诉你b指向的是一个指针, 甭管是什么类型的指针,反正b指向的是一个指针, 一个指针占用8字节, 所以b+1就是加8个字节)</div><div><br></div><div>那怎么样能让b+1结果是加1个字节呢?</div><div>这里要用到强制类型转换. (char *) b 就把b强制转成char *了. &nbsp;所以 ((char *) b)+1 就是加1字节. *(<span style="line-height: 22px;"   >((char *) b)+1) 就是取这个地址的内容.</span></div><div><span style="line-height: 22px;"   >%x表示取一个字节并按照16进制打印出来.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 zzz]# cat b.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char * a = "hello";</font></div><div><font size="2"   >&nbsp; char ** b = &amp;a;</font></div><div><font size="2"   >&nbsp; unsigned short i;</font></div><div><font size="2"   >&nbsp; unsigned short x = (unsigned short) sizeof(a);</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "&amp;a:%p, a:%p\n", &amp;a, a);</font></div><div><font size="2"   >&nbsp; for(i=0; i&lt;x; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; fprintf(stdout, "i:%u, ((char *) b)+i:%p, *(((char *) b)+i):%x\n", i, ((char *) b)+i, *(((char *) b)+i));</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果 :&nbsp;</font></div><div><font size="2"   >[root@db-172-16-3-33 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./b.c -o b &amp;&amp; ./b</font></div><div><font size="2"   >&amp;a:0x7fff1ffff608, a:0x400728</font></div><div><font size="2"   >i:0, ((char *) b)+i:0x7fff1ffff608, *(((char *) b)+i):28</font></div><div><font size="2"   >i:1, ((char *) b)+i:0x7fff1ffff609, *(((char *) b)+i):7</font></div><div><font size="2"   >i:2, ((char *) b)+i:0x7fff1ffff60a, *(((char *) b)+i):40</font></div><div><font size="2"   >i:3, ((char *) b)+i:0x7fff1ffff60b, *(((char *) b)+i):0</font></div><div><font size="2"   >i:4, ((char *) b)+i:0x7fff1ffff60c, *(((char *) b)+i):0</font></div><div><font size="2"   >i:5, ((char *) b)+i:0x7fff1ffff60d, *(((char *) b)+i):0</font></div><div><font size="2"   >i:6, ((char *) b)+i:0x7fff1ffff60e, *(((char *) b)+i):0</font></div><div><font size="2"   >i:7, ((char *) b)+i:0x7fff1ffff60f, *(((char *) b)+i):0</font></div><p></p></pre></div><div>解说 :&nbsp;</div><div>a变量存放在内存地址<span style="line-height: 22px;"   >0x7fff1ffff608这里的连续8个字节中.</span></div><div><span style="line-height: 22px;"   >a变量的8个字节中存储了什么内容呢?&nbsp;</span><span style="line-height: 22px;"   >0x400728</span></div><div><span style="line-height: 22px;"   >它是从低位到高位存储的, 如上面的结果, 28存在</span><span style="line-height: 22px;"   >0x7fff1ffff608, 07存在</span><span style="line-height: 22px;"   >0x7fff1ffff609, 40存在</span><span style="line-height: 22px;"   >0x7fff1ffff60a, 另外5个字节存的都是0x00.</span></div><div><br></div><div><br></div><div>5. 如果是多字节的数据又是怎么存储的呢? 比如int 占据了4个字节, 它是怎么存储的 ?</div><div>答案也是从低位到高位.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 zzz]# cat c.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; int a = -987654;</font></div><div><font size="2"   >&nbsp; int * b = &amp;a;</font></div><div><font size="2"   >&nbsp; unsigned short i;</font></div><div><font size="2"   >&nbsp; unsigned short x = (unsigned short) sizeof(a);</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "&amp;a:%p, a:%i, a:%x\n", &amp;a, a, a);</font></div><div><font size="2"   >&nbsp; for(i=0; i&lt;x; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; fprintf(stdout, "i:%u, ((char *) b)+i:%p, (unsigned char) (*(((char *) b)+i)):%x\n", i, ((char *) b)+i, (unsigned char) (*(((char *) b)+i)));</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果 :&nbsp;</font></div><div><font size="2"   >[root@db-172-16-3-33 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./c.c -o c &amp;&amp; ./c</font></div><div><font size="2"   >&amp;a:0x7fffe57051cc, a:-987654, a:fff0edfa &nbsp;//负数是正数的反码加1, 所以得到的是这个结果.</font></div><div><font size="2"   >i:0, ((char *) b)+i:0x7fffe57051cc, (unsigned char) (*(((char *) b)+i)):fa</font></div><div><font size="2"   >i:1, ((char *) b)+i:0x7fffe57051cd, (unsigned char) (*(((char *) b)+i)):ed</font></div><div><font size="2"   >i:2, ((char *) b)+i:0x7fffe57051ce, (unsigned char) (*(((char *) b)+i)):f0</font></div><div><font size="2"   >i:3, ((char *) b)+i:0x7fffe57051cf, (unsigned char) (*(((char *) b)+i)):ff</font></div><p></p></pre></div><div>注意, 这里一定要把内容再强制转换成unsigned char再输出, 就是这个<span style="line-height: 22px;"   >(unsigned char) (*(((char *) b)+i)):%x .&nbsp;</span></div><div><span style="line-height: 22px;"   >否则编译器会输出4字节的16进制数, 不太好看. 如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; int a = -987654;</font></div><div><font size="2"   >&nbsp; int * b = &amp;a;</font></div><div><font size="2"   >&nbsp; unsigned short i;</font></div><div><font size="2"   >&nbsp; unsigned short x = (unsigned short) sizeof(a);</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "&amp;a:%p, a:%i, a:%x\n", &amp;a, a, a);</font></div><div><font size="2"   >&nbsp; for(i=0; i&lt;x; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; fprintf(stdout, "i:%u, ((char *) b)+i:%p, (*(((char *) b)+i)):%x\n", i, ((char *) b)+i, (*(((char *) b)+i)));</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   >结果 :&nbsp;</font></div><div><span style="line-height: 22px;"   ><div><font size="2"   >[root@db-172-16-3-33 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./c.c -o c &amp;&amp; ./c</font></div><div><font size="2"   >&amp;a:0x7ffff6fada3c, a:-987654, a:fff0edfa</font></div><div><font size="2"   >i:0, ((char *) b)+i:0x7ffff6fada3c, (*(((char *) b)+i)):fffffffa</font></div><div><font size="2"   >i:1, ((char *) b)+i:0x7ffff6fada3d, (*(((char *) b)+i)):ffffffed</font></div><div><font size="2"   >i:2, ((char *) b)+i:0x7ffff6fada3e, (*(((char *) b)+i)):fffffff0</font></div><div><font size="2"   >i:3, ((char *) b)+i:0x7ffff6fada3f, (*(((char *) b)+i)):ffffffff</font></div></span></div><p></p></pre></div><div><span style="line-height: 22px;"   ><div><br></div></span></div><div>6. 那么bit-field又是怎么存储的呢?</div><div>答案当然也是从低位到高位存储的, 这里要用到struct来验证.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 zzz]# cat c.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; typedef struct test{</font></div><div><font size="2"   >&nbsp; &nbsp; unsigned char f1:1;</font></div><div><font size="2"   >&nbsp; &nbsp; unsigned char f2:2;</font></div><div><font size="2"   >&nbsp; &nbsp; unsigned char f3:3;</font></div><div><font size="2"   >&nbsp; &nbsp; unsigned char f4:2;</font></div><div><font size="2"   >&nbsp; } test;</font></div><div><font size="2"   >&nbsp; test t1 = {0,1,4,3};</font></div><div><font size="2"   >&nbsp; test * pt1 = &amp;t1;</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "(unsigned char) (*((unsigned char *) pt1)):%x\n", (unsigned char) (*((unsigned char *) pt1)));</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果 :&nbsp;</font></div><div><font size="2"   >[root@db-172-16-3-33 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./c.c -o c &amp;&amp; ./c</font></div><div><font size="2"   >(unsigned char) (*((unsigned char *) pt1)):e2</font></div><p></p></pre></div><div>解说 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 22px;"   >test t1 = {0,1,4,3};&nbsp;</span><span style="line-height: 22px;"   >转成二进制分别如下 :&nbsp;</span></font></div><div><span style="line-height: 22px;"   ><font size="2"   >f1(0) : 0</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   >f2(1) : 01</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   >f3(4) : 100</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   >f4(3) : 11</font></span></div><p></p></pre></div><div><span style="line-height: 22px;"   >如果是按低位到高位存储的, 那么它存储的应该是 : 11100010 . 这个与0xe2 刚好相符.</span></div><div><span style="line-height: 22px;"   >这里同样用到了强制类型转换,&nbsp;</span><span style="line-height: 22px;"   >(unsigned char *) pt1是把指向struct test的指针转成了指向unsigned char的指针.</span></div><div><span style="line-height: 22px;"   >(unsigned char) (*((unsigned char *) pt1)) 是把&nbsp;</span><span style="line-height: 22px;"   >*((unsigned char *) pt1) 转成了unsigned char类型.&nbsp;</span></div><div><span style="line-height: 22px;"   >如果不使用指针, 直接把struct变量转成unsigned是不能编译通过的. 错误如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 zzz]# cat c.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; typedef struct test{</font></div><div><font size="2"   >&nbsp; &nbsp; unsigned char f1:1;</font></div><div><font size="2"   >&nbsp; &nbsp; unsigned char f2:2;</font></div><div><font size="2"   >&nbsp; &nbsp; unsigned char f3:3;</font></div><div><font size="2"   >&nbsp; &nbsp; unsigned char f4:2;</font></div><div><font size="2"   >&nbsp; } test;</font></div><div><font size="2"   >&nbsp; test t1 = {0,1,4,3};</font></div><div><font size="2"   >&nbsp; unsigned char a = (unsigned char) t1;</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a:%x\n", a);</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果 :&nbsp;</font></div><div><font size="2"   >[root@db-172-16-3-33 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./c.c -o c &amp;&amp; ./c</font></div><div><font size="2"   >./c.c: In function ‘main’:</font></div><div><font size="2"   >./c.c:11: error: aggregate value used where an integer was expected</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >所以指针在C里面运用真的太灵活了.</span></div><div><br></div><div>进入正题, 讲讲 char **a , char *a[] , char a[][], char * a[][] , char ** a[][] , char * a [][][]</div><div>看起来很复杂, 其实理解了就不复杂了.</div><div><span style="line-height: 22px;"   >1.&nbsp;</span></div><div><span style="line-height: 22px;"   >char **a ：&nbsp;</span></div><div><span style="line-height: 22px;"   >表示a是一个指针, 这个指针指向的地址存储的是 char * 类型的数据.&nbsp;</span><span style="line-height: 22px;"   >指针的加减运算在这里的体现 :&nbsp;</span><span style="line-height: 22px;"   >a + 1 表示地址加8字节 . &nbsp;</span></div><div><span style="line-height: 22px;"   >char * 也是一个指针,&nbsp;</span><span style="line-height: 22px;"   >用(*a)表示</span><span style="line-height: 22px;"   >, </span><span style="line-height: 22px;"   >指向的地址存储的是 char 类型的数据。</span><span style="line-height: 22px;"   >指针的加减运算在这里的体现 : (*</span><span style="line-height: 22px;"   >a) + 1 表示地址加1字节 . &nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 zzz]# cat b.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char * a = "hello";</font></div><div><font size="2"   >&nbsp; char ** b = &amp;a;</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "&amp;b:%p, b:%p, &amp;a:%p, a:%p, *a:%c, a:%s\n", &amp;b, b, &amp;a, a, *a, a);</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果 :&nbsp;</font></div><div><font size="2"   >[root@db-172-16-3-33 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./b.c -o b &amp;&amp; ./b</font></div><div><font size="2"   >&amp;b:0x7fff5319c1d8, b:0x7fff5319c1e0, &amp;a:0x7fff5319c1e0, a:0x400628, *a:h, a:hello</font></div><p></p></pre></div><div><br></div><div>图示 :&nbsp;</div><div><div><div><img title="char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory - 德哥@Digoal - The Heart,The World."   alt="char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory - 德哥@Digoal - The Heart,The World."   style="margin:0 10px 0 0;"   src="http://img6.ph.126.net/cXnUfLBSFGHiBaPJDIfMgg==/6597395222098688396.jpg"   ></div>&nbsp;&nbsp;</div></div><div><div><img title="char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory - 德哥@Digoal - The Heart,The World."   alt="char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory - 德哥@Digoal - The Heart,The World."   style="margin:0 10px 0 0;"   src="http://img7.ph.126.net/mk71E_hsAY8jv2O9nRCdKQ==/6597391923563804947.jpg"   ></div>&nbsp;</div><div><br></div><div>2.&nbsp;<span style="line-height: 22px;"   >char *a[]</span></div><div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >表示 a是数组, 数组中的元素是指针, 指向char类型. (数组里面所有的元素是连续的内存存放的).</span></div><div style="line-height: 22px;"   >需要特别注意 :&nbsp;</div><div style="line-height: 22px;"   >数组名在C里面做了特殊处理 , 数组名用数组所占用内存区域的第一个字节的内存地址替代了。并且数组名a也表示指针.</div><div style="line-height: 22px;"   >如数组占用的内存区域是0x7fff5da3f550到0x7fff5da3f5a0, 那么a就被替换成<span style="line-height: 22px;"   >0x7fff5da3f550.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >所以a 并不表示a地址存储的内容, 而是a地址本身(这个从 a = &amp;a 就能够体现出来). 这个一定要理解, 否则会无法进行下去.&nbsp;</span></div><div style="line-height: 22px;"   >a+1 表示a的第二个元素的内存地址, 所以是加8字节.( 因为a的元素是char 指针, 所需要的空间为8字节(64位内存地址). )</div><div style="line-height: 22px;"   >*(a+1) 则表示a这个数组的第二个元素的内容 (是个char 类型的指针. 本例表示为world字符串的地址).</div></div><div style="line-height: 22px;"   >*(*(a+1)) 则表示<span style="line-height: 22px;"   >a这个数组的第二个元素的内容(char指针)所指向的内容(</span><span style="line-height: 22px;"   >w字符).</span></div><div style="line-height: 22px;"   >char * a[10] 表示限定这个数组最多可存放10个元素(char指针), 也就是说这个数组占用10*8 = 80字节.</div><div style="line-height: 22px;"   >如果存储超出数组的限额编译警告如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 zzz]# cat b.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char *a[1] = {"abc","def"};</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a[1]:%s\n", a[1]);</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果 :&nbsp;</font></div><div><font size="2"   >[root@db-172-16-3-33 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./b.c -o b &amp;&amp; ./b</font></div><div><font size="2"   >cc1: warnings being treated as errors</font></div><div><font size="2"   >./b.c: In function ‘main’:</font></div><div><font size="2"   >./b.c:4: warning: excess elements in array initializer &nbsp;// 超出数组长度. 因为赋值时给了2个元素, 而限定只有1个元素.</font></div><div><font size="2"   >./b.c:4: warning: (near initialization for ‘a’)</font></div><p></p></pre></div><div><br></div><div>例子 :&nbsp;</div><div><div><img title="char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory - 德哥@Digoal - The Heart,The World."   alt="char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory - 德哥@Digoal - The Heart,The World."   style="margin:0 10px 0 0;"   src="http://img7.ph.126.net/ipfPveCBoj6bpad1lFAv0A==/6597456794749030587.jpg"   ></div>&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-33 zzz]# cat b.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char *a[10] = {"hello", "world"};</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a:%p, a+1:%p, &amp;a:%p, (&amp;a)+1:%p, *a:%p, *(a+1):%p\n", a, a+1, &amp;a, (&amp;a)+1, *a, *(a+1));</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "*a:%s, *(a+1):%s, **a:%c, *(*(a+1)):%c\n", *a, *(a+1), **a, *(*(a+1)));</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   >结果 :&nbsp;</font></div><div><div><font size="2"   >[root@db-172-16-3-33 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./b.c -o b &amp;&amp; ./b</font></div><div><font size="2"   >a:0x7fff9d0fb180, a+1:0x7fff9d0fb188, &amp;a:0x7fff9d0fb180, (&amp;a)+1:0x7fff9d0fb1d0, *a:0x4006b8, *(a+1):0x4006be</font></div><div><font size="2"   >*a:hello, *(a+1):world, **a:h, *(*(a+1)):w</font></div></div><p></p></pre></div><div>解说 :&nbsp;</div><div><span style="line-height: 22px;"   >a:%p 打印&nbsp;</span> <span style="line-height: 22px;"   >0x7fff9d0fb180</span><span style="line-height: 22px;"   >&nbsp;表示a的内存地址 , 也就是说数组a的第一个元素存储在这个地址里面, 取出第一个元素的值(char指针)使用*a&nbsp;</span><span style="line-height: 22px;"   >.</span></div><div><span style="line-height: 22px;"   >a+1:%p 打印的是a这个数组的第二个元素</span><span style="line-height: 22px;"   >的内存地址</span><span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >0x7fff5da3f558 (因为a数组里面存储的是char指针, 指针在64位机器里面占用8字节, 所以第二个元素所在的内存地址相比第一个元素所在的内存地址刚好大8字节)</span><span style="line-height: 22px;"   >, 取出第二个元素的值(char指针)使用*(a+1)&nbsp;</span><span style="line-height: 22px;"   >.</span></div><div><span style="line-height: 22px;"   >&amp;a:%p 打印出来的结果和a:%p 0x7fff5da3f550 一致, 因为编译器把数组名替换成了数组所在内存的位置 .&nbsp;</span></div><div>(a:%p 打印的是第一个元素所在的内存地址, &amp;a:%p打印的则是a数组所在的内存地址. 所以结果是一样的)</div><div><span style="line-height: 22px;"   >但是 a+1 不等于 (&amp;a)+1. 原因是 a 和 &amp;a 含义不一样, a指向的是数组里面的第一个元素, 所以a+1 指的是第二个元素. &amp;a指向的是a这个数组, 所以(&amp;a)+1 表示整个a数组要用到的内存空间的下一个地址. ( 如果&amp;a不好理解的话, 想象把&amp;a 赋予给另一个指针变量c, 那么c+1 等于啥? )</span></div><div><br></div><div>3. char [][]</div><div>char a[2][10] 表示一个二维数组, 存储在最底层的元素是char. 1维最多允许存储2个元素(char []), 2维最多允许存储10个元素(char).</div><div>超出将告警 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 zzz]# cat b.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char a[2][10] = {"hello", "world", "linux"};</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果 :&nbsp;</font></div><div><font size="2"   >[root@db-172-16-3-33 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./b.c -o b &amp;&amp; ./b</font></div><div><font size="2"   >cc1: warnings being treated as errors</font></div><div><font size="2"   >./b.c: In function ‘main’:</font></div><div><font size="2"   >./b.c:4: warning: excess elements in array initializer &nbsp;// 1维在赋值时给出了3个元素"hello" , "world" , "linux" 因此告警了, 可能导致内存溢出.</font></div><div><font size="2"   >./b.c:4: warning: (near initialization for ‘a’)</font></div><div><font size="2"   >./b.c:4: warning: unused variable ‘a’</font></div><p></p></pre></div><div>2维超出长度同样告警 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 zzz]# cat b.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char a[2][10] = {"helloxxxxxxxx", "world"};</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >[root@db-172-16-3-33 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./b.c -o b &amp;&amp; ./b</font></div><div><font size="2"   >cc1: warnings being treated as errors</font></div><div><font size="2"   >./b.c: In function ‘main’:</font></div><div><font size="2"   >./b.c:4: warning: initializer-string for array of chars is too long</font></div><div><font size="2"   >./b.c:4: warning: (near initialization for ‘a[0]’)</font></div><div><font size="2"   >./b.c:4: warning: unused variable ‘a’</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >char a[2][10] 中, a+$n 或者 &amp; a[n] 表示 指向1维的第$n个元素的指针, *(a+$n)+$m 或 &amp; a[n][m] 表示指向1维的第n个元素中的第m个元素的指针.&nbsp;</span></div><div><span style="line-height: 22px;"   >*(</span><span style="line-height: 22px;"   >*(a+$n)+$m) 或者 a[n][m] 表示&nbsp;</span><span style="line-height: 22px;"   >1维的第n个元素中的第m个元素 的内容 .&nbsp;</span></div><div><div><div><div><img title="char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory - 德哥@Digoal - The Heart,The World."   alt="char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory - 德哥@Digoal - The Heart,The World."   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/VrS23gbKr7qbolX4HNATng==/1089871109841259422.jpg"   ></div>&nbsp;</div>解说 :&nbsp;</div><div>以<span style="line-height: 22px;"   >char a[2][10]为例子 :&nbsp;</span></div><div>&amp;a 是一个指针 , 加1 将加整个二维数组所占空间. 相当于加20字节.</div><div>a 是一个指针 , 加1 将加加1个1维元素所占空间.&nbsp;<span style="line-height: 22px;"   >相当于加10字节.</span></div><div>*a 是一个指针&nbsp;<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >, &nbsp;加1 将加加1个2维元素所占空间.&nbsp;</span><span style="line-height: 22px;"   >相当于加1字节.</span></div><div><span style="line-height: 22px;"   >**a 不是指针, 是char.&nbsp;</span></div><div>a+1与*(a+1)相等 是因为a+1 表示1维的第2个元素的首地址, *(a+1)表示<span style="line-height: 22px;"   >1维的第2个元素中的第1个元素的地址. 指向同一个地址. 但是含义不一样. &nbsp;(a+1) + 1 和 (*(a+1)) + 1就不一样了.</span></div><div><span style="line-height: 22px;"   >(a+1) + 1&nbsp;</span><span style="line-height: 22px;"   >表示1维的第3个元素的首地址;&nbsp;</span><span style="line-height: 22px;"   >(*(a+1)) + 1&nbsp;</span><span style="line-height: 22px;"   >表示</span><span style="line-height: 22px;"   >1维的第2个元素中的第2个元素的地址.&nbsp;</span></div><div><br></div><div>以char a[2][6]为例子 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-150 zzz]# cat a.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char a[2][6] = {"hello", "world"};</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "sizeof(a):%lu\n", sizeof(a)); // a数组占用空间</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "&amp;a:%p, (&amp;a)+1:%p\n", &amp;a, (&amp;a)+1); // a数组首地址, a数组首地址加1</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a:%p, a+1:%p\n", a, a+1); // a数组1维度第1个元素首地址, 加1</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "*a:%p, *(a)+1:%p\n", *a, *(a)+1); // a数组1维度第1个元素中的第1个元素首地址, 加1</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   >结果 :&nbsp;</font></div><div><div><font size="2"   >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o a &amp;&amp; ./a</font></div><div><font size="2"   >sizeof(a):12</font></div><div><font size="2"   >&amp;a:0x7ffffe5cf8b0, (&amp;a)+1:0x7ffffe5cf8bc &nbsp;// 加12个字节</font></div><div><font size="2"   >a:0x7ffffe5cf8b0, a+1:0x7ffffe5cf8b6<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;// 加6个字节</span></font></div><div><font size="2"   >*a:0x7ffffe5cf8b0, *(a)+1:0x7ffffe5cf8b1 &nbsp;<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;// 加1个字节</span></font></div></div><p></p></pre></div><div><br></div><div>验证图示正确性 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 zzz]# cat a.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char a[2][6] = {"hello", "world"};</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "&amp;a:%p, a:%p, *a:%p\n", &amp;a, a, *a);</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "(*(a+0))+1:%p, &amp;a[0][1]:%p\n", (*(a+0))+1, &amp;a[0][1]);</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a+1:%p, &amp;a[1]:%p, *(a+1):%p, a[1]:%p\n", a+1, &amp;a[1], *(a+1), a[1]);</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "(*(a+1))+1:%p, &amp;a[1][1]:%p\n", (*(a+1))+1, &amp;a[1][1]);</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "(&amp;a)+1:%p\n", (&amp;a)+1);</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果 :&nbsp;</font></div><div><font size="2"   >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o a &amp;&amp; ./a</font></div><div><font size="2"   >&amp;a:0x7fff5c94e670, a:0x7fff5c94e670, *a:0x7fff5c94e670</font></div><div><font size="2"   >(*(a+0))+1:0x7fff5c94e671, &amp;a[0][1]:0x7fff5c94e671</font></div><div><font size="2"   >a+1:0x7fff5c94e676, &amp;a[1]:0x7fff5c94e676, *(a+1):0x7fff5c94e676, a[1]:0x7fff5c94e676</font></div><div><font size="2"   >(*(a+1))+1:0x7fff5c94e677, &amp;a[1][1]:0x7fff5c94e677</font></div><font size="2"   >(&amp;a)+1:0x7fff5c94e67c&nbsp;</font><p></p></pre></div></div><div><br></div><div>指针运用 :</div><div>fprintf 打印 %s 需要传入char *指针 . %c 需要传入的是值.&nbsp;</div><div>下面试试使用 a+1 和 *(a+1) 来打印%s, a+1 会报错, 因为它是一个指向指针的指针. 不是char *.&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 zzz]# cat a.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char a[2][6] = {"hello", "world"};</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a+1:%s\n", a+1);</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o a &amp;&amp; ./a</font></div><div><font size="2"   >cc1: warnings being treated as errors</font></div><div><font size="2"   >./a.c: In function ‘main’:</font></div><div><font size="2"   >./a.c:5: warning: format ‘%s’ expects type ‘char *’, but argument 3 has type ‘char (*)[6]’</font></div><p></p></pre></div><div><br></div><div>将 a+1 指针强制转换成char * 就可以了 (char *) (a+1) . 如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 zzz]# cat a.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char a[2][6] = {"hello", "world"};</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a+1:%s\n", (char *) (a+1));</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o a &amp;&amp; ./a</font></div><div><font size="2"   >a+1:world</font></div><p></p></pre></div><div><br></div><div>你可能觉得不对劲,&nbsp;<span style="line-height: 22px;"   >(char *) (a+1) 到底是强制转换还是去a+1这个地址的内容? 那我们就用一个三维数组来验证一下, 如果是取这个地址的值, 那么得到的应该是一个指向指针的指针. 也是不能打印的. 如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-150 zzz]# cat a.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char a[2][6][6] = {{"hello", "world"},{"linux", "digoal"}};</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a+1:%s\n", (a+1));</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果</font></div><div><font size="2"   >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o a &amp;&amp; ./a</font></div><div><font size="2"   >cc1: warnings being treated as errors</font></div><div><font size="2"   >./a.c: In function ‘main’:</font></div><div><font size="2"   >./a.c:5: warning: format ‘%s’ expects type ‘char *’, but argument 3 has type ‘char (*)[6][6]’</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-150 zzz]# cat a.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char a[2][6][6] = {{"hello", "world"},{"linux", "digoal"}};</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a+1:%s\n", *(a+1));</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果</font></div><div><font size="2"   >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o a &amp;&amp; ./a</font></div><div><font size="2"   >cc1: warnings being treated as errors</font></div><div><font size="2"   >./a.c: In function ‘main’:</font></div><div><font size="2"   >./a.c:5: warning: format ‘%s’ expects type ‘char *’, but argument 3 has type ‘char (*)[6]’</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-150 zzz]# cat a.c</font></div><div><font size="2"   >#include &lt;stdio.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >int main() {</font></div><div><font size="2"   >&nbsp; char a[2][6][6] = {{"hello", "world"},{"linux", "digoal"}};</font></div><div><font size="2"   >&nbsp; fprintf(stdout, "a+1:%s\n", (char *) (a+1));</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   >结果</font></div><div><font size="2"   >[root@db-172-16-3-150 zzz]# gcc -O3 -Wall -Wextra -Werror -g ./a.c -o a &amp;&amp; ./a</font></div><div><font size="2"   >a+1:linux</font></div></div><p></p></pre></div><div>从上面得到一个结论, 只要是数组名, 就会被替换成地址, 不管是1维还是2维. 想象一下a[2][6], a是1维的数组名, *a是2维的数组名. 都是替换成地址了. 多维也是如此.</div><div><br></div><div>【其他】</div><div>1. 当char []作为函数的参数时, 表示 char *. 当作为函数的参数传入时, 实际上是拷贝了数组的第一个元素的地址 .&nbsp;</div><div>&nbsp; &nbsp; 所以 void test (char a[]) 等同于 void test ( char * a )</div><div>&nbsp; &nbsp; char x[10] ; 然后调用 test(x) 则等同于把 x 的第一个元素的地址赋予给参数 a .&nbsp;</div><div>2. char * a 和 char a[]&nbsp;</div><div>相同点 : a都是指针, &nbsp;指向char类型.</div><div>不同点 : char a[] 把内容存在stack .&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char *a 则把指针存在stack，把内容存在constants.&nbsp;</div><div>3. char * a[10] 和 char a[10][20]</div><div>相同点 : a 都是2级指针, *a 表示一级指针, **a 表示内存中存储的内容.</div><div>不同点 : &nbsp;char * a[10], 数组由char * 类型的指针组成;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;char a [10][20] 表示一位放10个元素, 二维放20个元素, 值存放地是一块连续的内存区域, 没有指针.</div><div><br></div><div>4. 小窍门 : &nbsp;[]和*的数量对应, 如 char a[][]的指针层数是2, 相当于char **a; char *a[]也是如此, 两层指针. 迷糊的时候数数到底有几个*几个[], 就知道什么情况下存储的是内容还是地址了? 如char a[][] 的情况里面: &amp;a, a, *a 都是地址, **a 是内容.</div><div><br>【参考】</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >SYNOPSIS</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;stdio.h&gt;</font></div></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;int fprintf(FILE *stream, const char *format, ...);</font></div><p></p></pre></div><div><p><br></p></div>

<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="char * a, char ** a, char * a[], char a[][], char * a[][], char ** a[][], char * a [][][], and so on in memory - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">x x  - 2014-07-20 11:09:54</h5>
				<div>排版太好了.. 图文并茂. 先评先转再阅~~~~~</div>
			</div>
			<div id="">
				<h5 id="">java_do - 2013-09-09 17:22:20</h5>
				<div>此文章是我看关于char * 讲解的最明白的了，以前总是模糊，虽然现在也有点模糊。不过还是明白了不少。<div><br></div><div>感觉c语言，更多的是理解。</div></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">常∮乐 回复 java_do - 2013-09-09 17:22:20</h5>
				<div style="width:600px;">顶</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 常∮乐 - 2013-09-09 17:22:20</h5>
				<div style="width:600px;">写得很肤浅,贻笑大方了.</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">11 回复 常∮乐 - 2013-09-09 17:22:20</h5>
				<div style="width:600px;">顶</div>
			</div>
			<div id="">
				<h5 id="">11 - 2014-04-13 18:34:31</h5>
				<div>讲得很详细<img src="http://b.bst.126.net/common/portrait/face/preview/face0.gif"  ><br><br></div>
			</div>
			<div id="">
				<h5 id="">aa - 2013-05-14 21:02:48</h5>
				<div>傻b看看c专家编程再来说别说的真么麻烦这么浅<br><br></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 aa - 2013-05-14 21:02:48</h5>
				<div style="width:600px;">C专家编程，还未拜读。有时间一定拜读各类经典。<br></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">常∮乐 回复 aa - 2013-05-14 21:02:48</h5>
				<div style="width:600px;">sb↑</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">常∮乐 回复 常∮乐 - 2013-05-14 21:02:48</h5>
				<div style="width:600px;">我去。。。对不起博主，我想说的是层主</div>
			</div>
	</div>
</div>
</body>
</html>