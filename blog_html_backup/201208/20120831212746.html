<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">table level replication use trigger -- multi master replication & performance tuning</h2>
	<h5 id="">2012-08-31 21:27:46&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012731944439/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">前一篇介绍了使用触发器实现远程同步数据.<div><a href="http://blog.163.com/digoal@126/blog/static/1638770402012731203716/"   >http://blog.163.com/digoal@126/blog/static/1638770402012731203716/</a>&nbsp;<br><div>这篇将上一篇的处理异常记录的函数进行优化. 本例的连接名将不再特别指定, 直接与dst_server同名.</div><div>函数改成如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create or replace function deal_sync_err_rec (i_limit int) returns boolean as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; v_conn_name text; &nbsp;-- 连接名</font></div><div><font size="2"   >&nbsp; v_conn_status text; &nbsp;-- 存储dblink_connect(v_conn_name, v_dst_server)的返回值</font></div><div><font size="2"   >&nbsp; v_exec_status text; &nbsp;-- 存储dblink_exec(v_conn_name, v_dst_query, true|false)的返回值.</font></div><div><font size="2"   >&nbsp; v_dst_server text; &nbsp;-- foreign server, 一次取一个. 根据这个dst_server再抽取错误的同步记录, 进行处理.</font></div><div><font size="2"   >&nbsp; v_dst_query text; &nbsp;-- sync_err_rec中记录的SQL语句</font></div><div><font size="2"   >&nbsp; v_id int8[]; &nbsp;-- sync_err_rec的主键, 用于记录一批记录, BATCH删除.</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; -- 取出最早的记录的dst_server, 接下来将处理这个dst_server发生的错误.</font></div><div><font size="2"   >&nbsp; </font><font size="2"   >select dst_server&nbsp;</font><span style="line-height: 19px; font-size: small;"   >into v_dst_server</span> <span style="font-size: small;"   >from sync_err_rec order by create_time limit 1;</span></div><div><font size="2"   >&nbsp; -- 空表示没有记录直接返回</font></div><div><font size="2"   >&nbsp; if (v_dst_server is NULL) then</font></div><div><font size="2"   >&nbsp; &nbsp; return true;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 将v_dst_server的值赋予给连接名</font></div><div><font size="2"   >&nbsp; v_conn_name := v_dst_server;</font></div><div><font size="2"   >&nbsp; -- 取出一批记录</font></div><div><font size="2"   >&nbsp; select array_agg(id), string_agg(dst_query, ';') into v_id, v_dst_query from&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; (select id,dst_query from sync_err_rec where dst_server=v_dst_server order by create_time limit i_limit) t;</font></div><div><font size="2"   >&nbsp; -- 删除sync_err_rec中对应的记录.</font></div><div><font size="2"   >&nbsp; delete from sync_err_rec where id in (select unnest(v_id));</font></div><div><font size="2"   >&nbsp; if ( dblink_get_connections() @&gt; ('{'||v_conn_name||'}')::text[] ) then&nbsp;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_conn_status from dblink_connect(v_conn_name, v_dst_server);</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 这里使用的是true, 所以远程异常, 本地也异常. 确保到这一步还可以回退, 只要这一步执行成功, 那本地删除的sync_err_rec和远程都执行成功.</font></div><div><font size="2"   >&nbsp; select * into v_exec_status from dblink_exec(v_conn_name, v_dst_query, true);</font></div><div><font size="2"   >&nbsp; -- raise notice 'v_conn_status:%, v_exec_status:%.', v_conn_status, v_exec_status;</font></div><div><font size="2"   >&nbsp; return true;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><p></p></pre></div><div><br></div><div>这一篇BLOG重点将介绍multi master replication的例子.</div><div><div><img title="table level replication use trigger -- multi master replication  performance tuning - 德哥@Digoal - The Heart,The World."   alt="table level replication use trigger -- multi master replication  performance tuning - 德哥@Digoal - The Heart,The World."   style="margin:0 10px 0 0;"   src="http://img4.ph.126.net/nYLnr0B3G3IpXp4atnMg5Q==/2746632822760282224.jpg"   ></div>&nbsp;</div><div>如下 :&nbsp;</div><div>创建两个用户 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create role local login encrypted password 'LOCAL321';</font></div><div><font size="2"   >CREATE ROLE</font></div><div><font size="2"   >postgres=# create role remote login encrypted password 'REMOTE321';</font></div><div><font size="2"   >CREATE ROLE</font></div><p></p></pre></div><div>创建两个数据库 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create database local owner local;</font></div><div><font size="2"   >CREATE DATABASE</font></div><div><font size="2"   >postgres=# create database remote owner remote;</font></div><div><font size="2"   >CREATE DATABASE</font></div><p></p></pre></div><div>创建dblink模块 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \c local postgres</font></div><div><font size="2"   >You are now connected to database "local" as user "postgres".</font></div><div><font size="2"   >local=# create extension dblink;</font></div><div><font size="2"   >CREATE EXTENSION</font></div><div><font size="2"   >local=# \c remote postgres</font></div><div><font size="2"   >You are now connected to database "remote" as user "postgres".</font></div><div><font size="2"   >remote=# create extension dblink;</font></div><div><font size="2"   >CREATE EXTENSION</font></div><p></p></pre></div><div>创建schema :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >local=&gt; create schema local;</font></div><div><font size="2"   >CREATE SCHEMA</font></div><div><font size="2"   >local=&gt; \c remote remote</font></div><div><font size="2"   >You are now connected to database "remote" as user "remote".</font></div><div><font size="2"   >remote=&gt; create schema remote;</font></div><div><font size="2"   >CREATE SCHEMA</font></div><p></p></pre></div><div><br></div><div>创建测试表 :&nbsp;</div><div>本例将使用联合索引 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >remote=&gt; \c local local</font></div><div><font size="2"   >You are now connected to database "local" as user "local".</font></div><div><font size="2"   >local=&gt; create table loc_test (pk1 int, pk2 text, info text, crt_time timestamp(0), mod_time timestamp(0), primary key(pk1,pk2));</font></div><div><font size="2"   >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "loc_test_pkey" for table "loc_test"</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >local=&gt; select string_agg(position::text,' ')::int2vector,count(*) from dblink_get_pkey('local.loc_test');</font></div><div><font size="2"   >&nbsp;string_agg | count&nbsp;</font></div><div><font size="2"   >------------+-------</font></div><div><font size="2"   >&nbsp;1 2 &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 2</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >local=&gt; create table sync_err_rec(id serial8 primary key, nsp_name name, table_name name, dst_server text, dst_query text, create_time timestamp without time zone);</font></div><div><font size="2"   >NOTICE: &nbsp;CREATE TABLE will create implicit sequence "sync_err_rec_id_seq" for serial column "sync_err_rec.id"</font></div><div><font size="2"   >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "sync_err_rec_pkey" for table "sync_err_rec"</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div><br></div><div>创建测试表 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \c remote remote</font></div><div><font size="2"   >You are now connected to database "remote" as user "remote".</font></div><div><font size="2"   >remote=&gt; create table rmt_test (pk1 int, pk2 text, info text, crt_time timestamp(0), mod_time timestamp(0), primary key(pk1,pk2));</font></div><div><font size="2"   >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "rmt_test_pkey" for table "rmt_test"</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >remote=&gt; select string_agg(position::text,' ')::int2vector,count(*) from dblink_get_pkey('remote.rmt_test');</font></div><div><font size="2"   >&nbsp;string_agg | count&nbsp;</font></div><div><font size="2"   >------------+-------</font></div><div><font size="2"   >&nbsp;1 2 &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 2</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >remote=&gt; create table sync_err_rec(id serial8 primary key, nsp_name name, table_name name, dst_server text, dst_query text, create_time timestamp without time zone);</font></div><div><font size="2"   >NOTICE: &nbsp;CREATE TABLE will create implicit sequence "sync_err_rec_id_seq" for serial column "sync_err_rec.id"</font></div><div><font size="2"   >NOTICE: &nbsp;CREATE TABLE / PRIMARY KEY will create implicit index "sync_err_rec_pkey" for table "sync_err_rec"</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div><br></div><div>回收<span style="line-height: 22px;"   >pg_user_mappings的public权限 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >local=&gt; \c local postgres</font></div><div><font size="2"   >You are now connected to database "local" as user "postgres".</font></div><div><font size="2"   >local=# revoke all on pg_user_mappings from public;</font></div><div><font size="2"   >REVOKE</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >回收</span><span style="line-height: 22px;"   >pg_user_mappings的public权限 :&nbsp;</span> </div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >local=# \c remote postgres</font></div><div><font size="2"   >You are now connected to database "remote" as user "postgres".</font></div><div><font size="2"   >remote=# revoke all on pg_user_mappings from public;</font></div><div><font size="2"   >REVOKE</font></div><p></p></pre></div><div><br></div><div>创建server :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \c local postgres</font></div><div><font size="2"   >You are now connected to database "local" as user "postgres".</font></div><div><font size="2"   >local=# CREATE FOREIGN DATA WRAPPER postgresql VALIDATOR postgresql_fdw_validator;</font></div><div><font size="2"   >CREATE FOREIGN DATA WRAPPER</font></div><div><font size="2"   >local=# CREATE SERVER dst FOREIGN DATA WRAPPER postgresql OPTIONS (hostaddr '172.16.3.150', port '9999', dbname 'remote', options '-c application_name=aaa_bbb_digoal');</font></div><div><font size="2"   >CREATE SERVER</font></div><div><font size="2"   >local=# GRANT USAGE ON FOREIGN SERVER dst TO local;</font></div><div><font size="2"   >GRANT</font></div><div><font size="2"   >local=# CREATE USER MAPPING FOR local SERVER dst OPTIONS (user 'remote', password 'REMOTE321');</font></div><div><font size="2"   >CREATE USER MAPPING</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >创建server :&nbsp;</span> </div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >local=# \c remote postgres</font></div><div><font size="2"   >You are now connected to database "remote" as user "postgres".</font></div><div><font size="2"   >remote=# CREATE FOREIGN DATA WRAPPER postgresql VALIDATOR postgresql_fdw_validator;</font></div><div><font size="2"   >CREATE FOREIGN DATA WRAPPER</font></div><div><font size="2"   >remote=# CREATE SERVER dst FOREIGN DATA WRAPPER postgresql OPTIONS (hostaddr '172.16.3.150', port '9999', dbname 'local', options '-c application_name=aaa_bbb_digoal');</font></div><div><font size="2"   >CREATE SERVER</font></div><div><font size="2"   >remote=# GRANT USAGE ON FOREIGN SERVER dst TO remote;</font></div><div><font size="2"   >GRANT</font></div><div><font size="2"   >remote=# CREATE USER MAPPING FOR remote SERVER dst OPTIONS (user 'local', password 'LOCAL321');</font></div><div><font size="2"   >CREATE USER MAPPING</font></div><p></p></pre></div><div><br></div>在local数据库创建触发器函数以及触发器 :&nbsp;<wbr></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >remote=&gt; \c local local</font></div><div><font size="2"   >You are now connected to database "local" as user "local".</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CREATE OR REPLACE FUNCTION f_sync_test()</font></div><div><font size="2"   >RETURNS trigger</font></div><div><font size="2"   >LANGUAGE plpgsql</font></div><div><font size="2"   >AS $BODY$</font></div><div><font size="2"   >DECLARE</font></div><div><font size="2"   >&nbsp; v_dst_server text := 'dst'; &nbsp;-- foreign server</font></div><div><font size="2"   >&nbsp; v_conn_name text := v_dst_server; &nbsp;-- 连接名, 本例配置与dst_server一致.</font></div><div><font size="2"   >&nbsp; v_conn_status text; &nbsp;-- 存储dblink_connect(v_conn_name, v_dst_server)的返回值</font></div><div><font size="2"   >&nbsp; v_nsp_name name := TG_TABLE_SCHEMA; &nbsp;-- 触发器变量, 触发这个触发器的表所在的schema</font></div><div><font size="2"   >&nbsp; v_table_name name := TG_TABLE_NAME; &nbsp;-- 触发器变量, 触发这个触发器的表名</font></div><div><font size="2"   >&nbsp; v_dst_nsp_name name := 'remote'; &nbsp;-- 目标schema, 当需要复制到其他schema下时, 这里改成其schema名即可</font></div><div><font size="2"   >&nbsp; v_dst_table_name name := 'rmt_test'; &nbsp;-- 目标表名</font></div><div><font size="2"   >&nbsp; v_query text; &nbsp;-- 使用dblink_build_sql_insert, dblink_build_sql_update, dblink_build_sql_delete得到的SQL, 用于调用dblink_exec远程执行.</font></div><div><font size="2"   >&nbsp; v_query_upd1 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_query_upd2 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_dst_query text; &nbsp;-- v_query修改后的语句, 主要就是修改目标schema和目标表名</font></div><div><font size="2"   >&nbsp; v_dst_query_upd1 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_dst_query_upd2 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_pk_vector int2vector; &nbsp;-- dblink_build_sql_insert, dblink_build_sql_update, dblink_build_sql_delete要用到的被复制的表的PK列s的逻辑位置</font></div><div><font size="2"   >&nbsp; v_pk_cnt int; &nbsp;-- dblink_build_sql_insert, dblink_build_sql_update, dblink_build_sql_delete要用到的被复制的表的PK列个数</font></div><div><font size="2"   >&nbsp; v_pk_att_vals_array text[]; &nbsp;-- pk值</font></div><div><font size="2"   >&nbsp; v_exec_status text; &nbsp;-- 存储dblink_exec(v_conn_name, v_dst_query, true|false)的返回值.</font></div><div><font size="2"   >&nbsp; -- multi master replication 需要以下参数分辨更新来源, 否则会出现环形触发.</font></div><div><font size="2"   >&nbsp; v_application_name text;</font></div><div><font size="2"   >&nbsp; v_pg_backend_pid int;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; -- 获取会话的postgres pid</font></div><div><font size="2"   >&nbsp; select pg_backend_pid() into v_pg_backend_pid;</font></div><div><font size="2"   >&nbsp; -- 根据这个PID获取application_name, 这个就可以用来区分是不是复制程序连上来的会话. 9.1(含9.1)以前的版本pg_stat_activity.procpid.</font></div><div><font size="2"   >&nbsp; select application_name into v_application_name from pg_stat_activity where pid=v_pg_backend_pid;</font></div><div><font size="2"   >&nbsp; -- 如果是复制程序连上来的会话, 直接返回null, 否则会出现环形触发.</font></div><div><font size="2"   >&nbsp; if (v_application_name = 'aaa_bbb_digoal' ) then</font></div><div><font size="2"   >&nbsp; &nbsp; return null;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; v_pk_vector := int2vector '1 2';</font></div><div><font size="2"   >&nbsp; v_pk_cnt := 2;</font></div><div><font size="2"   >&nbsp; -- v_pk_vector和v_pk_cnt也可以使用以下SQL得到.</font></div><div><font size="2"   >&nbsp; -- select string_agg(position::text,' ')::int2vector,count(*) into v_pk_vector,v_pk_cnt&nbsp;</font></div><div><font size="2"   >&nbsp; -- &nbsp;from dblink_get_pkey(v_nsp_name||'.'||v_table_name);</font></div><div><font size="2"   >&nbsp; case TG_OP</font></div><div><font size="2"   >&nbsp; when 'INSERT' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的insert语句, id是这个表的主键. 如果是多列值的则需要得到按v_pk_vector顺序的text[]</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||NEW.pk1||','||NEW.pk2||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query from dblink_build_sql_insert(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; when 'DELETE' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的delete语句, id是这个表的主键. 如果是多列值的则需要得到按v_pk_vector顺序的text[]</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||OLD.pk1||','||OLD.pk2||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query from dblink_build_sql_delete(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; when 'UPDATE' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的update语句, id是这个表的主键. 如果是多列值的则需要得到按v_pk_vector顺序的text[]</font></div><div><font size="2"   >&nbsp; &nbsp; -- 这里没有使用dblink_build_sql_update来生成update语句, 因为主键也可能被更新. 所以只能拆成两部分.</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||OLD.pk1||','||OLD.pk2||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query_upd1 from dblink_build_sql_delete(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||NEW.pk1||','||NEW.pk2||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query_upd2 from dblink_build_sql_insert(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; when 'TRUNCATE' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的truncate语句. 注意这里是truncate table only. 如果是子表, 可以在子表上继续减这样的触发器.</font></div><div><font size="2"   >&nbsp; &nbsp; v_query := 'truncate table only '||v_table_name;</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >&nbsp; -- 将目标schema和目标表名替换现有表名.</font></div><div><font size="2"   >&nbsp; case TG_OP</font></div><div><font size="2"   >&nbsp; when 'UPDATE' then</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query_upd1 := regexp_replace(v_query_upd1, v_table_name, v_dst_nsp_name||'.'||v_dst_table_name, '');</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query_upd2 := regexp_replace(v_query_upd2, v_table_name, v_dst_nsp_name||'.'||v_dst_table_name, '');</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query := v_dst_query_upd1||';'||v_dst_query_upd2;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query := regexp_replace(v_query, v_table_name, v_dst_nsp_name||'.'||v_dst_table_name, '');</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >&nbsp; -- 如果想打印用于复制的SQL是否正确, 可以使用以下语句 :&nbsp;</font></div><div><font size="2"   >&nbsp; -- raise notice 'v_dst_query:%', v_dst_query;</font></div><div><font size="2"   >&nbsp; -- 判断连接是否存在, 不存在则创建.</font></div><div><font size="2"   >&nbsp; if ( dblink_get_connections() @&gt; ('{'||v_conn_name||'}')::text[] ) then&nbsp;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_conn_status from dblink_connect(v_conn_name, v_dst_server);</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 如果远程执行失败,确保本地成功,本地写sync_err_rec</font></div><div><font size="2"   >&nbsp; select * into v_exec_status from dblink_exec(v_conn_name, v_dst_query, false);</font></div><div><font size="2"   >&nbsp; if (v_exec_status = 'ERROR') then</font></div><div><font size="2"   >&nbsp; &nbsp; insert into sync_err_rec (nsp_name, table_name, dst_server, dst_query, create_time)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_nsp_name, v_table_name, v_dst_server, v_dst_query, clock_timestamp());</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 如果想要远程失败,本地失败,本地不写sync_err_rec. 使用以下SQL替换前面几条SQL.&nbsp;</font></div><div><font size="2"   >&nbsp; -- 不了解的话可以去查询dblink_exec的详解.</font></div><div><font size="2"   >&nbsp; -- select * into v_exec_status from dblink_exec(v_conn_name, v_dst_query, true);</font></div><div><font size="2"   >&nbsp; -- -------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp; -- 不建议每次断开连接, 因为频繁的连接还是会带来很大开销的, 除非你在本地建立pgbouncer, 让pgbouncer来维持长连接.</font></div><div><font size="2"   >&nbsp; -- 断开连接的语句如下.</font></div><div><font size="2"   >&nbsp; -- select * into v_disconn_status from dblink_disconnect(v_conn_name);</font></div><div><font size="2"   >&nbsp; return null;</font></div><div><font size="2"   >exception</font></div><div><font size="2"   >when others then</font></div><div><font size="2"   >&nbsp; raise notice 'v_conn_status:%, v_exec_status:%.', v_conn_status, v_exec_status;</font></div><div><font size="2"   >&nbsp; insert into sync_err_rec (nsp_name, table_name, dst_server, dst_query, create_time)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; values (v_nsp_name, v_table_name, v_dst_server, v_dst_query, clock_timestamp());</font></div><div><font size="2"   >&nbsp; -- 如果想要远程失败,本地失败,本地不写sync_err_rec. 同时还需要以下语句.</font></div><div><font size="2"   >&nbsp; -- raise;</font></div><div><font size="2"   >&nbsp; return null;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$BODY$;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CREATE TRIGGER loc_test_sync_dml AFTER DELETE or UPDATE or INSERT ON loc_test FOR EACH ROW EXECUTE PROCEDURE f_sync_test();</font></div><div><font size="2"   >CREATE TRIGGER loc_test_sync_truncate AFTER TRUNCATE ON loc_test FOR EACH STATEMENT EXECUTE PROCEDURE f_sync_test();</font></div><p></p></pre></div><div><br></div><div>在remote数据库上创建触发器函数以及触发器 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >local=&gt; \c remote remote</font></div><div><font size="2"   >You are now connected to database "remote" as user "remote".</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CREATE OR REPLACE FUNCTION f_sync_test()</font></div><div><font size="2"   >RETURNS trigger</font></div><div><font size="2"   >LANGUAGE plpgsql</font></div><div><font size="2"   >AS $BODY$</font></div><div><font size="2"   >DECLARE</font></div><div><font size="2"   >&nbsp; v_dst_server text := 'dst'; &nbsp;-- foreign server</font></div><div><font size="2"   >&nbsp; v_conn_name text := v_dst_server; &nbsp;-- 连接名, 本例配置与dst_server一致.</font></div><div><font size="2"   >&nbsp; v_conn_status text; &nbsp;-- 存储dblink_connect(v_conn_name, v_dst_server)的返回值</font></div><div><font size="2"   >&nbsp; v_nsp_name name := TG_TABLE_SCHEMA; &nbsp;-- 触发器变量, 触发这个触发器的表所在的schema</font></div><div><font size="2"   >&nbsp; v_table_name name := TG_TABLE_NAME; &nbsp;-- 触发器变量, 触发这个触发器的表名</font></div><div><font size="2"   >&nbsp; v_dst_nsp_name name := 'local'; &nbsp;-- 目标schema, 当需要复制到其他schema下时, 这里改成其schema名即可</font></div><div><font size="2"   >&nbsp; v_dst_table_name name := 'loc_test'; &nbsp;-- 目标表名</font></div><div><font size="2"   >&nbsp; v_query text; &nbsp;-- 使用dblink_build_sql_insert, dblink_build_sql_update, dblink_build_sql_delete得到的SQL, 用于调用dblink_exec远程执行.</font></div><div><font size="2"   >&nbsp; v_query_upd1 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_query_upd2 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_dst_query text; &nbsp;-- v_query修改后的语句, 主要就是修改目标schema和目标表名</font></div><div><font size="2"   >&nbsp; v_dst_query_upd1 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_dst_query_upd2 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_pk_vector int2vector; &nbsp;-- dblink_build_sql_insert, dblink_build_sql_update, dblink_build_sql_delete要用到的被复制的表的PK列s的逻辑位置</font></div><div><font size="2"   >&nbsp; v_pk_cnt int; &nbsp;-- dblink_build_sql_insert, dblink_build_sql_update, dblink_build_sql_delete要用到的被复制的表的PK列个数</font></div><div><font size="2"   >&nbsp; v_pk_att_vals_array text[]; &nbsp;-- pk值</font></div><div><font size="2"   >&nbsp; v_exec_status text; &nbsp;-- 存储dblink_exec(v_conn_name, v_dst_query, true|false)的返回值.</font></div><div><font size="2"   >&nbsp; -- multi master replication 需要以下参数分辨更新来源, 否则会出现环形触发.</font></div><div><font size="2"   >&nbsp; v_application_name text;</font></div><div><font size="2"   >&nbsp; v_pg_backend_pid int;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; -- 获取会话的postgres pid</font></div><div><font size="2"   >&nbsp; select pg_backend_pid() into v_pg_backend_pid;</font></div><div><font size="2"   >&nbsp; -- 根据这个PID获取application_name, 这个就可以用来区分是不是复制程序连上来的会话.</font><span style="font-size: small; line-height: 19px;"   >9.1(含9.1)以前的版本pg_stat_activity.procpid.</span></div><div><font size="2"   >&nbsp; select application_name into v_application_name from pg_stat_activity where pid=v_pg_backend_pid;</font></div><div><font size="2"   >&nbsp; -- 如果是复制程序连上来的会话, 直接返回null, 否则会出现环形触发.</font></div><div><font size="2"   >&nbsp; if (v_application_name = 'aaa_bbb_digoal' ) then</font></div><div><font size="2"   >&nbsp; &nbsp; return null;</font></div><div><font size="2"   >&nbsp; end if; &nbsp;</font></div><div><font size="2"   >&nbsp; v_pk_vector := int2vector '1 2';</font></div><div><font size="2"   >&nbsp; v_pk_cnt := 2;</font></div><div><font size="2"   >&nbsp; -- v_pk_vector和v_pk_cnt也可以使用以下SQL得到.</font></div><div><font size="2"   >&nbsp; -- select string_agg(position::text,' ')::int2vector,count(*) into v_pk_vector,v_pk_cnt&nbsp;</font></div><div><font size="2"   >&nbsp; -- &nbsp;from dblink_get_pkey(v_nsp_name||'.'||v_table_name);</font></div><div><font size="2"   >&nbsp; case TG_OP</font></div><div><font size="2"   >&nbsp; when 'INSERT' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的insert语句, id是这个表的主键. 如果是多列值的则需要得到按v_pk_vector顺序的text[]</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||NEW.pk1||','||NEW.pk2||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query from dblink_build_sql_insert(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; when 'DELETE' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的delete语句, id是这个表的主键. 如果是多列值的则需要得到按v_pk_vector顺序的text[]</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||OLD.pk1||','||OLD.pk2||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query from dblink_build_sql_delete(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; when 'UPDATE' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的update语句, id是这个表的主键. 如果是多列值的则需要得到按v_pk_vector顺序的text[]</font></div><div><font size="2"   >&nbsp; &nbsp; -- 这里没有使用dblink_build_sql_update来生成update语句, 因为主键也可能被更新. 所以只能拆成两部分.</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||OLD.pk1||','||OLD.pk2||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query_upd1 from dblink_build_sql_delete(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||NEW.pk1||','||NEW.pk2||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query_upd2 from dblink_build_sql_insert(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; when 'TRUNCATE' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的truncate语句. 注意这里是truncate table only. 如果是子表, 可以在子表上继续减这样的触发器.</font></div><div><font size="2"   >&nbsp; &nbsp; v_query := 'truncate table only '||v_table_name;</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >&nbsp; -- 将目标schema和目标表名替换现有表名.</font></div><div><font size="2"   >&nbsp; case TG_OP</font></div><div><font size="2"   >&nbsp; when 'UPDATE' then</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query_upd1 := regexp_replace(v_query_upd1, v_table_name, v_dst_nsp_name||'.'||v_dst_table_name, '');</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query_upd2 := regexp_replace(v_query_upd2, v_table_name, v_dst_nsp_name||'.'||v_dst_table_name, '');</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query := v_dst_query_upd1||';'||v_dst_query_upd2;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query := regexp_replace(v_query, v_table_name, v_dst_nsp_name||'.'||v_dst_table_name, '');</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >&nbsp; -- 如果想打印用于复制的SQL是否正确, 可以使用以下语句 :&nbsp;</font></div><div><font size="2"   >&nbsp; -- raise notice 'v_dst_query:%', v_dst_query;</font></div><div><font size="2"   >&nbsp; -- 判断连接是否存在, 不存在则创建.</font></div><div><font size="2"   >&nbsp; if ( dblink_get_connections() @&gt; ('{'||v_conn_name||'}')::text[] ) then&nbsp;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_conn_status from dblink_connect(v_conn_name, v_dst_server);</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 如果远程执行失败,确保本地成功,本地写sync_err_rec</font></div><div><font size="2"   >&nbsp; select * into v_exec_status from dblink_exec(v_conn_name, v_dst_query, false);</font></div><div><font size="2"   >&nbsp; if (v_exec_status = 'ERROR') then</font></div><div><font size="2"   >&nbsp; &nbsp; insert into sync_err_rec (nsp_name, table_name, dst_server, dst_query, create_time)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_nsp_name, v_table_name, v_dst_server, v_dst_query, clock_timestamp());</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 如果想要远程失败,本地失败,本地不写sync_err_rec. 使用以下SQL替换前面几条SQL.&nbsp;</font></div><div><font size="2"   >&nbsp; -- 不了解的话可以去查询dblink_exec的详解.</font></div><div><font size="2"   >&nbsp; -- select * into v_exec_status from dblink_exec(v_conn_name, v_dst_query, true);</font></div><div><font size="2"   >&nbsp; -- -------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp; -- 不建议每次断开连接, 因为频繁的连接还是会带来很大开销的, 除非你在本地建立pgbouncer, 让pgbouncer来维持长连接.</font></div><div><font size="2"   >&nbsp; -- 断开连接的语句如下.</font></div><div><font size="2"   >&nbsp; -- select * into v_disconn_status from dblink_disconnect(v_conn_name);</font></div><div><font size="2"   >&nbsp; return null;</font></div><div><font size="2"   >exception</font></div><div><font size="2"   >when others then</font></div><div><font size="2"   >&nbsp; raise notice 'v_conn_status:%, v_exec_status:%.', v_conn_status, v_exec_status;</font></div><div><font size="2"   >&nbsp; insert into sync_err_rec (nsp_name, table_name, dst_server, dst_query, create_time)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; values (v_nsp_name, v_table_name, v_dst_server, v_dst_query, clock_timestamp());</font></div><div><font size="2"   >&nbsp; -- 如果想要远程失败,本地失败,本地不写sync_err_rec. 同时还需要以下语句.</font></div><div><font size="2"   >&nbsp; -- raise;</font></div><div><font size="2"   >&nbsp; return null;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$BODY$;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CREATE TRIGGER rmt_test_sync_dml AFTER DELETE or UPDATE or INSERT ON rmt_test FOR EACH ROW EXECUTE PROCEDURE f_sync_test();</font></div><div><font size="2"   >CREATE TRIGGER rmt_test_sync_truncate AFTER TRUNCATE ON rmt_test FOR EACH STATEMENT EXECUTE PROCEDURE f_sync_test();</font></div><p></p></pre></div><div><br></div><div>在local和remote数据库上都创建deal_sync_err_rec函数, 用来处理同步错误的记录.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create or replace function deal_sync_err_rec (i_limit int) returns boolean as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; v_conn_name text; &nbsp;-- 连接名</font></div><div><font size="2"   >&nbsp; v_conn_status text; &nbsp;-- 存储dblink_connect(v_conn_name, v_dst_server)的返回值</font></div><div><font size="2"   >&nbsp; v_exec_status text; &nbsp;-- 存储dblink_exec(v_conn_name, v_dst_query, true|false)的返回值.</font></div><div><font size="2"   >&nbsp; v_dst_server text; &nbsp;-- foreign server, 一次取一个. 根据这个dst_server再抽取错误的同步记录, 进行处理.</font></div><div><font size="2"   >&nbsp; v_dst_query text; &nbsp;-- sync_err_rec中记录的SQL语句</font></div><div><font size="2"   >&nbsp; v_id int8[]; &nbsp;-- sync_err_rec的主键, 用于记录一批记录, BATCH删除.</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; -- 取出最早的记录的dst_server, 接下来将处理这个dst_server发生的错误.</font></div><div><font size="2"   >&nbsp; </font><font size="2"   style="line-height: 19px;"   >select dst_server&nbsp;</font><span style="line-height: 19px; font-size: small;"   >into v_dst_server</span><span style="line-height: 22px;"   > </span><span style="line-height: 19px; font-size: small;"   >from sync_err_rec order by create_time limit 1;</span></div><div><font size="2"   >&nbsp; -- 空表示没有记录直接返回</font></div><div><font size="2"   >&nbsp; if (v_dst_server is NULL) then</font></div><div><font size="2"   >&nbsp; &nbsp; return true;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 将v_dst_server的值赋予给连接名</font></div><div><font size="2"   >&nbsp; v_conn_name := v_dst_server;</font></div><div><font size="2"   >&nbsp; -- 取出一批记录</font></div><div><font size="2"   >&nbsp; select array_agg(id), string_agg(dst_query, ';') into v_id, v_dst_query from&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; (select id,dst_query from sync_err_rec where dst_server=v_dst_server order by create_time limit i_limit) t;</font></div><div><font size="2"   >&nbsp; -- 删除sync_err_rec中对应的记录.</font></div><div><font size="2"   >&nbsp; delete from sync_err_rec where id in (select unnest(v_id));</font></div><div><font size="2"   >&nbsp; if ( dblink_get_connections() @&gt; ('{'||v_conn_name||'}')::text[] ) then&nbsp;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_conn_status from dblink_connect(v_conn_name, v_dst_server);</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 这里使用的是true, 所以远程异常, 本地也异常. 确保到这一步还可以回退, 只要这一步执行成功, 那本地删除的sync_err_rec和远程都执行成功.</font></div><div><font size="2"   >&nbsp; select * into v_exec_status from dblink_exec(v_conn_name, v_dst_query, true);</font></div><div><font size="2"   >&nbsp; -- raise notice 'v_conn_status:%, v_exec_status:%.', v_conn_status, v_exec_status;</font></div><div><font size="2"   >&nbsp; return true;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><p></p></pre></div><div><br></div><div>接下来开始测试 :&nbsp;</div><div>1. 在local库测试DML以及truncate</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >remote=&gt; \c local local</font></div><div><font size="2"   >You are now connected to database "local" as user "local".</font></div></div><div><div><font size="2"   >local=&gt; insert into &nbsp;loc_test select generate_series(1,10000),'digoal'||random(),'test'||random(),now(),clock_timestamp();</font></div><div><font size="2"   >INSERT 0 10000</font></div></div><div><font size="2"   >比对两库有无差异</font></div><div><div style="line-height: 22px;"   ><font size="2"   >local :&nbsp;</font></div><div><div><font size="2"   >local=&gt; select sum(hashtext(t.*::text)),count(*) from loc_test t;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;| count&nbsp;</font></div><div><font size="2"   >--------------+-------</font></div><div><font size="2"   >&nbsp;-74860910528 | 10000</font></div><div><font size="2"   >(1 row)</font></div></div><div style="line-height: 22px;"   ><font size="2"   ><br style="line-height: 22px;"   ></font></div><div style="line-height: 22px;"   ><font size="2"   >remote :&nbsp;</font></div><div><div><font size="2"   >remote=&gt; select sum(hashtext(t.*::text)),count(*) from rmt_test t;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;| count&nbsp;</font></div><div><font size="2"   >--------------+-------</font></div><div><font size="2"   >&nbsp;-74860910528 | 10000</font></div><div><font size="2"   >(1 row)</font></div></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >local=&gt; update loc_test set info=pk2;</font></div><div><font size="2"   >UPDATE 10000</font></div></div><div><div style="line-height: 22px;"   ><font size="2"   >比对两库有无差异</font></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><font size="2"   >local :&nbsp;</font></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><font size="2"   >local=&gt; select sum(hashtext(t.*::text)),count(*) from loc_test t;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;| count&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >--------------+-------</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;-119013305607 | 10000</font></div><div style="line-height: 22px;"   ><font size="2"   >(1 row)</font></div></div><div style="line-height: 22px;"   ><font size="2"   ><br style="line-height: 22px;"   ></font></div><div style="line-height: 22px;"   ><font size="2"   >remote :&nbsp;</font></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><font size="2"   >remote=&gt; select sum(hashtext(t.*::text)),count(*) from rmt_test t;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;| count&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >--------------+-------</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;-119013305607 | 10000</font></div><div style="line-height: 22px;"   ><font size="2"   >(1 row)</font></div></div></div></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div><div><font size="2"   >local=&gt; delete from loc_test where pk1&lt;1000;</font></div><div><font size="2"   >DELETE 999</font></div></div><div><div style="line-height: 22px;"   ><font size="2"   >比对两库有无差异</font></div><div><div style="line-height: 22px;"   ><font size="2"   >local :&nbsp;</font></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><font size="2"   >local=&gt; select sum(hashtext(t.*::text)),count(*) from loc_test t;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;| count&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >--------------+-------</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;-100635112078 | &nbsp;9001</font></div><div style="line-height: 22px;"   ><font size="2"   >(1 row)</font></div></div><div style="line-height: 22px;"   ><font size="2"   ><br style="line-height: 22px;"   ></font></div><div style="line-height: 22px;"   ><font size="2"   >remote :&nbsp;</font></div><div><div style="line-height: 22px;"   ><font size="2"   >remote=&gt; select sum(hashtext(t.*::text)),count(*) from rmt_test t;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;| count&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >--------------+-------</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;-100635112078 | &nbsp;9001</font></div><div style="line-height: 22px;"   ><font size="2"   >(1 row)</font></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div><div><font size="2"   >local=&gt; truncate loc_test ;</font></div><div><font size="2"   >TRUNCATE TABLE</font></div></div></div></div></div><div><div style="line-height: 22px;"   ><font size="2"   >比对两库有无差异</font></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><font size="2"   >local :&nbsp;</font></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><font size="2"   >local=&gt; select sum(hashtext(t.*::text)),count(*) from loc_test t;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;| count&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >--------------+-------</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 0</font></div><div style="line-height: 22px;"   ><font size="2"   >(1 row)</font></div></div><div style="line-height: 22px;"   ><font size="2"   ><br style="line-height: 22px;"   ></font></div><div style="line-height: 22px;"   ><font size="2"   >remote :&nbsp;</font></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><font size="2"   >remote=&gt; select sum(hashtext(t.*::text)),count(*) from rmt_test t;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;| count&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >--------------+-------</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; 0</font></div><div style="line-height: 22px;"   ><font size="2"   >(1 row)</font></div></div></div></div><p></p></pre></div><div style="line-height: 22px;"   ><br></div><div><span style="line-height: 22px;"   >2. 在remote库测试DML以及truncate</span> </div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><font size="2"   ><div>remote=&gt; insert into rmt_test select generate_series(1,10000),'digoal'||random(),'test'||random(),now(),clock_timestamp();</div><div>INSERT 0 10000</div><div><span style="line-height: 22px;"   >比对两库有无差异</span></div></font></span></div><div><div style="line-height: 22px;"   ><font size="2"   >local :&nbsp;</font></div><div><div><font size="2"   >local=&gt; select sum(hashtext(t.*::text)),count(*) from loc_test t;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;| count&nbsp;</font></div><div><font size="2"   >--------------+-------</font></div><div><font size="2"   >&nbsp;-25035561749 | 10000</font></div><div><font size="2"   >(1 row)</font></div></div><div style="line-height: 22px;"   ><font size="2"   ><br style="line-height: 22px;"   ></font></div><div style="line-height: 22px;"   ><font size="2"   >remote :&nbsp;</font></div><div><div><font size="2"   >remote=&gt; select sum(hashtext(t.*::text)),count(*) from rmt_test t;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;| count&nbsp;</font></div><div><font size="2"   >--------------+-------</font></div><div><font size="2"   >&nbsp;-25035561749 | 10000</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >UPDATE, DELETE, TRUNCATE得到的结果local, remote库都一致, 这里不再列出.</font></div></div><p></p></pre></div><div><div style="line-height: 22px;"   ><br></div></div><div><span style="line-height: 22px;"   >3. 测试异常, 把remote的login权限去除, 然后在local库插入10000条记录, 可以看到记录被写入了loc_test同时也写入了sync_err_rec表.</span></div><div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >remote=# alter role remote nologin;</font></div><div style="line-height: 22px;"   ><font size="2"   >ALTER ROLE</font></div><p></p></pre></div><div style="line-height: 22px;"   >注意要把所有连接remote的用户全部踢掉, 否则local还连在remote上, 测试将得不到要的结果.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >remote=# select pg_terminate_backend(pid) from pg_stat_activity where usename='remote';</font></div><div><font size="2"   >&nbsp;pg_terminate_backend&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;t</font></div><p></p></pre></div><div><br></div></div><div style="line-height: 22px;"   >在local库插入10000条记录</div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >\c local local</font></div><div><font size="2"   >local=&gt; insert into loc_test select generate_series(1,10000),'digoal'||random(),'test'||random(),now(),clock_timestamp();</font></div><p></p></pre></div></div><div>将报出10000条如下NOTICE</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >NOTICE: &nbsp;v_conn_status:&lt;NULL&gt;, v_exec_status:&lt;NULL&gt;.</font></div><div><font size="2"   >INSERT 0 10000</font></div><p></p></pre></div><div>查看loc_test 以及 sync_err_rec.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >local=&gt; select count(*) from loc_test ;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;10000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >local=&gt; select count(*) from sync_err_rec;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;10000</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>4. 处理异常记录, 先把remote用户的login权限加上, 然后到local库调用deal_sync_err_rec函数.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >local=&gt; \c remote postgres</font></div><div><font size="2"   >You are now connected to database "remote" as user "postgres".</font></div><div><font size="2"   >remote=# alter role remote login;</font></div><div><font size="2"   >ALTER ROLE</font></div></div><div><font size="2"   >处理1000条错误同步记录.</font></div><div><div><font size="2"   >remote=# \c local local</font></div><div><font size="2"   >You are now connected to database "local" as user "local".</font></div><div><font size="2"   >local=&gt; select * from deal_sync_err_rec(1000);</font></div><div><font size="2"   >&nbsp;deal_sync_err_rec&nbsp;</font></div><div><font size="2"   >-------------------</font></div><div><font size="2"   >&nbsp;t</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >看到<span style="line-height: 22px;"   >sync_err_rec减少了1000条记录.</span></font></div><div><font size="2"   >local=&gt; select count(*) from sync_err_rec;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; 9000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >远程库将多出1000条记录.</font></div><div><font size="2"   >local=&gt; \c remote remote</font></div><div><font size="2"   >You are now connected to database "remote" as user "remote".</font></div><div><font size="2"   >remote=&gt; select count(*) from rmt_test ;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; 1000</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >继续将所有的错误记录都修复.</font></div><div><div><font size="2"   >local=&gt; select * from deal_sync_err_rec(10000);</font></div><div><font size="2"   >&nbsp;deal_sync_err_rec&nbsp;</font></div><div><font size="2"   >-------------------</font></div><div><font size="2"   >&nbsp;t</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >现在sync_err_rec中将没有记录.</font></div><div><div><font size="2"   >local=&gt; select count(*) from sync_err_rec;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   ><span style="line-height: 22px;"   >比对两库有无差异</span> </font></div><div><font size="2"   >local :&nbsp;</font></div><div><font size="2"   >select sum(hashtext(t.*::text)),count(*) from loc_test t;</font></div><div><div><font size="2"   >local=&gt; select sum(hashtext(t.*::text)),count(*) from loc_test t;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;| count&nbsp;</font></div><div><font size="2"   >--------------+-------</font></div><div><font size="2"   >&nbsp;-29845555432 | 10000</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >remote :&nbsp;</font></div><div><div><font size="2"   >remote=&gt; select sum(hashtext(t.*::text)),count(*) from rmt_test t;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;sum &nbsp; &nbsp; &nbsp;| count&nbsp;</font></div><div><font size="2"   >--------------+-------</font></div><div><font size="2"   >&nbsp;-29845555432 | 10000</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div><br></div><div>初步测试完全正常.</div><div><br></div><div>【小结】</div><div>1. multi - master复制需要解决冲突的问题.</div><div>&nbsp; 本例没有实现冲突解决, 只将同步错误记录到sync_err_rec表.</div><div>&nbsp; 在设计多主复制时, 应该尽可能避免两边更新同一条记录, 可以考虑两边使用不同的主键取值范围.</div><div>&nbsp; &nbsp; 例如A库的主键是mod(id,2)=0;</div><div>&nbsp; &nbsp; B库的主键是mod(id,2)=1;</div><div>&nbsp; &nbsp; 这样可以避免两边去操作同一条记录.</div><div><br></div>2. 认真看的朋友一定会发现, 这里的复制存在一个比较大的漏洞, 当异常发生后, 记录写入sync_err_rec表, 但是当恢复正常后, 如果又发生了DML操作, 远程数据库执行SQL的顺序将发生颠倒, 也就是说sync_err_rec里面记录的SQL还未执行, 由触发器触发的SQL已经开始执行了.&nbsp;</div><div>打个比方,&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >1. sync_err_rec中有一条(UPDATE) DELETE from remote.rmt_test where&nbsp;<span style="line-height: 22px;"   >pk1=1 and pk2='digoal';INSERT into</span>&nbsp;remote.rmt_test values(1, 'digoal', 'test',...);</font></div><div><font size="2"   >2. 恢复正常后. 又对loc_test进行了2个DML操作.&nbsp;</font></div><div><font size="2"   >DELETE from&nbsp;<span style="line-height: 22px;"   >local.loc_test where&nbsp;</span><span style="line-height: 22px;"   >pk1=1 and pk2='digoal';</span>&nbsp;</font></div><div><font size="2"   >INSERT INTO&nbsp;<span style="line-height: 22px;"   >local.loc_test values(1, 'digoal', 'DDDDDDDDD',....);</span></font></div><div><font size="2"   ><span style="line-height: 22px;"   >此时在remote库, 应该是</span><span style="line-height: 22px;"   >remote.rmt_test values(1, 'digoal', 'DDDDDDDDD',....)的记录存在.</span></font></div><div><font size="2"   ><span style="line-height: 22px;"   >3. 修复sync_err_rec的记录. 那么会抹去</span><span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >remote.rmt_test values(1, 'digoal', 'DDDDDDDDD',....);这条记录, 变成老的记录</span><span style="line-height: 22px;"   >remote.rmt_test values(1, 'digoal', 'test',...) .</span></font></div><p></p></pre></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >怎么修复这个问题呢?</span></div><div>1. 在loc_test的触发器中调用deal_sync_err_rec可行吗?&nbsp;</div><div>如果可行, 必须一次性处理掉所有dst_server在sync_err_rec中的所有记录. 也是个麻烦事. (如果异常记录太多的话).</div><div>确保sync_err_rec中的记录只允许在远程执行一次, &nbsp;如果是并发的触发<span style="line-height: 22px;"   >deal_sync_err_rec会不会有问题 ?&nbsp;</span></div><div><span style="line-height: 22px;"   >我们来看看deal_sync_err_rec这个函数 :&nbsp;</span></div><div><pre class="prettyprint"   ><p><span style="line-height: 22px;"   ><font size="2"   ></font></span></p><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; -- 取出最早的记录的dst_server, 接下来将处理这个dst_server发生的错误.</font></div><div><font size="2"   ><span style="line-height: 22px;"   >&nbsp; -- 如果是并发执行, sync_err_rec中的同样的记录可能会被多个会话取到.</span> </font></div><div><font size="2"   >&nbsp; </font><font size="2"   style="line-height: 19px;"   >select dst_server&nbsp;</font><span style="line-height: 19px; font-size: small;"   >into v_dst_server</span><span style="line-height: 22px;"   > </span><span style="line-height: 19px; font-size: small;"   >from sync_err_rec order by create_time limit 1;</span></div><div><font size="2"   >&nbsp; -- 空表示没有记录直接返回</font></div><div><font size="2"   >&nbsp; if (v_dst_server is NULL) then</font></div><div><font size="2"   >&nbsp; &nbsp; return true;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 将v_dst_server的值赋予给连接名</font></div><div><font size="2"   >&nbsp; v_conn_name := v_dst_server;</font></div><div><font size="2"   >&nbsp; -- 取出一批记录</font></div><div><font size="2"   ><span style="line-height: 22px;"   >&nbsp; -- 如果是并发执行, sync_err_rec中的同样的记录可能会被多个会话取到.</span> </font></div><div><font size="2"   >&nbsp; select array_agg(id), string_agg(dst_query, ';') into v_id, v_dst_query from&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; (select id,dst_query from sync_err_rec where dst_server=v_dst_server order by create_time limit i_limit) t;</font></div><div><font size="2"   >&nbsp; -- 删除sync_err_rec中对应的记录.</font></div><div><font size="2"   >&nbsp; -- 当某个会话先获得了这些记录的行锁, 那么delete执行后删除掉的行总数应该等于<span style="line-height: 22px;"   >select unnest(v_id)的记录数.</span></font></div><div><font size="2"   ><span style="line-height: 22px;"   >&nbsp; -- 而等待中的会话删除的行数应该是0. 但是不会报错, 只是要等别人释放这些行锁. 这里就是并行执行</span><span style="line-height: 22px;"   >deal_sync_err_rec的问题所在.</span></font></div><div><font size="2"   ><span style="line-height: 22px;"   >&nbsp; -- 修复并行执行</span><span style="line-height: 22px;"   >deal_sync_err_rec的问题, 这里要加一个判断, 如果删除行数不等于</span><span style="line-height: 22px;"   >select unnest(v_id)的记录数. 返回异常.</span></font></div><div><font size="2"   ><span style="line-height: 22px;"   >&nbsp; -- 那么loc_test的触发器函数在接收到这个异常后, 将会记录这次触发DML或者TRUNCATE的SQL到sync_err_rec表,&nbsp;</span></font></div><div><font size="2"   ><span style="line-height: 22px;"   >&nbsp; -- 也不会去调用</span><span style="line-height: 22px;"   >dblink_exec(v_conn_name, v_dst_query, true);远程执行.&nbsp;</span></font></div><div><font size="2"   ><span style="line-height: 22px;"   >&nbsp; -- 但是问题又来了, 在(1.成功执行</span><span style="line-height: 22px;"   >deal_sync_err_rec的会话后) 和 (2.</span><span style="line-height: 22px;"   >记录这次触发DML或者TRUNCATE的SQL到sync_err_rec表前) 之间,&nbsp;</span></font></div><div><font size="2"   ><span style="line-height: 22px;"   >&nbsp; --&nbsp;</span><span style="line-height: 22px;"   >sync_err_rec</span><span style="line-height: 22px;"   >这个表里面的数据对其他会话来说是无记录的, 也就是说其他会话的DML将复制到远程, 又发生SQL执行顺序的问题了.</span></font></div><span style="line-height: 22px;"   ><div><font size="2"   >&nbsp; delete from sync_err_rec where id in (select unnest(v_id));</font></div><div><font size="2"   >&nbsp; if ( dblink_get_connections() @&gt; ('{'||v_conn_name||'}')::text[] ) then&nbsp;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_conn_status from dblink_connect(v_conn_name, v_dst_server);</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 这里使用的是true, 所以远程异常, 本地也异常. 确保到这一步还可以回退, 只要这一步执行成功, 那本地删除的sync_err_rec和远程都执行成功.</font></div><div><font size="2"   >&nbsp; select * into v_exec_status from dblink_exec(v_conn_name, v_dst_query, true);</font></div><div><font size="2"   >&nbsp; -- raise notice 'v_conn_status:%, v_exec_status:%.', v_conn_status, v_exec_status;</font></div><div><font size="2"   >&nbsp; return true;</font></div><div><font size="2"   >END;</font></div></span><p></p></pre><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >结论, </span><span style="line-height: 22px;"   >在loc_test的触发器中调用deal_sync_err_rec不可行.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >那么更好的办法是, 如果发现</span><span style="line-height: 22px;"   >sync_err_rec有对应的dst_server的记录,</span><span style="line-height: 22px;"   >那就直接往</span><span style="line-height: 22px;"   >sync_err_rec里面写, 而不要复制到远程.</span><span style="line-height: 22px;"   >&nbsp;(或者</span><span style="line-height: 22px;"   >sync_err_rec</span><span style="line-height: 22px;"   >没有记录, 并且sync_err_rec被其他会话加了</span>RowExclusiveLock<span style="line-height: 22px;"   >锁, 此时可能正在处理sync_err_rec中的记录或者其他会话在写入,&nbsp;</span> <span style="line-height: 22px;"   >那也要直接往</span><span style="line-height: 22px;"   >sync_err_rec里面写, 而不要复制到远程.</span>&nbsp;<span style="line-height: 22px;"   >最终都是为了保证SQL的执行顺序),</span><span style="line-height: 22px;"   >&nbsp;让deal_sync_err_rec来处理异常. 所以需要修改被复制表的触发器函数.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >修改后的函数如下 :&nbsp;</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >1.&nbsp;</span><span style="line-height: 22px;"   >deal_sync_err_rec函数增加显锁</span></div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; </font><font size="2"   style="line-height: 19px;"   >select dst_server&nbsp;</font><span style="line-height: 19px; font-size: small;"   >into v_dst_server</span><span style="line-height: 22px;"   > </span><span style="line-height: 19px; font-size: small;"   >from sync_err_rec order by create_time limit 1 for update;</span></div><p></p></pre></div><div>完全函数 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create or replace function deal_sync_err_rec (i_limit int) returns boolean as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; v_conn_name text; &nbsp;-- 连接名</font></div><div><font size="2"   >&nbsp; v_conn_status text; &nbsp;-- 存储dblink_connect(v_conn_name, v_dst_server)的返回值</font></div><div><font size="2"   >&nbsp; v_exec_status text; &nbsp;-- 存储dblink_exec(v_conn_name, v_dst_query, true|false)的返回值.</font></div><div><font size="2"   >&nbsp; v_dst_server text; &nbsp;-- foreign server, 一次取一个. 根据这个dst_server再抽取错误的同步记录, 进行处理.</font></div><div><font size="2"   >&nbsp; v_dst_query text; &nbsp;-- sync_err_rec中记录的SQL语句</font></div><div><font size="2"   >&nbsp; v_id int8[]; &nbsp;-- sync_err_rec的主键, 用于记录一批记录, BATCH删除.</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; -- 取出最早的记录的dst_server, 加上RowExclusiveLock锁, 接下来将处理这个dst_server发生的错误.</font></div><div><font size="2"   >&nbsp; </font><font size="2"   style="line-height: 19px;"   >select dst_server&nbsp;</font><span style="line-height: 19px; font-size: small;"   >into v_dst_server</span><span style="line-height: 22px;"   > </span><span style="line-height: 19px; font-size: small;"   >from sync_err_rec order by create_time limit 1 for update;</span></div><div><font size="2"   >&nbsp; -- 空表示没有记录直接返回</font></div><div><font size="2"   >&nbsp; if (v_dst_server is NULL) then</font></div><div><font size="2"   >&nbsp; &nbsp; return true;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 将v_dst_server的值赋予给连接名</font></div><div><font size="2"   >&nbsp; v_conn_name := v_dst_server;</font></div><div><font size="2"   >&nbsp; -- 取出一批记录</font></div><div><font size="2"   >&nbsp; select array_agg(id), string_agg(dst_query, ';') into v_id, v_dst_query from&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; (select id,dst_query from sync_err_rec where dst_server=v_dst_server order by create_time limit i_limit) t;</font></div><div><font size="2"   >&nbsp; -- 删除sync_err_rec中对应的记录.</font></div><div><font size="2"   >&nbsp; delete from sync_err_rec where id in (select unnest(v_id));</font></div><div><font size="2"   >&nbsp; if ( dblink_get_connections() @&gt; ('{'||v_conn_name||'}')::text[] ) then&nbsp;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_conn_status from dblink_connect(v_conn_name, v_dst_server);</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 这里使用的是true, 所以远程异常, 本地也异常. 确保到这一步还可以回退, 只要这一步执行成功, 那本地删除的sync_err_rec和远程都执行成功.</font></div><div><font size="2"   >&nbsp; select * into v_exec_status from dblink_exec(v_conn_name, v_dst_query, true);</font></div><div><font size="2"   >&nbsp; -- raise notice 'v_conn_status:%, v_exec_status:%.', v_conn_status, v_exec_status;</font></div><div><font size="2"   >&nbsp; return true;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >2. 触发器函数增加逻辑</span></div><div><span style="line-height: 22px;"   ><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; -- 判断sync_err_rec是否被其他会话加RowExclusiveLock锁. 如果发现, 往sync_err_rec写入触发SQL,&nbsp;</font></div><div><font size="2"   >&nbsp; -- 返回NULL. 不再继续调用dblink_exec(v_conn_name, v_dst_query, false)</font></div><div><font size="2"   >&nbsp; perform 1 from pg_locks where&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; relation=(select oid from pg_class where relname='sync_err_rec')&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; and pid != pg_backend_pid()</font></div><div><font size="2"   >&nbsp; &nbsp; and mode='RowExclusiveLock'</font></div><div><font size="2"   >&nbsp; &nbsp; limit 1;</font></div><div><font size="2"   >&nbsp; if found then</font></div><div><font size="2"   >&nbsp; &nbsp; insert into sync_err_rec (nsp_name, table_name, dst_server, dst_query, create_time)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_nsp_name, v_table_name, v_dst_server, v_dst_query, clock_timestamp());</font></div><div><font size="2"   >&nbsp; &nbsp; return null;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 判断sync_err_rec中是否有dst_server=v_dst_server的记录. 如果发现, 往sync_err_rec写入触发SQL,&nbsp;</font></div><div><font size="2"   >&nbsp; -- 返回NULL. 不再继续调用dblink_exec(v_conn_name, v_dst_query, false)</font></div><div><font size="2"   >&nbsp; perform 1 from sync_err_rec where dst_server=v_dst_server limit 1;</font></div><div><font size="2"   >&nbsp; if found then</font></div><div><font size="2"   >&nbsp; &nbsp; insert into sync_err_rec (nsp_name, table_name, dst_server, dst_query, create_time)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_nsp_name, v_table_name, v_dst_server, v_dst_query, clock_timestamp());</font></div><div><font size="2"   >&nbsp; &nbsp; return null;</font></div><div><font size="2"   >&nbsp; end if;</font></div><p></p></pre></div><div>完全函数 :&nbsp;</div></span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE OR REPLACE FUNCTION f_sync_test()</font></div><div><font size="2"   >RETURNS trigger</font></div><div><font size="2"   >LANGUAGE plpgsql</font></div><div><font size="2"   >AS $BODY$</font></div><div><font size="2"   >DECLARE</font></div><div><font size="2"   >&nbsp; v_dst_server text := 'dst'; &nbsp;-- foreign server</font></div><div><font size="2"   >&nbsp; v_conn_name text := v_dst_server; &nbsp;-- 连接名, 本例配置与dst_server一致.</font></div><div><font size="2"   >&nbsp; v_conn_status text; &nbsp;-- 存储dblink_connect(v_conn_name, v_dst_server)的返回值</font></div><div><font size="2"   >&nbsp; v_nsp_name name := TG_TABLE_SCHEMA; &nbsp;-- 触发器变量, 触发这个触发器的表所在的schema</font></div><div><font size="2"   >&nbsp; v_table_name name := TG_TABLE_NAME; &nbsp;-- 触发器变量, 触发这个触发器的表名</font></div><div><font size="2"   >&nbsp; v_dst_nsp_name name := 'remote'; &nbsp;-- 目标schema, 当需要复制到其他schema下时, 这里改成其schema名即可</font></div><div><font size="2"   >&nbsp; v_dst_table_name name := 'rmt_test'; &nbsp;-- 目标表名</font></div><div><font size="2"   >&nbsp; v_query text; &nbsp;-- 使用dblink_build_sql_insert, dblink_build_sql_update, dblink_build_sql_delete得到的SQL, 用于调用dblink_exec远程执行.</font></div><div><font size="2"   >&nbsp; v_query_upd1 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_query_upd2 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_dst_query text; &nbsp;-- v_query修改后的语句, 主要就是修改目标schema和目标表名</font></div><div><font size="2"   >&nbsp; v_dst_query_upd1 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_dst_query_upd2 text; &nbsp;-- update需要用到delete和insert</font></div><div><font size="2"   >&nbsp; v_pk_vector int2vector; &nbsp;-- dblink_build_sql_insert, dblink_build_sql_update, dblink_build_sql_delete要用到的被复制的表的PK列s的逻辑位置</font></div><div><font size="2"   >&nbsp; v_pk_cnt int; &nbsp;-- dblink_build_sql_insert, dblink_build_sql_update, dblink_build_sql_delete要用到的被复制的表的PK列个数</font></div><div><font size="2"   >&nbsp; v_pk_att_vals_array text[]; &nbsp;-- pk值</font></div><div><font size="2"   >&nbsp; v_exec_status text; &nbsp;-- 存储dblink_exec(v_conn_name, v_dst_query, true|false)的返回值.</font></div><div><font size="2"   >&nbsp; -- multi master replication 需要以下参数分辨更新来源, 否则会出现环形触发.</font></div><div><font size="2"   >&nbsp; v_application_name text;</font></div><div><font size="2"   >&nbsp; v_pg_backend_pid int;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; -- 获取会话的postgres pid</font></div><div><font size="2"   >&nbsp; select pg_backend_pid() into v_pg_backend_pid;</font></div><div><font size="2"   >&nbsp; -- 根据这个PID获取application_name, 这个就可以用来区分是不是复制程序连上来的会话.</font><span style="font-size: small; line-height: 19px;"   >9.1(含9.1)以前的版本pg_stat_activity.procpid.</span></div><div><font size="2"   >&nbsp; select application_name into v_application_name from pg_stat_activity where pid=v_pg_backend_pid;</font></div><div><font size="2"   >&nbsp; -- 如果是复制程序连上来的会话, 直接返回null, 否则会出现环形触发.</font></div><div><font size="2"   >&nbsp; if (v_application_name = 'aaa_bbb_digoal' ) then</font></div><div><font size="2"   >&nbsp; &nbsp; return null;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; v_pk_vector := int2vector '1 2';</font></div><div><font size="2"   >&nbsp; v_pk_cnt := 2;</font></div><div><font size="2"   >&nbsp; -- v_pk_vector和v_pk_cnt也可以使用以下SQL得到.</font></div><div><font size="2"   >&nbsp; -- select string_agg(position::text,' ')::int2vector,count(*) into v_pk_vector,v_pk_cnt&nbsp;</font></div><div><font size="2"   >&nbsp; -- &nbsp;from dblink_get_pkey(v_nsp_name||'.'||v_table_name);</font></div><div><font size="2"   >&nbsp; case TG_OP</font></div><div><font size="2"   >&nbsp; when 'INSERT' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的insert语句, id是这个表的主键. 如果是多列值的则需要得到按v_pk_vector顺序的text[]</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||NEW.pk1||','||NEW.pk2||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query from dblink_build_sql_insert(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; when 'DELETE' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的delete语句, id是这个表的主键. 如果是多列值的则需要得到按v_pk_vector顺序的text[]</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||OLD.pk1||','||OLD.pk2||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query from dblink_build_sql_delete(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; when 'UPDATE' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的update语句, id是这个表的主键. 如果是多列值的则需要得到按v_pk_vector顺序的text[]</font></div><div><font size="2"   >&nbsp; &nbsp; -- 这里没有使用dblink_build_sql_update来生成update语句, 因为主键也可能被更新. 所以只能拆成两部分.</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||OLD.pk1||','||OLD.pk2||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query_upd1 from dblink_build_sql_delete(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; &nbsp; v_pk_att_vals_array := ('{'||NEW.pk1||','||NEW.pk2||'}')::text[];</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_query_upd2 from dblink_build_sql_insert(v_nsp_name||'.'||v_table_name, v_pk_vector, v_pk_cnt, v_pk_att_vals_array, v_pk_att_vals_array);</font></div><div><font size="2"   >&nbsp; when 'TRUNCATE' then</font></div><div><font size="2"   >&nbsp; &nbsp; -- 生成远程要执行的truncate语句. 注意这里是truncate table only. 如果是子表, 可以在子表上继续减这样的触发器.</font></div><div><font size="2"   >&nbsp; &nbsp; v_query := 'truncate table only '||v_table_name;</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >&nbsp; -- 将目标schema和目标表名替换现有表名.</font></div><div><font size="2"   >&nbsp; case TG_OP</font></div><div><font size="2"   >&nbsp; when 'UPDATE' then</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query_upd1 := regexp_replace(v_query_upd1, v_table_name, v_dst_nsp_name||'.'||v_dst_table_name, '');</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query_upd2 := regexp_replace(v_query_upd2, v_table_name, v_dst_nsp_name||'.'||v_dst_table_name, '');</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query := v_dst_query_upd1||';'||v_dst_query_upd2;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; v_dst_query := regexp_replace(v_query, v_table_name, v_dst_nsp_name||'.'||v_dst_table_name, '');</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >&nbsp; -- 如果想打印用于复制的SQL是否正确, 可以使用以下语句 :&nbsp;</font></div><div><font size="2"   >&nbsp; -- raise notice 'v_dst_query:%', v_dst_query;</font></div><div><font size="2"   >&nbsp; -- 判断sync_err_rec是否被其他会话加RowExclusiveLock锁. 如果发现, 往sync_err_rec写入触发SQL,&nbsp;</font></div><div><font size="2"   >&nbsp; -- 返回NULL. 不再继续调用dblink_exec(v_conn_name, v_dst_query, false)</font></div><div><font size="2"   >&nbsp; perform 1 from pg_locks where&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; relation=(select oid from pg_class where relname='sync_err_rec')&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; and pid != pg_backend_pid()</font></div><div><font size="2"   >&nbsp; &nbsp; and mode='RowExclusiveLock'</font></div><div><font size="2"   >&nbsp; &nbsp; limit 1;</font></div><div><font size="2"   >&nbsp; if found then</font></div><div><font size="2"   >&nbsp; &nbsp; insert into sync_err_rec (nsp_name, table_name, dst_server, dst_query, create_time)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_nsp_name, v_table_name, v_dst_server, v_dst_query, clock_timestamp());</font></div><div><font size="2"   >&nbsp; &nbsp; return null;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 判断sync_err_rec中是否有dst_server=v_dst_server的记录. 如果发现, 往sync_err_rec写入触发SQL,&nbsp;</font></div><div><font size="2"   >&nbsp; -- 返回NULL. 不再继续调用dblink_exec(v_conn_name, v_dst_query, false)</font></div><div><font size="2"   >&nbsp; perform 1 from sync_err_rec where dst_server=v_dst_server limit 1;</font></div><div><font size="2"   >&nbsp; if found then</font></div><div><font size="2"   >&nbsp; &nbsp; insert into sync_err_rec (nsp_name, table_name, dst_server, dst_query, create_time)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_nsp_name, v_table_name, v_dst_server, v_dst_query, clock_timestamp());</font></div><div><font size="2"   >&nbsp; &nbsp; return null;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 判断连接是否存在, 不存在则创建.</font></div><div><font size="2"   >&nbsp; if ( dblink_get_connections() @&gt; ('{'||v_conn_name||'}')::text[] ) then&nbsp;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; select * into v_conn_status from dblink_connect(v_conn_name, v_dst_server);</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 如果远程执行失败,确保本地成功,本地写sync_err_rec</font></div><div><font size="2"   >&nbsp; select * into v_exec_status from dblink_exec(v_conn_name, v_dst_query, false);</font></div><div><font size="2"   >&nbsp; if (v_exec_status = 'ERROR') then</font></div><div><font size="2"   >&nbsp; &nbsp; insert into sync_err_rec (nsp_name, table_name, dst_server, dst_query, create_time)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; values (v_nsp_name, v_table_name, v_dst_server, v_dst_query, clock_timestamp());</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; -- 如果想要远程失败,本地失败,本地不写sync_err_rec. 使用以下SQL替换前面几条SQL.&nbsp;</font></div><div><font size="2"   >&nbsp; -- 不了解的话可以去查询dblink_exec的详解.</font></div><div><font size="2"   >&nbsp; -- select * into v_exec_status from dblink_exec(v_conn_name, v_dst_query, true);</font></div><div><font size="2"   >&nbsp; -- -------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp; -- 不建议每次断开连接, 因为频繁的连接还是会带来很大开销的, 除非你在本地建立pgbouncer, 让pgbouncer来维持长连接.</font></div><div><font size="2"   >&nbsp; -- 断开连接的语句如下.</font></div><div><font size="2"   >&nbsp; -- select * into v_disconn_status from dblink_disconnect(v_conn_name);</font></div><div><font size="2"   >&nbsp; return null;</font></div><div><font size="2"   >exception</font></div><div><font size="2"   >when others then</font></div><div><font size="2"   >&nbsp; raise notice 'v_conn_status:%, v_exec_status:%.', v_conn_status, v_exec_status;</font></div><div><font size="2"   >&nbsp; insert into sync_err_rec (nsp_name, table_name, dst_server, dst_query, create_time)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; values (v_nsp_name, v_table_name, v_dst_server, v_dst_query, clock_timestamp());</font></div><div><font size="2"   >&nbsp; -- 如果想要远程失败,本地失败,本地不写sync_err_rec. 同时还需要以下语句.</font></div><div><font size="2"   >&nbsp; -- raise;</font></div><div><font size="2"   >&nbsp; return null;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$BODY$;</font></div><p></p></pre></div><div>3. 对于multi - master环境. 要保证多点的SQL执行顺序问题(如local和remote全局SQL执行顺序一致). 不是这么简单能实现的.</div><div>&nbsp; &nbsp; &nbsp;不在这里的讨论范畴.</div><div>这里只确保本地SQL以及发往远程的SQL执行顺序是一致的.</div><div>4. 最近由于项目组需求, 开发了一个可以用作多表使用的通用触发器函数如下 :&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201321125220134/"   >http://blog.163.com/digoal@126/blog/static/163877040201321125220134/</a></div>值请使用quote_literal来解析, 本文的例子中OLD,NEW暂未修改, 请使用时自行修改或参考上文.</div>
	</div>
</div>
</body>
</html>