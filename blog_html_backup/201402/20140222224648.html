<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL xidVacLimit, xidWarnLimit, xidStopLimit, xidWrapLimit, MaxTransactionId</h2>
	<h5 id="">2014-02-22 22:46:48&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201412282455978/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>今天兄弟部门的数据库遇到无法正常申请事务号的错误, 原因是某些库由于年龄太老, 已经到达允许的xid上限(xidStopLimit = xidWrapLimit - 1000000), 数据库预留了100万的事务作为维护用, 所以此时不允许任何会话申请新的事务号.</div><div>这样的话就必须进入单用户模式做vacuum freeze处理, 将年龄降下来.</div><div>另一种情况是警告, 如果在到达<span style="line-height: 28px;"   >(</span>xidWarnLimit = xidStopLimit - 10000000<span style="line-height: 28px;"   >)的年龄后, 数据库会给出提示, 尽快执行vacuum freeze将数据库的年龄降下来, 避免达到</span><span style="line-height: 28px;"   >xidStopLimit&nbsp;</span><span style="line-height: 28px;"   >, 那个时候就必须进单用户处理了.</span></div><div><span style="line-height: 28px;"   >总的来说数据库有几个参数来防止数据库到达</span><span style="line-height: 28px;"   >xidStopLimit</span><span style="line-height: 28px;"   >&nbsp;.</span></div><div><span style="line-height: 28px;"   >1.&nbsp;</span><span style="line-height: 28px;"   >vacuum_freeze_table_age</span></div><div><span style="line-height: 28px;"   >2.&nbsp;</span><span style="line-height: 28px;"   >autovacuum_freeze_max_age</span></div><div><span style="line-height: 28px;"   ><br></span></div><div>我先来说一下避免发生数据库年龄到达<span style="line-height: 28px;"   >xidStopLimit</span><span style="line-height: 28px;"   >的几种方法, 然后再说一下如何进单用户, 如何处理这种情况, 以及比较快速且变态的做法等 :&nbsp;</span></div><div><span style="line-height: 28px;"   >避免发生数据库年龄到达</span><span style="line-height: 28px;"   >xidStopLimit&nbsp;</span><span style="line-height: 28px;"   >的几种方法 :&nbsp;</span></div><div><span style="line-height: 28px;"   >1.&nbsp;</span></div><div><span style="line-height: 28px;"   >合理的设置</span><span style="line-height: 28px;"   >vacuum_freeze_table_age, 这个参数决定了表的年龄到达这个值以来还未发生过全表数据块的vacuum的话, 那么这个vacuum或autovacuum操作就会扫描全表, 并且触发freeze, 从而降低表的年龄. 所以这个值不能太大, 这样的话数据库有足够多的机会降低表的年龄, 但是也不能太小, 太小的话, 会频繁的触发全表扫, 带来IO开销.</span></div><div><span style="line-height: 28px;"   >2.&nbsp;</span></div><div><span style="line-height: 28px;"   >合理的设置</span><span style="line-height: 28px;"   >autovacuum_freeze_max_age. 这个参数即使在没有开启autovacuum的情况下, 只要年龄到达这个值也会触发autovacuum.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >src/backend/access/transam/varsup.c</font></div><div><span style="line-height: 28px;"   ><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We'll start trying to force autovacuums when oldest_datfrozenxid gets</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to be more than autovacuum_freeze_max_age transactions old.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: guc.c ensures that autovacuum_freeze_max_age is in a sane range,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* so that xidVacLimit will be well before xidWarnLimit.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: autovacuum_freeze_max_age is a PGC_POSTMASTER parameter so that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we don't have to worry about dealing with on-the-fly changes in its</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* value. &nbsp;It doesn't look practical to update shared state from a GUC</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* assign hook (too many processes would try to execute the hook,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* resulting in race conditions as well as crashes of those not connected</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to shared memory). &nbsp;Perhaps this can be improved someday.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; xidVacLimit = oldest_datfrozenxid + autovacuum_freeze_max_age;</font></div></span></div><p></p></pre></div><div><span style="line-height: 28px;"   ><div>这个值是一个比较好的保护值, 最大是20亿, 但是不建议这么大, 应该预留足够的值防止到达xidStopLimit和xidWarnLimit阶段.</div></span></div><div><span style="line-height: 28px;"   >预留多少合适呢?</span></div><div><span style="line-height: 28px;"   >例如完成全库扫描要1天, 并且一天会产生1亿个事务的话, 那么预留最少要1亿比较好.&nbsp;</span></div><div><span style="line-height: 28px;"   >这样的话就设置成19亿.</span></div><div><span style="line-height: 28px;"   >3.</span></div><div><span style="line-height: 28px;"   >数据库的使用要合理, 例如对于长事务, 并且事务隔离级别是repeatable read或</span><span style="line-height: 28px;"   >SERIALIZABLE</span><span style="line-height: 28px;"   >&nbsp;的话, 会影响vacuum freeze降低对象的年龄, 将本文后面的测试.&nbsp;</span></div><div><span style="line-height: 28px;"   >同样要避免和逻辑备份的时间点冲突, 逻辑备份使用的是repeatable read隔离级别, 并且备份时间长.</span></div><div>参见 :&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201241134721101/"   >http://blog.163.com/digoal@126/blog/static/163877040201241134721101/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201322510519547/"   >http://blog.163.com/digoal@126/blog/static/163877040201322510519547/</a></div><div>或pg_dump的代码.</div><div><span style="line-height: 28px;"   >4.&nbsp;</span></div><div>控制单表的大小, 因为太大的话, 会增加单次扫描的负担, 如果未能降低年龄, 重复扫描更加浪费.</div><div>5.&nbsp;</div><div>提升存储IO能力, 这样也能提升VACUUM FREEZE的速率.</div><div>6.</div><div>必要的情况下, 进行分库(严格来说是分集群, 不要放在一个集群下面, 因为xid是整个集群统一分配的).</div><div>7.&nbsp;</div><div>加大maintenance_work_mem, 也能一定程度上提升vacuum 速率.</div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >接下来讲一下进数据库单用户模式处理数据库到达</span><span style="line-height: 28px;"   >xidStopLimit场景</span><span style="line-height: 28px;"   >的方法 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 28px;"   ><font size="2"   >首先关闭数据库</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >然后进入单用户, 进入指定的数据库名.</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >postgres --single -E $dbname</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >backend&gt;&nbsp;</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >为了最快的降低数据库的年龄, 其实没有必要做全库的vacuum freeze, 数据库的年龄由数据库中年龄最大的表决定.</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >所以只要把年龄最大的表年龄降下来, 数据库的年龄就会变成年龄次大的表的年龄, 以此类推.</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >那么我们进入单用户后, 首先要按年龄排序, 查出年龄大的表.</font></span></div><div><font size="2"   >select b.nspname,a.relname,a.relfrozenxid,age(a.relfrozenxid) from pg_class a, pg_namespace b where a.relnamespace=b.oid and a.relkind='r' order by a.relfrozenxid::text::int8 limit 10;</font></div><div><font size="2"   >根据查到的表做vacuum freeze.</font></div><div><font size="2"   >vacuum freeze tbl;</font></div><div><font size="2"   >做完以后, 查询一下数据库的年龄是否降了, 降到合理范围后. (建议降到)</font></div><div><font size="2"   >select datname,datfrozenxid,age(datfrozenxid) from pg_database;</font></div><div><font size="2"   >然后就可以启动数据库了, 启动后建议做全库的vacuum freeze, 彻底降低年龄, 同时定制空闲时间的vacuum freeze.</font></div><p></p></pre></div><div><br></div><div>接下来说一下比较变态的做法.</div><div>如果要vacuum freeze的表非常大, 那么freeze的时间可能会很久, 但是业务又不允许停很久的话, 可以有变态的方法吗?</div><div>其实可以修改pg_database的datfrozenxid, 以及pg_class的relfrozenxid. 这样的话对于那些非常老的tuple, 可能会发生disappear的现象. 如果业务允许这么做, 那么这是最快的方法.</div><div>改完后在不影响业务的情况下, 尽快对这些表执行vacuum freeze.&nbsp;</div><div><span style="line-height: 28px;"   >disappear原理</span>参考 :&nbsp;</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201183043153622/"   >http://blog.163.com/digoal@126/blog/static/163877040201183043153622/</a></div><div>例子 :&nbsp;</div><div>假设postgres数据库的xid到达了<span style="line-height: 28px;"   >xidStopLimit, 必须进单用户处理.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >1. 关闭数据库</font></div><div><div><font size="2"   >pg93@db-172-16-3-150-&gt; pg_ctl stop -m fast</font></div><div><font size="2"   >waiting for server to shut down.... done</font></div><div><font size="2"   >server stopped</font></div><div><font size="2"   >2. 单用户启动数据库, 连接到postgres库.</font></div><div><font size="2"   >pg93@db-172-16-3-150-&gt; postgres --single -E postgres</font></div><div><font size="2"   >PostgreSQL stand-alone backend 9.3.1</font></div><div><font size="2"   >查看当前数据库的<span style="line-height: 28px;"   >datfrozenxid</span><span style="line-height: 28px;"   >&nbsp;</span></font></div><div><font size="2"   >backend&gt; select datname,datfrozenxid from pg_database where datname=current_database();</font></div><div><font size="2"   >statement: select datname,datfrozenxid from pg_database where datname=current_database();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1: datname &nbsp; &nbsp; (typeid = 19, len = 64, typmod = -1, byval = f)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2: datfrozenxid &nbsp; &nbsp; &nbsp; &nbsp;(typeid = 28, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ----</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1: datname = "postgres" &nbsp; &nbsp; &nbsp; &nbsp;(typeid = 19, len = 64, typmod = -1, byval = f)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2: datfrozenxid = "316732855" &nbsp;(typeid = 28, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ----</font></div></div><div><font size="2"   >查看表的<span style="line-height: 28px;"   >datfrozenxid</span><span style="line-height: 28px;"   >&nbsp;, 排序输出</span></font></div><div><div><font size="2"   >backend&gt; select a.oid,b.nspname,a.relname,a.relfrozenxid,age(a.relfrozenxid) from pg_class a, pg_namespace b where a.relnamespace=b.oid and a.relkind='r' order by a.relfrozenxid::text::int8 limit 3;</font></div><div><font size="2"   >statement: select a.oid,b.nspname,a.relname,a.relfrozenxid,age(a.relfrozenxid) from pg_class a, pg_namespace b where a.relnamespace=b.oid and a.relkind='r' order by a.relfrozenxid::text::int8 limit 3;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1: oid (typeid = 26, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2: nspname &nbsp; &nbsp; (typeid = 19, len = 64, typmod = -1, byval = f)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3: relname &nbsp; &nbsp; (typeid = 19, len = 64, typmod = -1, byval = f)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4: relfrozenxid &nbsp; &nbsp; &nbsp; &nbsp;(typeid = 28, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5: age (typeid = 23, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ----</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1: oid = "126133" &nbsp; &nbsp; &nbsp;(typeid = 26, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2: nspname = "postgres" &nbsp; &nbsp; &nbsp; &nbsp;(typeid = 19, len = 64, typmod = -1, byval = f)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3: relname = "a" &nbsp; &nbsp; &nbsp; (typeid = 19, len = 64, typmod = -1, byval = f)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4: relfrozenxid = "316732855" &nbsp;(typeid = 28, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5: age = "12261206" &nbsp; &nbsp;(typeid = 23, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ----</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1: oid = "126136" &nbsp; &nbsp; &nbsp;(typeid = 26, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2: nspname = "postgres" &nbsp; &nbsp; &nbsp; &nbsp;(typeid = 19, len = 64, typmod = -1, byval = f)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3: relname = "abc" &nbsp; &nbsp; (typeid = 19, len = 64, typmod = -1, byval = f)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4: relfrozenxid = "316732857" &nbsp;(typeid = 28, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5: age = "12261204" &nbsp; &nbsp;(typeid = 23, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ----</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1: oid = "126139" &nbsp; &nbsp; &nbsp;(typeid = 26, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2: nspname = "postgres" &nbsp; &nbsp; &nbsp; &nbsp;(typeid = 19, len = 64, typmod = -1, byval = f)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3: relname = "p1" &nbsp; &nbsp; &nbsp;(typeid = 19, len = 64, typmod = -1, byval = f)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4: relfrozenxid = "316732859" &nbsp;(typeid = 28, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5: age = "12261202" &nbsp; &nbsp;(typeid = 23, len = 4, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ----</font></div></div><div><font size="2"   >我们看到a表的<span style="line-height: 28px;"   >datfrozenxid</span><span style="line-height: 28px;"   >&nbsp;最小, 和数据库的</span><span style="line-height: 28px;"   >datfrozenxid</span><span style="line-height: 28px;"   >&nbsp;一致, 所以把这个表的</span><span style="line-height: 28px;"   >datfrozenxid</span><span style="line-height: 28px;"   >&nbsp;改大, 数据库的</span><span style="line-height: 28px;"   >datfrozenxid</span><span style="line-height: 28px;"   >&nbsp;也改大 .</span></font></div><div><font size="2"   >改之前把表的数据, hash sum记录一下, 以便后面比对数据</font></div><div><div><font size="2"   >backend&gt; select count(*) from a;</font></div><div><font size="2"   >statement: select count(*) from a;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1: count &nbsp; &nbsp; &nbsp; (typeid = 20, len = 8, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ----</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1: count = "100000" &nbsp; &nbsp;(typeid = 20, len = 8, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ----</font></div><div><font size="2"   >backend&gt; select sum(hashtext(a.*::text)) from a;</font></div><div><font size="2"   >statement: select sum(hashtext(a.*::text)) from a;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1: sum (typeid = 20, len = 8, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ----</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1: sum = "-678752174844" &nbsp; &nbsp; &nbsp; (typeid = 20, len = 8, typmod = -1, byval = t)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ----</font></div></div><div><font size="2"   >更新pg_class和pg_database的对应条目</font></div><div><div><font size="2"   >backend&gt; update pg_class set relfrozenxid=316732857::text::xid where oid=126133;</font></div><div><font size="2"   >statement: update pg_class set relfrozenxid=316732857::text::xid where oid=126133;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >backend&gt; update pg_database set datfrozenxid=316732857::text::xid where datname=current_database();</font></div><div><font size="2"   >statement: update pg_database set datfrozenxid=316732857::text::xid where datname=current_database();</font></div></div><div><font size="2"   >检查点</font></div><div><div><font size="2"   >backend&gt; checkpoint;</font></div><div><font size="2"   >statement: checkpoint;</font></div><div><span style="line-height: 28px;"   ><font size="2"   >LOG: &nbsp;00000: checkpoint starting: immediate force wait</font></span></div><div><font size="2"   >LOCATION: &nbsp;LogCheckpointStart, xlog.c:6651</font></div><div><font size="2"   >STATEMENT: &nbsp;checkpoint;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >LOG: &nbsp;00000: checkpoint complete: wrote 0 buffers (0.0%); 0 transaction log file(s) added, 0 removed, 1 recycled; write=0.000 s, sync=0.000 s, total=0.003 s; sync files=0, longest=0.000 s, average=0.000 s</font></div><div><font size="2"   >LOCATION: &nbsp;LogCheckpointEnd, xlog.c:6746</font></div><div><font size="2"   >STATEMENT: &nbsp;checkpoint;</font></div></div><div><font size="2"   >退出单用户</font></div><div><font size="2"   >CTRL+D</font></div><div><font size="2"   >直接更新pg_class和pg_database争取到了时间, 正常启动数据库后业务可以连过来, 不会报不允许请求新的 xid的错误</font></div><div><font size="2"   >pg93@db-172-16-3-150-&gt; pg_ctl start</font></div><div><div><font size="2"   >pg93@db-172-16-3-150-&gt; psql postgres postgres</font></div><div><font size="2"   >psql (9.3.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >查询表的hash sum</font></div><div><font size="2"   >postgres=# select sum(hashtext(a.*::text)) from a;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; sum &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >---------------</font></div><div><font size="2"   >&nbsp;-678752174844</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >vacuum freeze a表</font></div><div><div><font size="2"   >postgres=# vacuum freeze a;</font></div><div><font size="2"   >VACUUM</font></div></div><div><font size="2"   >查看表的hash sum , 正常</font></div><div><div><font size="2"   >postgres=# select sum(hashtext(a.*::text)) from a;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; sum &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >---------------</font></div><div><font size="2"   >&nbsp;-678752174844</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div><br></div><div>接下来讲一下,2种事务隔离级别对vacuum freeze的影响讲解 :&nbsp;</div><div>如果数据库提示无法执行任何事务, 建议进入stand-alone模式, 执行vacuum freeze的话, 这个时候已经无法执行事务了, 所以必须以单用户模式启动数据库, 执行vacuum freeze, 将年龄最老的表freeze掉来降低数据库的年龄.</div><div>具体介绍参见 :&nbsp;</div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/routine-vacuuming.html"   >http://www.postgresql.org/docs/9.3/static/routine-vacuuming.html</a></div><div><pre style="-webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border: 1px solid rgb(207, 207, 207); padding: 2ex; margin-top: 2ex; margin-bottom: 2ex; margin-left: 2ex; overflow: auto; border-top-left-radius: 8px; border-top-right-radius: 8px; border-bottom-right-radius: 8px; border-bottom-left-radius: 8px; background-color: rgb(247, 247, 247); line-height: normal;"   ><font size="2"   >ERROR:  database is not accepting commands to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and use a standalone backend to VACUUM in "mydb".</font></pre></div><div><br></div><div>当freeze执行前, 数据库中存在活动的SERIALIZABLE 或 REPEATABLE READ 隔离级别的事务时, 且在freeze执行完后, 这个事务还未结束, 那么freeze将无法降低对象的年龄.&nbsp;</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SESSION A :&nbsp;</font></div><div><div><font size="2"   >digoal=# select relname,relfrozenxid,age(relfrozenxid) from pg_class where relname='a';</font></div><div><font size="2"   >&nbsp;relname | relfrozenxid | age&nbsp;</font></div><div><font size="2"   >---------+--------------+-----</font></div><div><font size="2"   >&nbsp;a &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; 2035 | &nbsp; 3</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# vacuum freeze a;</font></div><div><font size="2"   >VACUUM</font></div><div><font size="2"   >digoal=# select relname,relfrozenxid,age(relfrozenxid) from pg_class where relname='a';</font></div><div><font size="2"   >&nbsp;relname | relfrozenxid | age&nbsp;</font></div><div><font size="2"   >---------+--------------+-----</font></div><div><font size="2"   >&nbsp;a &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; 2038 | &nbsp; 0</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >SESSION B :&nbsp;</font></div><div><div><font size="2"   >digoal=# begin ISOLATION LEVEL REPEATABLE READ;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# select * from b limit 1;</font></div><div><font size="2"   >&nbsp;id | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+----------------------------------</font></div><div><font size="2"   >&nbsp; 5 | 77aadc6b569830d7c468c489e503055c</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >SESSION A :&nbsp;</font></div><div><div><font size="2"   >digoal=# select txid_current();</font></div><div><font size="2"   >&nbsp;txid_current&nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2038</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select txid_current();</font></div><div><font size="2"   >&nbsp;txid_current&nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2039</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select txid_current();</font></div><div><font size="2"   >&nbsp;txid_current&nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2040</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# vacuum freeze a;</font></div><div><font size="2"   >VACUUM</font></div><div><font size="2"   >digoal=# select relname,relfrozenxid,age(relfrozenxid) from pg_class where relname='a';</font></div><div><font size="2"   >&nbsp;relname | relfrozenxid | age&nbsp;</font></div><div><font size="2"   >---------+--------------+-----</font></div><div><font size="2"   >&nbsp;a &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; 2038 | &nbsp; 3</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div><br></div><div>由于会话B的<span style="line-height: 28px;"   >ISOLATION LEVEL REPEATABLE READ事务没有结束, 所以vacuum freeze无法正常的降低对象的年龄.</span></div><div>当SESSION B的事务结束后, 重新vacuum freeze的话, 可以降低年龄.</div><div>对于执行vacuum freeze过程中发起的ISOLATION LEVEL REPEATABLE READ事务, 不会影响<span style="line-height: 28px;"   >vacuum freeze减低对象的年龄.</span></div><div><br></div><div>后期建议的预防措施 :&nbsp;</div><div>1. 监控数据库年龄, 建议将这个监控加入nagios.</div><div><span style="line-height: 28px;"   >2. 自定义空闲时间的vacuum freeze.</span></div><div>修改pg_hba.conf</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >vi $PGDATA/pg_hba.conf</font></div><div><font size="2"   >local &nbsp; all &nbsp;postgres trust</font></div><div><font size="2"   >pg_ctl reload</font></div><div><font size="2"   >vi $PGDATA/postgresql.conf &nbsp;-- 以下这个可以不改, 后面的脚本连接正确的sock目录即可.</font></div><div><font size="2"   >unix_socket_directory = '.'</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >脚本, 检索数据库中年龄大于1亿, 并且表的大小大于800MB(当BLOCKSIZE=8K时)的前2000个表.&nbsp;</span></div><div><span style="line-height: 28px;"   >进行vacuum freeze操作.</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >vi /home/postgres/script/vacuumdb.sh</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#!/bin/bash</font></div><div><font size="2"   ># 环境变量</font></div><div><font size="2"   >export PGPORT=5432</font></div><div><font size="2"   >export PGDATA=/pgdata/pg_root</font></div><div><font size="2"   >export LANG=en_US.utf8</font></div><div><font size="2"   >export PGHOME=/opt/pgsql</font></div><div><font size="2"   >export LD_LIBRARY_PATH=$PGHOME/lib:/lib64:/usr/lib64:/usr/local/lib64:/lib:/usr/lib:/usr/local/lib</font></div><div><font size="2"   >export DATE=`date +"%Y%m%d%H%M"`</font></div><div><font size="2"   >export PATH=$PGHOME/bin:$PATH:.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ># 配置项</font></div><div><font size="2"   >TODAY=`date +%Y%m%d`</font></div><div><font size="2"   >AGE="500000000"</font></div><div><font size="2"   >PAGES="102400"</font></div><div><font size="2"   >LIMIT="5000"</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >HOST=$PGDATA</font></div><div><font size="2"   >PORT=$<span style="line-height: 28px;"   >PGPORT</span></font></div><div><font size="2"   >ROLE="postgres"</font></div><div><font size="2"   >QUERY1="select t2.nspname||'.'||t1.relname from pg_class t1 join pg_namespace t2 on (t1.relnamespace=t2.oid and t1.relkind='r' and age(t1.relfrozenxid)&gt;$AGE and t1.relpages&gt;$PAGES) order by age(relfrozenxid) desc limit 1;"<br><br>for ((i=1;i&lt;$LIMIT;i++)) do<br>for DB in `psql -A -q -t -h $HOST -p $PORT -U $ROLE postgres -c "select datname from pg_database where datname not in ('postgres','template0','template1')&nbsp;<span style="line-height: 21px;"   >and age(datfrozenxid)&gt;(select setting::int from pg_settings where name='vacuum_freeze_table_age') </span></font><span style="line-height: 21px; font-size: small; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, 宋体;"   >order by age(datfrozenxid) desc"`</span></div><div><font size="2"   >do<br>  for RELNAME in `psql -A -q -t -h $HOST -p $PORT -U $ROLE $DB -c "$QUERY1"`<br>  do<br>psql -h $HOST -p $PORT -U $ROLE $DB &lt;&lt;EOF<br>set synchronous_commit = off;<br>set work_mem = '2048MB';</font></div><div><font size="2"   >set maintenance_work_mem = '2048MB';<br>vacuum freeze $RELNAME;<br>EOF<br>  done<br>done</font></div><div><font size="2"   >done</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >chmod 500&nbsp;<span style="line-height: 28px;"   >vacuumdb.sh</span></font></div><p></p></pre></div><div><span style="line-height: 28px;"   >执行计划, 挑选一个空闲时间段, 例如每周日的中午12点开始.</span></div></div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >crontab -e</font></div><div style="line-height: 28px;"   ><font size="2"   ># vacuumdb</font></div><div style="line-height: 28px;"   ><font size="2"   >1 12 * * 1 /home/postgres/script/vacuumdb.sh &gt;/dev/null 2&gt;&amp;1</font></div><p></p></pre></div></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201382495753521/"   >http://blog.163.com/digoal@126/blog/static/163877040201382495753521/</a></div><div>2.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201183043153622/"   >http://blog.163.com/digoal@126/blog/static/163877040201183043153622/</a></div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201251911813661/"   >http://blog.163.com/digoal@126/blog/static/163877040201251911813661/</a></div><div><div style="line-height: 28px;"   >4.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201241134721101/"   >http://blog.163.com/digoal@126/blog/static/163877040201241134721101/</a></div><div style="line-height: 28px;"   >5.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201322510519547/"   >http://blog.163.com/digoal@126/blog/static/163877040201322510519547/</a></div></div><div>6.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/routine-vacuuming.html"   >http://www.postgresql.org/docs/9.3/static/routine-vacuuming.html</a></div><div>7.&nbsp;src/backend/access/transam/varsup.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check to see if it's safe to assign another XID. &nbsp;This protects against</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* catastrophic data loss due to XID wraparound. &nbsp;The basic rules are:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If we're past xidVacLimit, start trying to force autovacuum cycles.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If we're past xidWarnLimit, start issuing warnings.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If we're past xidStopLimit, refuse to execute transactions, unless</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we are running in a standalone backend (which gives an escape hatch</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to the DBA who somehow got past the earlier defenses).</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note that this coding also appears in GetNewMultiXactId.</font></div><p></p></pre></div><div>...</div><div>100万</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We'll refuse to continue assigning XIDs in interactive mode once we get</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* within 1M transactions of data loss. &nbsp;This leaves lots of room for the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* DBA to fool around fixing things in a standalone backend, while not</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* being significant compared to total XID space. (Note that since</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* vacuuming requires one transaction per table cleaned, we had better be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* sure there's lots of XIDs left...)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; xidStopLimit = xidWrapLimit - 1000000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (xidStopLimit &lt; FirstNormalTransactionId)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xidStopLimit -= FirstNormalTransactionId;</font></div><p></p></pre></div><div><br></div><div>8.&nbsp;src/include/access/transam.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* VariableCache is a data structure in shared memory that is used to track</font></div><div><font size="2"   >&nbsp;* OID and XID assignment state. &nbsp;For largely historical reasons, there is</font></div><div><font size="2"   >&nbsp;* just one struct with different fields that are protected by different</font></div><div><font size="2"   >&nbsp;* LWLocks.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: xidWrapLimit and oldestXidDB are not "active" values, but are</font></div><div><font size="2"   >&nbsp;* used just to generate useful messages when xidWarnLimit or xidStopLimit</font></div><div><font size="2"   >&nbsp;* are exceeded.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef struct VariableCacheData</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* These fields are protected by OidGenLock.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextOid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* next OID to assign */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;oidCount; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* OIDs available before must do XLOG work */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* These fields are protected by XidGenLock.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId nextXid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* next XID to assign */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId oldestXid; &nbsp; &nbsp; &nbsp; &nbsp;/* cluster-wide minimum datfrozenxid */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidVacLimit; &nbsp; &nbsp; &nbsp;/* start forcing autovacuums here */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidWarnLimit; /* start complaining here */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidStopLimit; /* refuse to advance nextXid beyond here */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidWrapLimit; /* where the world ends */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestXidDB; &nbsp; &nbsp;/* database with minimum datfrozenxid */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* These fields are protected by ProcArrayLock.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId latestCompletedXid; &nbsp; &nbsp; &nbsp; /* newest XID that has committed or</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* aborted */</font></div><div><font size="2"   >} VariableCacheData;</font></div><p></p></pre></div>9. 如何dump出ShmemVariableCache的内容?<div>首先确保数据库编译时开启了dtrace和debug.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg93@db-172-16-3-150-&gt; pg_config --configure</font></div><div><font size="2"   >'--prefix=/home/pg93/pgsql9.3.1' '--with-pgport=1921' '--with-perl' '--with-tcl' '--with-python' '--with-openssl' '--with-pam' '--without-ldap' '--with-libxml' '--with-libxslt' '--enable-thread-safety' '--with-wal-blocksize=16' '--enable-dtrace' '--enable-debug'</font></div><p></p></pre></div><div>然后参考<span style="line-height: 28px;"   >src/include/access/transam.h头文件我们知道要DUMP的变量</span><span style="line-height: 28px;"   >ShmemVariableCache的结构</span>VariableCacheData,&nbsp;</div><div><span style="line-height: 28px;"   >找到合适的跟踪点, 例如src/backend/access/transam/varsup.c的GetNewTransactionId函数, 每次申请XID的时候会调用, 并且可以输出当时的</span><span style="line-height: 28px;"   >ShmemVariableCache变量的值.</span></div><div><span style="line-height: 28px;"   >使用stap跟踪如下 :&nbsp;</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 postgresql-9.3.2]# stap --vp 10000 -e '</font></div><div><font size="2"   >probe process("/home/pg93/pgsql/bin/postgres").function("GetNewTransactionId@src/backend/access/transam/varsup.c") &nbsp;</font></div><div><font size="2"   >{</font></div><div><font size="2"   >printf("%s\n", $ShmemVariableCache$$) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >}'</font></div><div><font size="2"   >Pass 1: parsed user script and 96 library script(s) using 152020virt/25216res/2104shr/23928data kb, in 230usr/20sys/251real ms.</font></div><p></p></pre></div><div>然后开启一个psql会话, 执行<span style="line-height: 28px;"   >txid_current()申请一个新的xid.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select txid_current();</font></div><div><font size="2"   >&nbsp;txid_current&nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp; &nbsp; 328994069</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>stap的输出如下 :&nbsp;</div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >{.nextOid=130852, .oidCount=0, .nextXid=328994069, .oldestXid=1800, .xidVacLimit=1900001800, .xidWarnLimit=2136485447, .xidStopLimit=2146485447, .xidWrapLimit=2147485447, .oldestXidDB=1, .latestCompletedXid=328994068}</font></div></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >从结果我们得知几个重要的变量的值&nbsp;</span><span style="line-height: 28px;"   >xidVacLimit,&nbsp;</span><span style="line-height: 28px;"   >xidWarnLimit,&nbsp;</span><span style="line-height: 28px;"   >xidStopLimit,&nbsp;</span><span style="line-height: 28px;"   >xidWrapLimit.</span></div></div><div><span style="line-height: 28px;"   >这几个变量的值是在</span>SetTransactionIdLimit函数中设置的. 具体的算法请参考SetTransactionIdLimit函数.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 28px;"   >1. xidVacLimit =&nbsp;</span><span style="line-height: 28px;"   >autovacuum_freeze_max_age +&nbsp;</span><span style="line-height: 28px;"   >oldestXid =&nbsp;</span><span style="line-height: 28px;"   >1900001800;</span></font></div><div><div style="line-height: 28px;"   ><font size="2"   >digoal=# show autovacuum_freeze_max_age;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;autovacuum_freeze_max_age&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >---------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;1900000000</font></div><div style="line-height: 28px;"   ><font size="2"   >(1 row)</font></div><div style="line-height: 28px;"   ><font size="2"   ><br></font></div><div style="line-height: 28px;"   ><font size="2"   >2.&nbsp;xidWrapLimit = oldest_datfrozenxid + (MaxTransactionId &gt;&gt; 1); = 1800+2^31-1 =&nbsp;2147485447</font></div><div><font size="2"   >src/include/access/transam.h:#define MaxTransactionId &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((TransactionId) 0xFFFFFFFF)</font></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   ><br></font></span></div><div><font size="2"   ><span style="line-height: 28px;"   >3.&nbsp;</span>xidStopLimit = xidWrapLimit - 1000000; =&nbsp;2146485447</font></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   ><br></font></span></div><div><font size="2"   ><span style="line-height: 28px;"   >4. xidWarnLimit =&nbsp;</span>xidStopLimit - 10000000; =&nbsp;2136485447</font></div></div><p></p></pre></div><div><br></div></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL xidVacLimit, xidWarnLimit, xidStopLimit, xidWrapLimit, MaxTransactionId - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>