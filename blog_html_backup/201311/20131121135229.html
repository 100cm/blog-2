<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap examples, Identifying Contended User-Space Locks</h2>
	<h5 id="">2013-11-21 13:52:29&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020131021104039675/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>本文的例子 可用于判断程序性能问题是否由于futex锁冲突引起的.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >This section describes how to identify contended user-space locks throughout the system within a specific time period. The ability to identify contended user-space locks can help you investigate poor program performance that you suspect may be caused by futex contentions.</font></div><div><font size="2"   >Simply put, futex contention occurs when multiple processes are trying to access the same lock variable at the same time. This can result in a poor performance because the lock serializes execution; one process obtains the lock while the other processes must wait for the lock variable to become available again.</font></div><p></p></pre></div><div>修改成间隔输出后的脚本及注解如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 process]# cd /opt/systemtap/share/doc/systemtap/examples/process</font></div><div><div><font size="2"   >[root@db-172-16-3-150 process]# cat futexes.stp</font></div><div><font size="2"   >#! /usr/bin/env stap</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ># This script tries to identify contended user-space locks by hooking</font></div><div><font size="2"   ># into the futex system call.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >global FUTEX_WAIT = 0 /*, FUTEX_WAKE = 1 */</font></div><div><font size="2"   >global FUTEX_PRIVATE_FLAG = 128 /* linux 2.6.22+ */</font></div><div><font size="2"   >global FUTEX_CLOCK_REALTIME = 256 /* linux 2.6.29+ */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >global lock_waits # long-lived stats on (tid,lock) blockage elapsed time</font></div><div><font size="2"   >global process_names # long-lived pid-to-execname mapping</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe syscall.futex.return { &nbsp;</font></div><div><span style="line-height: 28px;"   ><font size="2"   >&nbsp; elapsed = gettimeofday_us() - @entry(gettimeofday_us())</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >&nbsp; // elapsed 调到第一条, 增加计算时间精度.</font></span></div><div><font size="2"   >&nbsp; if (($op &amp; ~(FUTEX_PRIVATE_FLAG|FUTEX_CLOCK_REALTIME)) != FUTEX_WAIT) next</font></div><div><font size="2"   >// &nbsp;next 表示跳过这次probe handler.</font></div><div><font size="2"   >&nbsp; process_names[pid()] = execname()</font></div><div><font size="2"   >&nbsp; lock_waits[pid(), $uaddr] &lt;&lt;&lt; elapsed</font></div><div><font size="2"   >}</font></div><div><font size="2"   >// &nbsp;<span style="line-height: 28px;"   >$op存储一个比特位变量, &nbsp;通过</span><span style="line-height: 28px;"   >($op &amp; ~(FUTEX_PRIVATE_FLAG|FUTEX_CLOCK_REALTIME)) != FUTEX_WAIT操作.</span></font></div><div><span style="line-height: 28px;"   ><font size="2"   >// &nbsp;判断进程是否处于等待状态.</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >// &nbsp;~ 比特位翻转</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >// &nbsp;| 比特或</font></span></div><div><font size="2"   ><span style="line-height: 28px;"   >// &nbsp;</span><span style="line-height: 28px;"   >&amp; 比特与</span></font></div><div><font size="2"   ><span style="line-height: 28px;"   >// &nbsp;参考&nbsp;</span><a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/163877040201398103956233/"   >http://blog.163.com/digoal@126/blog/static/163877040201398103956233/</a></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe timer.s(5) {</font></div><div><font size="2"   >&nbsp; foreach ([pid+, lock] in lock_waits)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; printf ("%s[%d] lock %p contended %d times, %d avg us\n",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process_names[pid], pid, lock, @count(lock_waits[pid,lock]),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @avg(lock_waits[pid,lock]))</font></div><div><font size="2"   >&nbsp; delete&nbsp;<span style="line-height: 28px;"   >process_names</span></font></div><div><font size="2"   ><span style="line-height: 28px;"   >&nbsp; delete&nbsp;</span><span style="line-height: 28px;"   >process_names</span><span style="line-height: 28px;"   >&nbsp;</span></font></div><div><font size="2"   >}</font></div></div><div><font size="2"   >// 输出: 进程名, 锁内存地址, 锁冲突次数, 平均等待时间.</font></div><p></p></pre></div><div><br></div><div>输出如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 process]# stap futexes.stp</font></div><div><font size="2"   >auditd[1599] lock 0x7f08ffd1f294 contended 1 times, 3291 avg us</font></div><div><font size="2"   >rs:main Q:Reg[1624] lock 0x7fbbc9d87e64 contended 1 times, 9619461 avg us</font></div><div><font size="2"   >[1599] lock 0x7f08ffd1f294 contended 1 times, 3291 avg us</font></div><div><font size="2"   >[1624] lock 0x7fbbc9d87e64 contended 1 times, 9619461 avg us</font></div><div><font size="2"   >pgbench[23916] lock 0x7f1440f07360 contended 4 times, 134 avg us</font></div><div><font size="2"   >[1599] lock 0x7f08ffd1f294 contended 1 times, 3291 avg us</font></div><div><font size="2"   >[1624] lock 0x7fbbc9d87e64 contended 1 times, 9619461 avg us</font></div><div><font size="2"   >automount[1973] lock 0x7faeb99e7224 contended 1 times, 3596 avg us</font></div><div><font size="2"   >automount[1973] lock 0x7faea00008ec contended 1 times, 2014 avg us</font></div><div><font size="2"   >automount[1973] lock 0x7faea00008c0 contended 1 times, 523 avg us</font></div><div><font size="2"   >[23916] lock 0x7f1440f07360 contended 4 times, 134 avg us</font></div><div><font size="2"   >[1599] lock 0x7f08ffd1f294 contended 1 times, 3291 avg us</font></div><div><font size="2"   >[1624] lock 0x7fbbc9d87e64 contended 1 times, 9619461 avg us</font></div><div><font size="2"   >[1973] lock 0x7faeb99e7224 contended 1 times, 3596 avg us</font></div><div><font size="2"   >[1973] lock 0x7faea00008ec contended 1 times, 2014 avg us</font></div><div><font size="2"   >[1973] lock 0x7faea00008c0 contended 1 times, 523 avg us</font></div><div><font size="2"   >[23916] lock 0x7f1440f07360 contended 4 times, 134 avg us</font></div><p></p></pre></div><div><br></div><div>本文涉及的probe alias原型 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># futex ______________________________________________________</font></div><div><font size="2"   ># long sys_futex(u32 __user *uaddr,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int op,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int val,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct timespec __user *utime,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u32 __user *uaddr2,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int val3)</font></div><div><font size="2"   ># long compat_sys_futex(u32 __user *uaddr, int op, u32 val,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct compat_timespec __user *utime, u32 __user *uaddr2,</font></div><div><font size="2"   ># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u32 val3)</font></div><div><font size="2"   >#</font></div><div><font size="2"   >probe syscall.futex = kernel.function("sys_futex").call ?</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "futex"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; futex_uaddr = $uaddr</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; op = $op</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; val = $val</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; utime_uaddr = $utime</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uaddr2_uaddr = $uaddr2</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; val3 = $val3</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if ($op == 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%p, %s, %d, %s", $uaddr, _futex_op_str($op),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $val, _struct_timespec_u($utime, 1))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argstr = sprintf("%p, %s, %d", $uaddr, _futex_op_str($op),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $val)</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe syscall.futex.return = kernel.function("sys_futex").return ?</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; name = "futex"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; retstr = return_str(1, $return)</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>源代码 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-150 linux]# stap -L 'kernel.function("sys_futex").return'</font></div><div><font size="2"   >kernel.function("sys_futex@kernel/futex.c:2692").return $return:long int $uaddr:u32* $op:int $val:u32 $utime:struct timespec* $uaddr2:u32* $val3:u32 $ts:struct timespec $t:ktime_t</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >/usr/src/debug/kernel-2.6.32-358.el6/linux-2.6.32-358.el6.x86_64/kernel/futex.c</font></div><div><div><font size="2"   >SYSCALL_DEFINE6(futex, u32 __user *, uaddr, int, op, u32, val,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct timespec __user *, utime, u32 __user *, uaddr2,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u32, val3)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct timespec ts;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ktime_t t, *tp = NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; u32 val2 = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int cmd = op &amp; FUTEX_CMD_MASK;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (utime &amp;&amp; (cmd == FUTEX_WAIT || cmd == FUTEX_LOCK_PI ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd == FUTEX_WAIT_BITSET ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd == FUTEX_WAIT_REQUEUE_PI)) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (copy_from_user(&amp;ts, utime, sizeof(ts)) != 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EFAULT;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!timespec_valid(&amp;ts))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t = timespec_to_ktime(ts);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (cmd == FUTEX_WAIT)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t = ktime_add_safe(ktime_get(), t);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp = &amp;t;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* requeue parameter in 'utime' if cmd == FUTEX_*_REQUEUE_*.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* number of waiters to wake in 'utime' if cmd == FUTEX_WAKE_OP.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (cmd == FUTEX_REQUEUE || cmd == FUTEX_CMP_REQUEUE ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd == FUTEX_CMP_REQUEUE_PI || cmd == FUTEX_WAKE_OP)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val2 = (u32) (unsigned long) utime;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return do_futex(uaddr, op, val, tp, uaddr2, val2, val3);</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><br></div><div>[参考]</div><div>1. man 2 futex</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >FUTEX(2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Linux Programmer’s Manual &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FUTEX(2)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >NAME</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;futex - Fast Userspace Locking system call</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SYNOPSIS</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;linux/futex.h&gt;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;sys/time.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;int futex(int *uaddr, int op, int val, const struct timespec *timeout,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int *uaddr2, int val3);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >DESCRIPTION</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;The futex() system call provides a method for a program to wait for a value at a given address to change, and a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;method to wake up anyone waiting on a particular address (while the addresses for the same memory &nbsp;in &nbsp;separate</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;processes &nbsp;may &nbsp;not &nbsp;be equal, the kernel maps them internally so the same memory mapped in different locations</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;will correspond for futex() calls). &nbsp;It is typically used to implement the contended case of a lock &nbsp;in &nbsp;shared</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;memory, as described in futex(7).</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;When &nbsp;a &nbsp;futex(7) &nbsp;operation &nbsp;did not finish uncontended in userspace, a call needs to be made to the kernel to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;arbitrate. &nbsp;Arbitration can either mean putting the calling process to sleep or, conversely, waking &nbsp;a &nbsp;waiting</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;process.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Callers &nbsp;of &nbsp;this &nbsp;function are expected to adhere to the semantics as set out in futex(7). &nbsp;As these semantics</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;involve writing non-portable assembly instructions, this in turn probably means that most users will in fact be</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;library authors and not general application developers.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;The &nbsp;uaddr argument needs to point to an aligned integer which stores the counter. &nbsp;The operation to execute is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;passed via the op argument, along with a value val.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Five operations are currently defined:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;FUTEX_WAIT</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This operation atomically verifies that the futex address uaddr still contains the value val, and sleeps</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; awaiting &nbsp;FUTEX_WAKE &nbsp;on this futex address. &nbsp;If the timeout argument is non-NULL, its contents describe</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the maximum duration of the wait, which is infinite &nbsp;otherwise. &nbsp; The &nbsp;arguments &nbsp;uaddr2 &nbsp;and &nbsp;val3 &nbsp;are</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored.</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For &nbsp;futex(7), &nbsp;this &nbsp;call &nbsp;is executed if decrementing the count gave a negative value (indicating con-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tention), and will sleep until another process releases the futex and executes the FUTEX_WAKE operation.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;FUTEX_WAKE</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This operation wakes at most val processes waiting on this futex address (i.e., inside FUTEX_WAIT). &nbsp;The</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arguments timeout, uaddr2 and val3 are ignored.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For futex(7), this is executed if incrementing the count showed that there were waiters, once the &nbsp;futex</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value has been set to 1 (indicating that it is available).</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;FUTEX_FD (present up to and including Linux 2.6.25)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; To &nbsp;support &nbsp;asynchronous wakeups, this operation associates a file descriptor with a futex. &nbsp;If another</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process executes a FUTEX_WAKE, the process will receive the signal number that was passed in &nbsp;val. &nbsp; The</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; calling &nbsp;process &nbsp;must &nbsp;close the returned file descriptor after use. &nbsp;The arguments timeout, uaddr2 and</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val3 are ignored.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; To prevent race conditions, the caller should test if the futex has been upped after FUTEX_FD returns.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Because it was inherently racy, FUTEX_FD has been removed from Linux 2.6.26 onwards.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;FUTEX_REQUEUE (since Linux 2.5.70)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This operation was introduced in order to avoid a "thundering herd" effect when FUTEX_WAKE is &nbsp;used &nbsp;and</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all &nbsp;processes &nbsp;woken &nbsp;up need to acquire another futex. &nbsp;This call wakes up val processes, and requeues</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all other waiters on the futex at address uaddr2. &nbsp;The arguments timeout and val3 are ignored.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;FUTEX_CMP_REQUEUE (since Linux 2.6.7)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; There was a race in the intended use of FUTEX_REQUEUE, so FUTEX_CMP_REQUEUE &nbsp;was &nbsp;introduced. &nbsp; This &nbsp;is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; similar to FUTEX_REQUEUE, but first checks whether the location uaddr still contains the value val3. &nbsp;If</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not, the operation fails with the error EAGAIN. &nbsp;The argument timeout is ignored.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >RETURN VALUE</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Depending on which operation was executed, the returned value for a successful call can &nbsp;have &nbsp;differing &nbsp;mean-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;ings.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;FUTEX_WAIT</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Returns &nbsp;0 &nbsp;if the process was woken by a FUTEX_WAKE call. &nbsp;In case of timeout, the operation fails with</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the error ETIMEDOUT. &nbsp;If the futex was not equal to the expected value, the &nbsp;operation &nbsp;fails &nbsp;with &nbsp;the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error &nbsp;EWOULDBLOCK. &nbsp;Signals (see signal(7)) or other spurious wakeups cause FUTEX_WAIT to fail with the</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error EINTR.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;FUTEX_WAKE</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Returns the number of processes woken up.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;FUTEX_FD</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Returns the new file descriptor associated with the futex.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;FUTEX_REQUEUE</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Returns the number of processes woken up.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;FUTEX_CMP_REQUEUE</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Returns the number of processes woken up.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;In the event of an error, all operations return -1, and set errno to indicate the error.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >ERRORS</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;EACCES No read access to futex memory.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;EAGAIN FUTEX_CMP_REQUEUE found an unexpected futex value. &nbsp;(This &nbsp;probably &nbsp;indicates &nbsp;a &nbsp;race; &nbsp;use &nbsp;the &nbsp;safe</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FUTEX_WAKE now.)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;EFAULT Error in getting timeout information from userspace.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;EINVAL An operation was not defined or error in page alignment.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;ENFILE The system limit on the total number of open files has been reached.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;ENOSYS Invalid operation specified in op.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >VERSIONS</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Initial &nbsp;futex support was merged in Linux 2.5.7 but with different semantics from what was described above. &nbsp;A</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;4-argument system call with the semantics given here was introduced in Linux 2.5.40. &nbsp;In Linux 2.5.70 one argu-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;ment was added. &nbsp;In Linux 2.6.7 a sixth argument was added ― messy, especially on the s390 architecture.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CONFORMING TO</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;This system call is Linux-specific.</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >NOTES</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;To &nbsp;reiterate, bare futexes are not intended as an easy-to-use abstraction for end-users. &nbsp;(There is no wrapper</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;function for this system call in glibc.) &nbsp;Implementors are expected to be assembly literate and &nbsp;to &nbsp;have &nbsp;read</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;the sources of the futex userspace library referenced below.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SEE ALSO</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;futex(7)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Fuss, &nbsp;Futexes &nbsp;and Furwocks: Fast Userlevel Locking in Linux (proceedings of the Ottawa Linux Symposium 2002),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;futex example library, futex-*.tar.bz2 &lt;URL:ftp://ftp.nl.kernel.org/pub/linux/kernel/people/rusty/&gt;.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >COLOPHON</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;This page is part of release 3.22 of the Linux man-pages project. &nbsp;A description of the project, &nbsp;and &nbsp;informa-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;tion about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Linux &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2008-11-27 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FUTEX(2)</font></div></div><p></p></pre></div><div><br></div><div>2. man 7 futex</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >FUTEX(7) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Linux Programmer’s Manual &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FUTEX(7)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >NAME</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;futex - Fast Userspace Locking</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SYNOPSIS</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;linux/futex.h&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >DESCRIPTION</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;The Linux kernel provides futexes ("Fast Userspace muTexes") as a building block for fast userspace locking and</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;semaphores. &nbsp;Futexes are very basic and lend themselves well for building &nbsp;higher &nbsp;level &nbsp;locking &nbsp;abstractions</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;such as POSIX mutexes.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;This &nbsp;page does not set out to document all design decisions but restricts itself to issues relevant for appli-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;cation and library development. &nbsp;Most programmers will in fact not be using futexes directly but &nbsp;instead &nbsp;rely</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;on system libraries built on them, such as the NPTL pthreads implementation.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;A futex is identified by a piece of memory which can be shared between different processes. &nbsp;In these different</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;processes, it need not have identical addresses. &nbsp;In its bare form, a futex has semaphore semantics; &nbsp;it &nbsp;is &nbsp;a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;counter &nbsp;that &nbsp;can &nbsp;be incremented and decremented atomically; processes can wait for the value to become posi-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;tive.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Futex operation is entirely userspace for the non-contended case. &nbsp;The kernel is only involved to arbitrate the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;contended &nbsp;case. &nbsp;As any sane design will strive for non-contention, futexes are also optimized for this situa-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;tion.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;In its bare form, a futex is an aligned integer which is only touched by atomic assembler &nbsp;instructions. &nbsp; Pro-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;cesses &nbsp;can share this integer using mmap(2), via shared memory segments or because they share memory space, in</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;which case the application is commonly called multithreaded.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp;Semantics</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Any futex operation starts in userspace, but it may necessary to communicate with the kernel using the futex(2)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;system call.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;To "up" a futex, execute the proper assembler instructions that will cause the host CPU to atomically increment</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;the integer. &nbsp;Afterwards, check if it has in fact changed from 0 to 1, in which case there were no waiters &nbsp;and</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;the operation is done. &nbsp;This is the non-contended case which is fast and should be common.</font></div></div><div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;In &nbsp;the &nbsp;contended case, the atomic increment changed the counter from -1 &nbsp;(or some other negative number). &nbsp;If</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;this is detected, there are waiters. &nbsp;Userspace should now set the counter to 1 and instruct the kernel to wake</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;up any waiters using the FUTEX_WAKE operation.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Waiting &nbsp;on &nbsp;a futex, to "down" it, is the reverse operation. &nbsp;Atomically decrement the counter and check if it</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;changed to 0, in which case the operation is done and the futex was uncontended. &nbsp;In all &nbsp;other &nbsp;circumstances,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;the &nbsp;process should set the counter to -1 and request that the kernel wait for another process to up the futex.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;This is done using the FUTEX_WAIT operation.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;The futex(2) system call can optionally be passed a timeout specifying how long the kernel should wait for &nbsp;the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;futex &nbsp;to &nbsp;be &nbsp;upped. &nbsp; In this case, semantics are more complex and the programmer is referred to futex(2) for</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;more details. &nbsp;The same holds for asynchronous futex waiting.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >VERSIONS</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Initial futex support was merged in Linux 2.5.7 but with different semantics from those described above. &nbsp; Cur-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;rent semantics are available from Linux 2.5.40 onwards.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >NOTES</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;To &nbsp;reiterate, &nbsp;bare &nbsp;futexes &nbsp;are &nbsp;not intended as an easy to use abstraction for end-users. &nbsp;Implementors are</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;expected to be assembly literate and to have read the sources of the futex userspace library referenced &nbsp;below.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;This man page illustrates the most common use of the futex(2) primitives: it is by no means the only one.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SEE ALSO</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;futex(2)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Fuss, &nbsp;Futexes &nbsp;and Furwocks: Fast Userlevel Locking in Linux (proceedings of the Ottawa Linux Symposium 2002),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;futex example library, futex-*.tar.bz2 &lt;URL:ftp://ftp.kernel.org/pub/linux/kernel/people/rusty/&gt;.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >COLOPHON</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;This page is part of release 3.22 of the Linux man-pages project. &nbsp;A description of the project, &nbsp;and &nbsp;informa-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;tion about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Linux &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2002-12-31 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FUTEX(7)</font></div></div><p></p></pre></div><div><br></div><div>3.&nbsp;<a style="line-height: 28px;" rel="nofollow" href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide/futexcontentionsect.html"   >https://sourceware.org/systemtap/SystemTap_Beginners_Guide/futexcontentionsect.html</a></div></div>
	</div>
</div>
</body>
</html>