<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap examples, Profiling - 2 Call Graph Tracing</h2>
	<h5 id="">2013-11-19 21:03:12&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201310194403488/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>例子来自para-callgraph.stp 脚本, 该脚本用以输出指定函数的call,return之间发生的所有函数调用情况, 类似在PostgreSQL plpgsql中输出call stack.</div><div>脚本内容以及注解 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 network]# cd /usr/share/systemtap/testsuite/systemtap.examples/profiling</font></div><div><font size="2"   >[root@db-172-16-3-150 profiling]# cat&nbsp;para-callgraph.stp</font></div><div><div><font size="2"   >#! /usr/bin/env stap</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >function trace(entry_p, extra) {</font></div><div><font size="2"   >&nbsp; %( $# &gt; 1 %? if (tid() in trace) %) &nbsp;// systemtap 预编译, &nbsp;$#表示stap 传入的参数个数, 当参数个数大于1时, if (...)</font></div><div><font size="2"   >&nbsp; // 参考<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/16387704020139831157191/"   >http://blog.163.com/digoal@126/blog/static/16387704020139831157191/</a></font></div><div><font size="2"   >&nbsp; printf("%s%s%s %s\n",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;thread_indent (entry_p), &nbsp; //&nbsp;<span style="line-height: 28px;"   >entry_p,&nbsp;</span><span style="line-height: 28px;"   >空格个数</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(entry_p&gt;0?"-&gt;":"&lt;-"), &nbsp;//&nbsp;<span style="line-height: 28px;"   >entry_p&gt;0时-&gt;, 否则&lt;- &nbsp;对应 $1.call和$1.return 的传入的1和-1 . 可以看清函数调用结构.</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pp (),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;extra)</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >%( $# &gt; 1 %? &nbsp; //&nbsp;<span style="line-height: 28px;"   >systemtap 预编译,</span><span style="line-height: 28px;"   >&nbsp;</span></font></div><div><font size="2"   >global trace</font></div><div><font size="2"   >probe $2.call {</font></div><div><font size="2"   >&nbsp; trace[tid()] = 1 &nbsp;// 如果有2个stap参数, 第二个参数设置trace数组, 通过<span style="line-height: 28px;"   >if (tid() in trace)判断函数trace是否需要输出printf....</span></font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe $2.return {</font></div><div><font size="2"   >&nbsp; delete trace[tid()] &nbsp;// 函数返回后, 删除这个数组索引. 这样的话只有$2相关的函数事件才会输出printf(...)</font></div><div><font size="2"   >// 也就是说在$2.call触发后, $2.return触发前, 所有的$1的事件都会有printf输出.</font></div><div><font size="2"   >}</font></div><div><font size="2"   >%)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe $1.call &nbsp; { trace(1, $$parms) } &nbsp;// 输出函数的参数</font></div><div><font size="2"   >probe $1.return { trace(-1, $$return) } &nbsp;// 输出函数返回值</font></div></div><div><font size="2"   >// 这个例子如果只有1个stap参数, 那么会输出所有与这个参数相关的调用情况和返回情况.</font></div><div><font size="2"   >// 如果有2个参数, 那么当第二个参数对应的事件被第一个参数包含时, 仅仅输出第二个参数事件的详细调用情况.</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >// 如果传入参数为2, 那么去除预编译后的脚本如下 :&nbsp;</span></div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >#! /usr/bin/env stap</font></div><div style="line-height: 28px;"   ><font size="2"   ><br style="line-height: 28px;"   ></font></div><div style="line-height: 28px;"   ><font size="2"   >function trace(entry_p, extra) {</font></div><div style="line-height: 28px;"   ><font size="2"   >if (tid() in trace)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; printf("%s%s%s %s\n",</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;thread_indent (entry_p),</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(entry_p&gt;0?"-&gt;":"&lt;-"),</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pp (),</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;extra)</font></div><div style="line-height: 28px;"   ><font size="2"   >}</font></div><div style="line-height: 28px;"   ><font size="2"   ><br style="line-height: 28px;"   ></font></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >global trace</font></span></div><div style="line-height: 28px;"   ><font size="2"   >probe $2.call {</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; trace[tid()] = 1</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;&nbsp;<span style="line-height: 28px;"   >trace(1, $$parms) &nbsp;// 加这行, 方便观察$2.call触发开始.</span></font></div><div style="line-height: 28px;"   ><font size="2"   >}</font></div><div style="line-height: 28px;"   ><font size="2"   >probe $2.return {</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;&nbsp;<span style="line-height: 28px;"   >trace(-1, $$return) &nbsp;</span><span style="line-height: 28px;"   >// 加这行, 方便观察</span></font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; delete trace[tid()]</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; exit() // 加这行方便观察单次$2事件的中间调用, .$2.return触发后, stap立刻退出</font></div><div style="line-height: 28px;"   ><font size="2"   >}</font></div><div style="line-height: 28px;"   ><font size="2"   ><br style="line-height: 28px;"   ></font></div><div style="line-height: 28px;"   ><font size="2"   >probe $1.call &nbsp; { trace(1, $$parms) }</font></div><div style="line-height: 28px;"   ><font size="2"   >probe $1.return { trace(-1, $$return) }</font></div><p></p></pre></div></div><div style="line-height: 28px;"   ><br></div><div>执行输出举例 :&nbsp;</div><div>// 第一个参数&nbsp;<span style="line-height: 28px;"   >'kernel.function("*@fs/*.c")'</span></div><div><span style="line-height: 28px;"   >// 第二个参数&nbsp;</span><span style="line-height: 28px;"   >'kernel.function("sys_read")'</span></div><div><span style="line-height: 28px;"   >// 第一个参数通配符中已经包含了第二个参数的事件.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 ~]# stap -L 'kernel.function("*@fs/*.c")'|grep sys_read</font></div><div><font size="2"   >...</font></div><div><font size="2"   >kernel.function("sys_read@fs/read_write.c:389") $fd:unsigned int $buf:char* $count:size_t $fput_needed:int</font></div><div><font size="2"   >...</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >// 因此以下stap的执行结果应该是只包含</span><span style="line-height: 28px;"   >'kernel.function("sys_read")'的调用和返回以及他们内部调用其他与</span><span style="line-height: 28px;"   >'kernel.function("*@fs/*.c")'通配符匹配的函数事件. 不会出现其他函数的输出.</span></div><div><span style="line-height: 28px;"   >// 以下结果我们看到</span><span style="line-height: 28px;"   >sys_read这个函数中间还调用了其他什么函数(</span><span style="line-height: 28px;"   >kernel.function("*@fs/*.c")通配符匹配的函数</span><span style="line-height: 28px;"   >).</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 profiling]# stap para-callgraph.stp 'kernel.function("*@fs/*.c")' 'kernel.function("sys_read")'</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;0 stapio(6305):-&gt;kernel.function("sys_read@fs/read_write.c:389").call fd=0x4 buf=0x7fff7c222af0 count=0x2004</font></div><div><font size="2"   >&nbsp; &nbsp; 10 stapio(6305): -&gt;kernel.function("fget_light@fs/file_table.c:298").call fd=0x4 fput_needed=0xffff8817e3005f54</font></div><div><font size="2"   >&nbsp; &nbsp; 15 stapio(6305): &lt;-kernel.function("fget_light@fs/file_table.c:298").return return=0xffff88181950cc80</font></div><div><font size="2"   >&nbsp; &nbsp; 33 stapio(6305): -&gt;kernel.function("vfs_read@fs/read_write.c:294").call file=0xffff88181950cc80 buf=0x7fff7c222af0 count=0x2004 pos=0xffff8817e3005f48</font></div><div><font size="2"   >&nbsp; &nbsp; 40 stapio(6305): &nbsp;-&gt;kernel.function("rw_verify_area@fs/read_write.c:232").call read_write=0x0 file=0xffff88181950cc80 ppos=0xffff8817e3005f48 count=0x2004</font></div><div><font size="2"   >&nbsp; &nbsp; 45 stapio(6305): &nbsp;&lt;-kernel.function("rw_verify_area@fs/read_write.c:232").return return=0x2004</font></div><div><font size="2"   >&nbsp; &nbsp; 51 stapio(6305): &nbsp;-&gt;kernel.function("inotify_inode_queue_event@fs/notify/inotify/inotify.c:297").call inode=0xffff881816fbd3d8 mask=0x1 cookie=0x0 name=0x0 n_inode=0x0</font></div><div><font size="2"   >&nbsp; &nbsp; 55 stapio(6305): &nbsp;&lt;-kernel.function("inotify_inode_queue_event@fs/notify/inotify/inotify.c:297").return&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; 60 stapio(6305): &nbsp;-&gt;kernel.function("__fsnotify_parent@fs/notify/fsnotify.c:80").call dentry=0xffff88172e1c7680 mask=0x1</font></div><div><font size="2"   >&nbsp; &nbsp; 64 stapio(6305): &nbsp;&lt;-kernel.function("__fsnotify_parent@fs/notify/fsnotify.c:80").return&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; 69 stapio(6305): &nbsp;-&gt;kernel.function("inotify_dentry_parent_queue_event@fs/notify/inotify/inotify.c:329").call dentry=0xffff88172e1c7680 mask=0x1 cookie=0x0 name=0xffff88172e1c7720</font></div><div><font size="2"   >&nbsp; &nbsp; 73 stapio(6305): &nbsp;&lt;-kernel.function("inotify_dentry_parent_queue_event@fs/notify/inotify/inotify.c:329").return&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; 79 stapio(6305): &nbsp;-&gt;kernel.function("fsnotify@fs/notify/fsnotify.c:135").call to_tell=0xffff881816fbd3d8 mask=0x1 data=0xffff881816fbd3d8 data_is=0x2 file_name=0x0 cookie=0x0</font></div><div><font size="2"   >&nbsp; &nbsp; 83 stapio(6305): &nbsp;&lt;-kernel.function("fsnotify@fs/notify/fsnotify.c:135").return&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; 86 stapio(6305): &lt;-kernel.function("vfs_read@fs/read_write.c:294").return return=0xc</font></div><div><font size="2"   >&nbsp; &nbsp; 91 stapio(6305): -&gt;kernel.function("fput@fs/file_table.c:196").call file=0xffff88181950cc80</font></div><div><font size="2"   >&nbsp; &nbsp; 94 stapio(6305): &lt;-kernel.function("fput@fs/file_table.c:196").return&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp;107 stapio(6305):&lt;-kernel.function("sys_read@fs/read_write.c:389").return return=0xc</font></div><p></p></pre></div><div>// 如果把$1的范围放大到所有函数, 则可以跟踪到sys_read的所有函数调用. 但是这样会比较慢甚至把操作系统搞挂. 产生的ko也非常巨大.</div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >本文事件源代码 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct file *file;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ssize_t ret = -EBADF;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int fput_needed;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; file = fget_light(fd, &amp;fput_needed);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (file) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loff_t pos = file_pos_read(file);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = vfs_read(file, buf, count, &amp;pos);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file_pos_write(file, pos);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fput_light(file, fput_needed);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return ret;</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>[参考]</div><div>1. https://sourceware.org/systemtap/SystemTap_Beginners_Guide/mainsect-profiling.html</div><div>2. https://sourceware.org/systemtap/examples/</div><div>3. /usr/share/systemtap/testsuite/systemtap.examples</div><div>4. systemtap-testsuite</div><div>5. /usr/share/systemtap/testsuite/systemtap.examples/index.txt</div><div>6. /usr/share/systemtap/testsuite/systemtap.examples/keyword-index.txt</div><div>7. /usr/share/systemtap/tapset</div><div>8.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/163877040201362691522349/"   >http://blog.163.com/digoal@126/blog/static/163877040201362691522349/</a></div><div>9.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/16387704020139831157191/"   >http://blog.163.com/digoal@126/blog/static/16387704020139831157191/</a></div><wbr></div>
	</div>
</div>
</body>
</html>