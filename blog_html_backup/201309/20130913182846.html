<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">systemtap Auxiliary functions and Embedded C</h2>
	<h5 id="">2013-09-13 18:28:46&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013813473578/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>一. systemtap函数</div><div>systemtap 中的函数只支持标量变量. 也就是systemtap支持的字符串和长整型.</div><pre class="prettyprint"   ><p></p><div><font size="2"   >Functions may take any number of scalar arguments, and must return a single scalar value. Scalars in this context are integers or strings.</font></div><div></div><p></p></pre><div><span style="line-height: 22px;"   >语法如下</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >function &lt;name&gt;[:&lt;type&gt;] ( &lt;arg1&gt;[:&lt;type&gt;], ... ) { &lt;stmts&gt; }</font></div><div></div><p></p></pre><div><span style="line-height: 22px;"   >可以指定变量类型, 也可以不指定变量类型</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >function thisfn (arg1, arg2) {</font></div><div><font size="2"   >&nbsp; &nbsp; return arg1 + arg2</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >function thatfn:string(arg1:long, arg2) {</font></div><div><font size="2"   >&nbsp; &nbsp; return sprintf("%d%s", arg1, arg2)</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div>并且systemtap函数支持递归调用, 但是递归次数受到安全限制. 参考 :&nbsp;</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201381021752228/"   >http://blog.163.com/digoal@126/blog/static/163877040201381021752228/</a></div><div><br></div><div>二.&nbsp;Embedded C</div><div>systemtap脚本中支持嵌入C代码. 嵌入的C代码使用符号%{和%}包围起来.</div><div>嵌入的C代码可以嵌入到脚本的最顶层, 也就是最外层, 与函数, 全局变量, probe一个级别.&nbsp;</div><div>嵌入的C代码也可以作为函数体使用, &nbsp;</div><div>甚至可以用在表达式中.</div><div>例如 :　</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >%{</font></div><div><font size="2"   >#include &lt;linux/in.h&gt;</font></div><div><font size="2"   >#include &lt;linux/ip.h&gt;</font></div><div><font size="2"   >%} /* &lt;-- top level */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* Reads the char value stored at a given address: */&nbsp;</font></div><div><font size="2"   >function __read_char:long(addr:long) %{ /* pure */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STAP_RETVALUE = kderef(sizeof(char), STAP_ARG_addr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CATCH_DEREF_FAULT ();</font></div><div><font size="2"   >%} /* &lt;-- function body */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* Determines whether an IP packet is TCP, based on the iphdr: */</font></div><div><font size="2"   >function is_tcp_packet:long(iphdr) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;protocol = @cast(iphdr, "iphdr")-&gt;protocol</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return (protocol == %{ IPPROTO_TCP %}) /* &lt;-- expression */</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>三.&nbsp;Embedded C functions</div><div>嵌入C代码作为systemtap 函数体时, 语法如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >function &lt;name&gt;:&lt;type&gt; ( &lt;arg1&gt;:&lt;type&gt;, ... ) %{ &lt;C_stmts&gt; %}</font></div><div><font size="2"   >The enclosed code may do anything reasonable and safe as allowed by the C parser.</font></div><p></p></pre></div><div>在函数体内的C代码中可以执行c parser允许的任何事情. (也就是说在systemtap脚本中的C代码不是完全没有保护的. 保护的责任交给了c parser)</div><div>c parser在这里就不深究了.</div><div>同时在systemtap脚本中还有一套复杂的约束体现, 在并发, 资源开销, handler的执行时间方面做了一些限制. 以免handler给内核带来太大的负担或者造成系统crash. 但是这些约束无法对嵌入的C代码进行检查, 所以使用C代码比使用systemtap 普通的脚本更危险.</div><div><div><pre class="prettyprint"   ><p><font size="2"   >There are a number of undocumented but complex safety constraints on concurrency, resource consumption and runtime limits that are applied to code written in the SystemTap language. These constraints are not applied to embedded C code, so use embedded C code with extreme caution. Be especially careful when dereferencing pointers. Use the kread() macro to dereference any pointers that could potentially be invalid or dangerous. If you are unsure, err on the side of caution and use kread(). The kread() macro is one of the safety mechanisms used in code generated by embedded C. It protects against pointer accesses that could crash the system.</font></p></pre></div><div><span style="line-height: 22px;"   >例如dereference操作, 尽量使用kread()宏来完成.&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >For example, to access the pointer chain name = skb-&gt;dev-&gt;name in embedded C, use the following code.</font></div><div><font size="2"   >struct net_device *dev;</font></div><div><font size="2"   >char *name;</font></div><div><font size="2"   >dev = kread(&amp;(skb-&gt;dev));</font></div><div><font size="2"   >name = kread(&amp;(dev-&gt;name));</font></div><p></p></pre></div><div>C函数体和systemtap函数的输入输出交互使用宏</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 22px;"   >STAP_ARG_foo&nbsp;</span><span style="line-height: 22px;"   >(for arguments named foo)</span></font></div><div><span style="line-height: 22px;"   ><font size="2"   >和</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   >STAP_RETVALUE</font></span></div><p></p></pre></div><div><span style="line-height: 22px;"   >例如 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >The memory locations reserved for input and output values are provided to a function using macros named STAP_ARG_foo (for arguments named foo) and STAP_RETVALUE. The following are examples.</font></div><div><font size="2"   >function add_one (val:long) %{</font></div><div><font size="2"   >&nbsp; &nbsp; STAP_RETVALUE = STAP_ARG_val + 1;</font></div><div><font size="2"   >%}</font></div><div><font size="2"   >function add_one_str:string (val:string) %{</font></div><div><font size="2"   >&nbsp; &nbsp; strlcpy (STAP_RETVALUE, STAP_ARG_val, MAXSTRINGLEN);</font></div><div><font size="2"   >&nbsp; &nbsp; strlcat (STAP_RETVALUE, "one", MAXSTRINGLEN);</font></div><div><font size="2"   >%}</font></div><div><font size="2"   >The function argument and return value types should be stated; the translator does not analyze the embedded C code within the function. You should examine C code generated for ordinary script language functions to write compatible embedded-C.&nbsp;</font></div><p></p></pre></div><div>注意使用C函数体的函数, 最好强制指定返回值类型和参数类型. 例如&nbsp;<span style="line-height: 22px;"   >function add_one_str:string (val:string) %{</span></div><div><br></div><div><pre class="prettyprint"   ><p><font size="2"   >Note that all SystemTap functions and probes run with interrupts disabled, thus you cannot call functions that might sleep within the embedded C.</font></p></pre></div></div><div>最后还要注意的是, 在systemtap函数以及probe handler中不允许使用中断, 所以在函数中类似sleep这样的处理是不允许的.</div><div><br></div><div>四.&nbsp;Embedded C pragma comments</div><div>用户可以在嵌入的C代码的注释中包含一些特定的信息, 这些信息的用途是告诉systemtap在对这部分代码解释时实施什么样的优化手段以及赋予什么样的安全属性.</div><div>例如嵌入C代码的systemtap脚本, 正常情况下是不能直接执行的. 需要带上-g 参数, 用guru模式执行.</div><div>例如 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp&nbsp;</font></div><div><font size="2"   >function test:long (arg1:long)&nbsp;</font></div><div><font size="2"   >%{</font></div><div><font size="2"   >&nbsp; STAP_RETVALUE = ++STAP_ARG_arg1 ;</font></div><div><font size="2"   >%}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe begin {</font></div><div><font size="2"   >&nbsp; v1 = test($1)</font></div><div><font size="2"   >&nbsp; printf("%d\n", v1)</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>直接执行的话, 会出现一个报错. &nbsp;(<span style="line-height: 22px;"   >parse error: embedded code in unprivileged script; need stap -g</span><span style="line-height: 22px;"   >)</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 5 test.stp 10</font></div><div><font size="2"   >Parsed kernel "/lib/modules/2.6.18-348.12.1.el5/build/.config", containing 1977 tuples</font></div><div><font size="2"   >Parsed kernel /lib/modules/2.6.18-348.12.1.el5/build/Module.symvers, which contained 3546 vmlinux exports</font></div><div><font size="2"   >parse error: embedded code in unprivileged script; need stap -g</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; saw: embedded-code at test.stp:2:1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;source: %{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div><font size="2"   >1 parse error.</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/x86_64/*.stp ", found: 4, processed: 4</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/*.stp ", found: 81, processed: 81</font></div><div><font size="2"   >Pass 1: parsed user script and 85 library script(s) using 146804virt/23692res/3016shr/21400data kb, in 160usr/10sys/172real ms.</font></div><div><font size="2"   >Pass 1: parse failed. &nbsp;Try again with another '--vp 1' option.</font></div><div><font size="2"   >Running rm -rf /tmp/stapkyhpL4</font></div><div><font size="2"   >Spawn waitpid result (0x0): 0</font></div><div><font size="2"   >Removed temporary directory "/tmp/stapkyhpL4"</font></div><p></p></pre></div></div><div>使用-g参数才可以执行 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 5 -g test.stp 10</font></div><div><font size="2"   >Parsed kernel "/lib/modules/2.6.18-348.12.1.el5/build/.config", containing 1977 tuples</font></div><div><font size="2"   >Parsed kernel /lib/modules/2.6.18-348.12.1.el5/build/Module.symvers, which contained 3546 vmlinux exports</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/x86_64/*.stp ", found: 4, processed: 4</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/*.stp ", found: 81, processed: 81</font></div><div><font size="2"   >Pass 1: parsed user script and 85 library script(s) using 146800virt/23712res/3008shr/21396data kb, in 190usr/10sys/205real ms.</font></div><div><font size="2"   >11</font></div><p></p></pre></div><div>或者使用comment. 如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Embedded C blocks may contain various markers to assert optimization and safety properties.</font></div><div><font size="2"   >/* pure */ means that the C code has no side effects and may be elided entirely if its value is not used by script code.</font></div><div><font size="2"   >/* unprivileged */ means that the C code is so safe that even unprivileged users are permitted to use it. (This is useful, in particular, to define an embedded-C function inside a tapset that may be used by unprivileged code.)</font></div><div><font size="2"   >/* myproc-unprivileged */ means that the C code is so safe that even unprivileged users are permitted to use it, provided that the target of the current probe is within the user's own process.</font></div><div><font size="2"   >/* guru */ means that the C code is so unsafe that a systemtap user must specify -g (guru mode) to use this, even if the C code is being exported from a tapset.</font></div><div><font size="2"   >/* unmangled */, used in an embedded-C function, means that the legacy (pre-1.8) argument access syntax should be made available inside the function. Hence, in addition to STAP_ARG_foo and STAP_RETVALUE one can use THIS-&gt;foo and THIS-&gt;__retvalue respectively inside the function. This is useful for quickly migrating code written for SystemTap version 1.7 and earlier.</font></div><div><font size="2"   >/* string */ in embedded-C expressions only, means that the expression has const char * type and should be treated as a string value, instead of the default long numeric.</font></div><p></p></pre></div><div>在tapset中大量的使用了嵌入C函数, 例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/usr/share/systemtap/tapset/ioblock.stp</font></div><div><div><font size="2"   >/* returns 0 for read, 1 for write */</font></div><div><font size="2"   >function bio_rw_num:long(rw:long)</font></div><div><font size="2"   >%{ /* pure */</font></div><div><font size="2"   >&nbsp; &nbsp; long rw = (long)STAP_ARG_rw;</font></div><div><font size="2"   >&nbsp; &nbsp; STAP_RETVALUE = (rw &amp; REQ_WRITE);</font></div><div><font size="2"   >%}</font></div></div><p></p></pre></div><div>注意它这里用到的comment, /* pure */ , 这个是告知systemtap c parser这部分C代码是安全的. 可以被任意用户使用.</div><div>下面我们在一个脚本中调用这个函数试试, 是不是不需要-g参数.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp&nbsp;</font></div><div><font size="2"   >probe begin {</font></div><div><font size="2"   >&nbsp; v1 = bio_rw_num($1)</font></div><div><font size="2"   >&nbsp; printf("%d\n", v1)</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >}</font></div></div><div><div style="line-height: 22px;"   ><font size="2"   >[root@db-172-16-3-39 ~]# stap test.stp 101</font></div><div style="line-height: 22px;"   ><font size="2"   >1</font></div></div><p></p></pre></div><div style="line-height: 22px;"   >果然不需要-g参数也可以正常执行.</div><div style="line-height: 22px;"   >那么我们如果把这个注释改成<span style="line-height: 22px;"   >/* guru */</span><span style="line-height: 22px;"   >&nbsp;, 按照手册的介绍, 它会需要-g才可以被调用.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 tapset]# vi ioblock.stp&nbsp;</font></div><div><div><font size="2"   >/* returns 0 for read, 1 for write */</font></div><div><font size="2"   >function bio_rw_num:long(rw:long)</font></div><div><font size="2"   >%{ /* guru */</font></div><div><font size="2"   >&nbsp; &nbsp; long rw = (long)STAP_ARG_rw;</font></div><div><font size="2"   >&nbsp; &nbsp; STAP_RETVALUE = (rw &amp; REQ_WRITE);</font></div><div><font size="2"   >%}</font></div></div><p></p></pre></div><div>再次调用前面的test.stp看看情况如何 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap test.stp 101</font></div><div><font size="2"   >semantic error: function may not be used unless -g is specified: identifier 'bio_rw_num' at /usr/share/systemtap/tapset/ioblock.stp:41:10</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: function bio_rw_num:long(rw:long)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div><p></p></pre></div><div>好了, 现在systemtap告诉你, 这个是需要加-g才能执行的.</div><div><br></div><div>最后需要注意的是, comment只有加到库stp文件中(-I指定或者系统指定默认的路径<span style="line-height: 22px;"   >/usr/share/systemtap/tapset</span><span style="line-height: 22px;"   >中)才有效.d</span></div><div><div style="line-height: 22px;"   >如果是放在本地需要执行的脚本中这些注释被无视. 例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp&nbsp;</font></div><div><font size="2"   >function test:long (arg1:long) &nbsp;</font></div><div><font size="2"   >%{ /* pure */</font></div><div><font size="2"   >&nbsp; STAP_RETVALUE = ++STAP_ARG_arg1 ;</font></div><div><font size="2"   >%}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe begin {</font></div><div><font size="2"   >&nbsp; v1 = test($1)</font></div><div><font size="2"   >&nbsp; printf("%d\n", v1)</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 5 test.stp 99</font></div><div><font size="2"   >Parsed kernel "/lib/modules/2.6.18-348.12.1.el5/build/.config", containing 1977 tuples</font></div><div><font size="2"   >Parsed kernel /lib/modules/2.6.18-348.12.1.el5/build/Module.symvers, which contained 3546 vmlinux exports</font></div><div><font size="2"   >parse error: embedded code in unprivileged script; need stap -g</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; saw: embedded-code at test.stp:2:1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;source: %{ /* pure */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div><font size="2"   >1 parse error.</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/x86_64/*.stp ", found: 4, processed: 4</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/*.stp ", found: 81, processed: 81</font></div><div><font size="2"   >Pass 1: parsed user script and 85 library script(s) using 146796virt/23688res/3016shr/21392data kb, in 170usr/0sys/172real ms.</font></div><div><font size="2"   >Pass 1: parse failed. &nbsp;Try again with another '--vp 1' option.</font></div><div><font size="2"   >Running rm -rf /tmp/stapyH0TYC</font></div><div><font size="2"   >Spawn waitpid result (0x0): 0</font></div><div><font size="2"   >Removed temporary directory "/tmp/stapyH0TYC"</font></div></div><p></p></pre></div></div><div>这个例子即使函数中带了注释/* pure */ 也是无助的. 还是需要-g参数.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 5 -g test.stp 99</font></div><div><font size="2"   >Parsed kernel "/lib/modules/2.6.18-348.12.1.el5/build/.config", containing 1977 tuples</font></div><div><font size="2"   >Parsed kernel /lib/modules/2.6.18-348.12.1.el5/build/Module.symvers, which contained 3546 vmlinux exports</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/x86_64/*.stp ", found: 4, processed: 4</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/*.stp ", found: 81, processed: 81</font></div><div><font size="2"   >Pass 1: parsed user script and 85 library script(s) using 146800virt/23704res/3008shr/21396data kb, in 150usr/20sys/173real ms.</font></div><div><font size="2"   >100</font></div><p></p></pre></div><div><br></div><div>但是如果把这个函数拆出来, 放到一个自定义库stp文件中, 这个注释就有效了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# vi /tmp/p.stp</font></div><div><div><font size="2"   >function test:long (arg1:long)</font></div><div><font size="2"   >%{ /* pure */</font></div><div><font size="2"   >&nbsp; STAP_RETVALUE = ++STAP_ARG_arg1 ;</font></div><div><font size="2"   >%}</font></div></div><p></p></pre></div><div>然后修改test.stp</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp&nbsp;</font></div><div><font size="2"   >probe begin {</font></div><div><font size="2"   >&nbsp; v1 = test($1)</font></div><div><font size="2"   >&nbsp; printf("%d\n", v1)</font></div><div><font size="2"   >&nbsp; exit()</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>再次执行, ok了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 5 -I /tmp test.stp 99</font></div><div><font size="2"   >Parsed kernel "/lib/modules/2.6.18-348.12.1.el5/build/.config", containing 1977 tuples</font></div><div><font size="2"   >Parsed kernel /lib/modules/2.6.18-348.12.1.el5/build/Module.symvers, which contained 3546 vmlinux exports</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/x86_64/*.stp ", found: 4, processed: 4</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/*.stp ", found: 81, processed: 81</font></div><div><font size="2"   >Searched: " /tmp/*.stp ", found: 2, processed: 2</font></div><div><font size="2"   >Pass 1: parsed user script and 87 library script(s) using 146916virt/23700res/3012shr/21512data kb, in 170usr/10sys/174real ms.</font></div><div><font size="2"   >100</font></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="https://sourceware.org/systemtap/langref/Components_SystemTap_script.html"   >https://sourceware.org/systemtap/langref/Components_SystemTap_script.html</a></div><div>2.&nbsp;<a style="line-height: 22px;" href="http://blog.163.com/digoal@126/blog/static/163877040201381021752228/"   >http://blog.163.com/digoal@126/blog/static/163877040201381021752228/</a></div></div>
	</div>
</div>
</body>
</html>