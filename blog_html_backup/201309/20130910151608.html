<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">systemtap SAFETY AND SECURITY</h2>
	<h5 id="">2013-09-10 15:16:08&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201381021752228/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>SAFETY AND SECURITY</div><div>systemtap 两个重要的组成部分, 脚本解释器编译器(包含安全性检测)stap程序, 以及加载stap编译好的模块的staprun后台程序(不做安全性检查).</div><div>&nbsp; &nbsp; &nbsp; &nbsp;Systemtap is an administrative tool. &nbsp;It exposes kernel internal data structures and potentially &nbsp;private &nbsp;user</div><div>&nbsp; &nbsp; &nbsp; &nbsp;information.</div><div>执行stap需要的操作系统权限如下</div><div>&nbsp; &nbsp; &nbsp; &nbsp;To actually run the kernel objects it builds, a user must be one of the following:</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;・ &nbsp; the root user;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;・ &nbsp; a member of the stapdev and stapusr groups;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;・ &nbsp; a member of the stapsys and stapusr groups; or</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;・ &nbsp; a member of the stapusr group.</div><div>可以build以及运行任何systemtap脚本的用户</div><div>&nbsp; &nbsp; &nbsp; &nbsp;The &nbsp;root user or a user who is a member of both the stapdev and stapusr groups can build and run any systemtap</div><div>&nbsp; &nbsp; &nbsp; &nbsp;script.</div><div>可以在限定条件下运行预build好的模块的用户</div><div>&nbsp; &nbsp; &nbsp; &nbsp;A user who is a member of both the stapsys and stapusr groups can only use pre-built modules under the &nbsp;follow-</div><div>&nbsp; &nbsp; &nbsp; &nbsp;ing conditions:</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;・ &nbsp; The &nbsp;module &nbsp;has &nbsp;been &nbsp;signed &nbsp;by a trusted signer. Trusted signers are normally systemtap compile-servers</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;which sign modules when the --privilege option is specified by the client. See &nbsp;the &nbsp;stap-server(8) &nbsp;manual</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;page for more information.</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;・ &nbsp; The module was built using the --privilege=stapsys or the --privilege=stapusr options.</div><div><span style="line-height: 22px;"   >可以在限定条件下运行预build好的模块的用户</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp;Members of only the stapusr group can only use pre-built modules under the following conditions:</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;・ &nbsp; The &nbsp;module &nbsp;is &nbsp;located &nbsp;in the /lib/modules/VERSION/systemtap directory. &nbsp;This directory must be owned by</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;root and not be world writable.</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;or</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;・ &nbsp; The module has been signed by a trusted signer. Trusted &nbsp;signers &nbsp;are &nbsp;normally &nbsp;systemtap &nbsp;compile-servers</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;which &nbsp;sign &nbsp;modules &nbsp;when the --privilege option is specified by the client. See the stap-server(8) manual</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;page for more information.</div></div><div><div>&nbsp; &nbsp; &nbsp; &nbsp;・ &nbsp; The module was built using the --privilege=stapusr option.</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;The kernel modules generated by stap program are run by the staprun program. &nbsp;The latter is a part of the &nbsp;Sys-</div><div>&nbsp; &nbsp; &nbsp; &nbsp;temtap package, dedicated to module loading and unloading (but only in the white zone), and kernel-to-user data</div><div>&nbsp; &nbsp; &nbsp; &nbsp;transfer. &nbsp;Since staprun does not perform any additional security checks on the kernel objects it is given, &nbsp;it</div><div>&nbsp; &nbsp; &nbsp; &nbsp;would be unwise for a system administrator to add untrusted users to the stapdev or stapusr groups.</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;The &nbsp;translator asserts certain safety constraints. &nbsp;It aims to ensure that no handler routine can run for very</div><div>&nbsp; &nbsp; &nbsp; &nbsp;long, allocate memory, perform unsafe operations, or in unintentionally interfere with &nbsp;the &nbsp;kernel. &nbsp; Uses &nbsp;of</div><div>&nbsp; &nbsp; &nbsp; &nbsp;script &nbsp;global variables are automatically read/write locked as appropriate, to protect against manipulation by</div><div>&nbsp; &nbsp; &nbsp; &nbsp;concurrent probe handlers. &nbsp;(Deadlocks are detected with timeouts. &nbsp;Use the -t flag to receive reports &nbsp;of &nbsp;ex-</div><div>&nbsp; &nbsp; &nbsp; &nbsp;cessive &nbsp;lock contention.) &nbsp;Use of guru mode constructs such as embedded C can violate these constraints, lead-</div><div>&nbsp; &nbsp; &nbsp; &nbsp;ing to kernel crash or data corruption.</div><div>以下宏被用作stap安全检测, 或者在运行过程中达到某些阈值退出运行.</div><div>为了减少stap对系统性能的影响, 同步事件的handler必须尽快处理并释放资源.</div><div>所以有如下限制. 使用stap -D 参数可以自定义.</div><div>&nbsp; &nbsp; &nbsp; &nbsp;The resource use limits are set by macros in the generated C code. &nbsp;These may be overridden with the &nbsp;-D &nbsp;flag.</div><div>&nbsp; &nbsp; &nbsp; &nbsp;A selection of these is as follows:</div><div>函数递归调用最大次数</div><div>&nbsp; &nbsp; &nbsp; &nbsp;MAXNESTING</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maximum &nbsp;number &nbsp;of nested function calls. &nbsp;Default determined by script analysis, with a bonus 10 slots</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; added for recursive scripts.</div><div>字符串最大长度</div><div>&nbsp; &nbsp; &nbsp; &nbsp;MAXSTRINGLEN</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maximum length of strings, default 128.</div><div>全局变量上获得锁的最大尝试次数, 超过次数后被视作死锁, 并跳过此handler, 记作一次skip.</div><div>&nbsp; &nbsp; &nbsp; &nbsp;MAXTRYLOCK</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maximum number of iterations to wait for locks on global variables before &nbsp;declaring &nbsp;possible &nbsp;deadlock</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and skipping the probe, default 1000.</div><div>单个probe hit(<span style="line-height: 22px;"   >with interrupts disabled</span><span style="line-height: 22px;"   >)的handler处理最大允许多少条语句. 包含递归.</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp;MAXACTION</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maximum &nbsp;number of statements to execute during any single probe hit (with interrupts disabled), default</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1000.</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;MAXACTION_INTERRUPTIBLE</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maximum number of statements to execute during any single probe hit which is &nbsp;executed &nbsp;with &nbsp;interrupts</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enabled (such as begin/end probes), default (MAXACTION * 10).</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;MAXBACKTRACE</div></div><div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maximum number of stack frames that will be be processed by the stap runtime unwinder as produced by the</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backtrace functions in the [u]context-unwind.stp tapsets, default 20.</div><div>数组长度限制, 仅仅限制未指定长度的数组</div><div>&nbsp; &nbsp; &nbsp; &nbsp;MAXMAPENTRIES</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Default maximum number of rows in any single global array, default 2048. &nbsp;Individual arrays may &nbsp;be &nbsp;de-</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clared with a larger or smaller limit instead:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; global big[10000],little[5]</div><div>错误退出限制</div><div>&nbsp; &nbsp; &nbsp; &nbsp;MAXERRORS</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maximum &nbsp;number &nbsp;of soft errors before an exit is triggered, default 0, which means that the first error</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; will exit the script. &nbsp;Note that with the --suppress-handler-errors option, this limit is not &nbsp;enforced.</div><div>跳过限制</div><div>&nbsp; &nbsp; &nbsp; &nbsp;MAXSKIPPED</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maximum &nbsp;number &nbsp;of &nbsp;skipped probes before an exit is triggered, default 100. &nbsp;Running systemtap with -t</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (timing) mode gives more details about skipped probes. &nbsp; With &nbsp;the &nbsp;default &nbsp;-DINTERRUPTIBLE=1 &nbsp;setting,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; probes &nbsp;skipped &nbsp;due &nbsp;to &nbsp;reentrancy &nbsp;are not accumulated against this limit. &nbsp;Note that with the --sup-</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; press-handler-errors option, this limit is not enforced.</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;MINSTACKSPACE</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Minimum number of free kernel stack bytes required in order to run a probe handler, default 1024. &nbsp; This</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; number should be large enough for the probe handler’s own needs, plus a safety margin.</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;MAXUPROBES</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maximum &nbsp;number of concurrently armed user-space probes (uprobes), default somewhat larger than the num-</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ber of user-space probe points named in the script. &nbsp;This pool needs to be potentialy large because &nbsp;in-</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dividual &nbsp;uprobe &nbsp;objects (about 64 bytes each) are allocated for each process for each matching script-</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level probe.</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;STP_MAXMEMORY</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Maximum amount of memory (in kilobytes) that the systemtap module should use, &nbsp;default &nbsp;unlimited. &nbsp; The</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memory &nbsp;size &nbsp;includes the size of the module itself, plus any additional allocations. &nbsp;This only tracks</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; direct allocations by the systemtap runtime. &nbsp;This does not &nbsp;track &nbsp;indirect &nbsp;allocations &nbsp;(as &nbsp;done &nbsp;by</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kprobes/uprobes/etc. internals).</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;STP_PROCFS_BUFSIZE</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size &nbsp;of &nbsp;procfs probe read buffers (in bytes). &nbsp;Defaults to MAXSTRINGLEN. &nbsp;This value can be overridden</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on a per-procfs file basis using the procfs read probe .maxsize(MAXSIZE) parameter.</div></div><div><div>&nbsp; &nbsp; &nbsp; With scripts that contain probes on any interrupt path, it is possible that those interrupts may occur &nbsp;in &nbsp;the</div><div>&nbsp; &nbsp; &nbsp; &nbsp;middle &nbsp;of &nbsp;another &nbsp;probe &nbsp;handler. &nbsp;The probe in the interrupt handler would be skipped in this case to avoid</div><div>&nbsp; &nbsp; &nbsp; &nbsp;reentrance. &nbsp;To work around this issue, execute stap with &nbsp;the &nbsp;option &nbsp;-DINTERRUPTIBLE=0 &nbsp;to &nbsp;mask &nbsp;interrupts</div><div>&nbsp; &nbsp; &nbsp; &nbsp;throughout &nbsp;the &nbsp;probe handler. &nbsp;This does add some extra overhead to the probes, but it may prevent reentrance</div><div>&nbsp; &nbsp; &nbsp; &nbsp;for common problem cases. &nbsp;However, probes in NMI handlers and in the callpath of the stap runtime may still be</div><div>&nbsp; &nbsp; &nbsp; &nbsp;skipped due to reentrance.</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;Multiple &nbsp;scripts &nbsp;can write data into a relay buffer concurrently. A host script provides an interface for ac-</div><div>&nbsp; &nbsp; &nbsp; &nbsp;cessing its relay buffer to guest scripts. &nbsp;Then, the output of the guests are merged into the &nbsp;output &nbsp;of &nbsp;the</div><div>&nbsp; &nbsp; &nbsp; &nbsp;host. &nbsp; To &nbsp;run &nbsp;a script as a host, execute stap with -DRELAYHOST[=name] option. The name identifies your host</div><div>&nbsp; &nbsp; &nbsp; &nbsp;script among several hosts. &nbsp;While running the host, execute stap &nbsp;with &nbsp;-DRELAYGUEST[=name] &nbsp;to &nbsp;add &nbsp;a &nbsp;guest</div><div>&nbsp; &nbsp; &nbsp; &nbsp;script &nbsp;to &nbsp;the &nbsp;host. &nbsp;Note that you must unload guests before unloading a host. If there are some guests con-</div><div>&nbsp; &nbsp; &nbsp; &nbsp;nected to the host, unloading the host will be failed.</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;In case something goes wrong with stap or staprun after a probe has already started &nbsp;running, &nbsp;one &nbsp;may &nbsp;safely</div><div>&nbsp; &nbsp; &nbsp; &nbsp;kill both user processes, and remove the active probe kernel module with rmmod. &nbsp;Any pending trace messages may</div><div>&nbsp; &nbsp; &nbsp; &nbsp;be lost.</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;In addition to the methods outlined above, the generated kernel module also uses overload &nbsp;processing &nbsp;to &nbsp;make</div><div>&nbsp; &nbsp; &nbsp; &nbsp;sure &nbsp;that &nbsp;probes can’t run for too long. &nbsp;If more than STP_OVERLOAD_THRESHOLD cycles (default 500000000) have</div><div>&nbsp; &nbsp; &nbsp; &nbsp;been spent in all the probes on a single cpu during the last STP_OVERLOAD_INTERVAL cycles (default 1000000000),</div><div>&nbsp; &nbsp; &nbsp; &nbsp;the probes have overloaded the system and an exit is triggered.</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;By &nbsp;default, &nbsp;overload processing is turned on for all modules. &nbsp;If you would like to disable overload process-</div><div>&nbsp; &nbsp; &nbsp; &nbsp;ing, define STP_NO_OVERLOAD (or its alias STAP_NO_OVERLOAD).</div></div><div><br></div><div>下面举几个例子 :&nbsp;</div><div><span style="line-height: 22px;"   >函数嵌套次数限制 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp&nbsp;</font></div><div><font size="2"   >global nest</font></div><div><font size="2"   >function fibonacci(i) {</font></div><div><font size="2"   >&nbsp; &nbsp; if (i &lt; 1) error ("bad number")</font></div><div><font size="2"   >&nbsp; &nbsp; if (i == 1) return 1</font></div><div><font size="2"   >&nbsp; &nbsp; if (i == 2) return 2</font></div><div><font size="2"   >&nbsp; &nbsp; nest++</font></div><div><font size="2"   >&nbsp; &nbsp; printf("nest: %d, i: %d\n", nest, i)</font></div><div><font size="2"   >&nbsp; &nbsp; return fibonacci (i-1) + fibonacci (i-2)</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe begin {</font></div><div><font size="2"   >&nbsp; &nbsp; printf ("%d's fibonacci number: %d\n", $1, fibonacci ($1))</font></div><div><font size="2"   >&nbsp; &nbsp; exit ()</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>单函数调用递归调用次数超出限制时 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 00001 -D MAXNESTING=6 test.stp 8</font></div><div><font size="2"   >Pass 5: starting run.</font></div><div><font size="2"   >ERROR: MAXNESTING exceeded near identifier 'fibonacci' at test.stp:2:10</font></div><div><font size="2"   >nest: 1, i: 8</font></div><div><font size="2"   >nest: 2, i: 7</font></div><div><font size="2"   >nest: 3, i: 6</font></div><div><font size="2"   >nest: 4, i: 5</font></div><div><font size="2"   >nest: 5, i: 4</font></div><div><font size="2"   >nest: 6, i: 3</font></div><div><font size="2"   >WARNING: Number of errors: 1, skipped probes: 0</font></div><div><font size="2"   >WARNING: /usr/bin/staprun exited with status: 1</font></div><div><font size="2"   >Pass 5: run completed in 10usr/20sys/307real ms.</font></div><div><font size="2"   >Pass 5: run failed. &nbsp;Try again with another '--vp 00001' option.</font></div><p></p></pre></div><div><br></div><div>函数嵌套次数限制<span style="line-height: 22px;"   >MAXNESTING</span><span style="line-height: 22px;"   >加大</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 00001 -D MAXNESTING=7 test.stp 8</font></div><div><font size="2"   >Pass 5: starting run.</font></div><div><font size="2"   >nest: 1, i: 8</font></div><div><font size="2"   >nest: 2, i: 7</font></div><div><font size="2"   >nest: 3, i: 6</font></div><div><font size="2"   >nest: 4, i: 5</font></div><div><font size="2"   >nest: 5, i: 4</font></div><div><font size="2"   >nest: 6, i: 3</font></div><div><font size="2"   >nest: 7, i: 3</font></div><div><font size="2"   >nest: 8, i: 4</font></div><div><font size="2"   >nest: 9, i: 3</font></div><div><font size="2"   >nest: 10, i: 5</font></div><div><font size="2"   >nest: 11, i: 4</font></div><div><font size="2"   >nest: 12, i: 3</font></div><div><font size="2"   >nest: 13, i: 3</font></div><div><font size="2"   >nest: 14, i: 6</font></div><div><font size="2"   >nest: 15, i: 5</font></div><div><font size="2"   >nest: 16, i: 4</font></div><div><font size="2"   >nest: 17, i: 3</font></div><div><font size="2"   >nest: 18, i: 3</font></div><div><font size="2"   >nest: 19, i: 4</font></div><div><font size="2"   >nest: 20, i: 3</font></div><div><font size="2"   >8's fibonacci number: 34</font></div><div><font size="2"   >Pass 5: run completed in 20usr/30sys/308real ms.</font></div><p></p></pre></div><div><br></div><div>单probe hit语句条数限制 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 00001 -D MAXNESTING=7 -D MAXACTION=10 test.stp 8</font></div><div><font size="2"   >Pass 5: starting run.</font></div><div><font size="2"   >ERROR: MAXACTION exceeded near keyword at test.stp:5:17</font></div><div><font size="2"   >nest: 1, i: 8</font></div><div><font size="2"   >nest: 2, i: 7</font></div><div><font size="2"   >nest: 3, i: 6</font></div><div><font size="2"   >nest: 4, i: 5</font></div><div><font size="2"   >nest: 5, i: 4</font></div><div><font size="2"   >nest: 6, i: 3</font></div><div><font size="2"   >nest: 7, i: 3</font></div><div><font size="2"   >nest: 8, i: 4</font></div><div><font size="2"   >nest: 9, i: 3</font></div><div><font size="2"   >nest: 10, i: 5</font></div><div><font size="2"   >nest: 11, i: 4</font></div><div><font size="2"   >nest: 12, i: 3</font></div><div><font size="2"   >WARNING: Number of errors: 1, skipped probes: 0</font></div><div><font size="2"   >WARNING: /usr/bin/staprun exited with status: 1</font></div><div><font size="2"   >Pass 5: run completed in 10usr/20sys/307real ms.</font></div><div><font size="2"   >Pass 5: run failed. &nbsp;Try again with another '--vp 00001' option.</font></div><p></p></pre></div><div><br></div><div>字符串长度限制</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp&nbsp;</font></div><div><font size="2"   >probe begin {</font></div><div><font size="2"   >&nbsp; &nbsp; a=@1</font></div><div><font size="2"   >&nbsp; &nbsp; printf ("%s\n", a)</font></div><div><font size="2"   >&nbsp; &nbsp; exit ()</font></div><div><font size="2"   >}</font></div></div><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -D MAXSTRINGLEN=2 test.stp abcdefghijkfffffffffffffffffffffffffffffff</font></div><div><font size="2"   >a</font></div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -D MAXSTRINGLEN=3 test.stp abcdefghijkfffffffffffffffffffffffffffffff</font></div><div><font size="2"   >ab</font></div></div><p></p></pre></div><div>超出部分被截断了.(注意字符串末尾\0需占1位.)</div><div><br></div><div>数组长度限制, 仅仅限制未指定长度的数组.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# cat test.stp&nbsp;</font></div><div><font size="2"   >global arr1[20], arr2</font></div><div><font size="2"   >probe begin {</font></div><div><font size="2"   >&nbsp; &nbsp; for (i=0; i&lt;20; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; arr1[i] = "test,arr1"</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; for (i=0; i&lt;$1; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; arr2[i] = "test,arr2"</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; foreach (s1- in arr1) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; printf ("%d, %s\n", s1, arr1[s1])</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; foreach (s2- in arr2) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; printf ("%d, %s\n", s2, arr2[s2])</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; exit ()</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>指定长度为20的数组不受<span style="line-height: 22px;"   >MAXMAPENTRIES的限制, 只有未指定长度的arr2收到这个限制.</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 00001 -D MAXMAPENTRIES=4 test.stp 5</font></div><div><font size="2"   >Pass 5: starting run.</font></div><div><font size="2"   >ERROR: Array overflow, check MAXMAPENTRIES near identifier 'arr2' at test.stp:7:7</font></div><div><font size="2"   >WARNING: Number of errors: 1, skipped probes: 0</font></div><div><font size="2"   >WARNING: /usr/bin/staprun exited with status: 1</font></div><div><font size="2"   >Pass 5: run completed in 10usr/20sys/307real ms.</font></div><div><font size="2"   >Pass 5: run failed. &nbsp;Try again with another '--vp 00001' option.</font></div><p></p></pre></div><div>如下, 指定长度为20的数组, 正常使用.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap --vp 00001 -D MAXMAPENTRIES=5 test.stp 5</font></div><div><font size="2"   >Pass 5: starting run.</font></div><div><font size="2"   >19, test,arr1</font></div><div><font size="2"   >18, test,arr1</font></div><div><font size="2"   >17, test,arr1</font></div><div><font size="2"   >16, test,arr1</font></div><div><font size="2"   >15, test,arr1</font></div><div><font size="2"   >14, test,arr1</font></div><div><font size="2"   >13, test,arr1</font></div><div><font size="2"   >12, test,arr1</font></div><div><font size="2"   >11, test,arr1</font></div><div><font size="2"   >10, test,arr1</font></div><div><font size="2"   >9, test,arr1</font></div><div><font size="2"   >8, test,arr1</font></div><div><font size="2"   >7, test,arr1</font></div><div><font size="2"   >6, test,arr1</font></div><div><font size="2"   >5, test,arr1</font></div><div><font size="2"   >4, test,arr1</font></div><div><font size="2"   >3, test,arr1</font></div><div><font size="2"   >2, test,arr1</font></div><div><font size="2"   >1, test,arr1</font></div><div><font size="2"   >0, test,arr1</font></div><div><font size="2"   >4, test,arr2</font></div><div><font size="2"   >3, test,arr2</font></div><div><font size="2"   >2, test,arr2</font></div><div><font size="2"   >1, test,arr2</font></div><div><font size="2"   >0, test,arr2</font></div><div><font size="2"   >Pass 5: run completed in 10usr/20sys/308real ms.</font></div><p></p></pre></div></div><div><br></div>[参考]<wbr><div>1. man stap</div><div>2.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="https://sourceware.org/systemtap/langref/SystemTap_overview.html"   >https://sourceware.org/systemtap/langref/SystemTap_overview.html</a></div></div>
	</div>
</div>
</body>
</html>