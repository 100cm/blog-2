<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL "Parallel" create index test</h2>
	<h5 id="">2012-03-02 11:40:21&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201222112937900/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">熟悉Oracle的同学肯定知道Oracle中有并行的HINT, 在创建索引是如果使用并行可大大提高速度, 当然是以加大资源开销为代价的.&nbsp;<div>在PostgreSQL中没有并行的概念, 一个SQL只会用到一个CPU核.</div><div>在做还原的时候 , 创建索引会消耗很多时间. 因为没有办法开启并行.</div><div>接下来我模拟一下PostgreSQL中开启并行来创建索引. (利用了PostgreSQL的partial index特性.)</div><div>首先创建测试表 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div>digoal=&gt; create table t1 (id int) ;</div><div>CREATE TABLE</div><p></p></pre></div><div>插入测试数据 :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div>digoal=&gt; insert into t1 select generate_series(0,31999999);</div><div>INSERT 0 32000000</div><p></p></pre></div>接下来我们不使用并行看看创建一个索引要多长时间 :&nbsp;<wbr></div><div><p></p><div><pre class="prettyprint"  ><p></p><div>digoal=&gt; create index idx_t1_id on t1(id) tablespace digoal_idx;</div><div>CREATE INDEX</div><div>Time: 61502.509 ms</div><p></p></pre></div><div>接下来我们把ID字段按照它的值拆分成8个段, 并行的创建8个partial索引.</div><div>这里使用ruby的多线程 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >#!/opt/ruby/bin/ruby<br>$id = 0<br><br>h1 = [:a,:b,:c,:d,:e,:f,:g,:h]<br><br>(0..7).each {<br>  |x|<br>  %x/psql -h 127.0.0.1 -p 1931 digoal digoal -c "drop index idx_t1_id_#{x}"/<br>}<br><br>(0..7).each {<br>  |x|<br>  h1["#{x}".to_i] = Thread.new {<br>    id = $id<br>    $id += 4000000<br>    Thread.pass<br>    puts( %x/date +%F%T/ )<br>    %x/psql -h 127.0.0.1 -p 1931 digoal digoal -c "create index idx_t1_id_#{x} on t1(id) tablespace digoal_idx where id&gt;=#{id} and id&lt;#{id+4000000}"/<br>    puts( %x/date +%F%T/ )<br>  }<br>}<br><br>(0..7).each {<br>  |x|<br>  p h1["#{x}".to_i].join<br>}</font></div><p></p></pre></div><div>执行结果 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >2012-03-0211:32:45<br>2012-03-0211:32:45<br>2012-03-0211:32:45<br>2012-03-0211:32:45<br>2012-03-0211:32:45<br>2012-03-0211:32:45<br>2012-03-0211:32:45<br>2012-03-0211:32:45<br>2012-03-0211:32:52<br>2012-03-0211:32:52<br>2012-03-0211:32:53<br>2012-03-0211:32:53<br>2012-03-0211:32:53<br>#&lt;Thread:0x0000000adb8f80 dead&gt;<br>2012-03-0211:32:53<br>2012-03-0211:32:53<br>2012-03-0211:32:53<br>#&lt;Thread:0x0000000adb8e90 dead&gt;<br>#&lt;Thread:0x0000000adb8da0 dead&gt;<br>#&lt;Thread:0x0000000adb8cb0 dead&gt;<br>#&lt;Thread:0x0000000adb8bc0 dead&gt;<br>#&lt;Thread:0x0000000adb93b8 dead&gt;<br>#&lt;Thread:0x0000000ad98f00 dead&gt;<br>#&lt;Thread:0x0000000ad996d0 dead&gt;</font></div><div></div><p></p></pre></div><div>并行创建耗时 : 8秒,</div><div>单线程创建是使用partial index并行创建耗时的7.6875倍.</div><div>我在想PG是不是可以考试考虑一下在创建索引的时候可以引入多线程呢.</div><div>但是请不要在生产中这么使用, 因为某些查询的执行计划会有问题, 例如跨了partial index的查询可能就走全表扫描了. 但是单个索引的情况下是不会发生这种情况的.</div><div>例如 :&nbsp;</div><div>下面这个查询跨了WHERE id &gt;= 0 AND id &lt; 4000000和WHERE id &gt;= 4000000 AND id &lt; 8000000的索引.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; explain analyze select * from t1 where id&gt;=3999995 and id&lt;4000009;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Seq Scan on t1 &nbsp;(cost=0.00..621593.00 rows=160000 width=4) (actual time=581.265..6931.473 rows=14 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;Filter: ((id &gt;= 3999995) AND (id &lt; 4000009))</font></div><div><font size="2"  >&nbsp;Total runtime: 6931.529 ms</font></div><div><font size="2"  >(3 rows)</font></div><p></p></pre></div><div>不跨partial index的查询会走索引 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; explain analyze select * from t1 where id&gt;=3999995 and id&lt;4000000;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Bitmap Heap Scan on t1 &nbsp;(cost=2518.47..122518.18 rows=160000 width=4) (actual time=0.033..0.035 rows=5 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;Recheck Cond: ((id &gt;= 3999995) AND (id &lt; 4000000))</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_t1_id_0 &nbsp;(cost=0.00..2478.47 rows=160000 width=0) (actual time=0.023..0.023 rows=5 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 3999995) AND (id &lt; 4000000))</font></div><div><font size="2"  >&nbsp;Total runtime: 0.131 ms</font></div><div><font size="2"  >(5 rows)</font></div><p></p></pre></div><div>下面是单一(complete)索引的情况, 走的就是索引了.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; explain analyze select * from t1 where id&gt;=3999995 and id&lt;4000009;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >-----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Bitmap Heap Scan on t1 &nbsp;(cost=2520.00..122519.72 rows=160000 width=4) (actual time=0.094..0.104 rows=14 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;Recheck Cond: ((id &gt;= 3999995) AND (id &lt; 4000009))</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on idx_t1_id_8 &nbsp;(cost=0.00..2480.00 rows=160000 width=0) (actual time=0.084..0.084 rows=14 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 3999995) AND (id &lt; 4000009))</font></div><div><font size="2"  >&nbsp;Total runtime: 0.156 ms</font></div><p></p></pre></div><div><br></div><p></p></div></div>
	</div>
</div>
</body>
</html>