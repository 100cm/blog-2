<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">ceph default values for mon, osd, radosgw, mds</h2>
	<h5 id="">2014-12-04 16:30:16&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201411441918267/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><span style="line-height: 28px;"   >ceph集群包括最基本的mon(monitor), osd(object storage devices)节点.</span></div><div><span style="line-height: 28px;"   >如果要使用ceph filesystem, 还需要mds(metadata server)节点.</span></div><div><span style="line-height: 28px;"   >如果要使用对象存储功能, 还需要radosgw(rados gateway)节点.</span></div><div>部署这些节点时, 需要大量的配置, 这些配置大部分是有默认值的, 如果使用源码安装ceph的话, 这些默认值在</div><div><span style="line-height: 28px;"   >src/common/config_opts.h中定义, 想修改的话就在这个文件里修改.</span></div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >http://ceph.com/download/ceph-0.87.tar.gz</span></div><wbr><div>src/common/config_opts.h</div><div><br></div><div><div><font size="1"   >[root@localhost ceph-0.87]# cat src/common/config_opts.h</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-</font></div><div><font size="1"   >// vim: ts=8 sw=2 smarttab</font></div><div><font size="1"   >/*</font></div><div><font size="1"   >&nbsp;* Ceph - scalable distributed file system</font></div><div><font size="1"   >&nbsp;*</font></div><div><font size="1"   >&nbsp;* Copyright (C) 2004-2006 Sage Weil &lt;sage@newdream.net&gt;</font></div><div><font size="1"   >&nbsp;*</font></div><div><font size="1"   >&nbsp;* This is free software; you can redistribute it and/or</font></div><div><font size="1"   >&nbsp;* modify it under the terms of the GNU Lesser General Public</font></div><div><font size="1"   >&nbsp;* License version 2.1, as published by the Free Software</font></div><div><font size="1"   >&nbsp;* Foundation. &nbsp;See file COPYING.</font></div><div><font size="1"   >&nbsp;*</font></div><div><font size="1"   >&nbsp;*/</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >/* note: no header guard */</font></div><div><font size="1"   >OPTION(host, OPT_STR, "localhost")</font></div><div><font size="1"   >OPTION(fsid, OPT_UUID, uuid_d())</font></div><div><font size="1"   >OPTION(public_addr, OPT_ADDR, entity_addr_t())</font></div><div><font size="1"   >OPTION(cluster_addr, OPT_ADDR, entity_addr_t())</font></div><div><font size="1"   >OPTION(public_network, OPT_STR, "")</font></div><div><font size="1"   >OPTION(cluster_network, OPT_STR, "")</font></div><div><font size="1"   >OPTION(num_client, OPT_INT, 1)</font></div><div><font size="1"   >OPTION(monmap, OPT_STR, "")</font></div><div><font size="1"   >OPTION(mon_host, OPT_STR, "")</font></div><div><font size="1"   >OPTION(lockdep, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(run_dir, OPT_STR, "/var/run/ceph") &nbsp; &nbsp; &nbsp; // the "/var/run/ceph" dir, created on daemon startup</font></div><div><font size="1"   >OPTION(admin_socket, OPT_STR, "$run_dir/$cluster-$name.asok") // default changed by common_preinit()</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(daemonize, OPT_BOOL, false) // default changed by common_preinit()</font></div><div><font size="1"   >OPTION(pid_file, OPT_STR, "") // default changed by common_preinit()</font></div><div><font size="1"   >OPTION(chdir, OPT_STR, "/")</font></div><div><font size="1"   >OPTION(max_open_files, OPT_LONGLONG, 0)</font></div><div><font size="1"   >OPTION(restapi_log_level, OPT_STR, "") &nbsp;// default set by Python code</font></div><div><font size="1"   >OPTION(restapi_base_url, OPT_STR, "") &nbsp; // "</font></div><div><font size="1"   >OPTION(fatal_signal_handlers, OPT_BOOL, true)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(log_file, OPT_STR, "/var/log/ceph/$cluster-$name.log") // default changed by common_preinit()</font></div><div><font size="1"   >OPTION(log_max_new, OPT_INT, 1000) // default changed by common_preinit()</font></div><div><font size="1"   >OPTION(log_max_recent, OPT_INT, 10000) // default changed by common_preinit()</font></div><div><font size="1"   >OPTION(log_to_stderr, OPT_BOOL, true) // default changed by common_preinit()</font></div><div><font size="1"   >OPTION(err_to_stderr, OPT_BOOL, true) // default changed by common_preinit()</font></div><div><font size="1"   >OPTION(log_to_syslog, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(err_to_syslog, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(log_flush_on_exit, OPT_BOOL, true) // default changed by common_preinit()</font></div><div><font size="1"   >OPTION(log_stop_at_utilization, OPT_FLOAT, .97) &nbsp;// stop logging at (near) full</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// options will take k/v pairs, or single-item that will be assumed as general</font></div><div><font size="1"   >// default for all, regardless of channel.</font></div><div><font size="1"   >// e.g., "info" would be taken as the same as "default=info"</font></div><div><font size="1"   >// also, "default=daemon audit=local0" would mean</font></div><div><font size="1"   >// &nbsp; &nbsp;"default all to 'daemon', override 'audit' with 'local0'</font></div><div><font size="1"   >OPTION(clog_to_monitors, OPT_STR, "default=true")</font></div><div><font size="1"   >OPTION(clog_to_syslog, OPT_STR, "false")</font></div><div><font size="1"   >OPTION(clog_to_syslog_level, OPT_STR, "info") // this level and above</font></div><div><font size="1"   >OPTION(clog_to_syslog_facility, OPT_STR, "default=daemon audit=local0")</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(mon_cluster_log_to_syslog, OPT_STR, "default=false")</font></div><div><font size="1"   >OPTION(mon_cluster_log_to_syslog_level, OPT_STR, "info") &nbsp; // this level and above</font></div><div><font size="1"   >OPTION(mon_cluster_log_to_syslog_facility, OPT_STR, "daemon")</font></div><div><font size="1"   >OPTION(mon_cluster_log_file, OPT_STR,</font></div><div><font size="1"   >&nbsp; &nbsp; "default=/var/log/ceph/$cluster.$channel.log cluster=/var/log/ceph/$cluster.log")</font></div><div><font size="1"   >OPTION(mon_cluster_log_file_level, OPT_STR, "info")</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >DEFAULT_SUBSYS(0, 5)</font></div><div><font size="1"   >SUBSYS(lockdep, 0, 1)</font></div><div><font size="1"   >SUBSYS(context, 0, 1)</font></div><div><font size="1"   >SUBSYS(crush, 1, 1)</font></div><div><font size="1"   >SUBSYS(mds, 1, 5)</font></div><div><font size="1"   >SUBSYS(mds_balancer, 1, 5)</font></div><div><font size="1"   >SUBSYS(mds_locker, 1, 5)</font></div><div><font size="1"   >SUBSYS(mds_log, 1, 5)</font></div><div><font size="1"   >SUBSYS(mds_log_expire, 1, 5)</font></div><div><font size="1"   >SUBSYS(mds_migrator, 1, 5)</font></div><div><font size="1"   >SUBSYS(buffer, 0, 1)</font></div><div><font size="1"   >SUBSYS(timer, 0, 1)</font></div><div><font size="1"   >SUBSYS(filer, 0, 1)</font></div><div><font size="1"   >SUBSYS(striper, 0, 1)</font></div><div><font size="1"   >SUBSYS(objecter, 0, 1)</font></div><div><font size="1"   >SUBSYS(rados, 0, 5)</font></div><div><font size="1"   >SUBSYS(rbd, 0, 5)</font></div><div><font size="1"   >SUBSYS(rbd_replay, 0, 5)</font></div><div><font size="1"   >SUBSYS(journaler, 0, 5)</font></div><div><font size="1"   >SUBSYS(objectcacher, 0, 5)</font></div><div><font size="1"   >SUBSYS(client, 0, 5)</font></div><div><font size="1"   >SUBSYS(osd, 0, 5)</font></div><div><font size="1"   >SUBSYS(optracker, 0, 5)</font></div><div><font size="1"   >SUBSYS(objclass, 0, 5)</font></div><div><font size="1"   >SUBSYS(filestore, 1, 3)</font></div><div><font size="1"   >SUBSYS(keyvaluestore, 1, 3)</font></div><div><font size="1"   >SUBSYS(journal, 1, 3)</font></div><div><font size="1"   >SUBSYS(ms, 0, 5)</font></div><div><font size="1"   >SUBSYS(mon, 1, 5)</font></div><div><font size="1"   >SUBSYS(monc, 0, 10)</font></div><div><font size="1"   >SUBSYS(paxos, 1, 5)</font></div><div><font size="1"   >SUBSYS(tp, 0, 5)</font></div><div><font size="1"   >SUBSYS(auth, 1, 5)</font></div><div><font size="1"   >SUBSYS(crypto, 1, 5)</font></div><div><font size="1"   >SUBSYS(finisher, 1, 1)</font></div><div><font size="1"   >SUBSYS(heartbeatmap, 1, 5)</font></div><div><font size="1"   >SUBSYS(perfcounter, 1, 5)</font></div><div><font size="1"   >SUBSYS(rgw, 1, 5) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // log level for the Rados gateway</font></div><div><font size="1"   >SUBSYS(civetweb, 1, 10)</font></div><div><font size="1"   >SUBSYS(javaclient, 1, 5)</font></div><div><font size="1"   >SUBSYS(asok, 1, 5)</font></div><div><font size="1"   >SUBSYS(throttle, 1, 1)</font></div><div><font size="1"   >SUBSYS(refs, 0, 0)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(key, OPT_STR, "")</font></div><div><font size="1"   >OPTION(keyfile, OPT_STR, "")</font></div><div><font size="1"   >OPTION(keyring, OPT_STR, "/etc/ceph/$cluster.$name.keyring,/etc/ceph/$cluster.keyring,/etc/ceph/keyring,/etc/ceph/keyring.bin") // default changed by common_preinit() for mds and osd</font></div><div><font size="1"   >OPTION(heartbeat_interval, OPT_INT, 5)</font></div><div><font size="1"   >OPTION(heartbeat_file, OPT_STR, "")</font></div><div><font size="1"   >OPTION(heartbeat_inject_failure, OPT_INT, 0) &nbsp; &nbsp;// force an unhealthy heartbeat for N seconds</font></div><div><font size="1"   >OPTION(perf, OPT_BOOL, true) &nbsp; &nbsp; &nbsp; // enable internal perf counters</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(ms_tcp_nodelay, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(ms_tcp_rcvbuf, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(ms_initial_backoff, OPT_DOUBLE, .2)</font></div><div><font size="1"   >OPTION(ms_max_backoff, OPT_DOUBLE, 15.0)</font></div><div><font size="1"   >OPTION(ms_nocrc, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(ms_die_on_bad_msg, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(ms_die_on_unhandled_msg, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(ms_die_on_old_message, OPT_BOOL, false) &nbsp; &nbsp; // assert if we get a dup incoming message and shouldn't have (may be triggered by pre-541cd3c64be0dfa04e8a2df39422e0eb9541a428 code)</font></div><div><font size="1"   >OPTION(ms_dispatch_throttle_bytes, OPT_U64, 100 &lt;&lt; 20)</font></div><div><font size="1"   >OPTION(ms_bind_ipv6, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(ms_bind_port_min, OPT_INT, 6800)</font></div><div><font size="1"   >OPTION(ms_bind_port_max, OPT_INT, 7300)</font></div><div><font size="1"   >OPTION(ms_rwthread_stack_bytes, OPT_U64, 1024 &lt;&lt; 10)</font></div><div><font size="1"   >OPTION(ms_tcp_read_timeout, OPT_U64, 900)</font></div><div><font size="1"   >OPTION(ms_pq_max_tokens_per_priority, OPT_U64, 16777216)</font></div><div><font size="1"   >OPTION(ms_pq_min_cost, OPT_U64, 65536)</font></div><div><font size="1"   >OPTION(ms_inject_socket_failures, OPT_U64, 0)</font></div><div><font size="1"   >OPTION(ms_inject_delay_type, OPT_STR, "") &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// "osd mds mon client" allowed</font></div><div><font size="1"   >OPTION(ms_inject_delay_msg_type, OPT_STR, "") &nbsp; &nbsp; &nbsp;// the type of message to delay, as returned by Message::get_type_name(). This is an additional restriction on the general type filter ms_inject_delay_type.</font></div><div><font size="1"   >OPTION(ms_inject_delay_max, OPT_DOUBLE, 1) &nbsp; &nbsp; &nbsp; &nbsp; // seconds</font></div><div><font size="1"   >OPTION(ms_inject_delay_probability, OPT_DOUBLE, 0) // range [0, 1]</font></div><div><font size="1"   >OPTION(ms_inject_internal_delays, OPT_DOUBLE, 0) &nbsp; // seconds</font></div><div><font size="1"   >OPTION(ms_dump_on_send, OPT_BOOL, false) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // hexdump msg to log on send</font></div><div><font size="1"   >OPTION(ms_dump_corrupt_message_level, OPT_INT, 1) &nbsp;// debug level to hexdump undecodeable messages at</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(inject_early_sigterm, OPT_BOOL, false)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(mon_data, OPT_STR, "/var/lib/ceph/mon/$cluster-$id")</font></div><div><font size="1"   >OPTION(mon_initial_members, OPT_STR, "") &nbsp; &nbsp;// list of initial cluster mon ids; if specified, need majority to form initial quorum and create new cluster</font></div><div><font size="1"   >OPTION(mon_sync_fs_threshold, OPT_INT, 5) &nbsp; // sync() when writing this many objects; 0 to disable.</font></div><div><font size="1"   >OPTION(mon_compact_on_start, OPT_BOOL, false) &nbsp;// compact leveldb on ceph-mon start</font></div><div><font size="1"   >OPTION(mon_compact_on_bootstrap, OPT_BOOL, false) &nbsp;// trigger leveldb compaction on bootstrap</font></div><div><font size="1"   >OPTION(mon_compact_on_trim, OPT_BOOL, true) &nbsp; &nbsp; &nbsp; // compact (a prefix) when we trim old states</font></div><div><font size="1"   >OPTION(mon_tick_interval, OPT_INT, 5)</font></div><div><font size="1"   >OPTION(mon_subscribe_interval, OPT_DOUBLE, 300)</font></div><div><font size="1"   >OPTION(mon_delta_reset_interval, OPT_DOUBLE, 10) &nbsp; // seconds of inactivity before we reset the pg delta to 0</font></div><div><font size="1"   >OPTION(mon_osd_laggy_halflife, OPT_INT, 60*60) &nbsp; &nbsp; &nbsp; &nbsp;// (seconds) how quickly our laggy estimations decay</font></div><div><font size="1"   >OPTION(mon_osd_laggy_weight, OPT_DOUBLE, .3) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// weight for new 'samples's in laggy estimations</font></div><div><font size="1"   >OPTION(mon_osd_adjust_heartbeat_grace, OPT_BOOL, true) &nbsp; &nbsp;// true if we should scale based on laggy estimations</font></div><div><font size="1"   >OPTION(mon_osd_adjust_down_out_interval, OPT_BOOL, true) &nbsp;// true if we should scale based on laggy estimations</font></div><div><font size="1"   >OPTION(mon_osd_auto_mark_in, OPT_BOOL, false) &nbsp; &nbsp; &nbsp; &nbsp; // mark any booting osds 'in'</font></div><div><font size="1"   >OPTION(mon_osd_auto_mark_auto_out_in, OPT_BOOL, true) // mark booting auto-marked-out osds 'in'</font></div><div><font size="1"   >OPTION(mon_osd_auto_mark_new_in, OPT_BOOL, true) &nbsp; &nbsp; &nbsp;// mark booting new osds 'in'</font></div><div><font size="1"   >OPTION(mon_osd_down_out_interval, OPT_INT, 300) // seconds</font></div><div><font size="1"   >OPTION(mon_osd_down_out_subtree_limit, OPT_STR, "rack") &nbsp; // smallest crush unit/type that we will not automatically mark out</font></div><div><font size="1"   >OPTION(mon_osd_min_up_ratio, OPT_DOUBLE, .3) &nbsp; &nbsp;// min osds required to be up to mark things down</font></div><div><font size="1"   >OPTION(mon_osd_min_in_ratio, OPT_DOUBLE, .3) &nbsp; // min osds required to be in to mark things out</font></div><div><font size="1"   >OPTION(mon_osd_max_op_age, OPT_DOUBLE, 32) &nbsp; &nbsp; // max op age before we get concerned (make it a power of 2)</font></div><div><font size="1"   >OPTION(mon_osd_max_split_count, OPT_INT, 32) // largest number of PGs per "involved" OSD to let split create</font></div><div><font size="1"   >OPTION(mon_osd_allow_primary_temp, OPT_BOOL, false) &nbsp;// allow primary_temp to be set in the osdmap</font></div><div><font size="1"   >OPTION(mon_osd_allow_primary_affinity, OPT_BOOL, false) &nbsp;// allow primary_affinity to be set in the osdmap</font></div><div><font size="1"   >OPTION(mon_stat_smooth_intervals, OPT_INT, 2) &nbsp;// smooth stats over last N PGMap maps</font></div><div><font size="1"   >OPTION(mon_lease, OPT_FLOAT, 5) &nbsp; &nbsp; &nbsp; // lease interval</font></div><div><font size="1"   >OPTION(mon_lease_renew_interval, OPT_FLOAT, 3) // on leader, to renew the lease</font></div><div><font size="1"   >OPTION(mon_lease_ack_timeout, OPT_FLOAT, 10.0) // on leader, if lease isn't acked by all peons</font></div><div><font size="1"   >OPTION(mon_clock_drift_allowed, OPT_FLOAT, .050) // allowed clock drift between monitors</font></div><div><font size="1"   >OPTION(mon_clock_drift_warn_backoff, OPT_FLOAT, 5) // exponential backoff for clock drift warnings</font></div><div><font size="1"   >OPTION(mon_timecheck_interval, OPT_FLOAT, 300.0) // on leader, timecheck (clock drift check) interval (seconds)</font></div><div><font size="1"   >OPTION(mon_accept_timeout, OPT_FLOAT, 10.0) &nbsp; &nbsp;// on leader, if paxos update isn't accepted</font></div><div><font size="1"   >OPTION(mon_pg_create_interval, OPT_FLOAT, 30.0) // no more than every 30s</font></div><div><font size="1"   >OPTION(mon_pg_stuck_threshold, OPT_INT, 300) // number of seconds after which pgs can be considered inactive, unclean, or stale (see doc/control.rst under dump_stuck for more info)</font></div><div><font size="1"   >OPTION(mon_pg_warn_min_per_osd, OPT_INT, 20) &nbsp;// min # pgs per (in) osd before we warn the admin</font></div><div><font size="1"   >OPTION(mon_pg_warn_max_object_skew, OPT_FLOAT, 10.0) // max skew few average in objects per pg</font></div><div><font size="1"   >OPTION(mon_pg_warn_min_objects, OPT_INT, 10000) &nbsp;// do not warn below this object #</font></div><div><font size="1"   >OPTION(mon_pg_warn_min_pool_objects, OPT_INT, 1000) &nbsp;// do not warn on pools below this object #</font></div><div><font size="1"   >OPTION(mon_cache_target_full_warn_ratio, OPT_FLOAT, .66) // position between pool cache_target_full and max where we start warning</font></div><div><font size="1"   >OPTION(mon_osd_full_ratio, OPT_FLOAT, .95) // what % full makes an OSD "full"</font></div><div><font size="1"   >OPTION(mon_osd_nearfull_ratio, OPT_FLOAT, .85) // what % full makes an OSD near full</font></div><div><font size="1"   >OPTION(mon_globalid_prealloc, OPT_INT, 100) &nbsp; // how many globalids to prealloc</font></div><div><font size="1"   >OPTION(mon_osd_report_timeout, OPT_INT, 900) &nbsp; &nbsp;// grace period before declaring unresponsive OSDs dead</font></div><div><font size="1"   >OPTION(mon_force_standby_active, OPT_BOOL, true) // should mons force standby-replay mds to be active</font></div><div><font size="1"   >OPTION(mon_warn_on_old_mons, OPT_BOOL, true) // should mons set health to WARN if part of quorum is old?</font></div><div><font size="1"   >OPTION(mon_warn_on_legacy_crush_tunables, OPT_BOOL, true) // warn if crush tunables are not optimal</font></div><div><font size="1"   >OPTION(mon_warn_on_osd_down_out_interval_zero, OPT_BOOL, true) // warn if 'mon_osd_down_out_interval == 0'</font></div><div><font size="1"   >OPTION(mon_warn_on_cache_pools_without_hit_sets, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(mon_min_osdmap_epochs, OPT_INT, 500)</font></div><div><font size="1"   >OPTION(mon_max_pgmap_epochs, OPT_INT, 500)</font></div><div><font size="1"   >OPTION(mon_max_log_epochs, OPT_INT, 500)</font></div><div><font size="1"   >OPTION(mon_max_mdsmap_epochs, OPT_INT, 500)</font></div><div><font size="1"   >OPTION(mon_max_osd, OPT_INT, 10000)</font></div><div><font size="1"   >OPTION(mon_probe_timeout, OPT_DOUBLE, 2.0)</font></div><div><font size="1"   >OPTION(mon_slurp_timeout, OPT_DOUBLE, 10.0)</font></div><div><font size="1"   >OPTION(mon_slurp_bytes, OPT_INT, 256*1024) &nbsp; &nbsp;// limit size of slurp messages</font></div><div><font size="1"   >OPTION(mon_client_bytes, OPT_U64, 100ul &lt;&lt; 20) &nbsp;// client msg data allowed in memory (in bytes)</font></div><div><font size="1"   >OPTION(mon_daemon_bytes, OPT_U64, 400ul &lt;&lt; 20) &nbsp;// mds, osd message memory cap (in bytes)</font></div><div><font size="1"   >OPTION(mon_max_log_entries_per_event, OPT_INT, 4096)</font></div><div><font size="1"   >OPTION(mon_reweight_min_pgs_per_osd, OPT_U64, 10) &nbsp; // min pgs per osd for reweight-by-pg command</font></div><div><font size="1"   >OPTION(mon_reweight_min_bytes_per_osd, OPT_U64, 100*1024*1024) &nbsp; // min bytes per osd for reweight-by-utilization command</font></div><div><font size="1"   >OPTION(mon_health_data_update_interval, OPT_FLOAT, 60.0)</font></div><div><font size="1"   >OPTION(mon_data_avail_crit, OPT_INT, 5)</font></div><div><font size="1"   >OPTION(mon_data_avail_warn, OPT_INT, 30)</font></div><div><font size="1"   >OPTION(mon_data_size_warn, OPT_U64, 15*1024*1024*1024) // issue a warning when the monitor's data store goes over 15GB (in bytes)</font></div><div><font size="1"   >OPTION(mon_config_key_max_entry_size, OPT_INT, 4096) // max num bytes per config-key entry</font></div><div><font size="1"   >OPTION(mon_sync_timeout, OPT_DOUBLE, 60.0)</font></div><div><font size="1"   >OPTION(mon_sync_max_payload_size, OPT_U32, 1048576) // max size for a sync chunk payload (say, 1MB)</font></div><div><font size="1"   >OPTION(mon_sync_debug, OPT_BOOL, false) // enable sync-specific debug</font></div><div><font size="1"   >OPTION(mon_sync_debug_leader, OPT_INT, -1) // monitor to be used as the sync leader</font></div><div><font size="1"   >OPTION(mon_sync_debug_provider, OPT_INT, -1) // monitor to be used as the sync provider</font></div><div><font size="1"   >OPTION(mon_sync_debug_provider_fallback, OPT_INT, -1) // monitor to be used as fallback if sync provider fails</font></div><div><font size="1"   >OPTION(mon_inject_sync_get_chunk_delay, OPT_DOUBLE, 0) &nbsp;// inject N second delay on each get_chunk request</font></div><div><font size="1"   >OPTION(mon_osd_min_down_reporters, OPT_INT, 1) &nbsp; // number of OSDs who need to report a down OSD for it to count</font></div><div><font size="1"   >OPTION(mon_osd_min_down_reports, OPT_INT, 3) &nbsp; &nbsp; // number of times a down OSD must be reported for it to count</font></div><div><font size="1"   >OPTION(mon_osd_force_trim_to, OPT_INT, 0) &nbsp; // force mon to trim maps to this point, regardless of min_last_epoch_clean (dangerous, use with care)</font></div><div><font size="1"   >OPTION(mon_mds_force_trim_to, OPT_INT, 0) &nbsp; // force mon to trim mdsmaps to this point (dangerous, use with care)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// dump transactions</font></div><div><font size="1"   >OPTION(mon_debug_dump_transactions, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(mon_debug_dump_location, OPT_STR, "/var/log/ceph/$cluster-$name.tdump")</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(mon_sync_provider_kill_at, OPT_INT, 0) &nbsp;// kill the sync provider at a specific point in the work flow</font></div><div><font size="1"   >OPTION(mon_sync_requester_kill_at, OPT_INT, 0) // kill the sync requester at a specific point in the work flow</font></div><div><font size="1"   >OPTION(mon_force_quorum_join, OPT_BOOL, false) // force monitor to join quorum even if it has been previously removed from the map</font></div><div><font size="1"   >OPTION(mon_keyvaluedb, OPT_STR, "leveldb") &nbsp; // type of keyvaluedb backend</font></div><div><font size="1"   >OPTION(paxos_stash_full_interval, OPT_INT, 25) &nbsp; // how often (in commits) to stash a full copy of the PaxosService state</font></div><div><font size="1"   >OPTION(paxos_max_join_drift, OPT_INT, 10) // max paxos iterations before we must first sync the monitor stores</font></div><div><font size="1"   >OPTION(paxos_propose_interval, OPT_DOUBLE, 1.0) &nbsp;// gather updates for this long before proposing a map update</font></div><div><font size="1"   >OPTION(paxos_min_wait, OPT_DOUBLE, 0.05) &nbsp;// min time to gather updates for after period of inactivity</font></div><div><font size="1"   >OPTION(paxos_min, OPT_INT, 500) &nbsp; &nbsp; &nbsp; // minimum number of paxos states to keep around</font></div><div><font size="1"   >OPTION(paxos_trim_min, OPT_INT, 250) &nbsp;// number of extra proposals tolerated before trimming</font></div><div><font size="1"   >OPTION(paxos_trim_max, OPT_INT, 500) // max number of extra proposals to trim at a time</font></div><div><font size="1"   >OPTION(paxos_service_trim_min, OPT_INT, 250) // minimum amount of versions to trigger a trim (0 disables it)</font></div><div><font size="1"   >OPTION(paxos_service_trim_max, OPT_INT, 500) // maximum amount of versions to trim during a single proposal (0 disables it)</font></div><div><font size="1"   >OPTION(paxos_kill_at, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(clock_offset, OPT_DOUBLE, 0) // how much to offset the system clock in Clock.cc</font></div><div><font size="1"   >OPTION(auth_cluster_required, OPT_STR, "cephx") &nbsp; // required of mon, mds, osd daemons</font></div><div><font size="1"   >OPTION(auth_service_required, OPT_STR, "cephx") &nbsp; // required by daemons of clients</font></div><div><font size="1"   >OPTION(auth_client_required, OPT_STR, "cephx, none") &nbsp; &nbsp; // what clients require of daemons</font></div><div><font size="1"   >OPTION(auth_supported, OPT_STR, "") &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // deprecated; default value for above if they are not defined.</font></div><div><font size="1"   >OPTION(cephx_require_signatures, OPT_BOOL, false) // &nbsp;If true, don't talk to Cephx partners if they don't support message signing; off by default</font></div><div><font size="1"   >OPTION(cephx_cluster_require_signatures, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(cephx_service_require_signatures, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(cephx_sign_messages, OPT_BOOL, true) &nbsp;// Default to signing session messages if supported</font></div><div><font size="1"   >OPTION(auth_mon_ticket_ttl, OPT_DOUBLE, 60*60*12)</font></div><div><font size="1"   >OPTION(auth_service_ticket_ttl, OPT_DOUBLE, 60*60)</font></div><div><font size="1"   >OPTION(auth_debug, OPT_BOOL, false) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// if true, assert when weird things happen</font></div><div><font size="1"   >OPTION(mon_client_hunt_interval, OPT_DOUBLE, 3.0) &nbsp; // try new mon every N seconds until we connect</font></div><div><font size="1"   >OPTION(mon_client_ping_interval, OPT_DOUBLE, 10.0) &nbsp;// ping every N seconds</font></div><div><font size="1"   >OPTION(mon_client_ping_timeout, OPT_DOUBLE, 30.0) &nbsp; // fail if we don't hear back</font></div><div><font size="1"   >OPTION(mon_client_hunt_interval_backoff, OPT_DOUBLE, 2.0) // each time we reconnect to a monitor, double our timeout</font></div><div><font size="1"   >OPTION(mon_client_hunt_interval_max_multiple, OPT_DOUBLE, 10.0) // up to a max of 10*default (30 seconds)</font></div><div><font size="1"   >OPTION(mon_client_max_log_entries_per_message, OPT_INT, 1000)</font></div><div><font size="1"   >OPTION(mon_max_pool_pg_num, OPT_INT, 65536)</font></div><div><font size="1"   >OPTION(mon_pool_quota_warn_threshold, OPT_INT, 0) // percent of quota at which to issue warnings</font></div><div><font size="1"   >OPTION(mon_pool_quota_crit_threshold, OPT_INT, 0) // percent of quota at which to issue errors</font></div><div><font size="1"   >OPTION(client_cache_size, OPT_INT, 16384)</font></div><div><font size="1"   >OPTION(client_cache_mid, OPT_FLOAT, .75)</font></div><div><font size="1"   >OPTION(client_use_random_mds, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(client_mount_timeout, OPT_DOUBLE, 300.0)</font></div><div><font size="1"   >OPTION(client_tick_interval, OPT_DOUBLE, 1.0)</font></div><div><font size="1"   >OPTION(client_trace, OPT_STR, "")</font></div><div><font size="1"   >OPTION(client_readahead_min, OPT_LONGLONG, 128*1024) &nbsp;// readahead at _least_ this much.</font></div><div><font size="1"   >OPTION(client_readahead_max_bytes, OPT_LONGLONG, 0) &nbsp;//8 * 1024*1024</font></div><div><font size="1"   >OPTION(client_readahead_max_periods, OPT_LONGLONG, 4) &nbsp;// as multiple of file layout period (object size * num stripes)</font></div><div><font size="1"   >OPTION(client_snapdir, OPT_STR, ".snap")</font></div><div><font size="1"   >OPTION(client_mountpoint, OPT_STR, "/")</font></div><div><font size="1"   >OPTION(client_notify_timeout, OPT_INT, 10) // in seconds</font></div><div><font size="1"   >OPTION(osd_client_watch_timeout, OPT_INT, 30) // in seconds</font></div><div><font size="1"   >OPTION(client_caps_release_delay, OPT_INT, 5) // in seconds</font></div><div><font size="1"   >OPTION(client_oc, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(client_oc_size, OPT_INT, 1024*1024* 200) &nbsp; &nbsp;// MB * n</font></div><div><font size="1"   >OPTION(client_oc_max_dirty, OPT_INT, 1024*1024* 100) &nbsp; &nbsp;// MB * n &nbsp;(dirty OR tx.. bigish)</font></div><div><font size="1"   >OPTION(client_oc_target_dirty, OPT_INT, 1024*1024* 8) // target dirty (keep this smallish)</font></div><div><font size="1"   >OPTION(client_oc_max_dirty_age, OPT_DOUBLE, 5.0) &nbsp; &nbsp; &nbsp;// max age in cache before writeback</font></div><div><font size="1"   >OPTION(client_oc_max_objects, OPT_INT, 1000) &nbsp; &nbsp; &nbsp;// max objects in cache</font></div><div><font size="1"   >OPTION(client_debug_force_sync_read, OPT_BOOL, false) &nbsp; &nbsp; // always read synchronously (go to osds)</font></div><div><font size="1"   >OPTION(client_debug_inject_tick_delay, OPT_INT, 0) // delay the client tick for a number of seconds</font></div><div><font size="1"   >OPTION(client_max_inline_size, OPT_U64, 4096)</font></div><div><font size="1"   >OPTION(client_inject_release_failure, OPT_BOOL, false) &nbsp;// synthetic client bug for testing</font></div><div><font size="1"   >// note: the max amount of "in flight" dirty data is roughly (max - target)</font></div><div><font size="1"   >OPTION(fuse_use_invalidate_cb, OPT_BOOL, false) // use fuse 2.8+ invalidate callback to keep page cache consistent</font></div><div><font size="1"   >OPTION(fuse_allow_other, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(fuse_default_permissions, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(fuse_big_writes, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(fuse_atomic_o_trunc, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(fuse_debug, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(fuse_multithreaded, OPT_BOOL, false)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(crush_location, OPT_STR, "") &nbsp; &nbsp; &nbsp; // whitespace-separated list of key=value pairs describing crush location</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(objecter_tick_interval, OPT_DOUBLE, 5.0)</font></div><div><font size="1"   >OPTION(objecter_timeout, OPT_DOUBLE, 10.0) &nbsp; &nbsp;// before we ask for a map</font></div><div><font size="1"   >OPTION(objecter_inflight_op_bytes, OPT_U64, 1024*1024*100) // max in-flight data (both directions)</font></div><div><font size="1"   >OPTION(objecter_inflight_ops, OPT_U64, 1024) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // max in-flight ios</font></div><div><font size="1"   >OPTION(objecter_completion_locks_per_session, OPT_U64, 32) // num of completion locks per each session, for serializing same object responses</font></div><div><font size="1"   >OPTION(journaler_allow_split_entries, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(journaler_write_head_interval, OPT_INT, 15)</font></div><div><font size="1"   >OPTION(journaler_prefetch_periods, OPT_INT, 10) &nbsp; // * journal object size</font></div><div><font size="1"   >OPTION(journaler_prezero_periods, OPT_INT, 5) &nbsp; &nbsp; // * journal object size</font></div><div><font size="1"   >OPTION(journaler_batch_interval, OPT_DOUBLE, .001) &nbsp; // seconds.. max add'l latency we artificially incur</font></div><div><font size="1"   >OPTION(journaler_batch_max, OPT_U64, 0) &nbsp;// max bytes we'll delay flushing; disable, for now....</font></div><div><font size="1"   >OPTION(mds_data, OPT_STR, "/var/lib/ceph/mds/$cluster-$id")</font></div><div><font size="1"   >OPTION(mds_max_file_size, OPT_U64, 1ULL &lt;&lt; 40)</font></div><div><font size="1"   >OPTION(mds_cache_size, OPT_INT, 100000)</font></div><div><font size="1"   >OPTION(mds_cache_mid, OPT_FLOAT, .7)</font></div><div><font size="1"   >OPTION(mds_max_file_recover, OPT_U32, 32)</font></div><div><font size="1"   >OPTION(mds_mem_max, OPT_INT, 1048576) &nbsp; &nbsp; &nbsp; &nbsp;// KB</font></div><div><font size="1"   >OPTION(mds_dir_max_commit_size, OPT_INT, 10) // MB</font></div><div><font size="1"   >OPTION(mds_decay_halflife, OPT_FLOAT, 5)</font></div><div><font size="1"   >OPTION(mds_beacon_interval, OPT_FLOAT, 4)</font></div><div><font size="1"   >OPTION(mds_beacon_grace, OPT_FLOAT, 15)</font></div><div><font size="1"   >OPTION(mds_enforce_unique_name, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(mds_blacklist_interval, OPT_FLOAT, 24.0*60.0) &nbsp;// how long to blacklist failed nodes</font></div><div><font size="1"   >OPTION(mds_session_timeout, OPT_FLOAT, 60) &nbsp; &nbsp;// cap bits and leases time out if client idle</font></div><div><font size="1"   >OPTION(mds_revoke_cap_timeout, OPT_FLOAT, 60) &nbsp; &nbsp;// detect clients which aren't revoking caps</font></div><div><font size="1"   >OPTION(mds_recall_state_timeout, OPT_FLOAT, 60) &nbsp; &nbsp;// detect clients which aren't trimming caps</font></div><div><font size="1"   >OPTION(mds_freeze_tree_timeout, OPT_FLOAT, 30) &nbsp; &nbsp;// detecting freeze tree deadlock</font></div><div><font size="1"   >OPTION(mds_session_autoclose, OPT_FLOAT, 300) // autoclose idle session</font></div><div><font size="1"   >OPTION(mds_health_summarize_threshold, OPT_INT, 10) // collapse N-client health metrics to a single 'many'</font></div><div><font size="1"   >OPTION(mds_reconnect_timeout, OPT_FLOAT, 45) &nbsp;// seconds to wait for clients during mds restart</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;make it (mds_session_timeout - mds_beacon_grace)</font></div><div><font size="1"   >OPTION(mds_tick_interval, OPT_FLOAT, 5)</font></div><div><font size="1"   >OPTION(mds_dirstat_min_interval, OPT_FLOAT, 1) &nbsp; &nbsp;// try to avoid propagating more often than this</font></div><div><font size="1"   >OPTION(mds_scatter_nudge_interval, OPT_FLOAT, 5) &nbsp;// how quickly dirstat changes propagate up the hierarchy</font></div><div><font size="1"   >OPTION(mds_client_prealloc_inos, OPT_INT, 1000)</font></div><div><font size="1"   >OPTION(mds_early_reply, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(mds_default_dir_hash, OPT_INT, CEPH_STR_HASH_RJENKINS)</font></div><div><font size="1"   >OPTION(mds_log, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(mds_log_skip_corrupt_events, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(mds_log_max_events, OPT_INT, -1)</font></div><div><font size="1"   >OPTION(mds_log_events_per_segment, OPT_INT, 1024)</font></div><div><font size="1"   >OPTION(mds_log_segment_size, OPT_INT, 0) &nbsp;// segment size for mds log,</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // defaults to g_default_file_layout.fl_object_size (4MB)</font></div><div><font size="1"   >OPTION(mds_log_max_segments, OPT_INT, 30)</font></div><div><font size="1"   >OPTION(mds_log_max_expiring, OPT_INT, 20)</font></div><div><font size="1"   >OPTION(mds_bal_sample_interval, OPT_FLOAT, 3.0) &nbsp;// every 5 seconds</font></div><div><font size="1"   >OPTION(mds_bal_replicate_threshold, OPT_FLOAT, 8000)</font></div><div><font size="1"   >OPTION(mds_bal_unreplicate_threshold, OPT_FLOAT, 0)</font></div><div><font size="1"   >OPTION(mds_bal_frag, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(mds_bal_split_size, OPT_INT, 10000)</font></div><div><font size="1"   >OPTION(mds_bal_split_rd, OPT_FLOAT, 25000)</font></div><div><font size="1"   >OPTION(mds_bal_split_wr, OPT_FLOAT, 10000)</font></div><div><font size="1"   >OPTION(mds_bal_split_bits, OPT_INT, 3)</font></div><div><font size="1"   >OPTION(mds_bal_merge_size, OPT_INT, 50)</font></div><div><font size="1"   >OPTION(mds_bal_merge_rd, OPT_FLOAT, 1000)</font></div><div><font size="1"   >OPTION(mds_bal_merge_wr, OPT_FLOAT, 1000)</font></div><div><font size="1"   >OPTION(mds_bal_interval, OPT_INT, 10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // seconds</font></div><div><font size="1"   >OPTION(mds_bal_fragment_interval, OPT_INT, 5) &nbsp; &nbsp; &nbsp;// seconds</font></div><div><font size="1"   >OPTION(mds_bal_idle_threshold, OPT_FLOAT, 0)</font></div><div><font size="1"   >OPTION(mds_bal_max, OPT_INT, -1)</font></div><div><font size="1"   >OPTION(mds_bal_max_until, OPT_INT, -1)</font></div><div><font size="1"   >OPTION(mds_bal_mode, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_bal_min_rebalance, OPT_FLOAT, .1) &nbsp;// must be this much above average before we export anything</font></div><div><font size="1"   >OPTION(mds_bal_min_start, OPT_FLOAT, .2) &nbsp; &nbsp; &nbsp;// if we need less than this, we don't do anything</font></div><div><font size="1"   >OPTION(mds_bal_need_min, OPT_FLOAT, .8) &nbsp; &nbsp; &nbsp; // take within this range of what we need</font></div><div><font size="1"   >OPTION(mds_bal_need_max, OPT_FLOAT, 1.2)</font></div><div><font size="1"   >OPTION(mds_bal_midchunk, OPT_FLOAT, .3) &nbsp; &nbsp; &nbsp; // any sub bigger than this taken in full</font></div><div><font size="1"   >OPTION(mds_bal_minchunk, OPT_FLOAT, .001) &nbsp; &nbsp; // never take anything smaller than this</font></div><div><font size="1"   >OPTION(mds_bal_target_removal_min, OPT_INT, 5) // min balance iterations before old target is removed</font></div><div><font size="1"   >OPTION(mds_bal_target_removal_max, OPT_INT, 10) // max balance iterations before old target is removed</font></div><div><font size="1"   >OPTION(mds_replay_interval, OPT_FLOAT, 1.0) // time to wait before starting replay again</font></div><div><font size="1"   >OPTION(mds_shutdown_check, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_thrash_exports, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_thrash_fragments, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_dump_cache_on_map, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(mds_dump_cache_after_rejoin, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(mds_verify_scatter, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(mds_debug_scatterstat, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(mds_debug_frag, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(mds_debug_auth_pins, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(mds_debug_subtrees, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(mds_kill_mdstable_at, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_kill_export_at, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_kill_import_at, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_kill_link_at, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_kill_rename_at, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_kill_openc_at, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_kill_journal_at, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_kill_journal_expire_at, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_kill_journal_replay_at, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_journal_format, OPT_U32, 1) &nbsp;// Default to most recent JOURNAL_FORMAT_*</font></div><div><font size="1"   >OPTION(mds_kill_create_at, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(mds_inject_traceless_reply_probability, OPT_DOUBLE, 0) /* percentage</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of MDS modify replies to skip sending the</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; client a trace on [0-1]*/</font></div><div><font size="1"   >OPTION(mds_wipe_sessions, OPT_BOOL, 0)</font></div><div><font size="1"   >OPTION(mds_wipe_ino_prealloc, OPT_BOOL, 0)</font></div><div><font size="1"   >OPTION(mds_skip_ino, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(max_mds, OPT_INT, 1)</font></div><div><font size="1"   >OPTION(mds_standby_for_name, OPT_STR, "")</font></div><div><font size="1"   >OPTION(mds_standby_for_rank, OPT_INT, -1)</font></div><div><font size="1"   >OPTION(mds_standby_replay, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(mds_enable_op_tracker, OPT_BOOL, true) // enable/disable MDS op tracking</font></div><div><font size="1"   >OPTION(mds_op_history_size, OPT_U32, 20) &nbsp; &nbsp;// Max number of completed ops to track</font></div><div><font size="1"   >OPTION(mds_op_history_duration, OPT_U32, 600) // Oldest completed op to track</font></div><div><font size="1"   >OPTION(mds_op_complaint_time, OPT_FLOAT, 30) // how many seconds old makes an op complaint-worthy</font></div><div><font size="1"   >OPTION(mds_op_log_threshold, OPT_INT, 5) // how many op log messages to show in one go</font></div><div><font size="1"   >OPTION(mds_snap_min_uid, OPT_U32, 0) // The minimum UID required to create a snapshot</font></div><div><font size="1"   >OPTION(mds_snap_max_uid, OPT_U32, 65536) // The maximum UID allowed to create a snapshot</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// If true, compact leveldb store on mount</font></div><div><font size="1"   >OPTION(osd_compact_leveldb_on_mount, OPT_BOOL, false)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// Maximum number of backfills to or from a single osd</font></div><div><font size="1"   >OPTION(osd_max_backfills, OPT_U64, 10)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// Minimum recovery priority (255 = max, smaller = lower)</font></div><div><font size="1"   >OPTION(osd_min_recovery_priority, OPT_INT, 0)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// Refuse backfills when OSD full ratio is above this value</font></div><div><font size="1"   >OPTION(osd_backfill_full_ratio, OPT_FLOAT, 0.85)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// Seconds to wait before retrying refused backfills</font></div><div><font size="1"   >OPTION(osd_backfill_retry_interval, OPT_DOUBLE, 10.0)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// max agent flush ops</font></div><div><font size="1"   >OPTION(osd_agent_max_ops, OPT_INT, 4)</font></div><div><font size="1"   >OPTION(osd_agent_min_evict_effort, OPT_FLOAT, .1)</font></div><div><font size="1"   >OPTION(osd_agent_quantize_effort, OPT_FLOAT, .1)</font></div><div><font size="1"   >OPTION(osd_agent_delay_time, OPT_FLOAT, 5.0)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// decay atime and hist histograms after how many objects go by</font></div><div><font size="1"   >OPTION(osd_agent_hist_halflife, OPT_INT, 1000)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// must be this amount over the threshold to enable,</font></div><div><font size="1"   >// this amount below the threshold to disable.</font></div><div><font size="1"   >OPTION(osd_agent_slop, OPT_FLOAT, .02)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(osd_uuid, OPT_UUID, uuid_d())</font></div><div><font size="1"   >OPTION(osd_data, OPT_STR, "/var/lib/ceph/osd/$cluster-$id")</font></div><div><font size="1"   >OPTION(osd_journal, OPT_STR, "/var/lib/ceph/osd/$cluster-$id/journal")</font></div><div><font size="1"   >OPTION(osd_journal_size, OPT_INT, 5120) &nbsp; &nbsp; &nbsp; &nbsp; // in mb</font></div><div><font size="1"   >OPTION(osd_max_write_size, OPT_INT, 90)</font></div><div><font size="1"   >OPTION(osd_max_pgls, OPT_U64, 1024) // max number of pgls entries to return</font></div><div><font size="1"   >OPTION(osd_client_message_size_cap, OPT_U64, 500*1024L*1024L) // client data allowed in-memory (in bytes)</font></div><div><font size="1"   >OPTION(osd_client_message_cap, OPT_U64, 100) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// num client messages allowed in-memory</font></div><div><font size="1"   >OPTION(osd_pg_bits, OPT_INT, 6) &nbsp;// bits per osd</font></div><div><font size="1"   >OPTION(osd_pgp_bits, OPT_INT, 6) &nbsp;// bits per osd</font></div><div><font size="1"   >OPTION(osd_crush_chooseleaf_type, OPT_INT, 1) // 1 = host</font></div><div><font size="1"   >OPTION(osd_pool_default_crush_rule, OPT_INT, -1) // deprecated for osd_pool_default_crush_replicated_ruleset</font></div><div><font size="1"   >OPTION(osd_pool_default_crush_replicated_ruleset, OPT_INT, CEPH_DEFAULT_CRUSH_REPLICATED_RULESET)</font></div><div><font size="1"   >OPTION(osd_pool_erasure_code_stripe_width, OPT_U32, OSD_POOL_ERASURE_CODE_STRIPE_WIDTH) // in bytes</font></div><div><font size="1"   >OPTION(osd_pool_default_size, OPT_INT, 3)</font></div><div><font size="1"   >OPTION(osd_pool_default_min_size, OPT_INT, 0) &nbsp;// 0 means no specific default; ceph will use size-size/2</font></div><div><font size="1"   >OPTION(osd_pool_default_pg_num, OPT_INT, 8) // number of PGs for new pools. Configure in global or mon section of ceph.conf</font></div><div><font size="1"   >OPTION(osd_pool_default_pgp_num, OPT_INT, 8) // number of PGs for placement purposes. Should be equal to pg_num</font></div><div><font size="1"   >OPTION(osd_pool_default_erasure_code_directory, OPT_STR, CEPH_PKGLIBDIR"/erasure-code") // default for the erasure-code-directory=XXX property of osd pool create</font></div><div><font size="1"   >OPTION(osd_pool_default_erasure_code_profile,</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp;OPT_STR,</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp;"plugin=jerasure "</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp;"technique=reed_sol_van "</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp;"k=2 "</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp;"m=1 "</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp;) // default properties of osd pool create</font></div><div><font size="1"   >OPTION(osd_erasure_code_plugins, OPT_STR,</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp;"jerasure"</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp;" lrc"</font></div><div><font size="1"   >#ifdef HAVE_BETTER_YASM_ELF64</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp;" isa"</font></div><div><font size="1"   >#endif</font></div><div><font size="1"   >&nbsp; &nbsp; &nbsp; &nbsp;) // list of erasure code plugins</font></div><div><font size="1"   >OPTION(osd_pool_default_flags, OPT_INT, 0) &nbsp; // default flags for new pools</font></div><div><font size="1"   >OPTION(osd_pool_default_flag_hashpspool, OPT_BOOL, true) &nbsp; // use new pg hashing to prevent pool/pg overlap</font></div><div><font size="1"   >OPTION(osd_pool_default_hit_set_bloom_fpp, OPT_FLOAT, .05)</font></div><div><font size="1"   >OPTION(osd_pool_default_cache_target_dirty_ratio, OPT_FLOAT, .4)</font></div><div><font size="1"   >OPTION(osd_pool_default_cache_target_full_ratio, OPT_FLOAT, .8)</font></div><div><font size="1"   >OPTION(osd_pool_default_cache_min_flush_age, OPT_INT, 0) &nbsp;// seconds</font></div><div><font size="1"   >OPTION(osd_pool_default_cache_min_evict_age, OPT_INT, 0) &nbsp;// seconds</font></div><div><font size="1"   >OPTION(osd_hit_set_min_size, OPT_INT, 1000) &nbsp;// min target size for a HitSet</font></div><div><font size="1"   >OPTION(osd_hit_set_max_size, OPT_INT, 100000) &nbsp;// max target size for a HitSet</font></div><div><font size="1"   >OPTION(osd_hit_set_namespace, OPT_STR, ".ceph-internal") // rados namespace for hit_set tracking</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(osd_tier_default_cache_mode, OPT_STR, "writeback")</font></div><div><font size="1"   >OPTION(osd_tier_default_cache_hit_set_count, OPT_INT, 4)</font></div><div><font size="1"   >OPTION(osd_tier_default_cache_hit_set_period, OPT_INT, 1200)</font></div><div><font size="1"   >OPTION(osd_tier_default_cache_hit_set_type, OPT_STR, "bloom")</font></div><div><font size="1"   >OPTION(osd_tier_default_cache_min_read_recency_for_promote, OPT_INT, 1) // number of recent HitSets the object must appear in to be promoted (on read)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(osd_map_dedup, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(osd_map_max_advance, OPT_INT, 200) // make this &lt; cache_size!</font></div><div><font size="1"   >OPTION(osd_map_cache_size, OPT_INT, 500)</font></div><div><font size="1"   >OPTION(osd_map_message_max, OPT_INT, 100) &nbsp;// max maps per MOSDMap message</font></div><div><font size="1"   >OPTION(osd_map_share_max_epochs, OPT_INT, 100) &nbsp;// cap on # of inc maps we send to peers, clients</font></div><div><font size="1"   >OPTION(osd_op_threads, OPT_INT, 2) &nbsp; &nbsp;// 0 == no threading</font></div><div><font size="1"   >OPTION(osd_peering_wq_batch_size, OPT_U64, 20)</font></div><div><font size="1"   >OPTION(osd_op_pq_max_tokens_per_priority, OPT_U64, 4194304)</font></div><div><font size="1"   >OPTION(osd_op_pq_min_cost, OPT_U64, 65536)</font></div><div><font size="1"   >OPTION(osd_disk_threads, OPT_INT, 1)</font></div><div><font size="1"   >OPTION(osd_disk_thread_ioprio_class, OPT_STR, "") // rt realtime be besteffort best effort idle</font></div><div><font size="1"   >OPTION(osd_disk_thread_ioprio_priority, OPT_INT, -1) // 0-7</font></div><div><font size="1"   >OPTION(osd_recovery_threads, OPT_INT, 1)</font></div><div><font size="1"   >OPTION(osd_recover_clone_overlap, OPT_BOOL, true) &nbsp; // preserve clone_overlap during recovery/migration</font></div><div><font size="1"   >OPTION(osd_op_num_threads_per_shard, OPT_INT, 2)</font></div><div><font size="1"   >OPTION(osd_op_num_shards, OPT_INT, 5)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// Only use clone_overlap for recovery if there are fewer than</font></div><div><font size="1"   >// osd_recover_clone_overlap_limit entries in the overlap set</font></div><div><font size="1"   >OPTION(osd_recover_clone_overlap_limit, OPT_INT, 10)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(osd_backfill_scan_min, OPT_INT, 64)</font></div><div><font size="1"   >OPTION(osd_backfill_scan_max, OPT_INT, 512)</font></div><div><font size="1"   >OPTION(osd_op_thread_timeout, OPT_INT, 15)</font></div><div><font size="1"   >OPTION(osd_recovery_thread_timeout, OPT_INT, 30)</font></div><div><font size="1"   >OPTION(osd_snap_trim_thread_timeout, OPT_INT, 60*60*1)</font></div><div><font size="1"   >OPTION(osd_snap_trim_sleep, OPT_FLOAT, 0)</font></div><div><font size="1"   >OPTION(osd_scrub_thread_timeout, OPT_INT, 60)</font></div><div><font size="1"   >OPTION(osd_scrub_finalize_thread_timeout, OPT_INT, 60*10)</font></div><div><font size="1"   >OPTION(osd_scrub_invalid_stats, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(osd_remove_thread_timeout, OPT_INT, 60*60)</font></div><div><font size="1"   >OPTION(osd_command_thread_timeout, OPT_INT, 10*60)</font></div><div><font size="1"   >OPTION(osd_age, OPT_FLOAT, .8)</font></div><div><font size="1"   >OPTION(osd_age_time, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(osd_heartbeat_addr, OPT_ADDR, entity_addr_t())</font></div><div><font size="1"   >OPTION(osd_heartbeat_interval, OPT_INT, 6) &nbsp; &nbsp; &nbsp; // (seconds) how often we ping peers</font></div><div><font size="1"   >OPTION(osd_heartbeat_grace, OPT_INT, 20) &nbsp; &nbsp; &nbsp; &nbsp; // (seconds) how long before we decide a peer has failed</font></div><div><font size="1"   >OPTION(osd_heartbeat_min_peers, OPT_INT, 10) &nbsp; &nbsp; // minimum number of peers</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// max number of parallel snap trims/pg</font></div><div><font size="1"   >OPTION(osd_pg_max_concurrent_snap_trims, OPT_U64, 2)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// minimum number of peers tha tmust be reachable to mark ourselves</font></div><div><font size="1"   >// back up after being wrongly marked down.</font></div><div><font size="1"   >OPTION(osd_heartbeat_min_healthy_ratio, OPT_FLOAT, .33)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(osd_mon_heartbeat_interval, OPT_INT, 30) &nbsp;// (seconds) how often to ping monitor if no peers</font></div><div><font size="1"   >OPTION(osd_mon_report_interval_max, OPT_INT, 120)</font></div><div><font size="1"   >OPTION(osd_mon_report_interval_min, OPT_INT, 5) &nbsp;// pg stats, failures, up_thru, boot.</font></div><div><font size="1"   >OPTION(osd_pg_stat_report_interval_max, OPT_INT, 500) &nbsp;// report pg stats for any given pg at least this often</font></div><div><font size="1"   >OPTION(osd_mon_ack_timeout, OPT_INT, 30) // time out a mon if it doesn't ack stats</font></div><div><font size="1"   >OPTION(osd_default_data_pool_replay_window, OPT_INT, 45)</font></div><div><font size="1"   >OPTION(osd_preserve_trimmed_log, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(osd_auto_mark_unfound_lost, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(osd_recovery_delay_start, OPT_FLOAT, 0)</font></div><div><font size="1"   >OPTION(osd_recovery_max_active, OPT_INT, 15)</font></div><div><font size="1"   >OPTION(osd_recovery_max_single_start, OPT_INT, 5)</font></div><div><font size="1"   >OPTION(osd_recovery_max_chunk, OPT_U64, 8&lt;&lt;20) &nbsp;// max size of push chunk</font></div><div><font size="1"   >OPTION(osd_copyfrom_max_chunk, OPT_U64, 8&lt;&lt;20) &nbsp; // max size of a COPYFROM chunk</font></div><div><font size="1"   >OPTION(osd_push_per_object_cost, OPT_U64, 1000) &nbsp;// push cost per object</font></div><div><font size="1"   >OPTION(osd_max_push_cost, OPT_U64, 8&lt;&lt;20) &nbsp;// max size of push message</font></div><div><font size="1"   >OPTION(osd_max_push_objects, OPT_U64, 10) &nbsp;// max objects in single push op</font></div><div><font size="1"   >OPTION(osd_recovery_forget_lost_objects, OPT_BOOL, false) &nbsp; // off for now</font></div><div><font size="1"   >OPTION(osd_max_scrubs, OPT_INT, 1)</font></div><div><font size="1"   >OPTION(osd_scrub_load_threshold, OPT_FLOAT, 0.5)</font></div><div><font size="1"   >OPTION(osd_scrub_min_interval, OPT_FLOAT, 60*60*24) &nbsp; &nbsp;// if load is low</font></div><div><font size="1"   >OPTION(osd_scrub_max_interval, OPT_FLOAT, 7*60*60*24) &nbsp;// regardless of load</font></div><div><font size="1"   >OPTION(osd_scrub_chunk_min, OPT_INT, 5)</font></div><div><font size="1"   >OPTION(osd_scrub_chunk_max, OPT_INT, 25)</font></div><div><font size="1"   >OPTION(osd_scrub_sleep, OPT_FLOAT, 0) &nbsp; // sleep between [deep]scrub ops</font></div><div><font size="1"   >OPTION(osd_deep_scrub_interval, OPT_FLOAT, 60*60*24*7) // once a week</font></div><div><font size="1"   >OPTION(osd_deep_scrub_stride, OPT_INT, 524288)</font></div><div><font size="1"   >OPTION(osd_scan_list_ping_tp_interval, OPT_U64, 100)</font></div><div><font size="1"   >OPTION(osd_auto_weight, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(osd_class_dir, OPT_STR, CEPH_LIBDIR "/rados-classes") // where rados plugins are stored</font></div><div><font size="1"   >OPTION(osd_open_classes_on_start, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(osd_check_for_log_corruption, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(osd_use_stale_snap, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(osd_rollback_to_cluster_snap, OPT_STR, "")</font></div><div><font size="1"   >OPTION(osd_default_notify_timeout, OPT_U32, 30) // default notify timeout in seconds</font></div><div><font size="1"   >OPTION(osd_kill_backfill_at, OPT_INT, 0)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// Bounds how infrequently a new map epoch will be persisted for a pg</font></div><div><font size="1"   >OPTION(osd_pg_epoch_persisted_max_stale, OPT_U32, 200)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(osd_min_pg_log_entries, OPT_U32, 3000) &nbsp;// number of entries to keep in the pg log when trimming it</font></div><div><font size="1"   >OPTION(osd_max_pg_log_entries, OPT_U32, 10000) // max entries, say when degraded, before we trim</font></div><div><font size="1"   >OPTION(osd_op_complaint_time, OPT_FLOAT, 30) // how many seconds old makes an op complaint-worthy</font></div><div><font size="1"   >OPTION(osd_command_max_records, OPT_INT, 256)</font></div><div><font size="1"   >OPTION(osd_max_pg_blocked_by, OPT_U32, 16) &nbsp; &nbsp;// max peer osds to report that are blocking our progress</font></div><div><font size="1"   >OPTION(osd_op_log_threshold, OPT_INT, 5) // how many op log messages to show in one go</font></div><div><font size="1"   >OPTION(osd_verify_sparse_read_holes, OPT_BOOL, false) &nbsp;// read fiemap-reported holes and verify they are zeros</font></div><div><font size="1"   >OPTION(osd_debug_drop_ping_probability, OPT_DOUBLE, 0)</font></div><div><font size="1"   >OPTION(osd_debug_drop_ping_duration, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(osd_debug_drop_pg_create_probability, OPT_DOUBLE, 0)</font></div><div><font size="1"   >OPTION(osd_debug_drop_pg_create_duration, OPT_INT, 1)</font></div><div><font size="1"   >OPTION(osd_debug_drop_op_probability, OPT_DOUBLE, 0) &nbsp; // probability of stalling/dropping a client op</font></div><div><font size="1"   >OPTION(osd_debug_op_order, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(osd_debug_verify_snaps_on_info, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(osd_debug_verify_stray_on_activate, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(osd_debug_skip_full_check_in_backfill_reservation, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(osd_debug_reject_backfill_probability, OPT_DOUBLE, 0)</font></div><div><font size="1"   >OPTION(osd_enable_op_tracker, OPT_BOOL, true) // enable/disable OSD op tracking</font></div><div><font size="1"   >OPTION(osd_num_op_tracker_shard, OPT_U32, 32) // The number of shards for holding the ops&nbsp;</font></div><div><font size="1"   >OPTION(osd_op_history_size, OPT_U32, 20) &nbsp; &nbsp;// Max number of completed ops to track</font></div><div><font size="1"   >OPTION(osd_op_history_duration, OPT_U32, 600) // Oldest completed op to track</font></div><div><font size="1"   >OPTION(osd_target_transaction_size, OPT_INT, 30) &nbsp; &nbsp; // to adjust various transactions that batch smaller items</font></div><div><font size="1"   >OPTION(osd_failsafe_full_ratio, OPT_FLOAT, .97) // what % full makes an OSD "full" (failsafe)</font></div><div><font size="1"   >OPTION(osd_failsafe_nearfull_ratio, OPT_FLOAT, .90) // what % full makes an OSD near full (failsafe)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// determines whether PGLog::check() compares written out log to stored log</font></div><div><font size="1"   >OPTION(osd_debug_pg_log_writeout, OPT_BOOL, false)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(leveldb_write_buffer_size, OPT_U64, 8 *1024*1024) // leveldb write buffer size</font></div><div><font size="1"   >OPTION(leveldb_cache_size, OPT_U64, 128 *1024*1024) // leveldb cache size</font></div><div><font size="1"   >OPTION(leveldb_block_size, OPT_U64, 0) // leveldb block size</font></div><div><font size="1"   >OPTION(leveldb_bloom_size, OPT_INT, 0) // leveldb bloom bits per entry</font></div><div><font size="1"   >OPTION(leveldb_max_open_files, OPT_INT, 0) // leveldb max open files</font></div><div><font size="1"   >OPTION(leveldb_compression, OPT_BOOL, true) // leveldb uses compression</font></div><div><font size="1"   >OPTION(leveldb_paranoid, OPT_BOOL, false) // leveldb paranoid flag</font></div><div><font size="1"   >OPTION(leveldb_log, OPT_STR, "/dev/null") &nbsp;// enable leveldb log file</font></div><div><font size="1"   >OPTION(leveldb_compact_on_mount, OPT_BOOL, false)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(kinetic_host, OPT_STR, "") // hostname or ip address of a kinetic drive to use</font></div><div><font size="1"   >OPTION(kinetic_port, OPT_INT, 8123) // port number of the kinetic drive</font></div><div><font size="1"   >OPTION(kinetic_user_id, OPT_INT, 1) // kinetic user to authenticate as</font></div><div><font size="1"   >OPTION(kinetic_hmac_key, OPT_STR, "asdfasdf") // kinetic key to authenticate with</font></div><div><font size="1"   >OPTION(kinetic_use_ssl, OPT_BOOL, false) // whether to secure kinetic traffic with TLS</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(rocksdb_compact_on_mount, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(rocksdb_write_buffer_size, OPT_U64, 0) // rocksdb write buffer size</font></div><div><font size="1"   >OPTION(rocksdb_target_file_size_base, OPT_U64, 0) // target file size for compaction</font></div><div><font size="1"   >OPTION(rocksdb_cache_size, OPT_U64, 0) // rocksdb cache size</font></div><div><font size="1"   >OPTION(rocksdb_block_size, OPT_U64, 0) // rocksdb block size</font></div><div><font size="1"   >OPTION(rocksdb_bloom_size, OPT_INT, 0) // rocksdb bloom bits per entry</font></div><div><font size="1"   >OPTION(rocksdb_write_buffer_num, OPT_INT, 0) // rocksdb bloom bits per entry</font></div><div><font size="1"   >OPTION(rocksdb_background_compactions, OPT_INT, 0) // number for background compaction jobs</font></div><div><font size="1"   >OPTION(rocksdb_background_flushes, OPT_INT, 0) // number for background flush jobs</font></div><div><font size="1"   >OPTION(rocksdb_max_open_files, OPT_INT, 0) // rocksdb max open files</font></div><div><font size="1"   >OPTION(rocksdb_compression, OPT_STR, "") // rocksdb uses compression : none, snappy, zlib, bzip2</font></div><div><font size="1"   >OPTION(rocksdb_paranoid, OPT_BOOL, false) // rocksdb paranoid flag</font></div><div><font size="1"   >OPTION(rocksdb_log, OPT_STR, "/dev/null") &nbsp;// enable rocksdb log file</font></div><div><font size="1"   >OPTION(rocksdb_level0_file_num_compaction_trigger, OPT_U64, 0) // Number of files to trigger level-0 compaction</font></div><div><font size="1"   >OPTION(rocksdb_level0_slowdown_writes_trigger, OPT_U64, 0) &nbsp;// number of level-0 files at which we start slowing down write.</font></div><div><font size="1"   >OPTION(rocksdb_level0_stop_writes_trigger, OPT_U64, 0) &nbsp;// number of level-0 files at which we stop writes</font></div><div><font size="1"   >OPTION(rocksdb_disableDataSync, OPT_BOOL, true) // if true, data files are not synced to stable storage</font></div><div><font size="1"   >OPTION(rocksdb_disableWAL, OPT_BOOL, false) &nbsp;// diable write ahead log</font></div><div><font size="1"   >OPTION(rocksdb_num_levels, OPT_INT, 0) // number of levels for this database</font></div><div><font size="1"   >OPTION(rocksdb_wal_dir, OPT_STR, "") &nbsp;// &nbsp;rocksdb write ahead log file</font></div><div><font size="1"   >OPTION(rocksdb_info_log_level, OPT_STR, "info") &nbsp;// info log level : debug , info , warn, error, fatal</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >/**</font></div><div><font size="1"   >&nbsp;* osd_client_op_priority and osd_recovery_op_priority adjust the relative</font></div><div><font size="1"   >&nbsp;* priority of client io vs recovery io.</font></div><div><font size="1"   >&nbsp;*</font></div><div><font size="1"   >&nbsp;* osd_client_op_priority/osd_recovery_op_priority determines the ratio of</font></div><div><font size="1"   >&nbsp;* available io between client and recovery. &nbsp;Each option may be set between</font></div><div><font size="1"   >&nbsp;* 1..63.</font></div><div><font size="1"   >&nbsp;*</font></div><div><font size="1"   >&nbsp;* osd_recovery_op_warn_multiple scales the normal warning threshhold,</font></div><div><font size="1"   >&nbsp;* osd_op_complaint_time, so that slow recovery ops won't cause noise</font></div><div><font size="1"   >&nbsp;*/</font></div><div><font size="1"   >OPTION(osd_client_op_priority, OPT_U32, 63)</font></div><div><font size="1"   >OPTION(osd_recovery_op_priority, OPT_U32, 10)</font></div><div><font size="1"   >OPTION(osd_recovery_op_warn_multiple, OPT_U32, 16)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// Max time to wait between notifying mon of shutdown and shutting down</font></div><div><font size="1"   >OPTION(osd_mon_shutdown_timeout, OPT_DOUBLE, 5)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(osd_max_object_size, OPT_U64, 100*1024L*1024L*1024L) // OSD's maximum object size</font></div><div><font size="1"   >OPTION(osd_max_object_name_len, OPT_U32, 2048) // max rados object name len</font></div><div><font size="1"   >OPTION(osd_max_attr_name_len, OPT_U32, 100) &nbsp; &nbsp;// max rados attr name len; cannot go higher than 100 chars for file system backends</font></div><div><font size="1"   >OPTION(osd_max_attr_size, OPT_U64, 0)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(osd_objectstore, OPT_STR, "filestore") &nbsp;// ObjectStore backend type</font></div><div><font size="1"   >// Override maintaining compatibility with older OSDs</font></div><div><font size="1"   >// Set to true for testing. &nbsp;Users should NOT set this.</font></div><div><font size="1"   >OPTION(osd_debug_override_acting_compat, OPT_BOOL, false)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(osd_bench_small_size_max_iops, OPT_U32, 100) // 100 IOPS</font></div><div><font size="1"   >OPTION(osd_bench_large_size_max_throughput, OPT_U64, 100 &lt;&lt; 20) // 100 MB/s</font></div><div><font size="1"   >OPTION(osd_bench_max_block_size, OPT_U64, 64 &lt;&lt; 20) // cap the block size at 64MB</font></div><div><font size="1"   >OPTION(osd_bench_duration, OPT_U32, 30) // duration of 'osd bench', capped at 30s to avoid triggering timeouts</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(filestore_omap_backend, OPT_STR, "leveldb")</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(filestore_debug_disable_sharded_check, OPT_BOOL, false)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >/// filestore wb throttle limits</font></div><div><font size="1"   >OPTION(filestore_wbthrottle_enable, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(filestore_wbthrottle_btrfs_bytes_start_flusher, OPT_U64, 41943040)</font></div><div><font size="1"   >OPTION(filestore_wbthrottle_btrfs_bytes_hard_limit, OPT_U64, 419430400)</font></div><div><font size="1"   >OPTION(filestore_wbthrottle_btrfs_ios_start_flusher, OPT_U64, 500)</font></div><div><font size="1"   >OPTION(filestore_wbthrottle_btrfs_ios_hard_limit, OPT_U64, 5000)</font></div><div><font size="1"   >OPTION(filestore_wbthrottle_btrfs_inodes_start_flusher, OPT_U64, 500)</font></div><div><font size="1"   >OPTION(filestore_wbthrottle_xfs_bytes_start_flusher, OPT_U64, 41943040)</font></div><div><font size="1"   >OPTION(filestore_wbthrottle_xfs_bytes_hard_limit, OPT_U64, 419430400)</font></div><div><font size="1"   >OPTION(filestore_wbthrottle_xfs_ios_start_flusher, OPT_U64, 500)</font></div><div><font size="1"   >OPTION(filestore_wbthrottle_xfs_ios_hard_limit, OPT_U64, 5000)</font></div><div><font size="1"   >OPTION(filestore_wbthrottle_xfs_inodes_start_flusher, OPT_U64, 500)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >/// These must be less than the fd limit</font></div><div><font size="1"   >OPTION(filestore_wbthrottle_btrfs_inodes_hard_limit, OPT_U64, 5000)</font></div><div><font size="1"   >OPTION(filestore_wbthrottle_xfs_inodes_hard_limit, OPT_U64, 5000)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// Tests index failure paths</font></div><div><font size="1"   >OPTION(filestore_index_retry_probability, OPT_DOUBLE, 0)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// Allow object read error injection</font></div><div><font size="1"   >OPTION(filestore_debug_inject_read_err, OPT_BOOL, false)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(filestore_debug_omap_check, OPT_BOOL, 0) // Expensive debugging check on sync</font></div><div><font size="1"   >OPTION(filestore_omap_header_cache_size, OPT_INT, 1024)&nbsp;</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// Use omap for xattrs for attrs over</font></div><div><font size="1"   >// filestore_max_inline_xattr_size or</font></div><div><font size="1"   >OPTION(filestore_max_inline_xattr_size, OPT_U32, 0) &nbsp; &nbsp; //Override</font></div><div><font size="1"   >OPTION(filestore_max_inline_xattr_size_xfs, OPT_U32, 65536)</font></div><div><font size="1"   >OPTION(filestore_max_inline_xattr_size_btrfs, OPT_U32, 2048)</font></div><div><font size="1"   >OPTION(filestore_max_inline_xattr_size_other, OPT_U32, 512)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// for more than filestore_max_inline_xattrs attrs</font></div><div><font size="1"   >OPTION(filestore_max_inline_xattrs, OPT_U32, 0) //Override</font></div><div><font size="1"   >OPTION(filestore_max_inline_xattrs_xfs, OPT_U32, 10)</font></div><div><font size="1"   >OPTION(filestore_max_inline_xattrs_btrfs, OPT_U32, 10)</font></div><div><font size="1"   >OPTION(filestore_max_inline_xattrs_other, OPT_U32, 2)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(filestore_sloppy_crc, OPT_BOOL, false) &nbsp; &nbsp; &nbsp; &nbsp; // track sloppy crcs</font></div><div><font size="1"   >OPTION(filestore_sloppy_crc_block_size, OPT_INT, 65536)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(filestore_max_alloc_hint_size, OPT_U64, 1ULL &lt;&lt; 20) // bytes</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(filestore_max_sync_interval, OPT_DOUBLE, 5) &nbsp; &nbsp;// seconds</font></div><div><font size="1"   >OPTION(filestore_min_sync_interval, OPT_DOUBLE, .01) &nbsp;// seconds</font></div><div><font size="1"   >OPTION(filestore_btrfs_snap, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(filestore_btrfs_clone_range, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(filestore_zfs_snap, OPT_BOOL, false) // zfsonlinux is still unstable</font></div><div><font size="1"   >OPTION(filestore_fsync_flushes_journal_data, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(filestore_fiemap, OPT_BOOL, false) &nbsp; &nbsp; // (try to) use fiemap</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// (try to) use extsize for alloc hint</font></div><div><font size="1"   >// WARNING: extsize seems to trigger data corruption in xfs -- that is why it is</font></div><div><font size="1"   >// off by default, see bug #8830</font></div><div><font size="1"   >OPTION(filestore_xfs_extsize, OPT_BOOL, false)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(filestore_journal_parallel, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(filestore_journal_writeahead, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(filestore_journal_trailing, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(filestore_queue_max_ops, OPT_INT, 50)</font></div><div><font size="1"   >OPTION(filestore_queue_max_bytes, OPT_INT, 100 &lt;&lt; 20)</font></div><div><font size="1"   >OPTION(filestore_queue_committing_max_ops, OPT_INT, 500) &nbsp; &nbsp; &nbsp; &nbsp;// this is ON TOP of filestore_queue_max_*</font></div><div><font size="1"   >OPTION(filestore_queue_committing_max_bytes, OPT_INT, 100 &lt;&lt; 20) // &nbsp;"</font></div><div><font size="1"   >OPTION(filestore_op_threads, OPT_INT, 2)</font></div><div><font size="1"   >OPTION(filestore_op_thread_timeout, OPT_INT, 60)</font></div><div><font size="1"   >OPTION(filestore_op_thread_suicide_timeout, OPT_INT, 180)</font></div><div><font size="1"   >OPTION(filestore_commit_timeout, OPT_FLOAT, 600)</font></div><div><font size="1"   >OPTION(filestore_fiemap_threshold, OPT_INT, 4096)</font></div><div><font size="1"   >OPTION(filestore_merge_threshold, OPT_INT, 10)</font></div><div><font size="1"   >OPTION(filestore_split_multiple, OPT_INT, 2)</font></div><div><font size="1"   >OPTION(filestore_update_to, OPT_INT, 1000)</font></div><div><font size="1"   >OPTION(filestore_blackhole, OPT_BOOL, false) &nbsp; &nbsp; // drop any new transactions on the floor</font></div><div><font size="1"   >OPTION(filestore_fd_cache_size, OPT_INT, 128) &nbsp; &nbsp;// FD lru size</font></div><div><font size="1"   >OPTION(filestore_fd_cache_shards, OPT_INT, 16) &nbsp; // FD number of shards</font></div><div><font size="1"   >OPTION(filestore_dump_file, OPT_STR, "") &nbsp; &nbsp; &nbsp; &nbsp; // file onto which store transaction dumps</font></div><div><font size="1"   >OPTION(filestore_kill_at, OPT_INT, 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// inject a failure at the n'th opportunity</font></div><div><font size="1"   >OPTION(filestore_inject_stall, OPT_INT, 0) &nbsp; &nbsp; &nbsp; // artificially stall for N seconds in op queue thread</font></div><div><font size="1"   >OPTION(filestore_fail_eio, OPT_BOOL, true) &nbsp; &nbsp; &nbsp; // fail/crash on EIO</font></div><div><font size="1"   >OPTION(filestore_replica_fadvise, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(filestore_debug_verify_split, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(journal_dio, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(journal_aio, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(journal_force_aio, OPT_BOOL, false)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(keyvaluestore_queue_max_ops, OPT_INT, 50)</font></div><div><font size="1"   >OPTION(keyvaluestore_queue_max_bytes, OPT_INT, 100 &lt;&lt; 20)</font></div><div><font size="1"   >OPTION(keyvaluestore_debug_check_backend, OPT_BOOL, 0) // Expensive debugging check on sync</font></div><div><font size="1"   >OPTION(keyvaluestore_op_threads, OPT_INT, 2)</font></div><div><font size="1"   >OPTION(keyvaluestore_op_thread_timeout, OPT_INT, 60)</font></div><div><font size="1"   >OPTION(keyvaluestore_op_thread_suicide_timeout, OPT_INT, 180)</font></div><div><font size="1"   >OPTION(keyvaluestore_default_strip_size, OPT_INT, 4096) // Only affect new object</font></div><div><font size="1"   >OPTION(keyvaluestore_max_expected_write_size, OPT_U64, 1ULL &lt;&lt; 24) // bytes</font></div><div><font size="1"   >OPTION(keyvaluestore_header_cache_size, OPT_INT, 4096) &nbsp; &nbsp;// Header cache size</font></div><div><font size="1"   >OPTION(keyvaluestore_backend, OPT_STR, "leveldb")</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// max bytes to search ahead in journal searching for corruption</font></div><div><font size="1"   >OPTION(journal_max_corrupt_search, OPT_U64, 10&lt;&lt;20)</font></div><div><font size="1"   >OPTION(journal_block_align, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(journal_write_header_frequency, OPT_U64, 0)</font></div><div><font size="1"   >OPTION(journal_max_write_bytes, OPT_INT, 10 &lt;&lt; 20)</font></div><div><font size="1"   >OPTION(journal_max_write_entries, OPT_INT, 100)</font></div><div><font size="1"   >OPTION(journal_queue_max_ops, OPT_INT, 300)</font></div><div><font size="1"   >OPTION(journal_queue_max_bytes, OPT_INT, 32 &lt;&lt; 20)</font></div><div><font size="1"   >OPTION(journal_align_min_size, OPT_INT, 64 &lt;&lt; 10) &nbsp;// align data payloads &gt;= this.</font></div><div><font size="1"   >OPTION(journal_replay_from, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(journal_zero_on_create, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(journal_ignore_corruption, OPT_BOOL, false) // assume journal is not corrupt</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(rados_mon_op_timeout, OPT_DOUBLE, 0) // how many seconds to wait for a response from the monitor before returning an error from a rados operation. 0 means on limit.</font></div><div><font size="1"   >OPTION(rados_osd_op_timeout, OPT_DOUBLE, 0) // how many seconds to wait for a response from osds before returning an error from a rados operation. 0 means no limit.</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(rbd_cache, OPT_BOOL, true) // whether to enable caching (writeback unless rbd_cache_max_dirty is 0)</font></div><div><font size="1"   >OPTION(rbd_cache_writethrough_until_flush, OPT_BOOL, true) // whether to make writeback caching writethrough until flush is called, to be sure the user of librbd will send flushs so that writeback is safe</font></div><div><font size="1"   >OPTION(rbd_cache_size, OPT_LONGLONG, 32&lt;&lt;20) &nbsp; &nbsp; &nbsp; &nbsp; // cache size in bytes</font></div><div><font size="1"   >OPTION(rbd_cache_max_dirty, OPT_LONGLONG, 24&lt;&lt;20) &nbsp; &nbsp;// dirty limit in bytes - set to 0 for write-through caching</font></div><div><font size="1"   >OPTION(rbd_cache_target_dirty, OPT_LONGLONG, 16&lt;&lt;20) // target dirty limit in bytes</font></div><div><font size="1"   >OPTION(rbd_cache_max_dirty_age, OPT_FLOAT, 1.0) &nbsp; &nbsp; &nbsp;// seconds in cache before writeback starts</font></div><div><font size="1"   >OPTION(rbd_cache_max_dirty_object, OPT_INT, 0) &nbsp; &nbsp; &nbsp; // dirty limit for objects - set to 0 for auto calculate from rbd_cache_size</font></div><div><font size="1"   >OPTION(rbd_cache_block_writes_upfront, OPT_BOOL, false) // whether to block writes to the cache before the aio_write call completes (true), or block before the aio completion is called (false)</font></div><div><font size="1"   >OPTION(rbd_concurrent_management_ops, OPT_INT, 10) // how many operations can be in flight for a management operation like deleting or resizing an image</font></div><div><font size="1"   >OPTION(rbd_balance_snap_reads, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(rbd_localize_snap_reads, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(rbd_balance_parent_reads, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(rbd_localize_parent_reads, OPT_BOOL, true)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >/*</font></div><div><font size="1"   >&nbsp;* The following options change the behavior for librbd's image creation methods that</font></div><div><font size="1"   >&nbsp;* don't require all of the parameters. These are provided so that older programs</font></div><div><font size="1"   >&nbsp;* can take advantage of newer features without being rewritten to use new versions</font></div><div><font size="1"   >&nbsp;* of the image creation functions.</font></div><div><font size="1"   >&nbsp;*</font></div><div><font size="1"   >&nbsp;* rbd_create()/RBD::create() are affected by all of these options.</font></div><div><font size="1"   >&nbsp;*</font></div><div><font size="1"   >&nbsp;* rbd_create2()/RBD::create2() and rbd_clone()/RBD::clone() are affected by:</font></div><div><font size="1"   >&nbsp;* - rbd_default_order</font></div><div><font size="1"   >&nbsp;* - rbd_default_stripe_count</font></div><div><font size="1"   >&nbsp;* - rbd_default_stripe_size</font></div><div><font size="1"   >&nbsp;*</font></div><div><font size="1"   >&nbsp;* rbd_create3()/RBD::create3() and rbd_clone2/RBD::clone2() are only</font></div><div><font size="1"   >&nbsp;* affected by rbd_default_order.</font></div><div><font size="1"   >&nbsp;*/</font></div><div><font size="1"   >OPTION(rbd_default_format, OPT_INT, 1)</font></div><div><font size="1"   >OPTION(rbd_default_order, OPT_INT, 22)</font></div><div><font size="1"   >OPTION(rbd_default_stripe_count, OPT_U64, 0) // changing requires stripingv2 feature</font></div><div><font size="1"   >OPTION(rbd_default_stripe_unit, OPT_U64, 0) // changing to non-object size requires stripingv2 feature</font></div><div><font size="1"   >OPTION(rbd_default_features, OPT_INT, 3) // 1 for layering, 3 for layering+stripingv2. only applies to format 2 images</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(nss_db_path, OPT_STR, "") // path to nss db</font></div><div><font size="1"   ><br></font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(rgw_max_chunk_size, OPT_INT, 512 * 1024)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(rgw_data, OPT_STR, "/var/lib/ceph/radosgw/$cluster-$id")</font></div><div><font size="1"   >OPTION(rgw_enable_apis, OPT_STR, "s3, swift, swift_auth, admin")</font></div><div><font size="1"   >OPTION(rgw_cache_enabled, OPT_BOOL, true) &nbsp; // rgw cache enabled</font></div><div><font size="1"   >OPTION(rgw_cache_lru_size, OPT_INT, 10000) &nbsp; // num of entries in rgw cache</font></div><div><font size="1"   >OPTION(rgw_socket_path, OPT_STR, "") &nbsp; // path to unix domain socket, if not specified, rgw will not run as external fcgi</font></div><div><font size="1"   >OPTION(rgw_host, OPT_STR, "") &nbsp;// host for radosgw, can be an IP, default is 0.0.0.0</font></div><div><font size="1"   >OPTION(rgw_port, OPT_STR, "") &nbsp;// port to listen, format as "8080" "5000", if not specified, rgw will not run external fcgi</font></div><div><font size="1"   >OPTION(rgw_dns_name, OPT_STR, "")</font></div><div><font size="1"   >OPTION(rgw_script_uri, OPT_STR, "") // alternative value for SCRIPT_URI if not set in request</font></div><div><font size="1"   >OPTION(rgw_request_uri, OPT_STR, &nbsp;"") // alternative value for REQUEST_URI if not set in request</font></div><div><font size="1"   >OPTION(rgw_swift_url, OPT_STR, "") &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // the swift url, being published by the internal swift auth</font></div><div><font size="1"   >OPTION(rgw_swift_url_prefix, OPT_STR, "swift") // entry point for which a url is considered a swift url</font></div><div><font size="1"   >OPTION(rgw_swift_auth_url, OPT_STR, "") &nbsp; &nbsp; &nbsp; &nbsp;// default URL to go and verify tokens for v1 auth (if not using internal swift auth)</font></div><div><font size="1"   >OPTION(rgw_swift_auth_entry, OPT_STR, "auth") &nbsp;// entry point for which a url is considered a swift auth url</font></div><div><font size="1"   >OPTION(rgw_swift_tenant_name, OPT_STR, "") &nbsp;// tenant name to use for swift access</font></div><div><font size="1"   >OPTION(rgw_keystone_url, OPT_STR, "") &nbsp;// url for keystone server</font></div><div><font size="1"   >OPTION(rgw_keystone_admin_token, OPT_STR, "") &nbsp;// keystone admin token (shared secret)</font></div><div><font size="1"   >OPTION(rgw_keystone_admin_user, OPT_STR, "") &nbsp;// keystone admin user name</font></div><div><font size="1"   >OPTION(rgw_keystone_admin_password, OPT_STR, "") &nbsp;// keystone admin user password</font></div><div><font size="1"   >OPTION(rgw_keystone_admin_tenant, OPT_STR, "") &nbsp;// keystone admin user tenant</font></div><div><font size="1"   >OPTION(rgw_keystone_accepted_roles, OPT_STR, "Member, admin") &nbsp;// roles required to serve requests</font></div><div><font size="1"   >OPTION(rgw_keystone_token_cache_size, OPT_INT, 10000) &nbsp;// max number of entries in keystone token cache</font></div><div><font size="1"   >OPTION(rgw_keystone_revocation_interval, OPT_INT, 15 * 60) &nbsp;// seconds between tokens revocation check</font></div><div><font size="1"   >OPTION(rgw_s3_auth_use_rados, OPT_BOOL, true) &nbsp;// should we try to use the internal credentials for s3?</font></div><div><font size="1"   >OPTION(rgw_s3_auth_use_keystone, OPT_BOOL, false) &nbsp;// should we try to use keystone for s3?</font></div><div><font size="1"   >OPTION(rgw_admin_entry, OPT_STR, "admin") &nbsp;// entry point for which a url is considered an admin request</font></div><div><font size="1"   >OPTION(rgw_enforce_swift_acls, OPT_BOOL, true)</font></div><div><font size="1"   >OPTION(rgw_swift_token_expiration, OPT_INT, 24 * 3600) // time in seconds for swift token expiration</font></div><div><font size="1"   >OPTION(rgw_print_continue, OPT_BOOL, true) &nbsp;// enable if 100-Continue works</font></div><div><font size="1"   >OPTION(rgw_remote_addr_param, OPT_STR, "REMOTE_ADDR") &nbsp;// e.g. X-Forwarded-For, if you have a reverse proxy</font></div><div><font size="1"   >OPTION(rgw_op_thread_timeout, OPT_INT, 10*60)</font></div><div><font size="1"   >OPTION(rgw_op_thread_suicide_timeout, OPT_INT, 0)</font></div><div><font size="1"   >OPTION(rgw_thread_pool_size, OPT_INT, 100)</font></div><div><font size="1"   >OPTION(rgw_num_control_oids, OPT_INT, 8)</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(rgw_zone, OPT_STR, "") // zone name</font></div><div><font size="1"   >OPTION(rgw_zone_root_pool, OPT_STR, ".rgw.root") &nbsp; &nbsp;// pool where zone specific info is stored</font></div><div><font size="1"   >OPTION(rgw_region, OPT_STR, "") // region name</font></div><div><font size="1"   >OPTION(rgw_region_root_pool, OPT_STR, ".rgw.root") &nbsp;// pool where all region info is stored</font></div><div><font size="1"   >OPTION(rgw_default_region_info_oid, OPT_STR, "default.region") &nbsp;// oid where default region info is stored</font></div><div><font size="1"   >OPTION(rgw_log_nonexistent_bucket, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(rgw_log_object_name, OPT_STR, "%Y-%m-%d-%H-%i-%n") &nbsp; &nbsp; &nbsp;// man date to see codes (a subset are supported)</font></div><div><font size="1"   >OPTION(rgw_log_object_name_utc, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(rgw_usage_max_shards, OPT_INT, 32)</font></div><div><font size="1"   >OPTION(rgw_usage_max_user_shards, OPT_INT, 1)</font></div><div><font size="1"   >OPTION(rgw_enable_ops_log, OPT_BOOL, false) // enable logging every rgw operation</font></div><div><font size="1"   >OPTION(rgw_enable_usage_log, OPT_BOOL, false) // enable logging bandwidth usage</font></div><div><font size="1"   >OPTION(rgw_ops_log_rados, OPT_BOOL, true) // whether ops log should go to rados</font></div><div><font size="1"   >OPTION(rgw_ops_log_socket_path, OPT_STR, "") // path to unix domain socket where ops log can go</font></div><div><font size="1"   >OPTION(rgw_ops_log_data_backlog, OPT_INT, 5 &lt;&lt; 20) // max data backlog for ops log</font></div><div><font size="1"   >OPTION(rgw_usage_log_flush_threshold, OPT_INT, 1024) // threshold to flush pending log data</font></div><div><font size="1"   >OPTION(rgw_usage_log_tick_interval, OPT_INT, 30) // flush pending log data every X seconds</font></div><div><font size="1"   >OPTION(rgw_intent_log_object_name, OPT_STR, "%Y-%m-%d-%i-%n") &nbsp;// man date to see codes (a subset are supported)</font></div><div><font size="1"   >OPTION(rgw_intent_log_object_name_utc, OPT_BOOL, false)</font></div><div><font size="1"   >OPTION(rgw_init_timeout, OPT_INT, 300) // time in seconds</font></div><div><font size="1"   >OPTION(rgw_mime_types_file, OPT_STR, "/etc/mime.types")</font></div><div><font size="1"   >OPTION(rgw_gc_max_objs, OPT_INT, 32)</font></div><div><font size="1"   >OPTION(rgw_gc_obj_min_wait, OPT_INT, 2 * 3600) &nbsp; &nbsp;// wait time before object may be handled by gc</font></div><div><font size="1"   >OPTION(rgw_gc_processor_max_time, OPT_INT, 3600) &nbsp;// total run time for a single gc processor work</font></div><div><font size="1"   >OPTION(rgw_gc_processor_period, OPT_INT, 3600) &nbsp;// gc processor cycle time</font></div><div><font size="1"   >OPTION(rgw_s3_success_create_obj_status, OPT_INT, 0) // alternative success status response for create-obj (0 - default)</font></div><div><font size="1"   >OPTION(rgw_resolve_cname, OPT_BOOL, false) &nbsp;// should rgw try to resolve hostname as a dns cname record</font></div><div><font size="1"   >OPTION(rgw_obj_stripe_size, OPT_INT, 4 &lt;&lt; 20)</font></div><div><font size="1"   >OPTION(rgw_extended_http_attrs, OPT_STR, "") // list of extended attrs that can be set on objects (beyond the default)</font></div><div><font size="1"   >OPTION(rgw_exit_timeout_secs, OPT_INT, 120) // how many seconds to wait for process to go down before exiting unconditionally</font></div><div><font size="1"   >OPTION(rgw_get_obj_window_size, OPT_INT, 16 &lt;&lt; 20) // window size in bytes for single get obj request</font></div><div><font size="1"   >OPTION(rgw_get_obj_max_req_size, OPT_INT, 4 &lt;&lt; 20) // max length of a single get obj rados op</font></div><div><font size="1"   >OPTION(rgw_relaxed_s3_bucket_names, OPT_BOOL, false) // enable relaxed bucket name rules for US region buckets</font></div><div><font size="1"   >OPTION(rgw_defer_to_bucket_acls, OPT_STR, "") // if the user has bucket perms, use those before key perms (recurse and full_control)</font></div><div><font size="1"   >OPTION(rgw_list_buckets_max_chunk, OPT_INT, 1000) // max buckets to retrieve in a single op when listing user buckets</font></div><div><font size="1"   >OPTION(rgw_md_log_max_shards, OPT_INT, 64) // max shards for metadata log</font></div><div><font size="1"   >OPTION(rgw_num_zone_opstate_shards, OPT_INT, 128) // max shards for keeping inter-region copy progress info</font></div><div><font size="1"   >OPTION(rgw_opstate_ratelimit_sec, OPT_INT, 30) // min time between opstate updates on a single upload (0 for disabling ratelimit)</font></div><div><font size="1"   >OPTION(rgw_curl_wait_timeout_ms, OPT_INT, 1000) // timeout for certain curl calls</font></div><div><font size="1"   >OPTION(rgw_copy_obj_progress, OPT_BOOL, true) // should dump progress during long copy operations?</font></div><div><font size="1"   >OPTION(rgw_copy_obj_progress_every_bytes, OPT_INT, 1024 * 1024) // min bytes between copy progress output</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(rgw_data_log_window, OPT_INT, 30) // data log entries window (in seconds)</font></div><div><font size="1"   >OPTION(rgw_data_log_changes_size, OPT_INT, 1000) // number of in-memory entries to hold for data changes log</font></div><div><font size="1"   >OPTION(rgw_data_log_num_shards, OPT_INT, 128) // number of objects to keep data changes log on</font></div><div><font size="1"   >OPTION(rgw_data_log_obj_prefix, OPT_STR, "data_log") //&nbsp;</font></div><div><font size="1"   >OPTION(rgw_replica_log_obj_prefix, OPT_STR, "replica_log") //&nbsp;</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(rgw_bucket_quota_ttl, OPT_INT, 600) // time for cached bucket stats to be cached within rgw instance</font></div><div><font size="1"   >OPTION(rgw_bucket_quota_soft_threshold, OPT_DOUBLE, 0.95) // threshold from which we don't rely on cached info for quota decisions</font></div><div><font size="1"   >OPTION(rgw_bucket_quota_cache_size, OPT_INT, 10000) // number of entries in bucket quota cache</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(rgw_expose_bucket, OPT_BOOL, false) // Return the bucket name in the 'Bucket' response header</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(rgw_frontends, OPT_STR, "fastcgi, civetweb port=7480") // rgw front ends</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(rgw_user_quota_bucket_sync_interval, OPT_INT, 180) // time period for accumulating modified buckets before syncing stats</font></div><div><font size="1"   >OPTION(rgw_user_quota_sync_interval, OPT_INT, 3600 * 24) // time period for accumulating modified buckets before syncing entire user stats</font></div><div><font size="1"   >OPTION(rgw_user_quota_sync_idle_users, OPT_BOOL, false) // whether stats for idle users be fully synced</font></div><div><font size="1"   >OPTION(rgw_user_quota_sync_wait_time, OPT_INT, 3600 * 24) // min time between two full stats syc for non-idle users</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(rgw_multipart_min_part_size, OPT_INT, 5 * 1024 * 1024) // min size for each part (except for last one) in multipart upload</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >OPTION(mutex_perf_counter, OPT_BOOL, false) // enable/disable mutex perf counter</font></div><div><font size="1"   >OPTION(throttler_perf_counter, OPT_BOOL, true) // enable/disable throttler perf counter</font></div><div><font size="1"   ><br></font></div><div><font size="1"   >// This will be set to true when it is safe to start threads.</font></div><div><font size="1"   >// Once it is true, it will never change.</font></div><div><font size="1"   >OPTION(internal_safe_to_start_threads, OPT_BOOL, false)</font></div></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="ceph default values for mon, osd, radosgw, mds - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>