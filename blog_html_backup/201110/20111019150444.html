<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL inheritance table scans to return meaningfully-sorted results</h2>
	<h5 id="">2011-10-19 15:04:44&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201191922618396/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">PostgreSQL 9.1 对继承表在优化器部分做了小小的改进。当查询父表时，并对输出结果执行了排序，如果子排序字段有索引存在，可以利用这个索引，不需要额外的排序过程。而在9.1以前的版本必须是先MERGE RESULT再进行一次排序。<wbr><div>下面来看两个例子：</div><div>例1 :&nbsp;</div><div>版本 9.0.4</div><div>新建测试表, ID作为主键，隐含索引。</div><div>digoal=&gt; create table test_inherit (id int primary key,info text);</div><div>digoal=&gt; create table test_inherit_1 &nbsp;(id int primary key check (id&gt;=0 and id&lt;100000),info text) inherits (test_inherit);</div><div>digoal=&gt; create table test_inherit_2 &nbsp;(id int primary key check (id&gt;=100000 and id&lt;200000),info text) inherits (test_inherit);</div><div>digoal=&gt; create table test_inherit_3 &nbsp;(id int primary key check (id&gt;=200000 and id&lt;300000),info text) inherits (test_inherit);</div><div>digoal=&gt; create table test_inherit_4 &nbsp;(id int primary key check (id&gt;=300000 and id&lt;400000),info text) inherits (test_inherit);</div><div>digoal=&gt; create table test_inherit_5 &nbsp;(id int primary key check (id&gt;=400000 and id&lt;500000),info text) inherits (test_inherit);</div><div>digoal=&gt; create table test_inherit_6 &nbsp;(id int primary key check (id&gt;=500000 and id&lt;600000),info text) inherits (test_inherit);</div><div><div>往子表插入测试数据</div><div>digoal=&gt; insert into test_inherit_1 select generate_series(0,99999),'digoal';</div><div>INSERT 0 100000</div><div>digoal=&gt; insert into test_inherit_2 select generate_series(100000,199999),'digoal';</div><div>INSERT 0 100000</div><div>digoal=&gt; insert into test_inherit_3 select generate_series(200000,299999),'digoal';</div><div>INSERT 0 100000</div><div>digoal=&gt; insert into test_inherit_4 select generate_series(300000,399999),'digoal';</div><div>INSERT 0 100000</div><div>digoal=&gt; insert into test_inherit_5 select generate_series(400000,499999),'digoal';</div><div>INSERT 0 100000</div><div>digoal=&gt; insert into test_inherit_6 select generate_series(500000,599999),'digoal';</div><div>INSERT 0 100000</div></div><div>跨分区查询，按ID排序。</div><div>执行计划很明了，子表查询完后Append，然后在按ID排序。也就是显示排序，开销Sort &nbsp;(cost=1085.14..1136.14 rows=20401 width=11)</div><div>digoal=&gt; explain select * from test_inherit where id&gt;=90000 and id&lt;110000 order by id limit 10;</div><div><div>&nbsp;Limit &nbsp;(cost=1085.14..1085.16 rows=10 width=11)</div><div>&nbsp; &nbsp;-&gt; &nbsp;Sort &nbsp;(cost=1085.14..1136.14 rows=20401 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Key: digoal.test_inherit.id</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Result &nbsp;(cost=2.31..644.28 rows=20401 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Append &nbsp;(cost=2.31..644.28 rows=20401 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Bitmap Heap Scan on test_inherit &nbsp;(cost=2.31..8.87 rows=6 width=36)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Recheck Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on test_inherit_pkey &nbsp;(cost=0.00..2.31 rows=6 width=0)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using test_inherit_1_pkey on test_inherit_1 test_inherit &nbsp;(cost=0.00..313.28 rows=10051 width=11</div><div>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using test_inherit_2_pkey on test_inherit_2 test_inherit &nbsp;(cost=0.00..322.14 rows=10344 width=11</div><div>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div></div><div><br></div><div>版本 9.1.0</div><div>测试表和测试数据同上，执行的SQL同上。</div><div>执行计划，显然排序走了子表的索引，能看到Merge Append的过程。总体开销成本下降明显。</div><div>digoal=&gt; explain select * from test_inherit where id&gt;=90000 and id&lt;110000 order by id limit 10;</div><div><div>&nbsp;Limit &nbsp;(cost=0.02..0.52 rows=10 width=11)</div><div>&nbsp; &nbsp;-&gt; &nbsp;Result &nbsp;(cost=0.02..1013.12 rows=20374 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Merge Append &nbsp;(cost=0.02..1013.12 rows=20374 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Key: digoal.test_inherit.id</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using test_inherit_pkey on test_inherit &nbsp;(cost=0.00..4.27 rows=1 width=36)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using test_inherit_1_pkey on test_inherit_1 test_inherit &nbsp;(cost=0.00..313.60 rows=10067 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using test_inherit_2_pkey on test_inherit_2 test_inherit &nbsp;(cost=0.00..321.38 rows=10306 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div><br></div></div><div>例2 :&nbsp;</div><div>与例1不同的是，这里的ID字段没有使用CHECK，并且子表有重叠记录，来看看9.1是不是也不需要显示排序。</div><div><div style="line-height: 22px;"  >版本 9.0.4</div><div style="line-height: 22px;"  >新建测试表, ID作为主键，隐含索引。</div><div>digoal=&gt; create table inherit_test ( id int primary key,info text);</div><div>digoal=&gt; create table inherit_test_1 (like inherit_test including all) inherits (inherit_test);</div><div>digoal=&gt; create table inherit_test_2 (like inherit_test including all) inherits (inherit_test);</div><div>digoal=&gt; create table inherit_test_3 (like inherit_test including all) inherits (inherit_test);</div><div>digoal=&gt; create table inherit_test_4 (like inherit_test including all) inherits (inherit_test);</div><div>digoal=&gt; create table inherit_test_5 (like inherit_test including all) inherits (inherit_test);</div><div>digoal=&gt; create table inherit_test_6 (like inherit_test including all) inherits (inherit_test);</div><div>往子表插入测试数据，插入的测试数据两个表可能有重叠部分。</div><div>digoal=&gt; insert into inherit_test_1 select generate_series(0,99999),'digoal';</div><div>digoal=&gt; insert into inherit_test_2 select generate_series(50000,199999),'digoal';</div><div>digoal=&gt; insert into inherit_test_3 select generate_series(150000,299999),'digoal';</div><div>digoal=&gt; insert into inherit_test_4 select generate_series(250000,399999),'digoal';</div><div>digoal=&gt; insert into inherit_test_5 select generate_series(350000,499999),'digoal';</div><div>digoal=&gt; insert into inherit_test_6 select generate_series(450000,599999),'digoal';</div><div>执行计划，显然9.0版本和例1的测试结果相似，都是先返回子表查询结果，然后MERGE，然后显示排序Sort &nbsp;(cost=1623.86..1699.59 rows=30295 width=11)。</div><div>digoal=&gt; explain select * from inherit_test where id&gt;=90000 and id&lt;110000 order by id limit 10;</div><div><div>&nbsp;Limit &nbsp;(cost=1623.86..1623.88 rows=10 width=11)</div><div>&nbsp; &nbsp;-&gt; &nbsp;Sort &nbsp;(cost=1623.86..1699.59 rows=30295 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Key: digoal.inherit_test.id</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Result &nbsp;(cost=2.31..969.19 rows=30295 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Append &nbsp;(cost=2.31..969.19 rows=30295 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Bitmap Heap Scan on inherit_test &nbsp;(cost=2.31..8.87 rows=6 width=36)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Recheck Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Bitmap Index Scan on inherit_test_pkey &nbsp;(cost=0.00..2.31 rows=6 width=0)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using inherit_test_1_pkey on inherit_test_1 inherit_test &nbsp;(cost=0.00..309.96 rows=9935 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using inherit_test_2_pkey on inherit_test_2 inherit_test &nbsp;(cost=0.00..633.26 rows=20350 width=11</div><div>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using inherit_test_3_pkey on inherit_test_3 inherit_test &nbsp;(cost=0.00..4.28 rows=1 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using inherit_test_4_pkey on inherit_test_4 inherit_test &nbsp;(cost=0.00..4.28 rows=1 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using inherit_test_5_pkey on inherit_test_5 inherit_test &nbsp;(cost=0.00..4.28 rows=1 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using inherit_test_6_pkey on inherit_test_6 inherit_test &nbsp;(cost=0.00..4.28 rows=1 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div></div><div style="line-height: 22px;"  >版本 9.1.0</div></div><div style="line-height: 22px;"  ><div style="line-height: 22px;"  >测试表和测试数据同上，执行的SQL同上。</div><div style="line-height: 22px;"  >执行计划，显然排序走了子表的索引，能看到Merge Append的过程。总体开销成本下降明显。</div></div><div>digoal=&gt; explain select * from inherit_test where id&gt;=90000 and id&lt;110000 order by id limit 10;</div><div><div><div>&nbsp;Limit &nbsp;(cost=0.10..3.77 rows=10 width=16)</div><div>&nbsp; &nbsp;-&gt; &nbsp;Result &nbsp;(cost=0.10..4600.72 rows=12513 width=16)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Merge Append &nbsp;(cost=0.10..4600.72 rows=12513 width=16)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Key: digoal.inherit_test.id</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using inherit_test_pkey on inherit_test &nbsp;(cost=0.00..4.27 rows=1 width=36)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using inherit_test_1_pkey on inherit_test_1 inherit_test &nbsp;(cost=0.00..312.60 rows=10017 width=11)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using inherit_test_2_pkey on inherit_test_2 inherit_test &nbsp;(cost=0.00..780.24 rows=499 width=36)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using inherit_test_3_pkey on inherit_test_3 inherit_test &nbsp;(cost=0.00..780.24 rows=499 width=36)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using inherit_test_4_pkey on inherit_test_4 inherit_test &nbsp;(cost=0.00..780.24 rows=499 width=36)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using inherit_test_5_pkey on inherit_test_5 inherit_test &nbsp;(cost=0.00..780.24 rows=499 width=36)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using inherit_test_6_pkey on inherit_test_6 inherit_test &nbsp;(cost=0.00..780.24 rows=499 width=36)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: ((id &gt;= 90000) AND (id &lt; 110000))</div></div></div><div>由于例2中WHERE条件的字段ID子表没有使用CHECK，所以对所有子表进行了遍历。</div><div><br></div><div>9.1 的这个改进在这种场景中使用会带来非常大的性能提升。</div></div>
	</div>
</div>
</body>
</html>