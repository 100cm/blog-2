<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.3 XLOG dump contrib introduce</h2>
	<h5 id="">2013-02-23 13:59:12&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201312311244246/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">PostgreSQL 9.3 添加了 pg_xlogdump 的功能, &nbsp;主要用于解析XLogRecord的信息. 可用于学习了解XLOG.<div>XLogRecord的数据结构如下 :&nbsp;</div><div>src/include/access/xlog.h</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >00021 /*</font></div><div><font size="2"   >00022 &nbsp;* The overall layout of an XLOG record is:</font></div><div><font size="2"   >00023 &nbsp;* &nbsp; &nbsp; &nbsp;Fixed-size header (XLogRecord struct)</font></div><div><font size="2"   >00024 &nbsp;* &nbsp; &nbsp; &nbsp;rmgr-specific data</font></div><div><font size="2"   >00025 &nbsp;* &nbsp; &nbsp; &nbsp;BkpBlock</font></div><div><font size="2"   >00026 &nbsp;* &nbsp; &nbsp; &nbsp;backup block data</font></div><div><font size="2"   >00027 &nbsp;* &nbsp; &nbsp; &nbsp;BkpBlock</font></div><div><font size="2"   >00028 &nbsp;* &nbsp; &nbsp; &nbsp;backup block data</font></div><div><font size="2"   >00029 &nbsp;* &nbsp; &nbsp; &nbsp;...</font></div><div><font size="2"   >00030 &nbsp;*</font></div><div><font size="2"   >00031 &nbsp;* where there can be zero to four backup blocks (as signaled by xl_info flag</font></div><div><font size="2"   >00032 &nbsp;* bits). &nbsp;XLogRecord structs always start on MAXALIGN boundaries in the WAL</font></div><div><font size="2"   >00033 &nbsp;* files, and we round up SizeOfXLogRecord so that the rmgr data is also</font></div><div><font size="2"   >00034 &nbsp;* guaranteed to begin on a MAXALIGN boundary. &nbsp;However, no padding is added</font></div><div><font size="2"   >00035 &nbsp;* to align BkpBlock structs or backup block data.</font></div><div><font size="2"   >00036 &nbsp;*</font></div><div><font size="2"   >00037 &nbsp;* NOTE: xl_len counts only the rmgr data, not the XLogRecord header,</font></div><div><font size="2"   >00038 &nbsp;* and also not any backup blocks. &nbsp;xl_tot_len counts everything. &nbsp;Neither</font></div><div><font size="2"   >00039 &nbsp;* length field is rounded up to an alignment boundary.</font></div><div><font size="2"   >00040 &nbsp;*/</font></div><div><font size="2"   >00041 typedef struct XLogRecord</font></div><div><font size="2"   >00042 {</font></div><div><font size="2"   >00043 &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp;xl_tot_len; &nbsp; &nbsp; /* total len of entire record */</font></div><div><font size="2"   >00044 &nbsp; &nbsp; TransactionId xl_xid; &nbsp; &nbsp; &nbsp; /* xact id */</font></div><div><font size="2"   >00045 &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp;xl_len; &nbsp; &nbsp; &nbsp; &nbsp; /* total len of rmgr data */</font></div><div><font size="2"   >00046 &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; xl_info; &nbsp; &nbsp; &nbsp; &nbsp;/* flag bits, see below */</font></div><div><font size="2"   >00047 &nbsp; &nbsp; RmgrId &nbsp; &nbsp; &nbsp;xl_rmid; &nbsp; &nbsp; &nbsp; &nbsp;/* resource manager for this record */</font></div><div><font size="2"   >00048 &nbsp; &nbsp; /* 2 bytes of padding here, initialize to zero */</font></div><div><font size="2"   >00049 &nbsp; &nbsp; XLogRecPtr &nbsp;xl_prev; &nbsp; &nbsp; &nbsp; &nbsp;/* ptr to previous record in log */</font></div><div><font size="2"   >00050 &nbsp; &nbsp; pg_crc32 &nbsp; &nbsp;xl_crc; &nbsp; &nbsp; &nbsp; &nbsp; /* CRC for this record */</font></div><div><font size="2"   >00051&nbsp;</font></div><div><font size="2"   >00052 &nbsp; &nbsp; /* If MAXALIGN==8, there are 4 wasted bytes here */</font></div><div><font size="2"   >00053&nbsp;</font></div><div><font size="2"   >00054 &nbsp; &nbsp; /* ACTUAL LOG DATA FOLLOWS AT END OF STRUCT */</font></div><div><font size="2"   >00055&nbsp;</font></div><div><font size="2"   >00056 } XLogRecord;</font></div><p></p></pre></div><div><br></div><div>用法 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg_xlogdump decodes and displays PostgreSQL transaction logs for debugging.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Usage:</font></div><div><font size="2"   >&nbsp; pg_xlogdump [OPTION] [STARTSEG [ENDSEG]]&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >General options:</font></div><div><font size="2"   >&nbsp; -V, --version &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;output version information, then exit</font></div><div><font size="2"   >&nbsp; -?, --help &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; show this help, then exit</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Content options:</font></div><div><font size="2"   >&nbsp; -b, --bkp-details &nbsp; &nbsp; &nbsp;output detailed information about backup blocks</font></div><div><font size="2"   >&nbsp; -e, --end=RECPTR &nbsp; &nbsp; &nbsp; stop reading at log position RECPTR</font></div><div><font size="2"   >&nbsp; -n, --limit=N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number of records to display</font></div><div><font size="2"   >&nbsp; -p, --path=PATH &nbsp; &nbsp; &nbsp; &nbsp;directory in which to find log segment files</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(default: ./pg_xlog)</font></div><div><font size="2"   >&nbsp; -r, --rmgr=RMGR &nbsp; &nbsp; &nbsp; &nbsp;only show records generated by resource manager RMGR</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;use --rmgr=list to list valid resource manager names</font></div><div><font size="2"   >&nbsp; -s, --start=RECPTR &nbsp; &nbsp; stop reading at log position RECPTR</font></div><div><font size="2"   >&nbsp; -t, --timeline=TLI &nbsp; &nbsp; timeline from which to read log records</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(default: 1 or the value used in STARTSEG)</font></div><div><font size="2"   >&nbsp; -x, --xid=XID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;only show records with TransactionId XID</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >输出解释, 以下条输出为例 :&nbsp;</span></div><div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >rmgr: Btree &nbsp; &nbsp; &nbsp; len (rec/tot): &nbsp; &nbsp; 18/ &nbsp;2374, tx: &nbsp; &nbsp; &nbsp; 1686, lsn: 0/0181D8E8, prev 0/0181CFA0, bkp: 1000, desc: insert: rel 1663/</font></div><div style="line-height: 22px;"   ><font size="2"   >16385/12599; tid 1/113</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; backup bkp #0; rel 1663/16385/12599; fork: main; block: 1; hole: offset: 476, length: 5892</font></div><p></p></pre></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >以上输出每个部分的详细解释 :&nbsp;</span></div></div></div><div>1. 该XLogRecord的资源管理器.</div><div><span style="line-height: 22px;"   ><u>rmgr: Btree</u></span></div><div>取自<span style="line-height: 22px;"   >XLogRecord.xl_rmid.&nbsp;</span></div><div><span style="line-height: 22px;"   >定义在</span>src/include/access/rmgrlist.h中可以找到. 详见本文参考部分.</div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >2. 该XLogRecord的资源管理器的长度以及</span><span style="line-height: 22px;"   >该XLogRecord的总长度</span></div><div><span style="line-height: 22px;"   ><u>len (rec/tot): &nbsp; &nbsp; 18/ &nbsp;2374,</u></span></div><div><span style="line-height: 22px;"   >取自</span><span style="line-height: 22px;"   >XLogRecord.xl_len和XLogRecord.xl_tot_len</span></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >3. 该XLogRecord的事务ID(TransactinoId)</span></div><div><span style="line-height: 22px;"   ><u>tx: &nbsp; &nbsp; &nbsp; 1686,</u></span></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >4. 该XLogRecord在xlog虚拟地址空间中的位置.</span></div><div>将XLogRecPtr拆成2个UINT32输出. 分别表示</div><div><span style="line-height: 22px;"   ><u>lsn: 0/0181D8E8,</u></span></div><div>xlog文件的命名也与<span style="line-height: 22px;"   >xlog虚拟地址空间有关.</span></div><div><span style="line-height: 22px;"   >参考 :&nbsp;</span></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020129159590908/"   >http://blog.163.com/digoal@126/blog/static/16387704020129159590908/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012914112949546/"   >http://blog.163.com/digoal@126/blog/static/1638770402012914112949546/</a></div><div><span style="line-height: 22px;"   >而在</span>PageHeaderData中pd_lsn存储的是该BLOCK对应的最后一次被改变时记录的<span style="line-height: 22px;"   >xlog虚拟地址空间中的下一个位置</span></div><div>pd_lsn<span style="white-space:pre;"   >	</span>XLogRecPtr<span style="white-space:pre;"   >	</span>8 bytes<span style="white-space:pre;"   >	</span>LSN: next byte after last byte of xlog record for last change to this page.</div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >5.&nbsp;</span><span style="line-height: 22px;"   >该XLogRecord的前一条</span><span style="line-height: 22px;"   >XLogRecord的位置(uint64位</span><span style="line-height: 22px;"   >虚拟地址空间</span><span style="line-height: 22px;"   >)</span></div><div><span style="line-height: 22px;"   >将XLogRecPtr拆成2个UINT32输出.</span></div><div><span style="line-height: 22px;"   ><u>prev 0/0181CFA0,</u></span></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >6. 该XLogRecord的</span><span style="line-height: 22px;"   >disk blocks的备份标记, 每个XLOG Record最多可以记录4个disk blocks.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >00046 &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; xl_info; &nbsp; &nbsp; &nbsp; &nbsp;/* flag bits, see below */</font></div><div><div><font size="2"   >00062 /*</font></div><div><font size="2"   >00063 &nbsp;* XLOG uses only low 4 bits of xl_info. &nbsp;High 4 bits may be used by rmgr.</font></div><div><font size="2"   >00064 &nbsp;*/</font></div><div><font size="2"   >00065 #define XLR_INFO_MASK &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0F</font></div><div><font size="2"   >00066&nbsp;</font></div><div><font size="2"   >00067 /*</font></div><div><font size="2"   >00068 &nbsp;* If we backed up any disk blocks with the XLOG record, we use flag bits in</font></div><div><font size="2"   >00069 &nbsp;* xl_info to signal it. &nbsp;We support backup of up to 4 disk blocks per XLOG</font></div><div><font size="2"   >00070 &nbsp;* record.</font></div><div><font size="2"   >00071 &nbsp;*/</font></div><div><font size="2"   >00072 #define XLR_BKP_BLOCK_MASK &nbsp; &nbsp; &nbsp;0x0F &nbsp; &nbsp;/* all info bits used for bkp blocks */</font></div></div><p></p></pre></div><div><span style="line-height: 22px;"   ><u>bkp: 1000,</u></span></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >7. 描述信息, 根据不同的资源管理器, 描述信息不同.</span></div><div><span style="line-height: 22px;"   >例如本条记录的资源管理器为Btree.</span></div><div><div style="line-height: 22px;"   ><u>desc: insert: rel 1663/<span style="line-height: 22px;"   >16385/12599; tid 1/113</span></u></div></div><div><span style="line-height: 22px;"   >那么描述信息取自&nbsp;</span>contrib/pg_xlogdump/<span style="line-height: 22px;"   >nbtdesc.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >out_target(StringInfo buf, xl_btreetid *target)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, "rel %u/%u/%u; tid %u/%u",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;target-&gt;node.spcNode, target-&gt;node.dbNode, target-&gt;node.relNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ItemPointerGetBlockNumber(&amp;(target-&gt;tid)),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ItemPointerGetOffsetNumber(&amp;(target-&gt;tid)));</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>包含表空间/数据库/对象的节点信息.</div><div>该索引数据块号码和OFFSET号.</div><div><br></div><div>以下是XLogRecord中包含的备份disk block的详细信息. 每个XLogRecord中最多4条.</div><div>数据结构如下 :&nbsp;</div><div><div><span style="line-height: 22px;"   >src/include/access/xlog_internal.h</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >00030 /*</font></div><div><font size="2"   >00031 &nbsp;* Header info for a backup block appended to an XLOG record.</font></div><div><font size="2"   >00032 &nbsp;*</font></div><div><font size="2"   >00033 &nbsp;* As a trivial form of data compression, the XLOG code is aware that</font></div><div><font size="2"   >00034 &nbsp;* PG data pages usually contain an unused "hole" in the middle, which</font></div><div><font size="2"   >00035 &nbsp;* contains only zero bytes. &nbsp;If hole_length &gt; 0 then we have removed</font></div><div><font size="2"   >00036 &nbsp;* such a "hole" from the stored data (and it's not counted in the</font></div><div><font size="2"   >00037 &nbsp;* XLOG record's CRC, either). &nbsp;Hence, the amount of block data actually</font></div><div><font size="2"   >00038 &nbsp;* present following the BkpBlock struct is BLCKSZ - hole_length bytes.</font></div><div><font size="2"   >00039 &nbsp;*</font></div><div><font size="2"   >00040 &nbsp;* Note that we don't attempt to align either the BkpBlock struct or the</font></div><div><font size="2"   >00041 &nbsp;* block's data. &nbsp;So, the struct must be copied to aligned local storage</font></div><div><font size="2"   >00042 &nbsp;* before use.</font></div><div><font size="2"   >00043 &nbsp;*/</font></div><div><font size="2"   >00044 typedef struct BkpBlock</font></div><div><font size="2"   >00045 {</font></div><div><font size="2"   >00046 &nbsp; &nbsp; RelFileNode node; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* relation containing block */</font></div><div><font size="2"   >00047 &nbsp; &nbsp; ForkNumber &nbsp;fork; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fork within the relation */</font></div><div><font size="2"   >00048 &nbsp; &nbsp; BlockNumber block; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* block number */</font></div><div><font size="2"   >00049 &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp;hole_offset; &nbsp; &nbsp;/* number of bytes before "hole" */</font></div><div><font size="2"   >00050 &nbsp; &nbsp; uint16 &nbsp; &nbsp; &nbsp;hole_length; &nbsp; &nbsp;/* number of bytes in "hole" */</font></div><div><font size="2"   >00051&nbsp;</font></div><div><font size="2"   >00052 &nbsp; &nbsp; /* ACTUAL BLOCK DATA FOLLOWS AT END OF STRUCT */</font></div><div><font size="2"   >00053 } BkpBlock;</font></div><p></p></pre></div></div><div><span style="line-height: 22px;"   >8. 备份数据块的信息, 前面提到了每条XLogRecord中最多可存储4个备份disk block的信息. &nbsp;从bkp 0开始编号.</span></div><div><span style="line-height: 22px;"   ><u>backup bkp #0; &nbsp;</u></span></div><div><span style="line-height: 22px;"   >代码如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (config-&gt;bkp_details)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bkpnum;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *blk = (char *) XLogRecGetData(record) + record-&gt;xl_len;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (bkpnum = 0; bkpnum &lt; XLR_MAX_BKP_BLOCKS; bkpnum++)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BkpBlock &nbsp; &nbsp; &nbsp; &nbsp;bkpb;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(XLR_BKP_BLOCK(bkpnum) &amp; record-&gt;xl_info))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;bkpb, blk, sizeof(BkpBlock));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk += sizeof(BkpBlock);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk += BLCKSZ - bkpb.hole_length;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("\tbackup bkp #%u; rel %u/%u/%u; fork: %s; block: %u; hole: offset: %u, length: %u\n",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bkpnum,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bkpb.node.spcNode, bkpb.node.dbNode, bkpb.node.relNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;forkNames[bkpb.fork],</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bkpb.block, bkpb.hole_offset, bkpb.hole_length);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >9. 该备份disk block的表空间/数据库/对象节点信息.</span></div><div><span style="line-height: 22px;"   ><u>rel 1663/16385/12599;</u></span></div><div><br></div><div><span style="line-height: 22px;"   >10. 该备份disk block对应的对象的fork类型, 这个不了解的话可以去看一下相关的手册.</span></div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/storage.html"   >http://www.postgresql.org/docs/devel/static/storage.html</a></div><div>包括main(主存储), fsm(free space map信息), vm(visilibity map信息) 等.</div><div><div>src/include/storage/relfilenode.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >00019 /*</font></div><div><font size="2"   >00020 &nbsp;* The physical storage of a relation consists of one or more forks. The</font></div><div><font size="2"   >00021 &nbsp;* main fork is always created, but in addition to that there can be</font></div><div><font size="2"   >00022 &nbsp;* additional forks for storing various metadata. ForkNumber is used when</font></div><div><font size="2"   >00023 &nbsp;* we need to refer to a specific fork in a relation.</font></div><div><font size="2"   >00024 &nbsp;*/</font></div><div><font size="2"   >00025 typedef enum ForkNumber</font></div><div><font size="2"   >00026 {</font></div><div><font size="2"   >00027 &nbsp; &nbsp; InvalidForkNumber = -1,</font></div><div><font size="2"   >00028 &nbsp; &nbsp; MAIN_FORKNUM = 0,</font></div><div><font size="2"   >00029 &nbsp; &nbsp; FSM_FORKNUM,</font></div><div><font size="2"   >00030 &nbsp; &nbsp; VISIBILITYMAP_FORKNUM,</font></div><div><font size="2"   >00031 &nbsp; &nbsp; INIT_FORKNUM</font></div><div><font size="2"   >00032&nbsp;</font></div><div><font size="2"   >00033 &nbsp; &nbsp; /*</font></div><div><font size="2"   >00034 &nbsp; &nbsp; &nbsp;* NOTE: if you add a new fork, change MAX_FORKNUM below and update the</font></div><div><font size="2"   >00035 &nbsp; &nbsp; &nbsp;* forkNames array in catalog.c</font></div><div><font size="2"   >00036 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >00037 } ForkNumber;</font></div><p></p></pre></div></div><div><span style="line-height: 22px;"   ><u>fork: main;</u></span></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >11. 该备份disk block的ID编号.</span></div><div><u>block: 1;</u></div><div>说明这个disk block是这个对象的第一个数据块.</div><div><br></div><div><span style="line-height: 22px;"   >12. 指这个备份disk block的零空间的位置(假设1个数据块为8KB, 最上面包括了数据块的头文件, 然后是itemID信息等. itemID对应的数据则是从数据块的最底部开始分配的,所以一个数据库的中间部分是空闲的, 也就是初始0的状态, XLogRecord备份的disk block中可以排除这些信息, 减少备份的大小.)</span></div><div><u><span style="line-height: 22px;"   >hole: offset: 476,&nbsp;</span><span style="line-height: 22px;"   >length: 5892</span></u></div><div><span style="line-height: 22px;"   >从这里来看空闲的位置是数据块的476开始的</span><span style="line-height: 22px;"   >5892个字节. 所以这个部分不需要备份.</span></div><div><span style="line-height: 22px;"   >数据块的结构如下 :&nbsp;</span></div><div><div><img title="PostgreSQL 9.3 XLOG dump contrib introduce - 德哥@Digoal - The Heart,The World."   alt="PostgreSQL 9.3 XLOG dump contrib introduce - 德哥@Digoal - The Heart,The World."   style="margin:0 10px 0 0;"   src="http://img8.ph.126.net/oJJO1Jz-YEv-GSg0mbC8sA==/6597875708680369678.jpg"   ></div>&nbsp;</div><div><span style="line-height: 22px;"   >【使用举例】</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><font size="2"   >-- 创建测试表</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   ><div>digoal=# create table a (id int primary key, info text);</div><div>CREATE TABLE</div><div>-- 开始事务</div></font></span></div><div><div><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >-- 获取当前事务号</font></div><div><font size="2"   >digoal=# select txid_current();</font></div><div><font size="2"   >&nbsp;txid_current&nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1694</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >-- 获取当前XLOG文件名</font></div><div><font size="2"   >digoal=# select pg_xlogfile_name(pg_current_xlog_location());</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;pg_xlogfile_name &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >--------------------------</font></div><div><font size="2"   >&nbsp;000000010000000000000004</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >-- 插入数据</font></div><div><font size="2"   >digoal=# insert into a values (1,'digoal');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >-- 提交事务</font></div><div><font size="2"   >digoal=# end;</font></div><div><font size="2"   >COMMIT</font></div><div><font size="2"   >-- 获取当前XLOG文件名</font></div><div><font size="2"   >digoal=# select pg_xlogfile_name(pg_current_xlog_location());</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;pg_xlogfile_name &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >--------------------------</font></div><div><font size="2"   >&nbsp;000000010000000000000004</font></div><div><font size="2"   >(1 row)</font></div></div></div><p></p></pre></div><div><div>-- 第一个XLOG文件名传入pg_xlogdump的STARTSEG, 第二个XLOG文件名传入ENDSEG.</div><div><span style="line-height: 22px;"   >下面将要输出以上事务的XLOG信息 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pgdev@db-172-16-3-150-&gt; pg_xlogdump -b -x 1689 -p /data06/pgdev/pg_root/pg_xlog 000000010000000000000002 000000010000000000000002</font></div><div><font size="2"   ><span style="line-height: 19px;"   >rmgr: Heap        len (rec/tot):     38/    70, tx:       1694, lsn: 0/040334A8, prev 0/04033468, bkp: 0000, desc: insert(init): rel 1663/16385/16410; tid 0/1<br>rmgr: Btree       len (rec/tot):     20/    52, tx:       1694, lsn: 0/040334F0, prev 0/040334A8, bkp: 0000, desc: newroot: rel 1663/16385/16416; root 1 lev 0<br>rmgr: Btree       len (rec/tot):     34/    66, tx:       1694, lsn: 0/04033528, prev 0/040334F0, bkp: 0000, desc: insert: rel 1663/16385/16416; tid 1/1<br>rmgr: Transaction len (rec/tot):     48/    80, tx:       1694, lsn: 0/04033570, prev 0/04033528, bkp: 0000, desc: commit: 2013-02-23 13:48:20.914498 CST; inval msgs: relcache 16416</span></font></div><p></p></pre></div></div><div>描述信息中涉及的rel ID可在数据库中查到 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 19px;"   >digoal=# select pg_relation_filepath('a');<br> pg_relation_filepath <br>----------------------<br> base/16385/16410<br>(1 row)<br>digoal=# select pg_relation_filepath('a_pkey');<br> pg_relation_filepath <br>----------------------<br> base/16385/16416<br>(1 row)</span></font></div><p></p></pre></div><div>表空间信息 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from pg_tablespace where oid='1663';</font></div><div><font size="2"   >&nbsp; spcname &nbsp; | spcowner | spcacl | spcoptions&nbsp;</font></div><div><font size="2"   >------------+----------+--------+------------</font></div><div><font size="2"   >&nbsp;pg_default | &nbsp; &nbsp; &nbsp; 10 | &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>当然也可以反向查询, 默认表空间取0 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select relname from pg_class where relfilenode=16410 and reltablespace in (0,1663);</font></div><div><font size="2"   >&nbsp;relname&nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;a</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=# select relname from pg_class where relfilenode=16416 and reltablespace in (0,1663);</font></div><div><font size="2"   >&nbsp;relname&nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;a_pkey</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>再解释一下描述信息 :&nbsp;</div><div><span style="line-height: 22px;"   >1.&nbsp;</span><u>desc: insert(init): rel 1663/16385/16410; tid 0/1</u></div><div><span style="line-height: 22px;"   ><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, "rel %u/%u/%u; tid %u/%u",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;target-&gt;node.spcNode, target-&gt;node.dbNode, target-&gt;node.relNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ItemPointerGetBlockNumber(&amp;(target-&gt;tid)),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ItemPointerGetOffsetNumber(&amp;(target-&gt;tid)));</font></div><p></p></pre></div><div style="text-decoration: underline;"   ><br></div></span></div><div><span style="line-height: 22px;"   >2.&nbsp;</span><u>desc: newroot: rel 1663/16385/16416; root 1 lev 0</u></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, "newroot: rel %u/%u/%u; root %u lev %u",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xlrec-&gt;node.spcNode, xlrec-&gt;node.dbNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xlrec-&gt;node.relNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xlrec-&gt;rootblk, xlrec-&gt;level);</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >btree索引的操作介绍见本文参考部分, 例如可以观察出新插入的ITEM是否是分裂插入的. 例如以下的UUID作为索引的例子, 可以通过XLogRecord来观察是否经常发生分裂.</span></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020129249646421/"   >http://blog.163.com/digoal@126/blog/static/16387704020129249646421/</a></div><div><span style="line-height: 22px;"   ><u><br></u></span></div><div><span style="line-height: 22px;"   >3.&nbsp;</span><u>desc: insert: rel 1663/16385/16416; tid 1/1</u></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, "rel %u/%u/%u; tid %u/%u",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;target-&gt;node.spcNode, target-&gt;node.dbNode, target-&gt;node.relNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ItemPointerGetBlockNumber(&amp;(target-&gt;tid)),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ItemPointerGetOffsetNumber(&amp;(target-&gt;tid)));</font></div><p></p></pre></div><div><span style="line-height: 22px;"   ><u><br></u></span></div><div><span style="line-height: 22px;"   >4.&nbsp;</span><u>desc: commit: 2013-02-23 13:48:20.914498 CST; inval msgs: relcache 16416</u></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >xact_desc_commit_compact(StringInfo buf, xl_xact_commit_compact *xlrec)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, timestamptz_to_str(xlrec-&gt;xact_time));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (xlrec-&gt;nsubxacts &gt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, "; subxacts:");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; xlrec-&gt;nsubxacts; i++)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, " %u", xlrec-&gt;subxacts[i]);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   >......</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, "; inval msgs:");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; xlrec-&gt;nmsgs; i++)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SharedInvalidationMessage *msg = &amp;msgs[i];</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (msg-&gt;id &gt;= 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, " catcache %d", msg-&gt;id);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (msg-&gt;id == SHAREDINVALCATALOG_ID)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, " catalog %u", msg-&gt;cat.catId);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (msg-&gt;id == SHAREDINVALRELCACHE_ID)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, " relcache %u", msg-&gt;rc.relId);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* remaining cases not expected, but print something anyway */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (msg-&gt;id == SHAREDINVALSMGR_ID)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, " smgr");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (msg-&gt;id == SHAREDINVALRELMAP_ID)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, " relmap");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, " unknown id %d", msg-&gt;id);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><p></p></pre></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >【参考】</span></div><div>1.&nbsp;contrib/pg_xlogdump/pg_xlogdump.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Print a record to stdout</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static void</font></div><div><font size="2"   >XLogDumpDisplayRecord(XLogDumpConfig *config, XLogRecPtr ReadRecPtr, XLogRecord *record)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; const RmgrDescData *desc = &amp;RmgrDescTable[record-&gt;xl_rmid];</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (config-&gt;filter_by_rmgr != -1 &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; config-&gt;filter_by_rmgr != record-&gt;xl_rmid)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (config-&gt;filter_by_xid_enabled &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; config-&gt;filter_by_xid != record-&gt;xl_xid)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; config-&gt;already_displayed_records++;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; printf("rmgr: %-11s len (rec/tot): %6u/%6u, tx: %10u, lsn: %X/%08X, prev %X/%08X, bkp: %u%u%u%u, desc: ",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;desc-&gt;rm_name,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;record-&gt;xl_len, record-&gt;xl_tot_len,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;record-&gt;xl_xid,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(uint32) (ReadRecPtr &gt;&gt; 32), (uint32) ReadRecPtr,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(uint32) (record-&gt;xl_prev &gt;&gt; 32), (uint32) record-&gt;xl_prev,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;!!(XLR_BKP_BLOCK(0) &amp; record-&gt;xl_info),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;!!(XLR_BKP_BLOCK(1) &amp; record-&gt;xl_info),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;!!(XLR_BKP_BLOCK(2) &amp; record-&gt;xl_info),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;!!(XLR_BKP_BLOCK(3) &amp; record-&gt;xl_info));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* the desc routine will printf the description directly to stdout */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; desc-&gt;rm_desc(NULL, record-&gt;xl_info, XLogRecGetData(record));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; putchar('\n');</font></div></div><div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (config-&gt;bkp_details)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bkpnum;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *blk = (char *) XLogRecGetData(record) + record-&gt;xl_len;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (bkpnum = 0; bkpnum &lt; XLR_MAX_BKP_BLOCKS; bkpnum++)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BkpBlock &nbsp; &nbsp; &nbsp; &nbsp;bkpb;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(XLR_BKP_BLOCK(bkpnum) &amp; record-&gt;xl_info))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;bkpb, blk, sizeof(BkpBlock));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk += sizeof(BkpBlock);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk += BLCKSZ - bkpb.hole_length;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("\tbackup bkp #%u; rel %u/%u/%u; fork: %s; block: %u; hole: offset: %u, length: %u\n",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bkpnum,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bkpb.node.spcNode, bkpb.node.dbNode, bkpb.node.relNode,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;forkNames[bkpb.fork],</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bkpb.block, bkpb.hole_offset, bkpb.hole_length);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div>2.&nbsp;<span style="line-height: 22px;"   >src/include/access/rmgrlist.h</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><font size="2"   >00018 /*</font></span></div><div><font size="2"   >00019 &nbsp;* List of resource manager entries. &nbsp;Note that order of entries defines the</font></div><div><font size="2"   >00020 &nbsp;* numerical values of each rmgr's ID, which is stored in WAL records. &nbsp;New</font></div><div><font size="2"   >00021 &nbsp;* entries should be added at the end, to avoid changing IDs of existing</font></div><div><font size="2"   >00022 &nbsp;* entries.</font></div><div><font size="2"   >00023 &nbsp;*</font></div><div><font size="2"   >00024 &nbsp;* Changes to this list possibly need a XLOG_PAGE_MAGIC bump.</font></div><div><font size="2"   >00025 &nbsp;*/</font></div><div><font size="2"   >00026&nbsp;</font></div><div><font size="2"   >00027 /* symbol name, textual name, redo, desc, startup, cleanup, restartpoint */</font></div><div><font size="2"   >00028 PG_RMGR(RM_XLOG_ID, "XLOG", xlog_redo, xlog_desc, NULL, NULL, NULL)</font></div><div><font size="2"   >00029 PG_RMGR(RM_XACT_ID, "Transaction", xact_redo, xact_desc, NULL, NULL, NULL)</font></div><div><font size="2"   >00030 PG_RMGR(RM_SMGR_ID, "Storage", smgr_redo, smgr_desc, NULL, NULL, NULL)</font></div><div><font size="2"   >00031 PG_RMGR(RM_CLOG_ID, "CLOG", clog_redo, clog_desc, NULL, NULL, NULL)</font></div><div><font size="2"   >00032 PG_RMGR(RM_DBASE_ID, "Database", dbase_redo, dbase_desc, NULL, NULL, NULL)</font></div><div><font size="2"   >00033 PG_RMGR(RM_TBLSPC_ID, "Tablespace", tblspc_redo, tblspc_desc, NULL, NULL, NULL)</font></div><div><font size="2"   >00034 PG_RMGR(RM_MULTIXACT_ID, "MultiXact", multixact_redo, multixact_desc, NULL, NULL, NULL)</font></div><div><font size="2"   >00035 PG_RMGR(RM_RELMAP_ID, "RelMap", relmap_redo, relmap_desc, NULL, NULL, NULL)</font></div><div><font size="2"   >00036 PG_RMGR(RM_STANDBY_ID, "Standby", standby_redo, standby_desc, NULL, NULL, NULL)</font></div><div><font size="2"   >00037 PG_RMGR(RM_HEAP2_ID, "Heap2", heap2_redo, heap2_desc, NULL, NULL, NULL)</font></div><div><font size="2"   >00038 PG_RMGR(RM_HEAP_ID, "Heap", heap_redo, heap_desc, NULL, NULL, NULL)</font></div><div><font size="2"   >00039 PG_RMGR(RM_BTREE_ID, "Btree", btree_redo, btree_desc, btree_xlog_startup, btree_xlog_cleanup, btree_safe_restartpoint)</font></div><div><font size="2"   >00040 PG_RMGR(RM_HASH_ID, "Hash", hash_redo, hash_desc, NULL, NULL, NULL)</font></div><div><font size="2"   >00041 PG_RMGR(RM_GIN_ID, "Gin", gin_redo, gin_desc, gin_xlog_startup, gin_xlog_cleanup, gin_safe_restartpoint)</font></div><div><font size="2"   >00042 PG_RMGR(RM_GIST_ID, "Gist", gist_redo, gist_desc, gist_xlog_startup, gist_xlog_cleanup, NULL)</font></div><div><font size="2"   >00043 PG_RMGR(RM_SEQ_ID, "Sequence", seq_redo, seq_desc, NULL, NULL, NULL)</font></div><div><font size="2"   >00044 PG_RMGR(RM_SPGIST_ID, "SPGist", spg_redo, spg_desc, spg_xlog_startup, spg_xlog_cleanup, NULL)</font></div><p></p></pre></div><div>3.&nbsp;<span style="line-height: 22px;"   >src/include/access/xlog.h</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >00041 typedef struct XLogRecord</font></div><div><font size="2"   >00042 {</font></div><div><font size="2"   >00043 &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp;xl_tot_len; &nbsp; &nbsp; /* total len of entire record */</font></div><div><font size="2"   >00044 &nbsp; &nbsp; TransactionId xl_xid; &nbsp; &nbsp; &nbsp; /* xact id */</font></div><div><font size="2"   >00045 &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp;xl_len; &nbsp; &nbsp; &nbsp; &nbsp; /* total len of rmgr data */</font></div><div><font size="2"   >00046 &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; xl_info; &nbsp; &nbsp; &nbsp; &nbsp;/* flag bits, see below */</font></div><div><font size="2"   >00047 &nbsp; &nbsp; RmgrId &nbsp; &nbsp; &nbsp;xl_rmid; &nbsp; &nbsp; &nbsp; &nbsp;/* resource manager for this record */</font></div><div><font size="2"   >00048 &nbsp; &nbsp; /* 2 bytes of padding here, initialize to zero */</font></div><div><font size="2"   >00049 &nbsp; &nbsp; XLogRecPtr &nbsp;xl_prev; &nbsp; &nbsp; &nbsp; &nbsp;/* ptr to previous record in log */</font></div><div><font size="2"   >00050 &nbsp; &nbsp; pg_crc32 &nbsp; &nbsp;xl_crc; &nbsp; &nbsp; &nbsp; &nbsp; /* CRC for this record */</font></div><div><font size="2"   >00051&nbsp;</font></div><div><font size="2"   >00052 &nbsp; &nbsp; /* If MAXALIGN==8, there are 4 wasted bytes here */</font></div><div><font size="2"   >00053&nbsp;</font></div><div><font size="2"   >00054 &nbsp; &nbsp; /* ACTUAL LOG DATA FOLLOWS AT END OF STRUCT */</font></div><div><font size="2"   >00055&nbsp;</font></div><div><font size="2"   >00056 } XLogRecord;</font></div><p></p></pre></div><div>4.&nbsp;<span style="line-height: 22px;"   >src/include/c.h</span></div><div><pre class="prettyprint"   ><p><font size="2"   >00354 typedef uint32 TransactionId;</font></p></pre></div><div>5.&nbsp;src/include/access/nbtree.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >00228 /*</font></div><div><font size="2"   >00229 &nbsp;* All that we need to find changed index tuple</font></div><div><font size="2"   >00230 &nbsp;*/</font></div><div><font size="2"   >00231 typedef struct xl_btreetid</font></div><div><font size="2"   >00232 {</font></div><div><font size="2"   >00233 &nbsp; &nbsp; RelFileNode node;</font></div><div><font size="2"   >00234 &nbsp; &nbsp; ItemPointerData tid; &nbsp; &nbsp; &nbsp; &nbsp;/* changed tuple id */</font></div><div><font size="2"   >00235 } xl_btreetid;</font></div><p></p></pre></div><div><br></div><div>6. src/include/storage/relfilenode.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >00041 /*</font></div><div><font size="2"   >00042 &nbsp;* RelFileNode must provide all that we need to know to physically access</font></div><div><font size="2"   >00043 &nbsp;* a relation, with the exception of the backend ID, which can be provided</font></div><div><font size="2"   >00044 &nbsp;* separately. Note, however, that a "physical" relation is comprised of</font></div><div><font size="2"   >00045 &nbsp;* multiple files on the filesystem, as each fork is stored as a separate</font></div><div><font size="2"   >00046 &nbsp;* file, and each fork can be divided into multiple segments. See md.c.</font></div><div><font size="2"   >00047 &nbsp;*</font></div><div><font size="2"   >00048 &nbsp;* spcNode identifies the tablespace of the relation. &nbsp;It corresponds to</font></div><div><font size="2"   >00049 &nbsp;* pg_tablespace.oid.</font></div><div><font size="2"   >00050 &nbsp;*</font></div><div><font size="2"   >00051 &nbsp;* dbNode identifies the database of the relation. &nbsp;It is zero for</font></div><div><font size="2"   >00052 &nbsp;* "shared" relations (those common to all databases of a cluster).</font></div><div><font size="2"   >00053 &nbsp;* Nonzero dbNode values correspond to pg_database.oid.</font></div><div><font size="2"   >00054 &nbsp;*</font></div><div><font size="2"   >00055 &nbsp;* relNode identifies the specific relation. &nbsp;relNode corresponds to</font></div><div><font size="2"   >00056 &nbsp;* pg_class.relfilenode (NOT pg_class.oid, because we need to be able</font></div><div><font size="2"   >00057 &nbsp;* to assign new physical files to relations in some situations).</font></div><div><font size="2"   >00058 &nbsp;* Notice that relNode is only unique within a particular database.</font></div><div><font size="2"   >00059 &nbsp;*</font></div><div><font size="2"   >00060 &nbsp;* Note: spcNode must be GLOBALTABLESPACE_OID if and only if dbNode is</font></div><div><font size="2"   >00061 &nbsp;* zero. &nbsp;We support shared relations only in the "global" tablespace.</font></div><div><font size="2"   >00062 &nbsp;*</font></div><div><font size="2"   >00063 &nbsp;* Note: in pg_class we allow reltablespace == 0 to denote that the</font></div><div><font size="2"   >00064 &nbsp;* relation is stored in its database's "default" tablespace (as</font></div><div><font size="2"   >00065 &nbsp;* identified by pg_database.dattablespace). &nbsp;However this shorthand</font></div><div><font size="2"   >00066 &nbsp;* is NOT allowed in RelFileNode structs --- the real tablespace ID</font></div><div><font size="2"   >00067 &nbsp;* must be supplied when setting spcNode.</font></div><div><font size="2"   >00068 &nbsp;*</font></div><div><font size="2"   >00069 &nbsp;* Note: in pg_class, relfilenode can be zero to denote that the relation</font></div><div><font size="2"   >00070 &nbsp;* is a "mapped" relation, whose current true filenode number is available</font></div><div><font size="2"   >00071 &nbsp;* from relmapper.c. &nbsp;Again, this case is NOT allowed in RelFileNodes.</font></div><div><font size="2"   >00072 &nbsp;*</font></div><div><font size="2"   >00073 &nbsp;* Note: various places use RelFileNode in hashtable keys. &nbsp;Therefore,</font></div><div><font size="2"   >00074 &nbsp;* there *must not* be any unused padding bytes in this struct. &nbsp;That</font></div><div><font size="2"   >00075 &nbsp;* should be safe as long as all the fields are of type Oid.</font></div><div><font size="2"   >00076 &nbsp;*/</font></div><div><font size="2"   >00077 typedef struct RelFileNode</font></div><div><font size="2"   >00078 {</font></div><div><font size="2"   >00079 &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; spcNode; &nbsp; &nbsp; &nbsp; &nbsp;/* tablespace */</font></div><div><font size="2"   >00080 &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; dbNode; &nbsp; &nbsp; &nbsp; &nbsp; /* database */</font></div><div><font size="2"   >00081 &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; relNode; &nbsp; &nbsp; &nbsp; &nbsp;/* relation */</font></div><div><font size="2"   >00082 } RelFileNode;</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >7.&nbsp;</span><span style="line-height: 22px;"   >src/include/access/nbtree.h</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >00204 /*</font></div><div><font size="2"   >00205 &nbsp;* XLOG records for btree operations</font></div><div><font size="2"   >00206 &nbsp;*</font></div><div><font size="2"   >00207 &nbsp;* XLOG allows to store some information in high 4 bits of log</font></div><div><font size="2"   >00208 &nbsp;* record xl_info field</font></div><div><font size="2"   >00209 &nbsp;*/</font></div><div><font size="2"   >00210 #define XLOG_BTREE_INSERT_LEAF &nbsp;0x00 &nbsp; &nbsp;/* add index tuple without split */</font></div><div><font size="2"   >00211 #define XLOG_BTREE_INSERT_UPPER 0x10 &nbsp; &nbsp;/* same, on a non-leaf page */</font></div><div><font size="2"   >00212 #define XLOG_BTREE_INSERT_META &nbsp;0x20 &nbsp; &nbsp;/* same, plus update metapage */</font></div><div><font size="2"   >00213 #define XLOG_BTREE_SPLIT_L &nbsp; &nbsp; &nbsp;0x30 &nbsp; &nbsp;/* add index tuple with split */</font></div><div><font size="2"   >00214 #define XLOG_BTREE_SPLIT_R &nbsp; &nbsp; &nbsp;0x40 &nbsp; &nbsp;/* as above, new item on right */</font></div><div><font size="2"   >00215 #define XLOG_BTREE_SPLIT_L_ROOT 0x50 &nbsp; &nbsp;/* add tuple with split of root */</font></div><div><font size="2"   >00216 #define XLOG_BTREE_SPLIT_R_ROOT 0x60 &nbsp; &nbsp;/* as above, new item on right */</font></div><div><font size="2"   >00217 #define XLOG_BTREE_DELETE &nbsp; &nbsp; &nbsp; 0x70 &nbsp; &nbsp;/* delete leaf index tuples for a page */</font></div><div><font size="2"   >00218 #define XLOG_BTREE_DELETE_PAGE &nbsp;0x80 &nbsp; &nbsp;/* delete an entire page */</font></div><div><font size="2"   >00219 #define XLOG_BTREE_DELETE_PAGE_META 0x90 &nbsp; &nbsp; &nbsp; &nbsp;/* same, and update metapage */</font></div><div><font size="2"   >00220 #define XLOG_BTREE_NEWROOT &nbsp; &nbsp; &nbsp;0xA0 &nbsp; &nbsp;/* new root page */</font></div><div><font size="2"   >00221 #define XLOG_BTREE_DELETE_PAGE_HALF 0xB0 &nbsp; &nbsp; &nbsp; &nbsp;/* page deletion that makes</font></div><div><font size="2"   >00222 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* parent half-dead */</font></div><div><font size="2"   >00223 #define XLOG_BTREE_VACUUM &nbsp; &nbsp; &nbsp; 0xC0 &nbsp; &nbsp;/* delete entries on a page during</font></div><div><font size="2"   >00224 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* vacuum */</font></div><div><font size="2"   >00225 #define XLOG_BTREE_REUSE_PAGE &nbsp; 0xD0 &nbsp; &nbsp;/* old page is about to be reused from</font></div><div><font size="2"   >00226 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* FSM */</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >8.&nbsp;</span><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012914112949546/"   >http://blog.163.com/digoal@126/blog/static/1638770402012914112949546/</a></div><div>9.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/pgxlogdump.html"   >http://www.postgresql.org/docs/devel/static/pgxlogdump.html</a></div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL 9.3 XLOG dump contrib introduce - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>