<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL varlena field upto 1GB and large object upto 4TB(>=9.3) 2GB(<=9.2)</h2>
	<h5 id="">2013-07-26 17:14:26&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020136264471312/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>我们知道PostgreSQL变长类型的字段有4种存储类型可以选择,&nbsp;<span style="line-height: 22px;"   >如下.</span></div><div><div>catalog/pg_type.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* ----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* typstorage tells if the type is prepared for toasting and what</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the default strategy for attributes of this type should be.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 'p' PLAIN &nbsp; &nbsp; &nbsp;type not prepared for toasting</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 'e' EXTERNAL &nbsp; external storage possible, don't try to compress</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 'x' EXTENDED &nbsp; try to compress and store external if required</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 'm' MAIN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; like 'x' but try to keep in main tuple</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;typstorage;</font></div><p></p></pre></div></div><div><span style="line-height: 22px;"   >定长字段没有外部存储方式可以选择,都是存储为plain模式.&nbsp;</span></div><div>当变长字段选择p或者m时, 数据在基表block中存储. 那么由于行不能跨block存储的限制, 行的最大size受到block size的限制.&nbsp;</div><div>当选择x或者e存储时, 当字段长度超过一定的阈值则会存储到基表以外的TOAST表中,(每个基表可能对应1个TOAST表. pg_class.reltoastrelid).</div><div>阈值代码如下.</div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><font size="2"   >/*</font></span></div><div><div><font size="2"   >&nbsp;* When we store an oversize datum externally, we divide it into chunks</font></div><div><font size="2"   >&nbsp;* containing at most TOAST_MAX_CHUNK_SIZE data bytes. &nbsp;This number *must*</font></div><div><font size="2"   >&nbsp;* be small enough that the completed toast-table tuple (including the</font></div><div><font size="2"   >&nbsp;* ID and sequence fields and all overhead) will fit on a page.</font></div><div><font size="2"   >&nbsp;* The coding here sets the size on the theory that we want to fit</font></div><div><font size="2"   >&nbsp;* EXTERN_TUPLES_PER_PAGE tuples of maximum size onto a page.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* NB: Changing TOAST_MAX_CHUNK_SIZE requires an initdb.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define EXTERN_TUPLES_PER_PAGE &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* tweak only this */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define EXTERN_TUPLE_MAX_SIZE &nbsp; MaximumBytesPerTuple(EXTERN_TUPLES_PER_PAGE)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#define TOAST_MAX_CHUNK_SIZE &nbsp; &nbsp;\</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; (EXTERN_TUPLE_MAX_SIZE - &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MAXALIGN(offsetof(HeapTupleHeaderData, t_bits)) - &nbsp; &nbsp; &nbsp;\</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sizeof(Oid) - &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sizeof(int32) - &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;VARHDRSZ)</font></div></div><p></p></pre></div><div>通过调整阈值可以调整数据存储方式, 有兴趣的朋友参考我以前写的一篇blog.</div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020130108132117/"   >http://blog.163.com/digoal@126/blog/static/16387704020130108132117/</a></div><div>那么为什么变长字段的数据存储在TOAST长度限制是1GB呢?</div><div>代码如下 :&nbsp;</div><div><span style="line-height: 22px;"   >src/include/postgres.h</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* These structs describe the header of a varlena object that may have been</font></div><div><font size="2"   >&nbsp;* TOASTed. &nbsp;Generally, don't reference these structs directly, but use the</font></div><div><font size="2"   >&nbsp;* macros below.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* We use separate structs for the aligned and unaligned cases because the</font></div><div><font size="2"   >&nbsp;* compiler might otherwise think it could generate code that assumes</font></div><div><font size="2"   >&nbsp;* alignment while touching fields of a 1-byte-header varlena.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >typedef union</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Normal varlena (4-byte length) */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;va_header;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;va_data[1];</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; va_4byte;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Compressed-in-line format */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;va_header;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;va_rawsize; /* Original data size (excludes header) */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;va_data[1]; /* Compressed data */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; va_compressed;</font></div><div><font size="2"   >} varattrib_4b;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >typedef struct</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; va_header;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;va_data[1]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Data begins here */</font></div><div><font size="2"   >} varattrib_1b;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* inline portion of a short varlena pointing to an external resource */</font></div><div><font size="2"   >typedef struct</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; va_header; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* Always 0x80 or 0x01 */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; va_tag; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Type of datum */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;va_data[1]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Data (of the type indicated by va_tag) */</font></div><div><font size="2"   >} varattrib_1b_e;</font></div><div><div><font size="2"   ><br></font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Bit layouts for varlena headers on big-endian machines:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 00xxxxxx 4-byte length word, aligned, uncompressed data (up to 1G)</font></div><div><font size="2"   >&nbsp;* 01xxxxxx 4-byte length word, aligned, *compressed* data (up to 1G)</font></div><div><font size="2"   >&nbsp;* 10000000 1-byte length word, unaligned, TOAST pointer</font></div><div><font size="2"   >&nbsp;* 1xxxxxxx 1-byte length word, unaligned, uncompressed data (up to 126b)</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Bit layouts for varlena headers on little-endian machines:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* xxxxxx00 4-byte length word, aligned, uncompressed data (up to 1G)</font></div><div><font size="2"   >&nbsp;* xxxxxx10 4-byte length word, aligned, *compressed* data (up to 1G)</font></div><div><font size="2"   >&nbsp;* 00000001 1-byte length word, unaligned, TOAST pointer</font></div><div><font size="2"   >&nbsp;* xxxxxxx1 1-byte length word, unaligned, uncompressed data (up to 126b)</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The "xxx" bits are the length field (which includes itself in all cases).</font></div><div><font size="2"   >&nbsp;* In the big-endian case we mask to extract the length, in the little-endian</font></div><div><font size="2"   >&nbsp;* case we shift. &nbsp;Note that in both cases the flag bits are in the physically</font></div><div><font size="2"   >&nbsp;* first byte. &nbsp;Also, it is not possible for a 1-byte length word to be zero;</font></div><div><font size="2"   >&nbsp;* this lets us disambiguate alignment padding bytes from the start of an</font></div><div><font size="2"   >&nbsp;* unaligned datum. &nbsp;(We now *require* pad bytes to be filled with zero!)</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* In TOAST datums the tag field in varattrib_1b_e is used to discern whether</font></div><div><font size="2"   >&nbsp;* its an indirection pointer or more commonly an on-disk tuple.</font></div><div><font size="2"   >&nbsp;*/</font></div></div><p></p></pre></div><div>4字节的头除去2个比特位剩余的30个比特位用来表示该字段存储的实际长度.</div><div>所以最大的长度是2^30-1=1GB.</div><div>如果要存储单字段超过1GB的数据, 可以选择large object, 在9.2以及更早的版本中大对象支持2GB的存储.</div><div>在9.3以及后续的版本, 加入了64位访问接口, 支持单字段最大4TB的存储.&nbsp;</div><div>有兴趣的朋友可参考如下BLOG :&nbsp;</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201341082422954/"   >http://blog.163.com/digoal@126/blog/static/163877040201341082422954/</a></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 22px;" href="http://blog.163.com/digoal@126/blog/static/16387704020130108132117/"   >http://blog.163.com/digoal@126/blog/static/16387704020130108132117/</a></div><div>2.&nbsp;<a style="line-height: 22px;" href="http://blog.163.com/digoal@126/blog/static/16387704020130108132117/"   >http://blog.163.com/digoal@126/blog/static/16387704020130108132117/</a></div><div>3.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/storage-toast.html"   >http://www.postgresql.org/docs/9.3/static/storage-toast.html</a></div><div>4.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/lo-intro.html"   >http://www.postgresql.org/docs/9.3/static/lo-intro.html</a></div><div>5.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=461ef73f0977c95c9452680495bc161618db9227"   >http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=461ef73f0977c95c9452680495bc161618db9227</a></div><div>6.&nbsp;<a style="line-height: 22px;" href="http://blog.163.com/digoal@126/blog/static/163877040201341082422954/"   >http://blog.163.com/digoal@126/blog/static/163877040201341082422954/</a></div><div>7. 数组结构参考如下</div><div>src/include/utils/array.h</div><wbr></div>
	</div>
</div>
</body>
</html>