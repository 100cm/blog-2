<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL USE dictionary table reduce storage requirement</h2>
	<h5 id="">2013-07-21 10:17:33&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201362194459995/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>本文要讲的是如何将大量的重复数据字典话,降低存储空间需求的目的.&nbsp;</div><div>字典化其实在PostgreSQL数据库的系统表中屡见不鲜.&nbsp;</div><div>例如oid字段, 很多系统表通过这个字段进行关联. 同时它也可以在一些类型中进行透明的转换.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select oid,relname from pg_class &nbsp;limit 1;</font></div><div><font size="2"   >&nbsp;oid &nbsp;| &nbsp; relname &nbsp; &nbsp;</font></div><div><font size="2"   >------+--------------</font></div><div><font size="2"   >&nbsp;2619 | pg_statistic</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>pg_class中的oid和regclass类型可以透明转换.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select 2619::regclass;</font></div><div><font size="2"   >&nbsp; &nbsp;regclass &nbsp;&nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp;pg_statistic</font></div><div><font size="2"   >(1 row)</font></div><div><div><font size="2"   >digoal=# select 'pg_statistic'::regclass::oid;</font></div><div><font size="2"   >&nbsp;oid &nbsp;</font></div><div><font size="2"   >------</font></div><div><font size="2"   >&nbsp;2619</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div></div><div>同时oid也是众多系统表关联的字段. 这里的pg_type.oid, pg_tablespace.oid等等.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# \d pg_class</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; Table "pg_catalog.pg_class"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;Column &nbsp; &nbsp; | &nbsp; Type &nbsp; &nbsp;| Modifiers&nbsp;</font></div><div><font size="2"   >----------------+-----------+-----------</font></div><div><font size="2"   >&nbsp;relname &nbsp; &nbsp; &nbsp; &nbsp;| name &nbsp; &nbsp; &nbsp;| not null</font></div><div><font size="2"   >&nbsp;relnamespace &nbsp; | oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;reltype &nbsp; &nbsp; &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;reloftype &nbsp; &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relowner &nbsp; &nbsp; &nbsp; | oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relam &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relfilenode &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;reltablespace &nbsp;| oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relpages &nbsp; &nbsp; &nbsp; | integer &nbsp; | not null</font></div><div><font size="2"   >&nbsp;reltuples &nbsp; &nbsp; &nbsp;| real &nbsp; &nbsp; &nbsp;| not null</font></div><div><font size="2"   >&nbsp;relallvisible &nbsp;| integer &nbsp; | not null</font></div><div><font size="2"   >&nbsp;reltoastrelid &nbsp;| oid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relhasindex &nbsp; &nbsp;| boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relisshared &nbsp; &nbsp;| boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relpersistence | "char" &nbsp; &nbsp;| not null</font></div><div><font size="2"   >&nbsp;relkind &nbsp; &nbsp; &nbsp; &nbsp;| "char" &nbsp; &nbsp;| not null</font></div><div><font size="2"   >&nbsp;relnatts &nbsp; &nbsp; &nbsp; | smallint &nbsp;| not null</font></div><div><font size="2"   >&nbsp;relchecks &nbsp; &nbsp; &nbsp;| smallint &nbsp;| not null</font></div><div><font size="2"   >&nbsp;relhasoids &nbsp; &nbsp; | boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relhaspkey &nbsp; &nbsp; | boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relhasrules &nbsp; &nbsp;| boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relhastriggers | boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relhassubclass | boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relispopulated | boolean &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relfrozenxid &nbsp; | xid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relminmxid &nbsp; &nbsp; | xid &nbsp; &nbsp; &nbsp; | not null</font></div><div><font size="2"   >&nbsp;relacl &nbsp; &nbsp; &nbsp; &nbsp; | aclitem[] |&nbsp;</font></div><div><font size="2"   >&nbsp;reloptions &nbsp; &nbsp; | text[] &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >Indexes:</font></div><div><font size="2"   >&nbsp; &nbsp; "pg_class_oid_index" UNIQUE, btree (oid)</font></div><div><font size="2"   >&nbsp; &nbsp; "pg_class_relname_nsp_index" UNIQUE, btree (relname, relnamespace)</font></div><p></p></pre></div><div>详见 :&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/catalog-pg-class.html"   >http://www.postgresql.org/docs/9.3/static/catalog-pg-class.html</a></div><div><br></div><div>应用场景举例 :&nbsp;</div><div>创建字典表, 建立ID和字符串的一一对应关系.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table dict (id serial4 primary key, info text unique);</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>创建测试表, 使用字典id代替字符串. 如果test表会很大的话, 可以减少存储.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table test (dict_id int, crt_time timestamp default clock_timestamp());</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>创建字符串转换成字典id的函数, 不存在对应关系的话自动创建一个id.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=#&nbsp;</font></div><div><font size="2"   >create or replace function text_to_dict(text) returns int as $$</font></div><div><font size="2"   >declare&nbsp;</font></div><div><font size="2"   >&nbsp; res int;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; select id into res from dict where info=$1;</font></div><div><font size="2"   >&nbsp; if found then</font></div><div><font size="2"   >&nbsp; &nbsp; return res;</font></div><div><font size="2"   >&nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; insert into dict(info) values($1) returning id into res;</font></div><div><font size="2"   >&nbsp; &nbsp; return res;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; return null;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql strict;</font></div><p></p></pre></div><div>但是需要注意, 规避恶意攻击, 造成字典表膨胀.</div><div>创建字典ID 转字符串的函数.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create or replace function dict_to_text(int) returns text as $$</font></div><div><font size="2"   >declare&nbsp;</font></div><div><font size="2"   >&nbsp; res text;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; select info into res from dict where id=$1;</font></div><div><font size="2"   >&nbsp; return res;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql strict;</font></div><p></p></pre></div><div><br></div><div>使用字符串, 插入test表.&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# insert into test (dict_id) values (text_to_dict('abc'));</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test (dict_id) values (text_to_dict('abc'));</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# insert into test (dict_id) values (text_to_dict('abc'));</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# select * from test ;</font></div><div><font size="2"   >&nbsp;dict_id | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >---------+----------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;1 | 2013-07-21 08:30:17.259049</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;1 | 2013-07-21 08:30:18.033941</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;1 | 2013-07-21 08:30:19.848933</font></div><div><font size="2"   >(3 rows)</font></div><div><font size="2"   >digoal=# insert into test (dict_id) values (text_to_dict('abcd'));</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >digoal=# select * from test;</font></div><div><font size="2"   >&nbsp;dict_id | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >---------+----------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;1 | 2013-07-21 08:30:17.259049</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;1 | 2013-07-21 08:30:18.033941</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;1 | 2013-07-21 08:30:19.848933</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;2 | 2013-07-21 08:30:45.972354</font></div><div><font size="2"   >(4 rows)</font></div><p></p></pre></div><div>text_to_dict将自动生成字典中不存在的字符串映射.</div><div><br></div><div>使用text_to_dict自动转换字符串和字典的映射关系, 如果是全新字典将带来巨大的性能问题.</div><div>使用转换函数插入的性能如下:</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# insert into test (dict_id) select text_to_dict(md5(random()::text)) from generate_series(1,100000);</font></div><div><font size="2"   >INSERT 0 100000</font></div><div><font size="2"   >Time: 4745.590 ms</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >直接使用ID插入的性能如下:</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# insert into test (dict_id) select generate_series(1,100000);</font></div><div><font size="2"   >INSERT 0 100000</font></div><div><font size="2"   >Time: 173.297 ms</font></div><div><font size="2"   >digoal=# select 4745/173.0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; ?column? &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------</font></div><div><font size="2"   >&nbsp;27.4277456647398844</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >如果插入的都是全新字符串的话性能相差了几十倍.</span></div><div><span style="line-height: 22px;"   >如果是固定字符串插入. 相差也非常大.</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from dict limit 1;</font></div><div><font size="2"   >&nbsp; &nbsp;id &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >--------+----------------------------------</font></div><div><font size="2"   >&nbsp;100007 | 269b2a3ceece7b5eccca4efbebe54f6b</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 0.443 ms</font></div><div><font size="2"   >digoal=# &nbsp;insert into test (dict_id) select text_to_dict('269b2a3ceece7b5eccca4efbebe54f6b') from generate_series(1,100000);</font></div><div><font size="2"   >INSERT 0 100000</font></div><div><font size="2"   >Time: 2075.123 ms</font></div><p></p></pre></div><div>将函数改成immutable, 固定输入在整个SQL中先执行后以常量替代, 那么以下<span style="line-height: 22px;"   >text_to_dict('269b2a3ceece7b5eccca4efbebe54f6b')</span><span style="line-height: 22px;"   >只执行一次.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# alter function text_to_dict (text) immutable;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><div><font size="2"   >Time: 0.245 ms</font></div><div><font size="2"   >digoal=# &nbsp;insert into test (dict_id) select text_to_dict('269b2a3ceece7b5eccca4efbebe54f6b') from generate_series(1,100000);</font></div><div><font size="2"   >INSERT 0 100000</font></div><div><font size="2"   >Time: 181.132 ms</font></div><p></p></pre></div></div><div>这个时间和直接输入ID 是接近的, 但是就无法适用在绑定变量中了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# &nbsp;insert into test (dict_id) select text_to_dict(md5(random()::text)) from generate_series(1,100000);</font></div><div><font size="2"   >ERROR: &nbsp;0A000: INSERT is not allowed in a non-volatile function</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "insert into dict(info) values($1) returning id"</font></div><div><font size="2"   >PL/pgSQL function text_to_dict(text) line 8 at SQL statement</font></div><div><font size="2"   >LOCATION: &nbsp;_SPI_execute_plan, spi.c:2062</font></div><div><font size="2"   >Time: 15.496 ms</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >查询性能如何呢?</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select count(*) from test ;</font></div><div><font size="2"   >&nbsp;count &nbsp;</font></div><div><font size="2"   >--------</font></div><div><font size="2"   >&nbsp;200005</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 18.933 ms</font></div><div><font size="2"   >digoal=# select count(dict_to_text(dict_id)) from test ;</font></div><div><font size="2"   >&nbsp;count &nbsp;</font></div><div><font size="2"   >--------</font></div><div><font size="2"   >&nbsp;200005</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 2890.798 ms</font></div><div><font size="2"   >digoal=# select 2890/18.0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;?column? &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;160.5555555555555556</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>如果都是差异化数据, 相差几百倍.</div><div><br></div><div>存储空间相差多少呢? 下面来计算一下. pg_column_size计算的大小未包含column_head_size. 这个后面会讲到.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select pg_column_size(info),pg_column_size(id),id,info from dict limit 10;;</font></div><div><font size="2"   >&nbsp;pg_column_size | pg_column_size | id | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------+----------------+----+----------------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 | &nbsp;1 | abc</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 | &nbsp;2 | abcd</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 | &nbsp;3 | abcdef</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;33 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 | &nbsp;4 | dbab1a0f8c3e8395d53d4b1439941a76</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;33 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 | &nbsp;5 | 09b07fa8e5d072e08c942dc3be5c740e</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;33 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 | &nbsp;6 | 3effe76ee7f025dafdb7719bc32544c5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;33 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 | &nbsp;7 | 507455aea4fd0026a56cd9f3bdb209ec</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;33 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 | &nbsp;8 | 6f233fb8e47a837fc51e7b3d79cfcc8a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;33 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 | &nbsp;9 | 5e494c39988a4562b30fdfe7503469e1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;33 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 | 10 | 389ce74e776aeaa6935c4c3a6e49c773</font></div><div><font size="2"   >(10 rows)</font></div><p></p></pre></div><div>创建pageinspect扩展, 计算精确的列占用大小.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create extension pageinspect;</font></div><div><font size="2"   >CREATE EXTENSION</font></div><div><font size="2"   >digoal=# create table t1(id int);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >Time: 1.050 ms</font></div><div><font size="2"   >digoal=# create table t2(id text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >Time: 3.103 ms</font></div><div><font size="2"   >digoal=# insert into t2 values ('dbab1a0f8c3e8395d53d4b1439941a76'),('dbab1a0f8c3e8395d53d4b1439941a76');</font></div><div><font size="2"   >INSERT 0 2</font></div><div><font size="2"   >Time: 0.414 ms</font></div><div><font size="2"   >digoal=# insert into t1 values (1),(1);</font></div><div><font size="2"   >INSERT 0 2</font></div><div><font size="2"   >Time: 0.300 ms</font></div><div><font size="2"   >digoal=# select * from heap_page_items(get_raw_page('t1',0));</font></div><div><font size="2"   >&nbsp;lp | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 | t_ctid | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"   >----+--------+----------+--------+--------+--------+----------+--------+-------------+------------+--------+--------+-------</font></div><div><font size="2"   >&nbsp; 1 | &nbsp; 8160 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 28 | &nbsp; 1758 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (0,1) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 2048 | &nbsp; &nbsp; 24 | NULL &nbsp; | &nbsp;NULL</font></div><div><font size="2"   >&nbsp; 2 | &nbsp; 8128 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 28 | &nbsp; 1758 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (0,2) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 2048 | &nbsp; &nbsp; 24 | NULL &nbsp; | &nbsp;NULL</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   >Time: 0.259 ms</font></div><p></p></pre></div><div>int占用列占用4字节的存储+1字节的column_head_size.</div><div>tuple_head=27字节.</div><div>所以一条记录的总长为32字节.</div><div><pre class="prettyprint"   ><div><font size="2"   >digoal=# select * from heap_page_items(get_raw_page('t2',0));</font></div><div><font size="2"   >&nbsp;lp | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 | t_ctid | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid&nbsp;</font></div><div><font size="2"   >----+--------+----------+--------+--------+--------+----------+--------+-------------+------------+--------+--------+-------</font></div><div><font size="2"   >&nbsp; 1 | &nbsp; 8128 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 57 | &nbsp; 1757 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (0,1) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 2050 | &nbsp; &nbsp; 24 | NULL &nbsp; | &nbsp;NULL</font></div><div><font size="2"   >&nbsp; 2 | &nbsp; 8064 | &nbsp; &nbsp; &nbsp; &nbsp;1 | &nbsp; &nbsp; 57 | &nbsp; 1757 | &nbsp; &nbsp; &nbsp;0 | &nbsp; &nbsp; &nbsp; &nbsp;0 | (0,2) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 | &nbsp; &nbsp; &nbsp; 2050 | &nbsp; &nbsp; 24 | NULL &nbsp; | &nbsp;NULL</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   >Time: 0.173 ms</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >'dbab1a0f8c3e8395d53d4b1439941a76'占用32字节的数据存储+1字节的'\0'结束符+4字节的column_head_size</span></div><div>tuple_head=27字节.</div><div>所以一条记录的总长为64字节.</div><div>使用变长字符串, 仅列头就要4字节, 再加上实际的字符串空间占用, 相比int型空间占用几倍以上是在所难免的.&nbsp;</div><div>而使用字典要考虑的是字典数据的转换带来的额外CPU开销, 是不是值得这么去做.</div><div>当然转换的工作不一定要放在数据库中操作, 前端还可以搞个key-value存储, 先去key-value取, 取不到再到数据库中取. 减轻数据库的压力.</div><div><br></div><div>[其他]</div><div>如果要做到和系统表的oid那样可以在字符串和oid之间相互透明的转换. 或者说你如果想要一种类似oid功能的数据类型.</div><div>那么可以自定义一个这样的类型, 同时也要自定义输入输出函数, 以及相关的操作符函数等等来完善这个类型的功能.</div><div><div>CREATE TYPE name (</div><div>&nbsp; &nbsp; INPUT = input_function,</div><div>&nbsp; &nbsp; OUTPUT = output_function</div><div>&nbsp; &nbsp; [ , RECEIVE = receive_function ]</div><div>&nbsp; &nbsp; [ , SEND = send_function ]</div><div>&nbsp; &nbsp; [ , TYPMOD_IN = type_modifier_input_function ]</div><div>&nbsp; &nbsp; [ , TYPMOD_OUT = type_modifier_output_function ]</div><div>&nbsp; &nbsp; [ , ANALYZE = analyze_function ]</div><div>&nbsp; &nbsp; [ , INTERNALLENGTH = { internallength | VARIABLE } ]</div><div>&nbsp; &nbsp; [ , PASSEDBYVALUE ]</div><div>&nbsp; &nbsp; [ , ALIGNMENT = alignment ]</div><div>&nbsp; &nbsp; [ , STORAGE = storage ]</div><div>&nbsp; &nbsp; [ , LIKE = like_type ]</div><div>&nbsp; &nbsp; [ , CATEGORY = category ]</div><div>&nbsp; &nbsp; [ , PREFERRED = preferred ]</div><div>&nbsp; &nbsp; [ , DEFAULT = default ]</div><div>&nbsp; &nbsp; [ , ELEMENT = element ]</div><div>&nbsp; &nbsp; [ , DELIMITER = delimiter ]</div><div>&nbsp; &nbsp; [ , COLLATABLE = collatable ]</div><div>)</div></div><div>具体的扩展实现可以参考citext, hstore等扩展包的做法.</div><div><a rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/citext.html"   >http://www.postgresql.org/docs/9.3/static/citext.html</a></div><div><a rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/hstore.html"   >http://www.postgresql.org/docs/9.3/static/hstore.html</a></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201351743331312/"   >http://blog.163.com/digoal@126/blog/static/163877040201351743331312/</a></div><div>2.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/storage-page-layout.html"   >http://www.postgresql.org/docs/9.2/static/storage-page-layout.html</a></div><div>3. src/include/access/htup.h</div><div>4.&nbsp;src/backend/access/common/heaptuple.c</div><div><div>变长字段(可选toast存储), 字段头为4字节.</div><div>如果是定长字段, 那么小于126字节时, 只需要1字节的头.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp;* Before Postgres 8.3 varlenas always had a 4-byte length header, and</font></div><div><font size="2"   >&nbsp;* therefore always needed 4-byte alignment (at least). &nbsp;This wasted space</font></div><div><font size="2"   >&nbsp;* for short varlenas, for example CHAR(1) took 5 bytes and could need up to</font></div><div><font size="2"   >&nbsp;* 3 additional padding bytes for alignment.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Now, a short varlena (up to 126 data bytes) is reduced to a 1-byte header</font></div><div><font size="2"   >&nbsp;* and we don't align it. &nbsp;To hide this from datatype-specific functions that</font></div><div><font size="2"   >&nbsp;* don't want to deal with it, such a datum is considered "toasted" and will</font></div><div><font size="2"   >&nbsp;* be expanded back to the normal 4-byte-header format by pg_detoast_datum.</font></div><div><font size="2"   >&nbsp;* (In performance-critical code paths we can use pg_detoast_datum_packed</font></div><div><font size="2"   >&nbsp;* and the appropriate access macros to avoid that overhead.) &nbsp;Note that this</font></div><div><font size="2"   >&nbsp;* conversion is performed directly in heap_form_tuple, without invoking</font></div><div><font size="2"   >&nbsp;* tuptoaster.c.</font></div><p></p></pre></div></div><div>5.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/catalog-pg-class.html"   >http://www.postgresql.org/docs/9.3/static/catalog-pg-class.html</a></div><wbr></div>
	</div>
</div>
</body>
</html>