<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.4 Patch, refresh materialized view concurrently (refresh_by_match_merge)</h2>
	<h5 id="">2013-07-23 10:46:54&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201362383382/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 9.4新增了物化视图增量更新的功能, 增量更新的原理是merge, 通过比对基表和物化视图的数据, 合并变更或新增, 删除的数据.</div><div>(注意没有用到触发器和xlog进行增量更新. 仅仅是数据比对, merge.)</div><div>对于数据量庞大的物化视图, 合并过程可能比全刷新还要慢, 但是增量更新不会影响物化视图的并行查询, 这一点是值得推荐的.&nbsp;</div><div>使用限制, 物化视图必须要有一个唯一约束的索引, 且这个索引必须是基于原始列的, 换句话说不能是表达式索引. 另外这个索引必须是full index, 环境话说不能是partial index. (即不能在索引中包含where 子句)</div><div>使用举例 :&nbsp;</div><div>创建一个测试表, 插入100万条数据.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create unlogged table test1(id int, info text,crt_time timestamp);</font></div><div><font size="2"   >digoal=# insert into test1 select generate_series(1,1000000), md5(random()::text), clock_timestamp();</font></div><p></p></pre></div><div>创建物化视图</div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create materialized view mv_test1 as select * from test1;</font></div><div></div><p></p></pre><div><span style="line-height: 22px;"   >给物化视图加唯一索引.</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create unique index idx_mv_test1 on mv_test1 (id);</font></div><div></div><p></p></pre><div><span style="line-height: 22px;"   >并行刷新</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# refresh materialized view CONCURRENTLY mv_test1 ;</font></div><div></div><p></p></pre><div><span style="line-height: 22px;"   >在刷新物化视图的同时查询这个物化视图, 不需要等待锁.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from mv_test1 where id=10000;</font></div><div><font size="2"   >&nbsp; id &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------+----------------------------------+---------------------------</font></div><div><font size="2"   >&nbsp;10000 | ee1b1541b3fd709f76372d80c385dc44 | 2013-07-23 10:12:05.09956</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>增量刷新耗时24.5秒.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><div><font size="2"   >Time: 24506.264 ms</font></div><p></p></pre></div></div><div>全量刷新</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# refresh materialized view mv_test1 ;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><div><font size="2"   >Time: 2635.838 ms</font></div><p></p></pre></div><div>全量刷新的时候, 查询这个物化视图需要等待.</div><div><pre class="prettyprint"   ><p><font size="2"   >digoal=# select * from mv_test1 where id=1;</font></p></pre></div><div>....等待刷新结束后返回结果.</div><div><br></div><div>另外需要注意的是, 如果基表没有唯一约束, 并且针对物化视图列出现了重复值的话, 刷新将失败.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# insert into test1 values (1,'test',now());</font></div><div><font size="2"   >INSERT 0 1</font></div><p></p></pre></div><div>并行刷新</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# refresh materialized view CONCURRENTLY mv_test1 ;</font></div><div><font size="2"   >ERROR: &nbsp;duplicate key value violates unique constraint "idx_mv_test1"</font></div><div><font size="2"   >DETAIL: &nbsp;Key (id)=(1) already exists.</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "INSERT INTO public.mv_test1 SELECT (y).* FROM pg_temp_2.pg_temp_16526_2 WHERE tid IS NULL"</font></div><p></p></pre></div></div><div><br></div><div>如果物化视图是一小部分数据的话,&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create materialized view mv_test2 as select * from test1 where id=10;</font></div><div><font size="2"   >SELECT 1</font></div><div><font size="2"   >digoal=# create unique index idx_mv_test2 on mv_test2 (id);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >digoal=# \timing</font></div><div><font size="2"   >Timing is on.</font></div><div><font size="2"   >digoal=# refresh materialized view CONCURRENTLY mv_test2;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><div><font size="2"   >Time: 117.597 ms</font></div></div><div><div><font size="2"   >digoal=# refresh materialized view mv_test2;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><div><font size="2"   >Time: 137.583 ms</font></div></div><p></p></pre></div><div><br></div><div>给基表的物化视图唯一索引所在列新增索引 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# \d test1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Unlogged table "public.test1"</font></div><div><font size="2"   >&nbsp; Column &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Modifiers&nbsp;</font></div><div><font size="2"   >----------+-----------------------------+-----------</font></div><div><font size="2"   >&nbsp;id &nbsp; &nbsp; &nbsp; | integer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >&nbsp;info &nbsp; &nbsp; | text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;crt_time | timestamp without time zone |&nbsp;</font></div></div><div><div><font size="2"   >digoal=# create index idx_test1 on test1(id);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >Time: 1211.793 ms</font></div><div><font size="2"   >digoal=# refresh materialized view mv_test2;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><div><font size="2"   >Time: 41.012 ms</font></div><div><font size="2"   >digoal=# refresh materialized view CONCURRENTLY mv_test2;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><div><font size="2"   >Time: 4.325 ms</font></div></div><p></p></pre></div><div>可以看到新增基表的索引后增量全量刷新的速度都快了好多.</div><div><br></div><div>[小结]</div><div>1. 如果要使用增量刷新, 那么物化视图必须有唯一索引, 并且这个索引必须是原始列索引, 同时是full index.</div><div>2. 在物化视图的数据量小时, 增量刷新可以体现出巨大的速度上的优势, 以及不和查询语句冲突的优势.</div><div>3. 如果要加速增量刷新的速度, 物化视图唯一索引列对应的<span style="line-height: 22px;"   >在基表中的列也要加索引, 加快查询速度.</span></div><div><span style="line-height: 22px;"   >4. 如果出现因为违反约束无法刷新的情况, 那么请检查基表是否出现了重复数据.</span></div><div><span style="line-height: 22px;"   >5. 并行更新物化视图不会改变物化视图的filenode(因为在现有基础上发生的dml), 而全量更新会产生新的filenode(类似vacuum full, cluster等).</span></div><div>&nbsp; &nbsp; 所以增量刷新的物化视图需要vacuum操作. 注意, 如果增量刷新带来了大量的数据变更, 垃圾数据会很多, 建议使用pg_reorg回收垃圾空间.</div><div>和Oracle不一样, PostgreSQL增量刷新并不需要基表记录数据的变更轨迹, 增量刷新时完全是物化视图的SQL和当前物化视图结果集进行差异比较, 合并差异的过程.</div><div><br></div><div>查看当前filenode.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select pg_relation_filepath('mv_test2');</font></div><div><font size="2"   >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;base/16384/16751</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>全量刷新</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# refresh materialized view mv_test2;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><p></p></pre></div><div>filenode发生变更</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select pg_relation_filepath('mv_test2');</font></div><div><font size="2"   >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;base/16384/16770</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div>增量刷新</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# refresh materialized view CONCURRENTLY mv_test2;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><p></p></pre></div><div>filenode未变更</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select pg_relation_filepath('mv_test2');</font></div><div><font size="2"   >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;base/16384/16770</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div>更新基表数据</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# update test1 set info='new' where id=10;</font></div><div><font size="2"   >UPDATE 1</font></div><p></p></pre></div><div>增量刷新</div></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# refresh materialized view CONCURRENTLY mv_test2;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><p></p></pre></div><div>查看物化视图的ctid, 使用了0号块的2号item.&nbsp;<span style="line-height: 22px;"   >因为增量刷新是数据合并, 而非filenode替代.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select ctid,* from mv_test2;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | info | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------+----+------+----------------------------</font></div><div><font size="2"   >&nbsp;(0,2) | 10 | new &nbsp;| 2013-07-23 10:12:05.056385</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>物化视图的filenode保持不变</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select pg_relation_filepath('mv_test2');</font></div><div><font size="2"   >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;base/16384/16770</font></div><p></p></pre></div><div>继续更新基表</div></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# update test1 set info='newnew' where id=10;</font></div><div><font size="2"   >UPDATE 1</font></div><p></p></pre></div><div>增量刷新</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# refresh materialized view CONCURRENTLY mv_test2;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><div><font size="2"   >digoal=# select pg_relation_filepath('mv_test2');</font></div><div><font size="2"   >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;base/16384/16770</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>物化视图的记录ctid又变了. 因为增量刷新是数据合并, 而非filenode替代.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select ctid,* from mv_test2;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | &nbsp;info &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------+----+--------+----------------------------</font></div><div><font size="2"   >&nbsp;(0,3) | 10 | newnew | 2013-07-23 10:12:05.056385</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>因此大量的更新后需要vacuum物化视图, 才能重复利用废弃的item.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# vacuum verbose mv_test2;</font></div><div><font size="2"   >INFO: &nbsp;vacuuming "public.mv_test2"</font></div><div><font size="2"   >INFO: &nbsp;scanned index "idx_mv_test2" to remove 2 row versions</font></div><div><font size="2"   >DETAIL: &nbsp;CPU 0.00s/0.00u sec elapsed 0.00 sec.</font></div><div><font size="2"   >INFO: &nbsp;"mv_test2": removed 2 row versions in 1 pages</font></div><div><font size="2"   >DETAIL: &nbsp;CPU 0.00s/0.00u sec elapsed 0.00 sec.</font></div><div><font size="2"   >INFO: &nbsp;index "idx_mv_test2" now contains 1 row versions in 2 pages</font></div><div><font size="2"   >DETAIL: &nbsp;2 index row versions were removed.</font></div><div><font size="2"   >0 index pages have been deleted, 0 are currently reusable.</font></div><div><font size="2"   >CPU 0.00s/0.00u sec elapsed 0.00 sec.</font></div><div><font size="2"   >INFO: &nbsp;"mv_test2": found 2 removable, 1 nonremovable row versions in 1 out of 1 pages</font></div><div><font size="2"   >DETAIL: &nbsp;0 dead row versions cannot be removed yet.</font></div><div><font size="2"   >There were 0 unused item pointers.</font></div><div><font size="2"   >0 pages are entirely empty.</font></div><div><font size="2"   >CPU 0.00s/0.00u sec elapsed 0.00 sec.</font></div><div><font size="2"   >INFO: &nbsp;vacuuming "pg_toast.pg_toast_16691"</font></div><div><font size="2"   >INFO: &nbsp;index "pg_toast_16691_index" now contains 0 row versions in 1 pages</font></div><div><font size="2"   >DETAIL: &nbsp;0 index row versions were removed.</font></div><div><font size="2"   >0 index pages have been deleted, 0 are currently reusable.</font></div><div><font size="2"   >CPU 0.00s/0.00u sec elapsed 0.00 sec.</font></div><div><font size="2"   >INFO: &nbsp;"pg_toast_16691": found 0 removable, 0 nonremovable row versions in 0 out of 0 pages</font></div><div><font size="2"   >DETAIL: &nbsp;0 dead row versions cannot be removed yet.</font></div><div><font size="2"   >There were 0 unused item pointers.</font></div><div><font size="2"   >0 pages are entirely empty.</font></div><div><font size="2"   >CPU 0.00s/0.00u sec elapsed 0.00 sec.</font></div><div><font size="2"   >VACUUM</font></div><p></p></pre></div><div>vacuum物化视图后, 回收了2行. 继续更新基表.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# update test1 set info='newnewnew' where id=10;</font></div><div><font size="2"   >UPDATE 1</font></div><p></p></pre></div><div>增量更新</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# refresh materialized view CONCURRENTLY mv_test2;</font></div><div><font size="2"   >REFRESH MATERIALIZED VIEW</font></div><p></p></pre></div><div>现在就用到废弃的0,1段空间了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select ctid,* from mv_test2;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | &nbsp; info &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------+----+-----------+----------------------------</font></div><div><font size="2"   >&nbsp;(0,1) | 10 | newnewnew | 2013-07-23 10:12:05.056385</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://www.postgresql.org/message-id/flat/1371225929.28496.YahooMailNeo@web162905.mail.bf1.yahoo.com#1371225929.28496.YahooMailNeo@web162905.mail.bf1.yahoo.com"   >http://www.postgresql.org/message-id/flat/1371225929.28496.YahooMailNeo@web162905.mail.bf1.yahoo.com#1371225929.28496.YahooMailNeo@web162905.mail.bf1.yahoo.com</a></div><div>2.&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >+ /*</font></div><div><font size="2"   >+ &nbsp;* refresh_by_match_merge</font></div><div><font size="2"   >+ &nbsp;*</font></div><div><font size="2"   >+ &nbsp;* Refresh a materialized view with transactional semantics, while allowing</font></div><div><font size="2"   >+ &nbsp;* concurrent reads.</font></div><div><font size="2"   >+ &nbsp;*</font></div><div><font size="2"   >+ &nbsp;* This is called after a new version of the data has been created in a</font></div><div><font size="2"   >+ &nbsp;* temporary table. &nbsp;It performs a full outer join against the old version of</font></div><div><font size="2"   >+ &nbsp;* the data, producing "diff" results. &nbsp; &nbsp; &nbsp; &nbsp;This join cannot work if there are any</font></div><div><font size="2"   >+ &nbsp;* duplicated rows in either the old or new versions, in the sense that every</font></div><div><font size="2"   >+ &nbsp;* column would compare as equal between the two rows. &nbsp; &nbsp; &nbsp; &nbsp;It does work correctly</font></div><div><font size="2"   >+ &nbsp;* in the face of rows which have at least one NULL value, with all non-NULL</font></div><div><font size="2"   >+ &nbsp;* columns equal. &nbsp;The behavior of NULLs on equality tests and on UNIQUE</font></div><div><font size="2"   >+ &nbsp;* indexes turns out to be quite convenient here; the tests we need to make</font></div><div><font size="2"   >+ &nbsp;* are consistent with default behavior. &nbsp;If there is at least one UNIQUE</font></div><div><font size="2"   >+ &nbsp;* index on the materialized view, we have exactly the guarantee we need. &nbsp;By</font></div><div><font size="2"   >+ &nbsp;* joining based on equality on all columns which are part of any unique</font></div><div><font size="2"   >+ &nbsp;* index, we identify the rows on which we can use UPDATE without any problem.</font></div><div><font size="2"   >+ &nbsp;* If any column is NULL in either the old or new version of a row (or both),</font></div><div><font size="2"   >+ &nbsp;* we must use DELETE and INSERT, since there could be multiple rows which are</font></div><div><font size="2"   >+ &nbsp;* NOT DISTINCT FROM each other, and we could otherwise end up with the wrong</font></div><div><font size="2"   >+ &nbsp;* number of occurrences in the updated relation. &nbsp;The temporary table used to</font></div><div><font size="2"   >+ &nbsp;* hold the diff results contains just the TID of the old record (if matched)</font></div><div><font size="2"   >+ &nbsp;* and the ROW from the new table as a single column of complex record type</font></div><div><font size="2"   >+ &nbsp;* (if matched).</font></div><div><font size="2"   >+ &nbsp;*</font></div><div><font size="2"   >+ &nbsp;* Once we have the diff table, we perform set-based DELETE, UPDATE, and</font></div><div><font size="2"   >+ &nbsp;* INSERT operations against the materialized view, and discard both temporary</font></div><div><font size="2"   >+ &nbsp;* tables.</font></div><div><font size="2"   >+ &nbsp;*</font></div><div><font size="2"   >+ &nbsp;* Everything from the generation of the new data to applying the differences</font></div><div><font size="2"   >+ &nbsp;* takes place under cover of an ExclusiveLock, since it seems as though we</font></div><div><font size="2"   >+ &nbsp;* would want to prohibit not only concurrent REFRESH operations, but also</font></div><div><font size="2"   >+ &nbsp;* incremental maintenance. &nbsp;It also doesn't seem reasonable or safe to allow</font></div><div><font size="2"   >+ &nbsp;* SELECT FOR UPDATE or SELECT FOR SHARE on rows being updated or deleted by</font></div><div><font size="2"   >+ &nbsp;* this command.</font></div><div><font size="2"   >+ &nbsp;*/</font></div></div><div><div><font size="2"   >+ static void</font></div><div><font size="2"   >+ refresh_by_match_merge(Oid matviewOid, Oid tempOid)</font></div><div><font size="2"   >+ {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; StringInfoData querybuf;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; Relation &nbsp; &nbsp; &nbsp; &nbsp;matviewRel;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; Relation &nbsp; &nbsp; &nbsp; &nbsp;tempRel;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *matviewname;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *tempname;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *diffname;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; TupleDesc &nbsp; &nbsp; &nbsp; tupdesc;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;foundUniqueIndex;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; List &nbsp; &nbsp; &nbsp; *indexoidlist;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; ListCell &nbsp; *indexoidscan;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; int16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relnatts;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; *usedForQual;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_userid;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_sec_context;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; initStringInfo(&amp;querybuf);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; matviewRel = heap_open(matviewOid, NoLock);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; matviewname = quote_qualified_identifier(get_namespace_name(RelationGetNamespace(matviewRel)),</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(matviewRel));</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; tempRel = heap_open(tempOid, NoLock);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; tempname = quote_qualified_identifier(get_namespace_name(RelationGetNamespace(tempRel)),</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(tempRel));</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; diffname = make_temptable_name_n(tempname, 2);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; relnatts = matviewRel-&gt;rd_rel-&gt;relnatts;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; usedForQual = (bool *) palloc0(sizeof(bool) * relnatts);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* Open SPI context. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (SPI_connect() != SPI_OK_CONNECT)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "SPI_connect failed");</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* Analyze the temp table with the new contents. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, "ANALYZE %s", tempname);</font></div></div><div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (SPI_exec(querybuf.data, 0) != SPI_OK_UTILITY)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "SPI_exec failed: %s", querybuf.data);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* We need to ensure that there are not duplicate rows without NULLs in</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* the new data set before we can count on the "diff" results. &nbsp;Check for</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* that in a way that allows showing the first duplicated row found. &nbsp;Even</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* after we pass this test, a unique index on the materialized view may</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* find a duplicate key problem.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;querybuf);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"SELECT x FROM %s x WHERE x IS NOT NULL AND EXISTS "</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"(SELECT * FROM %s y WHERE y IS NOT NULL "</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"AND (y.*) = (x.*) AND y.ctid &lt;&gt; x.ctid) LIMIT 1",</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tempname, tempname);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (SPI_execute(querybuf.data, false, 1) != SPI_OK_SELECT)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "SPI_exec failed: %s", querybuf.data);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (SPI_processed &gt; 0)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_CARDINALITY_VIOLATION),</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("new data for \"%s\" contains duplicate rows without any NULL columns",</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(matviewRel)),</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errdetail("Row: %s",</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SPI_getvalue(SPI_tuptable-&gt;vals[0], SPI_tuptable-&gt;tupdesc, 1))));</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* Start building the query for creating the diff table. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;querybuf);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"CREATE TEMP TABLE %s AS "</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"SELECT x.ctid AS tid, y FROM %s x FULL JOIN %s y ON (",</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;diffname, matviewname, tempname);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* Get the list of index OIDs for the table from the relcache, and look up</font></div></div><div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* each one in the pg_index syscache. &nbsp;We will test for equality on all</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* columns present in all unique indexes which only reference columns and</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* include all rows.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; tupdesc = matviewRel-&gt;rd_att;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; foundUniqueIndex = false;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; indexoidlist = RelationGetIndexList(matviewRel);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; foreach(indexoidscan, indexoidlist)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid = lfirst_oid(indexoidscan);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple &nbsp; &nbsp; &nbsp; indexTuple;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index index;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexTuple = SearchSysCache1(INDEXRELID, ObjectIdGetDatum(indexoid));</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!HeapTupleIsValid(indexTuple)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* should not happen */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "cache lookup failed for index %u", indexoid);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = (Form_pg_index) GETSTRUCT(indexTuple);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* We're only interested if it is unique and valid. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (index-&gt;indisunique &amp;&amp; IndexIsValid(index))</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numatts = index-&gt;indnatts;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;expr = false;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation &nbsp; &nbsp; &nbsp; &nbsp;indexRel;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Skip any index on an expression. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; numatts; i++)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (index-&gt;indkey.values[i] == 0)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = true;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (expr)</font></div></div><div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseSysCache(indexTuple);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Skip partial indexes. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRel = index_open(index-&gt;indexrelid, RowExclusiveLock);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (indexRel-&gt;rd_indpred != NIL)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_close(indexRel, NoLock);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseSysCache(indexTuple);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Hold the locks, since we're about to run DML which needs them. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_close(indexRel, NoLock);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Add quals for all columns from this index. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; numatts; i++)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = index-&gt;indkey.values[i];</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const char *colname;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Only include the column once regardless of how many times</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* it shows up in how many indexes.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* This is also useful later to omit columns which can not</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* have changed from the SET clause of the UPDATE statement.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (usedForQual[attnum - 1])</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usedForQual[attnum - 1] = true;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Actually add the qual, ANDed with any others.</font></div></div><div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (foundUniqueIndex)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;querybuf, " AND ");</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname = quote_identifier(NameStr((tupdesc-&gt;attrs[attnum - 1])-&gt;attname));</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, "y.%s ", colname);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = attnumTypeId(matviewRel, attnum);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op = lookup_type_cache(type, TYPECACHE_EQ_OPR)-&gt;eq_opr;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mv_GenerateOper(&amp;querybuf, op);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, " x.%s", colname);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foundUniqueIndex = true;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseSysCache(indexTuple);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; list_free(indexoidlist);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (!foundUniqueIndex)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("cannot refresh materialized view \"%s\" concurrently",</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matviewname),</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("Create a UNIQUE index with no WHERE clause on one or more columns of the materialized view.")));</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;querybuf,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;" AND y = x) WHERE (y.*) IS DISTINCT FROM (x.*)"</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;" ORDER BY tid");</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* Create the temporary "diff" table. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (SPI_exec(querybuf.data, 0) != SPI_OK_UTILITY)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "SPI_exec failed: %s", querybuf.data);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* We have no further use for data from the "full-data" temp table, but we</font></div></div><div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* must keep it around because its type is reference from the diff table.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* Analyze the diff table. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;querybuf);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, "ANALYZE %s", diffname);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (SPI_exec(querybuf.data, 0) != SPI_OK_UTILITY)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "SPI_exec failed: %s", querybuf.data);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; OpenMatViewIncrementalMaintenance();</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* Switch to the owner's userid, so that any functions are run as that</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* user. &nbsp;Also lock down security-restricted operations and arrange to</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;* make GUC variable changes local to this command.</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; GetUserIdAndSecContext(&amp;save_userid, &amp;save_sec_context);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; SetUserIdAndSecContext(matviewRel-&gt;rd_rel-&gt;relowner,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;save_sec_context | SECURITY_RESTRICTED_OPERATION);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; save_nestlevel = NewGUCNestLevel();</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* Deletes must come before inserts; do them first. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;querybuf);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"DELETE FROM %s WHERE ctid IN "</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"(SELECT d.tid FROM %s d "</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"WHERE d.tid IS NOT NULL "</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"AND (d.y) IS NOT DISTINCT FROM NULL)",</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;matviewname, diffname);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (SPI_exec(querybuf.data, 0) != SPI_OK_DELETE)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "SPI_exec failed: %s", querybuf.data);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* Updates before inserts gives a better chance at HOT updates. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;querybuf);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, "UPDATE %s x SET ", matviewname);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; {</font></div></div><div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;targetColFound = false;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; tupdesc-&gt;natts; i++)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const char *colname;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tupdesc-&gt;attrs[i]-&gt;attisdropped)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (usedForQual[i])</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (targetColFound)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;querybuf, ", ");</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetColFound = true;</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname = quote_identifier(NameStr((tupdesc-&gt;attrs[i])-&gt;attname));</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, "%s = (d.y).%s", colname, colname);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (targetColFound)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;" FROM %s d "</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"WHERE d.tid IS NOT NULL AND x.ctid = d.tid",</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;diffname);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (SPI_exec(querybuf.data, 0) != SPI_OK_UPDATE)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "SPI_exec failed: %s", querybuf.data);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* Inserts go last. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;querybuf);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf,</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"INSERT INTO %s SELECT (y).* FROM %s WHERE tid IS NULL",</font></div></div><div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;matviewname, diffname);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (SPI_exec(querybuf.data, 0) != SPI_OK_INSERT)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "SPI_exec failed: %s", querybuf.data);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* Roll back any GUC changes */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; AtEOXact_GUC(false, save_nestlevel);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* Restore userid and security context */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; SetUserIdAndSecContext(save_userid, save_sec_context);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* We're done maintaining the materialized view. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; CloseMatViewIncrementalMaintenance();</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; heap_close(tempRel, NoLock);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; heap_close(matviewRel, NoLock);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* Clean up temp tables. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;querybuf);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;querybuf, "DROP TABLE %s, %s", diffname, tempname);</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (SPI_exec(querybuf.data, 0) != SPI_OK_UTILITY)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "SPI_exec failed: %s", querybuf.data);</font></div><div><font size="2"   >+&nbsp;</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; /* Close SPI context. */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; if (SPI_finish() != SPI_OK_FINISH)</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "SPI_finish failed");</font></div><div><font size="2"   >+ }</font></div></div><p></p></pre></div><div><font size="2"   ><br></font></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL 9.4 Patch, refresh materialized view concurrently (refresh_by_match_merge) - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>