<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL transformArraySubscripts BUG? or because PostgreSQL's array don't limit dimensional</h2>
	<h5 id="">2013-07-16 17:42:46&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020136165196682/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 数组类型在plpgsql中的应用例子, 遇到一个比较怪异的错误. 来自<span style="line-height: 22px;"   >LOCATION: &nbsp;transformArrayType, parse_node.c:241的调用.</span></div><div><span style="line-height: 22px;"   >但是这样并不能看不出来有什么问题, 赋值类型和源数据类型一致.</span></div><div>原因后面解释. 你可以说这是PostgreSQL的 BUG, 也可以说它对array设计的功能缺陷. 未来也许会弥补.</div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >测试函数1 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><font size="2"   >digoal=# do language plpgsql $$</font></span></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; res text[];</font></div><div><font size="2"   >&nbsp; x text;</font></div><div><font size="2"   >&nbsp; i int := 0;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; foreach x in array array['1','2','3'] loop</font></div><div><font size="2"   >&nbsp; &nbsp; select x into res[i]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; i := i+1;</font></div><div><font size="2"   >&nbsp; end loop;</font></div><div><font size="2"   >&nbsp; raise notice '%', res;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$;</font></div><div><font size="2"   >ERROR: &nbsp;42804: cannot subscript type text because it is not an array</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "select x &nbsp; &nbsp; &nbsp; &nbsp; [i]"</font></div><div><font size="2"   >PL/pgSQL function inline_code_block line 8 at SQL statement</font></div><div><font size="2"   >LOCATION: &nbsp;transformArrayType, parse_node.c:241</font></div><p></p></pre></div><div>报错的SQL是<span style="line-height: 22px;"   >select x into res[i]; x是text 类型, res是text数组, 理论上text插入text数组中的一个元素没问题, 为什么为报错呢?</span></div><div><span style="line-height: 22px;"   >原因是PostgreSQL不限制数组维度, 所以res text[]定义的数组里面还可能存储text数组, 即多维数组.</span></div><div><span style="line-height: 22px;"   >但是这并不能阻止我们把text存进text[], 后面有解决办法 .</span></div><div><br></div><div><span style="line-height: 22px;"   >测试函数2 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# do language plpgsql $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; res text[];</font></div><div><font size="2"   >&nbsp; x varchar; -- 把x定义为varchar</font></div><div><font size="2"   >&nbsp; i int := 0;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; foreach x in array array['1','2','3'] loop</font></div><div><font size="2"   >&nbsp; &nbsp; select x into res[i];</font></div><div><font size="2"   >&nbsp; &nbsp; i := i+1;</font></div><div><font size="2"   >&nbsp; end loop;</font></div><div><font size="2"   >&nbsp; raise notice '%', res;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$;</font></div><div><font size="2"   >ERROR: &nbsp;42804: cannot subscript type character varying because it is not an array</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "select x &nbsp; &nbsp; &nbsp; &nbsp; [i]"</font></div><div><font size="2"   >PL/pgSQL function inline_code_block line 8 at SQL statement</font></div><div><font size="2"   >LOCATION: &nbsp;transformArrayType, parse_node.c:241</font></div><p></p></pre></div><div>第一个函数你可能没看明白, 这个函数把x改成varchar, 报错的信息变成</div><div><span style="line-height: 22px;"   >ERROR: &nbsp;42804: cannot subscript type character varying because it is not an array</span></div><div><span style="line-height: 22px;"   >这下看清楚了, 报错是说x是varchar类型, 不是数组类型, 所以无法存进数组中.</span></div><div>不得不说PostgreSQL可以改进一下这块.</div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >测试函数3 :&nbsp;</span></div><div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >digoal=# do language plpgsql $$</font></div><div style="line-height: 22px;"   ><font size="2"   >declare</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; res text[];</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; x text; &nbsp;&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; i int := 0;</font></div><div style="line-height: 22px;"   ><font size="2"   >begin &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; foreach x in array array['1','2','3'] loop</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; execute 'select $1' into res[i] using x;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; i := i+1;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; end loop;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; raise notice '%', res;</font></div><div style="line-height: 22px;"   ><font size="2"   >end;</font></div><div style="line-height: 22px;"   ><font size="2"   >$$;</font></div><div style="line-height: 22px;"   ><font size="2"   >ERROR: &nbsp;42601: syntax error at or near "["</font></div><div style="line-height: 22px;"   ><font size="2"   >LINE 8: &nbsp; &nbsp; execute 'select $1' into res[i] using x;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;plpgsql_yyerror, pl_scanner.c:521</font></div><p></p></pre></div></div><div style="line-height: 22px;"   >使用execute报的又是另一个错误, 它在语法上根本就不允许你将变量赋予数组中的一个元素.</div><div><br></div><div><span style="line-height: 22px;"   >测试函数4 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# do language plpgsql $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; res text[];</font></div><div><font size="2"   >&nbsp; x text; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; i int := 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; foreach x in array array['1','2','3'] loop</font></div><div><font size="2"   >&nbsp; &nbsp; res[i] := x; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; i := i+1;</font></div><div><font size="2"   >&nbsp; end loop;</font></div><div><font size="2"   >&nbsp; raise notice '%', res;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$;</font></div><div><font size="2"   >NOTICE: &nbsp;00000: [0:2]={1,2,3}</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >DO</font></div><p></p></pre></div><div>这个是解决办法, 直接赋值吧, 这样没那么多的检测了. 自己控制就好了.</div><div>如果你遇到同样的问题, 可以尝试这样解决.</div><div><br></div><div><span style="line-height: 22px;"   >以上错误和PostgreSQL不限制维度有关, 因为text[]定义可以存储多维数组. 并不局限1维数组.</span></div><div><span style="line-height: 22px;"   >手册原文如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ><font size="2"   >However, the current implementation ignores any supplied array size limits, i.e., the behavior is the same as for arrays of unspecified length.</font></p><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ><font size="2"   >The current implementation does not enforce the declared number of dimensions either. Arrays of a particular element type are all considered to be of the same type, regardless of size or number of dimensions. So, declaring the array size or number of dimensions in&nbsp;<tt>CREATE TABLE</tt>&nbsp;is simply documentation; it does not affect run-time behavior.</font></p><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ><font size="2"   >An alternative syntax, which conforms to the SQL standard by using the keyword&nbsp;<tt>ARRAY</tt>, can be used for one-dimensional arrays.&nbsp;<tt>pay_by_quarter</tt>&nbsp;could have been defined as:</font></p><pre style="-webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border: 1px solid rgb(207, 207, 207); padding: 2ex; margin-top: 2ex; margin-bottom: 2ex; margin-left: 2ex; overflow: auto; border-top-left-radius: 8px; border-top-right-radius: 8px; border-bottom-right-radius: 8px; border-bottom-left-radius: 8px; background-color: rgb(247, 247, 247); line-height: normal;"   ><font size="2"   >    pay_by_quarter  integer ARRAY[4],
</font></pre><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ><font size="2"   >Or, if no array size is to be specified:</font></p><pre style="-webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border: 1px solid rgb(207, 207, 207); padding: 2ex; margin-top: 2ex; margin-bottom: 2ex; margin-left: 2ex; overflow: auto; border-top-left-radius: 8px; border-top-right-radius: 8px; border-bottom-right-radius: 8px; border-bottom-left-radius: 8px; background-color: rgb(247, 247, 247); line-height: normal;"   ><font size="2"   >    pay_by_quarter  integer ARRAY,
</font></pre><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ><font size="2"   >As before, however,&nbsp;<span>PostgreSQL</span>&nbsp;does not enforce the size restriction in any case.</font></p><p></p></pre></div><div>如下 :&nbsp;</div><div>使用res 存储2维数组.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 19px;"   >postgres=# do language plpgsql $$<br>declare<br>  res text[];<br>begin<br>  res := '{{a,a,a},{b,b,b},{c,c,c}}';<br>  raise notice '%', res[1][1:3];<br>end;<br>$$;<br>NOTICE:  00000: {{a,a,a}}<br>LOCATION:  exec_stmt_raise, pl_exec.c:2840<br>DO</span></font></div><p></p></pre></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 22px;" href="http://blog.163.com/digoal@126/blog/static/163877040201201275922529/"   >http://blog.163.com/digoal@126/blog/static/163877040201201275922529/</a></div><div>2. src/backend/parser/parse_node.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp; 203 &nbsp;* transformArrayType()</font></div><div><font size="2"   >&nbsp; 204 &nbsp;* &nbsp; &nbsp; &nbsp;Identify the types involved in a subscripting operation</font></div><div><font size="2"   >&nbsp; 205 &nbsp;*</font></div><div><font size="2"   >&nbsp; 206 &nbsp;* On entry, arrayType/arrayTypmod identify the type of the input value</font></div><div><font size="2"   >&nbsp; 207 &nbsp;* to be subscripted (which could be a domain type). &nbsp;These are modified</font></div><div><font size="2"   >&nbsp; 208 &nbsp;* if necessary to identify the actual array type and typmod, and the</font></div><div><font size="2"   >&nbsp; 209 &nbsp;* array's element type is returned. &nbsp;An error is thrown if the input isn't</font></div><div><font size="2"   >&nbsp; 210 &nbsp;* an array type.</font></div><div><font size="2"   >&nbsp; 211 &nbsp;*/</font></div><div><font size="2"   >&nbsp; 212 Oid</font></div><div><font size="2"   >&nbsp; 213 transformArrayType(Oid *arrayType, int32 *arrayTypmod)</font></div><div><font size="2"   >&nbsp; 214 {</font></div><div><font size="2"   >&nbsp; 215 &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; origArrayType = *arrayType;</font></div><div><font size="2"   >&nbsp; 216 &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; elementType;</font></div><div><font size="2"   >&nbsp; 217 &nbsp; &nbsp; HeapTuple &nbsp; type_tuple_array;</font></div><div><font size="2"   >&nbsp; 218 &nbsp; &nbsp; Form_pg_type type_struct_array;</font></div><div><font size="2"   >&nbsp; 219&nbsp;</font></div><div><font size="2"   >&nbsp; 220 &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; 221 &nbsp; &nbsp; &nbsp;* If the input is a domain, smash to base type, and extract the actual</font></div><div><font size="2"   >&nbsp; 222 &nbsp; &nbsp; &nbsp;* typmod to be applied to the base type. &nbsp;Subscripting a domain is an</font></div><div><font size="2"   >&nbsp; 223 &nbsp; &nbsp; &nbsp;* operation that necessarily works on the base array type, not the domain</font></div><div><font size="2"   >&nbsp; 224 &nbsp; &nbsp; &nbsp;* itself. &nbsp;(Note that we provide no method whereby the creator of a</font></div><div><font size="2"   >&nbsp; 225 &nbsp; &nbsp; &nbsp;* domain over an array type could hide its ability to be subscripted.)</font></div><div><font size="2"   >&nbsp; 226 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; 227 &nbsp; &nbsp; *arrayType = getBaseTypeAndTypmod(*arrayType, arrayTypmod);</font></div><div><font size="2"   >&nbsp; 228&nbsp;</font></div><div><font size="2"   >&nbsp; 229 &nbsp; &nbsp; /* Get the type tuple for the array */</font></div><div><font size="2"   >&nbsp; 230 &nbsp; &nbsp; type_tuple_array = SearchSysCache1(TYPEOID, ObjectIdGetDatum(*arrayType));</font></div><div><font size="2"   >&nbsp; 231 &nbsp; &nbsp; if (!HeapTupleIsValid(type_tuple_array))</font></div><div><font size="2"   >&nbsp; 232 &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, "cache lookup failed for type %u", *arrayType);</font></div><div><font size="2"   >&nbsp; 233 &nbsp; &nbsp; type_struct_array = (Form_pg_type) GETSTRUCT(type_tuple_array);</font></div><div><font size="2"   >&nbsp; 234&nbsp;</font></div><div><font size="2"   >&nbsp; 235 &nbsp; &nbsp; /* needn't check typisdefined since this will fail anyway */</font></div><div><font size="2"   >&nbsp; 236&nbsp;</font></div><div><font size="2"   >&nbsp; 237 &nbsp; &nbsp; elementType = type_struct_array-&gt;typelem;</font></div><div><font size="2"   >&nbsp; 238 &nbsp; &nbsp; if (elementType == InvalidOid)</font></div><div><font size="2"   >&nbsp; 239 &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; 240 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_DATATYPE_MISMATCH),</font></div><div><font size="2"   >&nbsp; 241 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("cannot subscript type %s because it is not an array",</font></div><div><font size="2"   >&nbsp; 242 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; format_type_be(origArrayType))));</font></div><div><font size="2"   >&nbsp; 243&nbsp;</font></div><div><font size="2"   >&nbsp; 244 &nbsp; &nbsp; ReleaseSysCache(type_tuple_array);</font></div><div><font size="2"   >&nbsp; 245&nbsp;</font></div><div><font size="2"   >&nbsp; 246 &nbsp; &nbsp; return elementType;</font></div><div><font size="2"   >&nbsp; 247 }</font></div><div><font size="2"   >&nbsp; 248&nbsp;</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >3. src/include/catalog/pg_type.h</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp;91 &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp;92 &nbsp; &nbsp; &nbsp;* If typelem is not 0 then it identifies another row in pg_type. The</font></div><div><font size="2"   >&nbsp; &nbsp;93 &nbsp; &nbsp; &nbsp;* current type can then be subscripted like an array yielding values of</font></div><div><font size="2"   >&nbsp; &nbsp;94 &nbsp; &nbsp; &nbsp;* type typelem. A non-zero typelem does not guarantee this type to be a</font></div><div><font size="2"   >&nbsp; &nbsp;95 &nbsp; &nbsp; &nbsp;* "real" array type; some ordinary fixed-length types can also be</font></div><div><font size="2"   >&nbsp; &nbsp;96 &nbsp; &nbsp; &nbsp;* subscripted (e.g., name, point). Variable-length types can *not* be</font></div><div><font size="2"   >&nbsp; &nbsp;97 &nbsp; &nbsp; &nbsp;* turned into pseudo-arrays like that. Hence, the way to determine</font></div><div><font size="2"   >&nbsp; &nbsp;98 &nbsp; &nbsp; &nbsp;* whether a type is a "true" array type is if:</font></div><div><font size="2"   >&nbsp; &nbsp;99 &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; 100 &nbsp; &nbsp; &nbsp;* typelem != 0 and typlen == -1.</font></div><div><font size="2"   >&nbsp; 101 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; 102 &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; typelem;</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >4. src/include/postgres_ext.h</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp;33 #ifdef __cplusplus</font></div><div><font size="2"   >&nbsp; &nbsp;34 #define InvalidOid &nbsp; &nbsp; &nbsp;(Oid(0))</font></div><div><font size="2"   >&nbsp; &nbsp;35 #else</font></div><div><font size="2"   >&nbsp; &nbsp;36 #define InvalidOid &nbsp; &nbsp; &nbsp;((Oid) 0)</font></div><div><font size="2"   >&nbsp; &nbsp;37 #endif</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >5. src/backend/parser/parse_node.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; 249 /*</font></div><div><font size="2"   >&nbsp; 250 &nbsp;* transformArraySubscripts()</font></div><div><font size="2"   >&nbsp; 251 &nbsp;* &nbsp; &nbsp; &nbsp;Transform array subscripting. &nbsp;This is used for both</font></div><div><font size="2"   >&nbsp; 252 &nbsp;* &nbsp; &nbsp; &nbsp;array fetch and array assignment.</font></div><div><font size="2"   >&nbsp; 253 &nbsp;*</font></div><div><font size="2"   >&nbsp; 254 &nbsp;* In an array fetch, we are given a source array value and we produce an</font></div><div><font size="2"   >&nbsp; 255 &nbsp;* expression that represents the result of extracting a single array element</font></div><div><font size="2"   >&nbsp; 256 &nbsp;* or an array slice.</font></div><div><font size="2"   >&nbsp; 257 &nbsp;*</font></div><div><font size="2"   >&nbsp; 258 &nbsp;* In an array assignment, we are given a destination array value plus a</font></div><div><font size="2"   >&nbsp; 259 &nbsp;* source value that is to be assigned to a single element or a slice of</font></div><div><font size="2"   >&nbsp; 260 &nbsp;* that array. &nbsp;We produce an expression that represents the new array value</font></div><div><font size="2"   >&nbsp; 261 &nbsp;* with the source data inserted into the right part of the array.</font></div><div><font size="2"   >&nbsp; 262 &nbsp;*</font></div><div><font size="2"   >&nbsp; 263 &nbsp;* For both cases, if the source array is of a domain-over-array type,</font></div><div><font size="2"   >&nbsp; 264 &nbsp;* the result is of the base array type or its element type; essentially,</font></div><div><font size="2"   >&nbsp; 265 &nbsp;* we must fold a domain to its base type before applying subscripting.</font></div><div><font size="2"   >&nbsp; 266 &nbsp;*</font></div><div><font size="2"   >&nbsp; 267 &nbsp;* pstate &nbsp; &nbsp; &nbsp; Parse state</font></div><div><font size="2"   >&nbsp; 268 &nbsp;* arrayBase &nbsp; &nbsp;Already-transformed expression for the array as a whole</font></div><div><font size="2"   >&nbsp; 269 &nbsp;* arrayType &nbsp; &nbsp;OID of array's datatype (should match type of arrayBase,</font></div><div><font size="2"   >&nbsp; 270 &nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or be the base type of arrayBase's domain type)</font></div><div><font size="2"   >&nbsp; 271 &nbsp;* elementType &nbsp;OID of array's element type (fetch with transformArrayType,</font></div><div><font size="2"   >&nbsp; 272 &nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or pass InvalidOid to do it here)</font></div><div><font size="2"   >&nbsp; 273 &nbsp;* arrayTypMod &nbsp;typmod for the array (which is also typmod for the elements)</font></div><div><font size="2"   >&nbsp; 274 &nbsp;* indirection &nbsp;Untransformed list of subscripts (must not be NIL)</font></div><div><font size="2"   >&nbsp; 275 &nbsp;* assignFrom &nbsp; NULL for array fetch, else transformed expression for source.</font></div><div><font size="2"   >&nbsp; 276 &nbsp;*/</font></div><div><font size="2"   >&nbsp; 277 ArrayRef *</font></div><div><font size="2"   >&nbsp; 278 transformArraySubscripts(ParseState *pstate,</font></div><div><font size="2"   >&nbsp; 279 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Node *arrayBase,</font></div><div><font size="2"   >&nbsp; 280 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Oid arrayType,</font></div><div><font size="2"   >&nbsp; 281 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Oid elementType,</font></div><div><font size="2"   >&nbsp; 282 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int32 arrayTypMod,</font></div><div><font size="2"   >&nbsp; 283 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List *indirection,</font></div><div><font size="2"   >&nbsp; 284 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Node *assignFrom)</font></div><div><font size="2"   >&nbsp; 285 {</font></div><div><font size="2"   >&nbsp; 286 &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;isSlice = false;</font></div><div><font size="2"   >&nbsp; 287 &nbsp; &nbsp; List &nbsp; &nbsp; &nbsp; *upperIndexpr = NIL;</font></div><div><font size="2"   >&nbsp; 288 &nbsp; &nbsp; List &nbsp; &nbsp; &nbsp; *lowerIndexpr = NIL;</font></div><div><font size="2"   >&nbsp; 289 &nbsp; &nbsp; ListCell &nbsp; *idx;</font></div><div><font size="2"   >&nbsp; 290 &nbsp; &nbsp; ArrayRef &nbsp; *aref;</font></div><div><font size="2"   >&nbsp; 291&nbsp;</font></div><div><font size="2"   >&nbsp; 292 &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; 293 &nbsp; &nbsp; &nbsp;* Caller may or may not have bothered to determine elementType. &nbsp;Note</font></div><div><font size="2"   >&nbsp; 294 &nbsp; &nbsp; &nbsp;* that if the caller did do so, arrayType/arrayTypMod must be as modified</font></div><div><font size="2"   >&nbsp; 295 &nbsp; &nbsp; &nbsp;* by transformArrayType, ie, smash domain to base type.</font></div><div><font size="2"   >&nbsp; 296 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; 297 &nbsp; &nbsp; if (!OidIsValid(elementType))</font></div><div><font size="2"   >&nbsp; 298 &nbsp; &nbsp; &nbsp; &nbsp; elementType = transformArrayType(&amp;arrayType, &amp;arrayTypMod);</font></div><div><font size="2"   >&nbsp; 299&nbsp;</font></div><div><font size="2"   >&nbsp; 300 &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; 301 &nbsp; &nbsp; &nbsp;* A list containing only single subscripts refers to a single array</font></div><div><font size="2"   >&nbsp; 302 &nbsp; &nbsp; &nbsp;* element. &nbsp;If any of the items are double subscripts (lower:upper), then</font></div><div><font size="2"   >&nbsp; 303 &nbsp; &nbsp; &nbsp;* the subscript expression means an array slice operation. In this case,</font></div><div><font size="2"   >&nbsp; 304 &nbsp; &nbsp; &nbsp;* we supply a default lower bound of 1 for any items that contain only a</font></div><div><font size="2"   >&nbsp; 305 &nbsp; &nbsp; &nbsp;* single subscript. &nbsp;We have to prescan the indirection list to see if</font></div><div><font size="2"   >&nbsp; 306 &nbsp; &nbsp; &nbsp;* there are any double subscripts.</font></div><div><font size="2"   >&nbsp; 307 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; 308 &nbsp; &nbsp; foreach(idx, indirection)</font></div><div><font size="2"   >&nbsp; 309 &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; 310 &nbsp; &nbsp; &nbsp; &nbsp; A_Indices &nbsp;*ai = (A_Indices *) lfirst(idx);</font></div><div><font size="2"   >&nbsp; 311&nbsp;</font></div><div><font size="2"   >&nbsp; 312 &nbsp; &nbsp; &nbsp; &nbsp; if (ai-&gt;lidx != NULL)</font></div><div><font size="2"   >&nbsp; 313 &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; 314 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isSlice = true;</font></div><div><font size="2"   >&nbsp; 315 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; 316 &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; 317 &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; 318&nbsp;</font></div><div><font size="2"   >&nbsp; 319 &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; 320 &nbsp; &nbsp; &nbsp;* Transform the subscript expressions.</font></div><div><font size="2"   >&nbsp; 321 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; 322 &nbsp; &nbsp; foreach(idx, indirection)</font></div><div><font size="2"   >&nbsp; 323 &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; 324 &nbsp; &nbsp; &nbsp; &nbsp; A_Indices &nbsp;*ai = (A_Indices *) lfirst(idx);</font></div><div><font size="2"   >&nbsp; 325 &nbsp; &nbsp; &nbsp; &nbsp; Node &nbsp; &nbsp; &nbsp; *subexpr;</font></div><div><font size="2"   >&nbsp; 326&nbsp;</font></div><div><font size="2"   >&nbsp; 327 &nbsp; &nbsp; &nbsp; &nbsp; Assert(IsA(ai, A_Indices));</font></div><div><font size="2"   >&nbsp; 328 &nbsp; &nbsp; &nbsp; &nbsp; if (isSlice)</font></div><div><font size="2"   >&nbsp; 329 &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; 330 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ai-&gt;lidx)</font></div><div><font size="2"   >&nbsp; 331 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; 332 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr = transformExpr(pstate, ai-&gt;lidx, pstate-&gt;p_expr_kind);</font></div><div><font size="2"   >&nbsp; 333 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* If it's not int4 already, try to coerce */</font></div><div><font size="2"   >&nbsp; 334 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr = coerce_to_target_type(pstate,</font></div><div><font size="2"   >&nbsp; 335 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr, exprType(subexpr),</font></div><div><font size="2"   >&nbsp; 336 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INT4OID, -1,</font></div><div><font size="2"   >&nbsp; 337 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_ASSIGNMENT,</font></div><div><font size="2"   >&nbsp; 338 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,</font></div><div><font size="2"   >&nbsp; 339 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -1);</font></div><div><font size="2"   >&nbsp; 340 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (subexpr == NULL)</font></div><div><font size="2"   >&nbsp; 341 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; 342 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_DATATYPE_MISMATCH),</font></div><div><font size="2"   >&nbsp; 343 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("array subscript must have type integer"),</font></div><div><font size="2"   >&nbsp; 344 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parser_errposition(pstate, exprLocation(ai-&gt;lidx))));</font></div><div><font size="2"   >&nbsp; 345 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; 346 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; 347 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; 348 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Make a constant 1 */</font></div><div><font size="2"   >&nbsp; 349 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr = (Node *) makeConst(INT4OID,</font></div><div><font size="2"   >&nbsp; 350 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-1,</font></div><div><font size="2"   >&nbsp; 351 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;InvalidOid,</font></div><div><font size="2"   >&nbsp; 352 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sizeof(int32),</font></div><div><font size="2"   >&nbsp; 353 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Int32GetDatum(1),</font></div><div><font size="2"   >&nbsp; 354 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;false,</font></div><div><font size="2"   >&nbsp; 355 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;true); &nbsp; &nbsp; /* pass by value */</font></div><div><font size="2"   >&nbsp; 356 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; 357 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowerIndexpr = lappend(lowerIndexpr, subexpr);</font></div><div><font size="2"   >&nbsp; 358 &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; 359 &nbsp; &nbsp; &nbsp; &nbsp; subexpr = transformExpr(pstate, ai-&gt;uidx, pstate-&gt;p_expr_kind);</font></div><div><font size="2"   >&nbsp; 360 &nbsp; &nbsp; &nbsp; &nbsp; /* If it's not int4 already, try to coerce */</font></div><div><font size="2"   >&nbsp; 361 &nbsp; &nbsp; &nbsp; &nbsp; subexpr = coerce_to_target_type(pstate,</font></div><div><font size="2"   >&nbsp; 362 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr, exprType(subexpr),</font></div><div><font size="2"   >&nbsp; 363 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INT4OID, -1,</font></div><div><font size="2"   >&nbsp; 364 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_ASSIGNMENT,</font></div><div><font size="2"   >&nbsp; 365 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,</font></div><div><font size="2"   >&nbsp; 366 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -1);</font></div><div><font size="2"   >&nbsp; 367 &nbsp; &nbsp; &nbsp; &nbsp; if (subexpr == NULL)</font></div><div><font size="2"   >&nbsp; 368 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; 369 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_DATATYPE_MISMATCH),</font></div><div><font size="2"   >&nbsp; 370 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("array subscript must have type integer"),</font></div><div><font size="2"   >&nbsp; 371 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;parser_errposition(pstate, exprLocation(ai-&gt;uidx))));</font></div><div><font size="2"   >&nbsp; 372 &nbsp; &nbsp; &nbsp; &nbsp; upperIndexpr = lappend(upperIndexpr, subexpr);</font></div><div><font size="2"   >&nbsp; 373 &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; 374&nbsp;</font></div><div><font size="2"   >&nbsp; 375 &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; 376 &nbsp; &nbsp; &nbsp;* If doing an array store, coerce the source value to the right type.</font></div><div><font size="2"   >&nbsp; 377 &nbsp; &nbsp; &nbsp;* (This should agree with the coercion done by transformAssignedExpr.)</font></div><div><font size="2"   >&nbsp; 378 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; 379 &nbsp; &nbsp; if (assignFrom != NULL)</font></div><div><font size="2"   >&nbsp; 380 &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; 381 &nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; typesource = exprType(assignFrom);</font></div><div><font size="2"   >&nbsp; 382 &nbsp; &nbsp; &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; typeneeded = isSlice ? arrayType : elementType;</font></div><div><font size="2"   >&nbsp; 383 &nbsp; &nbsp; &nbsp; &nbsp; Node &nbsp; &nbsp; &nbsp; *newFrom;</font></div><div><font size="2"   >&nbsp; 384&nbsp;</font></div><div><font size="2"   >&nbsp; 385 &nbsp; &nbsp; &nbsp; &nbsp; newFrom = coerce_to_target_type(pstate,</font></div><div><font size="2"   >&nbsp; 386 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assignFrom, typesource,</font></div><div><font size="2"   >&nbsp; 387 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeneeded, arrayTypMod,</font></div><div><font size="2"   >&nbsp; 388 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_ASSIGNMENT,</font></div><div><font size="2"   >&nbsp; 389 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,</font></div><div><font size="2"   >&nbsp; 390 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -1);</font></div><div><font size="2"   >&nbsp; 391 &nbsp; &nbsp; &nbsp; &nbsp; if (newFrom == NULL)</font></div><div><font size="2"   >&nbsp; 392 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; 393 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_DATATYPE_MISMATCH),</font></div><div><font size="2"   >&nbsp; 394 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("array assignment requires type %s"</font></div><div><font size="2"   >&nbsp; 395 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; " but expression is of type %s",</font></div><div><font size="2"   >&nbsp; 396 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; format_type_be(typeneeded),</font></div><div><font size="2"   >&nbsp; 397 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; format_type_be(typesource)),</font></div><div><font size="2"   >&nbsp; 398 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("You will need to rewrite or cast the expression."),</font></div><div><font size="2"   >&nbsp; 399 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;parser_errposition(pstate, exprLocation(assignFrom))));</font></div><div><font size="2"   >&nbsp; 400 &nbsp; &nbsp; &nbsp; &nbsp; assignFrom = newFrom;</font></div><div><font size="2"   >&nbsp; 401 &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; 402&nbsp;</font></div><div><font size="2"   >&nbsp; 403 &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; 404 &nbsp; &nbsp; &nbsp;* Ready to build the ArrayRef node.</font></div><div><font size="2"   >&nbsp; 405 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; 406 &nbsp; &nbsp; aref = makeNode(ArrayRef);</font></div><div><font size="2"   >&nbsp; 407 &nbsp; &nbsp; aref-&gt;refarraytype = arrayType;</font></div><div><font size="2"   >&nbsp; 408 &nbsp; &nbsp; aref-&gt;refelemtype = elementType;</font></div><div><font size="2"   >&nbsp; 409 &nbsp; &nbsp; aref-&gt;reftypmod = arrayTypMod;</font></div><div><font size="2"   >&nbsp; 410 &nbsp; &nbsp; /* refcollid will be set by parse_collate.c */</font></div><div><font size="2"   >&nbsp; 411 &nbsp; &nbsp; aref-&gt;refupperindexpr = upperIndexpr;</font></div><div><font size="2"   >&nbsp; 412 &nbsp; &nbsp; aref-&gt;reflowerindexpr = lowerIndexpr;</font></div><div><font size="2"   >&nbsp; 413 &nbsp; &nbsp; aref-&gt;refexpr = (Expr *) arrayBase;</font></div><div><font size="2"   >&nbsp; 414 &nbsp; &nbsp; aref-&gt;refassgnexpr = (Expr *) assignFrom;</font></div><div><font size="2"   >&nbsp; 415&nbsp;</font></div><div><font size="2"   >&nbsp; 416 &nbsp; &nbsp; return aref;</font></div><div><font size="2"   >&nbsp; 417 }</font></div><p></p></pre></div><div><br></div><div><br></div><wbr></div>
	</div>
</div>
</body>
</html>