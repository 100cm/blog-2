<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">subquery & function & func's volatile state & constraint_exclusion</h2>
	<h5 id="">2014-10-29 11:44:21&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201492911252135/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>群里的兄弟问到的一个问题, 用子查询时无法获得良好的执行计划, 不能通过约束排除某些子表的扫描.</div><div>因为使用约束排除扫描表是在optimizer-&gt;plan阶段处理的, 见<span style="line-height: 28px;"   >src/backend/optimizer/util/plancat.c</span></div><div><span style="line-height: 28px;"   >而子查询在plan后处理, 所以无法用子查询的值来进行</span>optimizer.&nbsp;</div><div>如果一定要用的话, 可以考虑把子查询封装成一个函数, 同时设置函数为immutable的, immutable函数将在plan前被评估, 所以可以获得良好的执行计划.</div><div>对执行计划和函数稳定性感兴趣的朋友可以去了解一下 :&nbsp;</div><div><div>10. 性能优化培训 - 函数的三种稳定性状态对优化器的影响分解讲解&nbsp;</div><div><a target="_blank" rel="nofollow" href="http://www.tudou.com/programs/view/p6E3oQEsZv0/"   >http://www.tudou.com/programs/view/p6E3oQEsZv0/</a></div><div>8. 性能优化培训 - 执行计划缓存管理, 绑定变量接口</div><div><a target="_blank" rel="nofollow" href="http://www.tudou.com/programs/view/kwmilXD7JEw/"   >http://www.tudou.com/programs/view/kwmilXD7JEw/</a></div></div><div><br></div><div>例子 :&nbsp;</div><div>创建测试表, 以及约束.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table c(id int, crt_time date);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# create table c1(like c including all) inherits(c);</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "id" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "crt_time" with inherited definition</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# create table c2(like c including all) inherits(c);</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "id" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "crt_time" with inherited definition</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# create table c3(like c including all) inherits(c);</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "id" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "crt_time" with inherited definition</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# create table c4(like c including all) inherits(c);</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "id" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "crt_time" with inherited definition</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# create table c5(like c including all) inherits(c);</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "id" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "crt_time" with inherited definition</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# create table c6(like c including all) inherits(c);</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "id" with inherited definition</font></div><div><font size="2"   >NOTICE: &nbsp;merging column "crt_time" with inherited definition</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# alter table c1 add constraint ck check(crt_time='2014-01-01');</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=# alter table c2 add constraint ck check(crt_time='2014-01-02');</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=# alter table c3 add constraint ck check(crt_time='2014-01-03');</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=# alter table c4 add constraint ck check(crt_time='2014-01-04');</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=# alter table c5 add constraint ck check(crt_time='2014-01-05');</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=# alter table c6 add constraint ck check(crt_time='2014-01-06');</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >digoal=# show constraint_exclusion;<br> constraint_exclusion <br>----------------------<br> partition<br>(1 row)</font></div><p></p></pre></div><div>测试SQL, 使用常量作为条件, 可以排除不符合约束的子表扫描 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain select * from c where crt_time in ('2014-01-01','2014-01-02');</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Append &nbsp;(cost=0.00..235.25 rows=173 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c &nbsp;(cost=0.00..0.00 rows=1 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_time = ANY ('{2014-01-01,2014-01-02}'::date[]))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c1 &nbsp;(cost=0.00..117.62 rows=86 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_time = ANY ('{2014-01-01,2014-01-02}'::date[]))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c2 &nbsp;(cost=0.00..117.62 rows=86 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_time = ANY ('{2014-01-01,2014-01-02}'::date[]))</font></div><div><font size="2"   >(7 rows)</font></div><p></p></pre></div></div><div><br></div><div>使用子查询, 同样是这两天, 但是无法排除某些子表的扫描 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain select * from c where crt_time in (select generate_series('2014-01-01'::timestamp,'2014-01-02'::timestamp,interval '1 day')::date);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >----------------------------------------------</font></div><div><font size="2"   >&nbsp;Hash Join &nbsp;(cost=22.01..1308.95 rows=25830 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp;Hash Cond: (c.crt_time = ((generate_series('2014-01-01 00:00:00'::timestamp without time zone, '2014-01-02 00:00:00'::timestamp w</font></div><div><font size="2"   >ithout time zone, '1 day'::interval))::date))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Append &nbsp;(cost=0.00..576.60 rows=51661 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c &nbsp;(cost=0.00..0.00 rows=1 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c1 &nbsp;(cost=0.00..96.10 rows=8610 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c2 &nbsp;(cost=0.00..96.10 rows=8610 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c3 &nbsp;(cost=0.00..96.10 rows=8610 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c4 &nbsp;(cost=0.00..96.10 rows=8610 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c5 &nbsp;(cost=0.00..96.10 rows=8610 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c6 &nbsp;(cost=0.00..96.10 rows=8610 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Hash &nbsp;(cost=19.51..19.51 rows=200 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;HashAggregate &nbsp;(cost=17.51..19.51 rows=200 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Result &nbsp;(cost=0.00..5.01 rows=1000 width=0)</font></div><div><font size="2"   >(13 rows)</font></div><p></p></pre></div><div>另一个简单的子查询亦如此, 原因在开头已经分析过了 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain select * from c where crt_time in (select '2014-01-01'::date);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Hash Join &nbsp;(cost=0.04..772.95 rows=25830 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp;Hash Cond: (c.crt_time = ('2014-01-01'::date))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Append &nbsp;(cost=0.00..576.60 rows=51661 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c &nbsp;(cost=0.00..0.00 rows=1 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c1 &nbsp;(cost=0.00..96.10 rows=8610 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c2 &nbsp;(cost=0.00..96.10 rows=8610 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c3 &nbsp;(cost=0.00..96.10 rows=8610 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c4 &nbsp;(cost=0.00..96.10 rows=8610 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c5 &nbsp;(cost=0.00..96.10 rows=8610 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c6 &nbsp;(cost=0.00..96.10 rows=8610 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Hash &nbsp;(cost=0.03..0.03 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;HashAggregate &nbsp;(cost=0.02..0.03 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Result &nbsp;(cost=0.00..0.01 rows=1 width=0)</font></div><div><font size="2"   >(13 rows)</font></div><p></p></pre></div><div>接下来, 创建一个immutable函数, 返回一个数组(即你需要的条件).</div><div><pre class="prettyprint"   ><p></p><div><div><span style="line-height: 28px;"   ><font size="2"   >digoal=# create or replace function f(t1 timestamp, t2 timestamp) returns &nbsp;date[] as $$</font></span></div></div><div><div><font size="2"   >declare&nbsp;</font></div><div><font size="2"   >&nbsp; res date[];</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; select array_agg(x) into res from (select generate_series(t1,t2,interval '1 day')::date) as t(x);&nbsp;</font></div><div><font size="2"   >&nbsp; return res;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql strict immutable;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select f('2014-01-01','2014-01-02');</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------------------------</font></div><div><font size="2"   >&nbsp;{2014-01-01,2014-01-02}</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div></div><div><div>使用这个函数, 我们看到, 可以很好的过滤不符合约束的子表 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain select * from c where crt_time = any (f('2014-01-01','2014-01-02'));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Append &nbsp;(cost=0.00..235.25 rows=173 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c &nbsp;(cost=0.00..0.00 rows=1 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_time = ANY ('{2014-01-01,2014-01-02}'::date[]))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c1 &nbsp;(cost=0.00..117.62 rows=86 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_time = ANY ('{2014-01-01,2014-01-02}'::date[]))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c2 &nbsp;(cost=0.00..117.62 rows=86 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_time = ANY ('{2014-01-01,2014-01-02}'::date[]))</font></div><div><font size="2"   >(7 rows)</font></div><p></p></pre></div></div><div>如果改为stable或volatile的话, 当然是不能排除约束的, 原因在开始已经分析过了, 和函数的稳定性有关.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# alter function f(timestamp, timestamp) stable;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><div><font size="2"   >digoal=# explain select * from c where crt_time = any (f('2014-01-01','2014-01-02'));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;Append &nbsp;(cost=0.00..14137.35 rows=517 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c &nbsp;(cost=0.00..0.00 rows=1 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_time = ANY (f('2014-01-01 00:00:00'::timestamp without time zone, '2014-01-02 00:00:00'::timestamp without tim</font></div><div><font size="2"   >e zone)))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c1 &nbsp;(cost=0.00..2356.23 rows=86 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_time = ANY (f('2014-01-01 00:00:00'::timestamp without time zone, '2014-01-02 00:00:00'::timestamp without tim</font></div><div><font size="2"   >e zone)))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c2 &nbsp;(cost=0.00..2356.23 rows=86 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_time = ANY (f('2014-01-01 00:00:00'::timestamp without time zone, '2014-01-02 00:00:00'::timestamp without tim</font></div><div><font size="2"   >e zone)))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c3 &nbsp;(cost=0.00..2356.23 rows=86 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_time = ANY (f('2014-01-01 00:00:00'::timestamp without time zone, '2014-01-02 00:00:00'::timestamp without tim</font></div><div><font size="2"   >e zone)))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c4 &nbsp;(cost=0.00..2356.23 rows=86 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_time = ANY (f('2014-01-01 00:00:00'::timestamp without time zone, '2014-01-02 00:00:00'::timestamp without tim</font></div><div><font size="2"   >e zone)))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c5 &nbsp;(cost=0.00..2356.23 rows=86 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_time = ANY (f('2014-01-01 00:00:00'::timestamp without time zone, '2014-01-02 00:00:00'::timestamp without tim</font></div><div><font size="2"   >e zone)))</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on c6 &nbsp;(cost=0.00..2356.23 rows=86 width=8)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (crt_time = ANY (f('2014-01-01 00:00:00'::timestamp without time zone, '2014-01-02 00:00:00'::timestamp without tim</font></div><div><font size="2"   >e zone)))</font></div><div><font size="2"   >(15 rows)</font></div><p></p></pre></div><div><br></div></div>[参考]<wbr><div>1.&nbsp;src/backend/optimizer/util/plancat.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/* GUC parameter */</font></div><div><font size="2"   >int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint_exclusion = CONSTRAINT_EXCLUSION_PARTITION;</font></div></div><div><font size="2"   >.........................</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* relation_excluded_by_constraints</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Detect whether the relation need not be scanned because it has either</font></div><div><font size="2"   >&nbsp;* self-inconsistent restrictions, or restrictions inconsistent with the</font></div><div><font size="2"   >&nbsp;* relation's validated CHECK constraints.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: this examines only rel-&gt;relid, rel-&gt;reloptkind, and</font></div><div><font size="2"   >&nbsp;* rel-&gt;baserestrictinfo; therefore it can be called before filling in</font></div><div><font size="2"   >&nbsp;* other fields of the RelOptInfo.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >bool</font></div><div><font size="2"   >relation_excluded_by_constraints(PlannerInfo *root,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RelOptInfo *rel, RangeTblEntry *rte)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; List &nbsp; &nbsp; &nbsp; *safe_restrictions;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; List &nbsp; &nbsp; &nbsp; *constraint_pred;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; List &nbsp; &nbsp; &nbsp; *safe_constraints;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ListCell &nbsp; *lc;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Skip the test if constraint exclusion is disabled for the rel */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (constraint_exclusion == CONSTRAINT_EXCLUSION_OFF ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (constraint_exclusion == CONSTRAINT_EXCLUSION_PARTITION &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;!(rel-&gt;reloptkind == RELOPT_OTHER_MEMBER_REL ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(root-&gt;hasInheritedTarget &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;reloptkind == RELOPT_BASEREL &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;relid == root-&gt;parse-&gt;resultRelation))))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check for self-contradictory restriction clauses. &nbsp;We dare not make</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* deductions with non-immutable functions, but any immutable clauses that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* are self-contradictory allow us to conclude the scan is unnecessary.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: strip off RestrictInfo because predicate_refuted_by() isn't</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* expecting to see any in its predicate argument.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; safe_restrictions = NIL;</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, rel-&gt;baserestrictinfo)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!contain_mutable_functions((Node *) rinfo-&gt;clause))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safe_restrictions = lappend(safe_restrictions, rinfo-&gt;clause);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (predicate_refuted_by(safe_restrictions, safe_restrictions))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Only plain relations have constraints */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (rte-&gt;rtekind != RTE_RELATION || rte-&gt;inh)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* OK to fetch the constraint expressions. &nbsp;Include "col IS NOT NULL"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* expressions for attnotnull columns, in case we can refute those.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; constraint_pred = get_relation_constraints(root, rte-&gt;relid, rel, true);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We do not currently enforce that CHECK constraints contain only</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* immutable functions, so it's necessary to check here. We daren't draw</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* conclusions from plan-time evaluation of non-immutable functions. Since</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* they're ANDed, we can just ignore any mutable constraints in the list,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* and reason about the rest.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; safe_constraints = NIL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, constraint_pred)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node &nbsp; &nbsp; &nbsp; *pred = (Node *) lfirst(lc);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!contain_mutable_functions(pred))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; safe_constraints = lappend(safe_constraints, pred);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The constraints are effectively ANDed together, so we can just try to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* refute the entire collection at once. &nbsp;This may allow us to make proofs</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* that would fail if we took them individually.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: we use rel-&gt;baserestrictinfo, not safe_restrictions as might seem</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* an obvious optimization. &nbsp;Some of the clauses might be OR clauses that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* have volatile and nonvolatile subclauses, and it's OK to make</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* deductions with the nonvolatile parts.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (predicate_refuted_by(safe_constraints, rel-&gt;baserestrictinfo))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="2014年10月29日 - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>