<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">[转贴] hung_task_timeout_secs 简单学习</h2>
	<h5 id="">2013-06-03 8:38:52&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020135383852715/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>[原文链接]</div><div><a rel="nofollow" href="http://hi.baidu.com/stealth_space/item/2007d93fe93ca28fb711dbac"   >http://hi.baidu.com/stealth_space/item/2007d93fe93ca28fb711dbac</a></div><div><br></div><div>接上篇 简单学习了解下 hung_task_timeout_secs 相关知识.</div><div><br></div><div>OS: 2.6.18-194.32.1.el5 x86_64</div><div><br></div><div># 先从系统中看下 hung_task 相关的参数及其参数值</div><div>[sina@localhost ~]$ sudo sysctl -a | grep hung</div><div>kernel.hung_task_warnings = 0</div><div>kernel.hung_task_timeout_secs = 120</div><div>kernel.hung_task_check_count = 4194304</div><div>kernel.hung_task_panic = 0</div><div>[sina@localhost ~]$</div><div><br></div><div><br></div><div># 源码在此.... (v2.6.37.1) &nbsp; &amp; 结合看下kernel/sysctl.c更好</div><div># kernel/hung_task.c</div><div>/*</div><div>&nbsp;* Detect Hung Task</div><div>&nbsp;*</div><div>&nbsp;* kernel/hung_task.c - kernel thread for detecting tasks stuck in D state</div><div>&nbsp;*</div><div>&nbsp;*/</div><div><br></div><div>#include &lt;linux/mm.h&gt;</div><div>#include &lt;linux/cpu.h&gt;</div><div>#include &lt;linux/nmi.h&gt;</div><div>#include &lt;linux/init.h&gt;</div><div>#include &lt;linux/delay.h&gt;</div><div>#include &lt;linux/freezer.h&gt;</div><div>#include &lt;linux/kthread.h&gt;</div><div>#include &lt;linux/lockdep.h&gt;</div><div>#include &lt;linux/module.h&gt;</div><div>#include &lt;linux/sysctl.h&gt;</div><div><br></div><div>/*</div><div>&nbsp;* The number of tasks checked:</div><div>&nbsp;*/</div><div>unsigned long __read_mostly sysctl_hung_task_check_count = PID_MAX_LIMIT;</div><div><br></div><div>/*</div><div>&nbsp;* Limit number of tasks checked in a batch.</div><div>&nbsp;*</div><div>&nbsp;* This value controls the preemptibility of khungtaskd since preemption</div><div>&nbsp;* is disabled during the critical section. It also controls the size of</div><div>&nbsp;* the RCU grace period. So it needs to be upper-bound.</div><div>&nbsp;*/</div><div>#define HUNG_TASK_BATCHING 1024</div><div><br></div><div>/*</div><div>&nbsp;* Zero means infinite timeout - no checking done:</div><div>&nbsp;*/</div><div>unsigned long __read_mostly sysctl_hung_task_timeout_secs = 120;</div><div><br></div><div>unsigned long __read_mostly sysctl_hung_task_warnings = 10;</div><div><br></div><div>static int __read_mostly did_panic;</div><div><br></div><div>static struct task_struct *watchdog_task;</div><div><br></div><div>/*</div><div>&nbsp;* Should we panic (and reboot, if panic_timeout= is set) when a</div><div>&nbsp;* hung task is detected:</div><div>&nbsp;*/</div><div>unsigned int __read_mostly sysctl_hung_task_panic =</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE;</div><div><br></div><div>static int __init hung_task_panic_setup(char *str)</div><div>{</div><div>&nbsp; &nbsp; sysctl_hung_task_panic = simple_strtoul(str, NULL, 0);</div><div><br></div><div>&nbsp; &nbsp; return 1;</div><div>}</div><div>__setup("hung_task_panic=", hung_task_panic_setup);</div><div><br></div><div>static int</div><div>hung_task_panic(struct notifier_block *this, unsigned long event, void *ptr)</div><div>{</div><div>&nbsp; &nbsp; did_panic = 1;</div><div><br></div><div>&nbsp; &nbsp; return NOTIFY_DONE;</div><div>}</div><div><br></div><div>static struct notifier_block panic_block = {</div><div>&nbsp; &nbsp; .notifier_call = hung_task_panic,</div><div>};</div><div><br></div><div>static void check_hung_task(struct task_struct *t, unsigned long timeout)</div><div>{</div><div>&nbsp; &nbsp; unsigned long switch_count = t-&gt;nvcsw + t-&gt;nivcsw;</div><div><br></div><div>&nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp;* Ensure the task is not frozen.</div><div>&nbsp; &nbsp; &nbsp;* Also, when a freshly created task is scheduled once, changes</div><div>&nbsp; &nbsp; &nbsp;* its state to TASK_UNINTERRUPTIBLE without having ever been</div><div>&nbsp; &nbsp; &nbsp;* switched out once, it musn't be checked.</div><div>&nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; if (unlikely(t-&gt;flags &amp; PF_FROZEN || !switch_count))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return;</div><div><br></div><div>&nbsp; &nbsp; if (switch_count != t-&gt;last_switch_count) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; t-&gt;last_switch_count = switch_count;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; if (!sysctl_hung_task_warnings)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; sysctl_hung_task_warnings--;</div><div><br></div><div><u>&nbsp; &nbsp; /*</u></div><div><u>&nbsp; &nbsp; &nbsp;* Ok, the task did not get scheduled for more than 2 minutes,</u></div><div><u>&nbsp; &nbsp; &nbsp;* complain:</u></div><div><u>&nbsp; &nbsp; &nbsp;*/</u></div><div>&nbsp; &nbsp; printk(KERN_ERR "INFO: task %s:%d blocked for more than "</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "%ld seconds.\n", t-&gt;comm, t-&gt;pid, timeout);</div><div>&nbsp; &nbsp; printk(KERN_ERR "\"echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs\""</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; " disables this message.\n");</div><div>&nbsp; &nbsp; sched_show_task(t);</div><div>&nbsp; &nbsp; debug_show_held_locks(t);</div><div><br></div><div>&nbsp; &nbsp; touch_nmi_watchdog();</div><div><br></div><div>&nbsp; &nbsp; if (sysctl_hung_task_panic)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; panic("hung_task: blocked tasks");</div><div>}</div><div><br></div><div>/*</div><div>&nbsp;* To avoid extending the RCU grace period for an unbounded amount of time,</div><div>&nbsp;* periodically exit the critical section and enter a new one.</div><div>&nbsp;*</div><div>&nbsp;* For preemptible RCU it is sufficient to call rcu_read_unlock in order</div><div>&nbsp;* to exit the grace period. For classic RCU, a reschedule is required.</div><div>&nbsp;*/</div><div>static void rcu_lock_break(struct task_struct *g, struct task_struct *t)</div><div>{</div><div>&nbsp; &nbsp; get_task_struct(g);</div><div>&nbsp; &nbsp; get_task_struct(t);</div><div>&nbsp; &nbsp; rcu_read_unlock();</div><div>&nbsp; &nbsp; cond_resched();</div><div>&nbsp; &nbsp; rcu_read_lock();</div><div>&nbsp; &nbsp; put_task_struct(t);</div><div>&nbsp; &nbsp; put_task_struct(g);</div><div>}</div><div><br></div><div>/*</div><div>&nbsp;* Check whether a TASK_UNINTERRUPTIBLE does not get woken up for</div><div>&nbsp;* a really long time (120 seconds). If that happens, print out</div><div>&nbsp;* a warning.</div><div>&nbsp;*/</div><div>static void check_hung_uninterruptible_tasks(unsigned long timeout)</div><div>{</div><div>&nbsp; &nbsp; int max_count = sysctl_hung_task_check_count;</div><div>&nbsp; &nbsp; int batch_count = HUNG_TASK_BATCHING;</div><div>&nbsp; &nbsp; struct task_struct *g, *t;</div><div><br></div><div>&nbsp; &nbsp; /*</div><div>&nbsp; &nbsp; &nbsp;* If the system crashed already then all bets are off,</div><div>&nbsp; &nbsp; &nbsp;* do not report extra hung tasks:</div><div>&nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; if (test_taint(TAINT_DIE) || did_panic)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return;</div><div><br></div><div>&nbsp; &nbsp; rcu_read_lock();</div><div>&nbsp; &nbsp; do_each_thread(g, t) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (!max_count--)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto unlock;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (!--batch_count) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; batch_count = HUNG_TASK_BATCHING;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcu_lock_break(g, t);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Exit if t or g was unhashed during refresh. */</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (t-&gt;state == TASK_DEAD || g-&gt;state == TASK_DEAD)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto unlock;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; /* use "==" to skip the TASK_KILLABLE tasks waiting on NFS */</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (t-&gt;state == TASK_UNINTERRUPTIBLE)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check_hung_task(t, timeout);</div><div>&nbsp; &nbsp; } while_each_thread(g, t);</div><div>&nbsp;unlock:</div><div>&nbsp; &nbsp; rcu_read_unlock();</div><div>}</div><div><br></div><div>static unsigned long timeout_jiffies(unsigned long timeout)</div><div>{</div><div>&nbsp; &nbsp; /* timeout of 0 will disable the watchdog */</div><div>&nbsp; &nbsp; return timeout ? timeout * HZ : MAX_SCHEDULE_TIMEOUT;</div><div>}</div><div><br></div><div>/*</div><div>&nbsp;* Process updating of timeout sysctl</div><div>&nbsp;*/</div><div>int proc_dohung_task_timeout_secs(struct ctl_table *table, int write,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; void __user *buffer,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_t *lenp, loff_t *ppos)</div><div>{</div><div>&nbsp; &nbsp; int ret;</div><div><br></div><div>&nbsp; &nbsp; ret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);</div><div><br></div><div>&nbsp; &nbsp; if (ret || !write)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; goto out;</div><div><br></div><div>&nbsp; &nbsp; wake_up_process(watchdog_task);</div><div><br></div><div>&nbsp;out:</div><div>&nbsp; &nbsp; return ret;</div><div>}</div><div><br></div><div>/*</div><div>&nbsp;* kthread which checks for tasks stuck in D state</div><div>&nbsp;*/</div><div>static int watchdog(void *dummy)</div><div>{</div><div>&nbsp; &nbsp; set_user_nice(current, 0);</div><div><br></div><div>&nbsp; &nbsp; for ( ; ; ) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; unsigned long timeout = sysctl_hung_task_timeout_secs;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; while (schedule_timeout_interruptible(timeout_jiffies(timeout)))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeout = sysctl_hung_task_timeout_secs;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; check_hung_uninterruptible_tasks(timeout);</div><div>&nbsp; &nbsp; }</div><div><br></div><div>&nbsp; &nbsp; return 0;</div><div>}</div><div><br></div><div>static int __init hung_task_init(void)</div><div>{</div><div>&nbsp; &nbsp; atomic_notifier_chain_register(&amp;panic_notifier_list, &amp;panic_block);</div><div>&nbsp; &nbsp; watchdog_task = kthread_run(watchdog, NULL, "khungtaskd");</div><div><br></div><div>&nbsp; &nbsp; return 0;</div><div>}</div><div><br></div><div>module_init(hung_task_init);</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>[ -EOF- ]</div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="[转贴] hung_task_timeout_secs 简单学习 - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>