<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Can session_replication_role used like MySQL's BlackHole Engine?</h2>
	<h5 id="">2011-02-09 12:55:40&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201119111234570/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">&nbsp;&nbsp;&nbsp; 测试版本PostgreSQL 9.0.2<br>&nbsp;&nbsp;&nbsp; PostgreSQL数据库自带的流复制带来了非常强大的数据库容灾和负载均衡等特性体验。它告诉我们什么是TMD惊喜。预知惊喜请翻阅我以前写的两篇博客 <br>http://blog.163.com/digoal@126/blog/static/16387704020110442050808/<br>http://blog.163.com/digoal@126/blog/static/1638770402010113053825671/<br>&nbsp;&nbsp;&nbsp; 不过还是有点不完美，例如不能控制哪些表是需要复制的哪些表是不需要复制的。<br>&nbsp;&nbsp;&nbsp; 在MySQL中有一种存储引擎叫做黑洞存储引擎，配置为黑洞存储引擎的表对他做DML时啥都不做，但是可以在SLAVE端配置这个表为非黑洞引擎，那么这些DML在SLAVE端将被执行，并有作用。<br>&nbsp;&nbsp;&nbsp; 在PostgreSQL中有一个叫session_replication_role的参数，根据参数的解释:&nbsp;&nbsp;&nbsp; <tt><span style="font-family: Arial,Helvetica,Sans-Serif;"  ><br></span></tt><pre class="prettyprint"  ><p><tt><span style="font-family: Arial,Helvetica,Sans-Serif;"  ><font size="2"  >&nbsp;&nbsp;&nbsp; </font></span><font size="2"  >session_replication_role</font></tt><font size="2"  > (<tt>enum</tt>)<br>Controls firing of replication-related triggers and rules for  the         current session. &nbsp;</font></p><p><font size="2"  >Setting this variable requires          superuser privilege and results in discarding any previously cached          query plans. &nbsp;</font></p><p><font size="2"  >Possible values are <tt>origin</tt> (the default),         <tt>replica</tt> and <tt>local</tt>.        &nbsp;</font></p><p><font size="2"  >See <a rel="nofollow" href="http://www.postgresql.org/docs/9.0/static/sql-altertable.html"  >ALTER TABLE</a> for         more information. </font></p></pre>&nbsp;&nbsp;&nbsp; 在ALTER TABLE中也有一段这样的语法:&nbsp;&nbsp;&nbsp; <br><pre><pre class="prettyprint"  ><p><font size="2"  >    DISABLE TRIGGER [ <tt><i>trigger_name</i></tt> | ALL | USER ]<br>    ENABLE TRIGGER [ <tt><i>trigger_name</i></tt> | ALL | USER ]<br>    ENABLE REPLICA TRIGGER <tt><i>trigger_name</i></tt><br>    ENABLE ALWAYS TRIGGER <tt><i>trigger_name</i></tt><br>    DISABLE RULE <tt><i>rewrite_rule_name</i></tt><br>    ENABLE RULE <tt><i>rewrite_rule_name</i></tt><br>    ENABLE REPLICA RULE <tt><i>rewrite_rule_name</i></tt><br>    ENABLE ALWAYS RULE <tt><i>rewrite_rule_name</i></tt></font></p></pre><br>  从而可以根据当前SESSION的角色属性来控制rule和trigger是否生效。那么是否可以利用这个特性来控制哪些表可以被复制，哪些表不能被<br>复制呢？(如创建DO INSTEAD NOTHING的rule或触发器),欲知结果，请看如下测试:<br></pre>&nbsp;&nbsp;&nbsp; 1. 测试一 : 主库session_replication_role=origin&nbsp; hot_standby session_replication_role=replica<br>主库 :<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; show session_replication_role;<br>&nbsp;session_replication_role <br>--------------------------<br>&nbsp;origin<br>(1 row)<br>digoal=&gt; select count(*) from tbl_user;<br>&nbsp;count <br>-------<br>&nbsp;&nbsp;&nbsp; 25<br>(1 row)</font></p></pre>备库 :<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; show session_replication_role;<br>&nbsp;session_replication_role <br>--------------------------<br>&nbsp;replica<br>(1 row)<br>digoal=&gt; select count(*) from tbl_user;<br> &nbsp;count <br> -------<br> &nbsp;&nbsp;&nbsp; 25<br> (1 row)</font></p></pre>主库 : <br>新建insert do nothing的触发器,<br><pre class="prettyprint"  ><p><font size="2"  >CREATE OR REPLACE FUNCTION digoal.f_user_insert_replica()<br>&nbsp;RETURNS trigger<br>&nbsp;LANGUAGE plpgsql<br>AS $function$ begin return old; end;<br>$function$<br>create trigger t_user_insert_replica before insert on tbl_user for each row execute procedure f_user_insert_replica();<br>digoal=&gt; \d+ tbl_user</font></p></pre>默认情况下是这样的，在origin或local模式role模式生效,<br><pre class="prettyprint"  ><p><font size="2"  >Triggers:<br>&nbsp;&nbsp;&nbsp; t_user_insert_replica BEFORE INSERT ON tbl_user FOR EACH ROW EXECUTE PROCEDURE f_user_insert_replica()</font></p></pre>现在的目标是让他在replica模式生效,因此<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; alter table tbl_user disable trigger t_user_insert_replica ;<br>ALTER TABLE<br>digoal=&gt; alter table tbl_user enable replica trigger t_user_insert_replica ;<br>ALTER TABLE<br>digoal=&gt; \d+ tbl_user (已经改变为仅仅replica模式被触发)<br>Triggers firing on replica only:<br>&nbsp;&nbsp;&nbsp; t_user_insert_replica BEFORE INSERT ON tbl_user FOR EACH ROW EXECUTE PROCEDURE f_user_insert_replica()</font></p></pre>现在开始测试插入操作:<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; insert into digoal.tbl_user values (1,'zhou','digoal','sky-mobi');<br>INSERT 0 1<br>digoal=&gt; select count(*) from digoal.tbl_user;<br>&nbsp;count <br>-------<br>&nbsp;&nbsp;&nbsp; 26<br>(1 row)</font></p></pre>很明显，主库因为在origin模式所以没有触发这个触发器.记录已经插入.<br>下面看看hot_standby的情况:<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; select count(*) from tbl_user;<br>&nbsp;count <br>-------<br>&nbsp;&nbsp;&nbsp; 26<br>(1 row)</font></p></pre>很明显hot_standby也没有触发这个触发器。记录与主库一致。<br>把触发器改为origin和local触发模式，验证触发器有效性,<br>主库:<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; alter table tbl_user enable trigger t_user_insert_replica ;<br>ALTER TABLE<br>\d+ tbl_user<br>Triggers:<br>&nbsp;&nbsp;&nbsp; t_user_insert_replica BEFORE INSERT ON tbl_user FOR EACH ROW EXECUTE PROCEDURE f_user_insert_replica()<br>digoal=&gt; insert into digoal.tbl_user values (1,'zhou','digoal','sky-mobi');<br>INSERT 0 0</font></p></pre>触发器有效<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; select count(*) from digoal.tbl_user;<br>&nbsp;count <br>-------<br>&nbsp;&nbsp;&nbsp; 26<br>(1 row)</font></p></pre>hot_standby数据库:<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; select count(*) from digoal.tbl_user;<br>&nbsp;count <br>-------<br>&nbsp;&nbsp;&nbsp; 26<br>(1 row)</font></p></pre># 换成for each statement结果一样.<br><br>2. 测试二 : 看看规则行不行<br>主库:<br><pre class="prettyprint"  ><p><font size="2"  >首先删除触发器<br>digoal=&gt; drop trigger t_user_insert_replica on tbl_user;<br>创建规则<br>digoal=&gt; create or replace rule r_tbl_user_insert_replica as ON&nbsp; insert to tbl_user do instead nothing;<br>digoal=&gt; alter table tbl_user&nbsp; disable rule r_tbl_user_insert_replica ;<br>ALTER TABLE<br>digoal=&gt; alter table tbl_user enable replica rule r_tbl_user_insert_replica ;<br>ALTER TABLE<br>Rules firing on replica only:<br>&nbsp;&nbsp;&nbsp; r_tbl_user_insert_replica AS<br>&nbsp;&nbsp;&nbsp; ON INSERT TO tbl_user DO INSTEAD NOTHING<br>digoal=&gt; select count(*) from digoal.tbl_user;<br>&nbsp;count <br>-------<br>&nbsp;&nbsp;&nbsp; 26<br>(1 row)<br>digoal=&gt; insert into digoal.tbl_user values (1,'zhou','digoal','sky-mobi');<br>INSERT 0 1<br>digoal=&gt; select count(*) from digoal.tbl_user;<br>&nbsp;count <br>-------<br>&nbsp;&nbsp;&nbsp; 27<br>(1 row)</font></p></pre>hot_standby库(很明显又没有起到作用):<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; select count(*) from tbl_user;<br>&nbsp;count <br>-------<br>&nbsp;&nbsp;&nbsp; 27<br>(1 row)</font></p></pre>主库:(测试RULE有效性)<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; set session_replication_role=replica;<br>digoal=&gt; insert into digoal.tbl_user values (1,'zhou','digoal','sky-mobi');<br>INSERT 0 0<br>digoal=&gt; select count(*) from digoal.tbl_user;<br>&nbsp;count <br>-------<br>&nbsp;&nbsp;&nbsp; 27<br>(1 row)</font></p></pre><br>3. 测试三 : 修改session_replication_role<br>Primary和Slave连接使用walsender和walreceiver进程，那么会不会是slave连接到主库的模式决定了触发器或规则的触发条件呢？<br>修改主库的模式 : <br><pre class="prettyprint"  ><p><font size="2"  >vi postgresql.conf<br>session_replication_role=replica</font></p></pre>重启主库和hot_standby数据库.<br>重新以上的测试，还是没有达到预期效果.<br><br>4. 测试四 : 修改recovery.conf<br>那么会不会是需要在recovery.conf中配置呢?<br>修改hot_standby数据库的recovery.conf配置:<br><pre class="prettyprint"  ><p><font size="2"  >primary_conninfo = 'host=172.16.3.33 port=1921 user=repuser1 keepalives_idle=60 options="session_replication_role=replica"'</font></p></pre>修改后重启hot_standby数据库,报错,说明还是行不通<br>postgresql-2011-02-09_105814.csv:2011-02-09 10:58:19.593 CST,,,16375,,4d5202cb.3ff7,1,,2011-02-09 10:58:19 CST,,0,FATAL,XX000,"could not connect to the primary server: invalid connection option ""session_replication_role""<br><br>5. 测试五 : 非stream模式<br>注释掉hot_standby 数据库的配置文件recovery.conf中的primary_conninfo参数<br>重启hot_standby数据库,<br>在主库测试:<br><pre class="prettyprint"  ><p><font size="2"  >digoal=# set session session_replication_replica=replica;<br>digoal=# insert into digoal.tbl_user select * from digoal.tbl_user;<br>INSERT 0 0<br>digoal=# set session session_replication_replica=origin;<br>digoal=# insert into digoal.tbl_user select * from digoal.tbl_user;<br>INSERT 0 27<br>...<br>digoal=# insert into digoal.tbl_user select * from digoal.tbl_user;<br>INSERT 0 221184<br>digoal=# checkpoint;<br>CHECKPOINT<br>digoal=# select * from pg_switch_xlog();<br>&nbsp;pg_switch_xlog <br>----------------<br>&nbsp;4/F6536390<br>(1 row)<br><br>digoal=# checkpoint;<br>CHECKPOINT</font></p></pre>等待hot_standby数据库应用XLOG后，查看<br><pre class="prettyprint"  ><p><font size="2"  >digoal=&gt; select count(*) from digoal.tbl_user;<br>&nbsp;count&nbsp; <br>--------<br>&nbsp;442368<br>(1 row)</font></p></pre>stream和log shipping模式下得到的结果一样，<br><br>6. 测试六 : <br>开启hot_standby的DEBUG信息<br><pre class="prettyprint"  ><p><font size="2"  >debug_print_parse = on<br>debug_print_rewritten = on<br>debug_print_plan = on<br>debug_pretty_print = on<br>log_parser_stats = on<br>log_planner_stats = on<br>log_executor_stats = on</font></p></pre>在复制过程中,到hot_standby的日志中看不到相关的DEBUG信息，说明复制过程没有发生parse,rewritten,plan.executor这些事件.<br>&nbsp;参考 PostgreSQL manual 章节: Overview of PostgreSQL Internals , rule和trigger在复制时没有被触发与复制的机制和rule,trigger在数据库的执行阶段有直接关系.<br>&nbsp; 参考 源代码部分/src/backend/replication<br><br>目前想要在PostgreSQL 9.0.2 日志级复制环境中控制哪个表需要被复制，哪个表不需要被复制，使用session_replication_role和触发器或rule模式配合是行不通的。<br>当然在pgpool这类SQL级的复制中是可以行得通的.</div>
	</div>
</div>
</body>
</html>