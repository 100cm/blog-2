<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL serial global uuid stored in 64bit int8</h2>
	<h5 id="">2013-01-22 16:52:32&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201302245232286/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>Instagram 使用PostgreSQL数据库, 2012year中国PostgreSQL用户大会的时候他们来做过一次交流。</div><div>现在Instagram的月度活跃用户数已经超过9000万，每天照片上传量超4000万。</div><div>sharding, 一个非常关键的算法是如何产生所有节点全局唯一的ID。</div><div>Instagram 使用int8来存储这个唯一ID. 把64个bit位拆成3个部分, 如下 :&nbsp;</div><div>1. 最高的41个bit位, 存储从某时间点开始经过的毫秒数. (区别于UNIX epoch, 自'1970-01-01 00:00:00' 以来的秒数)</div><div>2. 接下来的13个bit位, 存储shard ID.</div><div>3. 最后10个bit位, 存储序列值.</div><div>例如 :&nbsp;</div><div>1. 指定'2010-01-01 00:00:00' 为这个起点, 这41个bit存储的是从这个起点开始历经的毫秒数.&nbsp;</div><div>&nbsp; &nbsp;41个bit位无符号的情况下可以存储2^41=2199023255552个数字, 也就是约69.7year的数据.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select (2^41)/1000/60/60/24/365.0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;?column? &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >&nbsp;69.7305700010147</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>如果把起始值设置为'2012-01-01'的话, 69.7year后也就是 '2081-09-01' 后这个算法将会有问题. 因为数值将大于41个bit位.</div><div>2. shard ID用了13个bit位, 所以可以存储8192个shard节点的信息.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select 2^13;</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;8192</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>如果每个shard节点用到1个主机, 使用这个算法的集群最大可以扩到8192个主机.</div><div>3. 序列值占用10个bit位, 可以存储1024个值.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select 2^10;</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;1024</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>因此可以这么来理解. 在1毫秒内, 每个shard节点, 允许产生1024个唯一值. 1秒产生102.4万个唯一值.</div><div>整个集群1秒允许产生102.4*8192 =&nbsp;83.88608亿个唯一值.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select 1024*1000;</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; 1024000</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>前段时间测试过2.0GHz 至强 8核的主机每秒约生成11万个序列值. 所以102.4万个唯一值这个宽度对于一台shard节点来说应该是没有问题的.</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201301591241964/"   >http://blog.163.com/digoal@126/blog/static/163877040201301591241964/</a></div><div><br></div><div>例子 :&nbsp;</div><div>假设起点为'2012-01-01', 转换成unix epoch再转换成毫秒后: 1325376000000</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select EXTRACT(EPOCH FROM '2012-01-01 00:00:00'::timestamp) * 1000;</font></div><div><font size="2"   >&nbsp; &nbsp;?column? &nbsp; &nbsp;</font></div><div><font size="2"   >---------------</font></div><div><font size="2"   >&nbsp;1325376000000</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>逻辑的shard可以使用schema来区分, 当然也可以使用database来区分. 本例使用schema来区分.</div><div>需要为每个shard创建生成全局唯一ID的函数 :&nbsp;</div><div>以 shard_id = 5 这个shard节点为例, 起始epoch = 1325376000000.</div><div>函数如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE OR REPLACE FUNCTION insta5.next_id(OUT result bigint) AS $$</font></div><div><font size="2"   >DECLARE</font></div><div><font size="2"   >&nbsp; &nbsp; our_epoch bigint := 1325376000000;</font></div><div><font size="2"   >&nbsp; &nbsp; seq_id bigint;</font></div><div><font size="2"   >&nbsp; &nbsp; now_millis bigint;</font></div><div><font size="2"   >&nbsp; &nbsp; shard_id int := 5;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; &nbsp; SELECT nextval('insta5.table_id_seq') % 1024 INTO seq_id;</font></div><div><font size="2"   >&nbsp; &nbsp; SELECT FLOOR(EXTRACT(EPOCH FROM clock_timestamp()) * 1000) INTO now_millis;</font></div><div><font size="2"   >&nbsp; &nbsp; result := (now_millis - our_epoch) &lt;&lt; 23;</font></div><div><font size="2"   >&nbsp; &nbsp; result := result | (shard_id &lt;&lt; 10);</font></div><div><font size="2"   >&nbsp; &nbsp; result := result | (seq_id);</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$$ LANGUAGE PLPGSQL;</font></div><p></p></pre></div><div>shard 5 中对应的表结构, id为全局唯一主键, 默认值来自上面的函数产生的值.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE TABLE insta5.our_table (</font></div><div><font size="2"   >&nbsp; &nbsp; "id" bigint NOT NULL DEFAULT insta5.next_id(),</font></div><div><font size="2"   >&nbsp; &nbsp; ...rest of table schema...</font></div><div><font size="2"   >)</font></div><p></p></pre></div><div><br></div><div>【小结】</div><div>1. 因为int8是带符号整型, 如果第一个BIT=1, 得出负数.&nbsp;</div><div>因此前34.87year这个函数产生的是正数, 后34.87year这个函数产生的是负数.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select 2^40/1000/60/60/24/365;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;?column? &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >&nbsp;34.8652850005074</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>例如 :&nbsp;</div><div>正值 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select date '2012-01-01'+ interval '34.8652850005074 year'</font></div><div><font size="2"   >postgres-# ;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; ?column? &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------</font></div><div><font size="2"   >&nbsp;2046-11-01 00:00:00</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# do language plpgsql $$</font></div><div><font size="2"   >DECLARE</font></div><div><font size="2"   >&nbsp; &nbsp; our_epoch bigint := 1325376000000;</font></div><div><font size="2"   >&nbsp; &nbsp; seq_id bigint;</font></div><div><font size="2"   >&nbsp; &nbsp; now_millis bigint;</font></div><div><font size="2"   >&nbsp; &nbsp; shard_id int := 5;</font></div><div><font size="2"   >&nbsp; &nbsp; result bigint;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; &nbsp; SELECT 112345 % 1024 INTO seq_id;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; SELECT FLOOR(EXTRACT(EPOCH FROM '2046-11-01 00:00:00'::timestamp) * 1000) INTO now_millis;</font></div><div><font size="2"   >&nbsp; &nbsp; result := (now_millis - our_epoch) &lt;&lt; 23;</font></div><div><font size="2"   >&nbsp; &nbsp; result := result | (shard_id &lt;&lt; 10);</font></div><div><font size="2"   >&nbsp; &nbsp; result := result | (seq_id);</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%', result;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$$;</font></div><div><font size="2"   >NOTICE: &nbsp;9221321628057605849</font></div><div><font size="2"   >DO</font></div><p></p></pre></div><div>负值 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select date '2012-01-01'+ interval '34.9652850005074 year';</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; ?column? &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------</font></div><div><font size="2"   >&nbsp;2046-12-01 00:00:00</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# do language plpgsql $$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >DECLARE</font></div><div><font size="2"   >&nbsp; &nbsp; our_epoch bigint := 1325376000000;</font></div><div><font size="2"   >&nbsp; &nbsp; seq_id bigint;</font></div><div><font size="2"   >&nbsp; &nbsp; now_millis bigint;</font></div><div><font size="2"   >&nbsp; &nbsp; shard_id int := 5;</font></div><div><font size="2"   >&nbsp; &nbsp; result bigint;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >&nbsp; &nbsp; SELECT 112345 % 1024 INTO seq_id;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; SELECT FLOOR(EXTRACT(EPOCH FROM '2046-12-01 00:00:00'::timestamp) * 1000) INTO now_millis;</font></div><div><font size="2"   >&nbsp; &nbsp; result := (now_millis - our_epoch) &lt;&lt; 23;</font></div><div><font size="2"   >&nbsp; &nbsp; result := result | (shard_id &lt;&lt; 10);</font></div><div><font size="2"   >&nbsp; &nbsp; result := result | (seq_id);</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%', result;</font></div><div><font size="2"   >END;</font></div><div><font size="2"   >$$;</font></div><div><font size="2"   >NOTICE: &nbsp;-9203679173715945767</font></div><div><font size="2"   >DO</font></div><p></p></pre></div><div>2. 这个算法的好处还有1个就是它产生的值是有顺序的, 不是无序的UUID. 因此存储顺序和索引的顺序一致性非常高.</div><div>对于使用索引查找是非常有效的.</div><div>并且这个算法对于shard也非常方便.</div><div><br></div><div>【参考】</div><div><div><img title="PostgreSQL serial global uuid stored in 64bit int8 - 德哥@Digoal - The Heart,The World."   alt="PostgreSQL serial global uuid stored in 64bit int8 - 德哥@Digoal - The Heart,The World."   style="margin:0 10px 0 0;"   src="http://img6.ph.126.net/2et-IqedZLtCMxdHKhHU0w==/6597930684261522886.jpg"   ></div></div><div>3.&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \do |</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of operators</font></div><div><font size="2"   >&nbsp; &nbsp;Schema &nbsp; | Name | Left arg type | Right arg type | Result type | &nbsp; &nbsp;Description &nbsp; &nbsp;</font></div><div><font size="2"   >------------+------+---------------+----------------+-------------+-------------------</font></div><div><font size="2"   >&nbsp;pg_catalog | | &nbsp; &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp; | bigint &nbsp; &nbsp; &nbsp;| bitwise or</font></div><p></p></pre></div><div><br></div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL serial global uuid stored in 64bit int8 - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>