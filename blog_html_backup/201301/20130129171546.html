<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.3 add Fast promote mode skips checkpoint at end of recovery</h2>
	<h5 id="">2013-01-29 17:15:46&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201302935435100/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 将新增promote的选项, -m smart | fast</div><div>1. smart 模式下promote standby数据库时, 在结束恢复后, 必须执行完一个checkpoint才激活.</div><div>2. fast 模式下promote standby数据库时, 在结束恢复后, 不需要等待checkpoin结束, 而是往XLOG中写入XLOG_END_OF_RECOVERY标记, 然后激活.</div><div>原文如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg_ctl promote -m fast will skip the checkpoint at end of recovery so that we</font></div><div><font size="2"   >can achieve very fast failover when the apply delay is low. Write new WAL record</font></div><div><font size="2"   >XLOG_END_OF_RECOVERY to allow us to switch timeline correctly for downstream log</font></div><div><font size="2"   >readers. If we skip synchronous end of recovery checkpoint we request a normal</font></div><div><font size="2"   >spread checkpoint so that the window of re-recovery is low.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Simon Riggs and Kyotaro Horiguchi, with input from Fujii Masao.</font></div><div><font size="2"   >Review by Heikki Linnakangas</font></div><p></p></pre></div><div><div style="line-height: 22px;"   >【注意】</div><div style="line-height: 22px;"   >1. 不管是哪种模式, 都需要等待已经接收到的xlog全部恢复.&nbsp;<span style="line-height: 22px;"   >所以如果standby的恢复速度与XLOG的接收量相差很大的话, fast模式也快不到哪去.</span></div></div><div>2. wal receiver进程是在apply xlog的进程逻辑(startup process)中关闭的. 如下,</div><div>src/backend/access/transam/xlog.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Check to see whether the user-specified trigger file exists and whether a</font></div><div><font size="2"   >&nbsp;* promote request has arrived. &nbsp;If either condition holds, return true.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static bool</font></div><div><font size="2"   >CheckForStandbyTrigger(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct stat stat_buf;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; static bool triggered = false;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (triggered)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (IsPromoteTriggered())</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("received promote request")));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResetPromoteTriggered();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; triggered = true;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (TriggerFile == NULL)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (stat(TriggerFile, &amp;stat_buf) == 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("trigger file found: %s", TriggerFile)));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlink(TriggerFile);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; triggered = true;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>所以在检测到触发文件或者promote_triggered=true也就是接收到pg_ctl的promote请求后, 将关闭WALreceiver进程.</div><div><br></div><div>src/backend/access/transam/xlog.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* In standby mode, wait for WAL at position 'RecPtr' to become available, either</font></div><div><font size="2"   >&nbsp;* via restore_command succeeding to restore the segment, or via walreceiver</font></div><div><font size="2"   >&nbsp;* having streamed the record (or via someone copying the segment directly to</font></div><div><font size="2"   >&nbsp;* pg_xlog, but that is not documented or recommended).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* If 'fetching_ckpt' is true, we're fetching a checkpoint record, and should</font></div><div><font size="2"   >&nbsp;* prepare to read WAL starting from RedoStartLSN after this.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 'RecPtr' might not point to the beginning of the record we're interested</font></div><div><font size="2"   >&nbsp;* in, it might also point to the page or segment header. In that case,</font></div><div><font size="2"   >&nbsp;* 'tliRecPtr' is the position of the WAL record we're interested in. It is</font></div><div><font size="2"   >&nbsp;* used to decide which timeline to stream the requested WAL from.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* When the requested record becomes available, the function opens the file</font></div><div><font size="2"   >&nbsp;* containing it (if not open already), and returns true. When end of standby</font></div><div><font size="2"   >&nbsp;* mode is triggered by the user, and there is no more WAL available, returns</font></div><div><font size="2"   >&nbsp;* false.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static bool</font></div><div><font size="2"   >WaitForWALToBecomeAvailable(XLogRecPtr RecPtr, bool randAccess,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool fetching_ckpt, XLogRecPtr tliRecPtr)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; static pg_time_t last_fail_time = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pg_time_t now;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*-------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Standby mode is implemented by a state machine:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 1. Read from archive (XLOG_FROM_ARCHIVE)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 2. Read from pg_xlog (XLOG_FROM_PG_XLOG)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 3. Check trigger file</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 4. Read from primary server via walreceiver (XLOG_FROM_STREAM)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 5. Rescan timelines</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 6. Sleep 5 seconds, and loop back to 1.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Failure to read from the current source advances the state machine to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the next state. In addition, successfully reading a file from pg_xlog</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* moves the state machine from state 2 back to state 1 (we always prefer</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* files in the archive over files in pg_xlog).</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 'currentSource' indicates the current state. There are no currentSource</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* values for "check trigger", "rescan timelines", and "sleep" states,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* those actions are taken when reading from the previous source fails, as</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* part of advancing to the next state.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*-------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >....</font></div></div><div><font size="2"   >略</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case XLOG_FROM_PG_XLOG:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Check to see if the trigger file exists. Note that we do</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* this only after failure, so when you create the trigger</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* file, we still finish replaying as much as we can from</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* archive and pg_xlog before failover.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (CheckForStandbyTrigger())</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ShutdownWalRcv();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><div><font size="2"   >略</font></div><div><font size="2"   >...</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >src/backend/postmaster/startup.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >void</font></div><div><font size="2"   >ResetPromoteTriggered(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; promote_triggered = false;</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div>【参考】<div>1.&nbsp;<a target="_blank" rel="nofollow" href="https://github.com/postgres/postgres/commit/fd4ced5230162b50a5c9d33b4bf9cfb1231aa62e"   >https://github.com/postgres/postgres/commit/fd4ced5230162b50a5c9d33b4bf9cfb1231aa62e</a><br><wbr><div><div>2. src/bin/pg_ctl/pg_ctl.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span> </span>printf(_("\nPromotion modes are:\n"));</font></div><div><font size="2"   ><span> </span>printf(_(" &nbsp;smart &nbsp; &nbsp; &nbsp; promote after performing a checkpoint\n"));</font></div><div><font size="2"   ><span> </span>printf(_(" &nbsp;fast &nbsp; &nbsp; &nbsp; &nbsp;promote quickly without waiting for checkpoint completion\n"));</font></div><p></p></pre></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >00278 static pgpid_t</font></div><div><font size="2"   >00279 get_pgpid(void)</font></div><div><font size="2"   >00280 {</font></div><div><font size="2"   >00281 &nbsp; &nbsp; FILE &nbsp; &nbsp; &nbsp; *pidf;</font></div><div><font size="2"   >00282 &nbsp; &nbsp; long &nbsp; &nbsp; &nbsp; &nbsp;pid;</font></div><div><font size="2"   >00283&nbsp;</font></div><div><font size="2"   >00284 &nbsp; &nbsp; pidf = fopen(pid_file, "r");</font></div><div><font size="2"   >00285 &nbsp; &nbsp; if (pidf == NULL)</font></div><div><font size="2"   >00286 &nbsp; &nbsp; {</font></div><div><font size="2"   >00287 &nbsp; &nbsp; &nbsp; &nbsp; /* No pid file, not an error on startup */</font></div><div><font size="2"   >00288 &nbsp; &nbsp; &nbsp; &nbsp; if (errno == ENOENT)</font></div><div><font size="2"   >00289 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"   >00290 &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >00291 &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >00292 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write_stderr(_("%s: could not open PID file \"%s\": %s\n"),</font></div><div><font size="2"   >00293 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;progname, pid_file, strerror(errno));</font></div><div><font size="2"   >00294 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit(1);</font></div><div><font size="2"   >00295 &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >00296 &nbsp; &nbsp; }</font></div><div><font size="2"   >00297 &nbsp; &nbsp; if (fscanf(pidf, "%ld", &amp;pid) != 1)</font></div><div><font size="2"   >00298 &nbsp; &nbsp; {</font></div><div><font size="2"   >00299 &nbsp; &nbsp; &nbsp; &nbsp; /* Is the file empty? */</font></div><div><font size="2"   >00300 &nbsp; &nbsp; &nbsp; &nbsp; if (ftell(pidf) == 0 &amp;&amp; feof(pidf))</font></div><div><font size="2"   >00301 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write_stderr(_("%s: the PID file \"%s\" is empty\n"),</font></div><div><font size="2"   >00302 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;progname, pid_file);</font></div><div><font size="2"   >00303 &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >00304 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write_stderr(_("%s: invalid data in PID file \"%s\"\n"),</font></div><div><font size="2"   >00305 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;progname, pid_file);</font></div><div><font size="2"   >00306 &nbsp; &nbsp; &nbsp; &nbsp; exit(1);</font></div><div><font size="2"   >00307 &nbsp; &nbsp; }</font></div><div><font size="2"   >00308 &nbsp; &nbsp; fclose(pidf);</font></div><div><font size="2"   >00309 &nbsp; &nbsp; return (pgpid_t) pid;</font></div><div><font size="2"   >00310 }</font></div><p></p></pre></div><div><pre class="prettyprint"   ><div><font size="2"   >01102 /*</font></div><div><font size="2"   >01103 &nbsp;* promote</font></div><div><font size="2"   >01104 &nbsp;*/</font></div><div><font size="2"   >01105&nbsp;</font></div><div><font size="2"   >01106 static void</font></div><div><font size="2"   >01107 do_promote(void)</font></div><div><font size="2"   >01108 {</font></div><div><font size="2"   >01109 &nbsp; &nbsp; FILE &nbsp; &nbsp; &nbsp; *prmfile;</font></div><div><font size="2"   >01110 &nbsp; &nbsp; pgpid_t &nbsp; &nbsp; pid;</font></div><div><font size="2"   >01111 &nbsp; &nbsp; struct stat statbuf;</font></div><div><font size="2"   >01112&nbsp;</font></div><div><font size="2"   >01113 &nbsp; &nbsp; pid = get_pgpid();</font></div><div><font size="2"   >01114&nbsp;</font></div><div><font size="2"   >01115 &nbsp; &nbsp; if (pid == 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* no pid file */</font></div><div><font size="2"   >01116 &nbsp; &nbsp; {</font></div><div><font size="2"   >01117 &nbsp; &nbsp; &nbsp; &nbsp; write_stderr(_("%s: PID file \"%s\" does not exist\n"), progname, pid_file);</font></div><div><font size="2"   >01118 &nbsp; &nbsp; &nbsp; &nbsp; write_stderr(_("Is server running?\n"));</font></div><div><font size="2"   >01119 &nbsp; &nbsp; &nbsp; &nbsp; exit(1);</font></div><div><font size="2"   >01120 &nbsp; &nbsp; }</font></div><div><font size="2"   >01121 &nbsp; &nbsp; else if (pid &lt; 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* standalone backend, not postmaster */</font></div><div><font size="2"   >01122 &nbsp; &nbsp; {</font></div><div><font size="2"   >01123 &nbsp; &nbsp; &nbsp; &nbsp; pid = -pid;</font></div><div><font size="2"   >01124 &nbsp; &nbsp; &nbsp; &nbsp; write_stderr(_("%s: cannot promote server; "</font></div><div><font size="2"   >01125 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"single-user server is running (PID: %ld)\n"),</font></div><div><font size="2"   >01126 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;progname, pid);</font></div><div><font size="2"   >01127 &nbsp; &nbsp; &nbsp; &nbsp; exit(1);</font></div><div><font size="2"   >01128 &nbsp; &nbsp; }</font></div><div><font size="2"   >01129&nbsp;</font></div><div><font size="2"   >01130 &nbsp; &nbsp; /* If recovery.conf doesn't exist, the server is not in standby mode */</font></div><div><font size="2"   >01131 &nbsp; &nbsp; if (stat(recovery_file, &amp;statbuf) != 0)</font></div><div><font size="2"   >01132 &nbsp; &nbsp; {</font></div><div><font size="2"   >01133 &nbsp; &nbsp; &nbsp; &nbsp; write_stderr(_("%s: cannot promote server; "</font></div><div><font size="2"   >01134 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"server is not in standby mode\n"),</font></div><div><font size="2"   >01135 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;progname);</font></div><div><font size="2"   >01136 &nbsp; &nbsp; &nbsp; &nbsp; exit(1);</font></div><div><font size="2"   >01137 &nbsp; &nbsp; }</font></div><div><font size="2"   >01138&nbsp;</font></div><div><font size="2"   >01139 &nbsp; &nbsp; /*</font></div><div><font size="2"   >01140 &nbsp; &nbsp; &nbsp;* Use two different kinds of promotion file so we can understand</font></div><div><font size="2"   >01141 &nbsp; &nbsp; &nbsp;* the difference between smart and fast promotion.</font></div><div><font size="2"   >01142 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >01143 &nbsp; &nbsp; if (shutdown_mode &gt;= FAST_MODE)</font></div><div><font size="2"   >01144 &nbsp; &nbsp; &nbsp; &nbsp; snprintf(promote_file, MAXPGPATH, "%s/fast_promote", pg_data);</font></div><div><font size="2"   >01145 &nbsp; &nbsp; else</font></div><div><font size="2"   >01146 &nbsp; &nbsp; &nbsp; &nbsp; snprintf(promote_file, MAXPGPATH, "%s/promote", pg_data);</font></div><div><font size="2"   >01147&nbsp;</font></div><div><font size="2"   >01148 &nbsp; &nbsp; if ((prmfile = fopen(promote_file, "w")) == NULL)</font></div><div><font size="2"   >01149 &nbsp; &nbsp; {</font></div><div><font size="2"   >01150 &nbsp; &nbsp; &nbsp; &nbsp; write_stderr(_("%s: could not create promote signal file \"%s\": %s\n"),</font></div><div><font size="2"   >01151 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;progname, promote_file, strerror(errno));</font></div><div><font size="2"   >01152 &nbsp; &nbsp; &nbsp; &nbsp; exit(1);</font></div><div><font size="2"   >01153 &nbsp; &nbsp; }</font></div><div><font size="2"   >01154 &nbsp; &nbsp; if (fclose(prmfile))</font></div><div><font size="2"   >01155 &nbsp; &nbsp; {</font></div><div><font size="2"   >01156 &nbsp; &nbsp; &nbsp; &nbsp; write_stderr(_("%s: could not write promote signal file \"%s\": %s\n"),</font></div><div><font size="2"   >01157 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;progname, promote_file, strerror(errno));</font></div><div><font size="2"   >01158 &nbsp; &nbsp; &nbsp; &nbsp; exit(1);</font></div><div><font size="2"   >01159 &nbsp; &nbsp; }</font></div><div><font size="2"   >01160&nbsp;</font></div><div><font size="2"   >01161 &nbsp; &nbsp; sig = SIGUSR1;</font></div><div><font size="2"   >01162 &nbsp; &nbsp; if (kill((pid_t) pid, sig) != 0)</font></div><div><font size="2"   >01163 &nbsp; &nbsp; {</font></div><div><font size="2"   >01164 &nbsp; &nbsp; &nbsp; &nbsp; write_stderr(_("%s: could not send promote signal (PID: %ld): %s\n"),</font></div><div><font size="2"   >01165 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;progname, pid, strerror(errno));</font></div><div><font size="2"   >01166 &nbsp; &nbsp; &nbsp; &nbsp; if (unlink(promote_file) != 0)</font></div><div><font size="2"   >01167 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write_stderr(_("%s: could not remove promote signal file \"%s\": %s\n"),</font></div><div><font size="2"   >01168 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;progname, promote_file, strerror(errno));</font></div><div><font size="2"   >01169 &nbsp; &nbsp; &nbsp; &nbsp; exit(1);</font></div><div><font size="2"   >01170 &nbsp; &nbsp; }</font></div><div><font size="2"   >01171&nbsp;</font></div><div><font size="2"   >01172 &nbsp; &nbsp; print_msg(_("server promoting\n"));</font></div><div><font size="2"   >01173 }</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >3. src/backend/postmaster/postmaster.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >04617 /*</font></div><div><font size="2"   >04618 &nbsp;* sigusr1_handler - handle signal conditions from child processes</font></div><div><font size="2"   >04619 &nbsp;*/</font></div><div><font size="2"   >04620 static void</font></div><div><font size="2"   >04621 sigusr1_handler(SIGNAL_ARGS)</font></div><div><font size="2"   >04622 {</font></div><div><font size="2"   >04623 &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;</font></div><div><font size="2"   >04624&nbsp;</font></div><div><font size="2"   >04625 &nbsp; &nbsp; PG_SETMASK(&amp;BlockSig);</font></div><div><font size="2"   >04626&nbsp;</font></div><div><font size="2"   >04627 &nbsp; &nbsp; /*</font></div><div><font size="2"   >04628 &nbsp; &nbsp; &nbsp;* RECOVERY_STARTED and BEGIN_HOT_STANDBY signals are ignored in</font></div><div><font size="2"   >04629 &nbsp; &nbsp; &nbsp;* unexpected states. If the startup process quickly starts up, completes</font></div><div><font size="2"   >04630 &nbsp; &nbsp; &nbsp;* recovery, exits, we might process the death of the startup process</font></div><div><font size="2"   >04631 &nbsp; &nbsp; &nbsp;* first. We don't want to go back to recovery in that case.</font></div><div><font size="2"   >04632 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >04633 &nbsp; &nbsp; if (CheckPostmasterSignal(PMSIGNAL_RECOVERY_STARTED) &amp;&amp;</font></div><div><font size="2"   >04634 &nbsp; &nbsp; &nbsp; &nbsp; pmState == PM_STARTUP &amp;&amp; Shutdown == NoShutdown)</font></div><div><font size="2"   >04635 &nbsp; &nbsp; {</font></div><div><font size="2"   >04636 &nbsp; &nbsp; &nbsp; &nbsp; /* WAL redo has started. We're out of reinitialization. */</font></div><div><font size="2"   >04637 &nbsp; &nbsp; &nbsp; &nbsp; FatalError = false;</font></div><div><font size="2"   >04638&nbsp;</font></div><div><font size="2"   >04639 &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >04640 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Crank up the background tasks. &nbsp;It doesn't matter if this fails,</font></div><div><font size="2"   >04641 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we'll just try again later.</font></div><div><font size="2"   >04642 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >04643 &nbsp; &nbsp; &nbsp; &nbsp; Assert(CheckpointerPID == 0);</font></div><div><font size="2"   >04644 &nbsp; &nbsp; &nbsp; &nbsp; CheckpointerPID = StartCheckpointer();</font></div><div><font size="2"   >04645 &nbsp; &nbsp; &nbsp; &nbsp; Assert(BgWriterPID == 0);</font></div><div><font size="2"   >04646 &nbsp; &nbsp; &nbsp; &nbsp; BgWriterPID = StartBackgroundWriter();</font></div><div><font size="2"   >04647&nbsp;</font></div><div><font size="2"   >04648 &nbsp; &nbsp; &nbsp; &nbsp; pmState = PM_RECOVERY;</font></div><div><font size="2"   >04649 &nbsp; &nbsp; }</font></div><div><font size="2"   >04650 &nbsp; &nbsp; if (CheckPostmasterSignal(PMSIGNAL_BEGIN_HOT_STANDBY) &amp;&amp;</font></div><div><font size="2"   >04651 &nbsp; &nbsp; &nbsp; &nbsp; pmState == PM_RECOVERY &amp;&amp; Shutdown == NoShutdown)</font></div><div><font size="2"   >04652 &nbsp; &nbsp; {</font></div><div><font size="2"   >04653 &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >04654 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Likewise, start other special children as needed.</font></div><div><font size="2"   >04655 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >04656 &nbsp; &nbsp; &nbsp; &nbsp; Assert(PgStatPID == 0);</font></div><div><font size="2"   >04657 &nbsp; &nbsp; &nbsp; &nbsp; PgStatPID = pgstat_start();</font></div><div><font size="2"   >04658&nbsp;</font></div><div><font size="2"   >04659 &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,</font></div><div><font size="2"   >04660 &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("database system is ready to accept read only connections")));</font></div><div><font size="2"   >04661&nbsp;</font></div><div><font size="2"   >04662 &nbsp; &nbsp; &nbsp; &nbsp; pmState = PM_HOT_STANDBY;</font></div><div><font size="2"   >04663&nbsp;</font></div><div><font size="2"   >04664 &nbsp; &nbsp; &nbsp; &nbsp; /* Some workers may be scheduled to start now */</font></div><div><font size="2"   >04665 &nbsp; &nbsp; &nbsp; &nbsp; StartOneBackgroundWorker();</font></div><div><font size="2"   >04666 &nbsp; &nbsp; }</font></div><div><font size="2"   >04667&nbsp;</font></div><div><font size="2"   >04668 &nbsp; &nbsp; if (CheckPostmasterSignal(PMSIGNAL_WAKEN_ARCHIVER) &amp;&amp;</font></div><div><font size="2"   >04669 &nbsp; &nbsp; &nbsp; &nbsp; PgArchPID != 0)</font></div><div><font size="2"   >04670 &nbsp; &nbsp; {</font></div><div><font size="2"   >04671 &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >04672 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Send SIGUSR1 to archiver process, to wake it up and begin archiving</font></div><div><font size="2"   >04673 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* next transaction log file.</font></div><div><font size="2"   >04674 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >04675 &nbsp; &nbsp; &nbsp; &nbsp; signal_child(PgArchPID, SIGUSR1);</font></div><div><font size="2"   >04676 &nbsp; &nbsp; }</font></div><div><font size="2"   >04677&nbsp;</font></div><div><font size="2"   >04678 &nbsp; &nbsp; if (CheckPostmasterSignal(PMSIGNAL_ROTATE_LOGFILE) &amp;&amp;</font></div><div><font size="2"   >04679 &nbsp; &nbsp; &nbsp; &nbsp; SysLoggerPID != 0)</font></div><div><font size="2"   >04680 &nbsp; &nbsp; {</font></div><div><font size="2"   >04681 &nbsp; &nbsp; &nbsp; &nbsp; /* Tell syslogger to rotate logfile */</font></div><div><font size="2"   >04682 &nbsp; &nbsp; &nbsp; &nbsp; signal_child(SysLoggerPID, SIGUSR1);</font></div><div><font size="2"   >04683 &nbsp; &nbsp; }</font></div><div><font size="2"   >04684&nbsp;</font></div><div><font size="2"   >04685 &nbsp; &nbsp; if (CheckPostmasterSignal(PMSIGNAL_START_AUTOVAC_LAUNCHER) &amp;&amp;</font></div><div><font size="2"   >04686 &nbsp; &nbsp; &nbsp; &nbsp; Shutdown == NoShutdown)</font></div><div><font size="2"   >04687 &nbsp; &nbsp; {</font></div><div><font size="2"   >04688 &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >04689 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Start one iteration of the autovacuum daemon, even if autovacuuming</font></div><div><font size="2"   >04690 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* is nominally not enabled. &nbsp;This is so we can have an active defense</font></div><div><font size="2"   >04691 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* against transaction ID wraparound. &nbsp;We set a flag for the main loop</font></div><div><font size="2"   >04692 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to do it rather than trying to do it here --- this is because the</font></div><div><font size="2"   >04693 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* autovac process itself may send the signal, and we want to handle</font></div><div><font size="2"   >04694 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* that by launching another iteration as soon as the current one</font></div><div><font size="2"   >04695 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* completes.</font></div><div><font size="2"   >04696 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >04697 &nbsp; &nbsp; &nbsp; &nbsp; start_autovac_launcher = true;</font></div><div><font size="2"   >04698 &nbsp; &nbsp; }</font></div><div><font size="2"   >04699&nbsp;</font></div><div><font size="2"   >04700 &nbsp; &nbsp; if (CheckPostmasterSignal(PMSIGNAL_START_AUTOVAC_WORKER) &amp;&amp;</font></div><div><font size="2"   >04701 &nbsp; &nbsp; &nbsp; &nbsp; Shutdown == NoShutdown)</font></div><div><font size="2"   >04702 &nbsp; &nbsp; {</font></div><div><font size="2"   >04703 &nbsp; &nbsp; &nbsp; &nbsp; /* The autovacuum launcher wants us to start a worker process. */</font></div><div><font size="2"   >04704 &nbsp; &nbsp; &nbsp; &nbsp; StartAutovacuumWorker();</font></div><div><font size="2"   >04705 &nbsp; &nbsp; }</font></div><div><font size="2"   >04706&nbsp;</font></div><div><font size="2"   >04707 &nbsp; &nbsp; if (CheckPostmasterSignal(PMSIGNAL_START_WALRECEIVER) &amp;&amp;</font></div><div><font size="2"   >04708 &nbsp; &nbsp; &nbsp; &nbsp; WalReceiverPID == 0 &amp;&amp;</font></div><div><font size="2"   >04709 &nbsp; &nbsp; &nbsp; &nbsp; (pmState == PM_STARTUP || pmState == PM_RECOVERY ||</font></div><div><font size="2"   >04710 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pmState == PM_HOT_STANDBY || pmState == PM_WAIT_READONLY) &amp;&amp;</font></div><div><font size="2"   >04711 &nbsp; &nbsp; &nbsp; &nbsp; Shutdown == NoShutdown)</font></div><div><font size="2"   >04712 &nbsp; &nbsp; {</font></div><div><font size="2"   >04713 &nbsp; &nbsp; &nbsp; &nbsp; /* Startup Process wants us to start the walreceiver process. */</font></div><div><font size="2"   >04714 &nbsp; &nbsp; &nbsp; &nbsp; WalReceiverPID = StartWalReceiver();</font></div><div><font size="2"   >04715 &nbsp; &nbsp; }</font></div><div><font size="2"   >04716&nbsp;</font></div><div><font size="2"   >04717 &nbsp; &nbsp; if (CheckPostmasterSignal(PMSIGNAL_ADVANCE_STATE_MACHINE) &amp;&amp;</font></div><div><font size="2"   >04718 &nbsp; &nbsp; &nbsp; &nbsp; (pmState == PM_WAIT_BACKUP || pmState == PM_WAIT_BACKENDS))</font></div><div><font size="2"   >04719 &nbsp; &nbsp; {</font></div><div><font size="2"   >04720 &nbsp; &nbsp; &nbsp; &nbsp; /* Advance postmaster's state machine */</font></div><div><font size="2"   >04721 &nbsp; &nbsp; &nbsp; &nbsp; PostmasterStateMachine();</font></div><div><font size="2"   >04722 &nbsp; &nbsp; }</font></div><div><font size="2"   >04723&nbsp;</font></div><div><font size="2"   >04724 &nbsp; &nbsp; if (CheckPromoteSignal() &amp;&amp; StartupPID != 0 &amp;&amp;</font></div><div><font size="2"   >04725 &nbsp; &nbsp; &nbsp; &nbsp; (pmState == PM_STARTUP || pmState == PM_RECOVERY ||</font></div><div><font size="2"   >04726 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pmState == PM_HOT_STANDBY || pmState == PM_WAIT_READONLY))</font></div><div><font size="2"   >04727 &nbsp; &nbsp; {</font></div><div><font size="2"   >04728 &nbsp; &nbsp; &nbsp; &nbsp; /* Tell startup process to finish recovery */</font></div><div><font size="2"   >04729 &nbsp; &nbsp; &nbsp; &nbsp; signal_child(StartupPID, SIGUSR2);</font></div><div><font size="2"   >04730 &nbsp; &nbsp; }</font></div><div><font size="2"   >04731&nbsp;</font></div><div><font size="2"   >04732 &nbsp; &nbsp; PG_SETMASK(&amp;UnBlockSig);</font></div><div><font size="2"   >04733&nbsp;</font></div><div><font size="2"   >04734 &nbsp; &nbsp; errno = save_errno;</font></div><div><font size="2"   >04735 }</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >4. src/backend/access/transam/xlog.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >09568 /*</font></div><div><font size="2"   >09569 &nbsp;* Check to see if a promote request has arrived. Should be</font></div><div><font size="2"   >09570 &nbsp;* called by postmaster after receiving SIGUSR1.</font></div><div><font size="2"   >09571 &nbsp;*/</font></div><div><font size="2"   >09572 bool</font></div><div><font size="2"   >09573 CheckPromoteSignal(void)</font></div><div><font size="2"   >09574 {</font></div><div><font size="2"   >09575 &nbsp; &nbsp; struct stat stat_buf;</font></div><div><font size="2"   >09576&nbsp;</font></div><div><font size="2"   >09577 &nbsp; &nbsp; if (stat(PROMOTE_SIGNAL_FILE, &amp;stat_buf) == 0 ||</font></div><div><font size="2"   >09578 &nbsp; &nbsp; &nbsp; &nbsp; stat(FAST_PROMOTE_SIGNAL_FILE, &amp;stat_buf) == 0)</font></div><div><font size="2"   >09579 &nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"   >09580&nbsp;</font></div><div><font size="2"   >09581 &nbsp; &nbsp; return false;</font></div><div><font size="2"   >09582 }</font></div><div></div><p></p></pre></div><div>5. src/backend/postmaster/startup.c</div><div><div><pre style="border: 1px solid rgb(196, 207, 229); background-color: rgb(251, 252, 253); padding: 4px 6px; margin: 4px 8px 4px 2px; overflow: auto; word-wrap: break-word;"   ><p><font face="monospace, fixed"   ><span style="font-size: 12px; line-height: 19px;"   >00106 /* SIGUSR2: set flag to finish recovery */ 00107 static void 00108 StartupProcTriggerHandler(SIGNAL_ARGS) 00109 { 00110     int         save_errno = errno; 00111  00112     promote_triggered = true; 00113     WakeupRecovery(); 00114  00115     errno = save_errno; 00116 }</span></font></p></pre></div><p></p></div><div><span style="line-height: 22px;"   >6. src/backend/access/transam/xlog.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >00438 &nbsp; &nbsp; /*</font></div><div><font size="2"   >00439 &nbsp; &nbsp; &nbsp;* recoveryWakeupLatch is used to wake up the startup process to continue</font></div><div><font size="2"   >00440 &nbsp; &nbsp; &nbsp;* WAL replay, if it is waiting for WAL to arrive or failover trigger file</font></div><div><font size="2"   >00441 &nbsp; &nbsp; &nbsp;* to appear.</font></div><div><font size="2"   >00442 &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >00443 &nbsp; &nbsp; Latch &nbsp; &nbsp; &nbsp; recoveryWakeupLatch;</font></div><p></p></pre></div><div><pre class="prettyprint"   ><div><font size="2"   >09584 /*</font></div><div><font size="2"   >09585 &nbsp;* Wake up startup process to replay newly arrived WAL, or to notice that</font></div><div><font size="2"   >09586 &nbsp;* failover has been requested.</font></div><div><font size="2"   >09587 &nbsp;*/</font></div><div><font size="2"   >09588 void</font></div><div><font size="2"   >09589 WakeupRecovery(void)</font></div><div><font size="2"   >09590 {</font></div><div><font size="2"   >09591 &nbsp; &nbsp; SetLatch(&amp;XLogCtl-&gt;recoveryWakeupLatch);</font></div><div><font size="2"   >09592 }</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >7. src/include/storage/latch.h</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >00090 /*</font></div><div><font size="2"   >00091 &nbsp;* Latch structure should be treated as opaque and only accessed through</font></div><div><font size="2"   >00092 &nbsp;* the public functions. It is defined here to allow embedding Latches as</font></div><div><font size="2"   >00093 &nbsp;* part of bigger structs.</font></div><div><font size="2"   >00094 &nbsp;*/</font></div><div><font size="2"   >00095 typedef struct</font></div><div><font size="2"   >00096 {</font></div><div><font size="2"   >00097 &nbsp; &nbsp; sig_atomic_t is_set;</font></div><div><font size="2"   >00098 &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;is_shared;</font></div><div><font size="2"   >00099 &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; owner_pid;</font></div><div><font size="2"   >00100 #ifdef WIN32</font></div><div><font size="2"   >00101 &nbsp; &nbsp; HANDLE &nbsp; &nbsp; &nbsp;event;</font></div><div><font size="2"   >00102 #endif</font></div><div><font size="2"   >00103 } Latch;</font></div><p></p></pre></div></div></div></div>
	</div>
</div>
</body>
</html>