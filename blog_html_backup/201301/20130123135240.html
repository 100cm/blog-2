<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.3 feature COPY Optimize, Data loaded with COPY can inited with freeze xid in some condition</h2>
	<h5 id="">2013-01-23 13:52:40&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013023111243253/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 9.3将带来令人兴奋的特性之一.</div><div>COPY的优化,</div><div>我们知道PostgreSQL 数据库的MVCC机制中需要用到tuple的xmin,xmax以及infomask,pg_clog中的信息等。</div><div>一条记录插入后xmin代表了执行这个插入SQL的事务的事务ID。</div><div>由于XID是有限的, 在经历若干个事务后, xmin或xmax必须置为frozenXID, 否则将会"消失", 注意这个"消失"不是数据没了, 而是MVCC机制导致的该TUPLE变成了未来的TUPLE, 而不可见。</div><div>因此frozen 这个动作是数据库在经常做的. 需要修改块的数据, 并且需要扫描块.</div><div>frozen也是个不小的开销.</div><div>但是PostgreSQL 9.3给大家带来了好消息, 在COPY命令中加入了freeze选项。只要符合以下三个条件, 就会在导入数据时将xmin置为frozenXID。</div><div>因此不需要后续的frozen动作。这次改进对COPY命令本身没有性能提升, 但是对于后续来说是有提升的。</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1.&nbsp;Rows will be frozen only if the table being loaded has been created in the current subtransaction,&nbsp;</font></div><div><font size="2"  >2. there are no cursors open&nbsp;<span style="line-height: 22px;"  >held by this transaction.</span></font></div><div><font size="2"  >3. there are no older snapshots held by this transaction.</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >commit信息 :&nbsp;</span></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >1. When a relfilenode is created in this subtransaction or a committed child transaction&nbsp;</font></div><div><font size="2"  >2. and it(relfilenode) cannot otherwise be seen by our own process,&nbsp;</font></div><div><font size="2"  >3. mark tuples committed ahead of transaction commit for all COPY commands in same transaction.&nbsp;</font></div><p></p></pre></div><div>&nbsp; &nbsp; (事务提交前标记tuple为committed状态, 而不需要等到事务结束后去修改infomask的信息)</div><div><pre class="prettyprint"  ><div><font size="2"  >1. If FREEZE specified on COPY</font></div><div><font size="2"  >2. and pre-conditions met&nbsp;</font></div><div><font size="2"  >then rows will also be frozen.</font></div><p></p></pre></div><div><pre class="prettyprint"  ><div><font size="2"  >Both options designed to avoid revisiting rows after commit,</font></div><div><font size="2"  >increasing performance of subsequent commands after data load and upgrade.&nbsp;</font></div><div><font size="2"  >pg_restore changes later.</font></div><p></p></pre></div></div><div>pg_restore随后将会改进, 因为pg_resotre也是通过COPY来恢复数据的, 直接置为frozenXID将减少了大量的frozen操作(块扫描以及块修改).</div><div><br></div><div>结合手册中的描述以及commit中的描述,&nbsp;<span style="line-height: 22px;"  >怎样算是满足了这3个条件呢?</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >1. 表必须是在当前事务创建的或前面已提交的前面的子事务创建的.</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >2. 如果表已经创建了, 那么如果relfilenode在本事务中或已经提交的前面的子事务中变更了. 也算满足条件</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >3. 除了当前进程, 其他进程无法看到这个relfilenode.</span></div><div style="line-height: 22px;"  >4. 执行COPY的事务没有已经打开的游标, 没有老的snapshot.</div><div><br></div><div>测试 :&nbsp;</div><div>安装数据库 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >cd&nbsp;/home/pgdev</font></div><div><font size="2"  >wget&nbsp;http://ftp.postgresql.org/pub/snapshot/dev/postgresql-snapshot.tar.bz2</font></div><div><font size="2"  >tar -jxvf&nbsp;<span style="line-height: 22px;"  >postgresql-snapshot.tar.bz2</span></font></div><div><font size="2"  ><br></font></div><div><div><span style="line-height: 22px;"  ><font size="2"  >export PGPORT=9300</font></span></div><div><font size="2"  >export PGUSER=postgres</font></div><div><font size="2"  >export PGDATA=/home/pgdev/pg_root</font></div><div><font size="2"  >export LANG=en_US.utf8</font></div><div><font size="2"  >export PGHOME=/home/pgdev/pgsql9.3</font></div><div><font size="2"  >export PGHOST=$PGDATA</font></div><div><font size="2"  >export LD_LIBRARY_PATH=$PGHOME/lib:/lib64:/usr/lib64:/usr/local/lib64:/lib:/usr/lib:/usr/local/lib</font></div><div><font size="2"  >export DATE=`date +"%Y%m%d%H%M"`</font></div><div><font size="2"  >export PATH=$PGHOME/bin:$PATH:.</font></div><div><font size="2"  >export MANPATH=$PGHOME/share/man:$MANPATH</font></div></div><div><font size="2"  ><br></font></div><div><font size="2"  >cd /home/pgdev/postgresql-9.3devel/</font></div><div><font size="2"  >./configure --prefix=/home/pgdev/pgsql9.3 --with-pgport=9300 --with-perl --with-python --with-tcl --with-openssl --with-pam --without-ldap --with-libxml --with-libxslt --enable-thread-safety --with-wal-blocksize=16 --enable-debug &amp;&amp; gmake world</font></div><div><font size="2"  >gmake install-world</font></div><div><font size="2"  >su - pgdev</font></div><div><font size="2"  >initdb -D $PGDATA -E UTF8 --locale=c -U postgres</font></div><div><font size="2"  >pg_ctl start</font></div><p></p></pre></div><div>测试 :&nbsp;</div><div><span style="line-height: 22px;"  >生成测试数据 :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# copy pg_class to '/home/pgdev/pg_class.sql';</font></div><div><font size="2"  >COPY 291</font></div><p></p></pre></div><div>测试1 , 符合在事务中新建表的条件 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >postgres=# create table test(like pg_class including all) with oids;</font></div><div><font size="2"  >CREATE TABLE</font></div><div><font size="2"  >postgres=# copy test from '/home/pgdev/pg_class.sql' freeze;</font></div><div><font size="2"  >COPY 291</font></div><div><font size="2"  >postgres=# select xmin,count(*) from test group by xmin;</font></div><div><font size="2"  >&nbsp;xmin | count&nbsp;</font></div><div><font size="2"  >------+-------</font></div><div><font size="2"  >&nbsp; &nbsp; 2 | &nbsp; 291</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>测试2 , 符合在事务中新建relfilenode的条件(truncate) :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >postgres=# truncate test;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><p></p></pre></div><div>-- 生成新的relfilenode, 这个filenode其他进程是看不到的.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# copy test from '/home/pgdev/pg_class.sql' freeze;</font></div><div><font size="2"  >COPY 291</font></div><div><font size="2"  >postgres=# select xmin,count(*) from test group by xmin;</font></div><div><font size="2"  >&nbsp;xmin | count&nbsp;</font></div><div><font size="2"  >------+-------</font></div><div><font size="2"  >&nbsp; &nbsp; 2 | &nbsp; 291</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div></div><div>测试3 , 不符合条件. 因为表不是在事务中创建的, 并且relfilenode也不是在事务中新建的 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# truncate test ;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><span style="line-height: 22px;"  ><font size="2"  >-- 生成新的relfilenode, 但是这个filenode其他进程是能看到的. 因为在事务外.</font></span></div><div><font size="2"  >postgres=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >postgres=# copy test from '/home/pgdev/pg_class.sql' freeze;</font></div><div><font size="2"  >COPY 291</font></div><div><font size="2"  >postgres=# select xmin,count(*) from test group by xmin;</font></div><div><font size="2"  >&nbsp;xmin | count&nbsp;</font></div><div><font size="2"  >------+-------</font></div><div><font size="2"  >&nbsp;1694 | &nbsp; 291</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >truncate生成filenode的解释 :&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >postgres=# select pg_relation_filepath('test'::regclass);</font></div><div><font size="2"  >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"  >----------------------</font></div><div><font size="2"  >&nbsp;base/12810/17887</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >postgres=# truncate test;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><font size="2"  >postgres=# select pg_relation_filepath('test'::regclass);</font></div><div><font size="2"  >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"  >----------------------</font></div><div><font size="2"  >&nbsp;base/12810/18183</font></div><div><font size="2"  >(1 row)</font></div></div><div><div><font size="2"  >postgres=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >postgres=# truncate test;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><font size="2"  >postgres=# select pg_relation_filepath('test'::regclass);</font></div><div><font size="2"  >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"  >----------------------</font></div><div><font size="2"  >&nbsp;base/12810/18188</font></div><div><font size="2"  >(1 row)</font></div></div><p></p></pre></div><div>其他会话看到的还是老的filenode :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# select pg_relation_filepath('test'::regclass);</font></div><div><font size="2"  >&nbsp;pg_relation_filepath&nbsp;</font></div><div><font size="2"  >----------------------</font></div><div><font size="2"  >&nbsp;base/12810/18183</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"  >测试4 , 不符合条件.&nbsp;</span>含游标的测试 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >postgres=# truncate test;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><span style="line-height: 22px;"  ><font size="2"  >postgres=# declare refcurs cursor for select * from pg_class;</font></span></div><div><font size="2"  >DECLARE CURSOR</font></div><div><font size="2"  >postgres=# select * from pg_cursors ;</font></div><div><font size="2"  >&nbsp; name &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; statement &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| is_holdable | is_binary | is_scrollable | &nbsp; &nbsp; &nbsp; &nbsp; creation_time &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >---------+----------------------------------------------------+-------------+-----------+---------------+---------------------------</font></div><div><font size="2"  >----</font></div><div><font size="2"  >&nbsp;refcurs | declare refcurs cursor for select * from pg_class; | f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | f &nbsp; &nbsp; &nbsp; &nbsp; | t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2013-01-23 13:30:31.793574</font></div><div><font size="2"  >+08</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >postgres=# copy test from '/home/pgdev/pg_class.sql' freeze;</font></div><div><font size="2"  >COPY 291</font></div><div><font size="2"  >postgres=# select xmin,count(*) from test group by xmin;</font></div><div><font size="2"  >&nbsp;xmin | count&nbsp;</font></div><div><font size="2"  >------+-------</font></div><div><font size="2"  >&nbsp;1698 | &nbsp; 291</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"  >测试5 , 不符合条件.&nbsp;</span>含已注册的snapshot的测试 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# begin TRANSACTION ISOLATION LEVEL repeatable read;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >postgres=#&nbsp;</font></div><div><font size="2"  >postgres=# SELECT pg_export_snapshot();</font></div><div><font size="2"  >&nbsp;pg_export_snapshot&nbsp;</font></div><div><font size="2"  >--------------------</font></div><div><font size="2"  >&nbsp;000006AA-1</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >postgres=# truncate test;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><font size="2"  >postgres=# copy test from '/home/pgdev/pg_class.sql' freeze;</font></div><div><font size="2"  >COPY 291</font></div><div><font size="2"  >postgres=# select xmin,count(*) from test group by xmin;</font></div><div><font size="2"  >&nbsp;xmin | count&nbsp;</font></div><div><font size="2"  >------+-------</font></div><div><font size="2"  >&nbsp;1706 | &nbsp; 291</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>xmin=2表示这个是frozenXID.</div><div>见 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><span style="color: rgb(51, 51, 51); font-family: Arial, Helvetica, simsun, u5b8bu4f53; line-height: 22px;"  ><font size="2"  >src/include/access/transam.h</font></span></div><div><span style="color: rgb(51, 51, 51); font-family: Arial, Helvetica, simsun, u5b8bu4f53; line-height: 22px;"  ><font size="2"  ><div>/* ----------------</div><div>&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Special transaction ID values</div><div>&nbsp;*</div><div>&nbsp;* BootstrapTransactionId is the XID for "bootstrap" operations, and</div><div>&nbsp;* FrozenTransactionId is used for very old tuples. &nbsp;Both should</div><div>&nbsp;* always be considered valid.</div><div>&nbsp;*</div><div>&nbsp;* FirstNormalTransactionId is the first "normal" transaction id.</div><div>&nbsp;* Note: if you need to change it, you must change pg_class.h as well.</div><div>&nbsp;* ----------------</div><div>&nbsp;*/</div><div>#define InvalidTransactionId &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;((TransactionId) 0)</div><div>#define BootstrapTransactionId &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;((TransactionId) 1)</div><div>#define FrozenTransactionId &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((TransactionId) 2)</div><div>#define FirstNormalTransactionId &nbsp; &nbsp; &nbsp; &nbsp;((TransactionId) 3)</div><div>#define MaxTransactionId &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;((TransactionId) 0xFFFFFFFF)</div></font></span></div><p></p></pre></div><div><br></div><div>【参考】</div>1.&nbsp;<wbr><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/sql-copy.html"  >http://www.postgresql.org/docs/devel/static/sql-copy.html</a><div>2.&nbsp;<a target="_blank" rel="nofollow" href="https://github.com/postgres/postgres/commit/8de72b66a2edcf12c812de0a73bd50b6b7d81d62"  >https://github.com/postgres/postgres/commit/8de72b66a2edcf12c812de0a73bd50b6b7d81d62</a><br><div>3.&nbsp;<a target="_blank" rel="nofollow" href="https://github.com/postgres/postgres/commit/ddf509eb4a163aacd59a7bbd44ba2ca9ba691da2"  >https://github.com/postgres/postgres/commit/ddf509eb4a163aacd59a7bbd44ba2ca9ba691da2</a><br><div>4.&nbsp;<a target="_blank" rel="nofollow" href="https://github.com/postgres/postgres/commit/02aea36414ecfac8d1e90fba6d4642d8d67d7aaa"  >https://github.com/postgres/postgres/commit/02aea36414ecfac8d1e90fba6d4642d8d67d7aaa</a></div><div>5.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201210134586363/"  >http://blog.163.com/digoal@126/blog/static/163877040201210134586363/</a></div><div>6.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201211259497702/"  >http://blog.163.com/digoal@126/blog/static/163877040201211259497702/</a></div><div>7.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402011830105342275/"  >http://blog.163.com/digoal@126/blog/static/1638770402011830105342275/</a></div><div>8.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201183043153622/"  >http://blog.163.com/digoal@126/blog/static/163877040201183043153622/</a></div><div>9.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012416105232835/"  >http://blog.163.com/digoal@126/blog/static/1638770402012416105232835/</a></div><div>10.&nbsp;<a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012101423358264/"  >http://blog.163.com/digoal@126/blog/static/1638770402012101423358264/</a></div><div>9.&nbsp;src/backend/utils/time/snapmgr.c</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >&nbsp;* snapmgr.c</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PostgreSQL snapshot manager</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* We keep track of snapshots in two ways: those "registered" by resowner.c,</font></div><div><font size="2"  >&nbsp;* and the "active snapshot" stack. &nbsp;All snapshots in either of them live in</font></div><div><font size="2"  >&nbsp;* persistent memory. &nbsp;When a snapshot is no longer in any of these lists</font></div><div><font size="2"  >&nbsp;* (tracked by separate refcounts on each snapshot), its memory can be freed.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* The FirstXactSnapshot, if any, is treated a bit specially: we increment its</font></div><div><font size="2"  >&nbsp;* regd_count and count it in RegisteredSnapshots, but this reference is not</font></div><div><font size="2"  >&nbsp;* tracked by a resource owner. We used to use the TopTransactionResourceOwner</font></div><div><font size="2"  >&nbsp;* to track this snapshot reference, but that introduces logical circularity</font></div><div><font size="2"  >&nbsp;* and thus makes it impossible to clean up in a sane fashion. &nbsp;It's better to</font></div><div><font size="2"  >&nbsp;* handle this reference as an internally-tracked registration, so that this</font></div><div><font size="2"  >&nbsp;* module is entirely lower-level than ResourceOwners.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Likewise, any snapshots that have been exported by pg_export_snapshot</font></div><div><font size="2"  >&nbsp;* have regd_count = 1 and are counted in RegisteredSnapshots, but are not</font></div><div><font size="2"  >&nbsp;* tracked by any resource owner.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* These arrangements let us reset MyPgXact-&gt;xmin when there are no snapshots</font></div><div><font size="2"  >&nbsp;* referenced by this transaction. &nbsp; &nbsp; &nbsp;(One possible improvement would be to be</font></div><div><font size="2"  >&nbsp;* able to advance Xmin when the snapshot with the earliest Xmin is no longer</font></div><div><font size="2"  >&nbsp;* referenced. &nbsp;That's a bit harder though, it requires more locking, and</font></div><div><font size="2"  >&nbsp;* anyway it should be rather uncommon to keep temporary snapshots referenced</font></div><div><font size="2"  >&nbsp;* for too long.)</font></div></div><div><font size="2"  >......................</font></div><div><div><font size="2"  >bool</font></div><div><font size="2"  >ThereAreNoPriorRegisteredSnapshots(void)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (RegisteredSnapshots &lt;= 1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"  >}</font></div></div><p></p></pre></div><div><span style="line-height: 22px;"  >10..&nbsp;src/backend/commands/copy.c</span></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Optimize if new relfilenode was created in this subxact or</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* one of its committed children and we won't see those rows later</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* as part of an earlier scan or command. This ensures that if this</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* subtransaction aborts then the frozen rows won't be visible</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* after xact cleanup. Note that the stronger test of exactly</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* which subtransaction created it is crucial for correctness</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* of this optimisation.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* As noted above rd_newRelfilenodeSubid is not set in all cases</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* where we can apply the optimization, so in those rare cases</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* where we cannot honour the request we do so silently.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (cstate-&gt;freeze &amp;&amp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ThereAreNoPriorRegisteredSnapshots() &amp;&amp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ThereAreNoReadyPortals() &amp;&amp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cstate-&gt;rel-&gt;rd_newRelfilenodeSubid == GetCurrentSubTransactionId() ||</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cstate-&gt;rel-&gt;rd_createSubid == GetCurrentSubTransactionId()))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hi_options |= HEAP_INSERT_FROZEN;</font></div><p></p></pre></div></div></div></div></div>
	</div>
</div>
</body>
</html>