<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL add 2 DML LOCK TUPLE MODE to 4</h2>
	<h5 id="">2013-01-30 17:44:04&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020130305109687/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>本文主要是这篇博客的扩展,</div><div><div style="line-height: 22px;"  >《PostgreSQL performance speedup by avoid lock references tuple when add or update(new) Foreign Key's value.》</div><div style="line-height: 22px;"  ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020130249109133/"  >http://blog.163.com/digoal@126/blog/static/16387704020130249109133/</a></div></div><div style="line-height: 22px;"  ><br></div><div>使用数据库的朋友应该都认同这个观点: 锁粒度越细致, 并发写锁等待的概率就越低, 因此可以大大提高数据库的并发写能力.</div><div>PostgreSQL 在行锁级别提供了2种模式,SELECT FOR SHARE和SELECT FOR UPDATE.&nbsp;</div><div>select for share的锁和select for share的锁不会冲突. 但是和select for update冲突.</div><div>for update和 for update以及for share都冲突.&nbsp;</div><div>for share 的应用场景, 多个会话可能都要取这些被锁行的数据, 但是不允许任何人更改这些数据.&nbsp;</div><div>for update 的应用场景, 单一会话需要更改这些被锁行的数据. 其他会话如果要更改那么就等待.&nbsp;</div><div>现在PostgreSQL又添加了2个行锁类型, 分别是select for key share和select for no key update.</div><div><br></div><div>【用法】</div><div><h3 style="margin: 2ex 0em 1.2em; color: rgb(102, 102, 102); font-family: verdana, sans-serif; line-height: normal;"  ><font size="2"  ><tt>FOR UPDATE</tt>,&nbsp;<tt>FOR NO KEY UPDATE</tt>/<tt>FOR SHARE</tt>/<tt>FOR KEY SHARE</tt>&nbsp;Clauses</font></h3><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"  ><font size="2"  ><tt>FOR UPDATE</tt>,&nbsp;<tt>FOR NO KEY UPDATE</tt>,&nbsp;<tt>FOR SHARE</tt>&nbsp;and&nbsp;<tt>FOR KEY SHARE</tt>&nbsp;are&nbsp;<i>locking clauses</i>; they affect how&nbsp;<tt>SELECT</tt>&nbsp;locks rows as they are obtained from the table.</font></p><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"  ><font size="2"  >The&nbsp;<tt>FOR UPDATE</tt>&nbsp;clause has this form:</font></p><pre style="-webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border: 1px solid rgb(207, 207, 207); padding: 2ex; margin-top: 2ex; margin-bottom: 2ex; margin-left: 2ex; overflow: auto; border-top-left-radius: 8px; border-top-right-radius: 8px; border-bottom-right-radius: 8px; border-bottom-left-radius: 8px; background-color: rgb(247, 247, 247); line-height: normal;"  ><font size="2"  >FOR UPDATE [ OF <tt style="font-weight: bold; font-style: italic;"  >table_name</tt> [, ...] ] [ NOWAIT ] </font></pre><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"  ><font size="2"  >The&nbsp;<tt>FOR NO KEY UPDATE</tt>&nbsp;clause has this form:</font></p><pre style="-webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border: 1px solid rgb(207, 207, 207); padding: 2ex; margin-top: 2ex; margin-bottom: 2ex; margin-left: 2ex; overflow: auto; border-top-left-radius: 8px; border-top-right-radius: 8px; border-bottom-right-radius: 8px; border-bottom-left-radius: 8px; background-color: rgb(247, 247, 247); line-height: normal;"  ><font size="2"  >FOR NO KEY UPDATE [ OF <tt style="font-weight: bold; font-style: italic;"  >table_name</tt> [, ...] ] [ NOWAIT ] </font></pre><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"  ><font size="2"  >The closely related&nbsp;<tt>FOR SHARE</tt>&nbsp;clause has this form:</font></p><pre style="-webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border: 1px solid rgb(207, 207, 207); padding: 2ex; margin-top: 2ex; margin-bottom: 2ex; margin-left: 2ex; overflow: auto; border-top-left-radius: 8px; border-top-right-radius: 8px; border-bottom-right-radius: 8px; border-bottom-left-radius: 8px; background-color: rgb(247, 247, 247); line-height: normal;"  ><font size="2"  >FOR SHARE [ OF <tt style="font-weight: bold; font-style: italic;"  >table_name</tt> [, ...] ] [ NOWAIT ] </font></pre><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"  ><font size="2"  >Similarly, the&nbsp;<tt>FOR KEY SHARE</tt>&nbsp;clause has this form:</font></p><pre style="-webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border: 1px solid rgb(207, 207, 207); padding: 2ex; margin-top: 2ex; margin-bottom: 2ex; margin-left: 2ex; overflow: auto; border-top-left-radius: 8px; border-top-right-radius: 8px; border-bottom-right-radius: 8px; border-bottom-left-radius: 8px; background-color: rgb(247, 247, 247); line-height: normal;"  ><font size="2"  >FOR KEY SHARE [ OF <tt style="font-weight: bold; font-style: italic;"  >table_name</tt> [, ...] ] [ NOWAIT ]</font><span style="font-size: 13.333333969116211px;"  > </span></pre><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"  ><font size="2"  ><tt>FOR UPDATE</tt>&nbsp;causes the rows retrieved by the&nbsp;<tt>SELECT</tt>&nbsp;statement to be locked as though for update. This prevents them from being modified or deleted by other transactions until the current transaction ends. That is, other transactions that attempt&nbsp;<tt>UPDATE</tt>,&nbsp;<tt>DELETE</tt>,&nbsp;<tt>SELECT FOR UPDATE</tt>,&nbsp;<tt>SELECT FOR SHARE</tt>&nbsp;or&nbsp;<tt>SELECT FOR KEY SHARE</tt>&nbsp;of these rows will be blocked until the current transaction ends. The&nbsp;<tt>FOR UPDATE</tt>&nbsp;lock mode is also acquired by any&nbsp;<tt>DELETE</tt>&nbsp;on a row, and also by an&nbsp;<tt>UPDATE</tt>&nbsp;that modifies the values on certain columns. Currently, the set of columns considered for the&nbsp;<tt>UPDATE</tt>&nbsp;case are those that have an unique index on them that can be used in a foreign key (so partial indexes and expressional indexes are not considered), but this may change in the future. Also, if an&nbsp;<tt>UPDATE</tt>,&nbsp;<tt>DELETE</tt>, or&nbsp;<tt>SELECT FOR UPDATE</tt>&nbsp;from another transaction has already locked a selected row or rows,&nbsp;<tt>SELECT FOR UPDATE</tt>&nbsp;will wait for the other transaction to complete, and will then lock and return the updated row (or no row, if the row was deleted). Within a&nbsp;<tt>REPEATABLE READ</tt>&nbsp;or&nbsp;<tt>SERIALIZABLE</tt>transaction, however, an error will be thrown if a row to be locked has changed since the transaction started. For further discussion see&nbsp;<a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/mvcc.html"  >Chapter 13</a>.</font></p><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"  ><font size="2"  ><tt>FOR NO KEY UPDATE</tt>&nbsp;behaves similarly, except that the lock acquired is weaker: this lock will not block&nbsp;<tt>SELECT FOR KEY SHARE</tt>&nbsp;commands that attempt to acquire a lock on the same rows.</font></p><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"  ><font size="2"  ><tt>FOR SHARE</tt>&nbsp;behaves similarly, except that it acquires a shared rather than exclusive lock on each retrieved row. A shared lock blocks other transactions from performing&nbsp;<tt>UPDATE</tt>,<tt>DELETE</tt>, or&nbsp;<tt>SELECT FOR UPDATE</tt>&nbsp;on these rows, but it does not prevent them from performing&nbsp;<tt>SELECT FOR SHARE</tt>&nbsp;or&nbsp;<tt>SELECT FOR KEY SHARE</tt>.</font></p><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"  ><font size="2"  ><tt>FOR KEY SHARE</tt>&nbsp;behaves similarly to&nbsp;<tt>FOR SHARE</tt>, except that the lock is weaker:&nbsp;<tt>SELECT FOR UPDATE</tt>&nbsp;is blocked, but not&nbsp;<tt>SELECT FOR NO KEY UPDATE</tt>. A key-shared lock blocks other transactions from performing&nbsp;<tt>DELETE</tt>&nbsp;or any&nbsp;<tt>UPDATE</tt>&nbsp;that changes the key values, but not other&nbsp;<tt>UPDATE</tt>, and neither it does prevent&nbsp;<tt>SELECT FOR UPDATE</tt>,&nbsp;<tt>SELECT FOR SHARE</tt>, or&nbsp;<tt>SELECT FOR KEY SHARE</tt>.</font></p></div><div><br></div><div>【测试】</div><div>以下将针对前面那篇BLOG的测试场景, 重新测试一下增加了这2个锁模式后, FOREIGN TABLE更新的情况.&nbsp;</div><div>测试结果表明, 已经和ORACLE的测试一致. 不需要等待了.</div><div>测试数据 :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# CREATE TABLE A (</font></div><div><font size="2"  >digoal(# &nbsp; &nbsp; &nbsp; &nbsp; AID integer not null,</font></div><div><font size="2"  >digoal(# &nbsp; &nbsp; &nbsp; &nbsp; Col1 integer,</font></div><div><font size="2"  >digoal(# &nbsp; &nbsp; &nbsp; &nbsp; PRIMARY KEY (AID)</font></div><div><font size="2"  >digoal(# &nbsp; );</font></div><div><font size="2"  >CREATE TABLE</font></div><div><font size="2"  >digoal=#&nbsp;</font></div><div><font size="2"  >digoal=# &nbsp; CREATE TABLE B (</font></div><div><font size="2"  >digoal(# &nbsp; &nbsp; &nbsp; &nbsp; BID integer not null,</font></div><div><font size="2"  >digoal(# &nbsp; &nbsp; &nbsp; &nbsp; AID integer not null,</font></div><div><font size="2"  >digoal(# &nbsp; &nbsp; &nbsp; &nbsp; Col2 integer,</font></div><div><font size="2"  >digoal(# &nbsp; &nbsp; &nbsp; &nbsp; PRIMARY KEY (BID),</font></div><div><font size="2"  >digoal(# &nbsp; &nbsp; &nbsp; &nbsp; FOREIGN KEY (AID) REFERENCES A(AID)</font></div><div><font size="2"  >digoal(# &nbsp; );</font></div><div><font size="2"  >CREATE TABLE</font></div><div><font size="2"  >digoal=# INSERT INTO A (AID) VALUES (1),(2);</font></div><div><font size="2"  >INSERT 0 2</font></div><div><font size="2"  >digoal=# &nbsp; INSERT INTO B (BID,AID) VALUES (2,1);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >digoal=# create extension pgrowlocks;</font></div><div><font size="2"  >CREATE EXTENSION</font></div><p></p></pre></div><div><br></div><div>场景1 :</div><div>SESSION A :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >digoal=# insert into b (aid,bid) values (1,1);</font></div><div><font size="2"  >INSERT 0 1</font></div></pre></div></div><div>SESSION B :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=# select * from pgrowlocks('a');</font></div><div><font size="2"  >&nbsp;locked_row | locker | multi | &nbsp;xids &nbsp;| &nbsp; &nbsp; &nbsp; modes &nbsp; &nbsp; &nbsp; | &nbsp;pids &nbsp;&nbsp;</font></div><div><font size="2"  >------------+--------+-------+--------+-------------------+---------</font></div><div><font size="2"  >&nbsp;(0,1) &nbsp; &nbsp; &nbsp;| &nbsp; 1706 | f &nbsp; &nbsp; | {1706} | {"For Key Share"} | {18172}</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >-- 注意锁模式是<span style="line-height: 22px;"  >"For Key Share"</span></font></div><div><font size="2"  >digoal=# select * from pgrowlocks('b');</font></div><div><font size="2"  >&nbsp;locked_row | locker | multi | xids | modes | pids&nbsp;</font></div><div><font size="2"  >------------+--------+-------+------+-------+------</font></div><div><font size="2"  >(0 rows)</font></div><div><font size="2"  >digoal=# select * from a where ctid='(0,1)';</font></div><div><font size="2"  >&nbsp;aid | col1&nbsp;</font></div><div><font size="2"  >-----+------</font></div><div><font size="2"  >&nbsp; &nbsp;1 | &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >digoal=# update a set col1=22 where aid=1;</font></div><div><font size="2"  >UPDATE 1</font></div></div><div><font size="2"  >-- 更新A表的非键值无需等待</font></div><p></p></pre></div><div><br></div><div>场景2 :&nbsp;</div><div>SESSION A :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >digoal=# update b set aid=2 where aid&lt;&gt;2;</font></div><div><font size="2"  >UPDATE 2</font></div></pre></div><div>SESSION B :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=# select * from pgrowlocks('a');</font></div><div><font size="2"  >&nbsp;locked_row | locker | multi | &nbsp;xids &nbsp;| &nbsp; &nbsp; &nbsp; modes &nbsp; &nbsp; &nbsp; | &nbsp;pids &nbsp;&nbsp;</font></div><div><font size="2"  >------------+--------+-------+--------+-------------------+---------</font></div><div><font size="2"  >&nbsp;(0,2) &nbsp; &nbsp; &nbsp;| &nbsp; 1708 | f &nbsp; &nbsp; | {1708} | {"For Key Share"} | {18172}</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><span style="line-height: 22px;"  >-- 注意锁模式是</span><span style="line-height: 22px;"  >"For Key Share"</span></font></div><div><font size="2"  >digoal=# select * from a where ctid='(0,2)';</font></div><div><font size="2"  >&nbsp;aid | col1&nbsp;</font></div><div><font size="2"  >-----+------</font></div><div><font size="2"  >&nbsp; &nbsp;2 | &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  >digoal=# update a set col1=22 where aid=2;</font></div><div><font size="2"  >UPDATE 1</font></div></div><div><font size="2"  ><span style="line-height: 22px;"  >--&nbsp;</span><span style="line-height: 19px;"  >更新A表的非键值无需等待</span></font></div><p></p></pre></div><div>那么会话B更新A表的时候, 是什么锁呢, 来看</div><div>场景3 :&nbsp;</div><div>SESSION A :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >digoal=# update b set aid=2 where aid&lt;&gt;2;</font></div><div><font size="2"  >UPDATE 2</font></div></pre></div><div>SESSION B :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# begin;</font></div><div><font size="2"  >BEGIN</font></div><div><font size="2"  >digoal=# update a set col1=22 where aid=1;</font></div><div><font size="2"  >UPDATE 1</font></div><div><font size="2"  >digoal=# update a set col1=22 where aid=2;</font></div><div><font size="2"  >UPDATE 1</font></div></pre></div><div>SESSION C :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >-- 一定要在第三个会话才能看到这些锁的状态.</font></div><div><font size="2"  >-- 因为MVCC, 本地会话看到的是已经更新后的TUPLE, 新的tuple头上的infomask的信息.</font></div><div><font size="2"  >-- 要看旧版本的infomask, 必须在其他会话查看. </font></div><div><div><font size="2"  >digoal=# select * from pgrowlocks('a');</font></div><div><font size="2"  >&nbsp;locked_row | locker | multi | &nbsp; &nbsp;xids &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; pids &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >------------+--------+-------+-------------+-------------------------------+---------------</font></div><div><font size="2"  >&nbsp;(0,3) &nbsp; &nbsp; &nbsp;| &nbsp; 1710 | f &nbsp; &nbsp; | {1710} &nbsp; &nbsp; &nbsp;| {Update} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| {18332}</font></div><div><font size="2"  >&nbsp;(0,4) &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;3 | t &nbsp; &nbsp; | {1708,1710} | {"Key Share","No Key Update"} | {18172,18332}</font></div><div><font size="2"  >(2 rows)</font></div></div><div><font size="2"  >-- 注意会话B获取了1个<span style="line-height: 22px;"  >No Key Update</span>锁, 就是<span style="line-height: 22px;"  >digoal=# update a set col1=22 where aid=2;这条产生的.</span></font></div><div><span style="line-height: 22px;"  ><font size="2"  >因为更新的不是键值相关的.</font></span></div><div><div><font size="2"  >digoal=# select * from pgrowlocks('b');</font></div><div><font size="2"  >&nbsp;locked_row | locker | multi | &nbsp;xids &nbsp;| &nbsp;modes &nbsp; | &nbsp;pids &nbsp;&nbsp;</font></div><div><font size="2"  >------------+--------+-------+--------+----------+---------</font></div><div><font size="2"  >&nbsp;(0,1) &nbsp; &nbsp; &nbsp;| &nbsp; 1708 | f &nbsp; &nbsp; | {1708} | {Update} | {18172}</font></div><div><font size="2"  >&nbsp;(0,2) &nbsp; &nbsp; &nbsp;| &nbsp; 1708 | f &nbsp; &nbsp; | {1708} | {Update} | {18172}</font></div><div><font size="2"  >(2 rows)</font></div></div><p></p></pre></div><div><br></div><div>【其他】</div><div>1. 获取锁时遵循先获取轻量级锁的原则. 例如以下代码.</div><div>src/backend/access/heap/heapam.c</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If we're not updating any "key" column, we can grab a weaker lock type.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* This allows for more concurrency when we are running simultaneously with</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* foreign key checks.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note that if a column gets detoasted while executing the update, but the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* value ends up being the same, this test will fail and we will use the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* stronger lock. &nbsp;This is acceptable; the important case to optimize is</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* updates that don't manipulate key columns, not those that</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* serendipitiously arrive at the same key values.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; HeapSatisfiesHOTandKeyUpdate(relation, hot_attrs, key_attrs,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;satisfies_hot, &amp;satisfies_key,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;oldtup, newtup);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (satisfies_key)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *lockmode = LockTupleNoKeyExclusive;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mxact_status = MultiXactStatusNoKeyUpdate;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_intact = true;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If this is the first possibly-multixact-able operation in the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* current transaction, set my per-backend OldestMemberMXactId setting.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We can be certain that the transaction will never become a member of</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* any older MultiXactIds than that. &nbsp;(We have to do this even if we</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* end up just using our own TransactionId below, since some other</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* backend could incorporate our XID into a MultiXact immediately</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* afterwards.)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactIdSetOldestMember();</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *lockmode = LockTupleExclusive;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mxact_status = MultiXactStatusUpdate;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_intact = false;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div><div><br></div>【参考】<div>1. 《PostgreSQL performance speedup by avoid lock references tuple when add or update(new) Foreign Key's value.》</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020130249109133/"  >http://blog.163.com/digoal@126/blog/static/16387704020130249109133/</a></div><div>2.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/sql-select.html"  >http://www.postgresql.org/docs/devel/static/sql-select.html</a></div><div>3.&nbsp;src/include/access/heapam.h</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Possible lock modes for a tuple.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >typedef enum LockTupleMode</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* SELECT FOR KEY SHARE */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LockTupleKeyShare,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* SELECT FOR SHARE */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LockTupleShare,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* SELECT FOR NO KEY UPDATE, and UPDATEs that don't modify key columns */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LockTupleNoKeyExclusive,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* SELECT FOR UPDATE, UPDATEs that modify key columns, and DELETE */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LockTupleExclusive</font></div><div><font size="2"  >} LockTupleMode;</font></div><p></p></pre></div>4.&nbsp;src/backend/access/heap/README.tuplock<div>5. 4种锁的冲突表如下</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; KEY UPDATE &nbsp; &nbsp; &nbsp; &nbsp;UPDATE &nbsp; &nbsp; &nbsp; &nbsp;SHARE &nbsp; &nbsp; &nbsp; &nbsp;KEY SHARE</font></div><div><font size="2"  >KEY UPDATE &nbsp; &nbsp; &nbsp; conflict &nbsp; &nbsp; &nbsp; &nbsp;conflict &nbsp; &nbsp; &nbsp;conflict &nbsp; &nbsp; &nbsp;conflict</font></div><div><font size="2"  >UPDATE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conflict &nbsp; &nbsp; &nbsp; &nbsp;conflict &nbsp; &nbsp; &nbsp;conflict</font></div><div><font size="2"  >SHARE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;conflict &nbsp; &nbsp; &nbsp; &nbsp;conflict</font></div><div><font size="2"  >KEY SHARE &nbsp; &nbsp; &nbsp; &nbsp;conflict</font></div><p></p></pre></div>6.&nbsp;src/include/access/htup_details.h</div>
	</div>
</div>
</body>
</html>