<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL recovery target introduce</h2>
	<h5 id="">2013-01-30 10:21:00&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201303082942271/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">QQ群里聊到的关于PostgreSQL 恢复点的话题.<div>本文涉及源码参考PostgreSQL 9.2.2版本.<br><div><div>我们知道PostgreSQL 支持PITR, 基于时间点的恢复. 通过配置recovery.conf可以指定3种恢复目标, 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >recovery_target_name (string)</font></div><div><font size="2"  >This parameter specifies the named restore point, created with pg_create_restore_point() to which recovery will proceed.&nbsp;</font></div><div><font size="2"  >At most one of recovery_target_name, recovery_target_time or recovery_target_xid can be specified. The default is to recover to the end of the WAL log.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >recovery_target_time (timestamp)</font></div><div><font size="2"  >This parameter specifies the time stamp up to which recovery will proceed.&nbsp;</font></div><div><font size="2"  >At most one of recovery_target_time, recovery_target_name or recovery_target_xid can be specified. The default is to recover to the end of the WAL log.&nbsp;</font></div><div><font size="2"  >The precise stopping point is also influenced by recovery_target_inclusive.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >recovery_target_xid (string)</font></div><div><font size="2"  >This parameter specifies the transaction ID up to which recovery will proceed. Keep in mind that while transaction IDs are assigned sequentially at transaction start, transactions can complete in a different numeric order. The transactions that will be recovered are those that committed before (and optionally including) the specified one.&nbsp;</font></div><div><font size="2"  >At most one of recovery_target_xid, recovery_target_name or recovery_target_time can be specified. The default is to recover to the end of the WAL log.&nbsp;</font></div><div><font size="2"  >The precise stopping point is also influenced by recovery_target_inclusive.</font></div><p></p></pre></div><div><br></div><div>其中<span style="line-height: 22px;"  >recovery_target_time和</span><span style="line-height: 22px;"  >recovery_target_xid可以指定</span><span style="line-height: 22px;"  >recovery_target_inclusive参数, 如下 :&nbsp;</span></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >recovery_target_inclusive (boolean)</font></div><div><font size="2"  >Specifies whether we stop just after the specified recovery target (true), or just before the recovery target (false).&nbsp;</font></div><div><font size="2"  >Applies to both recovery_target_time and recovery_target_xid, whichever one is specified for this recovery.&nbsp;</font></div><div><font size="2"  >This indicates whether transactions having exactly the target commit time or ID, respectively, will be included in the recovery.&nbsp;</font></div><div><font size="2"  >Default is true.</font></div><p></p></pre></div><div>默认为true取自src/backend/access/transam/xlog.c :&nbsp;</div><div><pre class="prettyprint"  ><p><font size="2"  >static bool recoveryTargetInclusive = true;</font></p></pre></div><br><wbr></div>为什么<span style="line-height: 22px;"  >recovery_target_name不能指定</span><span style="line-height: 22px;"  >recovery_target_inclusive参数?, 而</span><span style="line-height: 22px;"  >recovery_target_time和</span><span style="line-height: 22px;"  >recovery_target_xid可以指定</span><span style="line-height: 22px;"  >recovery_target_inclusive参数</span><span style="line-height: 22px;"  >呢?</span></div><div><div>首先要解释一下, 什么情况下恢复可以截止. 只在三种情况恢复可以截止 :&nbsp;</div><div>&nbsp;COMMIT/ABORT/XLOG_RESTORE_POINT, 然后这些信息从哪里来呢? 它们都取自XLOG的头数据<span style="line-height: 22px;"  >XLogRecord</span><span style="line-height: 22px;"  >中的sl_rmid和xl_info :&nbsp;</span></div><div>src/include/access/xlog.h</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* The overall layout of an XLOG record is:</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Fixed-size header (XLogRecord struct)</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rmgr-specific data</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BkpBlock</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;backup block data</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BkpBlock</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;backup block data</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* where there can be zero to four backup blocks (as signaled by xl_info flag</font></div><div><font size="2"  >&nbsp;* bits). &nbsp;XLogRecord structs always start on MAXALIGN boundaries in the WAL</font></div><div><font size="2"  >&nbsp;* files, and we round up SizeOfXLogRecord so that the rmgr data is also</font></div><div><font size="2"  >&nbsp;* guaranteed to begin on a MAXALIGN boundary. &nbsp;However, no padding is added</font></div><div><font size="2"  >&nbsp;* to align BkpBlock structs or backup block data.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* NOTE: xl_len counts only the rmgr data, not the XLogRecord header,</font></div><div><font size="2"  >&nbsp;* and also not any backup blocks. &nbsp; &nbsp; &nbsp;xl_tot_len counts everything. &nbsp;Neither</font></div><div><font size="2"  >&nbsp;* length field is rounded up to an alignment boundary.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >typedef struct XLogRecord</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; pg_crc32 &nbsp; &nbsp; &nbsp; &nbsp;xl_crc; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* CRC for this record */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;xl_prev; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* ptr to previous record in log */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xl_xid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* xact id */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xl_tot_len; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* total len of entire record */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xl_len; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* total len of rmgr data */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_info; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* flag bits, see below */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; RmgrId &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xl_rmid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* resource manager for this record */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* Depending on MAXALIGN, there are either 2 or 6 wasted bytes here */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* ACTUAL LOG DATA FOLLOWS AT END OF STRUCT */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >} XLogRecord;</font></div><p></p></pre></div><div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >只有在这三个状态下, 恢复允许进入截止判断.</span><span style="line-height: 22px;"  >&nbsp;COMMIT/ABORT/XLOG_RESTORE_POINT;</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >这个逻辑来自recoveryStopsHere函数 :&nbsp;</span></div></div><div>恢复截止的处理函数recoveryStopsHere中包含了这三个状态的判断, 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >src/backend/access/transam/xlog.c</font></div><div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* We only consider stopping at COMMIT, ABORT or RESTORE POINT records */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (record-&gt;xl_rmid != RM_XACT_ID &amp;&amp; record-&gt;xl_rmid != RM_XLOG_ID)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; record_info = record-&gt;xl_info &amp; ~XLR_INFO_MASK;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (record-&gt;xl_rmid == RM_XACT_ID &amp;&amp; record_info == XLOG_XACT_COMMIT_COMPACT)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_xact_commit_compact *recordXactCommitData;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recordXactCommitData = (xl_xact_commit_compact *) XLogRecGetData(record);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recordXtime = recordXactCommitData-&gt;xact_time;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; else if (record-&gt;xl_rmid == RM_XACT_ID &amp;&amp; record_info == XLOG_XACT_COMMIT)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_xact_commit *recordXactCommitData;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recordXactCommitData = (xl_xact_commit *) XLogRecGetData(record);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recordXtime = recordXactCommitData-&gt;xact_time;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; else if (record-&gt;xl_rmid == RM_XACT_ID &amp;&amp; record_info == XLOG_XACT_ABORT)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_xact_abort *recordXactAbortData;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recordXactAbortData = (xl_xact_abort *) XLogRecGetData(record);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recordXtime = recordXactAbortData-&gt;xact_time;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; else if (record-&gt;xl_rmid == RM_XLOG_ID &amp;&amp; record_info == XLOG_RESTORE_POINT)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_restore_point *recordRestorePointData;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recordRestorePointData = (xl_restore_point *) XLogRecGetData(record);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recordXtime = recordRestorePointData-&gt;rp_time;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strncpy(recordRPName, recordRestorePointData-&gt;rp_name, MAXFNAMELEN);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div></div><p></p></pre></div><div>COMMIT和ABORT很好理解, 就是事务结束时状态, RESOTRE POINT的信息则来自<span style="line-height: 22px;"  >XLogRestorePoint函数,&nbsp;</span></div><div><span style="line-height: 22px;"  >src/backend/access/transam/xlog.c</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Write a RESTORE POINT record</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >XLogRecPtr</font></div><div><font size="2"  >XLogRestorePoint(const char *rpName)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;RecPtr;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecData rdata;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; xl_restore_point xlrec;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; xlrec.rp_time = GetCurrentTimestamp();</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; strncpy(xlrec.rp_name, rpName, MAXFNAMELEN);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; rdata.buffer = InvalidBuffer;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; rdata.data = (char *) &amp;xlrec;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; rdata.len = sizeof(xl_restore_point);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; rdata.next = NULL;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; RecPtr = XLogInsert(RM_XLOG_ID, XLOG_RESTORE_POINT, &amp;rdata);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("restore point \"%s\" created at %X/%X",</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rpName, RecPtr.xlogid, RecPtr.xrecoff)));</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; return RecPtr;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>在使用PostgreSQL内建的<span style="line-height: 22px;"  >pg_create_restore_point函数创建还原点时用到</span><span style="line-height: 22px;"  >XLogRestorePoint</span><span style="line-height: 22px;"  >&nbsp;:&nbsp;</span></div><div>src/backend/access/transam/xlogfuncs.c</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* pg_create_restore_point: a named point for restore</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >Datum</font></div><div><font size="2"  >pg_create_restore_point(PG_FUNCTION_ARGS)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; text &nbsp; &nbsp; &nbsp; *restore_name = PG_GETARG_TEXT_P(0);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *restore_name_str;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;restorepoint;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;location[MAXFNAMELEN];</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (!superuser())</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(errmsg("must be superuser to create a restore point"))));</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (RecoveryInProgress())</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(errmsg("recovery is in progress"),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errhint("WAL control functions cannot be executed during recovery."))));</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (!XLogIsNeeded())</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("WAL level not sufficient for creating a restore point"),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errhint("wal_level must be set to \"archive\" or \"hot_standby\" at server start.")));</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; restore_name_str = text_to_cstring(restore_name);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (strlen(restore_name_str) &gt;= MAXFNAMELEN)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_INVALID_PARAMETER_VALUE),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("value too long for restore point (maximum %d characters)", MAXFNAMELEN - 1)));</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; restorepoint = XLogRestorePoint(restore_name_str);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div></div><div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* As a convenience, return the WAL location of the restore point record</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; snprintf(location, sizeof(location), "%X/%X",</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;restorepoint.xlogid, restorepoint.xrecoff);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(cstring_to_text(location));</font></div><div><font size="2"  >}</font></div></div><p></p></pre></div><div><br></div><div>经过以上介绍以后, 我们知道recoveryStopsHere开头部分的逻辑决定了PITR恢复可以选择截止在:</div><div>&nbsp; 1. 事务结束时(COMMIT/ABORT);&nbsp;</div><div>&nbsp; 2. 或者是用户使用<span style="line-height: 22px;"  >pg_create_restore_point</span><span style="line-height: 22px;"  >创建的还原点;</span></div><div><div><span style="line-height: 22px;"  >recoveryStopsHere</span>接下来的部分针对recovery.conf中的配置, 判断是否截止恢复.</div><div>在文章开头我们还提到了3个还原目标(target) :&nbsp;</div><div>(<span style="line-height: 22px;"  >recovery_target_xid,&nbsp;</span><span style="line-height: 22px;"  >recovery_target_time,&nbsp;</span><span style="line-height: 22px;"  >recovery_target_name</span><span style="line-height: 22px;"  >)</span></div><div><span style="line-height: 22px;"  >1. 未设置目标, 只返回false, 所以不会停止</span></div><div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* Do we have a PITR target at all? */</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (recoveryTarget == RECOVERY_TARGET_UNSET)</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Save timestamp of latest transaction commit/abort if this is a</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* transaction record</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (record-&gt;xl_rmid == RM_XACT_ID)</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetLatestXTime(recordXtime);</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div><div><span style="line-height: 22px;"  >RECOVERY_TARGET_UNSET&nbsp;</span>取自 src/include/access/xlog.h</div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Recovery target type.</font></div><div><font size="2"  >&nbsp;* Only set during a Point in Time recovery, not when standby_mode = on</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >typedef enum</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; RECOVERY_TARGET_UNSET,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; RECOVERY_TARGET_XID,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; RECOVERY_TARGET_TIME,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; RECOVERY_TARGET_NAME</font></div><div><font size="2"  >} RecoveryTargetType;</font></div><p></p></pre></div><div style="line-height: 22px;"  ><br></div></div><div><span style="line-height: 22px;"  >2. recovery_target_xid 与&nbsp;</span>XLogRecord-&gt;xl_xid<span style="line-height: 22px;"  >进行比较.</span></div><div>xid作为恢复目标时,&nbsp;<span style="line-height: 22px;"  >recoveryTargetInclusive只影响日志输出(</span><span style="line-height: 22px;"  >recoveryStopAfter</span><span style="line-height: 22px;"  >).</span></div><div>原因是xid是按事务启动顺序分配的, 而不是按事务结束顺序分配. 并且这种target下面截止只可能在COMMIT/ABORT.&nbsp;</div><div>所以只要达到这个xid并且状态是commit/abort时, 就返回true.</div><div><span style="line-height: 22px;"  >*includeThis = recoveryTargetInclusive;只影响了日志输出. 而不是包含和不包含的意思.</span></div><div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (recoveryTarget == RECOVERY_TARGET_XID)</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* There can be only one transaction end record with this exact</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* transactionid</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* when testing for an xid, we MUST test for equality only, since</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* transactions are numbered in the order they start, not the order</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* they complete. A higher numbered xid will complete before you about</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 50% of the time...</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stopsHere = (record-&gt;xl_xid == recoveryTargetXid);</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (stopsHere)</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *includeThis = recoveryTargetInclusive;</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div><div style="line-height: 22px;"  >日志输出时, 判断recoveryStopAfter :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (stopsHere)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recoveryStopXid = record-&gt;xl_xid;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recoveryStopTime = recordXtime;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recoveryStopAfter = *includeThis;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (record_info == XLOG_XACT_COMMIT_COMPACT || record_info == XLOG_XACT_COMMIT)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (recoveryStopAfter)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("recovery stopping after commit of transaction %u, time %s",</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recoveryStopXid,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timestamptz_to_str(recoveryStopTime))));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("recovery stopping before commit of transaction %u, time %s",</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recoveryStopXid,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timestamptz_to_str(recoveryStopTime))));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (record_info == XLOG_XACT_ABORT)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (recoveryStopAfter)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("recovery stopping after abort of transaction %u, time %s",</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recoveryStopXid,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timestamptz_to_str(recoveryStopTime))));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("recovery stopping before abort of transaction %u, time %s",</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recoveryStopXid,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timestamptz_to_str(recoveryStopTime))));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div><div style="line-height: 22px;"  ><br></div></div><div><span style="line-height: 22px;"  >3.&nbsp;</span><span style="line-height: 22px;"  >recovery_target_name 与&nbsp;</span><span style="line-height: 22px;"  >XLogRecData-&gt;</span><span style="line-height: 22px;"  >data进行比较.</span></div><div>如果数据库中有多个重复命名的还原点, 遇到第一个则停止.&nbsp;</div><div>同时因为还原点的信息写在单独的xlog数据块中, 不是一条transaction record块, 所以也没有包含或不包含的概念, 直接截止.&nbsp;</div><div>不需要判断<span style="line-height: 22px;"  >recovery_target_inclusive</span><span style="line-height: 22px;"  >&nbsp;.</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; else if (recoveryTarget == RECOVERY_TARGET_NAME)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* There can be many restore points that share the same name, so we</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* stop at the first one</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stopsHere = (strcmp(recordRPName, recoveryTargetName) == 0);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Ignore recoveryTargetInclusive because this is not a transaction</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* record</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *includeThis = false;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div><div><br></div><div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >4. recovery_target_time 与&nbsp;</span><span style="line-height: 22px;"  >xl_xact_commit_compact-&gt;</span><span style="line-height: 22px;"  >xact_time进行比较.&nbsp;</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >因为在同一个时间点, 可能有多个事务COMMIT/ABORT. 所以</span><span style="line-height: 22px;"  >recovery_target_inclusive</span><span style="line-height: 22px;"  >&nbsp;在这里起到的作用是 :&nbsp;</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >截止于这个时间点的第一个提交的事务后(包含这个时间点第一个遇到的提交/回滚的事务);</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >或者截止于这个时间点提交的最后一个事务后(包括这个时间点提交/回滚的所有事务).</span></div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  ><font size="2"  ><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; else</div><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; {</div><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</div><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* There can be many transactions that share the same commit time, so</div><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we stop after the last one, if we are inclusive, or stop at the</div><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* first one if we are exclusive</div><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (recoveryTargetInclusive)</div><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stopsHere = (recordXtime &gt; recoveryTargetTime);</div><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</div><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stopsHere = (recordXtime &gt;= recoveryTargetTime);</div><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (stopsHere)</div><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *includeThis = false;</div><div style="line-height: 22px;"  >&nbsp; &nbsp; &nbsp; &nbsp; }</div><p></p></pre></div></font></span></div></div><div><div style="line-height: 22px;"  ><span style="line-height: 22px;"  >其中事务结束时间来自这个数据结构 :&nbsp;</span></div><div style="line-height: 22px;"  ><div style="line-height: 22px;"  >src/include/access/xact.h</div><div style="line-height: 22px;"  ><pre class="prettyprint"  ><p></p><div style="line-height: 22px;"  ><font size="2"  >typedef struct xl_xact_commit_compact</font></div><div style="line-height: 22px;"  ><font size="2"  >{</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz xact_time; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* time of commit */</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsubxacts; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* number of subtransaction XIDs */</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* ARRAY OF COMMITTED SUBTRANSACTION XIDs FOLLOWS */</font></div><div style="line-height: 22px;"  ><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TransactionId subxacts[1]; &nbsp; &nbsp; &nbsp;/* VARIABLE LENGTH ARRAY */</font></div><div style="line-height: 22px;"  ><font size="2"  >} xl_xact_commit_compact;</font></div><p></p></pre></div><div style="line-height: 22px;"  ><br></div><div style="line-height: 22px;"  >从以上逻辑看到,&nbsp;<span style="line-height: 22px;"  >recoveryTargetInclusive只有当恢复目标是xid或者time时可以指定. 目标是name时无效.</span></div></div></div><div><span style="line-height: 22px;"  ><br></span></div><div><span style="line-height: 22px;"  >【参考】</span></div><div>1. src/include/catalog/pg_control.h</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/* XLOG info values for XLOG rmgr */</font></div><div><font size="2"  >#define XLOG_CHECKPOINT_SHUTDOWN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x00</font></div><div><font size="2"  >#define XLOG_CHECKPOINT_ONLINE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x10</font></div><div><font size="2"  >#define XLOG_NOOP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x20</font></div><div><font size="2"  >#define XLOG_NEXTOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x30</font></div><div><font size="2"  >#define XLOG_SWITCH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x40</font></div><div><font size="2"  >#define XLOG_BACKUP_END &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x50</font></div><div><font size="2"  >#define XLOG_PARAMETER_CHANGE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x60</font></div><div><font size="2"  >#define XLOG_RESTORE_POINT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x70</font></div><div><font size="2"  >#define XLOG_FPW_CHANGE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x80</font></div><p></p></pre></div><div><br></div><div>2.&nbsp;src/include/access/xlog.h</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* XLOG uses only low 4 bits of xl_info. &nbsp;High 4 bits may be used by rmgr.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >#define XLR_INFO_MASK &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0F</font></div><p></p></pre></div><div><br></div><div>3.&nbsp;src/include/access/rmgr.h</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Built-in resource managers</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Note: RM_MAX_ID could be as much as 255 without breaking the XLOG file</font></div><div><font size="2"  >&nbsp;* format, but we keep it small to minimize the size of RmgrTable[].</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >#define RM_XLOG_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"  >#define RM_XACT_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"  >#define RM_SMGR_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2</font></div><div><font size="2"  >#define RM_CLOG_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3</font></div><div><font size="2"  >#define RM_DBASE_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4</font></div><div><font size="2"  >#define RM_TBLSPC_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div><font size="2"  >#define RM_MULTIXACT_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6</font></div><div><font size="2"  >#define RM_RELMAP_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7</font></div><div><font size="2"  >#define RM_STANDBY_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8</font></div><div><font size="2"  >#define RM_HEAP2_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 9</font></div><div><font size="2"  >#define RM_HEAP_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10</font></div><div><font size="2"  >#define RM_BTREE_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11</font></div><div><font size="2"  >#define RM_HASH_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12</font></div><div><font size="2"  >#define RM_GIN_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 13</font></div><div><font size="2"  >#define RM_GIST_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14</font></div><div><font size="2"  >#define RM_SEQ_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 15</font></div><div><font size="2"  >#define RM_SPGIST_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16</font></div><p></p></pre></div><div><span style="line-height: 22px;"  ><br></span></div></div></div></div></div>
	</div>
</div>
</body>
</html>