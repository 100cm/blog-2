<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">OPENSSL 转载 - 1</h2>
	<h5 id="">2013-05-22 15:23:51&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201342232351672/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px; color: rgb(73, 73, 73); font-family: simsun; background-color: rgb(193, 207, 208);"   >OpenSSL是一个使用广泛的开源工具。可以方便的做一些编码解码，md5/sha1摘要，aes/des加密解密，以及证书的生成及使用。</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px; color: rgb(73, 73, 73); font-family: simsun; background-color: rgb(193, 207, 208);"   >Linux操作系统一般都会自带openssl。</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px; color: rgb(73, 73, 73); font-family: simsun; background-color: rgb(193, 207, 208);"   >以下内容引自OpenSSL Command-Line HOWTO（&nbsp;<wbr><a style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.madboa.com/geek/openssl/"   >http://www.madboa.com/geek/openssl/</a>&nbsp;<wbr>）</p><div style="color: rgb(73, 73, 73); font-family: simsun; line-height: 21px; background-color: rgb(193, 207, 208);"   ><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I find out what OpenSSL version I’m running?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Use the&nbsp;<code>version</code>&nbsp;option.</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl version</strong>&nbsp;OpenSSL 0.9.8b 04 May 2006</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >You can get much more information with the&nbsp;<code>version -a</code>&nbsp;option.</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl version -a</strong>&nbsp;OpenSSL 0.9.8b 04 May 2006 built on: Fri Sep 29 18:45:58 UTC 2006 platform: debian-i386-i686/cmov options: bn(64,32) md2(int) rc4(idx,int) des(ptr,risc1,16,long) blowfish(idx) compiler: gcc -fPIC -DOPENSSL_PIC -DZLIB -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DL_ENDIAN -DTERMIO -O3 -march=i686 -Wa,--noexecstack -g -Wall -DOPENSSL_BN_ASM_PART_WORDS -DOPENSSL_IA32_SSE2 -DSHA1_ASM -DMD5_ASM -DRMD160_ASM -DAES_ASM OPENSSLDIR: "/usr/lib/ssl"</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I get a list of the available commands?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >There are three built-in options for getting lists of available commands, but none of them provide what I consider useful output. The best thing to do is provide an invalid command (<strong><code>help</code></strong>&nbsp;or&nbsp;<strong><code>-h</code></strong>will do nicely) to get a readable answer.</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl help</strong>&nbsp;openssl:Error: 'help' is an invalid command. Standard commands asn1parse ca ciphers crl crl2pkcs7 dgst dh dhparam dsa dsaparam ec ecparam enc engine errstr gendh gendsa genrsa nseq ocsp passwd pkcs12 pkcs7 pkcs8 prime rand req rsa rsautl s_client s_server s_time sess_id smime speed spkac verify version x509 Message Digest commands (see the `dgst' command for more details) md2 md4 md5 rmd160 sha sha1 Cipher commands (see the `enc' command for more details) aes-128-cbc aes-128-ecb aes-192-cbc aes-192-ecb aes-256-cbc aes-256-ecb base64 bf bf-cbc bf-cfb bf-ecb bf-ofb cast cast-cbc cast5-cbc cast5-cfb cast5-ecb cast5-ofb des des-cbc des-cfb des-ecb des-ede des-ede-cbc des-ede-cfb des-ede-ofb des-ede3 des-ede3-cbc des-ede3-cfb des-ede3-ofb des-ofb des3 desx rc2 rc2-40-cbc rc2-64-cbc rc2-cbc rc2-cfb rc2-ecb rc2-ofb rc4 rc4-40</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >What the shell calls&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >“<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >Standard commands</span>”</span>&nbsp;are the main top-level options.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >You can use the same trick with any of the subcommands.</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl dgst -h</strong>&nbsp;unknown option '-h' options are -c to output the digest with separating colons -d to output debug info -hex output as hex dump -binary output in binary form -sign file sign digest using private key in file -verify file verify a signature using public key in file -prverify file verify a signature using private key in file -keyform arg key file format (PEM or ENGINE) -signature file signature to verify -binary output in binary form -engine e use engine e, possibly a hardware device. -md5 to use the md5 message digest algorithm (default) -md4 to use the md4 message digest algorithm -md2 to use the md2 message digest algorithm -sha1 to use the sha1 message digest algorithm -sha to use the sha message digest algorithm -sha256 to use the sha256 message digest algorithm -sha512 to use the sha512 message digest algorithm -mdc2 to use the mdc2 message digest algorithm -ripemd160 to use the ripemd160 message digest algorithm</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >In more boring fashion, you can consult the&nbsp;<a title="For further reading" style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.madboa.com/geek/openssl/#links"   >OpenSSL man pages</a>.</p><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I get a list of available ciphers?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Use the&nbsp;<code>ciphers</code>&nbsp;option. The&nbsp;<a style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.openssl.org/docs/apps/ciphers.html"   >ciphers(1)</a>&nbsp;man page is quite helpful.</p><pre style="white-space: normal;"   ># list all available ciphers openssl ciphers -v # list only TLSv1 ciphers openssl ciphers -v -tls1 # list only high encryption ciphers (keys larger than 128 bits) openssl ciphers -v 'HIGH' # list only high encryption ciphers using the AES algorithm openssl ciphers -v 'AES+HIGH'</pre></div></div><div><div><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >Benchmarking</h2></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I benchmark my system’s performance?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >The OpenSSL developers have built a benchmarking suite directly into the&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>openssl</strong></span>&nbsp;binary. It’s accessible via the&nbsp;<code>speed</code>&nbsp;option. It tests how many operations it can perform in a given time, rather than how long it takes to perform a given number of operations. This strikes me a quite sane, because the benchmarks don’t take significantly longer to run on a slow system than on a fast one.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >To run a catchall benchmark, run it without any further options.</p><pre style="white-space: normal;"   >openssl speed</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >There are two sets of results. The first reports how many bytes per second can be processed for each algorithm, the second the times needed for sign/verify cycles. Here are the results on an 2.16GHz Intel Core 2.</p><pre style="white-space: normal;"   >The 'numbers' are in 1000s of bytes per second processed. type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes md2 1736.10k 3726.08k 5165.04k 5692.28k 5917.35k mdc2 0.00 0.00 0.00 0.00 0.00 md4 18799.87k 65848.23k 187776.43k 352258.73k 474622.63k md5 16807.01k 58256.45k 160439.13k 287183.53k 375220.91k hmac(md5) 23601.24k 74405.08k 189993.05k 309777.75k 379431.59k sha1 16774.59k 55500.39k 142628.69k 233247.74k 288382.98k rmd160 13854.71k 40271.23k 87613.95k 124333.06k 141781.67k rc4 227935.60k 253366.06k 261236.94k 259858.09k 194928.50k des cbc 48478.10k 49616.16k 49765.21k 50106.71k 50034.01k des ede3 18387.39k 18631.02k 18699.26k 18738.18k 18718.72k idea cbc 0.00 0.00 0.00 0.00 0.00 rc2 cbc 19247.24k 19838.12k 19904.51k 19925.33k 19834.98k rc5-32/12 cbc 0.00 0.00 0.00 0.00 0.00 blowfish cbc 79577.50k 83067.03k 84676.78k 84850.01k 85063.00k cast cbc 45362.14k 48343.34k 49007.36k 49202.52k 49225.73k aes-128 cbc 58751.94k 94443.86k 111424.09k 116704.26k 117997.57k aes-192 cbc 53451.79k 82076.22k 94609.83k 98496.85k 99150.51k aes-256 cbc 49225.21k 72779.84k 82266.88k 85054.81k 85762.05k sha256 9359.24k 22510.83k 40963.75k 51710.29k 56014.17k sha512 7026.78k 28121.32k 54330.79k 86190.76k 104270.51k sign verify sign/s verify/s rsa 512 bits 0.000522s 0.000042s 1915.8 23969.9 rsa 1024 bits 0.002321s 0.000109s 430.8 9191.1 rsa 2048 bits 0.012883s 0.000329s 77.6 3039.6 rsa 4096 bits 0.079055s 0.001074s 12.6 931.3 sign verify sign/s verify/s dsa 512 bits 0.000380s 0.000472s 2629.3 2117.9 dsa 1024 bits 0.001031s 0.001240s 969.6 806.2 dsa 2048 bits 0.003175s 0.003744s 314.9 267.1</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >You can run any of the algorithm-specific subtests directly.</p><pre style="white-space: normal;"   ># test rsa speeds openssl speed rsa # do the same test on a two-way SMP system openssl speed rsa -multi 2</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I benchmark remote connections?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >The&nbsp;<code>s_time</code>&nbsp;option lets you test connection performance. The most simple invocation will run for 30 seconds, use any cipher, and use SSL handshaking to determine number of connections per second, using both new and reused sessions:</p><pre style="white-space: normal;"   >openssl s_time -connect remote.host:443</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Beyond that most simple invocation,&nbsp;<code>s_time</code>&nbsp;gives you a wide variety of testing options.</p><pre style="white-space: normal;"   ># retrieve remote test.html page using only new sessions openssl s_time -connect remote.host:443 -www /test.html -new # similar, using only SSL v3 and high encryption (see # ciphers(1) man page for cipher strings) openssl s_time \ -connect remote.host:443 -www /test.html -new \ -ssl3 -cipher HIGH # compare relative performance of various ciphers in # 10-second tests IFS=":" for c in $(openssl ciphers -ssl3 RSA); do echo $c openssl s_time -connect remote.host:443 \ -www / -new -time 10 -cipher $c 2&gt;&amp;1 | \ grep bytes echo done</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If you don’t have an SSL-enabled web server available for your use, you can emulate one using the<code>s_server</code>&nbsp;option.</p><pre style="white-space: normal;"   ># on one host, set up the server (using default port 4433) openssl s_server -cert mycert.pem -www # on second host (or even the same one), run s_time openssl s_time -connect myhost:4433 -www / -new -ssl3</pre></div></div><div><div><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >Certificates</h2></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I generate a self-signed certificate?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >You’ll first need to decide whether or not you want to encrypt your key. Doing so means that the key is protected by a passphrase.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >On the plus side, adding a passphrase to a key makes it more secure, so the key is less likely to be useful to someone who steals it. The downside, however, is that you’ll have to either store the passphrase in a file or type it manually every time you want to start your web or ldap server.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >It violates my normally paranoid nature to say it, but I prefer unencrypted keys, so I don’t have to manually type a passphrase each time a secure daemon is started. (It’s not terribly difficult<a title="How do I remove a passphrase from a key?" style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.madboa.com/geek/openssl/#key-removepass"   >to decrypt your key</a>&nbsp;if you later tire of typing a passphrase.)</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >This example will produce a file called&nbsp;<code>mycert.pem</code>&nbsp;which will contain both the private key and the public certificate based on it. The certificate will be valid for 365 days, and the key (thanks to the&nbsp;<code>-nodes</code>&nbsp;option) is unencrypted.</p><pre style="white-space: normal;"   >openssl req \ -x509 -nodes -days 365 \ -newkey rsa:1024 -keyout mycert.pem -out mycert.pem</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Using this command-line invocation, you’ll have to answer a lot of questions: Country Name, State, City, and so on. The tricky question is&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >“<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >Common Name.</span>”</span>&nbsp;You’ll want to answer with the<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><em>hostname or CNAME by which people will address the server</em></span>. This is very important. If your web server’s real hostname is&nbsp;<code>mybox.mydomain.com</code>&nbsp;but people will be using&nbsp;<code>www.mydomain.com</code>&nbsp;to address the box, then use the latter name to answer the&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >“<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >Common Name</span>”</span>&nbsp;question.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Once you’re comfortable with the answers you provide to those questions, you can script the whole thing by adding the&nbsp;<code>-subj</code>&nbsp;option. I’ve included some information about location into the example that follows, but the only thing you really need to include for the certificate to be useful is the hostname (CN).</p><pre style="white-space: normal;"   >openssl req \ -x509 -nodes -days 365 \ -subj '/C=US/ST=Oregon/L=Portland/CN=www.madboa.com' \ -newkey rsa:1024 -keyout mycert.pem -out mycert.pem</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I generate a certificate request for VeriSign?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Applying for a certificate signed by a recognized certificate authority like VeriSign is a complex bureaucratic process. You’ve got to perform all the requisite paperwork before creating a certificate request.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >As in the recipe for&nbsp;<a title="How do I generate a self-signed certificate?" style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.madboa.com/geek/openssl/#cert-self"   >creating a self-signed certificate</a>, you’ll have to decide whether or not you want a passphrase on your private key. The recipe below assumes you don’t. You’ll end up with two files: a new private key called&nbsp;<code>mykey.pem</code>&nbsp;and a certificate request called&nbsp;<code>myreq.pem</code>.</p><pre style="white-space: normal;"   >openssl req \ -new -newkey rsa:1024 -nodes \ -keyout mykey.pem -out myreq.pem</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If you’ve already&nbsp;<a title="How do I generate an RSA key?" style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.madboa.com/geek/openssl/#key-rsa"   >got a key</a>&nbsp;and would like to use it for generating the request, the syntax is a bit simpler.</p><pre style="white-space: normal;"   >openssl req -new -key mykey.pem -out myreq.pem</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Similarly, you can also provide subject information on the command line.</p><pre style="white-space: normal;"   >openssl req \ -new -newkey rsa:1024 -nodes \ -subj '/CN=www.mydom.com/O=My Dom, Inc./C=US/ST=Oregon/L=Portland' \ -keyout mykey.pem -out myreq.pem</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >When dealing with an institution like VeriSign, you need to take special care to make sure that the information you provide during the creation of the certificate request is&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><em>exactly</em></span>&nbsp;correct. I know from personal experience that even a difference as trivial as substituting&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >“<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >and</span>”</span>&nbsp;for&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >“<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >&amp;</span>”</span>in the Organization Name will stall the process.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If you’d like, you can double check the signature and information provided in the certificate request.</p><pre style="white-space: normal;"   ># verify signature openssl req -in myreq.pem -noout -verify -key mykey.pem # check info openssl req -in myreq.pem -noout -text</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Save the key file in a secure location. You’ll need it in order to use the certificate VeriSign sends you. The certificate request will typically be pasted into VeriSign’s online application form.</p></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I test a new certificate?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >The&nbsp;<code>s_server</code>&nbsp;option provides a simple but effective testing method. The example below assumes you’ve combined your key and certificate into one file called&nbsp;<code>mycert.pem</code>.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >First, launch the test server on the machine on which the certificate will be used. By default, the server will listen on port 4433; you can alter that using the&nbsp;<code>-accept</code>&nbsp;option.</p><pre style="white-space: normal;"   >openssl s_server -cert mycert.pem -www</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If the server launches without complaint, then chances are good that the certificate is ready for production use.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >You can also point your web browser at the test server,&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><em>e.g.</em></span>,&nbsp;<strong><code>https://yourserver:4433/</code></strong>. Don’t forget to specify the&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >“<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >https</span>”</span>&nbsp;protocol; plain-old&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >“<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >http</span>”</span>&nbsp;won’t work. You should see a page listing the various ciphers available and some statistics about your connection. Most modern browsers allow you to examine the certificate as well.</p><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I retrieve a remote certificate?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If you combine&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>openssl</strong></span>&nbsp;and&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>sed</strong></span>, you can retrieve remote certificates via a shell one-liner or a simple script.</p><pre style="white-space: normal;"   >#!/bin/sh # # usage: retrieve-cert.sh remote.host.name [port] # REMHOST=$1 REMPORT=${2:-443} echo |\ openssl s_client -connect ${REMHOST}:${REMPORT} 2&gt;&amp;1 |\ sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >You can, in turn, pipe that information back to&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>openssl</strong></span>&nbsp;to do things like check the dates on all your active certificates.</p><pre style="white-space: normal;"   >#!/bin/sh # for CERT in \ www.yourdomain.com:443 \ ldap.yourdomain.com:636 \ imap.yourdomain.com:993 \ do echo |\ openssl s_client -connect ${CERT} 2&gt;/dev/null |\ sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' |\ openssl x509 -noout -subject -dates done</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I extract information from a certificate?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >An SSL certificate contains a wide range of information: issuer, valid dates, subject, and some hardcore crypto stuff. The&nbsp;<code>x509</code>&nbsp;subcommand is the entry point for retrieving this information. The examples below all assume that the certificate you want to examine is stored in a file named<code>cert.pem</code>.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Using the&nbsp;<code>-text</code>&nbsp;option will give you the full breadth of information.</p><pre style="white-space: normal;"   >openssl x509 -text -in cert.pem</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Other options will provide more targeted sets of data.</p><pre style="white-space: normal;"   ># who issued the cert? openssl x509 -noout -in cert.pem -issuer # to whom was it issued? openssl x509 -noout -in cert.pem -subject # for what dates is it valid? openssl x509 -noout -in cert.pem -dates # the above, all at once openssl x509 -noout -in cert.pem -issuer -subject -dates # what is its hash value? openssl x509 -noout -in cert.pem -hash # what is its MD5 fingerprint? openssl x509 -noout -in cert.pem -fingerprint</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I export or import a PKCS#12 certificate?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >PKCS#12 files can be imported and exported by a number of applications, including Microsoft IIS. They are often associated with the file extension&nbsp;<code>.pfx</code>.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >To create a PKCS#12 certificate, you’ll need a private key and a certificate. During the conversion process, you’ll be given an opportunity to put an&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >“<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >Export Password</span>”</span>&nbsp;(which can be empty, if you choose) on the certificate.</p><pre style="white-space: normal;"   ># create a file containing key and self-signed certificate openssl req \ -x509 -nodes -days 365 \ -newkey rsa:1024 -keyout mycert.pem -out mycert.pem # export mycert.pem as PKCS#12 file, mycert.pfx openssl pkcs12 -export \ -out mycert.pfx -in mycert.pem \ -name "My Certificate"</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If someone sends you a PKCS#12 and any passwords needed to work with it, you can export it into standard PEM format.</p><pre style="white-space: normal;"   ># export certificate and passphrase-less key openssl pkcs12 -in mycert.pfx -out mycert.pem -nodes # same as above, but you’ll be prompted for a passphrase for # the private key openssl pkcs12 -in mycert.pfx -out mycert.pem</pre></div></div><div><div><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >Certificate Verification</h2></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Applications linked against the OpenSSL libraries can verify certificates signed by a recognized certificate authority (CA).</p><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I verify a certificate?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Use the&nbsp;<code>verify</code>&nbsp;option to verify certificates.</p><pre style="white-space: normal;"   >openssl verify cert.pem</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If your local OpenSSL installation recognizes the certificate or its signing authority and everything else (dates, signing chain, etc.) checks out, you’ll get a simple OK message.</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl verify remote.site.pem</strong>&nbsp;remote.site.pem: OK</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If anything is amiss, you’ll see some error messages with short descriptions of the problem,<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><em>e.g.</em></span>,</p><div><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; border: 0px; list-style: none;"   ><li style="margin: 0px 0px 0px 30px; padding: 0px; border: 0px; list-style: disc;"   ><code>error 10 at 0 depth lookup:certificate has expired</code>. Certificates are typically issued for a limited period of time―usually just one year―and&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>openssl</strong></span>&nbsp;will complain if a certificate has expired.</li><li style="margin: 0px 0px 0px 30px; padding: 0px; border: 0px; list-style: disc;"   ><code>error 18 at 0 depth lookup:self signed certificate</code>. Unless you&nbsp;<a title="How do I get OpenSSL to recognize/verify a certificate?" style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.madboa.com/geek/openssl/#verify-new"   >make an exception</a>, OpenSSL won’t verify a self-signed certificate.</li></ul></div></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >What certificate authorities does OpenSSL recognize?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >When OpenSSL was built for your system, it was configured with a&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >“<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >Directory for OpenSSL files.</span>”</span>(That’s the&nbsp;<code>--openssldir</code>&nbsp;option passed to the configure script, for you hands-on types.) This is the directory that typically holds information about certificate authorities your system trusts.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >The default location for this directory is&nbsp;<code>/usr/local/ssl</code>, but most vendors put it elsewhere,<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><em>e.g.</em></span>,&nbsp;<code>/usr/share/ssl</code>&nbsp;(Red Hat/Fedora),&nbsp;<code>/etc/ssl</code>&nbsp;(Gentoo),&nbsp;<code>/usr/lib/ssl</code>&nbsp;(Debian), or<code>/System/Library/OpenSSL</code>&nbsp;(Macintosh OS X).</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Use the&nbsp;<code>version</code>&nbsp;option to identify which directory (labeled&nbsp;<code>OPENSSLDIR</code>) your installation uses.</p><pre style="white-space: normal;"   >openssl version -d</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Within that directory and a subdirectory called&nbsp;<code>certs</code>, you’re likely to find one or more of three different kinds of files.</p><div><ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; border: 0px; list-style: none;"   ><li style="margin: 0px 0px 0px 30px; padding: 0px; border: 0px; list-style: decimal;"   >A large file called&nbsp;<code>cert.pem</code>, an omnibus collection of many certificates from recognized certificate authorities like VeriSign and Thawte.</li><li style="margin: 0px 0px 0px 30px; padding: 0px; border: 0px; list-style: decimal;"   >Some small files in the&nbsp;<code>certs</code>&nbsp;subdirectory named with a&nbsp;<code>.pem</code>&nbsp;file extension, each of which contains a certificate from a single CA.</li><li style="margin: 0px 0px 0px 30px; padding: 0px; border: 0px; list-style: decimal;"   >Some symlinks in the&nbsp;<code>certs</code>&nbsp;subdirectory with obscure filenames like&nbsp;<code>052eae11.0</code>. There is typically one of these links for each&nbsp;<code>.pem</code>&nbsp;file.The first part of obscure filename is actually a hash value based on the certificate within the&nbsp;<code>.pem</code>&nbsp;file to which it points. The file extension is just an iterator, since it’s theoretically possible that multiple certificates can generate identical hashes.On my Gentoo system, for example, there’s a symlink named<code>f73e89fd.0</code>&nbsp;that points to a file named&nbsp;<code>vsignss.pem</code>. Sure enough, the certificate in that file generates a hash the equates to the name of the symlink:<pre style="white-space: normal;"   >$&nbsp;<strong>openssl x509 -noout -hash -in vsignss.pem</strong>&nbsp;f73e89fd</pre></li></ol></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >When an application encounters a remote certificate, it will typically check to see if the cert can be found in&nbsp;<code>cert.pem</code>&nbsp;or, if not, in a file named after the certificate’s hash value. If found, the certificate is considered verified.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >It’s interesting to note that some applications, like Sendmail, allow you to specify at runtime the location of the certificates you trust, while others, like Pine, do not.</p></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I get OpenSSL to recognize/verify a certificate?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Put the file that contains the certificate you’d like to trust into the&nbsp;<code>certs</code>&nbsp;directory discussed<a title="What certificate authorities does OpenSSL recognize?" style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.madboa.com/geek/openssl/#verify-system"   >above</a>. Then create the hash-based symlink. Here’s a little script that’ll do just that.</p><pre style="white-space: normal;"   >#!/bin/sh # # usage: certlink.sh filename [filename ...] for CERTFILE in $*; do # make sure file exists and is a valid cert test -f "$CERTFILE" || continue HASH=$(openssl x509 -noout -hash -in "$CERTFILE") test -n "$HASH" || continue # use lowest available iterator for symlink for ITER in 0 1 2 3 4 5 6 7 8 9; do test -f "${HASH}.${ITER}" &amp;&amp; continue ln -s "$CERTFILE" "${HASH}.${ITER}" test -L "${HASH}.${ITER}" &amp;&amp; break done done</pre></div></div><div><div><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >Command-line clients and servers</h2></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >The&nbsp;<code>s_client</code>&nbsp;and&nbsp;<code>s_server</code>&nbsp;options provide a way to launch SSL-enabled command-line clients and servers. There are other examples of their use scattered around this document, but this section is dedicated solely to them.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >In this section, I assume you are familiar with the specific protocols at issue: SMTP, HTTP, etc. Explaining them is out of the scope of this article.</p><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I connect to a secure SMTP server?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >You can test, or even use, an SSL-enabled SMTP server from the command line using the&nbsp;<code>s_client option</code>.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Secure SMTP servers offer secure connections on up to three ports: 25 (TLS), 465 (SSL), and 587 (TLS). Some time around the 0.9.7 release, the&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>openssl</strong></span>&nbsp;binary was given the ability to use STARTTLS when talking to SMTP servers.</p><pre style="white-space: normal;"   ># port 25/TLS; use same syntax for port 587 openssl s_client -connect remote.host:25 -starttls smtp # port 465/SSL openssl s_client -connect remote.host:465</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   ><a style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.ietf.org/rfc/rfc0821.txt"   >RFC821</a>&nbsp;suggests (although it falls short of explicitly specifying) the two characters “&lt;CRLF&gt;” as line-terminator. Most mail agents do not care about this and accept either “&lt;LF&gt;” or “&lt;CRLF&gt;” as line-terminators, but Qmail does not. If you want to comply to the letter with RFC821 and/or communicate with Qmail, use also the&nbsp;<code>-crlf</code>&nbsp;option:</p><pre style="white-space: normal;"   >openssl s_client -connect remote.host:25 -crlf -starttls smtp</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I connect to a secure [whatever] server?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Connecting to a different type of SSL-enabled server is essentially the same operation as outlined above. As of the date of this writing,&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>openssl</strong></span>&nbsp;only supports command-line TLS with SMTP servers, so you have to use straightforward SSL connections with any other protocol.</p><pre style="white-space: normal;"   ># https: HTTP over SSL openssl s_client -connect remote.host:443 # ldaps: LDAP over SSL openssl s_client -connect remote.host:636 # imaps: IMAP over SSL openssl s_client -connect remote.host:993 # pop3s: POP-3 over SSL openssl s_client -connect remote.host:995</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I set up an SSL server from the command line?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >The&nbsp;<code>s_server</code>&nbsp;option allows you to set up an SSL-enabled server from the command line, but it’s I wouldn’t recommend using it for anything other than testing or debugging. If you need a production-quality wrapper around an otherwise insecure server, check out&nbsp;<a style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.stunnel.org/"   >Stunnel</a>&nbsp;instead.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >The&nbsp;<code>s_server</code>&nbsp;option works best when you have a certificate; it’s fairly limited without one.</p><pre style="white-space: normal;"   ># the -www option will sent back an HTML-formatted status page # to any HTTP clients that request a page openssl s_server -cert mycert.pem -www # the -WWW option "emulates a simple web server. Pages will be # resolved relative to the current directory." This example # is listening on the https port, rather than the default # port 4433 openssl s_server -accept 443 -cert mycert.pem -WWW</pre></div></div><div><div><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >Digests</h2></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Generating digests with the&nbsp;<code>dgst</code>&nbsp;option is one of the more straightforward tasks you can accomplish with the&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>openssl</strong></span>&nbsp;binary. Producing digests is done so often, as a matter of fact, that you can find special-use binaries for doing the same thing.</p><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I create an MD5 or SHA1 digest of a file?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Digests are created using the&nbsp;<code>dgst</code>&nbsp;option.</p><pre style="white-space: normal;"   ># MD5 digest openssl dgst -md5 filename # SHA1 digest openssl dgst -sha1 filename</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >The MD5 digests are identical to those created with the widely available&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>md5sum</strong></span>&nbsp;command, though the output formats differ.</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl dgst -md5 foo-2.23.tar.gz</strong>&nbsp;MD5(foo-2.23.tar.gz)= 81eda7985e99d28acd6d286a<wbr>a0e13e07 $<strong>md5sum foo-2.23.tar.gz</strong>&nbsp;81eda7985e99d28acd6d286a<wbr>a0e13e07 foo-2.23.tar.gz</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >The same is true for SHA1 digests and the output of the&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>sha1sum</strong></span>&nbsp;application.</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl dgst -sha1 foo-2.23.tar.gz</strong>&nbsp;SHA1(foo-2.23.tar.gz)= e4eabc78894e2c204d788521<wbr>812497e021f45c08 $&nbsp;<strong>sha1sum foo-2.23.tar.gz</strong>&nbsp;e4eabc78894e2c204d788521<wbr>812497e021f45c08 foo-2.23.tar.gz</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I sign a digest?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If you want to ensure that the digest you create doesn’t get modified without your permission, you can sign it using your&nbsp;<a title="How do I generate an RSA key?" style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.madboa.com/geek/openssl/#key-rsa"   >private key</a>. The following example assumes that you want to sign the SHA1 sum of a file called&nbsp;<code>foo-1.23.tar.gz</code>.</p><pre style="white-space: normal;"   ># signed digest will be foo-1.23.tar.gz.sha1 openssl dgst -sha1 \ -sign mykey.pem -out foo-1.23.tar.gz.sha1 \ foo-1.23.tar.gz</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I verify a signed digest?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >To verify a signed digest you’ll need the file from which the digest was derived, the signed digest, and the signer’s&nbsp;<a title="How do I generate a public RSA key?" style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.madboa.com/geek/openssl/#key-rsapublic"   >public key</a>.</p><pre style="white-space: normal;"   ># to verify foo-1.23.tar.gz using foo-1.23.tar.gz.sha1 # and pubkey.pem openssl dgst -sha1 \ -verify pubkey.pem \ -signature foo-1.23.tar.gz.sha1 \ foo-1.23.tar.gz</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I create an Apache digest password entry?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Apache’s HTTP digest authentication feature requires a special password format. Apache ships with the&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>htdigest</strong></span>&nbsp;utility, but it will only write to a file, not to standard output. When working with remote users, it’s sometimes nice for them to be able to generate a password hash on a machine they trust and then mail it for inclusion in your local password database.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >The format of the password database is relatively simple: a colon-separated list of the username, authorization realm (specified by the Apache AuthName directive), and an MD5 digest of those two items and the password. Below is a script that duplicates the output of&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>htdigest</strong></span>, except that the output is written to standard output. It takes advantage of the&nbsp;<code>dgst</code>&nbsp;option’s ability to read from standard input.</p><pre style="white-space: normal;"   >#!/bin/bash echo "Create an Apache-friendly Digest Password Entry" echo "-----------------------------------------------" # get user input, disabling tty echoing for password read -p "Enter username: " UNAME read -p "Enter Apache AuthName: " AUTHNAME read -s -p "Enter password: " PWORD; echo printf "\n%s:%s:%s\n" \ "$UNAME" \ "$AUTHNAME" \ $(printf "${UNAME}:${AUTHNAME}:${PWORD}" | openssl dgst -md5)</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >What other kinds of digests are available?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Use the built-in&nbsp;<code>list-message-digest-commands</code>&nbsp;option to get a list of the digest types available to your local OpenSSL installation.</p><pre style="white-space: normal;"   >openssl list-message-digest-commands</pre></div></div><div><div><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >Encryption/Decryption</h2></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I base64-encode something?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Use the&nbsp;<code>enc -base64</code>&nbsp;option.</p><pre style="white-space: normal;"   ># send encoded contents of file.txt to stdout openssl enc -base64 -in file.txt # same, but write contents to file.txt.enc openssl enc -base64 -in file.txt -out file.txt.enc</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >It’s also possible to do a quick command-line encoding of a string value:</p><pre style="white-space: normal;"   >$&nbsp;<strong>echo "encode me" | openssl enc -base64</strong>&nbsp;ZW5jb2RlIG1lCg==</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Note that&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>echo</strong></span>&nbsp;will silently attach a newline character to your string. Consider using its&nbsp;<code>-n</code>option if you want to avoid that situation, which could be important if you’re trying to encode a password or authentication string.</p><pre style="white-space: normal;"   >$&nbsp;<strong>echo -n "encode me" | openssl enc -base64</strong>&nbsp;ZW5jb2RlIG1l</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Use the&nbsp;<code>-d</code>&nbsp;(decode) option to reverse the process.</p><pre style="white-space: normal;"   >$&nbsp;<strong>echo "ZW5jb2RlIG1lCg==" | openssl enc -base64 -d</strong>&nbsp;encode me</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I simply encrypt a file?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Simple file encryption is probably better done using a&nbsp;<a style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.madboa.com/geek/gpg-quickstart/"   >tool like GPG</a>. Still, you may have occasion to want to encrypt a file without having to build or use a key/certificate structure. All you want to have to remember is a password. It can nearly be that simple―if you can also remember the cipher you employed for encryption.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >To choose a cipher, consult the&nbsp;<a style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.openssl.org/docs/apps/enc.html"   >enc(1) man page</a>. More simply (and perhaps more accurately), you can ask&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>openssl</strong></span>&nbsp;for a list in one of two ways.</p><pre style="white-space: normal;"   ># see the list under the 'Cipher commands' heading openssl -h # or get a long list, one cipher per line openssl list-cipher-commands</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >After you choose a cipher, you’ll also have to decide if you want to base64-encode the data. Doing so will mean the encrypted data can be, say, pasted into an email message. Otherwise, the output will be a binary file.</p><pre style="white-space: normal;"   ># encrypt file.txt to file.enc using 256-bit AES in CBC mode openssl enc -aes-256-cbc -salt -in file.txt -out file.enc # the same, only the output is base64 encoded for, e.g., e-mail openssl enc -aes-256-cbc -a -salt -in file.txt -out file.enc</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >To decrypt&nbsp;<code>file.enc</code>&nbsp;you or the file’s recipient will need to remember the cipher and the passphrase.</p><pre style="white-space: normal;"   ># decrypt binary file.enc openssl enc -d -aes-256-cbc -in file.enc # decrypt base64-encoded version openssl enc -d -aes-256-cbc -a -in file.enc</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If you’d like to avoid typing a passphrase every time you encrypt or decrypt a file, the<em>openssl(1)</em>&nbsp;man page provides the details under the heading&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >“<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >PASS PHRASE ARGUMENTS.</span>”</span>&nbsp;The format of the password argument is fairly simple.</p><pre style="white-space: normal;"   ># provide password on command line openssl enc -aes-256-cbc -salt -in file.txt \ -out file.enc -pass pass:mySillyPassword # provide password in a file openssl enc -aes-256-cbc -salt -in file.txt \ -out file.enc -pass file:/path/to/secret/password.txt</pre></div></div><div><div><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >Errors</h2></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I interpret SSL error messages?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Poking through your system logs, you see some error messages that are evidently related to OpenSSL or crypto:</p><pre style="white-space: normal;"   >sshd[31784]: error: RSA_public_decrypt failed: error:0407006A:lib(4):func(112):reason(106) sshd[770]: error: RSA_public_decrypt failed: error:0407006A:lib(4):func(112):reason(106)</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >The first step to figure out what’s going wrong is to use the&nbsp;<code>errstr</code>&nbsp;option to intrepret the error code. The code number is found between&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >“<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >error:</span>”</span>&nbsp;and&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >“<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >:lib</span>”</span>. In this case, it’s 0407006A.</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl errstr 0407006A</strong>&nbsp;error:0407006A:rsa routines:RSA_padding_check_PKCS1_type_1:block type is not 01</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If you’ve got a full OpenSSL installation, including all the development documentation, you can start your investigation there. In this example, the&nbsp;<em>RSA_padding_add_PKCS1_type_1(3)</em>&nbsp;man page will inform you that PKCS #1 involves block methods for signatures. After that, of course, you’d need to pore through your application’s source code to identify when it would expect be receiving those sorts of packets.</p></div><div><div><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >Keys</h2></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I generate an RSA key?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Use the&nbsp;<code>genrsa</code>&nbsp;option.</p><pre style="white-space: normal;"   ># default 512-bit key, sent to standard output openssl genrsa # 1024-bit key, saved to file named mykey.pem openssl genrsa -out mykey.pem 1024 # same as above, but encrypted with a passphrase openssl genrsa -des3 -out mykey.pem 1024</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I generate a public RSA key?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Use the&nbsp;<code>rsa</code>&nbsp;option to produce a public version of your private RSA key.</p><pre style="white-space: normal;"   >openssl rsa -in mykey.pem -pubout</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I generate a DSA key?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Building DSA keys requires a parameter file, and DSA verify operations are slower than their RSA counterparts, so they aren’t as widely used as RSA keys.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If you’re only going to build a single DSA key, you can do so in just one step using the&nbsp;<code>dsaparam</code>subcommand.</p><pre style="white-space: normal;"   ># key will be called dsakey.pem openssl dsaparam -noout -out dsakey.pem -genkey 1024</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If, on the other hand, you’ll be creating several DSA keys, you’ll probably want to build a shared parameter file before generating the keys. It can take a while to build the parameters, but once built, key generation is done quickly.</p><pre style="white-space: normal;"   ># create parameters in dsaparam.pem openssl dsaparam -out dsaparam.pem 1024 # create first key openssl gendsa -out key1.pem dsaparam.pem # and second ... openssl gendsa -out key2.pem dsaparam.pem</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I create an elliptic curve key?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Routines for working with&nbsp;<a style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.secg.org/"   >elliptic curve cryptography</a>&nbsp;were added to OpenSSL in version 0.9.8. Generating an EC key involves the&nbsp;<code>ecparam</code>&nbsp;option.</p><pre style="white-space: normal;"   >openssl ecparam -out key.pem -name prime256v1 -genkey # openssl can provide full list of EC parameter names suitable for # passing to the -name option above: openssl ecparam -list_curves</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I remove a passphrase from a key?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Perhaps you’ve grown tired of typing your passphrase every time your secure daemon starts. You can decrypt your key, removing the passphrase requirement, using the&nbsp;<code>rsa</code>&nbsp;or&nbsp;<code>dsa</code>&nbsp;option, depending on the signature algorithm you chose when creating your private key.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If you created an RSA key and it is stored in a standalone file called&nbsp;<code>key.pem</code>, then here’s how to output a decrypted version of the same key to a file called&nbsp;<code>newkey.pem</code>.</p><pre style="white-space: normal;"   ># you'll be prompted for your passphrase one last time openssl rsa -in key.pem -out newkey.pem</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Often, you’ll have your private key and public certificate stored in the same file. If they are stored in a file called&nbsp;<code>mycert.pem</code>, you can construct a decrypted version called&nbsp;<code>newcert.pem</code>&nbsp;in two steps.</p><pre style="white-space: normal;"   ># you'll need to type your passphrase once more openssl rsa -in mycert.pem -out newcert.pem openssl x509 -in mycert.pem &gt;&gt;newcert.pem</pre></div></div><div><div><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >Password hashes</h2></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Using the&nbsp;<code>passwd</code>&nbsp;option, you can generate password hashes that interoperate with traditional<code>/etc/passwd</code>&nbsp;files, newer-style&nbsp;<code>/etc/shadow</code>&nbsp;files, and Apache password files.</p><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I generate a crypt-style password hash?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >You can generate a new hash quite simply:</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl passwd MySecret</strong>&nbsp;8E4vqBR4UOYF.</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If you know an existing password’s&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >“<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   >salt,</span>”</span>&nbsp;you can duplicate the hash.</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl passwd -salt 8E MySecret</strong>&nbsp;8E4vqBR4UOYF.</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I generate a shadow-style password hash?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Newer Unix systems use a more secure MD5-based hashing mechanism that uses an eight-character salt (as compared to the two-character salt in traditional crypt()-style hashes). Generating them is still straightforward using the&nbsp;<code>-1</code>&nbsp;option:</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl passwd -1 MySecret</strong>&nbsp;$1$sXiKzkus$haDZ9JpVrRHBznY5OxB82.</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >The salt in this format consists of the eight characters between the second and third dollar signs, in this case&nbsp;<code>sXiKzkus</code>. So you can also duplicate a hash with a known salt and password.</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl passwd -1 -salt sXiKzkus MySecret</strong>&nbsp;$1$sXiKzkus$haDZ9JpVrRHBznY5OxB82.</pre></div></div><div><div><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >Prime numbers</h2></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Current cryptographic techniques rely heavily on the generation and testing of prime numbers, so it’s no surprise that the OpenSSL libraries contain several routines dealing with primes. Beginning with version 0.9.7e (or so), the&nbsp;<code>prime</code>&nbsp;option was added to the openssl binary.</p><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I test whether a number is prime?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Pass the number to the&nbsp;<code>prime</code>&nbsp;option. Note that the number returned by openssl will be in hex, not decimal, format.</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl prime 119054759245460753</strong>&nbsp;1A6F7AC39A53511 is not prime</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >You can also pass hex numbers directly.</p><pre style="white-space: normal;"   >$&nbsp;<strong>openssl prime -hex 2f</strong>&nbsp;2F is prime</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I generate a set of prime numbers?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Pass a bunch of numbers to openssl and see what sticks. The&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>seq</strong></span>&nbsp;utility is useful in this capacity.</p><pre style="white-space: normal;"   ># define start and ending points AQUO=10000 ADQUEM=10100 for N in $(seq $AQUO $ADQUEM); do # use bc to convert hex to decimal openssl prime $N | awk '/is prime/ {print "ibase=16;"$1}' | bc done</pre></div></div><div><div><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >Random data</h2></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I generate random data?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Use the&nbsp;<code>rand</code>&nbsp;option to generate binary or base64-encoded data.</p><pre style="white-space: normal;"   ># write 128 random bytes of base64-encoded data to stdout openssl rand -base64 128 # write 1024 bytes of binary random data to a file openssl rand -out random-data.bin 1024 # seed openssl with semi-random bytes from browser cache cd $(find ~/.mozilla/firefox -type d -name Cache) openssl rand -rand $(find . -type f -printf '%f:') -base64 1024</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >On a Unix box with a&nbsp;<code>/dev/urandom</code>&nbsp;device and a copy of GNU&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>head</strong></span>, you can achieve a similar effect, often with better entropy:</p><pre style="white-space: normal;"   ># get 32 bytes from /dev/urandom and base64 encode them head -c 32 /dev/urandom | openssl enc -base64</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Make sure you know the trade-offs between the&nbsp;<code>random</code>&nbsp;and&nbsp;<code>urandom</code>&nbsp;devices before relying on them for truly critical entropy. Consult the&nbsp;<em>random(4)</em>&nbsp;man page on Linux and BSD systems, or&nbsp;<em>random(7D)</em>on Solaris, for further information.</p></div><div><div><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >S/MIME</h2></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   ><a style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.ietf.org/html.charters/smime-charter.html"   >S/MIME</a>&nbsp;is a standard for sending and receiving secure MIME data, especially in e-mail messages. Automated S/MIME capabilities have been added to quite a few e-mail clients, though&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>openssl</strong></span>&nbsp;can provide command-line S/MIME services using the&nbsp;<code>smime</code>&nbsp;option.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Note that the documentation in the&nbsp;<a style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.openssl.org/docs/apps/smime.html"   >smime(1)</a>&nbsp;man page includes a number of good examples.</p><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I verify a signed S/MIME message?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >It’s pretty easy to verify a signed message. Use your mail client to save the signed message to a file. In this example, I assume that the file is named&nbsp;<code>msg.txt</code>.</p><pre style="white-space: normal;"   >openssl smime -verify -in msg.txt</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If the sender’s certificate is signed by a certificate authority trusted by your OpenSSL infrastructure, you’ll see some mail headers, a copy of the message, and a concluding line that says&nbsp;<code>Verification successful</code>.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If the messages has been modified by an unauthorized party, the output will conclude with a failure message indicating that the digest and/or the signature doesn’t match what you received:</p><pre style="white-space: normal;"   >Verification failure 23016:error:21071065:PKCS7 routines:PKCS7_signatureVerify:digest failure:pk7_doit.c:804: 23016:error:21075069:PKCS7 routines:PKCS7_verify:signature failure:pk7_smime.c:265:</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Likewise, if the sender’s certificate isn’t recognized by your OpenSSL infrastructure, you’ll get a similar error:</p><pre style="white-space: normal;"   >Verification failure 9544:error:21075075:PKCS7 routines:PKCS7_verify:certificate verify error:pk7_smime.c:222:Verify error:self signed certificate</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Most e-mail clients send a copy of the public certificate in the signature attached to the message. From the command line, you can view the certificate data yourself. You’ll use the&nbsp;<code>smime -pk7out</code>&nbsp;option to pipe a copy of the PKCS#7 certificate back into the&nbsp;<code>pkcs7</code>&nbsp;option. It’s oddly cumbersome but it works.</p><pre style="white-space: normal;"   >openssl smime -pk7out -in msg.txt | \ openssl pkcs7 -text -noout -print_certs</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If you’d like to extract a copy of your correspondent’s certificate for long-term use, use just the first part of that pipe.</p><pre style="white-space: normal;"   >openssl smime -pk7out -in msg.txt -out her-cert.pem</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >At that point, you can either&nbsp;<a title="How do I get OpenSSL to recognize/verify a certificate?" style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.madboa.com/geek/openssl/#verify-new"   >integrate it into your OpenSSL infrastructure</a>&nbsp;or you can save it off somewhere for special use.</p><pre style="white-space: normal;"   >openssl smime -verify -in msg.txt -CAfile /path/to/her-cert.pem</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I encrypt a S/MIME message?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >Let’s say that someone sends you her public certificate and asks that you encrypt some message to her. You’ve saved her certificate as&nbsp;<code>her-cert.pem</code>. You’ve saved your reply as&nbsp;<code>my-message.txt</code>.</p><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >To get the default―though fairly weak―RC2-40 encryption, you just tell&nbsp;<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>openssl</strong></span>&nbsp;where the message and the certificate are located.</p><pre style="white-space: normal;"   >openssl smime her-cert.pem -encrypt -in my-message.txt</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If you’re pretty sure your remote correspondent has a robust SSL toolkit, you can specify a stronger encryption algorithm like triple DES:</p><pre style="white-space: normal;"   >openssl smime her-cert.pem -encrypt -des3 -in my-message.txt</pre><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >By default, the encrypted message, including the mail headers, is sent to standard output. Use the<code>-out</code>&nbsp;option or your shell to redirect it to a file. Or, much trickier, pipe the output directly to<span style="word-wrap: normal; word-break: normal; line-height: 21px;"   ><strong>sendmail</strong></span>.</p><pre style="white-space: normal;"   >openssl smime her-cert.pem \ -encrypt \ -des3 \ -in my-message.txt \ -from 'Your Fullname &lt;you@youraddress.com&gt;' \ -to 'Her Fullname &lt;her@heraddress.com&gt;' \ -subject 'My encrypted reply' |\ sendmail her@heraddress.com</pre></div><div><div><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none;"   >How do I sign a S/MIME message?</h3></div><p style="margin-top: 0px; margin-bottom: 5px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;"   >If you don’t need to encrypt the entire message, but you do want to sign it so that your recipient can be assured of the message’s integrity, the recipe is similar to that for<a title="How do I encrypt a S/MIME message?" style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="http://www.madboa.com/geek/openssl/#smime-encrypt"   >encryption</a>. The main difference is that you need to have your own key and certificate, since you can’t sign anything with the recipient’s cert.</p><pre style="white-space: normal;"   >openssl smime \ -sign \ -signer /path/to/your-cert.pem \ -in my-message.txt \ -from 'Your Fullname &lt;you@youraddress.com&gt;' \ -to 'Her Fullname &lt;her@heraddress.com&gt;' \ -subject 'My signed reply' |\ sendmail&nbsp;<a style="text-decoration: none; color: rgb(86, 96, 83);" rel="nofollow" href="mailto:her@heraddress.com"   >her@heraddress.com</a></pre></div></div><div><br></div></div></div></div></div><wbr></div>
	</div>
</div>
</body>
</html>