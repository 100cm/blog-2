<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL pending patch : fail-back without fresh backup (have bug?)</h2>
	<h5 id="">2013-08-06 10:22:24&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020137551911457/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>[补充说明]</div><div>本文测试fail-back未成功的bug是-m immediate的一个bug, 已经修复 :&nbsp;</div><div><a rel="nofollow" href="http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=91c3613d3748d881706c3e60d8221ea92833ac1a"   >http://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=91c3613d3748d881706c3e60d8221ea92833ac1a</a></div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020137894542352/"   >http://blog.163.com/digoal@126/blog/static/16387704020137894542352/</a></div><div>[正文]</div><div>PostgreSQL的流复制应用非常普遍, 同时也可以作为HA的关键技术, 当主节点出现故障时, 可以通过激活备节点的方法达到高可用到目的.</div><div>当备份节点激活后, 原来的主节点可以作为备节点来使用.&nbsp;</div><div>但是, 如果主节点在发生故障前的WAL没有全部同步给备节点的话, 备节点激活后, 实际上与主节点是存在一定差异的. 这种情况下主节点不能直接作为备节点参与利用流复制做的增量恢复. &nbsp;遇到这样的情况<span style="line-height: 22px;"   >怎么样把主节点变成备节点呢?</span></div><div><span style="line-height: 22px;"   >1. 使用pg_basebackup, 或者COPY 的方法重新做一个standby, 这样的话相当于要把整个数据库的数据文件全部传一遍. 数据量大或者网络交差的话是比较痛苦的事情.</span></div><div><span style="line-height: 22px;"   >2. 使用rsync, 只传输增量数据, 但是需要注意的是, 如果数据库很大的话, rsync的数据比对过程非常漫长, 并且要消耗大量的io资源.</span></div><div><span style="line-height: 22px;"   >除了以上两种方法, 还有其他的工具可以利用, 例如</span><span style="line-height: 22px;"   >在此前写过一篇关于fail-back的工具pg_rewind的使用文章.&nbsp;</span></div><div><span style="line-height: 22px;"   >pg_rewind利用新的primary的history 文件, 取出切换时间线是的xlog位置信息, 用这个位置信息来匹配旧的primary节点的xlog文件中的信息, 如果旧的primary在这个点之后还产生了xlog信息, 那么说明standby在promote后有未同步至standby节点的xlog数据, 所以需要对这部分xlog做差异处理. 把这部分xlog对应的变更的块以及控制文件,clog等从新的primary拷贝到老的primary节点.&nbsp;</span></div><div><span style="line-height: 22px;"   >具体可参考 :&nbsp;</span></div><div><a style="line-height: 22px;" href="http://blog.163.com/digoal@126/blog/static/1638770402013758511857/"   >http://blog.163.com/digoal@126/blog/static/1638770402013758511857/</a></div><div><span style="line-height: 22px;"   >除了pg_rewind, PostgreSQL可能在内核中加入类似pg_rewind的功能, 当然原理完全不一样, 加入内核的功能原理如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >The proposal is based on the concept of master should not do any file</font></div><div><font size="2"   >system level change until corresponding WAL record is replicated to the</font></div><div><font size="2"   >standby.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >There are many places in the code which need to be handled to support the</font></div><div><font size="2"   >proposed solution. &nbsp;Following cases explains the need of fresh backup at</font></div><div><font size="2"   >the time of failover, and how can we avoid this need by our approach.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >1. We must not write any heap pages to the disk before the WAL records</font></div><div><font size="2"   >corresponding to those changes are received by the standby. Otherwise if</font></div><div><font size="2"   >standby failed to receive WAL corresponding to those heap pages there will</font></div><div><font size="2"   >be inconsistency.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >2. When CHECKPOINT happens on the master, control file of master gets</font></div><div><font size="2"   >updated and last checkpoint record is written to it. Suppose failover</font></div><div><font size="2"   >happens and standby fails to receive the WAL record corresponding to</font></div><div><font size="2"   >CHECKPOINT, then master and standby has inconsistent copies of control file</font></div><div><font size="2"   >that leads to the mismatch in redo record and recovery will not start</font></div><div><font size="2"   >normally. To avoid this situation we must not update the control file of</font></div><div><font size="2"   >master before the corresponding checkpoint WAL record is received by the</font></div><div><font size="2"   >standby</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >3. Also when we truncate any of the physical files on the master and</font></div><div><font size="2"   >suppose the standby failed to receive corresponding WAL, then that physical</font></div><div><font size="2"   >file is truncated on master but still available on standby causing</font></div><div><font size="2"   >inconsistency. To avoid this we must not truncate physical files on the</font></div><div><font size="2"   >master before the WAL record corresponding to that operation is received by</font></div><div><font size="2"   >the standby.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >4. Same case applies to CLOG pages. If CLOG page is written to the disk and</font></div><div><font size="2"   >corresponding WAL record is not replicated to the standby, leads to the</font></div><div><font size="2"   >inconsistency. So we must not write the CLOG pages (and may be other SLRU</font></div><div><font size="2"   >pages too) to the disk before the corresponding WAL records are received by</font></div><div><font size="2"   >standby.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >5. The same problem applies for the commit hint bits. But it is more</font></div><div><font size="2"   >complicated than the other problems, because no WAL records are generated</font></div><div><font size="2"   >for that, hence we cannot apply the same above method, that is wait for</font></div><div><font size="2"   >corresponding WAL record to be replicated on standby. &nbsp;So we delay the</font></div><div><font size="2"   >processes of updating the commit hint bits, similar to what is done by</font></div><div><font size="2"   >asynchronous commits. &nbsp;In other words we need to check if the WAL</font></div><div><font size="2"   >corresponding to the transaction commit is received by the failback safe</font></div><div><font size="2"   >standby and then only allow hint bit updates.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >*Patch explanation:*</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The initial work on this patch is done by Pavan Deolasee. I tested it and</font></div><div><font size="2"   >will make further enhancements based on the community feedback.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >This patch is not complete yet, but I plan to do so with the help of this</font></div><div><font size="2"   >community. At this point, the primary purpose is to understand the</font></div><div><font size="2"   >complexities and get some initial performance numbers to alleviate some of</font></div><div><font size="2"   >the concerns raised by the community.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >There are two GUC parameters which supports this failsafe standby</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >1. failback_safe_standby_name &nbsp;[ name of the failsafe standby ] It is the</font></div><div><font size="2"   >name of failsafe standby. Master will not do any file system level change</font></div><div><font size="2"   >before corresponding WAL is replicated on the this failsafe standby</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >2. failback_safe_standby_mode &nbsp;[ off/remote_write/remote_flush] This</font></div><div><font size="2"   >parameter specifies the behavior of master i.e. whether it should wait for</font></div><div><font size="2"   >WAL to be written on standby or WAL to be flushed on standby. &nbsp;We should</font></div><div><font size="2"   >turn it off when we do not want the failsafe standby. This failsafe mode</font></div><div><font size="2"   >can be combined with synchronous as well as asynchronous streaming</font></div><div><font size="2"   >replication.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Most of the changes are done in the syncrep.c. This is a slight misnomer</font></div><div><font size="2"   >because that file deals with synchronous standby and a failback standby</font></div><div><font size="2"   >could and most like be a async standby. But keeping the changes this way</font></div><div><font size="2"   >has ensured that the patch is easy to read. Once we have acceptance on the</font></div><div><font size="2"   >approach, the patch can be modified to reorganize the code in a more</font></div><div><font size="2"   >logical way.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The patch adds a new state SYNC_REP_WAITING_FOR_FAILBACK_SAFETY to the sync</font></div><div><font size="2"   >standby states. A backend which is waiting for a failback safe standby to</font></div><div><font size="2"   >receive WAL records, will wait in this state. &nbsp;Failback safe mechanism can</font></div><div><font size="2"   >work in two different modes, that is wait for WAL to be written or flushed</font></div><div><font size="2"   >on failsafe standby. That is represented by two new modes</font></div><div><font size="2"   >SYNC_REP_WAIT_FAILBACK_SAFE_WRITE and SYNC_REP_WAIT_FAILBACK_SAFE_FLUSH</font></div><div><font size="2"   >respectively.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Also the SyncRepWaitForLSN() is changed for conditional wait. So that we</font></div><div><font size="2"   >can delay hint bit updates on master instead of blocking the wait for the</font></div><div><font size="2"   >failback safe standby to receiver WAL's.</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >到第四版的补丁, 新增的参数名更改为</span>synchronous_transfer, 可配置3个值 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >synchronous_transfer = commit &nbsp; # data page synchronization level</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # commit, data_flush or all</font></div><p></p></pre></div><div>synchronous_transfer参数的含义 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >-'commit'</font></div><div><font size="2"   >&nbsp; &nbsp; 'commit' means that master waits for corresponding WAL to flushed</font></div><div><font size="2"   >to disk of standby server on commits.</font></div><div><font size="2"   >&nbsp; &nbsp; but master doesn't waits for replicated data pages.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; -'data_flush'</font></div><div><font size="2"   >&nbsp; &nbsp; 'data_flush' means that master waits for replicated data page</font></div><div><font size="2"   >(e.g, CLOG, pg_control) before flush to disk of master server.</font></div><div><font size="2"   >&nbsp; &nbsp; but if user set to 'data_flush' to this parameter,</font></div><div><font size="2"   >'synchronous_commit' values is ignored even if user set</font></div><div><font size="2"   >'synchronous_commit'.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; -'all'</font></div><div><font size="2"   >&nbsp; &nbsp; 'all' means that master waits for replicated WAL and data page.</font></div><p></p></pre></div><div>commit类似同步流复制,记录master节点的commit状态前,等待该xlog已经在standby flushed to disk.&nbsp;</div><div>data_flush则表示master节点在flush data page前, 必须确保这些变更对应的xlog信息已经在standby 节点flush to disk了. (这个配置将忽略synchronous_commit的配置)</div><div><br></div><div>同步流复制增加1种等待模式(<span style="line-height: 22px;"   >SYNC_REP_WAIT_DATA_FLUSH</span><span style="line-height: 22px;"   >) :&nbsp;</span></div><div><div>+++ b/src/include/replication/syncrep.h</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >@@ -19,23 +19,42 @@</font></div><div><font size="2"   >&nbsp;#define SyncRepRequested() \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; (max_wal_senders &gt; 0 &amp;&amp; synchronous_commit &gt; SYNCHRONOUS_COMMIT_LOCAL_FLUSH)</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >+#define SyncTransRequested() \</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; (max_wal_senders &gt; 0 &amp;&amp; synchronous_transfer &gt; SYNCHRONOUS_TRANSFER_COMMIT)</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+#define IsSyncRepSkipped() \</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; (max_wal_senders &gt; 0 &amp;&amp; synchronous_transfer == &nbsp;SYNCHRONOUS_TRANSFER_DATA_FLUSH)</font></div><div><font size="2"   >+</font></div><div><font size="2"   >&nbsp;/* SyncRepWaitMode */</font></div><div><font size="2"   >-#define SYNC_REP_NO_WAIT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -1</font></div><div><font size="2"   >-#define SYNC_REP_WAIT_WRITE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"   >-#define SYNC_REP_WAIT_FLUSH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"   >+#define SYNC_REP_NO_WAIT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -1</font></div><div><font size="2"   >+#define SYNC_REP_WAIT_WRITE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"   >+#define SYNC_REP_WAIT_FLUSH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"   >+#define SYNC_REP_WAIT_DATA_FLUSH &nbsp; &nbsp; &nbsp; 2</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >-#define NUM_SYNC_REP_WAIT_MODE 2</font></div><div><font size="2"   >+#define NUM_SYNC_REP_WAIT_MODE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >&nbsp;/* syncRepState */</font></div><div><font size="2"   >-#define SYNC_REP_NOT_WAITING &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0</font></div><div><font size="2"   >-#define SYNC_REP_WAITING &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1</font></div><div><font size="2"   >-#define SYNC_REP_WAIT_COMPLETE &nbsp; &nbsp; &nbsp; &nbsp; 2</font></div><div><font size="2"   >+#define SYNC_REP_NOT_WAITING &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0</font></div><div><font size="2"   >+#define SYNC_REP_WAITING &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1</font></div><div><font size="2"   >+#define SYNC_REP_WAIT_COMPLETE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2</font></div><div><font size="2"   >+</font></div><div><font size="2"   >+typedef enum</font></div><div><font size="2"   >+{</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; SYNCHRONOUS_TRANSFER_COMMIT, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* no wait for flush data page */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; SYNCHRONOUS_TRANSFER_DATA_FLUSH, &nbsp; &nbsp; &nbsp; &nbsp;/* wait for data page flush only</font></div></div><div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* no wait for WAL */</font></div><div><font size="2"   >+ &nbsp; &nbsp; &nbsp; SYNCHRONOUS_TRANSFER_ALL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* wait for data page flush */</font></div><div><font size="2"   >+} &nbsp; &nbsp; &nbsp;SynchronousTransferLevel;</font></div></div><p></p></pre></div></div><div>src/backend/replication/syncrep.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* ===========================================================</font></div><div><font size="2"   >&nbsp;* Synchronous Replication functions for normal user backends</font></div><div><font size="2"   >&nbsp;* ===========================================================</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Wait for synchronous replication, if requested by user.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Initially backends start in state SYNC_REP_NOT_WAITING and then</font></div><div><font size="2"   >&nbsp;* change that state to SYNC_REP_WAITING/SYNC_REP_WAITING_FOR_DATA_FLUSH</font></div><div><font size="2"   >&nbsp;* before adding ourselves to the wait queue. During SyncRepWakeQueue() a</font></div><div><font size="2"   >&nbsp;* WALSender changes the state to SYNC_REP_WAIT_COMPLETE once replication is</font></div><div><font size="2"   >&nbsp;* confirmed. This backend then resets its state to SYNC_REP_NOT_WAITING.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* ForDataFlush - if TRUE, we wait for the flushing data page.</font></div><div><font size="2"   >&nbsp;* Otherwise wait for the sync standby</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Wait - if FALSE, we don't actually wait, but tell the caller whether or not</font></div><div><font size="2"   >&nbsp;* the standby has already made progressed upto the given XactCommitLSN</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Return TRUE if either the sync standby is not</font></div><div><font size="2"   >&nbsp;* configured/turned off OR the standby has made enough progress</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >bool</font></div><div><font size="2"   >SyncRepWaitForLSN(XLogRecPtr XactCommitLSN, bool ForDataFlush, bool Wait)</font></div><p></p></pre></div><div>[测试]</div><div>下载PostgreSQL src :&nbsp;</div><div><a target="_blank" rel="nofollow" href="http://git.postgresql.org/gitweb/?p=postgresql.git;a=snapshot;h=e5592c61adb0766eaee53ec07d2f05783d1c6548;sf=tgz"   >http://git.postgresql.org/gitweb/?p=postgresql.git;a=snapshot;h=e5592c61adb0766eaee53ec07d2f05783d1c6548;sf=tgz</a></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >tar -zxvf postgresql-e5592c6.tar.gz</font></div><div><font size="2"   >cd&nbsp;<span style="line-height: 22px;"   >postgresql-e5592c6</span></font></div><p></p></pre></div><div><span style="line-height: 22px;"   >补丁 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 postgresql-e5592c6]# wget http://www.postgresql.org/message-id/attachment/29640/failback_safe_standby_v4.patch</font></div><div><div><font size="2"   >[root@db-172-16-3-39 postgresql-e5592c6]# patch -p1 &lt; ./failback_safe_standby_v4.patch&nbsp;</font></div><div><font size="2"   >patching file src/backend/access/transam/clog.c</font></div><div><font size="2"   >patching file src/backend/access/transam/slru.c</font></div><div><font size="2"   >patching file src/backend/access/transam/twophase.c</font></div><div><font size="2"   >patching file src/backend/access/transam/xact.c</font></div><div><font size="2"   >patching file src/backend/access/transam/xlog.c</font></div><div><font size="2"   >patching file src/backend/catalog/storage.c</font></div><div><font size="2"   >patching file src/backend/replication/syncrep.c</font></div><div><font size="2"   >patching file src/backend/storage/buffer/bufmgr.c</font></div><div><font size="2"   >patching file src/backend/utils/cache/relmapper.c</font></div><div><font size="2"   >patching file src/backend/utils/misc/guc.c</font></div><div><font size="2"   >patching file src/backend/utils/misc/postgresql.conf.sample</font></div><div><font size="2"   >patching file src/backend/utils/time/tqual.c</font></div><div><font size="2"   >patching file src/include/access/xlog.h</font></div><div><font size="2"   >patching file src/include/replication/syncrep.h</font></div></div><p></p></pre></div><div>安装PostgreSQL</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 postgresql-e5592c6]# ./configure --prefix=/home/pg94/pgsql9.4devel --with-pgport=2999 --with-perl --with-tcl --with-python --with-openssl --with-pam --without-ldap --with-libxml --with-libxslt --enable-thread-safety --with-wal-blocksize=16 &amp;&amp; gmake &amp;&amp; gmake install</font></div><div><font size="2"   >cd contrib</font></div><div><font size="2"   >gmake</font></div><div><font size="2"   >gmake install</font></div><p></p></pre></div><div>初始化数据库</div><pre class="prettyprint"   ><p></p><div><font size="2"   >initdb -D $PGDATA -E UTF8 --locale=C -W -U postgres</font></div><div></div><p></p></pre><div><span style="line-height: 22px;"   >配置master</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >cd $PGDATA</font></div><div><div><font size="2"   >vi pg_hba.conf&nbsp;</font></div><div><div><font size="2"   >host replication postgres 172.16.3.0/24 md5</font></div><div><font size="2"   >host all all 0.0.0.0/0 md5</font></div></div><div><font size="2"   >vi postgresql.conf&nbsp;</font></div></div><div><div><font size="2"   >listen_addresses = '0.0.0.0' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# what IP address(es) to listen on;</font></div><div><font size="2"   >port = 2999 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # (change requires restart)</font></div><div><font size="2"   >max_connections = 100 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # (change requires restart)</font></div><div><font size="2"   >superuser_reserved_connections = 13 &nbsp; &nbsp; # (change requires restart)</font></div><div><font size="2"   >unix_socket_directories = '.' &nbsp; # comma-separated list of directories</font></div><div><font size="2"   >unix_socket_permissions = 0700 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# begin with 0 to use octal notation</font></div><div><font size="2"   >tcp_keepalives_idle = 60 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# TCP_KEEPIDLE, in seconds;</font></div><div><font size="2"   >tcp_keepalives_interval = 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# TCP_KEEPINTVL, in seconds;</font></div><div><font size="2"   >tcp_keepalives_count = 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # TCP_KEEPCNT;</font></div><div><font size="2"   >shared_buffers = 1024MB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # min 128kB</font></div><div><font size="2"   >maintenance_work_mem = 512MB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# min 1MB</font></div><div><font size="2"   >shared_preload_libraries = 'pg_stat_statements' &nbsp; &nbsp; &nbsp; &nbsp; # (change requires restart)</font></div><div><font size="2"   >vacuum_cost_delay = 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 0-100 milliseconds</font></div><div><font size="2"   >vacuum_cost_limit = 10000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 1-10000 credits</font></div><div><font size="2"   >bgwriter_delay = 10ms &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 10-10000ms between rounds</font></div><div><font size="2"   >wal_level = hot_standby &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # minimal, archive, or hot_standby</font></div><div><font size="2"   >synchronous_commit = remote_write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # synchronization level;</font></div><div><font size="2"   >wal_sync_method = fdatasync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # the default is the first option</font></div><div><font size="2"   >full_page_writes = on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # recover from partial page writes</font></div><div><font size="2"   >wal_buffers = 16384kB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # min 32kB, -1 sets based on shared_buffers</font></div><div><font size="2"   >checkpoint_segments = 32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# in logfile segments, min 1, 16MB each</font></div><div><font size="2"   >archive_mode = on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # allows archiving to be done</font></div><div><font size="2"   >archive_command = '/bin/date' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # command to use to archive a logfile segment</font></div><div><font size="2"   >max_wal_senders = 32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# max number of walsender processes</font></div><div><font size="2"   >wal_keep_segments = 128 &nbsp; &nbsp; &nbsp; &nbsp; # in logfile segments, 16MB each; 0 disables</font></div><div><font size="2"   >synchronous_transfer = data_flush &nbsp; # data page synchronization level</font></div><div><font size="2"   >hot_standby = on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# "on" allows queries during recovery</font></div><div><font size="2"   >max_standby_archive_delay = 300s &nbsp; &nbsp; &nbsp; &nbsp;# max delay before canceling queries</font></div><div><font size="2"   >max_standby_streaming_delay = 300s &nbsp; &nbsp; &nbsp;# max delay before canceling queries</font></div><div><font size="2"   >wal_receiver_status_interval = 1s &nbsp; &nbsp; &nbsp; # send replies at least this often</font></div><div><font size="2"   >hot_standby_feedback = on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # send info from standby to prevent</font></div><div><font size="2"   >random_page_cost = 1.5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# same scale as above</font></div><div><font size="2"   >effective_cache_size = 128000MB</font></div><div><font size="2"   >log_destination = 'csvlog' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Valid values are combinations of</font></div><div><font size="2"   >logging_collector = on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Enable capturing of stderr and csvlog</font></div><div><font size="2"   >log_directory = 'pg_log' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# directory where log files are written,</font></div><div><font size="2"   >log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log' # log file name pattern,</font></div><div><font size="2"   >log_file_mode = 0600 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# creation mode for log files,</font></div><div><font size="2"   >log_truncate_on_rotation = on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # If on, an existing log file with the</font></div><div><font size="2"   >log_rotation_age = 1d &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Automatic rotation of logfiles will</font></div><div><font size="2"   >log_rotation_size = 10MB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Automatic rotation of logfiles will</font></div><div><font size="2"   >log_checkpoints = on</font></div><div><font size="2"   >log_connections = on</font></div><div><font size="2"   >log_disconnections = on</font></div><div><font size="2"   >log_error_verbosity = verbose &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # terse, default, or verbose messages</font></div><div><font size="2"   >log_timezone = 'PRC'</font></div><div><font size="2"   >autovacuum = on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Enable autovacuum subprocess? &nbsp;'on'</font></div><div><font size="2"   >log_autovacuum_min_duration = 0 # -1 disables, 0 logs all actions and</font></div><div><font size="2"   >datestyle = 'iso, mdy'</font></div><div><font size="2"   >timezone = 'PRC'</font></div><div><font size="2"   >lc_messages = 'C' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # locale for system error message</font></div><div><font size="2"   >lc_monetary = 'C' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # locale for monetary formatting</font></div><div><font size="2"   >lc_numeric = 'C' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# locale for number formatting</font></div><div><font size="2"   >lc_time = 'C' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # locale for time formatting</font></div><div><font size="2"   >default_text_search_config = 'pg_catalog.english'</font></div><div><font size="2"   >pg_stat_statements.max = 1000</font></div><div><font size="2"   >pg_stat_statements.track = all</font></div></div><div><font size="2"   >vi ~/.pgpass</font></div><div><div><font size="2"   >172.16.3.33:2999:replication:postgres:postgres</font></div><div><font size="2"   >172.16.3.39:2999:replication:postgres:postgres</font></div></div><div><font size="2"   >chmod 400 ~/.pgpass</font></div><div><font size="2"   >vi $PGDATA/recovery.done</font></div><div><font size="2"   >recovery_target_timeline = 'latest'<br>standby_mode = on<br>primary_conninfo = 'host=172.16.3.33 port=2999 user=postgres keepalives_idle=60'                # e.g. 'host=localhost port=5432'</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >创建standby</span></div><div>安装过程略</div><div>复制</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg94@db-172-16-3-33-&gt; pg_basebackup -D $PGDATA -F p -P -v -h 172.16.3.39 -p 2999 -U postgres</font></div><div><font size="2"   >WARNING: &nbsp;skipping special file "./.s.PGSQL.2999"</font></div><div><font size="2"   >WARNING: &nbsp;skipping special file "./.s.PGSQL.2999"94/pg_root/pg_clog/0000)</font></div><div><font size="2"   >26943/26943 kB (100%), 1/1 tablespace &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >NOTICE: &nbsp;pg_stop_backup complete, all required WAL segments have been archived</font></div><div><font size="2"   >pg_basebackup: base backup completed</font></div><p></p></pre></div><div>配置</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >cd $PGDATA</font></div><div><font size="2"   >mv recovery.done recovery.conf</font></div><div><font size="2"   >vi recovery.conf</font></div><div><div><font size="2"   >recovery_target_timeline = 'latest'</font></div><div><font size="2"   >standby_mode = on</font></div><div><font size="2"   >primary_conninfo = 'host=172.16.3.39 port=2999 user=postgres keepalives_idle=60' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# e.g. 'host=localhost port=5432'</font></div></div><p></p></pre></div><div>启动standby</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg_ctl start</font></div><div></div><p></p></pre></div><div><br></div><div>主节点,&nbsp;<span style="line-height: 22px;"   >查看复制状态 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >pg94@db-172-16-3-39-&gt; psql</font></div><div><font size="2"   >psql (9.4devel)</font></div><div><font size="2"   >Type "help" for help.</font></div></div><div><div><font size="2"   >digoal=# select * from pg_stat_replication ;</font></div><div><font size="2"   >&nbsp; pid &nbsp;| usesysid | usename &nbsp;| application_name | client_addr | client_hostname | client_port | &nbsp; &nbsp; &nbsp; &nbsp; backend_start &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; st</font></div><div><font size="2"   >ate &nbsp; | sent_location | write_location | flush_location | replay_location | sync_priority | sync_state&nbsp;</font></div><div><font size="2"   >-------+----------+----------+------------------+-------------+-----------------+-------------+-------------------------------+-----</font></div><div><font size="2"   >------+---------------+----------------+----------------+-----------------+---------------+------------</font></div><div><font size="2"   >&nbsp;12221 | &nbsp; &nbsp; &nbsp; 10 | postgres | walreceiver &nbsp; &nbsp; &nbsp;| 172.16.3.33 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; 20441 | 2013-08-06 09:15:35.617838+08 | stre</font></div><div><font size="2"   >aming | 0/3000090 &nbsp; &nbsp; | 0/3000090 &nbsp; &nbsp; &nbsp;| 0/3000090 &nbsp; &nbsp; &nbsp;| 0/3000090 &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 | async</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div><br></div><div>创建测试表, 测试函数&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# create table test (id int primary key, info text, crt_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# create or replace function func() returns void as $$</font></div><div><font size="2"   >digoal$# declare&nbsp;</font></div><div><font size="2"   >digoal$# &nbsp; v_id int;</font></div><div><font size="2"   >digoal$# begin</font></div><div><font size="2"   >digoal$# &nbsp; v_id := round(5000000*random());</font></div><div><font size="2"   >digoal$# &nbsp; update test set info=md5(random()::text),crt_time=clock_timestamp() where id=v_id;</font></div><div><font size="2"   >digoal$# &nbsp; if found then</font></div><div><font size="2"   >digoal$# &nbsp; &nbsp; return;</font></div><div><font size="2"   >digoal$# &nbsp; else</font></div><div><font size="2"   >digoal$# &nbsp; &nbsp; insert into test values (v_id,md5(random()::text),clock_timestamp());</font></div><div><font size="2"   >digoal$# &nbsp; end if;</font></div><div><font size="2"   >digoal$# &nbsp; return;</font></div><div><font size="2"   >digoal$# end;</font></div><div><font size="2"   >digoal$# $$ language plpgsql strict;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >测试</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select func();</font></div><div><font size="2"   >&nbsp;func&nbsp;</font></div><div><font size="2"   >------</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=# select * from test;</font></div><div><font size="2"   >&nbsp; &nbsp;id &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >---------+----------------------------------+----------------------------</font></div><div><font size="2"   >&nbsp;1894289 | e759b24e9cb227c300f85666c4ac2f81 | 2013-08-06 09:21:30.910392</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div>压力测试 &nbsp;:&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg94@db-172-16-3-39-&gt; vi test.sql</font></div><div><font size="2"   >select func();</font></div><div><div><font size="2"   >pg94@db-172-16-3-39-&gt; pgbench -M prepared -f ./test.sql -r -n -h $PGDATA -p 2999 -U postgres -c 16 -j 4 -T 10 digoal</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 16</font></div><div><font size="2"   >number of threads: 4</font></div><div><font size="2"   >duration: 10 s</font></div><div><font size="2"   >number of transactions actually processed: 211697</font></div><div><font size="2"   >tps = 21156.265771 (including connections establishing)</font></div><div><font size="2"   >tps = 21187.462509 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.752017 &nbsp; &nbsp; &nbsp; &nbsp;select func();</font></div></div><p></p></pre></div><div><br></div><div>测试failback 失败 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg94@db-172-16-3-39-&gt; pgbench -M prepared -f ./test.sql -r -n -h $PGDATA -p 2999 -U postgres -c 16 -j 4 -T 100 digoal</font></div><div><font size="2"   >Client 2 aborted in state 0: ERROR: &nbsp;duplicate key value violates unique constraint "test_pkey"</font></div><div><font size="2"   >DETAIL: &nbsp;Key (id)=(521247) already exists.</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "insert into test values (v_id,md5(random()::text),clock_timestamp())"</font></div><div><font size="2"   >PL/pgSQL function func() line 10 at SQL statement</font></div><div><font size="2"   >Client 14 aborted in state 0: ERROR: &nbsp;duplicate key value violates unique constraint "test_pkey"</font></div><div><font size="2"   >DETAIL: &nbsp;Key (id)=(4957439) already exists.</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "insert into test values (v_id,md5(random()::text),clock_timestamp())"</font></div><div><font size="2"   >PL/pgSQL function func() line 10 at SQL statement</font></div><div><font size="2"   >Client 15 aborted in state 0: ERROR: &nbsp;duplicate key value violates unique constraint "test_pkey"</font></div><div><font size="2"   >DETAIL: &nbsp;Key (id)=(3050904) already exists.</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "insert into test values (v_id,md5(random()::text),clock_timestamp())"</font></div><div><font size="2"   >PL/pgSQL function func() line 10 at SQL statement</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 16</font></div><div><font size="2"   >number of threads: 4</font></div><div><font size="2"   >duration: 100 s</font></div><div><font size="2"   >number of transactions actually processed: 2063626</font></div><div><font size="2"   >tps = 20633.969217 (including connections establishing)</font></div><div><font size="2"   >tps = 20637.002726 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.712672 &nbsp; &nbsp; &nbsp; &nbsp;select func();</font></div><p></p></pre></div><div>以上测试过程中将standby数据库关闭</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg94@db-172-16-3-33-&gt; pg_ctl stop -m fast</font></div><div><font size="2"   >waiting for server to shut down.... done</font></div><div><font size="2"   >server stopped</font></div><p></p></pre></div><div>测试完后, 在主节点执行checkpoint; 因为配置了synchronous_transfer = data_flush. 会出现等待状态!</div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres: checkpointer process &nbsp; &nbsp;waiting for 0/2D0C99D8</font></div><div></div><p></p></pre><div><span style="line-height: 22px;"   >此时停主库也是无法停止的, 也有flush的动作, 所以会等待.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >12198 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 1181m &nbsp;47m &nbsp;46m S &nbsp;0.0 &nbsp;0.6 &nbsp; 0:00.04 /home/pg94/pgsql9.4devel/bin/postgres &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >12199 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 &nbsp;108m 1032 &nbsp;504 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.00 postgres: logger process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >12201 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 1182m 198m 197m S &nbsp;0.0 &nbsp;2.5 &nbsp; 0:00.34 postgres: checkpointer process &nbsp; &nbsp;waiting for 0/2D0C99D8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >12205 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 &nbsp;110m 1024 &nbsp;460 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.01 postgres: archiver process &nbsp; last was 00000001000000000000002C &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >12206 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 &nbsp;110m 1228 &nbsp;576 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.04 postgres: stats collector process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >12687 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 66068 1552 1208 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.01 -bash &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >12786 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 &nbsp;109m 1748 1408 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.00 pg_ctl stop -m fast</font></div><p></p></pre></div><div>使用-m immediate关闭后, 重启主库.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg94@db-172-16-3-39-&gt; psql</font></div><div><font size="2"   >psql (9.4devel)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >digoal=# select count(*),sum(hashtext(test.*::text)) from test;</font></div><div><font size="2"   >&nbsp; count &nbsp;| &nbsp; &nbsp; sum &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >---------+--------------</font></div><div><font size="2"   >&nbsp;1828052 | 747103747132</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>开启standby, 数据一致</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg94@db-172-16-3-33-&gt; psql</font></div><div><font size="2"   >psql (9.4devel)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select count(*),sum(hashtext(test.*::text)) from test;</font></div><div><font size="2"   >&nbsp; count &nbsp;| &nbsp; &nbsp; sum &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >---------+--------------</font></div><div><font size="2"   >&nbsp;1828052 | 747103747132</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>测试fail-over.</div><div>主库测试过程中, &nbsp;promote备库.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg94@db-172-16-3-39-&gt; pgbench -M prepared -f ./test.sql -r -n -h $PGDATA -p 2999 -U postgres -c 16 -j 4 -T 100 digoal</font></div><div><font size="2"   >./test.sql: No such file or directory</font></div><div><font size="2"   >pg94@db-172-16-3-39-&gt; cd</font></div><div><font size="2"   >pg94@db-172-16-3-39-&gt; pgbench -M prepared -f ./test.sql -r -n -h $PGDATA -p 2999 -U postgres -c 16 -j 4 -T 100 digoal</font></div><div><font size="2"   >Client 4 aborted in state 0: ERROR: &nbsp;duplicate key value violates unique constraint "test_pkey"</font></div><div><font size="2"   >DETAIL: &nbsp;Key (id)=(2592452) already exists.</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "insert into test values (v_id,md5(random()::text),clock_timestamp())"</font></div><div><font size="2"   >PL/pgSQL function func() line 10 at SQL statement</font></div><div><font size="2"   >Client 7 aborted in state 0: ERROR: &nbsp;duplicate key value violates unique constraint "test_pkey"</font></div><div><font size="2"   >DETAIL: &nbsp;Key (id)=(3677118) already exists.</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "insert into test values (v_id,md5(random()::text),clock_timestamp())"</font></div><div><font size="2"   >PL/pgSQL function func() line 10 at SQL statement</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >promote备库.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg94@db-172-16-3-33-&gt; pg_ctl promote</font></div><div><font size="2"   >server promoting</font></div><div><font size="2"   >2013-08-06 09:34:46.772 CST,,,4728,,52005220.1278,6,,2013-08-06 09:32:16 CST,1/0,0,LOG,00000,"received promote request",,,,,,,,"CheckForStandbyTrigger, xlog.c:11127",""</font></div><div><font size="2"   >2013-08-06 09:34:46.772 CST,,,4745,,5200523e.1289,2,,2013-08-06 09:32:46 CST,,0,FATAL,57P01,"terminating walreceiver process due to administrator command",,,,,,,,"ProcessWalRcvInterrupts, walreceiver.c:167",""</font></div><div><font size="2"   >2013-08-06 09:34:46.871 CST,,,4728,,52005220.1278,7,,2013-08-06 09:32:16 CST,1/0,0,LOG,00000,"record with zero length at 0/45AD5F80",,,,,,,,"ReadRecord, xlog.c:4420",""</font></div><div><font size="2"   >2013-08-06 09:34:46.871 CST,,,4728,,52005220.1278,8,,2013-08-06 09:32:16 CST,1/0,0,LOG,00000,"redo done at 0/45AD5F50",,,,,,,,"StartupXLOG, xlog.c:6878",""</font></div><div><font size="2"   >2013-08-06 09:34:46.871 CST,,,4728,,52005220.1278,9,,2013-08-06 09:32:16 CST,1/0,0,LOG,00000,"last completed transaction was at log time 2013-08-06 09:34:46.753686+08",,,,,,,,"StartupXLOG, xlog.c:6883",""</font></div><div><font size="2"   >2013-08-06 09:34:46.871 CST,,,4728,,52005220.1278,10,,2013-08-06 09:32:16 CST,1/0,0,LOG,00000,"selected new timeline ID: 2",,,,,,,,"StartupXLOG, xlog.c:6989",""</font></div><div><font size="2"   >2013-08-06 09:34:47.080 CST,,,4728,,52005220.1278,11,,2013-08-06 09:32:16 CST,1/0,0,LOG,00000,"archive recovery complete",,,,,,,,"exitArchiveRecovery, xlog.c:5639",""</font></div><div><font size="2"   >2013-08-06 09:35:21.939 CST,,,4729,,52005220.1279,2,,2013-08-06 09:32:16 CST,,0,LOG,00000,"restartpoint complete: wrote 24656 buffers (18.8%); 0 transaction log file(s) added, 0 removed, 0 recycled; write=149.076 s, sync=0.868 s, total=150.366 s; sync files=41, longest=0.527 s, average=0.021 s",,,,,,,,"LogCheckpointEnd, xlog.c:7898",""</font></div><div><font size="2"   >2013-08-06 09:35:21.939 CST,,,4729,,52005220.1279,3,,2013-08-06 09:32:16 CST,,0,LOG,00000,"recovery restart point at 0/2D0C99D8","last completed transaction was at log time 2013-08-06 09:34:46.753686+08",,,,,,,"CreateRestartPoint, xlog.c:8715",""</font></div><div><font size="2"   >2013-08-06 09:36:03.135 CST,,,4840,"",52005303.12e8,1,"",2013-08-06 09:36:03 CST,,0,LOG,00000,"connection received: host=[local]",,,,,,,,"BackendInitialize, postmaster.c:3923",""</font></div><div><font size="2"   >2013-08-06 09:36:03.136 CST,"postgres","digoal",4840,"[local]",52005303.12e8,2,"authentication",2013-08-06 09:36:03 CST,2/3,0,LOG,00000,"connection authorized: user=postgres database=digoal",,,,,,,,"PerformAuthentication, postinit.c:239",""</font></div><div><font size="2"   >2013-08-06 09:36:16.409 CST,"postgres","digoal",4840,"[local]",52005303.12e8,3,"idle",2013-08-06 09:36:03 CST,,0,LOG,00000,"disconnection: session time: 0:00:13.274 user=postgres database=digoal host=[local]",,,,,,,,"log_disconnections, postgres.c:4427","psql"</font></div><p></p></pre></div><div><br></div><div>注意由于备库也配置了synchronous_transfer = data_flush, 所有的data flush操作都会等待, 所以要尽快把主库转成备库.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg94@db-172-16-3-39-&gt; cd $PGDATA</font></div><div><font size="2"   >pg94@db-172-16-3-39-&gt; mv recovery.done recovery.conf</font></div><div><font size="2"   >pg94@db-172-16-3-39-&gt; pg_ctl restart -m immediate</font></div><div><font size="2"   >waiting for server to shut down.... done</font></div><div><font size="2"   >server stopped</font></div><div><font size="2"   >server starting</font></div><div><font size="2"   >pg94@db-172-16-3-39-&gt; LOG: &nbsp;00000: loaded library "pg_stat_statements"</font></div><div><font size="2"   >LOCATION: &nbsp;load_libraries, miscinit.c:1296</font></div><p></p></pre></div><div>主库 fail-back失败 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >2013-08-06 09:39:38.208 CST,,,13320,,520053da.3408,1,,2013-08-06 09:39:38 CST,,0,LOG,00000,"database system was interrupted; last known up at 2013-08-06 09:32:33 CST",,,,,,,,"StartupXLOG, xlog.c:6080",""</font></div><div><font size="2"   >2013-08-06 09:39:38.208 CST,,,13320,,520053da.3408,2,,2013-08-06 09:39:38 CST,,0,LOG,00000,"entering standby mode",,,,,,,,"StartupXLOG, xlog.c:6133",""</font></div><div><font size="2"   >2013-08-06 09:39:38.208 CST,,,13320,,520053da.3408,3,,2013-08-06 09:39:38 CST,,0,LOG,00000,"database system was not properly shut down; automatic recovery in progress",,,,,,,,"StartupXLOG, xlog.c:6443",""</font></div><div><font size="2"   >2013-08-06 09:39:38.210 CST,,,13320,,520053da.3408,4,,2013-08-06 09:39:38 CST,1/0,0,LOG,00000,"redo starts at 0/36000090",,,,,,,,"StartupXLOG, xlog.c:6687",""</font></div><div><font size="2"   >2013-08-06 09:39:53.644 CST,,,13320,,520053da.3408,5,,2013-08-06 09:39:38 CST,1/0,0,LOG,00000,"record with zero length at 0/52438570",,,,,,,,"ReadRecord, xlog.c:4420",""</font></div><div><font size="2"   >2013-08-06 09:39:53.644 CST,,,13320,,520053da.3408,6,,2013-08-06 09:39:38 CST,1/0,0,LOG,00000,"consistent recovery state reached at 0/52438570",,,,,,,,"CheckRecoveryConsistency, xlog.c:7348",""</font></div><div><font size="2"   >2013-08-06 09:39:53.645 CST,,,13318,,520053da.3406,1,,2013-08-06 09:39:38 CST,,0,LOG,00000,"database system is ready to accept read only connections",,,,,,,,"sigusr1_handler, postmaster.c:4737",""</font></div><div><font size="2"   >2013-08-06 09:39:53.649 CST,,,13339,,520053e9.341b,1,,2013-08-06 09:39:53 CST,,0,LOG,00000,"started streaming WAL from primary at 0/52000000 on timeline 1",,,,,,,,"WalReceiverMain, walreceiver.c:366",""</font></div><div><font size="2"   >2013-08-06 09:39:53.650 CST,,,13339,,520053e9.341b,2,,2013-08-06 09:39:53 CST,,0,FATAL,XX000,"could not receive data from WAL stream: ERROR: &nbsp;requested starting point 0/52000000 is ahead of the WAL flush position of this server 0/45AD6088</font></div><div><font size="2"   >",,,,,,,,"libpqrcv_receive, libpqwalreceiver.c:513",""</font></div><div><font size="2"   >2013-08-06 09:40:08.653 CST,,,13346,,520053f8.3422,1,,2013-08-06 09:40:08 CST,,0,LOG,00000,"started streaming WAL from primary at 0/52000000 on timeline 1",,,,,,,,"WalReceiverMain, walreceiver.c:366",""</font></div><div><font size="2"   >2013-08-06 09:40:08.654 CST,,,13346,,520053f8.3422,2,,2013-08-06 09:40:08 CST,,0,FATAL,XX000,"could not receive data from WAL stream: ERROR: &nbsp;requested starting point 0/52000000 is ahead of the WAL flush position of this server 0/45AD6088</font></div><div><font size="2"   >",,,,,,,,"libpqrcv_receive, libpqwalreceiver.c:513",""</font></div><p></p></pre></div><div>将备库的synchronous_transfer改为commit. fail-back失败.</div><div><pre class="prettyprint"   ><p></p><div><div><div><font size="2"   >pg94@db-172-16-3-39-&gt; pgbench -M prepared -f ./test.sql -r -n -h $PGDATA -p 2999 -U postgres -c 16 -j 4 -T 100 digoal</font></div><div><font size="2"   >Client 0 aborted in state 0: ERROR: &nbsp;duplicate key value violates unique constraint "test_pkey"</font></div><div><font size="2"   >DETAIL: &nbsp;Key (id)=(2242608) already exists.</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "insert into test values (v_id,md5(random()::text),clock_timestamp())"</font></div><div><font size="2"   >PL/pgSQL function func() line 10 at SQL statement</font></div><div><font size="2"   >Client 7 aborted in state 0: ERROR: &nbsp;duplicate key value violates unique constraint "test_pkey"</font></div><div><font size="2"   >DETAIL: &nbsp;Key (id)=(2615244) already exists.</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "insert into test values (v_id,md5(random()::text),clock_timestamp())"</font></div><div><font size="2"   >PL/pgSQL function func() line 10 at SQL statement</font></div></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >pg94@db-172-16-3-39-&gt; psql</font></div><div><font size="2"   >psql (9.4devel)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >digoal=# checkpoint;</font></div><div><font size="2"   >CHECKPOINT</font></div><div><font size="2"   >digoal=# checkpoint;</font></div><div><font size="2"   >CHECKPOINT</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >pg94@db-172-16-3-33-&gt; pg_ctl promote</font></div><div><font size="2"   >server promoting</font></div><div><font size="2"   >pg94@db-172-16-3-33-&gt; top -c -u pg94</font></div><div><font size="2"   >top - 09:52:29 up 74 days, 16:10, &nbsp;1 user, &nbsp;load average: 0.29, 0.13, 0.07</font></div><div><font size="2"   >Tasks: 209 total, &nbsp; 1 running, 208 sleeping, &nbsp; 0 stopped, &nbsp; 0 zombie</font></div><div><font size="2"   >Cpu(s): &nbsp;0.0%us, &nbsp;0.0%sy, &nbsp;0.0%ni, 99.9%id, &nbsp;0.0%wa, &nbsp;0.0%hi, &nbsp;0.0%si, &nbsp;0.0%st</font></div><div><font size="2"   >Mem: &nbsp;14369440k total, &nbsp;9195600k used, &nbsp;5173840k free, &nbsp; 404756k buffers</font></div><div><font size="2"   >Swap: &nbsp;8385920k total, &nbsp; &nbsp; &nbsp;184k used, &nbsp;8385736k free, &nbsp;8036496k cached</font></div><div><font size="2"   >&nbsp; PID USER &nbsp; &nbsp; &nbsp;PR &nbsp;NI &nbsp;VIRT &nbsp;RES &nbsp;SHR S %CPU %MEM &nbsp; &nbsp;TIME+ &nbsp;COMMAND &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp;5409 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 12760 1204 &nbsp;844 R &nbsp;0.7 &nbsp;0.0 &nbsp; 0:00.12 top -c -u pg94 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;4262 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 67272 2900 1328 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.26 -bash &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp;5382 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 1181m &nbsp;47m &nbsp;46m S &nbsp;0.0 &nbsp;0.3 &nbsp; 0:00.04 /home/pg94/pgsql9.4devel/bin/postgres &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp;5383 pg94 &nbsp; &nbsp; &nbsp;16 &nbsp; 0 &nbsp;108m 1048 &nbsp;516 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.00 postgres: logger process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;5386 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 1182m 296m 295m S &nbsp;0.0 &nbsp;2.1 &nbsp; 0:00.55 postgres: checkpointer process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;5387 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 1182m 6744 6172 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.00 postgres: writer process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;5388 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 &nbsp;110m 1100 &nbsp;524 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.00 postgres: stats collector process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp;5404 pg94 &nbsp; &nbsp; &nbsp;15 &nbsp; 0 1182m 1192 &nbsp;620 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.00 postgres: wal writer process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;5405 pg94 &nbsp; &nbsp; &nbsp;17 &nbsp; 0 1183m 2248 1164 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.00 postgres: autovacuum launcher process &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp;5406 pg94 &nbsp; &nbsp; &nbsp;18 &nbsp; 0 &nbsp;110m 1044 &nbsp;472 S &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00.00 postgres: archiver process &nbsp; last was 00000002.history&nbsp;</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >pg94@db-172-16-3-39-&gt; pg_ctl stop -m immediate</font></div><div><font size="2"   >waiting for server to shut down.... done</font></div><div><font size="2"   >server stopped</font></div></div><div><font size="2"   >pg94@db-172-16-3-39-&gt; cd $PGDATA</font></div><div><font size="2"   >pg94@db-172-16-3-39-&gt; mv recovery.done recovery.conf</font></div><div><font size="2"   >pg94@db-172-16-3-39-&gt; pg_ctl start</font></div><div><font size="2"   >failed-back 失败 :&nbsp;</font></div><div><div><font size="2"   >pg94@db-172-16-3-39-&gt; cat postgresql-2013-08-06_095340.csv</font></div><div><font size="2"   >2013-08-06 09:53:40.585 CST,,,13969,,52005724.3691,1,,2013-08-06 09:53:40 CST,,0,LOG,00000,"database system was interrupted; last known up at 2013-08-06 09:51:32 CST",,,,,,,,"StartupXLOG, xlog.c:6080",""</font></div><div><font size="2"   >2013-08-06 09:53:40.585 CST,,,13969,,52005724.3691,2,,2013-08-06 09:53:40 CST,,0,LOG,00000,"entering standby mode",,,,,,,,"StartupXLOG, xlog.c:6133",""</font></div><div><font size="2"   >2013-08-06 09:53:40.585 CST,,,13969,,52005724.3691,3,,2013-08-06 09:53:40 CST,,0,LOG,00000,"database system was not properly shut down; automatic recovery in progress",,,,,,,,"StartupXLOG, xlog.c:6443",""</font></div><div><font size="2"   >2013-08-06 09:53:40.587 CST,,,13969,,52005724.3691,4,,2013-08-06 09:53:40 CST,1/0,0,LOG,00000,"redo starts at 0/74BAF018",,,,,,,,"StartupXLOG, xlog.c:6687",""</font></div><div><font size="2"   >2013-08-06 09:53:45.958 CST,,,13969,,52005724.3691,5,,2013-08-06 09:53:40 CST,1/0,0,LOG,00000,"record with zero length at 0/89217048",,,,,,,,"ReadRecord, xlog.c:4420",""</font></div><div><font size="2"   >2013-08-06 09:53:45.959 CST,,,13969,,52005724.3691,6,,2013-08-06 09:53:40 CST,1/0,0,LOG,00000,"consistent recovery state reached at 0/89217048",,,,,,,,"CheckRecoveryConsistency, xlog.c:7348",""</font></div><div><font size="2"   >2013-08-06 09:53:45.960 CST,,,13967,,52005724.368f,1,,2013-08-06 09:53:40 CST,,0,LOG,00000,"database system is ready to accept read only connections",,,,,,,,"sigusr1_handler, postmaster.c:4737",""</font></div><div><font size="2"   >2013-08-06 09:53:45.965 CST,,,13976,,52005729.3698,1,,2013-08-06 09:53:45 CST,,0,LOG,00000,"fetching timeline history file for timeline 2 from primary server",,,,,,,,"WalRcvFetchTimeLineHistoryFiles, walreceiver.c:666",""</font></div><div><font size="2"   >2013-08-06 09:53:45.966 CST,,,13976,,52005729.3698,2,,2013-08-06 09:53:45 CST,,0,FATAL,XX000,"could not start WAL streaming: ERROR: &nbsp;requested starting point 0/89000000 on timeline 1 is not in this server's history</font></div><div><font size="2"   >DETAIL: &nbsp;This server's history forked from timeline 1 at 0/82603A30</font></div><div><font size="2"   >",,,,,,,,"libpqrcv_startstreaming, libpqwalreceiver.c:195",""</font></div></div></pre></div></div><div><br></div><div>[其他]</div><div>1. 加入data_flush后 , 需要特别注意等待事件, 如果standby正常的话, 影响不大, 如果standby 性能不行或者standby 挂了, 就如同sync replication一样会带来堵塞.</div><div>2. 如果配置了synchronous_transfer = data_flush|all, 在没有已经连上来的其他standby节点的情况下, 使用pg_basebackup创建standby会处于等待状态, 因为pg_basebackup需要在master节点执行checkpoint.</div><div>3. 使用异步流复制的情况下, 测试<span style="line-height: 22px;"   >synchronous_transfer</span><span style="line-height: 22px;"   >&nbsp;= data_flush, all都不能完成主节点的failback.</span></div><div><span style="line-height: 22px;"   >4. 使用同步流复制的情况下, 测试</span><span style="line-height: 22px;"   >synchronous_transfer</span><span style="line-height: 22px;"   >&nbsp;= data_flush, all可以完成正常的主节点的failback.</span></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 22px;" href="http://blog.163.com/digoal@126/blog/static/1638770402013758511857/"   >http://blog.163.com/digoal@126/blog/static/1638770402013758511857/</a></div><div>2.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://www.postgresql.org/message-id/flat/CAF8Q-Gy7xa60HwXc0MKajjkWFEbFDWTG=gGyu1KmT+s2xcQ-bw@mail.gmail.com#CAF8Q-Gy7xa60HwXc0MKajjkWFEbFDWTG=gGyu1KmT+s2xcQ-bw@mail.gmail.com"   >http://www.postgresql.org/message-id/flat/CAF8Q-Gy7xa60HwXc0MKajjkWFEbFDWTG=gGyu1KmT+s2xcQ-bw@mail.gmail.com#CAF8Q-Gy7xa60HwXc0MKajjkWFEbFDWTG=gGyu1KmT+s2xcQ-bw@mail.gmail.com</a></div><div><div style="line-height: 25px; color: rgb(51, 51, 51); font-family: Arial, Helvetica, simsun, u5b8bu4f53;"   >3.&nbsp;<a style="line-height: 22px; font-family: Arial, Helvetica, sans-serif;" target="_blank" rel="nofollow" href="http://www.postgresql.org/message-id/flat/CAF8Q-Gxg3PQTf71NVECe-6OzRaew5pWhk7yQtbJgWrFu513s+Q@mail.gmail.com#CAF8Q-Gxg3PQTf71NVECe-6OzRaew5pWhk7yQtbJgWrFu513s+Q@mail.gmail.com"   >http://www.postgresql.org/message-id/flat/CAF8Q-Gxg3PQTf71NVECe-6OzRaew5pWhk7yQtbJgWrFu513s+Q@mail.gmail.com#CAF8Q-Gxg3PQTf71NVECe-6OzRaew5pWhk7yQtbJgWrFu513s+Q@mail.gmail.com</a></div><div style="line-height: 25px; color: rgb(51, 51, 51); font-family: Arial, Helvetica, simsun, u5b8bu4f53;"   >4.&nbsp;<a style="line-height: 22px; font-family: Arial, Helvetica, sans-serif;" target="_blank" rel="nofollow" href="http://www.postgresql.org/message-id/519DF910.4020609@vmware.com"   >http://www.postgresql.org/message-id/519DF910.4020609@vmware.com</a></div><div style="line-height: 25px; color: rgb(51, 51, 51); font-family: Arial, Helvetica, simsun, u5b8bu4f53;"   >5.&nbsp;<a style="line-height: 22px; font-family: Arial, Helvetica, sans-serif;" target="_blank" rel="nofollow" href="https://github.com/vmware/pg_rewind"   >https://github.com/vmware/pg_rewind</a></div></div><div style="line-height: 25px; color: rgb(51, 51, 51); font-family: Arial, Helvetica, simsun, u5b8bu4f53;"   >6.&nbsp;<a style="font-family: Arial, Helvetica, sans-serif; line-height: 22px;" href="http://blog.163.com/digoal@126/blog/static/16387704020136197354054/"   >http://blog.163.com/digoal@126/blog/static/16387704020136197354054/</a></div><div>7. 第4版补丁synchronous_transfer参数介绍</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >we support following 2 cases.</font></div><div><font size="2"   >1. SYNC server and also make same failback safe standby server</font></div><div><font size="2"   >2. ASYNC server and also make same failback safe standby server</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >1. &nbsp;changed name of parameter</font></div><div><font size="2"   >&nbsp; give up 'failback_safe_standby_names' parameter from the first patch.</font></div><div><font size="2"   >&nbsp; and changed name of parameter from 'failback_safe_mode ' to</font></div><div><font size="2"   >'synchronous_transfer'.</font></div><div><font size="2"   >&nbsp; this parameter accepts 'all', 'data_flush' and 'commit'.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; -'commit'</font></div><div><font size="2"   >&nbsp; &nbsp; 'commit' means that master waits for corresponding WAL to flushed</font></div><div><font size="2"   >to disk of standby server on commits.</font></div><div><font size="2"   >&nbsp; &nbsp; but master doesn't waits for replicated data pages.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; -'data_flush'</font></div><div><font size="2"   >&nbsp; &nbsp; 'data_flush' means that master waits for replicated data page</font></div><div><font size="2"   >(e.g, CLOG, pg_control) before flush to disk of master server.</font></div><div><font size="2"   >&nbsp; &nbsp; but if user set to 'data_flush' to this parameter,</font></div><div><font size="2"   >'synchronous_commit' values is ignored even if user set</font></div><div><font size="2"   >'synchronous_commit'.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; -'all'</font></div><div><font size="2"   >&nbsp; &nbsp; 'all' means that master waits for replicated WAL and data page.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >2. put SyncRepWaitForLSN() function into XLogFlush() function</font></div><div><font size="2"   >&nbsp; we have put SyncRepWaitForLSN() function into XLogFlush() function,</font></div><div><font size="2"   >and change argument of XLogFlush().</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >they are setup case and need to set parameters.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >- SYNC server and also make same failback safe standgy server (case 1)</font></div><div><font size="2"   >&nbsp; synchronous_transfer = all</font></div><div><font size="2"   >&nbsp; synchronous_commit = remote_write/on</font></div><div><font size="2"   >&nbsp; synchronous_standby_names = &lt;ServerName&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >- ASYNC server and also make same failback safe standgy server (case 2)</font></div><div><font size="2"   >&nbsp; synchronous_transfer = data_flush</font></div><div><font size="2"   >&nbsp; (synchronous_commit values is ignored)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >- default SYNC replication</font></div><div><font size="2"   >&nbsp; synchronous_transfer = commit</font></div><div><font size="2"   >&nbsp; synchronous_commit = on</font></div><div><font size="2"   >&nbsp; synchronous_standby_names = &lt;ServerName&gt;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >- default ASYNC replication</font></div><div><font size="2"   >&nbsp; synchronous_transfer = commit</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >ToDo</font></div><div><font size="2"   >1. currently this patch supports synchronous transfer. so we can't set</font></div><div><font size="2"   >different synchronous transfer mode to each server.</font></div><div><font size="2"   >&nbsp; &nbsp; we need to improve the patch for support following cases.</font></div><div><font size="2"   >&nbsp; &nbsp;- SYNC standby and make separate ASYNC failback safe standby</font></div><div><font size="2"   >&nbsp; &nbsp;- ASYNC standby and make separate ASYNC failback safe standby</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >2. we have not measure performance yet. we need to measure perfomance.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >please give me your feedback.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Regards,</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >-------</font></div><div><font size="2"   >Sawada Masahiko</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>