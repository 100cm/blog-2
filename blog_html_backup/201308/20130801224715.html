<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.4 patch : WITHIN GROUP (sql standard ordered set aggregate functions)</h2>
	<h5 id="">2013-08-01 22:47:15&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020137124851944/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>WITHIN GROUP 可以认为是PostgreSQL 聚合函数的功能性扩展. &nbsp;Oracle 对此支持比较完善. PostgreSQL目前不支持此功能.</div><div>本文末尾对Oracle的用法做了详细的介绍和举例说明 :&nbsp;</div><div>对聚合或者自定义聚合函数不了解到朋友可以先参考以下文章 :&nbsp;</div><div><div style="line-height: 22px;"   >1.&nbsp;<a style="line-height: 22px;" href="http://blog.163.com/digoal@126/blog/static/16387704020134222140958/"   >http://blog.163.com/digoal@126/blog/static/16387704020134222140958/</a></div><div style="line-height: 22px;"   >2.&nbsp;<a style="line-height: 22px;" href="http://blog.163.com/digoal@126/blog/static/16387704020121118112533410/"   >http://blog.163.com/digoal@126/blog/static/16387704020121118112533410/</a></div><div style="line-height: 22px;"   >3.&nbsp;<a style="line-height: 22px;" href="http://blog.163.com/digoal@126/blog/static/163877040201211174617734/"   >http://blog.163.com/digoal@126/blog/static/163877040201211174617734/</a></div></div><div style="line-height: 22px;"   >本文将要提到的这个PostgreSQL within group功能补丁实现方法如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >This is our current work-in-progress patch for WITHIN GROUP.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >What mostly works:</font></div><div><font size="2"   >&nbsp; - percentile_cont(float8) within group (order by float8)</font></div><div><font size="2"   >&nbsp; - percentile_cont(float8) within group (order by interval)</font></div><div><font size="2"   >&nbsp; - percentile_disc(float8) within group (order by float8)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >What doesn't work:</font></div><div><font size="2"   >&nbsp; - supporting other types in percentile_disc (want polymorphism to</font></div><div><font size="2"   >&nbsp; &nbsp; work first)</font></div><div><font size="2"   >&nbsp; - no commands yet to add new ordered set functions (want to nail</font></div><div><font size="2"   >&nbsp; &nbsp; down the catalog representation first)</font></div><div><font size="2"   >&nbsp; - no hypothetical set functions yet (need to resolve the above two</font></div><div><font size="2"   >&nbsp; &nbsp; points first)</font></div><div><font size="2"   >&nbsp; - some rough edges</font></div><div><font size="2"   >&nbsp; - probably some bugs</font></div><div><font size="2"   >&nbsp; - docs</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Implementation details:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >For execution, we repurpose the existing aggregate-orderby mechanics.</font></div><div><font size="2"   >Given func(directargs) WITHIN GROUP (ORDER BY args), we process the</font></div><div><font size="2"   >(ORDER BY args) into a tuplesort in the same way currently done for</font></div><div><font size="2"   >agg(args ORDER BY args). Rather than using a transfn, we then call the</font></div><div><font size="2"   >finalfn as finalfn(directargs), providing an API by which the finalfn</font></div><div><font size="2"   >can access the tuplesort. (This is somewhat inspired by the window</font></div><div><font size="2"   >function API, but unfortunately has nothing in common with it in terms</font></div><div><font size="2"   >of requirements, so we couldn't just reuse it.)</font></div><div><font size="2"   >-- 上面的片段介绍有点问题, 应该是常规调用<span style="line-height: 19px;"   >func(directargs) WITHIN GROUP (ORDER BY args)</span></font></div><div><font size="2"   ><span style="line-height: 19px;"   >-- 最后再调用finalfn(directargs)</span></font></div><div><font size="2"   >func(p1,p2,...) WITHIN GROUP (ORDER BY q1,q2,...) is represented in the</font></div><div><font size="2"   >catalog with two pg_proc rows:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >func(p1,p2,...,q1,q2,...) &nbsp;(proisagg=true)</font></div><div><font size="2"   >func_final(p1,p2,...)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >with the usual pg_aggregate row linking them, though aggtransfn is set</font></div><div><font size="2"   >to InvalidOid (as is aggtranstype) and an additional flag indicates</font></div><div><font size="2"   >that this is an ordered set function.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >(This representation is inadequate for a number of reasons; it does not</font></div><div><font size="2"   >handle polymorphism well and would require special-case coding for</font></div><div><font size="2"   >hypothetical set functions, which we have not yet tackled. See our other</font></div><div><font size="2"   >post.)</font></div><p></p></pre></div><div style="line-height: 22px;"   >函数 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# select oid,* from pg_proc where proname='percentile_disc';</font></div><div><font size="2"   >-[ RECORD 1 ]---+----------------</font></div><div><font size="2"   >oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 3931</font></div><div><font size="2"   >proname &nbsp; &nbsp; &nbsp; &nbsp; | percentile_disc</font></div><div><font size="2"   >pronamespace &nbsp; &nbsp;| 11</font></div><div><font size="2"   >proowner &nbsp; &nbsp; &nbsp; &nbsp;| 10</font></div><div><font size="2"   >prolang &nbsp; &nbsp; &nbsp; &nbsp; | 12</font></div><div><font size="2"   >procost &nbsp; &nbsp; &nbsp; &nbsp; | 1</font></div><div><font size="2"   >prorows &nbsp; &nbsp; &nbsp; &nbsp; | 0</font></div><div><font size="2"   >provariadic &nbsp; &nbsp; | 0</font></div><div><font size="2"   >protransform &nbsp; &nbsp;| -</font></div><div><font size="2"   >proisagg &nbsp; &nbsp; &nbsp; &nbsp;| t</font></div><div><font size="2"   >proiswindow &nbsp; &nbsp; | f</font></div><div><font size="2"   >prosecdef &nbsp; &nbsp; &nbsp; | f</font></div><div><font size="2"   >proleakproof &nbsp; &nbsp;| f</font></div><div><font size="2"   >proisstrict &nbsp; &nbsp; | t</font></div><div><font size="2"   >proretset &nbsp; &nbsp; &nbsp; | f</font></div><div><font size="2"   >provolatile &nbsp; &nbsp; | i</font></div><div><font size="2"   >pronargs &nbsp; &nbsp; &nbsp; &nbsp;| 2</font></div><div><font size="2"   >pronargdefaults | 0</font></div><div><font size="2"   >prorettype &nbsp; &nbsp; &nbsp;| 701</font></div><div><font size="2"   >proargtypes &nbsp; &nbsp; | 701 701</font></div><div><font size="2"   >proallargtypes &nbsp;|&nbsp;</font></div><div><font size="2"   >proargmodes &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >proargnames &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >proargdefaults &nbsp;|&nbsp;</font></div><div><font size="2"   >prosrc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| aggregate_dummy</font></div><div><font size="2"   >probin &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >proconfig &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >proacl &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select * from pg_aggregate where aggfnoid=3931;</font></div><div><font size="2"   >-[ RECORD 1 ]---+----------------------</font></div><div><font size="2"   >aggfnoid &nbsp; &nbsp; &nbsp; &nbsp;| percentile_disc</font></div><div><font size="2"   >aggtransfn &nbsp; &nbsp; &nbsp;| -</font></div><div><font size="2"   >aggfinalfn &nbsp; &nbsp; &nbsp;| percentile_disc_final</font></div><div><font size="2"   >aggsortop &nbsp; &nbsp; &nbsp; | 0</font></div><div><font size="2"   >aggtranstype &nbsp; &nbsp;| 0</font></div><div><font size="2"   >aggisordsetfunc | t</font></div><div><font size="2"   >agginitval &nbsp; &nbsp; &nbsp;|&nbsp;</font></div></div><div><div><font size="2"   >digoal=# \df PERCENTILE_cont</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of functions</font></div><div><font size="2"   >&nbsp; &nbsp;Schema &nbsp; | &nbsp; &nbsp; &nbsp;Name &nbsp; &nbsp; &nbsp; | Result data type | &nbsp; &nbsp; &nbsp; &nbsp;Argument data types &nbsp; &nbsp; &nbsp; &nbsp; | Type&nbsp;</font></div><div><font size="2"   >------------+-----------------+------------------+------------------------------------+------</font></div><div><font size="2"   >&nbsp;pg_catalog | percentile_cont | double precision | double precision, double precision | agg</font></div></div><p></p></pre></div><div>聚合函数<span style="line-height: 22px;"   >PERCENTILE_cont参数为2个双精, 分别表示</span>func(directargs) WITHIN GROUP (ORDER BY args)里的directargs和args.</div><div><span style="line-height: 22px;"   >finalfn为</span><span style="line-height: 22px;"   >percentile_disc_final</span><span style="line-height: 22px;"   >一个双精.表示directargs.</span></div><div><pre class="prettyprint"   ><div><font size="2"   >digoal=# \df percentile_disc_final</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of functions</font></div><div><font size="2"   >&nbsp; &nbsp;Schema &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Result data type | Argument data types | &nbsp;Type &nbsp;</font></div><div><font size="2"   >------------+-----------------------+------------------+---------------------+--------</font></div><div><font size="2"   >&nbsp;pg_catalog | percentile_disc_final | double precision | double precision &nbsp; &nbsp;| normal</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >补丁测试 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-33 pg94]# cd postgresql-10a509d</font></div><div><font size="2"   >[root@db-172-16-3-33 postgresql-10a509d]# patch -p1 &lt; ../patch19713context.patch&nbsp;</font></div><div><font size="2"   >patching file src/backend/executor/execQual.c</font></div><div><font size="2"   >patching file src/backend/executor/functions.c</font></div><div><font size="2"   >patching file src/backend/executor/nodeAgg.c</font></div><div><font size="2"   >patching file src/backend/nodes/copyfuncs.c</font></div><div><font size="2"   >patching file src/backend/nodes/equalfuncs.c</font></div><div><font size="2"   >patching file src/backend/nodes/makefuncs.c</font></div><div><font size="2"   >patching file src/backend/nodes/nodeFuncs.c</font></div><div><font size="2"   >Hunk #1 succeeded at 1631 (offset 59 lines).</font></div><div><font size="2"   >Hunk #2 succeeded at 2102 (offset 1 line).</font></div><div><font size="2"   >patching file src/backend/nodes/outfuncs.c</font></div><div><font size="2"   >patching file src/backend/nodes/readfuncs.c</font></div><div><font size="2"   >patching file src/backend/optimizer/util/clauses.c</font></div><div><font size="2"   >Hunk #4 succeeded at 3827 (offset -56 lines).</font></div><div><font size="2"   >patching file src/backend/parser/gram.y</font></div><div><font size="2"   >patching file src/backend/parser/parse_agg.c</font></div><div><font size="2"   >patching file src/backend/parser/parse_expr.c</font></div><div><font size="2"   >patching file src/backend/parser/parse_func.c</font></div><div><font size="2"   >patching file src/backend/parser/parse_oper.c</font></div><div><font size="2"   >patching file src/backend/utils/adt/Makefile</font></div><div><font size="2"   >patching file src/backend/utils/adt/inversedistribution.c</font></div><div><font size="2"   >patching file src/backend/utils/adt/ruleutils.c</font></div><div><font size="2"   >Hunk #2 succeeded at 7405 (offset 19 lines).</font></div><div><font size="2"   >Hunk #4 succeeded at 7562 (offset 19 lines).</font></div><div><font size="2"   >patching file src/backend/utils/sort/tuplesort.c</font></div><div><font size="2"   >patching file src/include/catalog/pg_aggregate.h</font></div><div><font size="2"   >patching file src/include/catalog/pg_proc.h</font></div><div><font size="2"   >Hunk #1 succeeded at 4729 (offset 2 lines).</font></div><div><font size="2"   >patching file src/include/executor/nodeAgg.h</font></div><div><font size="2"   >patching file src/include/fmgr.h</font></div><div><font size="2"   >patching file src/include/nodes/execnodes.h</font></div><div><font size="2"   >patching file src/include/nodes/nodes.h</font></div><div><font size="2"   >patching file src/include/nodes/parsenodes.h</font></div><div><font size="2"   >patching file src/include/nodes/primnodes.h</font></div><div><font size="2"   >patching file src/include/parser/kwlist.h</font></div><div><font size="2"   >patching file src/include/parser/parse_agg.h</font></div><div><font size="2"   >patching file src/include/parser/parse_func.h</font></div><div><font size="2"   >patching file src/test/regress/expected/aggregates.out</font></div><div><font size="2"   >patching file src/test/regress/expected/opr_sanity.out</font></div><div><font size="2"   >patching file src/test/regress/sql/aggregates.sql</font></div><div><font size="2"   >patching file src/test/regress/sql/opr_sanity.sql</font></div><p></p></pre></div><div>重新编译, 重启数据库 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >gmake</font></div><div><font size="2"   >sudo gmake install</font></div><div><font size="2"   >pg_ctl restart -m fast</font></div><p></p></pre></div><div><br></div><div>测试 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >pg94@db-172-16-3-33-&gt; psql</font></div><div><font size="2"   >psql (9.4devel)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# CREATE TABLE aggtest ( a &nbsp; &nbsp; int2,&nbsp;<span style="line-height: 22px;"   >b &nbsp; &nbsp; &nbsp; float4</span><span style="line-height: 22px;"   >);</span></font></div><div><font size="2"   >digoal=# copy aggtest from '/home/pg94/postgresql-10a509d/src/test/regress/data/agg.data';</font></div><div><font size="2"   >COPY 4</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# CREATE TABLE tenk1 ( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; unique1 &nbsp; &nbsp; &nbsp; &nbsp; int4,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; unique2 &nbsp; &nbsp; &nbsp; &nbsp; int4,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; two &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int4,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; four &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int4,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ten &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int4,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; twenty &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int4,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; hundred &nbsp; &nbsp; &nbsp; &nbsp; int4,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; thousand &nbsp; &nbsp; &nbsp; &nbsp;int4,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; twothousand &nbsp; &nbsp; int4,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; fivethous &nbsp; &nbsp; &nbsp; int4,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; tenthous &nbsp; &nbsp; &nbsp; &nbsp;int4,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; odd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int4,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; even &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int4,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; stringu1 &nbsp; &nbsp; &nbsp; &nbsp;name,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; stringu2 &nbsp; &nbsp; &nbsp; &nbsp;name,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; string4 &nbsp; &nbsp; &nbsp; &nbsp; name</font></div><div><font size="2"   >);</font></div></div><div><div><font size="2"   >digoal=# copy tenk1 from '/home/pg94/postgresql-10a509d/src/test/regress/data/tenk.data';</font></div><div><font size="2"   >COPY 10000</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >select p, percentile_cont(p order by p) within group (order by x::float8)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; from generate_series(1,5) x, (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; group by p order by x;</font></div><div><font size="2"   >ERROR: &nbsp;Cannot have multiple ORDER BY clauses with WITHIN GROUP</font></div><div><font size="2"   >LINE 1: select p, percentile_cont(p order by p) within group (order ...</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >select p, sum() within group (order by x::float8)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; from generate_series(1,5) x,&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p) group by p order by p;</font></div><div><font size="2"   >ERROR: &nbsp;sum(double precision) is not an ordered set function</font></div><div><font size="2"   >select p, percentile_cont(p,p) from generate_series(1,5) x,&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p) group by p order by p;</font></div><div><font size="2"   >ERROR: &nbsp;Ordered set function specified, but WITHIN GROUP not present</font></div><div><font size="2"   >LINE 1: select p, percentile_cont(p,p) from generate_series(1,5) x,&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >select percentile_cont(0.5) within group (order by b) from aggtest;</font></div><div><font size="2"   >&nbsp;percentile_cont &nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >&nbsp;53.4485001564026</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >select percentile_cont(0.5) within group (order by b),sum(b) from aggtest;</font></div><div><font size="2"   >&nbsp;percentile_cont &nbsp;| &nbsp; sum &nbsp;&nbsp;</font></div><div><font size="2"   >------------------+---------</font></div><div><font size="2"   >&nbsp;53.4485001564026 | 431.773</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >select percentile_cont(0.5) within group (order by thousand) from tenk1;</font></div><div><font size="2"   >&nbsp;percentile_cont&nbsp;</font></div><div><font size="2"   >-----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;499.5</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >select percentile_disc(0.5) within group (order by thousand) from tenk1;</font></div><div><font size="2"   >&nbsp;percentile_disc&nbsp;</font></div><div><font size="2"   >-----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;499</font></div></div><p></p></pre></div><div><br></div><div>下面在对比Oracle和PostgreSQL中的<span style="line-height: 22px;"   >percentile_disc和</span><span style="line-height: 22px;"   >percentile_cont; 结果一致.</span></div><div>Oracle测试在本文参考部分.</div><div>PostgreSQL测试如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create table test (id numeric);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=# insert into test values &nbsp;(1.1),(2.2),(3.3),(4.4),(5.5),(6.6),(null);</font></div><div><font size="2"   >INSERT 0 7</font></div><div><font size="2"   >digoal=# select * from test;</font></div><div><font size="2"   >&nbsp;id &nbsp;</font></div><div><font size="2"   >-----</font></div><div><font size="2"   >&nbsp;1.1</font></div><div><font size="2"   >&nbsp;2.2</font></div><div><font size="2"   >&nbsp;3.3</font></div><div><font size="2"   >&nbsp;4.4</font></div><div><font size="2"   >&nbsp;5.5</font></div><div><font size="2"   >&nbsp;6.6</font></div><div><font size="2"   >(7 rows)</font></div></div><div><div><font size="2"   >digoal=# select PERCENTILE_cont(0.5) within group (order by id) from test;</font></div><div><font size="2"   >&nbsp;percentile_cont&nbsp;</font></div><div><font size="2"   >-----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.85</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >digoal=# insert into test select 6.6 from generate_series(1,8);</font></div><div><font size="2"   >INSERT 0 8</font></div></div><div><div><font size="2"   >digoal=# select PERCENTILE_disc(.285714286) within group (order by id) from test;</font></div><div><font size="2"   >&nbsp;percentile_disc&nbsp;</font></div><div><font size="2"   >-----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5.5</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select PERCENTILE_disc(.285714285) within group (order by id) from test;</font></div><div><font size="2"   >&nbsp;percentile_disc&nbsp;</font></div><div><font size="2"   >-----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4.4</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div><br></div>[参考]<div>1.&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020134222140958/"   >http://blog.163.com/digoal@126/blog/static/16387704020134222140958/</a></div><div>2.&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020121118112533410/"   >http://blog.163.com/digoal@126/blog/static/16387704020121118112533410/</a></div><div>3.&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201211174617734/"   >http://blog.163.com/digoal@126/blog/static/163877040201211174617734/</a><br><wbr><div>4.&nbsp;<a style="line-height: 22px;" rel="nofollow" href="http://www.postgresql.org/message-id/flat/CAOeZVieLrQZGb23vtS26YyrU11NcGsEN59eUaK43nHXiKpF-CA@mail.gmail.com#CAOeZVieLrQZGb23vtS26YyrU11NcGsEN59eUaK43nHXiKpF-CA@mail.gmail.com"   >http://www.postgresql.org/message-id/flat/CAOeZVieLrQZGb23vtS26YyrU11NcGsEN59eUaK43nHXiKpF-CA@mail.gmail.com#CAOeZVieLrQZGb23vtS26YyrU11NcGsEN59eUaK43nHXiKpF-CA@mail.gmail.com</a></div><div>5.&nbsp;<span style="line-height: 22px;"   >Oracle? Database SQL Language Reference&nbsp;</span><span style="line-height: 22px;"   >11g Release 2 (11.2)</span></div><div><a rel="nofollow" href="http://docs.oracle.com/cd/E11882_01/server.112/e26088/functions003.htm#i89203"   >http://docs.oracle.com/cd/E11882_01/server.112/e26088/functions003.htm#i89203</a></div><div>Aggregate Functions :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CUME_DIST,&nbsp;DENSE_RANK,&nbsp;LISTAGG,&nbsp;PERCENT_RANK,&nbsp;</font></div><div><font size="2"   >PERCENTILE_CONT,&nbsp;PERCENTILE_DISC,&nbsp;RANK ...</font></div><p></p></pre></div><div>6. Oracle&nbsp;MEDIAN function, 用来获取一组数据中排序后得到的中间值. 举例如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >SQL&gt; create table test(id numeric(8,3));</font></div></div><div><div><font size="2"   >SQL&gt; insert into test values (1.1);</font></div><div><font size="2"   >SQL&gt; insert into test values (2.2);</font></div><div><font size="2"   >SQL&gt; insert into test values (3.3);</font></div><div><font size="2"   >SQL&gt; insert into test values (4.4);</font></div><div><font size="2"   >SQL&gt; insert into test values (5.5);</font></div><div><font size="2"   >SQL&gt; insert into test values (6.6);</font></div><div><div><font size="2"   >SQL&gt; &nbsp;insert into test values (null);</font></div></div><div><div><font size="2"   >SQL&gt; select median(id) from test;</font></div><div><font size="2"   >MEDIAN(ID)</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;3.85</font></div></div></div><p></p></pre></div><div>这个结果怎么得到的?</div><div>N=6(忽略id is null的行), 因为未使用partition by, 也为使用group by, 所有记录为1个分组. 所以分组共6行.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >RN=(1+0.5*(N-1))=3.5</font></div><div><font size="2"   >FRN=floor(3.5)=3</font></div><div><font size="2"   >CRN=ceiling(3.5)=4</font></div><div><div><font size="2"   >if (CRN = FRN = RN) then</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; (value of expression from row at RN)</font></div><div><font size="2"   >&nbsp; &nbsp;else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; (CRN - RN) * (value of expression for row at FRN) +</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; (RN - FRN) * (value of expression for row at CRN)</font></div></div><p></p></pre></div><div><span style="line-height: 22px;"   >value of expression for row at FRN, CRN. (</span>按照id排序, 然后取对应行号上的值.)</div><div>最终结果median(id)等于</div><pre class="prettyprint"   ><p></p><div><font size="2"   >(4-3.5)*3.3+(3.5-3)*4.4=3.85</font></div><div></div><p></p></pre><div><span style="line-height: 22px;"   >等同于如下</span><span style="line-height: 22px;"   >PERCENTILE_CONT</span><span style="line-height: 22px;"   >用法 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; select PERCENTILE_CONT(0.5) within group (order by id) from test;</font></div><div><font size="2"   >PERCENTILE_CONT(0.5)WITHINGROUP(ORDERBYID)</font></div><div><font size="2"   >------------------------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.85</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >PERCENTILE_DISC</span><span style="line-height: 22px;"   >用法 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; select row_number() over(order by id),test.* from test order by id;</font></div><div><font size="2"   >ROW_NUMBER()OVER(ORDERBYID) &nbsp; &nbsp; &nbsp; &nbsp; ID</font></div><div><font size="2"   >--------------------------- ----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp;1.1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp;2.2</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 &nbsp; &nbsp; &nbsp; &nbsp;3.3</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; &nbsp; &nbsp;4.4</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5 &nbsp; &nbsp; &nbsp; &nbsp;5.5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 &nbsp; &nbsp; &nbsp; &nbsp;6.6</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7 &nbsp; &nbsp; &nbsp; &nbsp;6.6</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 &nbsp; &nbsp; &nbsp; &nbsp;6.6</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 9 &nbsp; &nbsp; &nbsp; &nbsp;6.6</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 &nbsp; &nbsp; &nbsp; &nbsp;6.6</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11 &nbsp; &nbsp; &nbsp; &nbsp;6.6</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12 &nbsp; &nbsp; &nbsp; &nbsp;6.6</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;13 &nbsp; &nbsp; &nbsp; &nbsp;6.6</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 &nbsp; &nbsp; &nbsp; &nbsp;6.6</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;15 NULL</font></div><div><font size="2"   >15 rows selected.</font></div><p></p></pre></div><div><div>id有效的行数为14, 第四行的连续性位置值为<span style="line-height: 22px;"   >.285714286</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; select 4/14.0 from dual;</font></div><div><font size="2"   >&nbsp; &nbsp; 4/14.0</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >.285714286</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >PERCENTILE_disc的参数为numeric类型, 结果为该分组内按id排序的大于或等于该连续性位置的id值.</span></div><div><span style="line-height: 22px;"   >因此取0.286则为4.4的下一个值.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; select PERCENTILE_disc(0.286) within group (order by id) from test;</font></div><div><font size="2"   >PERCENTILE_DISC(0.286)WITHINGROUP(ORDERBYID)</font></div><div><font size="2"   >--------------------------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5.5</font></div><p></p></pre></div><div>取<span style="line-height: 22px;"   >0.285则为第四行的id值.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; select PERCENTILE_disc(0.285) within group (order by id) from test;</font></div><div><font size="2"   >PERCENTILE_DISC(0.285)WITHINGROUP(ORDERBYID)</font></div><div><font size="2"   >--------------------------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4.4</font></div><p></p></pre></div></div><div>下面的更加精确的说明这个结果 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; select PERCENTILE_disc(.285714286) within group (order by id) from test;</font></div><div><font size="2"   >PERCENTILE_DISC(.285714286)WITHINGROUP(ORDERBYID)</font></div><div><font size="2"   >-------------------------------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.5</font></div><p></p></pre></div><div><pre class="prettyprint"   ><div><font size="2"   >SQL&gt; select PERCENTILE_disc(.285714285) within group (order by id) from test;</font></div><div><font size="2"   >PERCENTILE_DISC(.285714285)WITHINGROUP(ORDERBYID)</font></div><div><font size="2"   >-------------------------------------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4.4</font></div><p></p></pre></div></div><div>PERCENTILE_DISC函数解释 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >The first expr must evaluate to a numeric value between 0 and 1, because it is a percentile value. This expression must be constant within each aggregate group. The ORDER BY clause takes a single expression that can be of any type that can be sorted.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >For a given percentile value P, PERCENTILE_DISC sorts the values of the expression in the ORDER BY clause and returns the value with the smallest CUME_DIST value (with respect to the same sort specification) that is greater than or equal to P.</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >PERCENTILE_CONT函数解释 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >The result of PERCENTILE_CONT is computed by linear interpolation between values after ordering them. Using the percentile value (P) and the number of rows (N) in the aggregation group, you can compute the row number you are interested in after ordering the rows with respect to the sort specification. This row number (RN) is computed according to the formula RN = (1+(P*(N-1)). The final result of the aggregate function is computed by linear interpolation between the values from rows at row numbers CRN = CEILING(RN) and FRN = FLOOR(RN).</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The final result will be:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; If (CRN = FRN = RN) then the result is</font></div><div><font size="2"   >&nbsp; &nbsp; (value of expression from row at RN)</font></div><div><font size="2"   >&nbsp; Otherwise the result is</font></div><div><font size="2"   >&nbsp; &nbsp; (CRN - RN) * (value of expression for row at FRN) +</font></div><div><font size="2"   >&nbsp; &nbsp; (RN - FRN) * (value of expression for row at CRN)</font></div><p></p></pre></div><div>MEDIAN函数详解 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >MEDIAN is an inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns the middle value or an interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you specify only expr, then the function returns the same data type as the numeric data type of the argument. If you specify the OVER clause, then Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</font></div></div><div><div><font size="2"   >The result of MEDIAN is computed by first ordering the rows. Using N as the number of rows in the group, Oracle calculates the row number (RN) of interest with the formula RN = (1 + (0.5*(N-1)). The final result of the aggregate function is computed by linear interpolation between the values from rows at row numbers CRN = CEILING(RN) and FRN = FLOOR(RN).</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The final result will be:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >if (CRN = FRN = RN) then</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; (value of expression from row at RN)</font></div><div><font size="2"   >&nbsp; &nbsp;else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; (CRN - RN) * (value of expression for row at FRN) +</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; (RN - FRN) * (value of expression for row at CRN)</font></div></div><p></p></pre></div><div><br></div><div>7. 摘录oracle一个rank的within group 用法.</div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >select rank(1500) within group (order by salary desc) "rank of 1500" from employees;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >实际得到的结果就是：</font></div><div><font size="2"   >如果存在一条记录，这条记录的salary字段值为1500。</font></div><div><font size="2"   >那么将该条记录插入employees表中后，按照salary字段降序排列后，该条记录的序号为多少？</font></div><div><font size="2"   >比如原表employees内容如下</font></div><div><font size="2"   >SQL&gt; select * from employees;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >EMP_ID &nbsp; &nbsp; EMP_NAME &nbsp; &nbsp; &nbsp; &nbsp; SALARY</font></div><div><font size="2"   >---------- -------------------- ----------</font></div><div><font size="2"   >10001 &nbsp; &nbsp; &nbsp;ZhangSan &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;500</font></div><div><font size="2"   >10002 &nbsp; &nbsp; &nbsp;LiSi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1000</font></div><div><font size="2"   >10003 &nbsp; &nbsp; &nbsp;WangWu &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1500</font></div><div><font size="2"   >10004 &nbsp; &nbsp; &nbsp;MaLiu &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2000</font></div><div><font size="2"   >10005 &nbsp; &nbsp; &nbsp;NiuQi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2500</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >则如果一个员工的薪水为1500，那么该员工在员工表中的薪水排名应与WangWu相同，并列排名第三。</font></div><div><font size="2"   >通过聚合函数RANK() WITHIN GROUP验证一下：</font></div><div><font size="2"   >SQL&gt; select rank(1500) within group (order by salary) as "rank number" from employees;</font></div><div><font size="2"   >rank number</font></div><div><font size="2"   >-----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >若原表内容如下</font></div><div><font size="2"   >SQL&gt; select * from employees;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >EMP_ID &nbsp; &nbsp; EMP_NAME &nbsp; &nbsp; &nbsp; &nbsp; SALARY</font></div><div><font size="2"   >---------- -------------------- --------------</font></div><div><font size="2"   >10001 &nbsp; &nbsp; &nbsp;ZhangSan &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 500</font></div><div><font size="2"   >10004 &nbsp; &nbsp; &nbsp;MaLiu &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2000</font></div><div><font size="2"   >10005 &nbsp; &nbsp; &nbsp;NiuQi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2500</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >则排名应为第2，验证如下</font></div><div><font size="2"   >SQL&gt; select rank(1500) within group (order by salary) as "rank number" from employees;</font></div><div><font size="2"   >rank number</font></div><div><font size="2"   >-----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2</font></div><p></p></pre></div><div><div style="line-height: 22px;"   >Oracle RANK聚合用法语法 :&nbsp;</div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >RANK(expr [, expr ]...) WITHIN GROUP</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp;(ORDER BY</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; expr [ DESC | ASC ]</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[ NULLS { FIRST | LAST } ]</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; [, expr [ DESC | ASC ]</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ NULLS { FIRST | LAST } ]</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; ]...</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp;)</font></div><p></p></pre></div></div><div style="line-height: 22px;"   >Oracle RANK分析函数用法语法 :&nbsp;</div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><font size="2"   >RANK( )</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp;OVER ([ query_partition_clause ] order_by_clause)</font></div></div><div style="line-height: 22px;"   ><font size="2"   >Oracle&nbsp;<span style="line-height: 22px;"   >PERCENTILE_CONT 用法 :&nbsp;</span></font></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><font size="2"   >PERCENTILE_CONT(expr) WITHIN GROUP</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp;(ORDER BY expr [ DESC | ASC ])</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp;[ OVER (query_partition_clause) ]</font></div></div><p></p></pre></div></div></div></div>
	</div>
</div>
</body>
</html>