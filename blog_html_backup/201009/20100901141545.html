<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">[转]Understanding Virtual Memory</h2>
	<h5 id="">2010-09-01 14:15:45&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020108121545916/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><span style="WIDOWS: 2; TEXT-TRANSFORM: none; TEXT-INDENT: 0px; BORDER-COLLAPSE: separate; FONT: medium Simsun; WHITE-SPACE: normal; ORPHANS: 2; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;"  ><span style="TEXT-ALIGN: left; FONT-FAMILY: 'Lucida Grande', 'Luxi Sans', 'Trebuchet MS', 'Bitstream Vera Sans', helvetica, verdana, arial, sans-serif; COLOR: rgb(51,51,51); FONT-SIZE: small;"  >  <h4 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 2em; FONT-SIZE: x-small; FONT-WEIGHT: bold;"  >by Norm Murray and Neil Horman</h4>  <ul style="PADDING-BOTTOM: 1.6em; MARGIN-TOP: 1.5em; PADDING-LEFT: 1.5em; MARGIN-LEFT: 12px;"  id="articleMenu"  >  <li style="LIST-STYLE-POSITION: outside; MARGIN: 5px 0px;"  ><span><a style="COLOR: rgb(0,102,204); TEXT-DECORATION: none;" href="http://blog.163.com/digoal@126/blog/getBlog.do#intro"  >Introduction</a></span></li>  <li style="LIST-STYLE-POSITION: outside; MARGIN: 5px 0px;"  ><span><a style="COLOR: rgb(0,102,204); TEXT-DECORATION: none;" href="http://blog.163.com/digoal@126/blog/getBlog.do#definitions"  >Definitions</a></span></li>  <li style="LIST-STYLE-POSITION: outside; MARGIN: 5px 0px;"  ><span><a style="COLOR: rgb(102,153,204); TEXT-DECORATION: none;" href="http://blog.163.com/digoal@126/blog/getBlog.do#life-page"  >The Life of a Page</a></span></li>  <li style="LIST-STYLE-POSITION: outside; MARGIN: 5px 0px;"  ><span><a style="COLOR: rgb(0,102,204); TEXT-DECORATION: none;" href="http://blog.163.com/digoal@126/blog/getBlog.do#tuning-vm"  >Tuning the VM</a></span></li>  <li style="LIST-STYLE-POSITION: outside; MARGIN: 5px 0px;"  ><span><a style="COLOR: rgb(0,102,204); TEXT-DECORATION: none;" href="http://blog.163.com/digoal@126/blog/getBlog.do#example-scenarios"  >Example Scenarios</a></span></li>  <li style="LIST-STYLE-POSITION: outside; MARGIN: 5px 0px;"  ><span><a style="COLOR: rgb(0,102,204); TEXT-DECORATION: none;" href="http://blog.163.com/digoal@126/blog/getBlog.do#further-reading"  >Further Reading</a></span></li>  <li style="LIST-STYLE-POSITION: outside; MARGIN: 5px 0px;"  ><span><a style="COLOR: rgb(0,102,204); TEXT-DECORATION: none;" href="http://blog.163.com/digoal@126/blog/getBlog.do#author"  >About the Author</a></span></li></ul>  <h2 style="PADDING-BOTTOM: 0px; MARGIN: 0.5em 0px 0px; COLOR: rgb(0,0,0); FONT-SIZE: medium; FONT-WEIGHT: bold;"  id="intro"  >Introduction</h2>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >One of the most important aspects of an operating system is the Virtual Memory Management system. Virtual Memory (VM) allows an operating system to perform many of its advanced functions, such as process isolation, file caching, and swapping. As such, it is imperative that an administrator understand the functions and tunable parameters of an operating system's Virtual Memory Manager so that optimal performance for a given workload may be achieved. After reading this article, the reader should have a rudimentary understanding of the data the Red Hat Enterprise Linux (RHEL3) VM controls and the algorithms it uses. Further, the reader should have a fairly good understanding of general Linux VM tuning techniques. It is important to note that Linux as an operating system has a proud legacy of overhaul. Items which no longer serve useful purposes or which have better implementations as technology advances are phased out. This implies that the tuning parameters described in this article may be out of date if you are using a newer or older kernel. Fear not however! With a well grounded understanding of the general mechanics of a VM, it is fairly easy to convert knowledge of VM tuning to another VM. The same general principles apply, and documentation for a given kernel (including its specific tunable parameters) can be found in the corresponding kernel source tree under the file<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >Documentation/sysctl/vm.txt</font></code>.</p>  <h2 style="PADDING-BOTTOM: 0px; MARGIN: 0.5em 0px 0px; COLOR: rgb(0,0,0); FONT-SIZE: medium; FONT-WEIGHT: bold;"  id="definitions"  >Definitions</h2>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >To properly understand how a Virtual Memory Manager does its job, it helps to understand what components comprise a VM. While the low level view of a VM are overwhelming for most, a high level view is necessary to understand how a VM works and how it can be optimized for workloads.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="what-comprises"  >What Comprises a VM</h3><a id="fig-vm-toplevel" name="fig-vm-toplevel" rel="nofollow"  ></a>  <div><img title="[转]Understanding Virtual Memory - 德哥@Digoal - The Heart,The World."  style="BORDER-RIGHT-WIDTH: 0px; BORDER-TOP-WIDTH: 0px; BORDER-BOTTOM-WIDTH: 0px; BORDER-LEFT-WIDTH: 0px;"  alt="High Level Overview of VM Subsystem"  src="http://blog.163.com/digoal@126/blog/figs/vm-toplevel.png"  ></div>  <div style="BACKGROUND-IMAGE: none; FONT-STYLE: normal; BACKGROUND-POSITION: 100% 0%; MARGIN-BOTTOM: 1.6em; COLOR: rgb(102,102,102); FONT-SIZE: x-small; FONT-WEIGHT: bold; background-origin: initial; background-clip: initial;"  >Figure 1. High Level Overview of VM Subsystem</div>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The inner workings of the Linux virtual memory subsystem are quite complex, but it can be defined at a high level with the following components:</p>  <h4 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; FONT-SIZE: x-small;"  id="mmu"  >MMU</h4>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The Memory Management Unit (MMU) is the hardware base that makes a VM system possible. The MMU allows software to reference physical memory by aliased addresses, quite often more than one. It accomplishes this through the use of pages and page tables. The MMU uses a section of memory to translate virtual addresses into physical addresses via a series of table lookups.</p>  <h4 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; FONT-SIZE: x-small;"  id="zoned-buddy-allocator"  >Zoned Buddy Allocator</h4>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The Zoned Buddy Allocator is responsible for the management of page allocations to the entire system. This code manages lists of physically contiguous pages and maps them into the MMU page tables, so as to provide other kernel subsystems with valid physical address ranges when the kernel requests them (Physical to Virtual Address mapping is handled by a higher layer of the VM). The name Buddy Allocator is derived from the algorithm this subsystem uses to maintain it free page lists. All physical pages in RAM are cataloged by the Buddy Allocator and grouped into lists. Each list represents clusters of 2n pages, where n is incremented in each list. If no entries exist on the requested list, an entry from the next list up is broken into two separate clusters and is returned to the caller while the other is added to the next list down. When an allocation is returned to the buddy allocator, the reverse process happens. Note that the Buddy Allocator also manages memory zones, which define pools of memory which have different purposes. Currently there are three memory pools which the Buddy Allocator manages accesses for:</p>  <ul style="PADDING-BOTTOM: 1.6em; PADDING-LEFT: 12px; MARGIN-LEFT: 12px;"  >  <li style="MARGIN: 5px 0px;"  >  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >DMA ― This zone consists of the first 16 MB of RAM, from which legacy devices allocate to perform direct memory operations.</p></li>  <li style="MARGIN: 5px 0px;"  >  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >NORMAL ― This zone encompasses memory addresses from 16 MB to 1 GB and is used by the kernel for internal data structures as well as other system and user space allocations.</p></li>  <li style="MARGIN: 5px 0px;"  >  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >HIGHMEM ― This zone includes all memory above 1 GB and is used exclusively for system allocations (file system buffers, user space allocations, etc).</p></li></ul>  <h4 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; FONT-SIZE: x-small;"  id="slab-allocator"  >Slab Allocator</h4>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The Slab Allocator provides a more usable front end to the Buddy Allocator for those sections of the kernel which require memory in sizes that are more flexible than the standard 4 KB page. The Slab Allocator allows other kernel components to create caches of memory objects of a given size. The Slab Allocator is responsible for placing as many of the cache's objects on a page as possible and monitoring which objects are free and which are allocated. When allocations are requested and no more are available, the Slab Allocator requests more pages from the Buddy Allocator to satisfy the request. This allows kernel components to use memory in a much simpler way. This way components which make use of many small portions of memory are not required to individually implement memory management code so that too many pages are not wasted. The Slab Allocator may only allocate from the DMA and NORMAL zones.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="kernel-threads"  >Kernel Threads</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The last component in the VM subsystem are the kernel threads:<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >kscand</font></code>,<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >kswapd</font></code>,<code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >kupdated</font></code>, and<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >bdflush</font></code>. These tasks are responsible for the recovery and management of in use memory. All pages of memory have an associated state (for more information on the memory state machine, refer to<span>&nbsp;</span><a title="The Life of a Page" style="COLOR: rgb(102,153,204);" href="http://blog.163.com/digoal@126/blog/getBlog.do#life-page"  >the section called “The Life of a Page”</a><span>&nbsp;</span>section. In general, the active tasks in the kernel related to VM usage are responsible for attempting to move pages out of RAM. Periodically they examine RAM, trying to identify and free inactive memory so that it can be put to other uses in the system.</p>  <h2 style="PADDING-BOTTOM: 0px; MARGIN: 0.5em 0px 0px; COLOR: rgb(0,0,0); FONT-SIZE: medium; FONT-WEIGHT: bold;"  id="life-page"  >The Life of a Page</h2>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >All of the memory managed by the VM is labeled by a state. These states help let the VM know what to do with a given page under various circumstances. Dependent on the current needs of the system, the VM may transfer pages from one state to the next, according to the state machine in<span>&nbsp;</span><a title="Figure 2. VM Page State Machine" style="COLOR: rgb(0,102,204);" href="http://blog.163.com/digoal@126/blog/getBlog.do#vm-page-state-machine"  >Figure 2. “VM Page State Machine”</a>. Using these states, the VM can determine what is being done with a page by the system at a given time and what actions the VM may take on the page. The states that have particular meanings are as follows:</p>  <ol style="PADDING-BOTTOM: 1.6em; PADDING-LEFT: 12px; MARGIN-LEFT: 12px;"  >  <li style="MARGIN: 5px 0px;"  >  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >FREE ― All pages available for allocation begin in this state. This indicates to the VM that the page is not being used for any purpose and is available for allocation.</p></li>  <li style="MARGIN: 5px 0px;"  >  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >ACTIVE ― Pages which have been allocated from the Buddy Allocator enter this state. It indicates to the VM that the page has been allocated and is actively in use by the kernel or a user process.</p></li>  <li style="MARGIN: 5px 0px;"  >  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >INACTIVE DIRTY ― This state indicates that the page has fallen into disuse by the entity which allocated it and thus is a candidate for removal from main memory. The<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >kscand</font></code><span>&nbsp;</span>task periodically sweeps through all the pages in memory, taking note of the amount of time the page has been in memory since it was last accessed. If<code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >kscand</font></code><span>&nbsp;</span>finds that a page has been accessed since it last visited the page, it increments the page's age counter; otherwise, it decrements that counter. If<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >kscand</font></code>finds a page with its age counter at zero, it moves the page to the inactive dirty state. Pages in the inactive dirty state are kept in a list of pages to be laundered.</p></li>  <li style="MARGIN: 5px 0px;"  >  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >INACTIVE LAUNDERED ― This is an interim state in which those pages which have been selected for removal from main memory enter while their contents are being moved to disk. Only pages which were in the inactive dirty state can enter this state. When the disk I/O operation is complete, the page is moved to the inactive clean state, where it may be deallocated or overwritten for another purpose. If, during the disk operation, the page is accessed, the page is moved back into the active state.</p></li>  <li style="MARGIN: 5px 0px;"  >  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >INACTIVE CLEAN ― Pages in this state have been laundered. This means that the contents of the page are in sync with the backed up data on disk. Thus, they may be deallocated by the VM or overwritten for other purposes.</p></li></ol><a id="vm-page-state-machine" name="vm-page-state-machine" rel="nofollow"  ></a>  <div><img title="[转]Understanding Virtual Memory - 德哥@Digoal - The Heart,The World."  style="BORDER-RIGHT-WIDTH: 0px; BORDER-TOP-WIDTH: 0px; BORDER-BOTTOM-WIDTH: 0px; BORDER-LEFT-WIDTH: 0px;"  alt="VM Page State Machine"  src="http://blog.163.com/digoal@126/blog/figs/vm-state-machine.png"  ></div>  <div style="BACKGROUND-IMAGE: none; FONT-STYLE: normal; BACKGROUND-POSITION: 100% 0%; MARGIN-BOTTOM: 1.6em; COLOR: rgb(102,102,102); FONT-SIZE: x-small; FONT-WEIGHT: bold; background-origin: initial; background-clip: initial;"  >Figure 2. VM Page State Machine</div>  <h2 style="PADDING-BOTTOM: 0px; MARGIN: 0.5em 0px 0px; COLOR: rgb(0,0,0); FONT-SIZE: medium; FONT-WEIGHT: bold;"  id="tuning-vm"  >Tuning the VM</h2>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >Now that the picture of the VM mechanism is sufficiently illustrated, how is it adjusted to fit certain workloads? There are two methods for changing tunable parameters in the Linux VM. The first is the sysctl interface. The sysctl interface is a programming oriented interface, which allows software programs to modify various tunable parameters directly. It is exported to system administrators via the sysctl utility, which allows an administrator to specify a value for any of the tunable VM parameters via the command line. For example:</p><pre style="PADDING-BOTTOM: 10px; OVERFLOW-X: auto; OVERFLOW-Y: visible; BACKGROUND-COLOR: rgb(247,242,208); PADDING-LEFT: 10px; WIDTH: 500px; PADDING-RIGHT: 10px; FONT-SIZE: x-small; PADDING-TOP: 10px; background-origin: initial; background-clip: initial;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  >sysctl -w vm.max map count=65535</code>  </pre>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The sysctl utility also supports the use of a configuration file (<code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >/etc/sysctl.conf</font></code>), in which all the desirable changes to a VM can be recorded for a system and restored after a restart of the operating system, making this access method suitable for long term changes to a system VM. The file is straightforward in its layout, using simple key-value pairs with comments for clarity. For example:</p><pre style="PADDING-BOTTOM: 10px; OVERFLOW-X: auto; OVERFLOW-Y: visible; BACKGROUND-COLOR: rgb(247,242,208); PADDING-LEFT: 10px; WIDTH: 500px; PADDING-RIGHT: 10px; FONT-SIZE: x-small; PADDING-TOP: 10px; background-origin: initial; background-clip: initial;"  ><tt>  #Adjust the min and max read-ahead for files  vm.max-readahead=64  vm.min-readahead=32  #turn on memory over-commit   vm.overcommit_memory=2  #bump up the percentage of memory in use to activate bdflush  vm.bdflush="40 500 0 0 500 3000 60 20 0"  </tt>  </pre>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The second method of modifying VM tunable parameters is via the proc file system. This method exports every group of VM tunables as a virtual file, accessible via all the common Linux utilities used for modifying file contents. The VM tunables are available in the directory<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >/proc/sys/vm/</font></code><span>&nbsp;</span>and are most commonly read and modified using the<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >cat</font></code>and<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >echo</font></code><span>&nbsp;</span>commands. For example, use the command<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >cat /proc/sys/vm/kswapd</font></code><span>&nbsp;</span>to view the current value of the<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >kswapd</font></code><span>&nbsp;</span>tunable. The output should be similar to:</p><pre style="PADDING-BOTTOM: 10px; OVERFLOW-X: auto; OVERFLOW-Y: visible; BACKGROUND-COLOR: rgb(247,242,208); PADDING-LEFT: 10px; WIDTH: 500px; PADDING-RIGHT: 10px; FONT-SIZE: x-small; PADDING-TOP: 10px; background-origin: initial; background-clip: initial;"  ><tt>  512 32 8  </tt>  </pre>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >Then, use the following command to modify the value of the tunable:</p><pre style="PADDING-BOTTOM: 10px; OVERFLOW-X: auto; OVERFLOW-Y: visible; BACKGROUND-COLOR: rgb(247,242,208); PADDING-LEFT: 10px; WIDTH: 500px; PADDING-RIGHT: 10px; FONT-SIZE: x-small; PADDING-TOP: 10px; background-origin: initial; background-clip: initial;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  >echo 511 31 7 &gt; /proc/sys/vm/kswapd</code>  </pre>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >Use the<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >cat /proc/sys/vm/kswapd</font></code><span>&nbsp;</span>command again to verify that the value was modified. The output should be:</p><pre style="PADDING-BOTTOM: 10px; OVERFLOW-X: auto; OVERFLOW-Y: visible; BACKGROUND-COLOR: rgb(247,242,208); PADDING-LEFT: 10px; WIDTH: 500px; PADDING-RIGHT: 10px; FONT-SIZE: x-small; PADDING-TOP: 10px; background-origin: initial; background-clip: initial;"  ><tt>  511 31 7  </tt>  </pre>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The proc file system interface is a convenient method for making adjustments to the VM while attempting to isolate the peak performance of a system. For convenience, the following sections list the VM tunable parameters as the filenames they are exported to in the<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >/proc/sys/vm/</font></code><span>&nbsp;</span>directory. Unless otherwise noted, these tunables apply to the RHEL3 2.4.21-4 kernel.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="bdflush"  >bdflush</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >bdflush</font></code><span>&nbsp;</span>file contains 9 parameters, of which 6 are tunable. These parameters affect the rate at which pages in the buffer cache (the subset of pagecache which stores files in memory) are freed and returned to disk. By adjusting the various values in this file, a system can be tuned to achieve better performance in environments where large amounts of file I/O are performed.<span>&nbsp;</span><a title="Table 1. bdflush Parameters" style="COLOR: rgb(0,102,204);" href="http://blog.163.com/digoal@126/blog/getBlog.do#bdflush-params"  >Table 1. “bdflush Parameters”</a><span>&nbsp;</span>defines the parameters for<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >bdflush</font></code><span>&nbsp;</span>in the order they appear in the file.</p><a id="bdflush-params" name="bdflush-params" rel="nofollow"  ></a>  <table style="BORDER-RIGHT-WIDTH: 1px; BACKGROUND-COLOR: rgb(247,242,208); BORDER-TOP-WIDTH: 1px; BORDER-BOTTOM-WIDTH: 1px; FONT-SIZE: x-small; BORDER-LEFT-WIDTH: 1px;"  cellspacing="0"  summary="bdflush Parameters"  >  <colgroup>  <col>  <col>  <thead>  <tr>  <th style="BACKGROUND-IMAGE: none; BORDER-BOTTOM: white 2px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; BACKGROUND-COLOR: rgb(198,194,166); PADDING-LEFT: 10px; PADDING-RIGHT: 10px; COLOR: white; FONT-SIZE: small; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px; background-origin: initial; background-clip: initial;"  >Parameter</th>  <th style="BACKGROUND-IMAGE: none; BORDER-BOTTOM: white 2px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; BACKGROUND-COLOR: rgb(198,194,166); PADDING-LEFT: 10px; PADDING-RIGHT: 10px; COLOR: white; FONT-SIZE: small; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px; background-origin: initial; background-clip: initial;"  >Description</th></tr></thead>  <tbody>  <tr>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >nfract</font></code></td>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  >The percentage of dirty pages in the buffer cache required to activate the<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >bdflush</font></code><span>&nbsp;</span>task</td></tr>  <tr>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >ndirty</font></code></td>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  >The maximum number of dirty pages in the buffer cache to write to disk in each<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >bdflush</font></code><span>&nbsp;</span>execution</td></tr>  <tr>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >reserved1</font></code></td>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  >Reserved for future use</td></tr>  <tr>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >reserved2</font></code></td>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  >Reserved for future</td></tr>  <tr>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >interval</font></code></td>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  >The number of jiffies (10ms periods) to delay between<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >bdflush</font></code>iterations</td></tr>  <tr>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >age_buffer</font></code></td>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  >The time for a normal buffer to age before it is considered for flushing back to disk</td></tr>  <tr>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >nfract_sync</font></code></td>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  >The percentage of dirty pages in the buffer cache required to cause the tasks which are writing pages of memory to begin writing those pages to disk instead</td></tr>  <tr>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >nfract_stop_bdflush</font></code></td>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  >The percentage of dirty pages in buffer cache required to allow<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >bdflush</font></code><span>&nbsp;</span>to return to idle state</td></tr>  <tr>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >reserved3</font></code></td>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  >Reserved for future use</td></tr></table>  <div style="BACKGROUND-IMAGE: none; FONT-STYLE: normal; BACKGROUND-POSITION: 100% 0%; MARGIN-BOTTOM: 1.6em; COLOR: rgb(102,102,102); FONT-SIZE: x-small; FONT-WEIGHT: bold; background-origin: initial; background-clip: initial;"  >Table 1.<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >bdflush</font></code><span>&nbsp;</span>Parameters</div>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >Generally, systems that require more free memory for application allocation want to set the<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >bdflush</font></code><span>&nbsp;</span>values higher (except for the<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >age_buffer</font></code>, which would be moved lower), so that file data is sent to disk more frequently and in greater volume, thus freeing up pages of RAM for application use. This, of course, comes at the expense of CPU cycles because the system processor spends more time moving data to disk and less time running applications. Conversely, systems which are required to perform large amounts of I/O would want to do the opposite to these values, allowing more RAM to be used to cache disk file so that file access is faster.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="dcache-priority"  >dcache_priority</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >This file controls the bias of the priority for caching directory contents. When the system is under stress, it selectively reduces the size of various file system caches in an effort to reclaim memory. By increasing this value, memory reclamation bias is shifted away from the dirent cache. By reducing this amount, the bias is shifted towards reclaiming dirent memory. This is not a particularly useful tuning parameter, but it can be helpful in maintaining the interactive response time on an otherwise heavily loaded system. If you experience intolerable delays in communicating with your system when it is busy performing other work, increasing this parameter may help.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="hugetlb"  >hugetlb_pool</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >hugetlb_pool</font></code><span>&nbsp;</span>file is responsible for recording the number of megabytes used for huge pages. Huge pages are just like regular pages in the VM, only they are an order of magnitude larger. Note also that huge pages are not swappable. Huge pages are both beneficial and detrimental to a system. They are helpful in that each huge page takes only one set of entries in the VM page tables, which allows for a higher degree of virtual address caching in the TLB (Translation Look-aside Buffer: A device which caches virtual address translations for faster lookups) and a requisite performance improvement. On the downside, they are very large and can be wasteful of memory resources for those applications which do not need large amounts of memory. Some applications, however, do require large amounts of memory and can make good use of huge pages if they are written to be aware of them. If a system is running applications which require large amounts of memory and is aware of this feature, then it is advantageous to increase this value to an amount satisfactory to that application or set of applications.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="inactive-clean-percent"  >inactive_clean_percent</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >This control specifies the minimum percentage of pages in each page zone that must be in the clean or laundered state. If any zone drops below this threshold, and the system is under pressure for more memory, then that zone will begin having its inactive dirty pages laundered. Note that this control is only available on the 2.4.21-5EL kernels forward. Raising the value for the corresponding zone which is memory starved causes pages to be paged out more quickly, eliminating memory starvation at the expense of CPU clock cycles. Lowering this number allows more data to remain in RAM, increasing the system performance but at the risk of memory starvation.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="kswapd"  >kswapd</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >While this set of parameters previously defined how frequently and in what volume a system moved non-buffer cache pages to disk, in Red Hat Enterprise Linux 3, these controls are unused.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="max-map-count"  >max_map_count</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >max_map_count</font></code><span>&nbsp;</span>file allows for the restriction of the number of VMAs (Virtual Memory Areas) that a particular process can own. A Virtual Memory Area is a contiguous area of virtual address space. These areas are created during the life of the process when the program attempts to memory map a file, links to a shared memory segment, or allocates heap space. Tuning this value limits the amount of these VMAs that a process can own. Limiting the amount of VMAs a process can own can lead to problematic application behavior because the system will return out of memory errors when a process reaches its VMA limit but can free up lowmem for other kernel uses. If your system is running low on memory in the NORMAL zone, then lowering this value will help free up memory for kernel use.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="max-readahead"  >max-readahead</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >max-readahead</font></code><span>&nbsp;</span>tunable affects how early the Linux VFS (Virtual File System) fetches the next block of a file from memory. File readahead values are determined on a per file basis in the VFS and are adjusted based on the behavior of the application accessing the file. Anytime the current position being read in a file plus the current read ahead value results in the file pointer pointing to the next block in the file, that block is fetched from disk. By raising this value, the Linux kernel allows the readahead value to grow larger, resulting in more blocks being prefetched from disks which predictably access files in uniform linear fashion. This can result in performance improvements but can also result in excess (and often unnecessary) memory usage. Lowering this value has the opposite affect. By forcing readaheads to be less aggressive, memory may be conserved at a potential performance impact.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="min-readahead"  >min-readahead</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >Like<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >max-readahead</font></code>,<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >min-readahead</font></code><span>&nbsp;</span>places a floor on the readahead value. Raising this number forces a file's readahead value to be unconditionally higher, which can bring about performance improvements provided that all file access in the system is predictably linear from the start to the end of a file. This, of course, results in higher memory usage from the pagecache. Conversely, lowering this value, allows the kernel to conserve pagecache memory at a potential performance cost.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="overcommit-memory"  >overcommit_memory</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >overcommit_memory</font></code><span>&nbsp;</span>is a value which sets the general kernel policy toward granting memory allocations. If the value is 0, then the kernel checks to determine if there is enough memory free to grant a memory request to a malloc call from an application. If there is enough memory, then the request is granted. Otherwise, it is denied and an error code is returned to the application. If the value is set to 1, then the kernel grants allocations above the amount of physical RAM and swap in the system as defined by the<code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >overcommit_ratio</font></code><span>&nbsp;</span>value. Enabling this feature can be somewhat helpful in environments which allocate large amounts of memory expecting worst case scenarios but do not use it all. If the setting in this file is 2, the kernel allows all memory allocations, regardless of the current memory allocation state.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="overcommit-ratio"  >overcommit_ratio</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >overcommit_ratio</font></code><span>&nbsp;</span>tunable defines the amount by which the kernel overextends its memory resources in the event that<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >overcommit_memory</font></code><span>&nbsp;</span>is set to the value of 2. The value in this file represents a percentage added to the amount of actual RAM in a system when considering whether to grant a particular memory request. For instance, if this value is set to 50, then the kernel would treat a system with 1 GB of RAM and 1 GB of swap as a system with 2.5 GB of allocatable memory when considering whether to grant a malloc request from an application. The general formula for this tunable is:</p><pre style="PADDING-BOTTOM: 10px; OVERFLOW-X: auto; OVERFLOW-Y: visible; BACKGROUND-COLOR: rgb(247,242,208); PADDING-LEFT: 10px; WIDTH: 500px; PADDING-RIGHT: 10px; FONT-SIZE: x-small; PADDING-TOP: 10px; background-origin: initial; background-clip: initial;"  >allocatable memory=(swap size + (RAM size * overcommit ratio))  </pre>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >Use these previous two parameters with caution. Enabling<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >overcommit_memory</font></code><span>&nbsp;</span>can create significant performance gains at little cost but only if your applications are suited to its use. If your applications use all of the memory they allocate, memory overcommit can lead to short performance gains followed by long latencies as your applications are swapped out to disk frequently when they must compete for oversubscribed RAM. Also, ensure that you have at least enough swap space to cover the overallocation of RAM (meaning that your swap space should be at least big enough to handle the percentage if overcommit in addition to the regular 50 percent of RAM that is normally recommended).</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="pagecache"  >pagecache</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >pagecache</font></code><span>&nbsp;</span>file adjusts the amount of RAM which can be used by the page cache. The page cache holds various pieces of data, such as open files from disk, memory mapped files, and pages of executable programs. Modifying the values in this file dictates how much of memory is used for this purpose.<span>&nbsp;</span><a title="Table 2. pagecache Parameters" style="COLOR: rgb(0,102,204);" href="http://blog.163.com/digoal@126/blog/getBlog.do#pagecache-parameters"  >Table 2. “pagecache Parameters”</a><span>&nbsp;</span>defines the parameters for pagecache in the order they appear in the file.</p><a id="pagecache-parameters" name="pagecache-parameters" rel="nofollow"  ></a>  <table style="BORDER-RIGHT-WIDTH: 1px; BACKGROUND-COLOR: rgb(247,242,208); BORDER-TOP-WIDTH: 1px; BORDER-BOTTOM-WIDTH: 1px; FONT-SIZE: x-small; BORDER-LEFT-WIDTH: 1px;"  cellspacing="0"  summary="pagecache Parameters"  >  <colgroup>  <col>  <col>  <thead>  <tr>  <th style="BACKGROUND-IMAGE: none; BORDER-BOTTOM: white 2px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; BACKGROUND-COLOR: rgb(198,194,166); PADDING-LEFT: 10px; PADDING-RIGHT: 10px; COLOR: white; FONT-SIZE: small; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px; background-origin: initial; background-clip: initial;"  >Parameter</th>  <th style="BACKGROUND-IMAGE: none; BORDER-BOTTOM: white 2px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; BACKGROUND-COLOR: rgb(198,194,166); PADDING-LEFT: 10px; PADDING-RIGHT: 10px; COLOR: white; FONT-SIZE: small; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px; background-origin: initial; background-clip: initial;"  >Description</th></tr></thead>  <tbody>  <tr>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >min</font></code></td>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  >The minimum amount of memory to reserve for pagecache use.</td></tr>  <tr>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >borrow</font></code></td>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  >The percentage of pagecache pages<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >kswapd</font></code><span>&nbsp;</span>uses to balance the reclaiming of pagecache pages and process memory.</td></tr>  <tr>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  ><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >max</font></code></td>  <td style="BORDER-BOTTOM: white 1px solid; TEXT-ALIGN: left; BORDER-LEFT: white 1px solid; PADDING-BOTTOM: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px; VERTICAL-ALIGN: top; BORDER-TOP: white 1px solid; BORDER-RIGHT: white 1px solid; PADDING-TOP: 10px;"  >If more memory than this percentage is used by pagecache,<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >kswapd</font></code><span>&nbsp;</span>only evicts pages from the pagecache. Once the amount of memory in pagecache is below this threshold,<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >kswapd</font></code><span>&nbsp;</span>begins moving process pages to swap again.</td></tr></table>  <div style="BACKGROUND-IMAGE: none; FONT-STYLE: normal; BACKGROUND-POSITION: 100% 0%; MARGIN-BOTTOM: 1.6em; COLOR: rgb(102,102,102); FONT-SIZE: x-small; FONT-WEIGHT: bold; background-origin: initial; background-clip: initial;"  >Table 2.<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >pagecache</font></code><span>&nbsp;</span>Parameters</div>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >Increasing these values allows more programs and cached files to stay in memory longer, thereby allowing applications to execute more quickly. On memory starved systems, however, this may lead to application delays as processes must wait for memory to become available. Moving these values downward swaps processes and other disk-backed data out more quickly, allowing for other processes to obtain memory more easily and increasing execution speed. For most workloads the automatic tuning is sufficient. However, if your workload suffers from excessive swapping and a large cache, you may want to reduce the values until the swapping problem goes away.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="page-cluster"  >page-cluster</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >The kernel attempts to read multiple pages from disk on a page fault to avoid excessive seeks on the hard drive. This parameter defines the number of pages the kernel tries to read from memory during each page fault. The value is interpreted as 2<sup>page-cluster</sup>pages for each page fault. A page fault is encountered every time a virtual memory address is accessed for which there is not yet a corresponding physical page assigned or for which the corresponding physical page has been swapped to disk. If the memory address has been requested in a valid way (for example, the application contains the address in its virtual memory map), then the kernel associates a page of RAM with the address or retrieves the page from disk and places it back in RAM. Then the kernel restarts the application from where it left off. By increasing the<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >page-cluster</font></code><span>&nbsp;</span>value, pages subsequent to the requested page are also retrieved, meaning that if the workload of a particular system accesses data in RAM in a linear fashion, increasing this parameter can provide significant performance gains (much like the file readahead parameters described earlier). Of course if your workload accesses data discreetly in many separate areas of memory, then this can just as easily cause performance degradation.</p>  <h2 style="PADDING-BOTTOM: 0px; MARGIN: 0.5em 0px 0px; COLOR: rgb(0,0,0); FONT-SIZE: medium; FONT-WEIGHT: bold;"  id="example-scenarios"  >Example Scenarios</h2>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >Now that we have covered the details of kernel tuning, let us look at some example workloads and the various tuning parameters that may improve system performance.</p>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="file-server"  >File (IMAP, Web, etc.) Server</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >This workload is geared towards performing a large amount of I/O to and from the local disk, thus benefiting from an adjustment allowing more files to be maintained in RAM. This speeds up I/O by caching more files in RAM and eliminating the need to wait for disk I/O to complete. A simple change to<span>&nbsp;</span><code style="COLOR: rgb(0,0,0); FONT-WEIGHT: bold;"  ><font face="NSimsun"  >sysctl.conf</font></code><span>&nbsp;</span>as follows usually benefits this workload:</p><pre style="PADDING-BOTTOM: 10px; OVERFLOW-X: auto; OVERFLOW-Y: visible; BACKGROUND-COLOR: rgb(247,242,208); PADDING-LEFT: 10px; WIDTH: 500px; PADDING-RIGHT: 10px; FONT-SIZE: x-small; PADDING-TOP: 10px; background-origin: initial; background-clip: initial;"  ><tt>  #increase the amount of RAM pagecache is allowed to use   #before we start moving it back to disk   vm.pagecache="10 40 100"  </tt>  </pre>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="general-compute-server"  >General Compute Server With Many Active Users</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >This workload is a very general type of configuration. It involves many active users who likely run many processes, all of which may or may not be CPU intensive or I/O intensive or a combination thereof. As the default VM configuration attempts to find a balance between I/O and process memory usage, it may be best to leave most configuration settings alone in this case. However, this environment likely contains many small processes which, regardless of workload, consume memory resources, particularly lowmem. It may help, therefore, to tune the VM to conserve low memory resources when possible:</p><pre style="PADDING-BOTTOM: 10px; OVERFLOW-X: auto; OVERFLOW-Y: visible; BACKGROUND-COLOR: rgb(247,242,208); PADDING-LEFT: 10px; WIDTH: 500px; PADDING-RIGHT: 10px; FONT-SIZE: x-small; PADDING-TOP: 10px; background-origin: initial; background-clip: initial;"  ><tt>  #lower the pagecache max to keep from eating all memory up with cache   vm.pagecache=10 25 50   #lower max-readahead to reduce the amount of unneeded IO   vm.max-readahead=16  </tt>  </pre>  <h3 style="PADDING-BOTTOM: 0px; MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px; COLOR: rgb(0,0,0); FONT-SIZE: small;"  id="batch-computing-server"  >Non interactive (Batch) Computing Server</h3>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >A batch computing server is usually the exact opposite of a file server. Applications run without human interaction, and they commonly perform with little I/O. The number of processes running on controlled. Consequently this system should allow maximum throughput:</p><pre style="PADDING-BOTTOM: 10px; OVERFLOW-X: auto; OVERFLOW-Y: visible; BACKGROUND-COLOR: rgb(247,242,208); PADDING-LEFT: 10px; WIDTH: 500px; PADDING-RIGHT: 10px; FONT-SIZE: x-small; PADDING-TOP: 10px; background-origin: initial; background-clip: initial;"  ><tt>  #Reduce the amount of pagecache normally allowed  vm.pagecache="1 10 100"  #do not worry about conserving lowmem, not that many processes  vm.max_map_count=128000 14  #crank up overcommit, processes can sleep as they are not interactive  vm.overcommit=2   vm.overcommit_ratio=75  </tt>  </pre>  <h2 style="PADDING-BOTTOM: 0px; MARGIN: 0.5em 0px 0px; COLOR: rgb(0,0,0); FONT-SIZE: medium; FONT-WEIGHT: bold;"  id="further-reading"  >Further Reading</h2>  <ol style="PADDING-BOTTOM: 1.6em; PADDING-LEFT: 12px; MARGIN-LEFT: 12px;"  >  <li style="MARGIN: 5px 0px;"  >  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  ><i>Understanding the Linux Kernel</i><span>&nbsp;</span>by Daniel Bovet and Marco Cesati (O'Reilly &amp; Associates)</p></li>  <li style="MARGIN: 5px 0px;"  >  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  ><i><a style="COLOR: rgb(0,102,204);" rel="nofollow" href="http://people.redhat.com/nmurray/RHEL-2.1-VM-whitepaper.pdf"  >Virtual Memory Behavior in Red Hat Enterprise Linux AS 2.1</a></i><span>&nbsp;</span>by Bob Matthews and Norm Murray</p></li>  <li style="MARGIN: 5px 0px;"  >  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  ><i><a style="COLOR: rgb(0,102,204);" rel="nofollow" href="http://surriel.com/lectures/ols2003/"  >Towards an O(1) VM</a></i><span>&nbsp;</span>by Rik Van Riel</p></li>  <li style="MARGIN: 5px 0px;"  >  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  ><i><a style="COLOR: rgb(0,102,204);" rel="nofollow" href="http://www.kernel.org/pub/linux/kernel/v2.4/linux-2.4.21.tar.bz2"  >The Linux Kernel Source Tree, versions 2.4.21-4EL &amp; 2.4.21-5EL</a></i></p></li></ol>  <h2 style="PADDING-BOTTOM: 0px; MARGIN: 0.5em 0px 0px; COLOR: rgb(0,0,0); FONT-SIZE: medium; FONT-WEIGHT: bold;"  id="author"  >About the Author</h2>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >Neil Horman is a software engineer at Red Hat. He lives in Raleigh, NC with his wife and 1 year old son. He has a BS and MS in computer engineering from North Carolina State University. When not enjoying family time he enjoys developing, repairing, and writing about software.</p>  <p style="PADDING-BOTTOM: 1.6em; LINE-HEIGHT: 1.25em; MARGIN: 0px 1em 0px 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px;"  >Norm Murray has been working at Red Hat for the last 3 years. Coming to programming after dissatisfaction with the state of genetic engineering, he is now an information and learning junkie.</p></span></span></div>
	</div>
</div>
</body>
</html>