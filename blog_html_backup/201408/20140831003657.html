<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">thinking monetdb in tag system</h2>
	<h5 id="">2014-08-31 0:36:57&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020147302170117/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>tag系统, 简单来说可能是从互联网抓取大量信息, 生成分类标签;&nbsp;</div><div>然后从用户或终端或浏览器等可以获取用户行为的地方获取用户的行为信息, 计算出用户在各类标签中的匹配值(例如0-100), 例如经常浏览男士用品的或者大量安装游戏的用户, 在男性和游戏玩家的标签下匹配值可能就比较高.&nbsp;</div><div>并且标签可能还有时间属性, 例如孕妇标签匹配值很高的用户, 一般有10个月的有效期限, 然后就要贴贴哺乳期的标签了.&nbsp;</div><div>年龄标签则随着时间增长.</div><div>生成标签的算法, 从用户行为运算出用户和标签的匹配值都是很复杂的. 我们这里要说的不是这个, 而是在整个过程中存储用户和标签信息的数据库.&nbsp;</div><div>标签数据库可以选择NOSQL,NEWSQL,DBMS等, 但是要考虑标签系统的独有特性, 数据库要满足才行.</div><div><br></div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >table</font></div><div><font size="2"   >userid, tag1, tag2, tag3, ...tag20000,.....-- 用户的标签可能会一直增加, 或者到了一定数量后压缩旧的标签</font></div><p></p></pre></div><div>这里每个用户一条记录, 每个标签占用一个字段, 在这个字段上存储用户在这个标签上的匹配程度, 时间属性等.</div><div>标签系统可以用于定向选择用户, 例如婴幼儿产品的厂商, 可以通过标签系统, 选择和婴幼儿产品相关的用户人群, 发送定向广告.&nbsp;</div><div>标签系统最重要的,&nbsp;</div><div>1. 提高生成标签的准确度, 精细度, 不断完善, 新增标签.</div><div>2. 用户和标签的匹配度算法的效率和准确度. &nbsp;用户行为信息可以有cookie, feed, 浏览行为, 安装的软件列表, 运行的软件列表等, 从这些信息可以计算出用户和标签的匹配度, 计算结果的准确度越高, 人群的划分就越精准. 而计算效率也是需要考虑的, 如果你的系统支撑了大量的用户, 效率越高, 就可以快速的从用户的短期行为分析出用户最近的标签.</div><div><br></div><div>标签数据库比较繁忙的地方 :&nbsp;</div><div>1. 生成/更新标签的操作</div><div>新用户, 根据用户行为信息计算出用户和标签的匹配值, 对于完全不匹配的标签可以使用默认值. 新用户在数据库的操作是插入新行.&nbsp;</div><div>旧用户, 根据用户行为信息计算出用户和标签的匹配在, 该用户可能会产生一个或多个新标签匹配, 也可能在已有标签上的匹配值. 所以有新增列的需求, 或者对已有列更新的需求.</div><div>2. 生成目标人群的操作</div><div>是一个查询操作, 查询需要结合条件, 例如我们要这样的数据:</div><div>select userid from table where</div><div>a标签的匹配度&gt;50</div><div>and</div><div>b标签的匹配度&gt;80</div><div>and</div><div><span style="line-height: 28px;"   >c标签的匹配度&gt;60</span></div><div><span style="line-height: 28px;"   >or</span></div><div><span style="line-height: 28px;"   >d标签的匹配度&gt;80</span></div><div><span style="line-height: 28px;"   >limit 10000;</span></div><div><span style="line-height: 28px;"   >这个查询最终要的是用户ID, 查询条件是某些标签的匹配度.&nbsp;</span></div><div><span style="line-height: 28px;"   >20003个列的宽表, 在monetdb上的查询效率 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >sql&gt;select count(*) from sys.storage where "table"='t1';</font></div><div><font size="2"   >+-------+</font></div><div><font size="2"   >| L1 &nbsp; &nbsp;|</font></div><div><font size="2"   >+=======+</font></div><div><font size="2"   >| 20003 |</font></div><div><font size="2"   >+-------+</font></div><div><font size="2"   >1 tuple (5.0s)</font></div></div><div><div><font size="2"   >sql&gt;select id from t1 where c1&gt;1 and c2&gt;1 and c3&gt;1 or c4&gt;1 limit 10000;</font></div><div><font size="2"   >10000 tuples (81.377ms)</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >&nbsp;</span></div><div>monetdb在TAG系统里使用可能存在的问题.</div><div>1. 全表导入/行插入速度, 我这里测试的是2万个列的表. 缺少很慢, 很难接受.</div><div>2. 全表导出速度<span style="line-height: 28px;"   >, 我这里测试的是2万个列的表. 缺少很慢, 很难接受.</span></div><div><span style="line-height: 28px;"   >参考</span></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201472962051905/"   >http://blog.163.com/digoal@126/blog/static/163877040201472962051905/</a></div><div><br></div><div><span style="line-height: 28px;"   >对标签数据库的要求 :&nbsp;</span></div><div><span style="line-height: 28px;"   >1. 数据导出速度</span></div><div><span style="line-height: 28px;"   >2. 数据导入速度</span></div><div><span style="line-height: 28px;"   >3. 添加列的速度</span></div><div><span style="line-height: 28px;"   >4. 数据更新速度</span></div><div><span style="line-height: 28px;"   >5. 数据库扩展性</span></div><div><span style="line-height: 28px;"   >6. 数据查询速度</span></div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >[注意]</span></div><div><span style="line-height: 28px;"   >1. 当列非常多时, 如果查询列很多则查询会很慢(例如一次查询2万个列), 但是如果控制查询列的数量, 例如10个列, 则可以接受.</span></div><div><span style="line-height: 28px;"   >见</span></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201472962051905/"   >http://blog.163.com/digoal@126/blog/static/163877040201472962051905/</a></div><div>2. 新增列的问题, 当表已经有数据时, 新增列会发生初始化, 所以表的已有数据越多, 新增列会越慢.&nbsp;</div><div>参见</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201472962051905/"   >http://blog.163.com/digoal@126/blog/static/163877040201472962051905/</a></div><wbr><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201472962051905/"   >http://blog.163.com/digoal@126/blog/static/163877040201472962051905/</a></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="thinking monetdb in tag system - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>