<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL custom aggregate function(hash agg) improve performance for count distince</h2>
	<h5 id="">2014-08-21 9:52:22&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402014721981288/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>之前写过关于定制PostgreSQL和Postgres-XC聚合函数的文章, 感兴趣的朋友可参考如下, 对自定义聚合函数有个了解.</div><div><div style="line-height: 28px;"   >1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020134222140958/"   >http://blog.163.com/digoal@126/blog/static/16387704020134222140958/</a></div><div style="line-height: 28px;"   >2.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020121118112533410/"   >http://blog.163.com/digoal@126/blog/static/16387704020121118112533410/</a></div></div><div style="line-height: 28px;"   >本文说的是通过自定义聚合函数来提升count(distinct x)的性能.</div><div style="line-height: 28px;"   >我们先看一下PostgreSQL是如何处理这个操作的 :&nbsp;</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >digoal=# CREATE TABLE test_table (id INT, val INT);</font></div><div style="line-height: 28px;"   ><font size="2"   >CREATE TABLE</font></div><div style="line-height: 28px;"   ><font size="2"   >digoal=# INSERT INTO test_table</font></div><div style="line-height: 28px;"   ><font size="2"   >digoal-# &nbsp; &nbsp; &nbsp;SELECT mod(i, 1000), (1000 * random())::int</font></div><div style="line-height: 28px;"   ><font size="2"   >digoal-# &nbsp; &nbsp; &nbsp; &nbsp;FROM generate_series(1,10000000) s(i);</font></div><div style="line-height: 28px;"   ><font size="2"   >INSERT 0 10000000</font></div><div style="line-height: 28px;"   ><font size="2"   >digoal=# ANALYZE test_table;</font></div><div style="line-height: 28px;"   ><font size="2"   >ANALYZE</font></div><div style="line-height: 28px;"   ><font size="2"   >digoal=# explain analyze SELECT id, COUNT(DISTINCT val) FROM test_table GROUP BY 1;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;GroupAggregate &nbsp;(cost=1376219.83..1451229.83 rows=1000 width=8) (actual time=18734.990..24936.301 rows=1000 loops=1)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Sort &nbsp;(cost=1376219.83..1401219.83 rows=10000000 width=8) (actual time=18728.432..21178.936 rows=10000000 loops=1)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Key: id</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Method: external merge &nbsp;Disk: 175872kB</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on test_table &nbsp;(cost=0.00..111002.00 rows=10000000 width=8) (actual time=0.033..1218.911 rows=10000000 loops=1<span style="line-height: 28px;"   >)</span></font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;Total runtime: 24984.937 ms</font></div><div style="line-height: 28px;"   ><font size="2"   >(6 rows)</font></div><p></p></pre></div></div><wbr><div>总共耗时大概25秒, 其中全表扫描耗时1.2秒, 排序耗时19秒, 排序后输出到下一节点(聚合)耗时2秒, 聚合耗时4秒.</div><div>显然, 排序占了大部分时间. 这里有较大的优化空间.</div><div>tvondra贡献了一个插件来提高count distinct的性能, 确切的应该说提供了一个聚合函数.</div><div><a target="_blank" rel="nofollow" href="https://github.com/tvondra/count_distinct"   >https://github.com/tvondra/count_distinct</a></div><div>当前版本9.3.5, count distinct的处理原理 :&nbsp;</div><div><div><pre class="prettyprint"   ><p><font size="2"   >With the previous implementation (based on hash tables), memory consumption was a big problem. For example when counting 80M unique 32-bit integers, it was common to see more than 5GB of RAM allocated (which is way more than the 320MB necessary for the values, and ~1.6GB when including some hash table related overhead (buckets, pointers, ...). This was mostly due to clashing with MemoryContext internals, etc.</font></p></pre></div><div>tvondra的聚合函数可以降低内存的使用, 但是依旧有可能导致内存溢出(超出WORK_MEM使用disk). 所以, 如果有很多的唯一值, 那么需要更大的内存.&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >With the new implementation significantly improves this, and the memory consumption is a fraction (usually less than 10-20% of what it used to be).</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Still, it may happen that you run out of memory. It's not very likely because for large number of groups planner will switch to GroupAggregate (effectively keeping a single group in memory), but it's possible.</font></div><p></p></pre></div><div>9.5以后可能会通过哈希聚合(也就是本文提到的插件)来解决性能问题.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Sadly, that is not something the extension could handle internally in a reasonable way. The only actual solution is to implement this into HashAggregate itself (some people are working on this, but don't hold your breath - it won't happen before 9.5).</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >So in short - if you're dealing with a lot of distinct values, you need a lot of RAM in the machine.</font></div><p></p></pre></div></div><div><span style="line-height: 28px;"   >前面我们的work_mem较小, 所以没有使用qsort, 加大work_mem后可以看到memory的开销是860MB, 我们后面观察一下使用自定义的聚合函数后会不会下降.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# set work_mem='2048MB';</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) SELECT id, COUNT(DISTINCT val) FROM test_table GROUP BY 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;GroupAggregate &nbsp;(cost=10001273676.83..10001348686.83 rows=1000 width=8) (actual time=10853.080..17148.746 rows=1000 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, count(DISTINCT val)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=11002</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Sort &nbsp;(cost=10001273676.83..10001298676.83 rows=10000000 width=8) (actual time=10844.455..12902.849 rows=10000000 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, val</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Key: test_table.id</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Method: quicksort &nbsp;Memory: 861967kB</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=11002</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.test_table &nbsp;(cost=0.00..111002.00 rows=10000000 width=8) (actual time=0.037..1258.655 rows=10000000&nbsp;</font></div><div><font size="2"   >loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, val</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=11002</font></div><div><font size="2"   >&nbsp;Total runtime: 17240.958 ms</font></div><div><font size="2"   >(12 rows)</font></div><p></p></pre></div><div><br></div><div>下载并安装count distinct插件.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-221 soft_bak]# cd /opt/soft_bak/</font></div><div><font size="2"   >[root@db-172-16-3-221 soft_bak]# git clone https://github.com/tvondra/count_distinct</font></div></div><div><div><font size="2"   >[root@db-172-16-3-221 soft_bak]# cd count_distinct/</font></div><div><font size="2"   >[root@db-172-16-3-221 count_distinct]# export PATH=/opt/pgsql/bin:$PATH</font></div><div><font size="2"   >[root@db-172-16-3-221 count_distinct]# which pg_config</font></div><div><font size="2"   >/opt/pgsql/bin/pg_config</font></div><div><font size="2"   >[root@db-172-16-3-221 count_distinct]# gmake clean</font></div><div><font size="2"   >[root@db-172-16-3-221 count_distinct]# gmake &amp;&amp; gmake install</font></div></div><div><div><font size="2"   >[root@db-172-16-3-221 count_distinct]# su - postgres</font></div><div><font size="2"   >postgres@db-172-16-3-221-&gt; psql</font></div><div><font size="2"   >psql (9.3.5)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >digoal=# create extension count_distinct;</font></div><div><font size="2"   >CREATE EXTENSION</font></div></div><div><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select id,count_distinct(val) from test_table group by 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;GroupAggregate &nbsp;(cost=1376219.83..1451232.33 rows=1000 width=8) (actual time=18885.591..27492.614 rows=1000 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, count_distinct(val)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=11002, temp read=37391 written=37391</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Sort &nbsp;(cost=1376219.83..1401219.83 rows=10000000 width=8) (actual time=18876.824..21338.226 rows=10000000 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, val</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Key: test_table.id</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sort Method: external merge &nbsp;Disk: 175872kB</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=11002, temp read=37391 written=37391</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.test_table &nbsp;(cost=0.00..111002.00 rows=10000000 width=8) (actual time=0.041..1250.068 rows=10000000&nbsp;</font></div><div><font size="2"   >loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, val</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=11002</font></div><div><font size="2"   >&nbsp;Total runtime: 27550.719 ms</font></div><div><font size="2"   >(12 rows)</font></div></div><p></p></pre></div><div>我们看到, 如果work memory不够的话, 还是会用到排序和分组聚合, 所以时间没有比传统的快.</div><div>加大work_mem后, 没有使用排序了, 而是使用了哈希聚合, 数据全命中的情况下, 时间从17秒缩短到了8.8秒</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# set work_mem='2048MB';</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain (analyze,verbose,buffers) select id,count_distinct(val) from test_table group by 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >---</font></div><div><font size="2"   >&nbsp;HashAggregate &nbsp;(cost=161002.00..161014.50 rows=1000 width=8) (actual time=8570.713..8820.665 rows=1000 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, count_distinct(val)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=11002</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.test_table &nbsp;(cost=0.00..111002.00 rows=10000000 width=8) (actual time=0.038..1319.931 rows=10000000 loops=</font></div><div><font size="2"   >1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, val</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=11002</font></div><div><font size="2"   >&nbsp;Total runtime: 8822.011 ms</font></div><div><font size="2"   >(7 rows)</font></div><p></p></pre></div><div>使用哈希聚合效率比分组聚合要高, 少了排序的过程.</div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020134222140958/"   >http://blog.163.com/digoal@126/blog/static/16387704020134222140958/</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020121118112533410/"   >http://blog.163.com/digoal@126/blog/static/16387704020121118112533410/</a></div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/xaggr.html"   >http://www.postgresql.org/docs/9.4/static/xaggr.html</a></div><div>4.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://blog.pgaddict.com/posts/count-distinct-improvements"   >http://blog.pgaddict.com/posts/count-distinct-improvements</a></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL custom aggregate function(hash agg) improve performance for count distince - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>