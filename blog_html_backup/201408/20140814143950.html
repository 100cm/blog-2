<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">MonetDB table level write lock? OR it's repeatable read above isolate?</h2>
	<h5 id="">2014-08-14 14:39:50&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020147142269881/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>在测试对单个表执行insert时, 发现并行的话会导致除最早提交的事务以外的其他事务回滚.</div><div><br></div><div>来看个例子 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;\d d</font></div><div><font size="2"   >CREATE TABLE "sys"."d" (</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; "id" &nbsp; INTEGER,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; "info" VARCHAR(64),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; "c1" &nbsp; VARCHAR(64)</font></div><div><font size="2"   >);</font></div><p></p></pre></div><div><br></div><div>当前d表有1条记录.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;select * from d;</font></div><div><font size="2"   >+------+------+------+</font></div><div><font size="2"   >| id &nbsp; | info | c1 &nbsp; |</font></div><div><font size="2"   >+======+======+======+</font></div><div><font size="2"   >| &nbsp; &nbsp;1 | test | test |</font></div><div><font size="2"   >+------+------+------+</font></div><div><font size="2"   >1 tuple (1.698ms)</font></div><p></p></pre></div><div>开启会话1, 插入一条记录, 可以查看到有2条记录</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;start transaction;</font></div><div><font size="2"   >auto commit mode: off</font></div><div><font size="2"   >sql&gt;insert into d values (2,'test','test');</font></div><div><font size="2"   >1 affected rows (0.726ms)</font></div><div><font size="2"   >sql&gt;select * from d;</font></div><div><font size="2"   >+------+------+------+</font></div><div><font size="2"   >| id &nbsp; | info | c1 &nbsp; |</font></div><div><font size="2"   >+======+======+======+</font></div><div><font size="2"   >| &nbsp; &nbsp;1 | test | test |</font></div><div><font size="2"   >| &nbsp; &nbsp;2 | test | test |</font></div><div><font size="2"   >+------+------+------+</font></div><div><font size="2"   >2 tuples (1.595ms)</font></div><p></p></pre></div><div><br></div><div>开启会话2, 查看只有1条记录, 说明至少是read committed隔离级别.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;start transaction;</font></div><div><font size="2"   >auto commit mode: off</font></div><div><font size="2"   >sql&gt;select * from d;</font></div><div><font size="2"   >+------+------+------+</font></div><div><font size="2"   >| id &nbsp; | info | c1 &nbsp; |</font></div><div><font size="2"   >+======+======+======+</font></div><div><font size="2"   >| &nbsp; &nbsp;1 | test | test |</font></div><div><font size="2"   >+------+------+------+</font></div><div><font size="2"   >1 tuple (1.299ms)</font></div><p></p></pre></div><div>在会话2删除这条记录. 再次查看没有记录了</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;delete from d;</font></div><div><font size="2"   >1 affected rows (0.684ms)</font></div><div><font size="2"   >sql&gt;select * from d;</font></div><div><font size="2"   >+----+------+----+</font></div><div><font size="2"   >| id | info | c1 |</font></div><div><font size="2"   >+====+======+====+</font></div><div><font size="2"   >+----+------+----+</font></div><div><font size="2"   >0 tuples (1.152ms)</font></div><p></p></pre></div></div><div><br></div><div>在会话1, 还可以看到2条记录</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;select * from d;</font></div><div><font size="2"   >+------+------+------+</font></div><div><font size="2"   >| id &nbsp; | info | c1 &nbsp; |</font></div><div><font size="2"   >+======+======+======+</font></div><div><font size="2"   >| &nbsp; &nbsp;1 | test | test |</font></div><div><font size="2"   >| &nbsp; &nbsp;2 | test | test |</font></div><div><font size="2"   >+------+------+------+</font></div><div><font size="2"   >2 tuples (0.926ms)</font></div><p></p></pre></div><div><br></div><div>会话2提交, 成功</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;commit;</font></div><div><font size="2"   >auto commit mode: on</font></div><p></p></pre></div><div><br></div><div>在会话1, 还可以看到2条记录, 现在有点像repeatable read或者ssi隔离级别了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;select * from d;</font></div><div><font size="2"   >+------+------+------+</font></div><div><font size="2"   >| id &nbsp; | info | c1 &nbsp; |</font></div><div><font size="2"   >+======+======+======+</font></div><div><font size="2"   >| &nbsp; &nbsp;1 | test | test |</font></div><div><font size="2"   >| &nbsp; &nbsp;2 | test | test |</font></div><div><font size="2"   >+------+------+------+</font></div><div><font size="2"   >2 tuples (1.065ms)</font></div><p></p></pre></div><div>提交会话1失败</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;commit;</font></div><div><font size="2"   >COMMIT: failed</font></div><p></p></pre></div><div>在会话1再次查看表d, 已经没有记录了. 因为会话2删除了d的所有记录</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;select * from d;</font></div><div><font size="2"   >+----+------+----+</font></div><div><font size="2"   >| id | info | c1 |</font></div><div><font size="2"   >+====+======+====+</font></div><div><font size="2"   >+----+------+----+</font></div><div><font size="2"   >0 tuples (1.399ms)</font></div><p></p></pre></div></div><div><br></div><div>从现象上看, 在事务过程中并没有锁冲突发生, 在事务提交的时候检测到冲突后回滚.&nbsp;</div><div>所以先提交的事务成功了, 后提交的事务就失败了.</div><div>这样也没有死锁的问题. 反正不会等待.</div><wbr><div>来看一下MonetDB对事务的介绍 : 用的是OCC并发控制方法, 提交时检测冲突, 所以不适合有增删改冲突的并行长事务场景.</div><div><div id="content-header"   style="color: rgb(0, 0, 68); font-family: 'Trebuchet MS', 'Helvetica neue', Helvetica, Arial, Verdana, sans-serif; font-size: 14px; line-height: 21px;"   ><h1 style="margin-bottom: 0.3em; font-size: 1.3em;"   >Transactions</h1></div><div id="content-area"   style="color: rgb(0, 0, 68); font-family: 'Trebuchet MS', 'Helvetica neue', Helvetica, Arial, Verdana, sans-serif; font-size: 14px; line-height: 21px;"   ><div id="node-58"   style="margin: 0px 0px 15px; padding: 0px; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"   ><div><div><div><div><div style="line-height: 1.5em; clear: both; margin: 1em 0px 0.5em;"   ><p style="margin-top: 0.4em; margin-bottom: 0.8em;"   >MonetDB/SQL supports a multi-statement transaction scheme marked by START&nbsp;TRANSACTION and closed with either COMMIT or ROLLBACK. The session variable<span>auto_commit</span>&nbsp;can be set to&nbsp;<span>true</span>&nbsp;if each SQL statement should be considered an independent transaction.</p><p style="margin-top: 0.4em; margin-bottom: 0.8em;"   ><strong>WARNING.&nbsp;</strong>The transaction management scheme is based on<a style="text-decoration: none; font-weight: bold; color: rgb(0, 102, 255);" rel="nofollow" href="http://en.wikipedia.org/wiki/Optimistic_concurrency_control"   >&nbsp;optimistic concurrency control.</a>&nbsp;It provides each transaction with a consistent view on the database, but updates are collected in an addendum processed on transaction commit. If at commit time it can be assured that the data prepared for update affects tables has not changed in the mean time, the results are merged.&nbsp;<br>This optimistic concurrency scheme is particularly useful for query dominant environments. It negatively affects long running transactions which concurrently are affected by updates on their underlying tables.</p><p style="margin-top: 0.4em; margin-bottom: 0.8em;"   ><strong>WARNING.&nbsp;</strong>Optimistic concurrency control may be confusing for those who built online-transaction applications, because the granularity of the concurrency control scheme will show higher then expected transaction failures. There is not a locking schema to avoid this. Applications may have to resort to serial execution.</p><p style="margin-top: 0.4em; margin-bottom: 0.8em;"   ><strong>WARNING. T</strong>he tuples being deleted are only marked as such. They do not reduce the table size. It calls for a vacuum cleaning algorithm.</p></div></div></div></div></div></div></div></div><div>为什么说是表级别的冲突呢? 因为不同的表的DML不会冲突.</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >会话1</font></div><div><div><font size="2"   >sql&gt;start transaction;</font></div><div><font size="2"   >auto commit mode: off</font></div><div><font size="2"   >sql&gt;insert into d values(100,'test','test');</font></div><div><font size="2"   >1 affected rows (0.678ms)</font></div><div><span style="line-height: 28px;"   ><font size="2"   >会话2</font></span></div></div><div><div><font size="2"   >sql&gt;start transaction;</font></div><div><font size="2"   >auto commit mode: off</font></div><div><font size="2"   >sql&gt;insert into c values(100,'test','test');</font></div><div><font size="2"   >1 affected rows (0.678ms)</font></div><div><span style="line-height: 28px;"   ><font size="2"   >会话1</font></span></div><div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >sql&gt;commit;</font></div></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >auto commit mode: on</font></span></div></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >会话2</font></span></div><div><font size="2"   >sql&gt;commit;</font></div><div><font size="2"   >auto commit mode: on</font></div></div><p></p></pre></div><div>都提交成功</div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://www.monetdb.org/Documentation"   >https://www.monetdb.org/Documentation</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Optimistic_concurrency_control"   >http://en.wikipedia.org/wiki/Optimistic_concurrency_control</a></div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://www.monetdb.org/Documentation/Manuals/SQLreference/Transactions"   >https://www.monetdb.org/Documentation/Manuals/SQLreference/Transactions</a></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="MonetDB table level write lock? OR its repeatable read above isolate? - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>