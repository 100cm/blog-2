<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">keepalived modify notify.c & vrrp.c to enforce waiting notify script execute success</h2>
	<h5 id="">2014-08-26 11:02:32&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201472610253450/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>我们在设计数据库HA的时候, 为了防止主备同时读写一份数据, 或者主备同时对外提供服务. 备机在切换成主机前, 需要有一个fence操作, 需先将主节点fence掉, 然后再激活备库为主库.</div><div>例如我们这边用的一个HA脚本 :&nbsp;</div><div><a target="_blank" rel="nofollow" href="https://raw.githubusercontent.com/digoal/sky_postgresql_cluster/master/INSTALL.txt"   >https://raw.githubusercontent.com/digoal/sky_postgresql_cluster/master/INSTALL.txt</a></div><div>或者RHEL的HA套件, 都有类似的FENCE操作.</div><div>但是keepalived目前没有切换前的自定义脚本, 只有切换后的自定义脚本(notify), 并且不等待脚本执行.</div><div>如图 :&nbsp;</div><div><div><img title="keepalived modify notify.c  vrrp.c to enforce waiting notify script execute success - 德哥@Digoal - PostgreSQL research"   alt="keepalived modify notify.c  vrrp.c to enforce waiting notify script execute success - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img0.ph.126.net/gEW1bGfIGTOIQ_0P-Y9EtA==/6608605842655141194.png"   ></div></div><div>keepalived如果用于数据库的HA切换还需要完善一下.</div><div>本文将讲解一下, 如何修改keepalived代码, 来实现这方面的功能, 即备切换成主之前, 必须先等待fence主节点.</div><div>最终目的如图 :&nbsp;</div><div><div><img title="keepalived modify notify.c  vrrp.c to enforce waiting notify script execute success - 德哥@Digoal - PostgreSQL research"   alt="keepalived modify notify.c  vrrp.c to enforce waiting notify script execute success - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img0.ph.126.net/C5EAb8iwNP4pTNEPD-JA9Q==/6608749878678379173.png"   ></div></div><div><br></div><div>首先要了解一下keepalived notify的机制 :&nbsp;</div><div>顺序是这样的 : 起vip, 起静态路由, fork进程调用notify脚本(并且不等待).&nbsp;</div><div>注意调用notify脚本在起VIP之后.</div><div>我们的目的是把它放到最前面, 并且需要等待notify脚本调用完成再起VIP.</div><div><br></div><div>keepalived有几项配置和notify有关, 即当路由器的角色转换后, 调用用户配置的脚本.</div><div><span style="line-height: 28px;"   >doc/keepalived.conf.SYNOPSIS</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; notify_master &lt;STRING&gt;|&lt;QUOTED-STRING&gt; # Script to run during MASTER transit</font></div><div><font size="2"   >&nbsp; &nbsp; notify_backup &lt;STRING&gt;|&lt;QUOTED-STRING&gt; # Script to run during BACKUP transit</font></div><div><font size="2"   >&nbsp; &nbsp; notify_fault &lt;STRING&gt;|&lt;QUOTED-STRING&gt; &nbsp;# Script to run during FAULT transit</font></div><div><font size="2"   >&nbsp; &nbsp; notify &lt;STRING&gt;|&lt;QUOTED-STRING&gt; &nbsp; &nbsp; &nbsp; &nbsp;# Script to run during ANY state transit (1)</font></div><div><font size="2"   >&nbsp; &nbsp; smtp_alert &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Send email notif during state transit</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >(1) The "notify" script is called AFTER the corresponding notify_* script has</font></div><div><font size="2"   >&nbsp; &nbsp; been called, and is given exactly 4 arguments (the whole string is interpreted</font></div><div><font size="2"   >&nbsp; &nbsp; as a litteral filename so don't add parameters!):</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; $1 = A string indicating whether it's a "GROUP" or an "INSTANCE"</font></div><div><font size="2"   >&nbsp; &nbsp; $2 = The name of said group or instance</font></div><div><font size="2"   >&nbsp; &nbsp; $3 = The state it's transitioning to ("MASTER", "BACKUP" or "FAULT")</font></div><div><font size="2"   >&nbsp; &nbsp; $4 = The priority value</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; $1 and $3 are ALWAYS sent in uppercase, and the possible strings sent are the</font></div><div><font size="2"   >&nbsp; &nbsp; same ones listed above ("GROUP"/"INSTANCE", "MASTER"/"BACKUP"/"FAULT").</font></div><p></p></pre></div><div>当路由器在进入对应的角色后, 会调用对应的脚本如notify_master, notify_backup, notify_fault.</div><div>当以上脚本调用完后, 再调用notify脚本.</div><div>相关代码举例 :&nbsp;</div><div>进入master角色的代码</div><div><span style="line-height: 28px;"   >keepalived/vrrp/vrrp.c</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/* MASTER state processing */</font></div><div><font size="2"   >int</font></div><div><font size="2"   >vrrp_state_master_tx(vrrp_t * vrrp, const int prio)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int ret = 0;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!VRRP_VIP_ISSET(vrrp)) {</font></div><div><span style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_message(LOG_INFO, "VRRP_Instance(%s) Entering MASTER STATE"</font></span></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; , vrrp-&gt;iname);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrrp_state_become_master(vrrp); &nbsp; // 进入master角色的操作对应的函数</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; } else if (vrrp-&gt;garp_refresh &amp;&amp; timer_cmp(time_now, vrrp-&gt;garp_refresh_timer) &gt; 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrrp_send_link_update(vrrp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrrp-&gt;garp_refresh_timer = timer_add_long(time_now, vrrp-&gt;garp_refresh);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; vrrp_send_adv(vrrp,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (prio == VRRP_PRIO_OWNER) ? VRRP_PRIO_OWNER :</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrrp-&gt;effective_priority);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return ret;</font></div><div><font size="2"   >}</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >当进入master角色后, 在启用虚拟IP后, 会调用notify脚本.</font></div><div><div><font size="2"   >/* becoming master */</font></div><div><font size="2"   >void</font></div><div><font size="2"   >vrrp_state_become_master(vrrp_t * vrrp)</font></div><div><font size="2"   >{</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* add the ip addresses */ &nbsp;// 先启用虚拟IP</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!LIST_ISEMPTY(vrrp-&gt;vip))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrrp_handle_ipaddress(vrrp, IPADDRESS_ADD, VRRP_VIP_TYPE);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!LIST_ISEMPTY(vrrp-&gt;evip))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrrp_handle_ipaddress(vrrp, IPADDRESS_ADD, VRRP_EVIP_TYPE);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; vrrp-&gt;vipset = 1;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* add virtual routes */ &nbsp;// 然后添加静态路由</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!LIST_ISEMPTY(vrrp-&gt;vroutes))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrrp_handle_iproutes(vrrp, IPROUTE_ADD);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* remotes neighbour update */ &nbsp;// 然后发送免费ARP报文</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; vrrp_send_link_update(vrrp);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* set refresh timer */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (vrrp-&gt;garp_refresh) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrrp-&gt;garp_refresh_timer = timer_add_long(time_now, vrrp-&gt;garp_refresh);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Check if notify is needed */ &nbsp;// 最后是调用自定义的notify脚本</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; notify_instance_exec(vrrp, VRRP_STATE_MAST);</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >#ifdef _WITH_SNMP_ &nbsp;// 触发snmp</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; vrrp_snmp_instance_trap(vrrp);</font></div><div><font size="2"   >#endif</font></div></div><div><font size="2"   >....</font></div><p></p></pre></div><div><br></div><div>这里要注意的是, notify脚本调用时fork进程通过system函数来调用的, 并且主进程直接返回0, 不等待子进程执行完毕.</div><div>对应的代码 :&nbsp;</div><div>lib/notify.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/* perform a system call */</font></div><div><font size="2"   >int</font></div><div><font size="2"   >system_call(char *cmdline)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int retval;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; retval = system(cmdline);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (retval == 127) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* couldn't exec command */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_message(LOG_ALERT, "Couldn't exec command: %s", cmdline);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; } else if (retval == -1) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* other error */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_message(LOG_ALERT, "Error exec-ing command: %s", cmdline);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return retval;</font></div><div><font size="2"   >}</font></div></div><div><div><font size="2"   >/* Execute external script/program */</font></div><div><font size="2"   >int</font></div><div><font size="2"   >notify_exec(char *cmd)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pid_t pid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int ret;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pid = fork();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* In case of fork is error. */ &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (pid &lt; 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_message(LOG_INFO, "Failed fork process");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* In case of this is parent process */ &nbsp;// 主进程直接退出, 没有wait 子进程.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (pid)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; signal_handler_destroy();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; closeall(0);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; open("/dev/null", O_RDWR);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ret = dup(0);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (ret &lt; 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_message(LOG_INFO, "dup(0) error");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ret = dup(0);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (ret &lt; 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_message(LOG_INFO, "dup(0) error");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; system_call(cmd);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; exit(0);</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><br></div><div>所以, 为了达到目的, 我们需要改2个地方. 为了方便观察, 加几个日志输出.</div><div># cd /opt/soft_bak/keepalived-1.2.13</div><div>1. 把调用notify脚本移到vip前面</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># vi keepalived/vrrp/vrrp.c</font></div><div><font size="2"   >修改函数, 把调用notify脚本从这个函数剥离出来</font></div><div><div><font size="2"   >/* becoming master */</font></div><div><font size="2"   >void</font></div><div><font size="2"   >vrrp_state_become_master(vrrp_t * vrrp)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Check if notify is needed */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; //notify_instance_exec(vrrp, VRRP_STATE_MAST); &nbsp;//注释这里&nbsp;</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >修改函数</font></div><div><div><font size="2"   >/* MASTER state processing */</font></div><div><font size="2"   >int</font></div><div><font size="2"   >vrrp_state_master_tx(vrrp_t * vrrp, const int prio)</font></div></div><div><font size="2"   >{</font></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; // if (!VRRP_VIP_ISSET(vrrp)) { &nbsp;// 改成如下, 即把notify脚本放到<span style="line-height: 28px;"   >vrrp_state_become_master之前, 并且返回成功才会调用</span><span style="line-height: 28px;"   >vrrp_state_become_master.</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if ((!VRRP_VIP_ISSET(vrrp)) &amp;&amp; notify_instance_exec(vrrp, VRRP_STATE_MAST)) {</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_message(LOG_INFO, "VRRP_Instance(%s) Entering MASTER STATE"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; , vrrp-&gt;iname);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vrrp_state_become_master(vrrp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = 1;</font></div></div><p></p></pre></div><div><br></div><div>2. 需要让主进程等待notify脚本执行完</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># vi lib/notify.c</font></div><div><font size="2"   >添加等待需要的头文件</font></div><div><div><font size="2"   >#include &lt;sys/types.h&gt;</font></div><div><font size="2"   >#include &lt;sys/wait.h&gt;</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >修改函数</font></div><div><div><div><font size="2"   >/* Execute external script/program */</font></div><div><font size="2"   >int</font></div><div><font size="2"   >notify_exec(char *cmd)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pid_t pid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int ret;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pid_t wait_pid;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int wait_ret;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pid = fork();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* In case of fork is error. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (pid &lt; 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_message(LOG_INFO, "Failed fork process");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* child process */ &nbsp;// 子进程执行</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (pid == 0) {</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; signal_handler_destroy();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closeall(0);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; open("/dev/null", O_RDWR);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = dup(0);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ret &lt; 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_message(LOG_INFO, "dup(0) error");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = dup(0);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ret &lt; 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_message(LOG_INFO, "dup(0) error");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_message(LOG_INFO, "notify executing."); &nbsp;// 添加日志输出</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; system_call(cmd);</font></div></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit(0);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* In case of this is parent process */ &nbsp;// 主进程等待</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_message(LOG_INFO, "waiting notify execute success."); &nbsp;&nbsp;<span style="line-height: 28px;"   >// 添加日志输出</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait_pid = waitpid(pid, &amp;wait_ret, 0);&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (wait_pid == pid &amp;&amp; WIFEXITED(wait_ret)) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_message(LOG_INFO, "notify execute successed."); &nbsp; &nbsp;<span style="line-height: 28px;"   >// 添加日志输出</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div><br></div><div>重新编译</div><div># gmake &amp;&amp; gmake install</div><div><br></div><div>测试</div><div>配置文件</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@192_168_173_203 keepalived-1.2.13]# cd /opt/keepalived/etc/keepalived/</font></div><div><font size="2"   >[root@192_168_173_203 keepalived]# cat keepalived.conf</font></div><div><font size="2"   >! Configuration File for keepalived &nbsp;!号或#号开头为注释</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >global_defs { &nbsp; &nbsp; &nbsp;# 全局配置除了router_id, 其他都无所谓, 因为我这里的测试只是观察script weight对vrrp的影响.</font></div><div><font size="2"   >&nbsp; &nbsp;notification_email {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;acassen@firewall.loc</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;failover@firewall.loc</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;sysadmin@firewall.loc</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;notification_email_from Alexandre.Cassen@firewall.loc</font></div><div><font size="2"   >&nbsp; &nbsp;smtp_server 192.168.200.1</font></div><div><font size="2"   >&nbsp; &nbsp;smtp_connect_timeout 30</font></div><div><font size="2"   >&nbsp; &nbsp;router_id DIGOAL_TEST1 &nbsp; # 随便配置, 因为这个不在VRRP包里面体现, 在VRRP包里体现的是虚拟路由器ID.</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >vrrp_script pos { &nbsp; # 脚本配置&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; script "/root/pos.sh"</font></div><div><font size="2"   >&nbsp; &nbsp; interval 1</font></div><div><font size="2"   >&nbsp; &nbsp; weight 0 &nbsp; # 配置默认weight 0, 后面可以在instance中覆盖</font></div><div><font size="2"   >&nbsp; &nbsp; fall 1 &nbsp; &nbsp;# 从OK到KO需要1次检测失败.</font></div><div><font size="2"   >&nbsp; &nbsp; rise 1 &nbsp; &nbsp;# 从KO到OK需要1次检测成功.</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >vrrp_script nag { &nbsp; # 脚本配置&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; script "/root/nag.sh"</font></div><div><font size="2"   >&nbsp; &nbsp; interval 1</font></div><div><font size="2"   >&nbsp; &nbsp; weight 0 &nbsp; # 配置默认weight 0, 后面可以在instance中覆盖</font></div><div><font size="2"   >&nbsp; &nbsp; fall 1 &nbsp; &nbsp;# 从OK到KO需要1次检测失败.</font></div><div><font size="2"   >&nbsp; &nbsp; rise 1 &nbsp; &nbsp;# 从KO到OK需要1次检测成功.</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >vrrp_script zero { &nbsp; # 脚本配置&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; script "/root/zero.sh"</font></div><div><font size="2"   >&nbsp; &nbsp; interval 1</font></div><div><font size="2"   >&nbsp; &nbsp; weight 0 &nbsp; # 配置默认weight 0, 后面可以在instance中覆盖</font></div><div><font size="2"   >&nbsp; &nbsp; fall 1 &nbsp; &nbsp;# 从OK到KO需要1次检测失败.</font></div><div><font size="2"   >&nbsp; &nbsp; rise 1 &nbsp; &nbsp;# 从KO到OK需要1次检测成功.</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >vrrp_instance vi_1 {</font></div><div><font size="2"   >&nbsp; &nbsp; state MASTER &nbsp; &nbsp;# 初始状态</font></div><div><font size="2"   >&nbsp; &nbsp; interface eth0</font></div><div><font size="2"   >&nbsp; &nbsp; virtual_router_id 51</font></div><div><font size="2"   >&nbsp; &nbsp; priority 100 &nbsp; # 初始优先级, 注意两个节点配置要不一样. 一高一低, 高的选举为master.</font></div><div><font size="2"   >&nbsp; &nbsp; advert_int 1</font></div><div><font size="2"   >&nbsp; &nbsp; authentication {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; auth_type PASS</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; auth_pass 12345678  # 最大长度为8, 如果要修改最大长度,&nbsp;</font></div><div><font size="2"   >                            # 可参考 </font><a style="line-height: 28px; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, &#23435;&#20307;;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201472123810816/"   ><font size="2"   >http://blog.163.com/digoal@126/blog/static/163877040201472123810816/</font></a></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; track_script {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; pos weight 3</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; zero weight 0</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; nag weight -5</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; unicast_peer { &nbsp; # 使用单播代替组播发送vrrp心跳.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 192.168.173.203</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 192.168.173.204</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; virtual_ipaddress { &nbsp; # 虚拟地址配置, 和ifconfig兼容</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 172.16.173.100/24 brd 172.16.173.255 dev eth0 scope link label eth0:1</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; debug &nbsp; # 打开debug, 方便调试, 本例没有用到</font></div><div><font size="2"   >    nopreempt   # 不主动竞争master, 这样的话优先级只用于决定第一次搭建HA时的主库节点, 发生failover后, 不会主动提升.</font></div><div><font size="2"   >&nbsp; &nbsp; notify_master "/root/notify.sh"</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>配置脚本</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@192_168_173_203 keepalived]# vi /root/notify.sh&nbsp;</font></div><div><font size="2"   >#!/bin/bash</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >sleep 1000</font></div><div><font size="2"   >exit 0</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   ># chmod 555 /root/notify.sh</font></div><p></p></pre></div><div><br></div><div>启动keepalived</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># keepalived -f /opt/keepalived/etc/keepalived/keepalived.conf -D</font></div><div></div><p></p></pre></div><div>观察日志 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># tail -f -n 1 /var/log/messages</font></div><div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived[14531]: Starting Keepalived v1.2.13 (08/19,2014)</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived[14532]: Starting Healthcheck child process, pid=14533</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived[14532]: Starting VRRP child process, pid=14534</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_vrrp[14534]: Netlink reflector reports IP 192.168.173.203 added</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_vrrp[14534]: Netlink reflector reports IP 192.168.173.156 added</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_vrrp[14534]: Netlink reflector reports IP fe80::f6ce:46ff:fe86:4234 added</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_healthcheckers[14533]: Netlink reflector reports IP 192.168.173.203 added</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_healthcheckers[14533]: Netlink reflector reports IP 192.168.173.156 added</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_vrrp[14534]: Registering Kernel netlink reflector</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_vrrp[14534]: Registering Kernel netlink command channel</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_healthcheckers[14533]: Netlink reflector reports IP fe80::f6ce:46ff:fe86:4234 added</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_vrrp[14534]: Registering gratuitous ARP shared channel</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_healthcheckers[14533]: Registering Kernel netlink reflector</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_healthcheckers[14533]: Registering Kernel netlink command channel</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_healthcheckers[14533]: Opening file '/opt/keepalived/etc/keepalived/keepalived.conf'.</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_vrrp[14534]: Opening file '/opt/keepalived/etc/keepalived/keepalived.conf'.</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_healthcheckers[14533]: Configuration is using : 7972 Bytes</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_vrrp[14534]: Configuration is using : 69370 Bytes</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_vrrp[14534]: Using LinkWatch kernel netlink reflector...</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_vrrp[14534]: VRRP sockpool: [ifindex(2), proto(112), unicast(1), fd(10,11)]</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_healthcheckers[14533]: Using LinkWatch kernel netlink reflector...</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_vrrp[14534]: VRRP_Script(nag) succeeded</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_vrrp[14534]: VRRP_Script(zero) succeeded</font></div><div><font size="2"   >Aug 26 10:13:31 192_168_173_203 Keepalived_vrrp[14534]: VRRP_Script(pos) succeeded</font></div><div><font size="2"   >Aug 26 10:13:32 192_168_173_203 Keepalived_vrrp[14534]: VRRP_Instance(vi_1) Transition to MASTER STATE</font></div><div><font size="2"   >Aug 26 10:13:33 192_168_173_203 Keepalived_vrrp[14534]: waiting notify execute success.</font></div><div><font size="2"   >Aug 26 10:13:33 192_168_173_203 Keepalived_vrrp[14564]: notify executing.</font></div></div><div><font size="2"   >... 1000秒后, 进入master, 并且启动VIP, 测试成功.</font></div><div><div><font size="2"   >Aug 26 10:30:13 192_168_173_203 Keepalived_vrrp[14534]: notify execute successed.</font></div><div><font size="2"   >Aug 26 10:30:13 192_168_173_203 Keepalived_vrrp[14534]: VRRP_Instance(vi_1) Entering MASTER STATE</font></div><div><font size="2"   >Aug 26 10:30:13 192_168_173_203 Keepalived_vrrp[14534]: VRRP_Instance(vi_1) setting protocol VIPs.</font></div><div><font size="2"   >Aug 26 10:30:13 192_168_173_203 Keepalived_vrrp[14534]: VRRP_Instance(vi_1) Sending gratuitous ARPs on eth0 for 172.16.173.100</font></div><div><font size="2"   >Aug 26 10:30:13 192_168_173_203 Keepalived_healthcheckers[14533]: Netlink reflector reports IP 172.16.173.100 added</font></div><div><font size="2"   >Aug 26 10:30:18 192_168_173_203 Keepalived_vrrp[14534]: VRRP_Instance(vi_1) Sending gratuitous ARPs on eth0 for 172.16.173.100</font></div></div><p></p></pre></div><div><br></div><div>我们只要把fence操作放在这个脚本里面, 就可以实现先fence, 再启VIP的过程.</div><div><br></div><div>[注意]</div><div>本文仅提供思路, 仅供测试, 用于生产请自行承担风险.</div><div><br></div>[参考]<wbr><div>1. lib/notify.c</div><div>2. keepalived/vrrp/vrrp.c</div><div>3. man 2 wait</div><div>4. man 3 system</div><div>5.&nbsp;doc/keepalived.conf.SYNOPSIS</div><div>6.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://raw.githubusercontent.com/digoal/sky_postgresql_cluster/master/INSTALL.txt"   >https://raw.githubusercontent.com/digoal/sky_postgresql_cluster/master/INSTALL.txt</a></div><div>7.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201472123810816/"   >http://blog.163.com/digoal@126/blog/static/163877040201472123810816/</a></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="keepalived modify notify.c  vrrp.c to enforce waiting notify script execute success - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>