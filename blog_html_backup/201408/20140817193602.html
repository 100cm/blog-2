<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">MonetDB multiplex-funnel</h2>
	<h5 id="">2014-08-17 19:36:02&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201471743511773/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>本文介绍一下MonetDB的漏斗功能. 此功能也是需要基于MonetDB的discovery和remote database.</div><div><br></div><div>m-funnel这个功能有点像plproxy, 多了一个queue/funnel的限制, 并且没有plproxy 的路由算法, 一个纯粹的代理.</div><div>plproxy接受客户端请求, 客户端的请求是并行提交给数据节点.</div><div>而MonetDB multiplex-funnel则是并行的接收客户端请求, 但是请求最终是一个一个提交给后端的所有数据节点的.&nbsp;</div><div>返回结果的话则是所有数据节点并行执行的结果返回, 如有4个后端monetdbd, 那么count(*)返回4条记录.</div><div>另外需要注意的是m-funnel还限制了单条SQL返回的结果集的大小, 默认是80K.</div><div>注意使用m-funnel会打乱事务特性, 例如一个客户端的事务请求, 事务的中间可能被其他客户端的SQL插入.</div><div><div><img title="MonetDB multiplex-funnel - 德哥@Digoal - PostgreSQL research"   alt="MonetDB multiplex-funnel - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img0.ph.126.net/aoZbQkX11xF4YXTXVUBd6Q==/6619223826444168066.png"   ></div><br></div><div>MonetDB的multiplex-funnel举例 :&nbsp;</div><div>使用monetdb创建m-funnel数据库</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;-m pattern</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; With the -m flag, instead of creating a database, a multiplex-funnel is created. &nbsp;See section MULTIPLEX-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FUNNEL in monetdbd(1). &nbsp;The pattern argument is not fully the same as a pattern for connecting &nbsp;or &nbsp;dis-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; covery. &nbsp; Each &nbsp;parallel target for the multiplex-funnel is given as username+password@pattern sequence,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; separated by commas. &nbsp;Here the pattern is an ordinary pattern as would &nbsp;be &nbsp;used &nbsp;for &nbsp;connecting &nbsp;to &nbsp;a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; database, and can hence also be just the name of a database.</font></div><p></p></pre></div><div>注意pattern的格式,&nbsp;<span style="line-height: 28px;"   >&nbsp;</span><span style="line-height: 28px;"   >username+password@pattern, 这里的pattern是数据库, 所以数据库需要在同一个广播域. 并且配置好tag(假设有重名的情况下)</span></div><div><div><img title="MonetDB multiplex-funnel - 德哥@Digoal - PostgreSQL research"   alt="MonetDB multiplex-funnel - 德哥@Digoal - PostgreSQL research"   style="margin:0 10px 0 0;"   src="http://img2.ph.126.net/WKdpnyR6ieg1NFAgxWbb6w==/6608456309073720503.png"   ></div>这里dbx是边界, 主机属于两个广播域, 所以forward必须=proxy, 因为从db0的主机无法直接连接dbx1和dbx2. 必须通过dbx所在的monetdbd进行代理.</div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >使用举例 :&nbsp;</span></div><div><span style="line-height: 28px;"   >配置hostname</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >150.sky-mobi.com</font></div><div><font size="2"   >db-172-16-3-221</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >配置/etc/sysconfig/network</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >HOSTNAME=db-172-16-3-221</font></div><div></div><p></p></pre></div><div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >在所有monetdb节点配置DNS或/etc/hosts, 使解析正常.</span></div></div><div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >本例配置/etc/hosts</span></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >172.16.3.221 db-172-16-3-221</font></div><div style="line-height: 28px;"   ><font size="2"   >172.16.3.150 150.sky-mobi.com</font></div><p></p></pre></div></div></div><div><br></div><div><span style="line-height: 28px;"   >配置防火墙, 让monetdbd之间可以相互通讯</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >iptables -t filter -I INPUT -s 172.16.0.0/16 -j ACCEPT</font></div><div></div><p></p></pre></div><div><span style="line-height: 28px;"   >创建monetdbd storage</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 28px;"   ><font size="2"   >monetdbd create /data01/mdb1</font></span></div><div></div><p></p></pre></div><div><span style="line-height: 28px;"   >配置discovery</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 28px;"   >monetdbd set&nbsp;</span><span style="line-height: 28px;"   >discovery</span><span style="line-height: 28px;"   >=yes /data01/mdb1</span></font></div><div></div><p></p></pre></div><div><span style="line-height: 28px;"   >可选, 配置forward = proxy (如果这是个边界m-funnel库的话, 默认就是proxy)</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 28px;"   ><font size="2"   >monetdbd set forward=proxy /data01/mdb1</font></span></div><div></div><p></p></pre></div><div><span style="line-height: 28px;"   >启动monetdbd</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 28px;"   ><font size="2"   >monetdbd start /data01/mdb1</font></span></div><div></div><p></p></pre></div><div>创建数据库, 解锁数据库</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@150 postgresql-9.3.5]# monetdb create db1</font></div><div><font size="2"   >created database in maintenance mode: db1</font></div><div><font size="2"   >[root@150 postgresql-9.3.5]# monetdb create db2</font></div><div><font size="2"   >created database in maintenance mode: db2</font></div><div><font size="2"   >[root@150 postgresql-9.3.5]# monetdb release db1</font></div><div><font size="2"   >taken database out of maintenance mode: db1</font></div><div><font size="2"   >[root@150 postgresql-9.3.5]# monetdb release db2</font></div><div><font size="2"   >taken database out of maintenance mode: db2</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-221 ~]# monetdb create dbx1</font></div><div><font size="2"   >created database in maintenance mode: dbx1</font></div><div><span style="line-height: 28px;"   ><font size="2"   >[root@db-172-16-3-221 ~]# monetdb create dbx2</font></span></div><div><font size="2"   >created database in maintenance mode: dbx2</font></div><div><font size="2"   >[root@db-172-16-3-221 ~]# monetdb release dbx1</font></div><div><font size="2"   >taken database out of maintenance mode: dbx1</font></div><div><font size="2"   >[root@db-172-16-3-221 ~]# monetdb release dbx2</font></div><div><font size="2"   >taken database out of maintenance mode: dbx2</font></div></div><p></p></pre></div><div><br></div><div>配置shared, tag(可选, 仅仅当数据库在广播域有重名是需要使用)</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@150 postgresql-9.3.5]# monetdb set shared=150 db1</font></div><div><font size="2"   >[root@150 postgresql-9.3.5]# monetdb set shared=150 db2</font></div></div><div><div><font size="2"   >[root@db-172-16-3-221 ~]# monetdb set shared=221 dbx1</font></div><div><font size="2"   >[root@db-172-16-3-221 ~]# monetdb set shared=221 dbx2</font></div></div><p></p></pre></div><div><br></div><div>发现</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-221 ~]# monetdb discover</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; location</font></div><div><font size="2"   >mapi:monetdb://150.sky-mobi.com:50000/db1/150</font></div><div><font size="2"   >mapi:monetdb://150.sky-mobi.com:50000/db2/150</font></div><div><span style="line-height: 28px;"   ><font size="2"   >mapi:monetdb://db-172-16-3-221:50000/dbx1/221</font></span></div><div><font size="2"   >mapi:monetdb://db-172-16-3-221:50000/dbx2/221</font></div><div><font size="2"   ><br></font></div></div><div><div><font size="2"   >[root@150 mdb1]# monetdb discover</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; location</font></div><div><font size="2"   >mapi:monetdb://150.sky-mobi.com:50000/db1/150</font></div><div><font size="2"   >mapi:monetdb://150.sky-mobi.com:50000/db2/150</font></div><div><font size="2"   >mapi:monetdb://db-172-16-3-221:50000/dbx1/221</font></div><div><font size="2"   >mapi:monetdb://db-172-16-3-221:50000/dbx2/221</font></div></div><p></p></pre></div><div><div><br></div></div><div>创建第一个m-funnel, 这里假设dbx这个m-funnel是边界funnel.</div><div>首先测试一下库名是否正常.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-221 ~]# mclient -h 127.0.0.1 dbx1/221</font></div><div><font size="2"   >Welcome to mclient, the MonetDB/SQL interactive terminal (Jan2014-SP3)</font></div><div><font size="2"   >Database: MonetDB v11.17.21 (Jan2014-SP3), 'mapi:monetdb://db-172-16-3-221:50000/dbx1'</font></div><div><font size="2"   >Type \q to quit, \? for a list of available commands</font></div><div><font size="2"   >auto commit mode: on</font></div><div><font size="2"   >sql&gt;\q</font></div><div><font size="2"   >[root@db-172-16-3-221 ~]# mclient -h 127.0.0.1 dbx2/221</font></div><div><font size="2"   >Welcome to mclient, the MonetDB/SQL interactive terminal (Jan2014-SP3)</font></div><div><font size="2"   >Database: MonetDB v11.17.21 (Jan2014-SP3), 'mapi:monetdb://db-172-16-3-221:50000/dbx2'</font></div><div><font size="2"   >Type \q to quit, \? for a list of available commands</font></div><div><font size="2"   >auto commit mode: on</font></div><p></p></pre></div><div>使用这两个库名创建m-funnel, 注意用户密码我没改, 用默认的</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-221 ~]# monetdb create -m monetdb+monetdb@dbx1/221,monetdb+monetdb@dbx2/221 dbx</font></div><div><font size="2"   >created multiplex-funnel in maintenance mode: dbx</font></div><div><font size="2"   >[root@db-172-16-3-221 ~]# monetdb release dbx</font></div><div><font size="2"   >taken database out of maintenance mode: dbx</font></div><p></p></pre></div><div>查看状态</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-221 ~]# monetdb get all dbx</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;prop &nbsp; &nbsp; source &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value</font></div><div><font size="2"   >dbx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp; &nbsp;dbx</font></div><div><font size="2"   >dbx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;type &nbsp; &nbsp; &nbsp;local &nbsp; &nbsp;mfunnel</font></div><div><font size="2"   >dbx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shared &nbsp; &nbsp;default &nbsp;yes</font></div><div><font size="2"   >dbx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mfunnel &nbsp; local &nbsp; &nbsp;monetdb+monetdb@dbx1/221,monetdb+monetdb@dbx2/221</font></div><p></p></pre></div><div>测试第一个m-funnel是否正常, 可以正常的像两个底层数据库发出SQL.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-221 ~]# mclient -h 127.0.0.1 dbx</font></div><div><font size="2"   >Welcome to mclient, the MonetDB/SQL interactive terminal (Jan2014-SP3)</font></div><div><font size="2"   >Database: MonetDB v11.17.21 (Jan2014-SP3), 'mapi:monetdb://db-172-16-3-221:50000/dbx2'</font></div><div><font size="2"   >Type \q to quit, \? for a list of available commands</font></div><div><font size="2"   >auto commit mode: on</font></div><div><font size="2"   >sql&gt;create table abc(id int);</font></div><div><font size="2"   >operation successful (22.611ms)</font></div><div><font size="2"   >sql&gt;insert into abc values(1);</font></div><div><font size="2"   >2 affected row (7.259ms)</font></div><div><font size="2"   >sql&gt;select * from abc;</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >| id &nbsp; |</font></div><div><font size="2"   >+======+</font></div><div><font size="2"   >| &nbsp; &nbsp;1 |</font></div><div><font size="2"   >| &nbsp; &nbsp;1 |</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >2 tuples (1.854ms)</font></div></div><div><div><font size="2"   >sql&gt;insert into abc values(2);</font></div><div><font size="2"   >2 affected row (5.553ms)</font></div><div><font size="2"   >sql&gt;select * from abc;</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >| id &nbsp; |</font></div><div><font size="2"   >+======+</font></div><div><font size="2"   >| &nbsp; &nbsp;1 |</font></div><div><font size="2"   >| &nbsp; &nbsp;2 |</font></div><div><font size="2"   >| &nbsp; &nbsp;1 |</font></div><div><font size="2"   >| &nbsp; &nbsp;2 |</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >4 tuples (1.014ms)</font></div></div><p></p></pre></div><div>已经正常了, 插入和查询都从两个节点正常返回并合并结果.</div><div>配置第一个m-funnel的tag(可选, 仅仅当广播域中这个m-funnel的名字有重名才需要)</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-221 ~]# monetdb set shared=221 dbx</font></div><div><font size="2"   >[root@db-172-16-3-221 ~]# monetdb get all dbx</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;prop &nbsp; &nbsp; source &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value</font></div><div><font size="2"   >dbx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp; &nbsp;dbx</font></div><div><font size="2"   >dbx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;type &nbsp; &nbsp; &nbsp;local &nbsp; &nbsp;mfunnel</font></div><div><font size="2"   >dbx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shared &nbsp; &nbsp;local &nbsp; &nbsp;221</font></div><div><font size="2"   >dbx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mfunnel &nbsp; local &nbsp; &nbsp;monetdb+monetdb@dbx1/221,monetdb+monetdb@dbx2/221</font></div><p></p></pre></div><div><br></div><div>创建第二个m-funnel :&nbsp;</div><div>先执行discover得到URI, 从而得知database name.(含shared设置的tag)</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@150 postgresql-9.3.5]# monetdb discover</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; location</font></div><div><font size="2"   >mapi:monetdb://150.sky-mobi.com:50000/db1/150</font></div><div><font size="2"   >mapi:monetdb://150.sky-mobi.com:50000/db2/150</font></div><div><font size="2"   >mapi:monetdb://db-172-16-3-221:50000/dbx/221</font></div><div><font size="2"   >mapi:monetdb://db-172-16-3-221:50000/dbx1/221</font></div><div><font size="2"   >mapi:monetdb://db-172-16-3-221:50000/dbx2/221</font></div><p></p></pre></div><div>创建m-funnel,&nbsp;<span style="line-height: 28px;"   >注意用户密码我没改, 用默认的</span></div></div><div><span style="line-height: 28px;"   >这个m-funnel包含3个库, 其中2个是normal 库, 另一个是前面创建的funnel, 所以实际上就是4个normal库, 但是funnel里看到的是3个库.&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@150 postgresql-9.3.5]# monetdb create -m monetdb+monetdb@db1/150,monetdb+monetdb@db2/150,monetdb+monetdb@dbx/221 db0</font></div><div><font size="2"   >created multiplex-funnel in maintenance mode: db0</font></div><div><font size="2"   >[root@150 postgresql-9.3.5]# monetdb release db0</font></div><div><font size="2"   >taken database out of maintenance mode: db0</font></div><p></p></pre></div><div>查看m-funnel的状态</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@150 postgresql-9.3.5]# monetdb get all db0</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;prop &nbsp; &nbsp; source &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value</font></div><div><font size="2"   >db0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp; &nbsp;db0</font></div><div><font size="2"   >db0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;type &nbsp; &nbsp; &nbsp;local &nbsp; &nbsp;mfunnel</font></div><div><font size="2"   >db0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shared &nbsp; &nbsp;default &nbsp;yes</font></div><div><font size="2"   >db0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mfunnel &nbsp; local &nbsp; &nbsp;monetdb+monetdb@db1/150,monetdb+monetdb@db2/150,monetdb+monetdb@dbx/221</font></div><p></p></pre></div><div>测试 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@150 postgresql-9.3.5]# mclient db0</font></div><div><font size="2"   >Welcome to mclient, the MonetDB/SQL interactive terminal (Jan2014-SP3)</font></div><div><font size="2"   >Database: MonetDB v11.17.21 (Jan2014-SP3), 'mapi:monetdb://db-172-16-3-221:50000/dbx2'</font></div><div><font size="2"   >Type \q to quit, \? for a list of available commands</font></div><div><font size="2"   >auto commit mode: on</font></div><div><font size="2"   >sql&gt;create table abc(id int); &nbsp;-- 前面测试的时候创建了abc表, 所以这里创建会报错.</font></div><div><font size="2"   >node dbx/221 failed: node dbx1/221 failed: 42S01!CREATE TABLE: name 'abc' already in use</font></div><p></p></pre></div><div>-- 特别注意, 虽然报错了, 但是实际上只是2个节点报错, 其他2个节点创建成功了.</div><div>-- 这个测试用了auto commit, 所以导致部分提交成功, 部分提交失败了.</div><div>-- 要全局一致的话, 需要用start transaction</div><div>-- 但是用start transaction的话, 会扰乱, 因为并行的事情. 后面有测试</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;select * from abc;</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >| id &nbsp; |</font></div><div><font size="2"   >+======+</font></div><div><font size="2"   >| &nbsp; &nbsp;1 |</font></div><div><font size="2"   >| &nbsp; &nbsp;2 |</font></div><div><font size="2"   >| &nbsp; &nbsp;1 |</font></div><div><font size="2"   >| &nbsp; &nbsp;2 |</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >4 tuples (1.607ms)</font></div><div><font size="2"   >sql&gt;insert into abc values (3); &nbsp;-- 从这个插入我们就能知道, 上面建表的语句在2个节点执行成果了.</font></div><div><font size="2"   >4 affected row (5.192ms)</font></div><div><font size="2"   >sql&gt;select * from abc;</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >| id &nbsp; |</font></div><div><font size="2"   >+======+</font></div><div><font size="2"   >| &nbsp; &nbsp;3 |</font></div><div><font size="2"   >| &nbsp; &nbsp;3 |</font></div><div><font size="2"   >| &nbsp; &nbsp;1 |</font></div><div><font size="2"   >| &nbsp; &nbsp;2 |</font></div><div><font size="2"   >| &nbsp; &nbsp;3 |</font></div><div><font size="2"   >| &nbsp; &nbsp;1 |</font></div><div><font size="2"   >| &nbsp; &nbsp;2 |</font></div><div><font size="2"   >| &nbsp; &nbsp;3 |</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >8 tuples (1.459ms)</font></div><p></p></pre></div></div><div><br></div><div>假设我们用了事务会怎么样呢?</div><div>可能出现部分提交失败, 部分提交成功或者全部提交成功的情况, 回滚的话则全部节点回滚.</div><div>所以鉴于此, 如果报错了, 就立刻回滚, 那么是全部回滚的.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;create table abc(id int);</font></div><div><font size="2"   >node dbx/221 failed: node dbx1/221 failed: 42S01!CREATE TABLE: name 'abc' already in use</font></div><div><font size="2"   >sql&gt;select * from abc;</font></div><div><font size="2"   >node dbx/221 failed: node dbx1/221 failed: 25005!current transaction is aborted (please ROLLBACK)</font></div><div><font size="2"   >sql&gt;commit; &nbsp;-- 此时commit, 部分节点提交成功, 部分节点提交失败.</font></div><div><font size="2"   >node dbx/221 failed: node dbx1/221 failed: 2D000!COMMIT: failed</font></div><div><font size="2"   >sql&gt;rollback; &nbsp;-- 事务已经结束了, 所以不能再回滚.</font></div><div><font size="2"   >node db1/150 failed: 2DM30!ROLLBACK: not allowed in auto commit mode</font></div><div><font size="2"   >sql&gt;select * from abc;</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >| id &nbsp; |</font></div><div><font size="2"   >+======+</font></div><div><font size="2"   >| &nbsp; &nbsp;1 |</font></div><div><font size="2"   >| &nbsp; &nbsp;2 |</font></div><div><font size="2"   >| &nbsp; &nbsp;1 |</font></div><div><font size="2"   >| &nbsp; &nbsp;2 |</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >4 tuples (1.676ms)</font></div><div><font size="2"   >sql&gt;insert into abc values (3); &nbsp;-- 因为部分提交成功, 所以DB1和DB2创建abc表完成.</font></div><div><font size="2"   >4 affected row (5.538ms)</font></div><div><font size="2"   >sql&gt;select * from abc;</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >| id &nbsp; |</font></div><div><font size="2"   >+======+</font></div><div><font size="2"   >| &nbsp; &nbsp;3 |</font></div><div><font size="2"   >| &nbsp; &nbsp;3 |</font></div><div><font size="2"   >| &nbsp; &nbsp;1 |</font></div><div><font size="2"   >| &nbsp; &nbsp;2 |</font></div><div><font size="2"   >| &nbsp; &nbsp;3 |</font></div><div><font size="2"   >| &nbsp; &nbsp;1 |</font></div><div><font size="2"   >| &nbsp; &nbsp;2 |</font></div><div><font size="2"   >| &nbsp; &nbsp;3 |</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >8 tuples (1.395ms)</font></div><p></p></pre></div><div><br></div><div>全部回滚的测试 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;create table abc(id int);</font></div><div><font size="2"   >node dbx/221 failed: node dbx1/221 failed: 42S01!CREATE TABLE: name 'abc' already in use</font></div><div><font size="2"   >sql&gt;rollback;</font></div><div><font size="2"   >auto commit mode: on</font></div><div><font size="2"   >sql&gt;\dt</font></div><div><font size="2"   >TABLE &nbsp;sys.abc</font></div><div><font size="2"   >TABLE &nbsp;sys.abc</font></div><p></p></pre></div><div>部分提交成功和失败的测试 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;create table abc(id int);</font></div><div><font size="2"   >node dbx/221 failed: node dbx1/221 failed: 42S01!CREATE TABLE: name 'abc' already in use</font></div><div><font size="2"   >sql&gt;\dt</font></div><div><font size="2"   >TABLE &nbsp;sys.abc</font></div><div><font size="2"   >TABLE &nbsp;sys.abc</font></div><div><font size="2"   >TABLE &nbsp;sys.abc</font></div><div><font size="2"   >TABLE &nbsp;sys.abc</font></div><p></p></pre></div><div>全部提交成功的测试 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >sql&gt;insert into abc values (10);</font></div><div><font size="2"   >4 affected row (5.611ms)</font></div><div><font size="2"   >sql&gt;select * from abc where id=10;</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >| id &nbsp; |</font></div><div><font size="2"   >+======+</font></div><div><font size="2"   >| &nbsp; 10 |</font></div><div><font size="2"   >| &nbsp; 10 |</font></div><div><font size="2"   >| &nbsp; 10 |</font></div><div><font size="2"   >| &nbsp; 10 |</font></div><div><font size="2"   >+------+</font></div><div><font size="2"   >4 tuples (1.906ms)</font></div><p></p></pre></div><div>如果需要全局事务一致的话, 必须使用start trasaction;</div><div><br></div><div>使用start transaction带来的困扰, 原因就是漏斗效应, 因为并行转换成了串行来执行, 所以中间会被其他SQL插入, 测试如下.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >会话A</font></div><div><div><font size="2"   >sql&gt;start transaction;</font></div><div><font size="2"   >auto commit mode: off</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >会话B</font></div><div><div><font size="2"   >sql&gt;start transaction; &nbsp;-- 因为在m-funnel 中已经启动了事务, 所以再次启动失败</font></div><div><font size="2"   >node db1/150 failed: 25001!START TRANSACTION: cannot start a transaction within a transaction</font></div></div><div><div><font size="2"   >sql&gt;select * from abc;</font></div><div><font size="2"   >node db1/150 failed: 25005!current transaction is aborted (please ROLLBACK)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >会话A</font></div><div><div><font size="2"   >sql&gt;select * from abc; &nbsp;-- 回退</font></div><div><font size="2"   >node db1/150 failed: 25005!current transaction is aborted (please ROLLBACK)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >-- 任何一个会话执行了rollback都可以, 就结束这个事务了.</font></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1. man monetdbd</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >MULTIPLEX-FUNNELS</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Monetdbd &nbsp;implements multiplex-funnel capabilities. &nbsp;As the name suggests two techniques are combined, the mul-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;tiplexer and the funnel.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;The funnel capability limits the access to the database to one client at a time. &nbsp;That is, if multiple &nbsp;clients</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;connect &nbsp;to &nbsp;the &nbsp;funnel, their queries will be serialized such that they are executed one after the other. &nbsp;An</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;effect of this approach is that clients no longer have an exclusive channel to the database, which &nbsp;means &nbsp;that</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;individual queries from one client may have been interleaved with queries from others. &nbsp;This most notably makes</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;SQL transaction blocks unreliable with a funnel. &nbsp;The funnel, hence, is meant to scale down a large &nbsp;amount &nbsp;of</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;clients that perform short-running (read-only) queries, as typically seen in web-based query loads.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;When a funnel is defined to use multiple databases, the funnel adds a multiplexer to its query channel. &nbsp;A mul-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;tiplex-funnel sends each query to all of the defined databases. &nbsp;This behavior can be quite confusing at first,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;but &nbsp;proves &nbsp;to be useful in typical sharding configurations, where in particular simple selection queries have</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;to be performed on each of the shards. &nbsp;The multiplexer combines the answers from all defined databases in &nbsp;one</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;single &nbsp;answer &nbsp;that it sends back to the client. &nbsp;However, this combining is without any smart logic, that is,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;the multiplexer does not evaluate the query it is running, but just combines all answers it receives &nbsp;from &nbsp;the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;databases. &nbsp; This &nbsp;results &nbsp;in &nbsp;e.g. &nbsp;as many return tuples for a SELECT COUNT(*) query, as there are databases</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;defined.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;Due to the two above mentioned characteristics, a multiplex-funnel has some limitations. &nbsp;As mentioned &nbsp;before,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;transactions over multiple queries are likely not to result in the desired behavior. &nbsp;This is due to each query</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;to the funnel is required to be self-contained. &nbsp;Further, since for &nbsp;each &nbsp;query, &nbsp;the &nbsp;results &nbsp;from &nbsp;multiple</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;servers &nbsp;have &nbsp;to &nbsp;be &nbsp;combined &nbsp;into one, that query must only return a single response, i.e. &nbsp;multi-statement</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;queries are most likely causing the funnel to respond with an error, or return garbled results. &nbsp;Last, the size</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;of &nbsp;each query is limited to currently about 80K. &nbsp;While this size should be sufficient for most queries, it is</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;likely not enough for e.g. COPY INTO statements. &nbsp;Apart from the data transfer &nbsp;implications, &nbsp;such &nbsp;statements</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;should not be used with the funnel, as the results will be undefined due to the limited query buffer. &nbsp;Applica-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;tions using the funnel should aim for short and single-statement queries that require no transactions.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;See the create command in the monetdb(1) man-page for details on how to setup a multiplex-funnel.</font></div><p></p></pre></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="MonetDB multiplex-funnel - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>