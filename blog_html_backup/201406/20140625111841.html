<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">ZIL (ZFS intent log) zil.c</h2>
	<h5 id="">2014-06-25 11:18:41&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402014525111238683/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>ZIL或称SLOG, 被用于提升ZFS系统的离散fsync性能.</div><div>类似数据库的redo log或wal.</div><div>注意</div><div>1. 每个dataset对应一个zil, 也就是说一个zpool有多个zfs的话, 如果有log设备, 那么在log设备中实际上包含了多个ZIL entry.</div><div>数据写入ZIL后(fsync), 即使服务器异常, 也可以用于恢复文件系统.</div><div>2. 并不是每一笔FSYNC都会用到ZIL, 只有小于2*<span style="line-height: 28px;"   >zil_slog_limit</span><span style="line-height: 28px;"   >&nbsp;的commit操作才会用到. 如果你的zil 块设备够强的话, 可以调大伙调到UINT64_MAX, &nbsp;那么就不检测了, 所有的commit都用上zil设备. 一般不需要调整</span></div><div><br></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* The zfs intent log (ZIL) saves transaction records of system calls</font></div><div><font size="2"   >&nbsp;* that change the file system in memory with enough information</font></div><div><font size="2"   >&nbsp;* to be able to replay them. These are stored in memory until</font></div><div><font size="2"   >&nbsp;* either the DMU transaction group (txg) commits them to the stable pool</font></div><div><font size="2"   >&nbsp;* and they can be discarded, or they are flushed to the stable log</font></div><div><font size="2"   >&nbsp;* (also in the pool) due to a fsync, O_DSYNC or other synchronous</font></div><div><font size="2"   >&nbsp;* requirement. In the event of a panic or power fail then those log</font></div><div><font size="2"   >&nbsp;* records (transactions) are replayed.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* There is one ZIL per file system. Its on-disk (pool) format consists</font></div><div><font size="2"   >&nbsp;* of 3 parts:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;- ZIL header</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;- ZIL blocks</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;- ZIL records</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* A log record holds a system call transaction. Log blocks can</font></div><div><font size="2"   >&nbsp;* hold many log records and the blocks are chained together.</font></div><div><font size="2"   >&nbsp;* Each ZIL block contains a block pointer (blkptr_t) to the next</font></div><div><font size="2"   >&nbsp;* ZIL block in the chain. The ZIL header points to the first</font></div><div><font size="2"   >&nbsp;* block in the chain. Note there is not a fixed place in the pool</font></div><div><font size="2"   >&nbsp;* to hold blocks. They are dynamically allocated and freed as</font></div><div><font size="2"   >&nbsp;* needed from the blocks available. Figure X shows the ZIL structure:</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >可调参数,&nbsp;</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* This global ZIL switch affects all pools</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >int zil_replay_disable = 0; &nbsp; &nbsp;/* disable intent logging replay */</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Tunable parameter for debugging or performance analysis. &nbsp;Setting</font></div><div><font size="2"   >&nbsp;* zfs_nocacheflush will cause corruption on power loss if a volatile</font></div><div><font size="2"   >&nbsp;* out-of-order write cache is enabled.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >int zfs_nocacheflush = 0;</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Define a limited set of intent log block sizes.</font></div><div><font size="2"   >&nbsp;* These must be a multiple of 4KB. Note only the amount used (again</font></div><div><font size="2"   >&nbsp;* aligned to 4KB) actually gets written. However, we can't always just</font></div><div><font size="2"   >&nbsp;* allocate SPA_MAXBLOCKSIZE as the slog space could be exhausted.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >uint64_t zil_block_buckets[] = {</font></div><div><font size="2"   >&nbsp; &nbsp; 4096, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* non TX_WRITE */</font></div><div><font size="2"   >&nbsp; &nbsp; 8192+4096, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* data base */</font></div><div><font size="2"   >&nbsp; &nbsp; 32*1024 + 4096, &nbsp; &nbsp; /* NFS writes */</font></div><div><font size="2"   >&nbsp; &nbsp; UINT64_MAX</font></div><div><font size="2"   >};</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Use the slog as long as the current commit size is less than the</font></div><div><font size="2"   >&nbsp;* limit or the total list size is less than 2X the limit. &nbsp;Limit</font></div><div><font size="2"   >&nbsp;* checking is disabled by setting zil_slog_limit to UINT64_MAX.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >unsigned long zil_slog_limit = 1024 * 1024;</font></div><div><font size="2"   >#define USE_SLOG(zilog) (((zilog)-&gt;zl_cur_used &lt; zil_slog_limit) || \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ((zilog)-&gt;zl_itx_list_sz &lt; (zil_slog_limit &lt;&lt; 1)))</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   ><br></font></div><div><font size="2"   >#if defined(_KERNEL) &amp;&amp; defined(HAVE_SPL)</font></div><div><font size="2"   >module_param(zil_replay_disable, int, 0644);</font></div><div><font size="2"   >MODULE_PARM_DESC(zil_replay_disable, "Disable intent logging replay");</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >module_param(zfs_nocacheflush, int, 0644);</font></div><div><font size="2"   >MODULE_PARM_DESC(zfs_nocacheflush, "Disable cache flushes");</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >module_param(zil_slog_limit, ulong, 0644);</font></div><div><font size="2"   >MODULE_PARM_DESC(zil_slog_limit, "Max commit bytes to separate log device");</font></div><div><font size="2"   >#endif</font></div></div><p></p></pre></div><div><br></div><wbr>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="ZIL (ZFS intent log) zil.c - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>