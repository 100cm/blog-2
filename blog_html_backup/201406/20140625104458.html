<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">ZFS ARC & L2ARC zfs-$ver/module/zfs/arc.c</h2>
	<h5 id="">2014-06-25 10:44:58&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402014525103556357/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><span style="line-height: 28px;"   >可调参数, 含义以及默认值见arc.c或/sys/module/zfs/parameter/$parm_name</span></div><div>如果是freebsd或其他原生支持zfs的系统, 调整sysctl.conf.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zfs_arc_min:Min arc size (ulong)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zfs_arc_max:Max arc size (ulong)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zfs_arc_meta_limit:Meta limit for arc size (ulong)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zfs_arc_meta_prune:Bytes of meta data to prune (int)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zfs_arc_grow_retry:Seconds before growing arc size (int)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zfs_arc_shrink_shift:log2(fraction of arc to reclaim) (int)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zfs_arc_p_min_shift:arc_c shift to calc min/max arc_p (int)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zfs_disable_dup_eviction:disable duplicate buffer eviction (int)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zfs_arc_memory_throttle_disable:disable memory throttle (int)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zfs_arc_min_prefetch_lifespan:Min life of prefetch block (int)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l2arc_write_max:Max write bytes per interval (ulong)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l2arc_write_boost:Extra write bytes during device warmup (ulong)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l2arc_headroom:Number of max device writes to precache (ulong)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l2arc_headroom_boost:Compressed l2arc_headroom multiplier (ulong)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l2arc_feed_secs:Seconds between L2ARC writing (ulong)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l2arc_feed_min_ms:Min feed interval in milliseconds (ulong)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l2arc_noprefetch:Skip caching prefetched buffers (int)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l2arc_nocompress:Skip compressing L2ARC buffers (int)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l2arc_feed_again:Turbo L2ARC warmup (int)</font></div><div><font size="2"   >parm: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l2arc_norw:No reads during writes (int)</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 28px;"   >L2ARC几点需要注意,&nbsp;</span></div><div>1. L2ARC的内容是l2arc_feed_thread函数主动间歇性的从ARC读取的. 所以ARC里没有的内容, L2ARC也不可能有.</div><div>2. L2ARC不存储脏数据, 所以也不需要回写到DISK. 鉴于这个因素, L2ARC不适合频繁变更的场景(如oltp中的频繁更新场景)</div><div>3. 如果L2ARC中缓存的数据块在ARC变成脏数据了, 这部分数据会直接从L2ARC丢弃.</div><div>4. L2ARC的优化参数(配置到/etc/modprobe.d/zfs.conf或动态变更/sys/module/zfs/parameters/$PARM_NAME)</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_write_max &nbsp; &nbsp; &nbsp; &nbsp; max write bytes per interval, 一次l2arc feed的最大量.</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_write_boost &nbsp; &nbsp; &nbsp; extra write bytes during device warmup</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_noprefetch &nbsp; &nbsp; &nbsp; &nbsp;skip caching prefetched buffers</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_nocompress &nbsp; &nbsp; &nbsp; &nbsp;skip compressing buffers</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_headroom &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number of max device writes to precache</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_headroom_boost &nbsp; &nbsp;when we find compressed buffers during ARC</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanning, we multiply headroom by this</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;percentage factor for the next scan cycle,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;since more compressed buffers are likely to</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;be present</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_feed_secs &nbsp; &nbsp; &nbsp; &nbsp; seconds between L2ARC writing, 如果要加快从arc导入l2arc的速度, 可缩短interval</font></div><p></p></pre></div><div><br></div><div>参见</div><div>zfs-0.6.2/module/zfs/arc.c</div><div><br></div>ARC<wbr><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* DVA-based Adjustable Replacement Cache</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* While much of the theory of operation used here is</font></div><div><font size="2"   >&nbsp;* based on the self-tuning, low overhead replacement cache</font></div><div><font size="2"   >&nbsp;* presented by Megiddo and Modha at FAST 2003, there are some</font></div><div><font size="2"   >&nbsp;* significant differences:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 1. The Megiddo and Modha model assumes any page is evictable.</font></div><div><font size="2"   >&nbsp;* Pages in its cache cannot be "locked" into memory. &nbsp;This makes</font></div><div><font size="2"   >&nbsp;* the eviction algorithm simple: evict the last page in the list.</font></div><div><font size="2"   >&nbsp;* This also make the performance characteristics easy to reason</font></div><div><font size="2"   >&nbsp;* about. &nbsp;Our cache is not so simple. &nbsp;At any given moment, some</font></div><div><font size="2"   >&nbsp;* subset of the blocks in the cache are un-evictable because we</font></div><div><font size="2"   >&nbsp;* have handed out a reference to them. &nbsp;Blocks are only evictable</font></div><div><font size="2"   >&nbsp;* when there are no external references active. &nbsp;This makes</font></div><div><font size="2"   >&nbsp;* eviction far more problematic: &nbsp;we choose to evict the evictable</font></div><div><font size="2"   >&nbsp;* blocks that are the "lowest" in the list.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* There are times when it is not possible to evict the requested</font></div><div><font size="2"   >&nbsp;* space. &nbsp;In these circumstances we are unable to adjust the cache</font></div><div><font size="2"   >&nbsp;* size. &nbsp;To prevent the cache growing unbounded at these times we</font></div><div><font size="2"   >&nbsp;* implement a "cache throttle" that slows the flow of new data</font></div><div><font size="2"   >&nbsp;* into the cache until we can make space available.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 2. The Megiddo and Modha model assumes a fixed cache size.</font></div><div><font size="2"   >&nbsp;* Pages are evicted when the cache is full and there is a cache</font></div><div><font size="2"   >&nbsp;* miss. &nbsp;Our model has a variable sized cache. &nbsp;It grows with</font></div><div><font size="2"   >&nbsp;* high use, but also tries to react to memory pressure from the</font></div><div><font size="2"   >&nbsp;* operating system: decreasing its size when system memory is</font></div><div><font size="2"   >&nbsp;* tight.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 3. The Megiddo and Modha model assumes a fixed page size. All</font></div><div><font size="2"   >&nbsp;* elements of the cache are therefor exactly the same size. &nbsp;So</font></div><div><font size="2"   >&nbsp;* when adjusting the cache size following a cache miss, its simply</font></div><div><font size="2"   >&nbsp;* a matter of choosing a single page to evict. &nbsp;In our model, we</font></div><div><font size="2"   >&nbsp;* have variable sized cache blocks (rangeing from 512 bytes to</font></div><div><font size="2"   >&nbsp;* 128K bytes). &nbsp;We therefor choose a set of blocks to evict to make</font></div></div><div><div><font size="2"   >&nbsp;* space for a cache miss that approximates as closely as possible</font></div><div><font size="2"   >&nbsp;* the space used by the new block.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* See also: &nbsp;"ARC: A Self-Tuning, Low Overhead Replacement Cache"</font></div><div><font size="2"   >&nbsp;* by N. Megiddo &amp; D. Modha, FAST 2003</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* The locking model:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* A new reference to a cache buffer can be obtained in two</font></div><div><font size="2"   >&nbsp;* ways: 1) via a hash table lookup using the DVA as a key,</font></div><div><font size="2"   >&nbsp;* or 2) via one of the ARC lists. &nbsp;The arc_read() interface</font></div><div><font size="2"   >&nbsp;* uses method 1, while the internal arc algorithms for</font></div><div><font size="2"   >&nbsp;* adjusting the cache use method 2. &nbsp;We therefor provide two</font></div><div><font size="2"   >&nbsp;* types of locks: 1) the hash table lock array, and 2) the</font></div><div><font size="2"   >&nbsp;* arc list locks.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Buffers do not have their own mutexes, rather they rely on the</font></div><div><font size="2"   >&nbsp;* hash table mutexes for the bulk of their protection (i.e. most</font></div><div><font size="2"   >&nbsp;* fields in the arc_buf_hdr_t are protected by these mutexes).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* buf_hash_find() returns the appropriate mutex (held) when it</font></div><div><font size="2"   >&nbsp;* locates the requested buffer in the hash table. &nbsp;It returns</font></div><div><font size="2"   >&nbsp;* NULL for the mutex if the buffer was not in the table.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* buf_hash_remove() expects the appropriate hash mutex to be</font></div><div><font size="2"   >&nbsp;* already held before it is invoked.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Each arc state also has a mutex which is used to protect the</font></div><div><font size="2"   >&nbsp;* buffer list associated with the state. &nbsp;When attempting to</font></div><div><font size="2"   >&nbsp;* obtain a hash table lock while holding an arc list lock you</font></div><div><font size="2"   >&nbsp;* must use: mutex_tryenter() to avoid deadlock. &nbsp;Also note that</font></div><div><font size="2"   >&nbsp;* the active state mutex must be held before the ghost state mutex.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Arc buffers may have an associated eviction callback function.</font></div><div><font size="2"   >&nbsp;* This function will be invoked prior to removing the buffer (e.g.</font></div><div><font size="2"   >&nbsp;* in arc_do_user_evicts()). &nbsp;Note however that the data associated</font></div></div><div><div><font size="2"   >&nbsp;* with the buffer may be evicted prior to the callback. &nbsp;The callback</font></div><div><font size="2"   >&nbsp;* must be made with *no locks held* (to prevent deadlock). &nbsp;Additionally,</font></div><div><font size="2"   >&nbsp;* the users of callbacks must ensure that their private data is</font></div><div><font size="2"   >&nbsp;* protected from simultaneous callbacks from arc_buf_evict()</font></div><div><font size="2"   >&nbsp;* and arc_do_user_evicts().</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* It as also possible to register a callback which is run when the</font></div><div><font size="2"   >&nbsp;* arc_meta_limit is reached and no buffers can be safely evicted. &nbsp;In</font></div><div><font size="2"   >&nbsp;* this case the arc user should drop a reference on some arc buffers so</font></div><div><font size="2"   >&nbsp;* they can be reclaimed and the arc_meta_limit honored. &nbsp;For example,</font></div><div><font size="2"   >&nbsp;* when using the ZPL each dentry holds a references on a znode. &nbsp;These</font></div><div><font size="2"   >&nbsp;* dentries must be pruned before the arc buffer holding the znode can</font></div><div><font size="2"   >&nbsp;* be safely evicted.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note that the majority of the performance stats are manipulated</font></div><div><font size="2"   >&nbsp;* with atomic operations.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The L2ARC uses the l2arc_buflist_mtx global mutex for the following:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;- L2ARC buflist creation</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;- L2ARC buflist eviction</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;- L2ARC write completion, which walks L2ARC buflists</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;- ARC header destruction, as it removes from L2ARC buflists</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;- ARC header release, as it removes from L2ARC buflists</font></div><div><font size="2"   >&nbsp;*/</font></div></div><p></p></pre></div><div><br></div><div>L2ARC</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Level 2 ARC</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The level 2 ARC (L2ARC) is a cache layer in-between main memory and disk.</font></div><div><font size="2"   >&nbsp;* It uses dedicated storage devices to hold cached data, which are populated</font></div><div><font size="2"   >&nbsp;* using large infrequent writes. &nbsp;The main role of this cache is to boost</font></div><div><font size="2"   >&nbsp;* the performance of random read workloads. &nbsp;The intended L2ARC devices</font></div><div><font size="2"   >&nbsp;* include short-stroked disks, solid state disks, and other media with</font></div><div><font size="2"   >&nbsp;* substantially faster read latency than disk.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +-----------------------+</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; ARC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +-----------------------+</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; ^</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_feed_thread() &nbsp; &nbsp;arc_read()</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp;l2arc read &nbsp; |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;V &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +---------------+ &nbsp; &nbsp;|</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; L2ARC &nbsp; &nbsp; | &nbsp; &nbsp;|</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +---------------+ &nbsp; &nbsp;|</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;l2arc_write() | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +-------+ &nbsp; &nbsp; &nbsp;+-------+</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | vdev &nbsp;| &nbsp; &nbsp; &nbsp;| vdev &nbsp;|</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | cache | &nbsp; &nbsp; &nbsp;| cache |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +-------+ &nbsp; &nbsp; &nbsp;+-------+</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +=========+ &nbsp; &nbsp; .-----.</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : &nbsp;L2ARC &nbsp;: &nbsp; &nbsp;|-_____-|</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : devices : &nbsp; &nbsp;| Disks |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +=========+ &nbsp; &nbsp;`-_____-'</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Read requests are satisfied from the following sources, in order:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;1) ARC</font></div></div><div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;2) vdev cache of L2ARC devices</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;3) L2ARC devices</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;4) vdev cache of disks</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;5) disks</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Some L2ARC device types exhibit extremely slow write performance.</font></div><div><font size="2"   >&nbsp;* To accommodate for this there are some significant differences between</font></div><div><font size="2"   >&nbsp;* the L2ARC and traditional cache design:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 1. There is no eviction path from the ARC to the L2ARC. &nbsp;Evictions from</font></div><div><font size="2"   >&nbsp;* the ARC behave as usual, freeing buffers and placing headers on ghost</font></div><div><font size="2"   >&nbsp;* lists. &nbsp;The ARC does not send buffers to the L2ARC during eviction as</font></div><div><font size="2"   >&nbsp;* this would add inflated write latencies for all ARC memory pressure.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 2. The L2ARC attempts to cache data from the ARC before it is evicted.</font></div><div><font size="2"   >&nbsp;* It does this by periodically scanning buffers from the eviction-end of</font></div><div><font size="2"   >&nbsp;* the MFU and MRU ARC lists, copying them to the L2ARC devices if they are</font></div><div><font size="2"   >&nbsp;* not already there. It scans until a headroom of buffers is satisfied,</font></div><div><font size="2"   >&nbsp;* which itself is a buffer for ARC eviction. If a compressible buffer is</font></div><div><font size="2"   >&nbsp;* found during scanning and selected for writing to an L2ARC device, we</font></div><div><font size="2"   >&nbsp;* temporarily boost scanning headroom during the next scan cycle to make</font></div><div><font size="2"   >&nbsp;* sure we adapt to compression effects (which might significantly reduce</font></div><div><font size="2"   >&nbsp;* the data volume we write to L2ARC). The thread that does this is</font></div><div><font size="2"   >&nbsp;* l2arc_feed_thread(), illustrated below; example sizes are included to</font></div><div><font size="2"   >&nbsp;* provide a better sense of ratio than this diagram:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head --&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tail</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+---------------------+----------+</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;ARC_mfu |:::::#:::::::::::::::|o#o###o###|--&gt;. &nbsp; # already on L2ARC</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+---------------------+----------+ &nbsp; | &nbsp; o L2ARC eligible</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;ARC_mru |:#:::::::::::::::::::|#o#ooo####|--&gt;| &nbsp; : ARC buffer</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+---------------------+----------+ &nbsp; |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 15.9 Gbytes &nbsp; &nbsp; &nbsp;^ 32 Mbytes &nbsp; &nbsp;|</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; headroom &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;l2arc_feed_thread()</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l2arc write hand &lt;--[oooo]--'</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 Mbyte</font></div></div><div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;write max</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; V</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+==============================+</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;L2ARC dev |####|#|###|###| &nbsp; &nbsp;|####| ... |</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+==============================+</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 32 Gbytes</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 3. If an ARC buffer is copied to the L2ARC but then hit instead of</font></div><div><font size="2"   >&nbsp;* evicted, then the L2ARC has cached a buffer much sooner than it probably</font></div><div><font size="2"   >&nbsp;* needed to, potentially wasting L2ARC device bandwidth and storage. &nbsp;It is</font></div><div><font size="2"   >&nbsp;* safe to say that this is an uncommon case, since buffers at the end of</font></div><div><font size="2"   >&nbsp;* the ARC lists have moved there due to inactivity.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 4. If the ARC evicts faster than the L2ARC can maintain a headroom,</font></div><div><font size="2"   >&nbsp;* then the L2ARC simply misses copying some buffers. &nbsp;This serves as a</font></div><div><font size="2"   >&nbsp;* pressure valve to prevent heavy read workloads from both stalling the ARC</font></div><div><font size="2"   >&nbsp;* with waits and clogging the L2ARC with writes. &nbsp;This also helps prevent</font></div><div><font size="2"   >&nbsp;* the potential for the L2ARC to churn if it attempts to cache content too</font></div><div><font size="2"   >&nbsp;* quickly, such as during backups of the entire pool.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 5. After system boot and before the ARC has filled main memory, there are</font></div><div><font size="2"   >&nbsp;* no evictions from the ARC and so the tails of the ARC_mfu and ARC_mru</font></div><div><font size="2"   >&nbsp;* lists can remain mostly static. &nbsp;Instead of searching from tail of these</font></div><div><font size="2"   >&nbsp;* lists as pictured, the l2arc_feed_thread() will search from the list heads</font></div><div><font size="2"   >&nbsp;* for eligible buffers, greatly increasing its chance of finding them.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The L2ARC device write speed is also boosted during this time so that</font></div><div><font size="2"   >&nbsp;* the L2ARC warms up faster. &nbsp;Since there have been no ARC evictions yet,</font></div><div><font size="2"   >&nbsp;* there are no L2ARC reads, and no fear of degrading read performance</font></div><div><font size="2"   >&nbsp;* through increased writes.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 6. Writes to the L2ARC devices are grouped and sent in-sequence, so that</font></div><div><font size="2"   >&nbsp;* the vdev queue can aggregate them into larger and fewer writes. &nbsp;Each</font></div><div><font size="2"   >&nbsp;* device is written to in a rotor fashion, sweeping writes through</font></div><div><font size="2"   >&nbsp;* available space then repeating.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 7. The L2ARC does not store dirty content. &nbsp;It never needs to flush</font></div><div><font size="2"   >&nbsp;* write buffers back to disk based storage.</font></div></div><div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* 8. If an ARC buffer is written (and dirtied) which also exists in the</font></div><div><font size="2"   >&nbsp;* L2ARC, the now stale L2ARC buffer is immediately dropped.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The performance of the L2ARC can be tweaked by a number of tunables, which</font></div><div><font size="2"   >&nbsp;* may be necessary for different workloads:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_write_max &nbsp; &nbsp; &nbsp; &nbsp; max write bytes per interval</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_write_boost &nbsp; &nbsp; &nbsp; extra write bytes during device warmup</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_noprefetch &nbsp; &nbsp; &nbsp; &nbsp;skip caching prefetched buffers</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_nocompress &nbsp; &nbsp; &nbsp; &nbsp;skip compressing buffers</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_headroom &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number of max device writes to precache</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_headroom_boost &nbsp; &nbsp;when we find compressed buffers during ARC</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanning, we multiply headroom by this</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;percentage factor for the next scan cycle,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;since more compressed buffers are likely to</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;be present</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_feed_secs &nbsp; &nbsp; &nbsp; &nbsp; seconds between L2ARC writing</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Tunables may be removed or added as future performance improvements are</font></div><div><font size="2"   >&nbsp;* integrated, and also may become zpool properties.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* There are three key functions that control how the L2ARC warms up:</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_write_eligible() &nbsp;check if a buffer is eligible to cache</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_write_size() &nbsp; &nbsp; &nbsp;calculate how much to write</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;l2arc_write_interval() &nbsp;calculate sleep delay between writes</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* These three functions determine what to write, how much, and how quickly</font></div><div><font size="2"   >&nbsp;* to send writes.</font></div><div><font size="2"   >&nbsp;*/</font></div></div><p></p></pre></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="ZFS ARC  L2ARC zfs-ver/module/zfs/arc.c - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>