<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap EXP: PostgreSQL IN-BUILD mark Class 7 - others(statement,xlog,sort)</h2>
	<h5 id="">2013-10-17 9:21:34&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013916221518/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>本文介绍一下剩余的几个PostgreSQL探针:&nbsp;</div><div>1. 语句状态改变探针, 在<span style="line-height: 28px;"   >pg_stat_activity.status值改变时触发, 值为字符串, 可以从中获取到SQL语句.</span></div><div>2. xlog探针, 在插入WAL record时触发. 可以获取到被插入record的rmid, info flags.</div><div>3. xlog探针, 在xlog段切换时触发.&nbsp;</div><div>4. 排序开始探针, 可获取到排序类别(heap,index,datum), 是否强制唯一值, 排序的列数量, work_mem kbytes, 是否需要随机访问排序结果.</div><div>5. 排序结束探针, 可以获取到本探针处的排序空间(磁盘 或 内存), 以及消耗的大小blocks or kbytes.</div><div>探针的详细信息如下 :&nbsp;</div><div><br></div><div><table border="1"   style="margin: 2ex 0px 2ex 2ex; -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border-spacing: 0px; border-collapse: collapse; background-color: rgb(224, 236, 239); border: 2px solid rgb(167, 198, 223); color: rgb(0, 0, 0); font-family: verdana, sans-serif; font-size: 13.333333969116211px; line-height: normal;"   ><tbody><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >statement-status</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >(const char *)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >Probe that fires anytime the server process updates its&nbsp;<tt>pg_stat_activity</tt>.<tt>status</tt>. arg0 is the new status string.</td></tr></table></div><table border="1"   style="margin: 2ex 0px 2ex 2ex; -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border-spacing: 0px; border-collapse: collapse; background-color: rgb(224, 236, 239); border: 2px solid rgb(167, 198, 223); color: rgb(0, 0, 0); font-family: verdana, sans-serif; font-size: 13.333333969116211px; line-height: normal;"   ><tbody><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >xlog-insert</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(unsigned char, unsigned char)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when a WAL record is inserted. arg0 is the resource manager (rmid) for the record. arg1 contains the info flags.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >xlog-switch</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >()</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when a WAL segment switch is requested.</td></tr></table><div><table border="1"   style="margin: 2ex 0px 2ex 2ex; -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border-spacing: 0px; border-collapse: collapse; background-color: rgb(224, 236, 239); border: 2px solid rgb(167, 198, 223); color: rgb(0, 0, 0); font-family: verdana, sans-serif; font-size: 13.333333969116211px; line-height: normal;"   ><tbody><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >sort-start</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(int, bool, int, int, bool)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when a sort operation is started. arg0 indicates heap, index or datum sort. arg1 is true for unique-value enforcement. arg2 is the number of key columns. arg3 is the number of kilobytes of work memory allowed. arg4 is true if random access to the sort result is required.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >sort-done</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(bool, long)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when a sort is complete. arg0 is true for external sort, false for internal sort. arg1 is the number of disk blocks used for an external sort, or kilobytes of memory used for an internal sort.</td></tr></table></div><br><div>[举例]</div><div>1. 语句探针, 当语句状态改变(pg_stat_activity.status)时, 输出语句的当前值.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 postgresql-9.3.1]# stap -e '</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status") {printdln("**", pn(), $arg1 ? user_string($arg1) : "0")&nbsp;</font></div><div><font size="2"   >}'</font></div><p></p></pre></div><div>执行SQL :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >WARNING: &nbsp;there is already a transaction in progress</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# end;</font></div><div><font size="2"   >COMMIT</font></div><div><font size="2"   >digoal=# select * from t1;</font></div></div><div><div><font size="2"   >digoal=# select * from t1 limit 1;</font></div><div><font size="2"   >&nbsp;id | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+----------------------------------</font></div><div><font size="2"   >&nbsp; 1 | 006f3673faa5991478e6db0c01c88716</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >digoal=# select * from t1 limit 1;</font></div><div><font size="2"   >&nbsp;id | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+----------------------------------</font></div><div><font size="2"   >&nbsp; 1 | 006f3673faa5991478e6db0c01c88716</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select * from t1 limit 1;</font></div><div><font size="2"   >&nbsp;id | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+----------------------------------</font></div><div><font size="2"   >&nbsp; 1 | 006f3673faa5991478e6db0c01c88716</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select * from t1 limit 1;</font></div><div><font size="2"   >&nbsp;id | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----+----------------------------------</font></div><div><font size="2"   >&nbsp; 1 | 006f3673faa5991478e6db0c01c88716</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >digoal=# select * from t12 limit 1;<br>ERROR:  relation "t12" does not exist<br>LINE 1: select * from t12 limit 1;<br>                      ^</font></div><p></p></pre></div><div>输出 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**begin;</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**0</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**end;</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**0</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**select * from t1;</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**0</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**select * from t1 limit 1;</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**0</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**begin;</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**0</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**select * from t1 limit 1;</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**0</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**select * from t1 limit 1;</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**0</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**select * from t1 limit 1;</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**0</font></div></div><div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**select * from t12 limit 1;</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("statement__status")**0</font></div></div><p></p></pre></div><div>2. xlog探针</div><div>xlog record data插入跟踪, 可以得到rmid(枚举,), info flags(不同的rmid, info有不同的含义).</div><div>rmid和info的介绍参考本文源码部分.</div><div>测试stap如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 postgresql-9.3.1]# stap -e '</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("xlog__insert") {</font></div><div><font size="2"   >&nbsp; printf("rmid:%u, info:%d\n", $arg1 ,$arg2)</font></div><div><font size="2"   >}<span style="line-height: 28px;"   >'</span></font></div><p></p></pre></div><div>输出如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# insert into t1 values (1,'test');</font></div><div><font size="2"   >INSERT 0 1</font></div></div><div><font size="2"   >OUTPUT :&nbsp;</font></div><div><div><font size="2"   >rmid:10, info:0</font></div><div><font size="2"   >rmid:1, info:96</font></div></div><p></p></pre></div><div>简单介绍, rmid=10代表这是个heap_redo, info=0在heap_redo中的含义是INSERT.</div><div>rmid=1表示xact_redo, info=96在xact_redo中的含义是<span style="line-height: 28px;"   >XLOG_XACT_COMMIT_COMPACT, 如下 .</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >src/include/access/xact.h</font></div><div><div><font size="2"   >/* ----------------</font></div><div><font size="2"   >&nbsp; &nbsp;99 &nbsp;* &nbsp; &nbsp; &nbsp;transaction-related XLOG entries</font></div><div><font size="2"   >&nbsp; 100 &nbsp;* ----------------</font></div><div><font size="2"   >&nbsp; 101 &nbsp;*/</font></div><div><font size="2"   >&nbsp; 102&nbsp;</font></div><div><font size="2"   >&nbsp; 103 /*</font></div><div><font size="2"   >&nbsp; 104 &nbsp;* XLOG allows to store some information in high 4 bits of log</font></div><div><font size="2"   >&nbsp; 105 &nbsp;* record xl_info field</font></div><div><font size="2"   >&nbsp; 106 &nbsp;*/</font></div><div><font size="2"   >&nbsp; 107 #define XLOG_XACT_COMMIT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x00</font></div><div><font size="2"   >&nbsp; 108 #define XLOG_XACT_PREPARE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x10</font></div><div><font size="2"   >&nbsp; 109 #define XLOG_XACT_ABORT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x20</font></div><div><font size="2"   >&nbsp; 110 #define XLOG_XACT_COMMIT_PREPARED &nbsp; 0x30</font></div><div><font size="2"   >&nbsp; 111 #define XLOG_XACT_ABORT_PREPARED &nbsp; &nbsp;0x40</font></div><div><font size="2"   >&nbsp; 112 #define XLOG_XACT_ASSIGNMENT &nbsp; &nbsp; &nbsp; &nbsp;0x50</font></div><div><font size="2"   >&nbsp; 113 #define XLOG_XACT_COMMIT_COMPACT &nbsp; &nbsp;0x60</font></div></div><p></p></pre></div><div>详见本文源码部分.</div><div>其他输出不再解释, 可以去查doxygen.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# checkpoint;</font></div><div><font size="2"   >CHECKPOINT</font></div></div><div><font size="2"   >OUTPUT :&nbsp;</font></div><div><div><font size="2"   >rmid:8, info:16</font></div><div><font size="2"   >rmid:0, info:16</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# select pg_switch_xlog()</font></div><div><font size="2"   >digoal-# ;</font></div><div><font size="2"   >&nbsp;pg_switch_xlog&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp;3/4226BC88</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >OUTPUT :&nbsp;</font></div><div><font size="2"   >rmid:0, info:64</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# select pg_start_backup('test');</font></div><div><font size="2"   >&nbsp;pg_start_backup&nbsp;</font></div><div><font size="2"   >-----------------</font></div><div><font size="2"   >&nbsp;3/43000028</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >OUTPUT :&nbsp;</font></div><div><div><font size="2"   >rmid:0, info:64</font></div><div><font size="2"   >rmid:8, info:16</font></div><div><font size="2"   >rmid:0, info:16</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select pg_stop_backup();</font></div><div><font size="2"   >NOTICE: &nbsp;WAL archiving is not enabled; you must ensure that all required WAL segments are copied through other means to complete the backup</font></div><div><font size="2"   >&nbsp;pg_stop_backup&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp;3/430000F0</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >OUTPUT :&nbsp;</font></div><div><div><font size="2"   >rmid:0, info:80</font></div><div><font size="2"   >rmid:0, info:64</font></div></div><p></p></pre></div><div><span style="line-height: 28px;"   >3. xlog探针, 切换xlog时触发.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 postgresql-9.3.1]# stap -e '</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("xlog__switch") {</font></div><div><font size="2"   >&nbsp; println(pn()) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >}<span style="line-height: 28px;"   >'</span></font></div><div><span style="line-height: 28px;"   ><font size="2"   >SQL :&nbsp;</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   ><div>digoal=# select pg_switch_xlog();</div><div>&nbsp;pg_switch_xlog&nbsp;</div><div>----------------</div><div>&nbsp;3/45000728</div><div>(1 row)</div></font></span></div><div><span style="line-height: 28px;"   ><font size="2"   ><div>digoal=# select pg_switch_xlog();</div><div>&nbsp;pg_switch_xlog&nbsp;</div><div>----------------</div><div>&nbsp;3/5EE76270</div><div>(1 row)</div><div>输出</div></font></span></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("xlog__switch")</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("xlog__switch")</font></div><p></p></pre></div><div>4. 排序探针</div><div>stap脚本 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 postgresql-9.3.1]# stap --vp 10000 -e '</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("sort__start") {</font></div><div><font size="2"   >&nbsp; if ($arg1 == 0) st="HEAP_SORT"</font></div><div><font size="2"   >&nbsp; if ($arg1 == 1) st="INDEX_SORT"</font></div><div><font size="2"   >&nbsp; if ($arg1 == 2) st="DATUM_SORT"</font></div><div><font size="2"   >&nbsp; if ($arg1 == 3) st="CLUSTER_SORT"</font></div><div><font size="2"   >&nbsp; printdln("**",pn(),st,$arg2,$arg3,$arg4,$arg5)</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("sort__done") {&nbsp;</font></div><div><font size="2"   >&nbsp; if ($arg1) st="EXTERNAL_SORT"</font></div><div><font size="2"   >&nbsp; if (! $arg1) st="MEM_SORT"</font></div><div><font size="2"   >&nbsp; printdln("**",pn(),st,$arg2)</font></div><div><font size="2"   >}'</font></div><p></p></pre></div><div>SQL :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# explain (analyze,verbose,costs,buffers,timing) select * from t1 order by id;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Sort &nbsp;(cost=884772.20..898852.12 rows=5631970 width=11) (actual time=11457.870..13425.913 rows=5635072 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp;Sort Key: t1.id</font></div><div><font size="2"   >&nbsp; &nbsp;Sort Method: external merge &nbsp;Disk: 118696kB</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=31965, temp read=57480 written=57480</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.t1 &nbsp;(cost=0.00..88281.70 rows=5631970 width=11) (actual time=0.010..969.990 rows=5635072 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=31962</font></div><div><font size="2"   >&nbsp;Total runtime: 14040.272 ms</font></div><div><font size="2"   >(9 rows)</font></div><p></p></pre></div><div># 使用了外部文件排序, 耗费<span style="line-height: 28px;"   >14837个数据库, 与stap输出一致.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select 14837*8;</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp;118696</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div>stap输出 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("sort__start")**HEAP_SORT**0**1**1024**0</font></div><div><font size="2"   >第一个0代表非唯一排序, 后面的1表示排序为1个key. 1024KB表示允许的work mem大小, 最后的0表示不需要随机访问排序结果</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("sort__done")**EXTERNAL_SORT**14837</font></div></div><div><font size="2"   >14837个块, 和analyze结果一致.</font></div><p></p></pre></div><div>再来两个SQL, 修改work_mem后, 使用了内存排序.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# explain (analyze,verbose,costs,buffers,timing) select * from t1 order by id desc,info;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Sort &nbsp;(cost=884772.20..898852.12 rows=5631970 width=11) (actual time=15619.253..18770.273 rows=5635072 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp;Sort Key: t1.id, t1.info</font></div><div><font size="2"   >&nbsp; &nbsp;Sort Method: external merge &nbsp;Disk: 118704kB</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=31962, temp read=58144 written=58144</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.t1 &nbsp;(cost=0.00..88281.70 rows=5631970 width=11) (actual time=0.011..961.801 rows=5635072 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=31962</font></div><div><font size="2"   >&nbsp;Total runtime: 19390.284 ms</font></div><div><font size="2"   >(9 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# set work_mem='1024MB';</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=# explain (analyze,verbose,costs,buffers,timing) select * from t1 order by id desc,info;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Sort &nbsp;(cost=719772.20..733852.12 rows=5631970 width=11) (actual time=4449.092..5611.460 rows=5635072 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp;Sort Key: t1.id, t1.info</font></div><div><font size="2"   >&nbsp; &nbsp;Sort Method: quicksort &nbsp;Memory: 476753kB</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=31962</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.t1 &nbsp;(cost=0.00..88281.70 rows=5631970 width=11) (actual time=0.012..901.700 rows=5635072 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=31962</font></div><div><font size="2"   >&nbsp;Total runtime: 6203.356 ms</font></div><div><font size="2"   >(9 rows)</font></div></div><div><div><font size="2"   >digoal=# explain (analyze,verbose,costs,buffers,timing) select * from t1 group by info,id order by id desc,info;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Sort &nbsp;(cost=175868.07..177276.06 rows=563197 width=11) (actual time=3792.241..3793.914 rows=11000 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp;Sort Key: t1.id, t1.info</font></div><div><font size="2"   >&nbsp; &nbsp;Sort Method: quicksort &nbsp;Memory: 931kB</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=31962</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;HashAggregate &nbsp;(cost=116441.55..122073.52 rows=563197 width=11) (actual time=3777.310..3784.205 rows=11000 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=31962</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.t1 &nbsp;(cost=0.00..88281.70 rows=5631970 width=11) (actual time=0.017..920.271 rows=5635072 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: id, info</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=31962</font></div><div><font size="2"   >&nbsp;Total runtime: 3800.721 ms</font></div><div><font size="2"   >(12 rows)</font></div></div><p></p></pre></div><div>输出</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("sort__start")**HEAP_SORT**0**2**1024**0</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("sort__done")**EXTERNAL_SORT**14838</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("sort__start")**HEAP_SORT**0**2**1048576**0</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("sort__done")**MEM_SORT**476753</font></div></div><div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("sort__start")**HEAP_SORT**0**2**1048576**0</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("sort__done")**MEM_SORT**931</font></div></div><p></p></pre></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/dynamic-trace.html"   >http://www.postgresql.org/docs/9.3/static/dynamic-trace.html</a></div><div>2.&nbsp;</div><div>src/backend/postmaster/pgstat.c</div><div>src/backend/access/transam/xlog.c</div><div>src/backend/utils/sort/tuplesort.c</div><div>src/include/access/rmgr.h</div><div>src/include/access/rmgrlist.h</div><div>src/include/access/xact.h</div><div>3. 探针信息 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/* TRACE_POSTGRESQL_STATEMENT_STATUS ( const char *) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_STATEMENT_STATUS_ENABLED() __builtin_expect (statement__status_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_statement__status_semaphore statement__status_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_STATEMENT_STATUS_ENABLED() __builtin_expect (postgresql_statement__status_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_statement__status_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_STATEMENT_STATUS(arg1) \</font></div><div><font size="2"   >DTRACE_PROBE1(postgresql,statement__status,arg1)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/* TRACE_POSTGRESQL_XLOG_INSERT ( unsigned char, unsigned char) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_XLOG_INSERT_ENABLED() __builtin_expect (xlog__insert_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_xlog__insert_semaphore xlog__insert_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_XLOG_INSERT_ENABLED() __builtin_expect (postgresql_xlog__insert_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_xlog__insert_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_XLOG_INSERT(arg1,arg2) \</font></div><div><font size="2"   >DTRACE_PROBE2(postgresql,xlog__insert,arg1,arg2)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* TRACE_POSTGRESQL_XLOG_SWITCH () */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_XLOG_SWITCH_ENABLED() __builtin_expect (xlog__switch_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_xlog__switch_semaphore xlog__switch_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_XLOG_SWITCH_ENABLED() __builtin_expect (postgresql_xlog__switch_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_xlog__switch_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_XLOG_SWITCH() \</font></div><div><font size="2"   >DTRACE_PROBE(postgresql,xlog__switch)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >/* TRACE_POSTGRESQL_SORT_START ( int, char, int, int, char) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_SORT_START_ENABLED() __builtin_expect (sort__start_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_sort__start_semaphore sort__start_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_SORT_START_ENABLED() __builtin_expect (postgresql_sort__start_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_sort__start_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_SORT_START(arg1,arg2,arg3,arg4,arg5) \</font></div><div><font size="2"   >DTRACE_PROBE5(postgresql,sort__start,arg1,arg2,arg3,arg4,arg5)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* TRACE_POSTGRESQL_SORT_DONE ( char, long) */</font></div><div><font size="2"   >#if defined STAP_SDT_V1</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_SORT_DONE_ENABLED() __builtin_expect (sort__done_semaphore, 0)</font></div><div><font size="2"   >#define postgresql_sort__done_semaphore sort__done_semaphore</font></div><div><font size="2"   >#else</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_SORT_DONE_ENABLED() __builtin_expect (postgresql_sort__done_semaphore, 0)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >__extension__ extern unsigned short postgresql_sort__done_semaphore __attribute__ ((unused)) __attribute__ ((section (".probes")));</font></div><div><font size="2"   >#define TRACE_POSTGRESQL_SORT_DONE(arg1,arg2) \</font></div><div><font size="2"   >DTRACE_PROBE2(postgresql,sort__done,arg1,arg2)</font></div></div><p></p></pre></div><div>4. 探针在源码中的信息 :&nbsp;</div><div>语句状态改变探针:&nbsp;</div><div>src/backend/postmaster/pgstat.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/* ----------</font></div><div><font size="2"   >&nbsp;* pgstat_report_activity() -</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;Called from tcop/postgres.c to report what the backend is actually doing</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;(but note cmd_str can be NULL for certain cases).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* All updates of the status entry follow the protocol of bumping</font></div><div><font size="2"   >&nbsp;* st_changecount before and after. &nbsp;We use a volatile pointer here to</font></div><div><font size="2"   >&nbsp;* ensure the compiler doesn't try to get cute.</font></div><div><font size="2"   >&nbsp;* ----------</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >pgstat_report_activity(BackendState state, const char *cmd_str)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; volatile PgBackendStatus *beentry = MyBEEntry;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz start_timestamp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz current_timestamp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = 0;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_STATEMENT_STATUS(cmd_str);</font></div><p></p></pre></div><div>xlog插入和切换探针:&nbsp;</div><div>src/backend/access/transam/xlog.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Insert an XLOG record having the specified RMID and info bytes,</font></div><div><font size="2"   >&nbsp;* with the body of the record being the data chunk(s) described by</font></div><div><font size="2"   >&nbsp;* the rdata chain (see xlog.h for notes about rdata).</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Returns XLOG pointer to end of record (beginning of next record).</font></div><div><font size="2"   >&nbsp;* This can be used as LSN for data pages affected by the logged action.</font></div><div><font size="2"   >&nbsp;* (LSN is the XLOG point up to which the XLOG must be flushed to disk</font></div><div><font size="2"   >&nbsp;* before the data page can be written out. &nbsp;This implements the basic</font></div><div><font size="2"   >&nbsp;* WAL rule "write the log before the data".)</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* NB: this routine feels free to scribble on the XLogRecData structs,</font></div><div><font size="2"   >&nbsp;* though not on the data they reference. &nbsp;This is OK since the XLogRecData</font></div><div><font size="2"   >&nbsp;* structs are always just temporaries in the calling code.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >XLogRecPtr</font></div><div><font size="2"   >XLogInsert(RmgrId rmid, uint8 info, XLogRecData *rdata)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* info's high bits are reserved for use by me */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (info &amp; XLR_INFO_MASK)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, "invalid xlog info mask %02X", info);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_XLOG_INSERT(rmid, info);</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If the record is an XLOG_SWITCH, we must now write and flush all the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* existing data, and then forcibly advance to the start of the next</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* segment. &nbsp;It's not good to do this I/O while holding the insert lock,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* but there seems too much risk of confusion if we try to release the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* lock sooner. &nbsp;Fortunately xlog switch needn't be a high-performance</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* operation anyway...</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (isLogSwitch)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogwrtRqst FlushRqst;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;OldSegEnd;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_XLOG_SWITCH();</font></div></div><div><font size="2"   >...</font></div><div><font size="2"   >src/include/access/rmgr.h</font></div><div><font size="2"   >typedef uint8 RmgrId;</font></div><div><font size="2"   >...</font></div><div><font size="2"   >src/include/access/rmgrlist.h</font></div><div><font size="2"   >/* symbol name, textual name, redo, desc, startup, cleanup, restartpoint */<br>PG_RMGR(RM_XLOG_ID, "XLOG", xlog_redo, xlog_desc, NULL, NULL, NULL)<br>PG_RMGR(RM_XACT_ID, "Transaction", xact_redo, xact_desc, NULL, NULL, NULL)<br>PG_RMGR(RM_SMGR_ID, "Storage", smgr_redo, smgr_desc, NULL, NULL, NULL)<br>PG_RMGR(RM_CLOG_ID, "CLOG", clog_redo, clog_desc, NULL, NULL, NULL)<br>PG_RMGR(RM_DBASE_ID, "Database", dbase_redo, dbase_desc, NULL, NULL, NULL)<br>PG_RMGR(RM_TBLSPC_ID, "Tablespace", tblspc_redo, tblspc_desc, NULL, NULL, NULL)<br>PG_RMGR(RM_MULTIXACT_ID, "MultiXact", multixact_redo, multixact_desc, NULL, NULL, NULL)<br>PG_RMGR(RM_RELMAP_ID, "RelMap", relmap_redo, relmap_desc, NULL, NULL, NULL)<br>PG_RMGR(RM_STANDBY_ID, "Standby", standby_redo, standby_desc, NULL, NULL, NULL)<br>PG_RMGR(RM_HEAP2_ID, "Heap2", heap2_redo, heap2_desc, NULL, NULL, NULL)<br>PG_RMGR(RM_HEAP_ID, "Heap", heap_redo, heap_desc, NULL, NULL, NULL)<br>PG_RMGR(RM_BTREE_ID, "Btree", btree_redo, btree_desc, btree_xlog_startup, btree_xlog_cleanup, btree_safe_restartpoint)<br>PG_RMGR(RM_HASH_ID, "Hash", hash_redo, hash_desc, NULL, NULL, NULL)<br>PG_RMGR(RM_GIN_ID, "Gin", gin_redo, gin_desc, gin_xlog_startup, gin_xlog_cleanup, gin_safe_restartpoint)<br>PG_RMGR(RM_GIST_ID, "Gist", gist_redo, gist_desc, gist_xlog_startup, gist_xlog_cleanup, NULL)<br>PG_RMGR(RM_SEQ_ID, "Sequence", seq_redo, seq_desc, NULL, NULL, NULL)<br>PG_RMGR(RM_SPGIST_ID, "SPGist", spg_redo, spg_desc, spg_xlog_startup, spg_xlog_cleanup, NULL)</font></div><div><font size="2"   >不同的rmid, info有不同的含义, 例如heap insert</font></div><div><font size="2"   >src/include/access/heapam_xlog.h</font></div><div><font size="2"   >/*<br> * WAL record definitions for heapam.c's WAL operations<br> *<br> * XLOG allows to store some information in high 4 bits of log<br> * record xl_info field.  We use 3 for opcode and one for init bit.<br> */<br>#define XLOG_HEAP_INSERT                0x00<br>#define XLOG_HEAP_DELETE                0x10<br>#define XLOG_HEAP_UPDATE                0x20<br>/* 0x030 is free, was XLOG_HEAP_MOVE */<br>#define XLOG_HEAP_HOT_UPDATE    0x40<br>#define XLOG_HEAP_NEWPAGE               0x50<br>#define XLOG_HEAP_LOCK                  0x60<br>#define XLOG_HEAP_INPLACE               0x70</font></div><p></p></pre></div><div>排序探针:&nbsp;</div><div>src/backend/utils/sort/tuplesort.c</div><div><pre class="prettyprint"   ><p></p><div><div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >/*</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tuplesort_begin_xxx</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;* Initialize for a tuple sort operation.</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;* After calling tuplesort_begin, the caller should call tuplesort_putXXX</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;* zero or more times, then call tuplesort_performsort when all the tuples</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;* have been supplied. &nbsp;After performsort, retrieve the tuples in sorted</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;* order by calling tuplesort_getXXX until it returns false/NULL. &nbsp;(If random</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;* access was requested, rescan, markpos, and restorepos can also be called.)</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;* Call tuplesort_end to terminate the operation and release memory/disk space.</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;*</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;* Each variant of tuplesort_begin has a workMem parameter specifying the</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;* maximum number of kilobytes of RAM to use before spilling data to disk.</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;* (The normal value of this parameter is work_mem, but some callers use</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;* other values.) &nbsp;Each variant also has a randomAccess parameter specifying</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;* whether the caller needs non-sequential access to the sort result.</font></div><div style="line-height: 28px;"   ><font size="2"   style="line-height: 21px;"   >&nbsp;*/</font></div></div><div><font size="2"   >...</font></div><div><font size="2"   >Tuplesortstate *<br>tuplesort_begin_heap(TupleDesc tupDesc,<br>                                         int nkeys, AttrNumber *attNums,<br>                                         Oid *sortOperators, Oid *sortCollations,<br>                                         bool *nullsFirstFlags,<br>                                         int workMem, bool randomAccess)<br>{</font></div><div><font size="2"   >...</font></div><div><font size="2"   >        state-&gt;nKeys = nkeys;<br><br>        TRACE_POSTGRESQL_SORT_START(HEAP_SORT,<br>                                                                false,  /* no unique check */<br>                                                                nkeys,<br>                                                                workMem,<br>                                                                randomAccess);</font></div><div><font size="2"   >...</font></div><div><font size="2"   ><span style="line-height: 21px;"   >Tuplesortstate *<br>tuplesort_begin_cluster(TupleDesc tupDesc,<br>                                                Relation indexRel,<br>                                                int workMem, bool randomAccess)<br>{</span></font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nKeys = RelationGetNumberOfAttributes(indexRel);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_SORT_START(CLUSTER_SORT,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; false, &nbsp;/* no unique check */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nKeys,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workMem,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; randomAccess);</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >Tuplesortstate *</font></div><div><font size="2"   >tuplesort_begin_index_btree(Relation heapRel,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation indexRel,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool enforceUnique,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int workMem, bool randomAccess)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nKeys = RelationGetNumberOfAttributes(indexRel);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_SORT_START(INDEX_SORT,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enforceUnique,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nKeys,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workMem,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; randomAccess);</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >Tuplesortstate *</font></div><div><font size="2"   >tuplesort_begin_datum(Oid datumType, Oid sortOperator, Oid sortCollation,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool nullsFirstFlag,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int workMem, bool randomAccess)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nKeys = 1; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* always a one-column sort */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_SORT_START(DATUM_SORT,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; false, &nbsp;/* no unique check */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workMem,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; randomAccess);</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* tuplesort_end</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;Release resources and clean up.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* NOTE: after calling this, any pointers returned by tuplesort_getXXX are</font></div><div><font size="2"   >&nbsp;* pointing to garbage. &nbsp;Be careful not to attempt to use or free such</font></div><div><font size="2"   >&nbsp;* pointers afterwards!</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >tuplesort_end(Tuplesortstate *state)</font></div><div><font size="2"   >{</font></div></div><div><font size="2"   >...</font></div><div><div><font size="2"   >#ifdef TRACE_SORT</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (trace_sort)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (state-&gt;tapeset)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, "external sort ended, %ld disk blocks used: %s",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;spaceUsed, pg_rusage_show(&amp;state-&gt;ru_start));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, "internal sort ended, %ld KB used: %s",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;spaceUsed, pg_rusage_show(&amp;state-&gt;ru_start));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_SORT_DONE(state-&gt;tapeset != NULL, spaceUsed);</font></div><div><font size="2"   >#else</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If you disabled TRACE_SORT, you can still probe sort__done, but you</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ain't getting space-used stats.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_SORT_DONE(state-&gt;tapeset != NULL, 0L);</font></div></div><div><font size="2"   >排序类型定义</font></div><div><font size="2"   >src/backend/utils/sort/tuplesort.c</font></div><div><font size="2"   >/* sort-type codes for sort__start probes */<br>#define HEAP_SORT               0<br>#define INDEX_SORT              1<br>#define DATUM_SORT              2<br>#define CLUSTER_SORT    3</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>