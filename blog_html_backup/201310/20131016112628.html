<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap EXP: PostgreSQL IN-BUILD mark Class 2 - query</h2>
	<h5 id="">2013-10-16 11:26:28&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013916101117367/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>本文要讲的是PostgreSQL内建探针的第二个分类 : query.</div><div>相比第一个分类transaction, query更加精细. 例如函数调用, 可以精细到函数内部的每个SQL, 以及嵌套函数的最底层的SQL等.</div><div>包含SQL查询开始, 结束, 语义解析开始, 结束, 重写开始, 结束, plan开始, 结束, 执行开始, 结束.</div><div><table border="1"   style="margin: 2ex 0px 2ex 2ex; -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border-spacing: 0px; border-collapse: collapse; background-color: rgb(224, 236, 239); border: 2px solid rgb(167, 198, 223); color: rgb(0, 0, 0); font-family: verdana, sans-serif; font-size: 12px; line-height: normal;"   ><tbody><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >query-start</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(const char *)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when the processing of a query is started. arg0 is the query string.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >query-done</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(const char *)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when the processing of a query is complete. arg0 is the query string.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >query-parse-start</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >(const char *)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >Probe that fires when the parsing of a query is started. arg0 is the query string.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >query-parse-done</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(const char *)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when the parsing of a query is complete. arg0 is the query string.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >query-rewrite-start</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(const char *)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when the rewriting of a query is started. arg0 is the query string.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >query-rewrite-done</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >(const char *)</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when the rewriting of a query is complete. arg0 is the query string.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >query-plan-start</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >()</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when the planning of a query is started.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >query-plan-done</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >()</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when the planning of a query is complete.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >query-execute-start</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >()</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when the execution of a query is started.</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >query-execute-done</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >()</td><td style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Probe that fires when the execution of a query is complete.</td></tr></table></div><div>源码位置 :&nbsp;</div><div>src/backend/tcop/postgres.c</div><div>src/backend/tcop/pquery.c</div><div>使用这些探针, 可以收集SQL级别的统计信息, 与事务级别的类似, 所以就不再举例, 有兴趣的童鞋可参考 &nbsp;:&nbsp;</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201391684012713/"   >http://blog.163.com/digoal@126/blog/static/163877040201391684012713/</a></div><div>下面要举的这个例子和数据库优化有关, 以前写过一篇优化案例讲解, 有兴趣的童鞋可以参考一下</div><div><div style="line-height: 28px;"   ><a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/163877040201221382150858/"   >http://blog.163.com/digoal@126/blog/static/163877040201221382150858/</a></div><div style="line-height: 28px;"   ><a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/163877040201221333411196/"   >http://blog.163.com/digoal@126/blog/static/163877040201221333411196/</a></div></div><div style="line-height: 28px;"   >在使用pgbench压数据库时, 可以选择三种模式.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;-M querymode</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Protocol to use for submitting queries to the server:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;・ &nbsp; simple: use simple query protocol.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;・ &nbsp; extended: use extended query protocol.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;・ &nbsp; prepared: use extended query protocol with prepared statements.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;The default is simple query protocol. (See Chapter 48, Frontend/Backend Protocol, in the documentation for</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;more information.)</font></div><p></p></pre></div><div>2种协议的区别参见 :&nbsp;</div><div><a rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/protocol-flow.html"   >http://www.postgresql.org/docs/9.3/static/protocol-flow.html</a></div><div><pre class="prettyprint"   ><div><font size="2"   >A simple query cycle is initiated by the frontend sending a Query message to the backend. The message includes an SQL command (or commands) expressed as a text string. The backend then sends one or more response messages depending on the contents of the query command string, and finally a ReadyForQuery response message. ReadyForQuery informs the frontend that it can safely send a new command. (It is not actually necessary for the frontend to wait for ReadyForQuery before issuing another command, but the frontend must then take responsibility for figuring out what happens if the earlier command fails and already-issued later commands succeed.)</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >The extended query protocol breaks down the above-described simple query protocol into multiple steps. The results of preparatory steps can be re-used multiple times for improved efficiency. Furthermore, additional features are available, such as the possibility of supplying data values as separate parameters instead of having to insert them directly into a query string.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >In the extended protocol, the frontend first sends a Parse message, which contains a textual query string, optionally some information about data types of parameter placeholders, and the name of a destination prepared-statement object (an empty string selects the unnamed prepared statement). The response is either ParseComplete or ErrorResponse. Parameter data types can be specified by OID; if not given, the parser attempts to infer the data types in the same way as it would do for untyped literal string constants.</font></div></div><p></p></pre></div><div>pgbench的prepared模式用的是extended协议, 同时使用了named prepared statement.</div><div>接下来使用stap观察一下3种模式的区别.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >stap -e '</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__start") {</font></div><div><font size="2"   >&nbsp; println(pn(), user_string($arg1), pid())</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start") {</font></div><div><font size="2"   >&nbsp; println(pn(), user_string($arg1), pid())</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__rewrite__start") {</font></div><div><font size="2"   >&nbsp; println(pn(), user_string($arg1), pid())</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start") {</font></div><div><font size="2"   >&nbsp; println(pn(), pid())</font></div><div><font size="2"   >}</font></div><div><font size="2"   >probe process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start") {</font></div><div><font size="2"   >&nbsp; println(pn(), pid())</font></div><div><font size="2"   >}<span style="line-height: 28px;"   >'</span></font></div><p></p></pre></div><div><span style="line-height: 28px;"   ><div>执行pgbench :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg93@db-172-16-3-150-&gt; cat test.sql</font></div><div><span style="line-height: 28px;"   ><font size="2"   >select clock_timestamp();</font></span></div><p></p></pre></div><div><span style="line-height: 28px;"   >首先是simple模式</span></div></span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg93@db-172-16-3-150-&gt; pgbench -M simple -n -r -f ./test.sql -c 1 -j 1 -t 6</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >输出, 每条SQL都需要经历query start, parse, rewrite, plan, execute.</span></div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__rewrite__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start")14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__rewrite__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start")14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__rewrite__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start")14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__rewrite__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start")14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__rewrite__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start")14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__rewrite__start")select clock_timestamp();14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start")14146</font></div><div style="line-height: 28px;"   ><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14146</font></div><p></p></pre></div></div><div style="line-height: 28px;"   ><br></div><div>接下来是extended模式</div><div><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >pg93@db-172-16-3-150-&gt; pgbench -M extended -n -r -f ./test.sql -c 1 -j 1 -t 6</font></div><div style="line-height: 28px;"   ></div><p></p></pre><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >输出</span><span style="line-height: 28px;"   >, 没有了query start和 rewrite. 每条SQL都需要经历 parse, plan, execute.</span></div></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >parse中包含SQL语句.</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start")select clock_timestamp();14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start")14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start")select clock_timestamp();14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start")14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start")select clock_timestamp();14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start")14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start")select clock_timestamp();14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start")14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start")select clock_timestamp();14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start")14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start")select clock_timestamp();14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start")14140</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14140</font></div><p></p></pre></div><div><br></div><div>最后是prepared模式</div><div><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >pg93@db-172-16-3-150-&gt; pgbench -M prepared -n -r -f ./test.sql -c 1 -j 1 -t 6</font></div><div style="line-height: 28px;"   ></div><p></p></pre><div style="line-height: 28px;"   ><span style="line-height: 28px;"   >输出, 只有一次query parse, plan, 后面执行同样类型SQL的都是execute.</span></div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__parse__start")select clock_timestamp();14143</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__plan__start")14143</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14143</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14143</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14143</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14143</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14143</font></div><div><font size="2"   >process("/home/pg93/pgsql9.3.1/bin/postgres").mark("query__execute__start")14143</font></div><p></p></pre></div><div>显然是一prepared模式效率最高. 但是对于客户端和数据库之间有连接池的情况可能就不适用, 例如pgbouncer连接池.</div></div><div>因为extended协议下如果使用prepared模式, 只有第一个parse消息中包含了sql, 后面都以named prepared statement代替, 如果更换服务端, 将找不到该backend process中存储的<span style="line-height: 28px;"   >named prepared statement. 以致报错.</span></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/163877040201391684012713/"   >http://blog.163.com/digoal@126/blog/static/163877040201391684012713/</a></div><div>2.&nbsp;<a style="line-height: 28px;" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/dynamic-trace.html"   >http://www.postgresql.org/docs/9.3/static/dynamic-trace.html</a></div><div>3.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/163877040201221382150858/"   >http://blog.163.com/digoal@126/blog/static/163877040201221382150858/</a></div><div>4.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/163877040201221333411196/"   >http://blog.163.com/digoal@126/blog/static/163877040201221333411196/</a></div><div>5.&nbsp;<span style="line-height: 28px;"   >src/backend/tcop/postgres.c</span></div><div><span style="line-height: 28px;"   >6.&nbsp;</span><span style="line-height: 28px;"   >src/backend/tcop/pquery.c</span></div><div><span style="line-height: 28px;"   >7.&nbsp;</span><a style="line-height: 28px;" rel="nofollow" href="http://www.postgresql.org/docs/9.3/static/protocol-flow.html"   >http://www.postgresql.org/docs/9.3/static/protocol-flow.html</a></div></div>
	</div>
</div>
</body>
</html>