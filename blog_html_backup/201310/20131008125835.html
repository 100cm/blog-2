<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap Language elements - 1</h2>
	<h5 id="">2013-10-08 12:58:35&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201398103956233/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>1. 标识</div><div>变量名, 函数名的命名规则 : 由数字, 字母, 下划线, $ 符号组成. 不能以数字开头.</div><div>$符号开头的变量名用来表示被跟踪的源码中的变量. 其他开头的变量名用来表示stap脚本中的变量名或函数名.</div><div><br></div><div>2. 数据类型</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >The SystemTap language includes a small number of data types, but no type declarations.&nbsp;</font></div><div><font size="2"   >A variable's type is inferred from its use.&nbsp;</font></div><div><font size="2"   >To support this inference, the translator enforces consistent typing of function arguments and return values, array indices and values.&nbsp;</font></div><div><font size="2"   >There are no implicit type conversions between strings and numbers.&nbsp;</font></div><div><font size="2"   >Inconsistent type-related use of an identifier signals an error.</font></div><p></p></pre></div><div>定义变量时无需声明类型, systemtap包含数据类型long,string,array,statistic</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >5.2.1 Literals</font></div><div><font size="2"   >Literals are either strings or integers. Literal integers can be expressed as decimal, octal, or hexadecimal, using C notation. Type suffixes (e.g., L or U) are not used.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >5.2.2 Integers</font></div><div><font size="2"   >Integers are decimal, hexadecimal, or octal, and use the same notation as in C. Integers are 64-bit signed quantities, although the parser also accepts (and wraps around) values above positive $2^{63}$ but below $2^{64}$.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >5.2.3 Strings</font></div><div><font size="2"   >Strings are enclosed in quotation marks (``string''), and pass through standard C escape codes with backslashes. A string literal may be split into several pieces, which are glued together, as follows.</font></div><div><font size="2"   >str1 = "foo" "bar"</font></div><div><font size="2"   >&nbsp; /* --&gt; becomes "foobar" */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >str2 = "a good way to do a multi-line\n"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;"string literal"</font></div><div><font size="2"   >&nbsp; /* --&gt; becomes "a good way to do a multi-line\nstring literal" */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >str3 = "also a good way to " @1 " splice command line args"</font></div><div><font size="2"   >&nbsp; /* --&gt; becomes "also a good way to foo splice command line args",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;assuming @1 is given as foo on the command line */</font></div><div><font size="2"   >Observe that script arguments can also be glued into a string literal.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Strings are limited in length to MAXSTRINGLEN. For more information about this and other limits,</font></div><p></p></pre></div><div>详见</div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020138392759478/"   >http://blog.163.com/digoal@126/blog/static/16387704020138392759478/</a></div><div><br></div><div>3. 分号;</div><div>空语句, 一般用于隔开多个表达式, 多个probe之间不需要使用分号隔开</div><div><br></div><div>4. 注释</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># ... shell style, to the end of line</font></div><div><font size="2"   >// ... C++ style, to the end of line</font></div><div><font size="2"   >/* ... C style ... */</font></div><p></p></pre></div><div>支持以上三种注释</div><div><br></div><div>5. 空格</div><pre class="prettyprint"   ><p></p><div><font size="2"   >As in C, spaces, tabs, returns, newlines, and comments are treated as whitespace. Whitespace is ignored by the parser.</font></div><div></div><p></p></pre><div><span style="line-height: 23px;"   >空格不被stap解释, 忽略.</span></div><div><br></div><div>6. 表达式</div><div><div>5.6.1 Binary numeric operators</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >* / % + - &gt;&gt; &lt;&lt; &amp; ^ | &amp;&amp; ||</font></div><div><span style="line-height: 23px;"   ><font size="2"   >* 乘法</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >/ 除法</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >% 取余数</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >+ 加法</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >- 减法</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >&gt;&gt; 比特右移: 8&gt;&gt;1 = 4</font></span></div><div><font size="2"   ><span style="line-height: 23px;"   >&lt;&lt;&nbsp;</span><span style="line-height: 23px;"   >比特</span><span style="line-height: 23px;"   >左移: 4&lt;&lt;1 = 8</span></font></div><div><font size="2"   ><span style="line-height: 23px;"   >&amp;&nbsp;</span><span style="line-height: 23px;"   >比特与:&nbsp;</span>5&amp;1 = 101 &amp; 001 = 001 = 1</font></div><div><font size="2"   ><span style="line-height: 23px;"   >^ 比特异或:&nbsp;</span><span style="line-height: 23px;"   >5^1 = 101 ^ 001 = 100 = 4</span></font></div><div><font size="2"   ><span style="line-height: 23px;"   >| 比特或</span><span style="line-height: 23px;"   >:&nbsp;</span><span style="line-height: 23px;"   >5|1 = 101 | 001 = 101 = 5</span></font></div><div><font size="2"   ><span style="line-height: 23px;"   >&amp;&amp; 逻辑与:&nbsp;</span><span style="line-height: 23px;"   >5&amp;&amp;0 = 0 (结果为1真0假)</span></font></div><div><font size="2"   ><span style="line-height: 23px;"   >|| 逻辑或</span><span style="line-height: 23px;"   >:&nbsp;</span><span style="line-height: 23px;"   >5||0 = 1 (结果为1真0假)</span></font></div><p></p></pre></div><div><br></div><div>5.6.2 Binary string operators</div><pre class="prettyprint"   ><p></p><div><font size="2"   >. (string concatenation)</font></div><div></div><p></p></pre><div><span style="line-height: 23px;"   >字符串连接操作符 :&nbsp;"hello" . "world" =&nbsp;helloworld</span></div><div><br></div><div>5.6.3 Numeric assignment operators</div><div>= *= /= %= += -= &gt;&gt;= &lt;&lt;= &amp;= ^= |=</div><div>数字赋值操作符 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 23px;"   ><font size="2"   >=&nbsp;</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >*=&nbsp;</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >/=&nbsp;</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >%=&nbsp;</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >+=&nbsp;</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >-=&nbsp;</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >&gt;&gt;=&nbsp;</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >&lt;&lt;=&nbsp;</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >&amp;=&nbsp;</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >^=&nbsp;</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >|=</font></span></div><p></p></pre></div><div><br></div><div>5.6.4 String assignment operators</div><div>=&nbsp;<span style="line-height: 23px;"   >.=</span></div><div>字符串赋值操作符</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >=</font></div><div><font size="2"   >.=</font></div><p></p></pre></div><div><br></div><div>5.6.5 Unary numeric operators</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >+ - ! ~ ++ --</font></div><div><font size="2"   >一元数字操作符</font></div><div><span style="line-height: 23px;"   ><font size="2"   >+ 正</font></span></div><div><span style="line-height: 23px;"   ><font size="2"   >- 负</font></span></div><div><font size="2"   ><span style="line-height: 23px;"   >! 逻辑非:&nbsp;</span>!5=0, !1=0, !0=1</font></div><div><font size="2"   ><span style="line-height: 23px;"   >~ 比特反转:&nbsp;</span>~1=0xfffffffffffffffe, ~2=0xfffffffffffffffd</font></div><div><span style="line-height: 23px;"   ><font size="2"   >++ : 自增</font></span></div><div><font size="2"   ><span style="line-height: 23px;"   >--</span><span style="line-height: 23px;"   >&nbsp;</span><span style="line-height: 23px;"   >: 自减</span></font></div><p></p></pre></div><div><br></div><div>5.6.6 Binary numeric, string comparison, or regular expression matching operators</div><div>比较操作符,&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&lt;&nbsp;</font></div><div><font size="2"   >&gt;&nbsp;</font></div><div><font size="2"   >&lt;=&nbsp;</font></div><div><font size="2"   >&gt;=&nbsp;</font></div><div><font size="2"   >==&nbsp;</font></div><div><font size="2"   >!=&nbsp;</font></div><div><span style="line-height: 23px;"   ><font size="2"   >字符串规则表达式匹配操作符</font></span></div><div><font size="2"   >=~&nbsp;</font></div><div><font size="2"   >!~</font></div><p></p></pre></div><div><pre class="prettyprint"   ><p><font size="2"   >The regular expression matching (=~ and !~) is currently an experimental feature. The second operand must be a string literal containing a syntactically valid regular expression. The regular expression syntax supports most of the features of POSIX Extended Regular Expressions, aside from subexpression reuse (\1) and named character classes ([:digit:], [:alpha:], ...). The ability to capture and extract the contents of the matched string and subexpressions has not yet been implemented.</font></p></pre></div><div>规则表达式匹配是一个实验特性, 在1.8的版本中未能测试出来可以正常使用. 使用2.4的版本正常.</div><div>2.4的安装如下 :&nbsp;</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201391391613269/"   >http://blog.163.com/digoal@126/blog/static/163877040201391391613269/</a></div><div>测试 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 ~]# /opt/systemtap/bin/stap -e 'probe begin {if (@1 =~ "^abc") printf("match ^abc\n"); exit()}' "abcdef"</font></div><div><font size="2"   >match ^abc</font></div><div><font size="2"   >[root@db-172-16-3-150 ~]# /opt/systemtap/bin/stap -e 'probe begin {if (@1 =~ "^abc") printf("match ^abc\n"); exit()}' "Habcdef"</font></div><p></p></pre></div><div><br></div><div>5.6.7 Ternary operator</div><pre class="prettyprint"   ><p></p><div><font size="2"   >cond ? exp1 : exp2</font></div><div></div><p></p></pre><div><span style="line-height: 23px;"   >三目操作符, cond真则执行表达式1, 假则执行表达式2</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'probe begin {1==1 ? printf("true\n") : printf("false\n"); exit();}'</font></div><div><font size="2"   >true</font></div><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'probe begin {1==2 ? printf("true\n") : printf("false\n"); exit();}'</font></div><div><font size="2"   >false</font></div><p></p></pre></div><div><br></div><div>5.6.8 Grouping operator</div><pre class="prettyprint"   ><p></p><div><font size="2"   >( exp )</font></div><div></div><p></p></pre><div><span style="line-height: 23px;"   >分组操作符: 括号.</span></div><div><br></div><div>5.6.9 Function call</div><div><span style="line-height: 23px;"   >函数调用语法</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >General syntax:</font></div><div><font size="2"   >fn ([ arg1, arg2, ... ])</font></div><p></p></pre></div><div><br></div><div>5.6.10 $ptr-&gt;member</div><pre class="prettyprint"   ><p></p><div><font size="2"   >ptr is a kernel pointer available in a probed context.</font></div><div></div><p></p></pre><div><span style="line-height: 23px;"   >结构指针, 取结构内数据的操作符. 用于探针对应的函数的上下文变量</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >-&gt;</font></div><div></div><p></p></pre></div><div>5.6.11 Pointer typecasting</div><div><pre class="prettyprint"   ><p><font size="2"   >Typecasting is supported using the @cast() operator. A script can define a pointer type for a long value, then access type members using the same syntax as with $target variables. After a pointer is saved into a script integer variable, the translator loses the necessary type information to access members from that pointer. The @cast() operator tells the translator how to read a pointer.</font></p></pre></div><div>因为systemtap脚本中支持的变量类型有限, 对于结构数据的指针, 在systemtap中可以存储为整型变量(地址). 这种数据转存将导致类型丢失, 所以为了从这个整型变量中的得到它存储的指针对应的结构值, 就需要进行类型转换.</div><div>类型转换的语法<span style="line-height: 23px;"   >@cast(p, "type_name"[, "module"]), 转换后可以进行与$target一样的操作, 如suffix $$, -&gt;等.</span></div><div><br></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >The following statement interprets p as a pointer to a struct or union named type_name and dereferences the member value:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >@cast(p, "type_name"[, "module"])-&gt;member</font></div><div><font size="2"   >The optional module parameter tells the translator where to look for information about that type. You can specify multiple modules as a list with colon (:) separators. If you do not specify the module parameter, the translator defaults to either the probe module for dwarf probes or to kernel for functions and all other probe types.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The following statement retrieves the parent PID from a kernel task_struct:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >@cast(pointer, "task_struct", "kernel")-&gt;parent-&gt;tgid</font></div><div><font size="2"   >The translator can create its own module with type information from a header surrounded by angle brackets (&lt; &gt;) if normal debugging information is not available. For kernel headers, prefix it with kernel to use the appropriate build system. All other headers are built with default GCC parameters into a user module. The following statements are examples.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >@cast(tv, "timeval", "&lt;sys/time.h&gt;")-&gt;tv_sec</font></div><div><font size="2"   >@cast(task, "task_struct", "kernel&lt;linux/sched.h&gt;")-&gt;tgid</font></div><div><font size="2"   >In guru mode, the translator allows scripts to assign new values to members of typecasted pointers.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Typecasting is also useful in the case of void* members whose type might be determinable at run time.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >probe foo {</font></div><div><font size="2"   >&nbsp; &nbsp;if ($var-&gt;type == 1) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; value = @cast($var-&gt;data, "type1")-&gt;bar</font></div><div><font size="2"   >&nbsp; &nbsp;} else {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; value = @cast($var-&gt;data, "type2")-&gt;baz</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;print(value)</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>举例 :&nbsp;</div><div>我们选取一个DWARF-based 探针</div><pre class="prettyprint"   ><p></p><div><font size="2"   >kernel.function("icmp_echo@net/ipv4/icmp.c:843")</font></div><div></div><p></p></pre><div><span style="line-height: 23px;"   >输出这个探针中有哪些上下文变量.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'probe kernel.function("icmp_echo") {printf("%s\n", $$vars); exit();}'</font></div><div><font size="2"   >skb=0xffff81021b4e7280</font></div><p></p></pre></div><div>这个探针中只有一个变量skb. 使用suffix $$输出它的结构数据.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'probe kernel.function("icmp_echo") {printf("%s\n", $$vars$$); exit();}'</font></div><div><font size="2"   >skb={.next=0x0, .prev=0x0, .sk=0x0, .tstamp={.off_sec=1381205475, .off_usec=140535}, .dev=0xffffffff80352b80, .input_dev=0xffffffff80352b80, .h={.th=0xffff8101eda8a424, .uh=0xffff8101eda8a424, .icmph=0xffff8101eda8a424, .igmph=0xffff8101eda8a424, .ipiph=0xffff8101eda8a424, .ipv6h=0xffff8101eda8a424, .raw="}, .nh={.iph=0xffff8101eda8a410, .ipv6h=0xffff8101eda8a410, .arph=0xffff8101eda8a410, .raw="E"}, .mac={.raw=""}, .dst=0xffff81011d1dfe40, .sp=0x0, .cb="", .len=56, .data_len=0, .mac_len=14, .csum=330099</font></div><p></p></pre></div><div>下面要把skb这个变量赋予给stap中的脚本变量, 前面已经说了, 这样做的话, stap中的脚本变量会丢失类型. 因为脚本中存储的是整型.</div><div>可以使用%p输出这个地址.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'probe kernel.function("icmp_echo") {var=$skb; printf("%p\n", var); exit();}'</font></div><div><font size="2"   >0xffff81011a4a5e80</font></div><p></p></pre></div><div>如果不做类型转换, var不能使用$skb的其他用法, 例如$skb$$</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'probe kernel.function("icmp_echo") {var=$skb; printf("%s\n", var$$); exit();}'</font></div><div><font size="2"   >WARNING: never-assigned local variable 'var$$' (alternatives: var): identifier 'var$$' at &lt;input&gt;:1:62</font></div><div><font size="2"   >&nbsp;source: probe kernel.function("icmp_echo") {var=$skb; printf("%s\n", var$$); exit();}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   >WARNING: Eliding assignment to var at operator '=' at &lt;input&gt;:1:40</font></div><div><font size="2"   >WARNING: Eliding side-effect-free expression : identifier 'var' at :1:37</font></div><div><font size="2"   >&nbsp;source: probe kernel.function("icmp_echo") {var=$skb; printf("%s\n", var$$); exit();}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><p></p></pre></div><div><br></div><div>下面要对var进行转换, 首先要知道skb这个变量的类型, 我们找到源码&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 23px;"   >/usr/src/debug/kernel-2.6.18/linux-2.6.18-348.12.1.el5.x86_64/</span><span style="line-height: 23px;"   >net/ipv4/icmp.c</span></font></div><div><font size="2"   >static void icmp_echo(struct sk_buff *skb)</font></div><p></p></pre></div><div>所以skb对应的是结构<span style="line-height: 23px;"   >sk_buff</span><span style="line-height: 23px;"   >&nbsp;的指针.</span></div><div>类型转换@cast(var, "sk_buff")</div><div>如果要加上头文件位置的话, 不要使用全路径<span style="line-height: 23px;"   >/usr/src/debug/kernel-2.6.18/linux-2.6.18-348.12.1.el5.x86_64/</span><span style="line-height: 23px;"   >net/ipv4/icmp.c</span></div><div><span style="line-height: 23px;"   >请使用如下 :&nbsp;</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >@cast(var,"sk_buff","kernel&lt;linux/skbuff.h&gt;")</font></div><div></div><p></p></pre><div><span style="line-height: 23px;"   >例子 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'probe kernel.function("icmp_echo") {var=$skb; printf("%s\n", @cast(var,"sk_buff","kernel&lt;linux/skbuff.h&gt;")$$); exit();}'</font></div><div><font size="2"   >{.next=0x0, .prev=0x0, .sk=0x0, .tstamp={.off_sec=1381207237, .off_usec=54643}, .dev=0xffffffff80352b80, .input_dev=0xffffffff80352b80, .h={.th=0xffff810119b3c024, .uh=0xffff810119b3c024, .icmph=0xffff810119b3c024, .igmph=0xffff810119b3c024, .ipiph=0xffff810119b3c024, .ipv6h=0xffff810119b3c024, .raw="}, .nh={.iph=0xffff810119b3c010, .ipv6h=0xffff810119b3c010, .arph=0xffff810119b3c010, .raw="E"}, .mac={.raw=""}, .dst=0xffff8101eedb2e00, .sp=0x0, .cb="", .len=56, .data_len=0, .mac_len=14, .csum=119797980,&nbsp;</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'probe kernel.function("icmp_echo") {var=$skb; printf("%s\n", @cast(var,"sk_buff")$$); exit();}'</font></div><div><font size="2"   >{.next=0x0, .prev=0x0, .sk=0x0, .tstamp={.off_sec=1381207264, .off_usec=581377}, .dev=0xffffffff80352b80, .input_dev=0xffffffff80352b80, .h={.th=0xffff8101ef486824, .uh=0xffff8101ef486824, .icmph=0xffff8101ef486824, .igmph=0xffff8101ef486824, .ipiph=0xffff8101ef486824, .ipv6h=0xffff8101ef486824, .raw="}, .nh={.iph=0xffff8101ef486810, .ipv6h=0xffff8101ef486810, .arph=0xffff8101ef486810, .raw="E"}, .mac={.raw=""}, .dst=0xffff8101eedb2e00, .sp=0x0, .cb="", .len=56, .data_len=0, .mac_len=14, .csum=4249748145</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'probe kernel.function("icmp_echo") {var=$skb; printf("%p\n", @cast(var,"sk_buff")-&gt;next); exit();}'</font></div><div><font size="2"   >0x0</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'probe kernel.function("icmp_echo") {var=$skb; printf("%d\n", @cast(var,"sk_buff")-&gt;tstamp-&gt;off_sec); exit();}'<br>1381207332</font></div><p></p></pre></div><div><br></div><div>5.6.12 &lt;value&gt; in &lt;array_name&gt;</div><pre class="prettyprint"   ><p></p><div><font size="2"   >This expression evaluates to true if the array contains an element with the specified index.</font></div><div></div><p></p></pre><div><span style="line-height: 23px;"   >判断value是否是数组的下标, 返回0假 或 1真;</span></div><div>举例 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'global arr1; probe begin {arr1["a"]=1; arr1["b"]=2; printf("%d\n", @1 in arr1); exit();}' "a"&nbsp;</font></div><div><font size="2"   >1</font></div><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'global arr1; probe begin {arr1["a"]=1; arr1["b"]=2; printf("%d\n", @1 in arr1); exit();}' "b"&nbsp;</font></div><div><font size="2"   >1</font></div><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'global arr1; probe begin {arr1["a"]=1; arr1["b"]=2; printf("%d\n", @1 in arr1); exit();}' "c"&nbsp;</font></div><div><font size="2"   >0</font></div><p></p></pre></div><div><br></div><div>5.6.13 [ &lt;value&gt;, ... ] in &lt;array_name&gt;</div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >The number of index values must match the number of indexes previously specified.</font></div></div><div></div><p></p></pre><div><span style="line-height: 23px;"   >如果数组的下标是多元下标, 那么需要使用这种语法来匹配 :&nbsp;</span></div></div><div><span style="line-height: 23px;"   >[ &lt;value&gt;, ... ] in &lt;array_name&gt;</span></div><div>下标个数必须相同. 否则报错</div><div>举例 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'global arr1; probe begin {arr1["a","b","c"]=1; arr1["b","a","c"]=2; printf("%d\n", ["b", "a", "c"] in arr1); exit();}'</font></div><div><font size="2"   >1</font></div><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'global arr1; probe begin {arr1["a","b","c"]=1; arr1["b","a","c"]=2; printf("%d\n", ["a", "c", "b"] in arr1); exit();}'</font></div><div><font size="2"   >0</font></div><p></p></pre></div><div>如果下标个数不一致, 将报错</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'global arr1; probe begin {arr1["a","b","c"]=1; arr1["b","a","c"]=2; printf("%d\n", ["a", "c"] in arr1); exit();}'</font></div><div><font size="2"   >semantic error: inconsistent arity (3 vs 2): identifier 'arr1' at &lt;input&gt;:1:98</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global arr1; probe begin {arr1["a","b","c"]=1; arr1["b","a","c"]=2; printf("%d\n", ["a", "c"] in arr1); exit();}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >semantic error: arity 3 first inferred here: identifier 'arr1' at :1:27</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global arr1; probe begin {arr1["a","b","c"]=1; arr1["b","a","c"]=2; printf("%d\n", ["a", "c"] in arr1); exit();}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div><p></p></pre></div><div>同样, 在定义数组时, 也必须与第一次定义一致, 所以以下操作也是错误的 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 memory]# stap -e 'global arr1; probe begin {arr1["a","b","c"]=1; arr1["b","a"]=2; exit();}'</font></div><div><font size="2"   >semantic error: inconsistent arity (3 vs 2): identifier 'arr1' at &lt;input&gt;:1:48</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global arr1; probe begin {arr1["a","b","c"]=1; arr1["b","a"]=2; exit();}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >semantic error: arity 3 first inferred here: identifier 'arr1' at :1:27</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global arr1; probe begin {arr1["a","b","c"]=1; arr1["b","a"]=2; exit();}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div><p></p></pre></div><div><br></div><div>6. stap参数传入</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Literals passed in from the stap command line</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Literals are either strings enclosed in double quotes ('' '') or integers.</font></div><div><font size="2"   >Script arguments at the end of a command line are expanded as literals.&nbsp;</font></div><div><font size="2"   >You can use these in all contexts where literals are accepted.&nbsp;</font></div><div><font size="2"   >A reference to a nonexistent argument number is an error.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >5.7.1 $1 ... $&lt;NN&gt; for literal pasting 传入整型用$</font></div><div><font size="2"   >Use $1 ... $&lt;NN&gt; for pasting the entire argument string into the input stream, which will be further lexically tokenized.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >5.7.2 @1 ... @&lt;NN&gt; for strings 传入字符串用@</font></div><div><font size="2"   >Use @1 ... @&lt;NN&gt; for casting an entire argument as a string literal.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >5.7.3 Examples</font></div><div><font size="2"   >For example, if the following script named example.stp</font></div><div><font size="2"   >probe begin { printf("%d, %s\n", $1, @2) }</font></div><div><font size="2"   >is invoked as follows</font></div><div><font size="2"   ># stap example.stp '5+5' mystring</font></div><div><font size="2"   >then 5+5 is substituted for $1 and "mystring" for @2. The output will be</font></div><div><font size="2"   >10, mystring</font></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 23px;" rel="nofollow" href="https://sourceware.org/systemtap/langref/Language_elements.html"   >https://sourceware.org/systemtap/langref/Language_elements.html</a></div><div>2.&nbsp;<a style="line-height: 23px;" href="http://blog.163.com/digoal@126/blog/static/16387704020138392759478/"   >http://blog.163.com/digoal@126/blog/static/16387704020138392759478/</a></div><div>3.&nbsp;<a style="line-height: 23px;" rel="nofollow" href="http://en.wikipedia.org/wiki/Unary_operation"   >http://en.wikipedia.org/wiki/Unary_operation</a></div><div>4.&nbsp;<a style="line-height: 23px;" rel="nofollow" href="http://en.wikipedia.org/wiki/Signed_number_representations"   >http://en.wikipedia.org/wiki/Signed_number_representations</a></div><div>5.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/163877040201391391613269/"   >http://blog.163.com/digoal@126/blog/static/163877040201391391613269/</a></div><div>6.&nbsp;</div><div>/usr/src/linux/include/linux/skbuff.h</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >struct sk_buff {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* These two members must be first. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct sk_buff &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*next;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct sk_buff &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*prev;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct sock &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *sk;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct skb_timeval &nbsp; &nbsp; &nbsp;tstamp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct net_device &nbsp; &nbsp; &nbsp; *dev;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct net_device &nbsp; &nbsp; &nbsp; *input_dev;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; union {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct tcphdr &nbsp; *th;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct udphdr &nbsp; *uh;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct icmphdr &nbsp;*icmph;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct igmphdr &nbsp;*igmph;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct iphdr &nbsp; &nbsp;*ipiph;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct ipv6hdr &nbsp;*ipv6h;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned char &nbsp; *raw;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; } h;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; union {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct iphdr &nbsp; &nbsp;*iph;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct ipv6hdr &nbsp;*ipv6h;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct arphdr &nbsp; *arph;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned char &nbsp; *raw;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; } nh;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; union {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned char &nbsp; *raw;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; } mac;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct &nbsp;dst_entry &nbsp; &nbsp; &nbsp; *dst;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; struct &nbsp;sec_path &nbsp; &nbsp; &nbsp; &nbsp;*sp;</font></div></div><div><font size="2"   >... 略</font></div><p></p></pre></div><div>6.&nbsp;</div><div>/usr/src/debug/kernel-2.6.18/linux-2.6.18-348.12.1.el5.x86_64/<span style="line-height: 23px;"   >net/ipv4/icmp.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >static void icmp_echo(struct sk_buff *skb)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!sysctl_icmp_echo_ignore_all) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct icmp_bxm icmp_param;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icmp_param.data.icmph &nbsp; &nbsp; &nbsp;= *skb-&gt;h.icmph;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icmp_param.data.icmph.type = ICMP_ECHOREPLY;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icmp_param.skb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = skb;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icmp_param.offset &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icmp_param.data_len &nbsp; &nbsp; &nbsp; &nbsp;= skb-&gt;len;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icmp_param.head_len &nbsp; &nbsp; &nbsp; &nbsp;= sizeof(struct icmphdr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icmp_reply(&amp;icmp_param, skb);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >}</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>