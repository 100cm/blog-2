<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap Associative array Data Type</h2>
	<h5 id="">2013-10-09 10:35:59&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013999511424/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>数组变量在stap启动时以哈希表形式初始化, 在handler中使用数组时不需要再动态创建.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Associative arrays are implemented as hash tables with a maximum size set at startup.&nbsp;</font></div><div><font size="2"   >Associative arrays are too large to be created dynamically for individual probe handler runs, so they must be declared as global.</font></div><p></p></pre></div><div>由于数组类型占用的空间明显大于数字或字符串类型, 考虑到安全, systemtap设计时就不允许数组作为handler本地变量动态创建. 所以数组变量必须声明为全局变量.</div><div><br></div><div>数组的基本操作就是设置和读取元素值</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >The basic operations for arrays are setting and looking up elements.&nbsp;</font></div><div><font size="2"   >These operations are expressed in awk syntax:&nbsp;</font></div><div><font size="2"   >the array name followed by an opening bracket ([), a comma-separated list of up to nine index index expressions, and a closing bracket (]).&nbsp;</font></div><p></p></pre></div><div>使用语法</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >arrvar[idx1, ... idxn]</font></div><div><font size="2"   >Each index expression may be a string or a number, as long as it is consistently typed throughout the script.</font></div><p></p></pre></div><div>数组的索引, 元素值各自必须一致, 否则会报错, 例如 :&nbsp;</div><div>arr1的索引和元素都不一致 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin {arr1["a"]=1;arr1[1]="x";exit()}'</font></div><div><font size="2"   >semantic error: type mismatch (string vs. long): identifier 'arr1' at &lt;input&gt;:1:39</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global arr1; probe begin {arr1["a"]=1;arr1[1]="x";exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >semantic error: type was first inferred here (long): identifier 'arr1' at :1:27</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global arr1; probe begin {arr1["a"]=1;arr1[1]="x";exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >semantic error: type mismatch (long vs. string): number '1' at :1:44</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global arr1; probe begin {arr1["a"]=1;arr1[1]="x";exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >semantic error: type mismatch (long vs. string): identifier 'arr1' at :1:39</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global arr1; probe begin {arr1["a"]=1;arr1[1]="x";exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div><p></p></pre></div><div>arr1的元素类型不一致 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin {arr1["a"]=1;arr1["b"]="x";exit()}'</font></div><div><font size="2"   >semantic error: type mismatch (string vs. long): identifier 'arr1' at &lt;input&gt;:1:39</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global arr1; probe begin {arr1["a"]=1;arr1["b"]="x";exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >semantic error: type was first inferred here (long): identifier 'arr1' at :1:27</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; source: global arr1; probe begin {arr1["a"]=1;arr1["b"]="x";exit()}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Pass 2: analysis failed. &nbsp;Try again with another '--vp 01' option.</font></div><p></p></pre></div><div>元素和索引类型一致, 可以正常使用.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin {arr1["a"]=1;arr1["b"]=2;exit()}'</font></div><div><font size="2"   >arr1["b"]=0x2</font></div><div><font size="2"   >arr1["a"]=0x1</font></div><p></p></pre></div></div><div><br></div><div>7.1 Examples</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># Increment the named array slot:</font></div><div><font size="2"   >foo [4,"hello"] ++</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ># Update a statistic:</font></div><div><font size="2"   >processusage [uid(),execname()] ++</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ># Set a timestamp reference point:</font></div><div><font size="2"   >times [tid()] = get_cycles()</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ># Compute a timestamp delta:</font></div><div><font size="2"   >delta = get_cycles() - times [tid()]</font></div><p></p></pre></div><div>数组的索引一般选取pid, execname, uid, tid等, 以便做唯一性区分.</div><div>数组的索引含义有点类似数据库中的primary key.&nbsp;</div><div>数组的元素value 含义则类似K-V中的value.</div><div><br></div><div>7.2 Types of values</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Array elements may be set to a number, a string, or an aggregate.&nbsp;</font></div><div><font size="2"   >The type must be consistent throughout the use of the array.&nbsp;</font></div><div><font size="2"   >The first assignment to the array defines the type of the elements.&nbsp;</font></div><div><font size="2"   >Unset array elements may be fetched and return a null value (zero or empty string) as appropriate, but they are not seen by a membership test.</font></div><p></p></pre></div><div>数组的元素值类型, 可以是数字, 字符串, 或者统计类型</div><div>统计类型参考 :&nbsp;</div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020138310438924/"   >http://blog.163.com/digoal@126/blog/static/16387704020138310438924/</a></div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020138333731979/"   >http://blog.163.com/digoal@126/blog/static/16387704020138333731979/</a></div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020138392759478/"   >http://blog.163.com/digoal@126/blog/static/16387704020138392759478/</a></div><div>不管存储何种类型, 一个数组中所有元素的类型必须一致, 例如都存储数字.</div><div>当然一个数组的索引的类型也必须一致.</div><div>例子见本文开头部分.</div><div>数组元素delete后, 清理为改元素类型的原始状态. 数字0, 字符串空"", 统计类型空.</div><div>例子 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin {arr1[1]=1; delete arr1[1]; println(arr1[1]); exit()}'</font></div><div><font size="2"   >0</font></div></div><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin {arr1[1]="hello"; delete arr1[1]; println(arr1[1]); exit()}'</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1; probe begin {arr1[1] &lt;&lt;&lt; 123; delete arr1[1]; println(@count(arr1[1])); exit()}'</font></div><div><font size="2"   >0</font></div></div><p></p></pre></div><div><br></div><div>7.3 Array capacity</div><pre class="prettyprint"   ><p></p><div><font size="2"   >Array sizes can be specified explicitly or allowed to default to the maximum size as defined by MAXMAPENTRIES.&nbsp;</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >参考</span></div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201381021752228/"   >http://blog.163.com/digoal@126/blog/static/163877040201381021752228/</a></div><div>数组中可以存储多少个元素可以在声明全局变量时指定或者由<span style="line-height: 28px;"   >MAXMAPENTRIES参数决定(默认2048).</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >You can explicitly specify the size of an array as follows:</font></div><div><font size="2"   >global ARRAY[&lt;size&gt;]</font></div><div><font size="2"   >If you do not specify the size parameter, then the array is created to hold MAXMAPENTRIES number of elements.</font></div><p></p></pre></div><div>默认情况下超出存储的个数会报错. 例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1[10]; probe begin {for(i=0;i&lt;100;i++) arr1[i]=i; exit()}'</font></div><div><font size="2"   >ERROR: Array overflow, check size limit (10) near identifier 'arr1' at &lt;input&gt;:1:50</font></div><div><font size="2"   >WARNING: Number of errors: 1, skipped probes: 0</font></div><div><font size="2"   >WARNING: /usr/bin/staprun exited with status: 1</font></div><div><font size="2"   >Pass 5: run failed. &nbsp;Try again with another '--vp 00001' option.</font></div><p></p></pre></div><div><br></div><div>7.4 Array wrapping</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Arrays may be wrapped using the percentage symbol (%) causing previously entered elements to be overwritten if more elements are inserted than the array can hold.&nbsp;</font></div><div><font size="2"   >This works for both regular and statistics typed arrays.</font></div><div><font size="2"   >You can mark arrays for wrapping as follows:</font></div><div><font size="2"   >global ARRAY1%[&lt;size&gt;], ARRAY2%</font></div><p></p></pre></div><div>前面说的数组变量<span style="line-height: 28px;"   >超出存储的个数会报错, 有一种使用场景是, 对于前面的元素进行覆盖. 而不报错.</span></div><div><span style="line-height: 28px;"   >类似mongodb中的capped collection.</span></div><div><span style="line-height: 28px;"   >例如 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-39 ~]# stap -e 'global arr1%[10]; probe begin {for(i=0;i&lt;100;i++) arr1[i]=i; exit()}'</font></div><div><font size="2"   >arr1[99]=0x63</font></div><div><font size="2"   >arr1[98]=0x62</font></div><div><font size="2"   >arr1[97]=0x61</font></div><div><font size="2"   >arr1[96]=0x60</font></div><div><font size="2"   >arr1[95]=0x5f</font></div><div><font size="2"   >arr1[94]=0x5e</font></div><div><font size="2"   >arr1[93]=0x5d</font></div><div><font size="2"   >arr1[92]=0x5c</font></div><div><font size="2"   >arr1[91]=0x5b</font></div><div><font size="2"   >arr1[90]=0x5a</font></div><p></p></pre></div><div><br></div><div>7.5 Iteration, foreach</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Like awk, SystemTap's foreach creates a loop that iterates over key tuples of an array, not only values.&nbsp;</font></div><div><font size="2"   >The iteration may be sorted by any single key or a value by adding an extra plus symbol (+) or minus symbol (-) to the code or limited to only a few elements with the limit keyword.&nbsp;</font></div><div><font size="2"   >The following are examples.</font></div><div><font size="2"   ># Simple loop in arbitrary sequence:</font></div><div><font size="2"   >foreach ([a,b] in foo)</font></div><div><font size="2"   >&nbsp; &nbsp; fuss_with(foo[a,b])</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ># Loop in increasing sequence of value:</font></div><div><font size="2"   >foreach ([a,b] in foo+) { ... }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ># Loop in decreasing sequence of first key:</font></div><div><font size="2"   >foreach ([a-,b] in foo) { ... }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ># Print the first 10 tuples and values in the array in decreasing sequence</font></div><div><font size="2"   >foreach (v = [i,j] in foo- limit 10)</font></div><div><font size="2"   >&nbsp; &nbsp; printf("foo[%d,%s] = %d\n", i, j, v)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >foreach中可以使用break以及continue语句</font></div><div><font size="2"   >The break and continue statements also work inside foreach loops.&nbsp;</font></div><div><font size="2"   >Since arrays can be large but probe handlers must execute quickly, you should write scripts that exit iteration early, if possible.&nbsp;</font></div><div><font size="2"   >foreach中不允许修改数组元素的值, 目的是为了简化handler长度操作, 降低handler对程序的影响.</font></div><div><font size="2"   >For simplicity, SystemTap forbids any modification of an array during iteration with a foreach.</font></div><p></p></pre></div><div>详细的foreach用法参考 :&nbsp;</div><div><a href="http://blog.163.com/digoal@126/blog/static/1638770402013997490563/"   >http://blog.163.com/digoal@126/blog/static/1638770402013997490563/</a></div><div><br></div><div>7.6 Deletion</div><pre class="prettyprint"   ><p></p><div><font size="2"   >The delete statement can either remove a single element by index from an array or clear an entire array at once.&nbsp;</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >详细的DELETE用法参考 :&nbsp;</span></div><div><a href="http://blog.163.com/digoal@126/blog/static/1638770402013997490563/"   >http://blog.163.com/digoal@126/blog/static/1638770402013997490563/</a></div><div><br></div><div>[参考]</div><div>1.&nbsp;<a style="line-height: 28px;" rel="nofollow" href="https://sourceware.org/systemtap/langref/Associative_arrays.html"   >https://sourceware.org/systemtap/langref/Associative_arrays.html</a></div><div><div style="line-height: 28px;"   >2.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/16387704020138310438924/"   >http://blog.163.com/digoal@126/blog/static/16387704020138310438924/</a></div><div style="line-height: 28px;"   >3.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/16387704020138333731979/"   >http://blog.163.com/digoal@126/blog/static/16387704020138333731979/</a></div><div style="line-height: 28px;"   >4.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/16387704020138392759478/"   >http://blog.163.com/digoal@126/blog/static/16387704020138392759478/</a></div></div><div style="line-height: 28px;"   >5.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/163877040201381021752228/"   >http://blog.163.com/digoal@126/blog/static/163877040201381021752228/</a></div><div style="line-height: 28px;"   >6.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/1638770402013997490563/"   >http://blog.163.com/digoal@126/blog/static/1638770402013997490563/</a></div><wbr></div>
	</div>
</div>
</body>
</html>