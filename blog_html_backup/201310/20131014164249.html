<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Systemtap : stap PROCESSING 5 steps introduce</h2>
	<h5 id="">2013-10-14 16:42:49&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201391434530674/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>stap处理stp时, 分5步进行, 以下取自man stap :&nbsp;</div><div>第一步 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 28px;"   ><font size="2"   >The translator begins pass 1 by parsing the given input script, and all scripts (files named *.stp) found in a tapset directory.&nbsp;</font></span></div><div><font size="2"   >The directories listed with -I are processed in sequence, each processed in "guru mode".&nbsp;</font></div><div><font size="2"   >"guru mode" : Enable parsing of unsafe expert-level constructs like embedded C.</font></div><div><font size="2"   >For each directory, a number of subdirectories are also searched.&nbsp;</font></div><div><font size="2"   ><u>These subdirectories are derived from the selected kernel version (the -R option), in order to allow more kernel-version-specific scripts to override less specific ones.</u>&nbsp;</font></div><div><font size="2"   >For example, for a kernel version 2.6.12-23.FC3 the following patterns would be searched, in sequence:&nbsp;</font></div><div><font size="2"   >&nbsp; 2.6.12-23.FC3/*.stp,&nbsp;</font></div><div><font size="2"   >&nbsp; 2.6.12/*.stp,&nbsp;</font></div><div><font size="2"   >&nbsp; 2.6/*.stp,&nbsp;</font></div><div><font size="2"   >and finally *.stp Stopping the translator after pass 1 causes it to print the parse trees.</font></div><p></p></pre></div><div><div>第一步做的事情是 :&nbsp;</div><div>解析stap输入脚本, 或者-e中指定的内容, 以及tapset库, -I检索路径中的*.stp文件.</div><div>如下 :&nbsp;</div><div>parsed user script and 95 library script.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 ~]# stap --vp 50000 -I /tmp -e 'probe syscall.read {printf("hello i am digoal.\n"); exit()}'</font></div><div><font size="2"   >Parsed kernel "/lib/modules/2.6.32-358.el6.x86_64/build/.config", containing 3166 tuples</font></div><div><font size="2"   >Parsed kernel /lib/modules/2.6.32-358.el6.x86_64/build/Module.symvers, which contained 5541 vmlinux exports</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/x86_64/*.stp ", found: 10, processed: 10</font></div><div><font size="2"   >Searched: " /usr/share/systemtap/tapset/*.stp ", found: 82, processed: 82</font></div><div><font size="2"   >Searched: " /tmp/2.6.32-358.el6.x86_64/*.stp ", found: 1, processed: 1</font></div><div><font size="2"   >Searched: " /tmp/2.6.32/*.stp ", found: 1, processed: 1</font></div><div><font size="2"   >Searched: " /tmp/2.6/*.stp ", found: 1, processed: 1</font></div><div><font size="2"   >Pass 1: parsed user script and 95 library script(s) using 203480virt/31780res/3104shr/29416data kb, in 290usr/20sys/307real ms.</font></div><div><font size="2"   >hello i am digoal.</font></div><p></p></pre></div></div><div><span style="line-height: 28px;"   >第一步中, -R在测试时发现一个BUG, 参见 :&nbsp;</span></div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020139142437763/"   >http://blog.163.com/digoal@126/blog/static/16387704020139142437763/</a></div><div><br></div><div><span style="line-height: 28px;"   >第二步 :&nbsp;</span></div><div>分析 stap"执行脚本或者-e中指定内容" 包含的符号(指变量,函数,探针, 条件预编译, 宏 ,符号(probe,function, global..等语法型字符)等) 以及变量类型(猜或指定类型如函数返回值和参数).</div><div>未能直接分析出来的符号, 将通过第一步得到的tapset库进行匹配, 只要匹配到了, 就会把对应的stp(探针库), stpm(宏库)文件选择进来.&nbsp;</div><div>直到所有的符号都分析匹配完.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >In pass 2, the translator analyzes the input script to resolve symbols and types.&nbsp;</font></div><div><font size="2"   >References to variables, functions, and probe aliases that are unresolved internally are satisfied by searching through the parsed tapset script files.&nbsp;</font></div><div><font size="2"   >If any tapset script file is selected because it defines an unresolved symbol, then the entirety of that file is added to the translator's resolution queue.&nbsp;</font></div><div><font size="2"   >This process iterates until all symbols are resolved and a subset of tapset script files is selected.</font></div><p></p></pre></div><div>接下来校验stap脚本(或-e内容)中用到的所有的探针, 以及探针handler中的target端变量.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Next, all probe point descriptions are validated against the wide variety supported by the translator.&nbsp;</font></div><div><font size="2"   >Probe points that refer to code locations ("synchronous probe points") require the appropriate kernel debugging information to be installed.&nbsp;</font></div><div><font size="2"   >In the associated probe handlers, target-side variables (whose names begin with "$") are found and have their run-time locations decoded.</font></div><p></p></pre></div><div>如果未使用stap -u选项, 那么接下来要做的是优化脚本. 移除未使用的变量, 表达式, 函数等.</div><div>具体的优化规则参见 :&nbsp;</div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020138109459201/"   >http://blog.163.com/digoal@126/blog/static/16387704020138109459201/</a></div><div><pre class="prettyprint"   ><div><span style="line-height: 28px;"   ><font size="2"   >Next, all probes and functions are analyzed for optimization opportunities, in order to remove variables, expressions, and functions that have no useful value and no side-effect.&nbsp;</font></span></div><div><font size="2"   >Embedded-C functions are assumed to have side-effects unless they include the magic string /* pure */.&nbsp;</font></div><div><font size="2"   >Since this optimization can hide latent code errors such as type mismatches or invalid $target variables, it sometimes may be useful to disable the optimizations with the -u option.</font></div><p></p></pre></div><div>pass2最后要做的是, 根据上下文(例如语境或操作符)推测所有变量的类型, 函数的返回值类型和参数类型, 数组中存储的类型, 数组的索引类型.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Finally, all variable, function, parameter, array, and index types are inferred from context (literals and operators).&nbsp;</font></div><div><font size="2"   >Stopping the translator after pass 2 causes it to list all the probes, functions, and variables, along with all inferred types.&nbsp;</font></div><div><font size="2"   >Any inconsistent or unresolved types cause an error.</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >第二步示例输出如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 ~]# stap --vp 05000 -I /tmp -e 'probe syscall.read {printf("hello i am digoal.\n"); exit()}'</font></div><div><font size="2"   >Attempting to extract kernel debuginfo build ID from /lib/modules/2.6.32-358.el6.x86_64/build/vmlinux.id</font></div><div><font size="2"   >Attempting to extract kernel debuginfo build ID from /sys/kernel/notes</font></div><div><font size="2"   >blacklist regexps:</font></div><div><font size="2"   >blfn: ^(atomic_notifier_call_chain|default_do_nmi|__die|die_nmi|do_debug|do_general_protection|do_int3|do_IRQ|do_page_fault|do_sparc64_fault|do_trap|dummy_nmi_callback|flush_icache_range|ia64_bad_break|ia64_do_page_fault|ia64_fault|io_check_error|mem_parity_error|nmi_watchdog_tick|notifier_call_chain|oops_begin|oops_end|program_check_exception|single_step_exception|sync_regs|unhandled_fault|unknown_nmi_error|xen_[gs]et_debugreg|xen_irq_.*|xen_.*_fl_direct.*|check_events|xen_adjust_exception_frame|xen_iret.*|xen_sysret64.*|test_ti_thread_flag.*|inat_get_opcode_attribute|system_call_after_swapgs|.*raw_.*_lock.*|.*raw_.*_unlock.*|.*raw_.*_trylock.*|.*read_lock.*|.*read_unlock.*|.*read_trylock.*|.*write_lock.*|.*write_unlock.*|.*write_trylock.*|.*write_seqlock.*|.*write_sequnlock.*|.*spin_lock.*|.*spin_unlock.*|.*spin_trylock.*|.*spin_is_locked.*|rwsem_.*lock.*|.*mutex_.*lock.*|raw_.*|atomic_.*|atomic64_.*|get_bh|put_bh|.*apic.*|.*APIC.*|.*softirq.*|.*IRQ.*|.*_intr.*|__delay|.*kernel_text.*|get_current|current_.*|.*exception_tables.*|.*setup_rt_frame.*|.*preempt_count.*|preempt_schedule|__switch_to|special_mapping_.*|.*_pte_.*)$</font></div><div><font size="2"   >blfn_ret: ^(do_exit|sys_exit|sys_exit_group)$</font></div><div><font size="2"   >blfile: ^(kernel/kprobes\.c|arch/.*/kernel/kprobes\.c|.*/include/asm/io\.h|.*/include/asm/io_64\.h|.*/include/asm/bitops\.h|drivers/ide/ide-iops\.c|arch/.*/kernel/paravirt\.c|.*/include/asm/paravirt\.h|fs/seq_file\.c)$</font></div><div><font size="2"   >blsection: ^(\.init\.|\.exit\.|\.devinit\.|\.devexit\.|\.cpuinit\.|\.cpuexit\.|\.meminit\.|\.memexit\.)</font></div><div><font size="2"   >dwarf_builder::build for&nbsp;</font></div><div><font size="2"   >parse 'sys_read', func 'sys_read'</font></div><div><font size="2"   >pattern 'kernel' matches module 'kernel'</font></div><div><font size="2"   >focused on module 'kernel' = [0xffffffff81000000-0xffffffff8203c000, bias 0 file /usr/lib/debug/lib/modules/2.6.32-358.el6.x86_64/vmlinux ELF machine |x86_64 (code 62)</font></div><div><font size="2"   >focused on module 'kernel'</font></div><div><font size="2"   >module function cache kernel size 60247</font></div><div><font size="2"   >module function cache kernel hit sys_read</font></div><div><font size="2"   >selected function sys_read</font></div><div><font size="2"   >function cache kernel:fs/read_write.c size 114</font></div><div><font size="2"   >function cache kernel:fs/read_write.c hit sys_read</font></div><div><font size="2"   >selected function sys_read</font></div><div><font size="2"   >probe sys_read@fs/read_write.c:389 kernel reloc=.dynamic pc=0xffffffff811817b0</font></div><div><font size="2"   >die parent cache kernel:fs/read_write.c size 611</font></div><div><font size="2"   >finding location for local 'fd' near address 0xffffffff811817b0, module bias 0</font></div><div><font size="2"   >get_cfa_ops @0xffffffff811817b0, module_start @0xffffffff81000000</font></div><div><font size="2"   >got dwarf cfi bias: 0x0</font></div><div><font size="2"   >found cfa, info: 16 [start: 0xffffffff811817b0, end: 0xffffffff811817b1, nops: 1</font></div><div><font size="2"   >finding location for local 'buf' near address 0xffffffff811817b0, module bias 0</font></div><div><font size="2"   >get_cfa_ops @0xffffffff811817b0, module_start @0xffffffff81000000</font></div><div><font size="2"   >got dwarf cfi bias: 0x0</font></div><div><font size="2"   >found cfa, info: 16 [start: 0xffffffff811817b0, end: 0xffffffff811817b1, nops: 1</font></div><div><font size="2"   >finding location for local 'count' near address 0xffffffff811817b0, module bias 0</font></div><div><font size="2"   >get_cfa_ops @0xffffffff811817b0, module_start @0xffffffff81000000</font></div><div><font size="2"   >got dwarf cfi bias: 0x0</font></div><div><font size="2"   >found cfa, info: 16 [start: 0xffffffff811817b0, end: 0xffffffff811817b1, nops: 1</font></div><div><font size="2"   >finding location for local 'fd' near address 0xffffffff811817b0, module bias 0</font></div><div><font size="2"   >get_cfa_ops @0xffffffff811817b0, module_start @0xffffffff81000000</font></div><div><font size="2"   >got dwarf cfi bias: 0x0</font></div><div><font size="2"   >found cfa, info: 16 [start: 0xffffffff811817b0, end: 0xffffffff811817b1, nops: 1</font></div><div><font size="2"   >finding location for local 'buf' near address 0xffffffff811817b0, module bias 0</font></div><div><font size="2"   >get_cfa_ops @0xffffffff811817b0, module_start @0xffffffff81000000</font></div><div><font size="2"   >got dwarf cfi bias: 0x0</font></div><div><font size="2"   >found cfa, info: 16 [start: 0xffffffff811817b0, end: 0xffffffff811817b1, nops: 1</font></div><div><font size="2"   >finding location for local 'count' near address 0xffffffff811817b0, module bias 0</font></div><div><font size="2"   >get_cfa_ops @0xffffffff811817b0, module_start @0xffffffff81000000</font></div><div><font size="2"   >got dwarf cfi bias: 0x0</font></div><div><font size="2"   >found cfa, info: 16 [start: 0xffffffff811817b0, end: 0xffffffff811817b1, nops: 1</font></div><div><font size="2"   >deleting module_cache</font></div><div><font size="2"   >Eliding side-effect-free empty block operator '{' at /usr/share/systemtap/tapset/syscalls2.stp:676:1</font></div><div><font size="2"   >Flattening nested block operator '{' at &lt;input&gt;:1:20</font></div><div><font size="2"   >Pass 2: analyzed script: 1 probe(s), 1 function(s), 0 embed(s), 0 global(s) using 358144virt/132372res/79236shr/53812data kb, in 620usr/40sys/655real ms.</font></div><div><font size="2"   >hello i am digoal.</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 28px;"   >第三步 :&nbsp;</span></div><div><span style="line-height: 28px;"   >将以上解析好的stap脚本转换成c代码.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >In pass 3, the translator writes C code that represents the actions of all selected script files, and creates a Makefile to build that into a kernel object.&nbsp;</font></div><div><font size="2"   >These files are placed into a temporary directory.&nbsp;</font></div><div><font size="2"   >Stopping the translator at this point causes it to print the contents of the C file.</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >第三步示例输出如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 ~]# stap --vp 00500 -I /tmp -e 'probe syscall.read {printf("hello i am digoal.\n"); exit()}'</font></div><div><font size="2"   >Pass 3: using cached /root/.systemtap/cache/e8/stap_e878009262b7836eb07f0b5a0bf0705e_970.c</font></div><div><font size="2"   >hello i am digoal.</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 28px;"   >第四步 :&nbsp;</span></div><div>使用第三步生成的c文件创建linux内核对象文件(.ko).</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >In pass 4, the translator invokes the Linux kernel build system to create the actual kernel object file.&nbsp;</font></div><div><font size="2"   >This involves running make in the temporary directory, and requires a kernel module build system (headers, config and Makefiles) to be installed in the usual spot /lib/modules/VERSION/build.&nbsp;</font></div><div><font size="2"   >Stopping the translator after pass 4 is the last chance before running the kernel object.&nbsp;</font></div><div><font size="2"   >This may be useful if you want to archive the file.</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >第四步示例输出如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 ~]# stap --vp 00050 -I /tmp -e 'probe syscall.read {printf("hello i am digoal.\n"); exit()}'</font></div><div><font size="2"   >Pass 4: using cached /root/.systemtap/cache/e8/stap_e878009262b7836eb07f0b5a0bf0705e_970.ko</font></div><div><font size="2"   >hello i am digoal.</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 28px;"   >第五步 :&nbsp;</span></div><div><span style="line-height: 28px;"   >调用</span><span style="line-height: 28px;"   >staprun, 将ko文件加载到内核中, 并与之通讯, 拷贝这个内核对象跟踪到的数据到临时文件中. 直到stap运行结束或受到中断请求信号.</span></div><div><span style="line-height: 28px;"   >最后staprun 从内核中卸载这个ko模块, 并且清除整个stap过程产生的临时文件.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >In pass 5, the translator invokes the systemtap auxiliary program staprun program for the given kernel object.&nbsp;</font></div><div><font size="2"   >This program arranges to load the module then communicates with it, copying trace data from the kernel into temporary files, until the user sends an interrupt signal.&nbsp;</font></div><div><font size="2"   >Any run-time error encountered by the probe handlers, such as running out of memory, division by zero, exceeding nesting or runtime limits, results in a soft error indication.&nbsp;</font></div><div><font size="2"   >Soft errors in excess of MAXERRORS block of all subsequent probes (except error-handling probes), and terminate the session.&nbsp;</font></div><div><font size="2"   >Finally, staprun unloads the module, and cleans up.</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >第五步示例输出如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-150 ~]# stap --vp 00005 -I /tmp -e 'probe syscall.read {printf("hello i am digoal.\n"); exit()}'</font></div><div><font size="2"   >Pass 5: starting run.</font></div><div><font size="2"   >Running /usr/bin/staprun -v -v -R /tmp/stapNmEOL6/stap_e878009262b7836eb07f0b5a0bf0705e_970.ko</font></div><div><font size="2"   >staprun:main:387 modpath="/tmp/stapNmEOL6/stap_e878009262b7836eb07f0b5a0bf0705e_970.ko", modname="stap_e878009262b7836eb07f0b5a0bf0705e_970"</font></div><div><font size="2"   >staprun:init_staprun:305 init_staprun</font></div><div><font size="2"   >staprun:insert_module:73 inserting module /tmp/stapNmEOL6/stap_e878009262b7836eb07f0b5a0bf0705e_970.ko</font></div><div><font size="2"   >staprun:insert_module:99 module options: _stp_bufsize=0</font></div><div><font size="2"   >staprun:insert_module:107 module path canonicalized to '/tmp/stapNmEOL6/stap_e878009262b7836eb07f0b5a0bf0705e_970.ko'</font></div><div><font size="2"   >staprun:check_signature:441 checking signature for /tmp/stapNmEOL6/stap_e878009262b7836eb07f0b5a0bf0705e_970.ko</font></div><div><font size="2"   >Signature file /tmp/stapNmEOL6/stap_e878009262b7836eb07f0b5a0bf0705e_970.ko.sgn not found</font></div><div><font size="2"   >staprun:check_signature:454 verify_module returns 0</font></div><div><font size="2"   >staprun:insert_module:170 Renaming module 'stap_e878009262b7836eb07f0b5a0bf0705e_970'</font></div><div><font size="2"   >staprun:insert_module:178 Renamed module to 'stap_e878009262b7836eb07f0b5a0bf070_14544'</font></div><div><font size="2"   >staprun:init_ctl_channel:31 Opened /sys/kernel/debug/systemtap/stap_e878009262b7836eb07f0b5a0bf070_14544/.cmd (4)</font></div><div><font size="2"   >staprun:close_ctl_channel:66 Closed ctl fd 4</font></div><div><font size="2"   >execing: /usr/libexec/systemtap/stapio -v -v -R stap_e878009262b7836eb07f0b5a0bf070_14544&nbsp;</font></div><div><font size="2"   >stapio:parse_modpath:408 modpath="/lib/modules/2.6.32-358.el6.x86_64/systemtap/stap_e878009262b7836eb07f0b5a0bf070_14544.ko"</font></div><div><font size="2"   >stapio:main:41 modpath="/lib/modules/2.6.32-358.el6.x86_64/systemtap/stap_e878009262b7836eb07f0b5a0bf070_14544.ko", modname="stap_e878009262b7836eb07f0b5a0bf070_14544"</font></div><div><font size="2"   >stapio:init_stapio:367 init_stapio</font></div><div><font size="2"   >stapio:init_ctl_channel:31 Opened /sys/kernel/debug/systemtap/stap_e878009262b7836eb07f0b5a0bf070_14544/.cmd (4)</font></div><div><font size="2"   >stapio:stp_main_loop:565 in main loop</font></div><div><font size="2"   >stapio:stp_main_loop:584 select_supported: 1</font></div><div><font size="2"   >stapio:init_relayfs:244 initializing relayfs</font></div><div><font size="2"   >stapio:init_relayfs:268 attempting to open /sys/kernel/debug/systemtap/stap_e878009262b7836eb07f0b5a0bf070_14544/trace0</font></div><div><font size="2"   >stapio:init_relayfs:268 attempting to open /sys/kernel/debug/systemtap/stap_e878009262b7836eb07f0b5a0bf070_14544/trace1</font></div><div><font size="2"   >stapio:init_relayfs:274 ncpus=1, bulkmode = 0</font></div><div><font size="2"   >stapio:init_relayfs:357 starting threads</font></div><div><font size="2"   >stapio:stp_main_loop:736 systemtap_module_init() returned 0</font></div><div><font size="2"   >stapio:stp_main_loop:727 got STP_REQUEST_EXIT</font></div><div><font size="2"   >hello i am digoal.</font></div><div><font size="2"   >stapio:stp_main_loop:720 got STP_EXIT</font></div><div><font size="2"   >stapio:cleanup_and_exit:452 detach=0</font></div><div><font size="2"   >stapio:close_relayfs:373 closing</font></div><div><font size="2"   >stapio:close_relayfs:392 done</font></div><div><font size="2"   >stapio:cleanup_and_exit:469 closing control channel</font></div><div><font size="2"   >stapio:close_ctl_channel:66 Closed ctl fd 4</font></div><div><font size="2"   >stapio:cleanup_and_exit:477&nbsp;</font></div><div><font size="2"   >Renamed module to: stap_e878009262b7836eb07f0b5a0bf070_14544</font></div><div><font size="2"   >stapio:cleanup_and_exit:484 removing stap_e878009262b7836eb07f0b5a0bf070_14544</font></div><div><font size="2"   >staprun:parse_modpath:408 modpath="/lib/modules/2.6.32-358.el6.x86_64/systemtap/stap_e878009262b7836eb07f0b5a0bf070_14544.ko"</font></div><div><font size="2"   >staprun:main:387 modpath="/lib/modules/2.6.32-358.el6.x86_64/systemtap/stap_e878009262b7836eb07f0b5a0bf070_14544.ko", modname="stap_e878009262b7836eb07f0b5a0bf070_14544"</font></div><div><font size="2"   >staprun:init_staprun:305 init_staprun</font></div><div><font size="2"   >staprun:remove_module:222 stap_e878009262b7836eb07f0b5a0bf070_14544</font></div><div><font size="2"   >staprun:init_ctl_channel:31 Opened /sys/kernel/debug/systemtap/stap_e878009262b7836eb07f0b5a0bf070_14544/.cmd (4)</font></div><div><font size="2"   >staprun:close_ctl_channel:66 Closed ctl fd 4</font></div><div><font size="2"   >staprun:remove_module:247 removing module stap_e878009262b7836eb07f0b5a0bf070_14544</font></div><div><font size="2"   >staprun:remove_module:259 Module stap_e878009262b7836eb07f0b5a0bf070_14544 removed.</font></div><div><font size="2"   >Spawn waitpid result (0x0): 0</font></div><div><font size="2"   >Pass 5: run completed in 0usr/20sys/326real ms.</font></div><div><font size="2"   >Running rm -rf /tmp/stapNmEOL6</font></div><div><font size="2"   >Spawn waitpid result (0x0): 0</font></div><div><font size="2"   >Removed temporary directory "/tmp/stapNmEOL6"</font></div><p></p></pre></div></div><div><br></div><div>[其他 ]</div><div>man stap</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >运行至某个步骤停止, 一般可用于生成可移动模块.</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;-p NUM Stop &nbsp;after &nbsp;pass NUM. &nbsp;The passes are numbered 1-5: parse, elaborate, translate, compile, run. &nbsp;See the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROCESSING section for details.</font></div><div><font size="2"   >提高输出详细级别</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;-v &nbsp; &nbsp; Increase verbosity for all passes. &nbsp;Produce a larger volume of informative (?) output each &nbsp;time &nbsp;option</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repeated.</font></div><div><font size="2"   >设置各步骤的输出详细级别</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;--vp ABCDE</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Increase &nbsp;verbosity &nbsp;on &nbsp;a &nbsp;per-pass basis. &nbsp;For example, "--vp 002" adds 2 units of verbosity to pass 3</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; only. &nbsp;The combination "-v --vp 00004" adds 1 unit of verbosity for all passes, and 4 more for pass 5.</font></div></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" rel="nofollow" href="https://sourceware.org/systemtap/man/stap.1.html"   >https://sourceware.org/systemtap/man/stap.1.html</a></div><div>2.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/16387704020139142437763/"   >http://blog.163.com/digoal@126/blog/static/16387704020139142437763/</a></div><div>3.&nbsp;<a style="line-height: 28px;" href="http://blog.163.com/digoal@126/blog/static/16387704020138109459201/"   >http://blog.163.com/digoal@126/blog/static/16387704020138109459201/</a></div><div>4. 宏以及条件预编译参考</div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020139831157191/"   >http://blog.163.com/digoal@126/blog/static/16387704020139831157191/</a></div><div><a href="http://blog.163.com/digoal@126/blog/static/16387704020139851437162/"   >http://blog.163.com/digoal@126/blog/static/16387704020139851437162/</a></div><div>5.&nbsp;[root@db-172-16-3-150 e8]# cat &nbsp;/root/.systemtap/cache/e8/stap_e878009262b7836eb07f0b5a0bf0705e_970.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >#define STAP_MSG_RUNTIME_H_01 "myproc-unprivileged tapset function called without is_myproc checking for pid %d (euid %d)"</font></div><div><font size="2"   >#define STAP_MSG_LOC2C_01 "kernel read fault at 0x%p (%s)"</font></div><div><font size="2"   >#define STAP_MSG_LOC2C_02 "kernel write fault at 0x%p (%s)"</font></div><div><font size="2"   >#define STAP_MSG_LOC2C_03 "divide by zero in DWARF operand (%s)"</font></div><div><font size="2"   >#define STAP_VERSION(a, b) ( ((a) &lt;&lt; 8) + (b) )</font></div><div><font size="2"   >#ifndef STAP_COMPAT_VERSION</font></div><div><font size="2"   >#define STAP_COMPAT_VERSION STAP_VERSION(1, 8)</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >#include "runtime_defines.h"</font></div><div><font size="2"   >#define STP_PR_STAPUSR 0x2</font></div><div><font size="2"   >#define STP_PR_STAPSYS 0x4</font></div><div><font size="2"   >#define STP_PR_STAPDEV 0x8</font></div><div><font size="2"   >#define STP_PRIVILEGE 0x8</font></div><div><font size="2"   >int stp_required_privilege __attribute__ ((section (".stap_privilege"))) = STP_PRIVILEGE;</font></div><div><font size="2"   >#ifndef MAXNESTING</font></div><div><font size="2"   >#define MAXNESTING 1</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >#define STP_SKIP_BADVARS 0</font></div><div><font size="2"   >#include "runtime.h"</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#include "common_session_state.h"</font></div><div><font size="2"   >struct context {</font></div><div><font size="2"   >&nbsp; #include "common_probe_context.h"</font></div><div><font size="2"   >&nbsp; union {</font></div><div><font size="2"   >&nbsp; &nbsp; struct probe_3027_locals {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; union {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; };</font></div><div><font size="2"   >&nbsp; &nbsp; } probe_3027;</font></div><div><font size="2"   >&nbsp; } probe_locals;</font></div><div><font size="2"   >&nbsp; union {</font></div><div><font size="2"   >&nbsp; &nbsp; struct function_exit_locals {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; /* no return value */</font></div><div><font size="2"   >&nbsp; &nbsp; } function_exit;</font></div><div><font size="2"   >&nbsp; } locals [MAXNESTING+1];</font></div><div><font size="2"   >&nbsp; #if MAXNESTING &lt; 0</font></div><div><font size="2"   >&nbsp; #error "MAXNESTING must be positive"</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; #ifndef STP_LEGACY_PRINT</font></div><div><font size="2"   >&nbsp; union {</font></div><div><font size="2"   >&nbsp; } printf_locals;</font></div><div><font size="2"   >&nbsp; #endif // STP_LEGACY_PRINT</font></div><div><font size="2"   >};</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >static struct context *contexts[NR_CPUS] = { NULL };</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#ifdef STAP_NEED_GETTIMEOFDAY</font></div><div><font size="2"   >#include "time.c"</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >#ifndef STP_LEGACY_PRINT</font></div><div><font size="2"   >#endif // STP_LEGACY_PRINT</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#include "runtime_context.h"</font></div><div><font size="2"   >#include "probe_lock.h"&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >static void function_exit (struct context * __restrict__ c);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >static void function_exit (struct context* __restrict__ c) {</font></div><div><font size="2"   >&nbsp; __label__ out;</font></div><div><font size="2"   >&nbsp; struct function_exit_locals * &nbsp;__restrict__ l = &amp; c-&gt;locals[c-&gt;nesting+1].function_exit;</font></div><div><font size="2"   >&nbsp; (void) l;</font></div><div><font size="2"   >&nbsp; #define CONTEXT c</font></div><div><font size="2"   >&nbsp; #define THIS l</font></div><div><font size="2"   >&nbsp; #define STAP_RETVALUE THIS-&gt;__retvalue</font></div><div><font size="2"   >&nbsp; c-&gt;last_stmt = "identifier 'exit' at /usr/share/systemtap/tapset/logging.stp:49:10";</font></div><div><font size="2"   >&nbsp; if (unlikely (c-&gt;nesting+1 &gt;= MAXNESTING)) {</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;last_error = "MAXNESTING exceeded";</font></div><div><font size="2"   >&nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; } else {</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;nesting ++;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; #define return goto out</font></div><div><font size="2"   >&nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;/* unprivileged */</font></div><div><font size="2"   >&nbsp; &nbsp; atomic_set (&amp;session_state, STAP_SESSION_STOPPING);</font></div><div><font size="2"   >&nbsp; &nbsp; _stp_exit ();</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; #undef return</font></div><div><font size="2"   >out:</font></div><div><font size="2"   >&nbsp; if (0) goto out;</font></div><div><font size="2"   >&nbsp; c-&gt;nesting --;</font></div><div><font size="2"   >&nbsp; #undef CONTEXT</font></div><div><font size="2"   >&nbsp; #undef THIS</font></div><div><font size="2"   >&nbsp; #undef STAP_RETVALUE</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >static void probe_3027 (struct context * __restrict__ c) {</font></div><div><font size="2"   >&nbsp; __label__ out;</font></div><div><font size="2"   >&nbsp; static const struct stp_probe_lock locks[] = {</font></div><div><font size="2"   >&nbsp; };</font></div><div><font size="2"   >&nbsp; struct probe_3027_locals * __restrict__ l = &amp; c-&gt;probe_locals.probe_3027;</font></div><div><font size="2"   >&nbsp; (void) l;</font></div><div><font size="2"   >&nbsp; #if ! STP_PRIVILEGE_CONTAINS (STP_PRIVILEGE, STP_PR_STAPDEV) &amp;&amp; \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; ! STP_PRIVILEGE_CONTAINS (STP_PRIVILEGE, STP_PR_STAPSYS)</font></div><div><font size="2"   >&nbsp; #error Internal Error: Probe kernel.function("sys_read@fs/read_write.c:389").call generated in --unprivileged mode</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; #if defined __ia64__</font></div><div><font size="2"   >&nbsp; bspcache(c-&gt;unwaddr, c-&gt;kregs);</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; if (!stp_lock_probe(locks, ARRAY_SIZE(locks)))</font></div><div><font size="2"   >&nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; (void)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; ({</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_print ("hello i am digoal.\n");</font></div><div><font size="2"   >&nbsp; &nbsp; });</font></div><div><font size="2"   >&nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; (void)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; ({</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; function_exit (c);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (unlikely(c-&gt;last_error)) goto out;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; (void) 0;</font></div><div><font size="2"   >&nbsp; &nbsp; });</font></div><div><font size="2"   >&nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; c-&gt;actionremaining -= 2;</font></div><div><font size="2"   >&nbsp; if (unlikely (c-&gt;actionremaining &lt;= 0)) {</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;last_error = "MAXACTION exceeded";</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;last_stmt = "operator '{' at /usr/share/systemtap/tapset/syscalls2.stp:676:1";</font></div><div><font size="2"   >&nbsp; &nbsp; goto out;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >out:</font></div><div><font size="2"   >&nbsp; stp_unlock_probe(locks, ARRAY_SIZE(locks));</font></div><div><font size="2"   >&nbsp; _stp_print_flush();</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >static struct stap_probe {</font></div><div><font size="2"   >&nbsp; void (* const ph) (struct context*);</font></div><div><font size="2"   >&nbsp; #ifdef STP_ALIBI</font></div><div><font size="2"   >&nbsp; atomic_t alibi;</font></div><div><font size="2"   >&nbsp; #define STAP_PROBE_INIT_ALIBI() .alibi=ATOMIC_INIT(0),</font></div><div><font size="2"   >&nbsp; #else</font></div><div><font size="2"   >&nbsp; #define STAP_PROBE_INIT_ALIBI()</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; Stat timing;</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; #if defined(STP_TIMING) || defined(STP_ALIBI)</font></div><div><font size="2"   >&nbsp; const char location[14];</font></div><div><font size="2"   >&nbsp; const char derivation[63];</font></div><div><font size="2"   >&nbsp; #define STAP_PROBE_INIT_TIMING(L, D) .location=(L), .derivation=(D),</font></div><div><font size="2"   >&nbsp; #else</font></div><div><font size="2"   >&nbsp; #define STAP_PROBE_INIT_TIMING(L, D)</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; const char pp[57];</font></div><div><font size="2"   >&nbsp; #ifdef STP_NEED_PROBE_NAME</font></div><div><font size="2"   >&nbsp; const char pn[15];</font></div><div><font size="2"   >&nbsp; #define STAP_PROBE_INIT_NAME(PN) .pn=(PN),</font></div><div><font size="2"   >&nbsp; #else</font></div><div><font size="2"   >&nbsp; #define STAP_PROBE_INIT_NAME(PN)</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; #define STAP_PROBE_INIT(PH, PP, PN, L, D) { .ph=(PH), .pp=(PP), STAP_PROBE_INIT_NAME(PN) STAP_PROBE_INIT_ALIBI() STAP_PROBE_INIT_TIMING(L, D) }</font></div><div><font size="2"   >} stap_probes[] = {</font></div><div><font size="2"   >&nbsp; STAP_PROBE_INIT(&amp;probe_3027, "kernel.function(\"sys_read@fs/read_write.c:389\").call", "syscall.read", "&lt;input&gt;:1:7", " from: kernel.function(\"sys_read\").call from: syscall.read"),</font></div><div><font size="2"   >};</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/* ---- dwarf probes ---- */</font></div><div><font size="2"   >#if ! defined(CONFIG_KPROBES)</font></div><div><font size="2"   >#error "Need CONFIG_KPROBES!"</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#ifndef KRETACTIVE</font></div><div><font size="2"   >#define KRETACTIVE (max(15,6*(int)num_possible_cpus()))</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >#include "kprobes-common.h"</font></div><div><font size="2"   >static int enter_kprobe_probe (struct kprobe *inst, struct pt_regs *regs);</font></div><div><font size="2"   >static int enter_kretprobe_probe (struct kretprobe_instance *inst, struct pt_regs *regs);</font></div><div><font size="2"   >#if defined(STAPCONF_UNREGISTER_KPROBES)</font></div><div><font size="2"   >static void * stap_unreg_kprobes[1];</font></div><div><font size="2"   >#endif</font></div><div><font size="2"   >static struct stap_dwarf_kprobe stap_dwarf_kprobes[1];</font></div><div><font size="2"   >static struct stap_dwarf_probe {</font></div><div><font size="2"   >&nbsp; const unsigned return_p:1;</font></div><div><font size="2"   >&nbsp; const unsigned maxactive_p:1;</font></div><div><font size="2"   >&nbsp; const unsigned optional_p:1;</font></div><div><font size="2"   >&nbsp; unsigned registered_p:1;</font></div><div><font size="2"   >&nbsp; const unsigned short maxactive_val;</font></div><div><font size="2"   >&nbsp; const unsigned short saved_longs;</font></div><div><font size="2"   >&nbsp; const unsigned short saved_strings;</font></div><div><font size="2"   >&nbsp; const char module[7];</font></div><div><font size="2"   >&nbsp; const char section[7];</font></div><div><font size="2"   >&nbsp; const unsigned long address;</font></div><div><font size="2"   >&nbsp; struct stap_probe * const probe;</font></div><div><font size="2"   >&nbsp; struct stap_probe * const entry_probe;</font></div><div><font size="2"   >} stap_dwarf_probes[] = {</font></div><div><font size="2"   >&nbsp; { .address=(unsigned long)0x181618ULL, .module="kernel", .section="_stext", .probe=(&amp;stap_probes[0]), },</font></div><div><font size="2"   >};</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >static int enter_kprobe_probe (struct kprobe *inst, struct pt_regs *regs) {</font></div><div><font size="2"   >&nbsp; int kprobe_idx = ((uintptr_t)inst-(uintptr_t)stap_dwarf_kprobes)/sizeof(struct stap_dwarf_kprobe);</font></div><div><font size="2"   >&nbsp; struct stap_dwarf_probe *sdp = &amp;stap_dwarf_probes[((kprobe_idx &gt;= 0 &amp;&amp; kprobe_idx &lt; 1)?kprobe_idx:0)];</font></div><div><font size="2"   >&nbsp; #ifdef STP_ALIBI</font></div><div><font size="2"   >&nbsp; atomic_inc(&amp;(sdp-&gt;probe-&gt;alibi));</font></div><div><font size="2"   >&nbsp; #else</font></div><div><font size="2"   >&nbsp; struct context* __restrict__ c;</font></div><div><font size="2"   >&nbsp; #if !INTERRUPTIBLE</font></div><div><font size="2"   >&nbsp; unsigned long flags;</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; #if defined(STP_TIMING) || defined(STP_OVERLOAD)</font></div><div><font size="2"   >&nbsp; cycles_t cycles_atstart = get_cycles ();</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; Stat stat = sdp-&gt;probe-&gt;timing;</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; #if INTERRUPTIBLE</font></div><div><font size="2"   >&nbsp; preempt_disable ();</font></div><div><font size="2"   >&nbsp; #else</font></div><div><font size="2"   >&nbsp; local_irq_save (flags);</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; if (unlikely ((((unsigned long) (&amp; c)) &amp; (THREAD_SIZE-1))</font></div><div><font size="2"   >&nbsp; &nbsp; &lt; (MINSTACKSPACE + sizeof (struct thread_info)))) {</font></div><div><font size="2"   >&nbsp; &nbsp; atomic_inc (&amp; skipped_count);</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; atomic_inc (&amp; skipped_count_lowstack);</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; goto probe_epilogue;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; if (atomic_read (&amp;session_state) != STAP_SESSION_RUNNING)</font></div><div><font size="2"   >&nbsp; &nbsp; goto probe_epilogue;</font></div><div><font size="2"   >&nbsp; c = contexts[smp_processor_id()];</font></div><div><font size="2"   >&nbsp; if (atomic_inc_return (&amp; c-&gt;busy) != 1) {</font></div><div><font size="2"   >&nbsp; &nbsp; #if !INTERRUPTIBLE</font></div><div><font size="2"   >&nbsp; &nbsp; atomic_inc (&amp; skipped_count);</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; atomic_inc (&amp; skipped_count_reentrant);</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef DEBUG_REENTRANCY</font></div><div><font size="2"   >&nbsp; &nbsp; _stp_warn ("Skipped %s due to %s residency on cpu %u\n", sdp-&gt;probe-&gt;pp, c-&gt;probe_point ?: "?", smp_processor_id());</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; atomic_dec (&amp; c-&gt;busy);</font></div><div><font size="2"   >&nbsp; &nbsp; goto probe_epilogue;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; c-&gt;last_stmt = 0;</font></div><div><font size="2"   >&nbsp; c-&gt;last_error = 0;</font></div><div><font size="2"   >&nbsp; c-&gt;nesting = -1;</font></div><div><font size="2"   >&nbsp; c-&gt;uregs = 0;</font></div><div><font size="2"   >&nbsp; c-&gt;kregs = 0;</font></div><div><font size="2"   >&nbsp; #if defined __ia64__</font></div><div><font size="2"   >&nbsp; c-&gt;unwaddr = 0;</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; c-&gt;probe_point = sdp-&gt;probe-&gt;pp;</font></div><div><font size="2"   >&nbsp; #ifdef STP_NEED_PROBE_NAME</font></div><div><font size="2"   >&nbsp; c-&gt;probe_name = sdp-&gt;probe-&gt;pn;</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; c-&gt;probe_type = _STP_PROBE_HANDLER_KPROBE;</font></div><div><font size="2"   >&nbsp; memset(&amp;c-&gt;ips, 0, sizeof(c-&gt;ips));</font></div><div><font size="2"   >&nbsp; c-&gt;probe_flags = 0;</font></div><div><font size="2"   >&nbsp; #ifdef STAP_NEED_REGPARM</font></div><div><font size="2"   >&nbsp; c-&gt;regparm = 0;</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; #if INTERRUPTIBLE</font></div><div><font size="2"   >&nbsp; c-&gt;actionremaining = MAXACTION_INTERRUPTIBLE;</font></div><div><font size="2"   >&nbsp; #else</font></div><div><font size="2"   >&nbsp; c-&gt;actionremaining = MAXACTION;</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; c-&gt;kregs = regs;</font></div><div><font size="2"   >&nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; unsigned long kprobes_ip = REG_IP(c-&gt;kregs);</font></div><div><font size="2"   >&nbsp; &nbsp; SET_REG_IP(regs, (unsigned long) inst-&gt;addr);</font></div><div><font size="2"   >&nbsp; &nbsp; (*sdp-&gt;probe-&gt;ph) (c);</font></div><div><font size="2"   >&nbsp; &nbsp; SET_REG_IP(regs, kprobes_ip);</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; #if defined(STP_TIMING) || defined(STP_OVERLOAD)</font></div><div><font size="2"   >&nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; cycles_t cycles_atend = get_cycles ();</font></div><div><font size="2"   >&nbsp; &nbsp; int32_t cycles_elapsed = ((int32_t)cycles_atend &gt; (int32_t)cycles_atstart)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; ? ((int32_t)cycles_atend - (int32_t)cycles_atstart)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; : (~(int32_t)0) - (int32_t)cycles_atstart + (int32_t)cycles_atend + 1;</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; if (likely (stat)) _stp_stat_add(stat, cycles_elapsed);</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STP_OVERLOAD</font></div><div><font size="2"   >&nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; cycles_t interval = (cycles_atend &gt; c-&gt;cycles_base)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ? (cycles_atend - c-&gt;cycles_base)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; : (STP_OVERLOAD_INTERVAL + 1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; c-&gt;cycles_sum += cycles_elapsed;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (interval &gt; STP_OVERLOAD_INTERVAL) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (c-&gt;cycles_sum &gt; STP_OVERLOAD_THRESHOLD) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _stp_error ("probe overhead exceeded threshold");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atomic_set (&amp;session_state, STAP_SESSION_ERROR);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atomic_inc (&amp;error_count);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; c-&gt;cycles_base = cycles_atend;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; c-&gt;cycles_sum = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; c-&gt;probe_point = 0;</font></div><div><font size="2"   >&nbsp; #ifdef STP_NEED_PROBE_NAME</font></div><div><font size="2"   >&nbsp; c-&gt;probe_name = 0;</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; c-&gt;probe_type = 0;</font></div><div><font size="2"   >&nbsp; if (unlikely (c-&gt;last_error &amp;&amp; c-&gt;last_error[0])) {</font></div><div><font size="2"   >&nbsp; &nbsp; if (c-&gt;last_stmt != NULL)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_softerror ("%s near %s", c-&gt;last_error, c-&gt;last_stmt);</font></div><div><font size="2"   >&nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_softerror ("%s", c-&gt;last_error);</font></div><div><font size="2"   >&nbsp; &nbsp; atomic_inc (&amp; error_count);</font></div><div><font size="2"   >&nbsp; &nbsp; if (atomic_read (&amp; error_count) &gt; MAXERRORS) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; atomic_set (&amp; session_state, STAP_SESSION_ERROR);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_exit ();</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; atomic_dec (&amp;c-&gt;busy);</font></div><div><font size="2"   >probe_epilogue:</font></div><div><font size="2"   >&nbsp; if (unlikely (atomic_read (&amp; skipped_count) &gt; MAXSKIPPED)) {</font></div><div><font size="2"   >&nbsp; &nbsp; if (unlikely (pseudo_atomic_cmpxchg(&amp; session_state, STAP_SESSION_RUNNING, STAP_SESSION_ERROR) == STAP_SESSION_RUNNING))</font></div><div><font size="2"   >&nbsp; &nbsp; _stp_error ("Skipped too many probes, check MAXSKIPPED or try again with stap -t for more details.");</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; #if INTERRUPTIBLE</font></div><div><font size="2"   >&nbsp; preempt_enable_no_resched ();</font></div><div><font size="2"   >&nbsp; #else</font></div><div><font size="2"   >&nbsp; local_irq_restore (flags);</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; #endif // STP_ALIBI</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >static int enter_kretprobe_common (struct kretprobe_instance *inst, struct pt_regs *regs, int entry) {</font></div><div><font size="2"   >&nbsp; struct kretprobe *krp = inst-&gt;rp;</font></div><div><font size="2"   >&nbsp; int kprobe_idx = ((uintptr_t)krp-(uintptr_t)stap_dwarf_kprobes)/sizeof(struct stap_dwarf_kprobe);</font></div><div><font size="2"   >&nbsp; struct stap_dwarf_probe *sdp = &amp;stap_dwarf_probes[((kprobe_idx &gt;= 0 &amp;&amp; kprobe_idx &lt; 1)?kprobe_idx:0)];</font></div><div><font size="2"   >&nbsp; struct stap_probe *sp = entry ? sdp-&gt;entry_probe : sdp-&gt;probe;</font></div><div><font size="2"   >&nbsp; if (sp) {</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STP_ALIBI</font></div><div><font size="2"   >&nbsp; &nbsp; atomic_inc(&amp;(sp-&gt;alibi));</font></div><div><font size="2"   >&nbsp; &nbsp; #else</font></div><div><font size="2"   >&nbsp; &nbsp; struct context* __restrict__ c;</font></div><div><font size="2"   >&nbsp; &nbsp; #if !INTERRUPTIBLE</font></div><div><font size="2"   >&nbsp; &nbsp; unsigned long flags;</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; #if defined(STP_TIMING) || defined(STP_OVERLOAD)</font></div><div><font size="2"   >&nbsp; &nbsp; cycles_t cycles_atstart = get_cycles ();</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; Stat stat = sp-&gt;timing;</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; #if INTERRUPTIBLE</font></div><div><font size="2"   >&nbsp; &nbsp; preempt_disable ();</font></div><div><font size="2"   >&nbsp; &nbsp; #else</font></div><div><font size="2"   >&nbsp; &nbsp; local_irq_save (flags);</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; if (unlikely ((((unsigned long) (&amp; c)) &amp; (THREAD_SIZE-1))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &lt; (MINSTACKSPACE + sizeof (struct thread_info)))) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; atomic_inc (&amp; skipped_count);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; atomic_inc (&amp; skipped_count_lowstack);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; goto probe_epilogue;</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; if (atomic_read (&amp;session_state) != STAP_SESSION_RUNNING)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; goto probe_epilogue;</font></div><div><font size="2"   >&nbsp; &nbsp; c = contexts[smp_processor_id()];</font></div><div><font size="2"   >&nbsp; &nbsp; if (atomic_inc_return (&amp; c-&gt;busy) != 1) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #if !INTERRUPTIBLE</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; atomic_inc (&amp; skipped_count);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; atomic_inc (&amp; skipped_count_reentrant);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #ifdef DEBUG_REENTRANCY</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_warn ("Skipped %s due to %s residency on cpu %u\n", sp-&gt;pp, c-&gt;probe_point ?: "?", smp_processor_id());</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; atomic_dec (&amp; c-&gt;busy);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; goto probe_epilogue;</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;last_stmt = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;last_error = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;nesting = -1;</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;uregs = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;kregs = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; #if defined __ia64__</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;unwaddr = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;probe_point = sp-&gt;pp;</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STP_NEED_PROBE_NAME</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;probe_name = sp-&gt;pn;</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;probe_type = _STP_PROBE_HANDLER_KRETPROBE;</font></div><div><font size="2"   >&nbsp; &nbsp; memset(&amp;c-&gt;ips, 0, sizeof(c-&gt;ips));</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;probe_flags = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STAP_NEED_REGPARM</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;regparm = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; #if INTERRUPTIBLE</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;actionremaining = MAXACTION_INTERRUPTIBLE;</font></div><div><font size="2"   >&nbsp; &nbsp; #else</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;actionremaining = MAXACTION;</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;kregs = regs;</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;ips.krp.pi = inst;</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;ips.krp.pi_longs = sdp-&gt;saved_longs;</font></div><div><font size="2"   >&nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; unsigned long kprobes_ip = REG_IP(c-&gt;kregs);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (entry)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SET_REG_IP(regs, (unsigned long) inst-&gt;rp-&gt;kp.addr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SET_REG_IP(regs, (unsigned long)inst-&gt;ret_addr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; (sp-&gt;ph) (c);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; SET_REG_IP(regs, kprobes_ip);</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; #if defined(STP_TIMING) || defined(STP_OVERLOAD)</font></div><div><font size="2"   >&nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; cycles_t cycles_atend = get_cycles ();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; int32_t cycles_elapsed = ((int32_t)cycles_atend &gt; (int32_t)cycles_atstart)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ? ((int32_t)cycles_atend - (int32_t)cycles_atstart)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; : (~(int32_t)0) - (int32_t)cycles_atstart + (int32_t)cycles_atend + 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (likely (stat)) _stp_stat_add(stat, cycles_elapsed);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #ifdef STP_OVERLOAD</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; cycles_t interval = (cycles_atend &gt; c-&gt;cycles_base)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? (cycles_atend - c-&gt;cycles_base)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : (STP_OVERLOAD_INTERVAL + 1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; c-&gt;cycles_sum += cycles_elapsed;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (interval &gt; STP_OVERLOAD_INTERVAL) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (c-&gt;cycles_sum &gt; STP_OVERLOAD_THRESHOLD) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _stp_error ("probe overhead exceeded threshold");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atomic_set (&amp;session_state, STAP_SESSION_ERROR);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atomic_inc (&amp;error_count);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c-&gt;cycles_base = cycles_atend;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c-&gt;cycles_sum = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;probe_point = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STP_NEED_PROBE_NAME</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;probe_name = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; c-&gt;probe_type = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; if (unlikely (c-&gt;last_error &amp;&amp; c-&gt;last_error[0])) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (c-&gt;last_stmt != NULL)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; _stp_softerror ("%s near %s", c-&gt;last_error, c-&gt;last_stmt);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; _stp_softerror ("%s", c-&gt;last_error);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; atomic_inc (&amp; error_count);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (atomic_read (&amp; error_count) &gt; MAXERRORS) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; atomic_set (&amp; session_state, STAP_SESSION_ERROR);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; _stp_exit ();</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; atomic_dec (&amp;c-&gt;busy);</font></div><div><font size="2"   >&nbsp; probe_epilogue:</font></div><div><font size="2"   >&nbsp; &nbsp; if (unlikely (atomic_read (&amp; skipped_count) &gt; MAXSKIPPED)) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (unlikely (pseudo_atomic_cmpxchg(&amp; session_state, STAP_SESSION_RUNNING, STAP_SESSION_ERROR) == STAP_SESSION_RUNNING))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_error ("Skipped too many probes, check MAXSKIPPED or try again with stap -t for more details.");</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; #if INTERRUPTIBLE</font></div><div><font size="2"   >&nbsp; &nbsp; preempt_enable_no_resched ();</font></div><div><font size="2"   >&nbsp; &nbsp; #else</font></div><div><font size="2"   >&nbsp; &nbsp; local_irq_restore (flags);</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; #endif // STP_ALIBI</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >static int enter_kretprobe_probe (struct kretprobe_instance *inst, struct pt_regs *regs) {</font></div><div><font size="2"   >&nbsp; return enter_kretprobe_common(inst, regs, 0);</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >static int enter_kretprobe_entry_probe (struct kretprobe_instance *inst, struct pt_regs *regs) {</font></div><div><font size="2"   >&nbsp; return enter_kretprobe_common(inst, regs, 1);</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >static int systemtap_module_init (void) {</font></div><div><font size="2"   >&nbsp; int rc = 0;</font></div><div><font size="2"   >&nbsp; int cpu;</font></div><div><font size="2"   >&nbsp; int i=0, j=0;</font></div><div><font size="2"   >&nbsp; const char *probe_point = "";</font></div><div><font size="2"   >&nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; const char* release = UTS_RELEASE;</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STAPCONF_GENERATED_COMPILE</font></div><div><font size="2"   >&nbsp; &nbsp; const char* version = UTS_VERSION;</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; if (strcmp (release, "2.6.32-358.el6.x86_64")) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_error ("module release mismatch (%s vs %s)", release, "2.6.32-358.el6.x86_64");</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; rc = -EINVAL;</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STAPCONF_GENERATED_COMPILE</font></div><div><font size="2"   >&nbsp; &nbsp; if (strcmp (utsname()-&gt;version, version)) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_error ("module version mismatch (%s vs %s), release %s", version, utsname()-&gt;version, release);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; rc = -EINVAL;</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; if (_stp_module_check()) rc = -EINVAL;</font></div><div><font size="2"   >&nbsp; &nbsp; if (_stp_privilege_credentials == 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (STP_PRIVILEGE_CONTAINS(STP_PRIVILEGE, STP_PR_STAPDEV) ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STP_PRIVILEGE_CONTAINS(STP_PRIVILEGE, STP_PR_STAPUSR)) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; _stp_privilege_credentials = STP_PRIVILEGE;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #ifdef DEBUG_PRIVILEGE</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dbug("User's privilege credentials default to %s\n",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; privilege_to_text(_stp_privilege_credentials));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; else {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; _stp_error ("Unable to verify that you have the required privilege credentials to run this module (%s required). You must use staprun version 1.7 or higher.",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; privilege_to_text(STP_PRIVILEGE));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rc = -EINVAL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; else {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #ifdef DEBUG_PRIVILEGE</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; _dbug("User's privilege credentials provided as %s\n",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; privilege_to_text(_stp_privilege_credentials));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (! STP_PRIVILEGE_CONTAINS(_stp_privilege_credentials, STP_PRIVILEGE)) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; _stp_error ("Your privilege credentials (%s) are insufficient to run this module (%s required).",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; privilege_to_text(_stp_privilege_credentials), privilege_to_text(STP_PRIVILEGE));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rc = -EINVAL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; if (rc) goto out;</font></div><div><font size="2"   >&nbsp; #ifdef STAP_NEED_GETTIMEOFDAY</font></div><div><font size="2"   >&nbsp; rc = _stp_init_time();</font></div><div><font size="2"   >&nbsp; if (rc) {</font></div><div><font size="2"   >&nbsp; &nbsp; _stp_error ("couldn't initialize gettimeofday");</font></div><div><font size="2"   >&nbsp; &nbsp; goto out;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; (void) probe_point;</font></div><div><font size="2"   >&nbsp; (void) i;</font></div><div><font size="2"   >&nbsp; (void) j;</font></div><div><font size="2"   >&nbsp; atomic_set (&amp;session_state, STAP_SESSION_STARTING);</font></div><div><font size="2"   >&nbsp; for_each_possible_cpu(cpu) {</font></div><div><font size="2"   >&nbsp; &nbsp; contexts[cpu] = _stp_kzalloc_gfp(sizeof(struct context), STP_ALLOC_SLEEP_FLAGS);</font></div><div><font size="2"   >&nbsp; &nbsp; if (contexts[cpu] == NULL) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_error ("context (size %lu) allocation failed", (unsigned long) sizeof (struct context));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; rc = -ENOMEM;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; goto out;</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; for (i = 0; i &lt; ARRAY_SIZE(stap_probes); ++i)</font></div><div><font size="2"   >&nbsp; &nbsp; stap_probes[i].timing = _stp_stat_init (HIST_NONE);</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; _stp_print_kernel_info("1.8/0.152", (num_online_cpus() * sizeof(struct context)), 1);</font></div><div><font size="2"   >&nbsp; for (i=0; i&lt;1; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; struct stap_dwarf_probe *sdp = &amp; stap_dwarf_probes[i];</font></div><div><font size="2"   >&nbsp; &nbsp; struct stap_dwarf_kprobe *kp = &amp; stap_dwarf_kprobes[i];</font></div><div><font size="2"   >&nbsp; &nbsp; unsigned long relocated_addr = _stp_kmodule_relocate (sdp-&gt;module, sdp-&gt;section, sdp-&gt;address);</font></div><div><font size="2"   >&nbsp; &nbsp; if (relocated_addr == 0) continue;</font></div><div><font size="2"   >&nbsp; &nbsp; probe_point = sdp-&gt;probe-&gt;pp;</font></div><div><font size="2"   >&nbsp; &nbsp; if (sdp-&gt;return_p) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; kp-&gt;u.krp.kp.addr = (void *) relocated_addr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (sdp-&gt;maxactive_p) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;u.krp.maxactive = sdp-&gt;maxactive_val;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; } else {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;u.krp.maxactive = KRETACTIVE;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; kp-&gt;u.krp.handler = &amp;enter_kretprobe_probe;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,25)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (sdp-&gt;entry_probe) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;u.krp.entry_handler = &amp;enter_kretprobe_entry_probe;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;u.krp.data_size = sdp-&gt;saved_longs * sizeof(int64_t) +&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sdp-&gt;saved_strings * MAXSTRINGLEN;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #ifdef __ia64__</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; kp-&gt;dummy.addr = kp-&gt;u.krp.kp.addr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; kp-&gt;dummy.pre_handler = NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; rc = register_kprobe (&amp; kp-&gt;dummy);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (rc == 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rc = register_kretprobe (&amp; kp-&gt;u.krp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (rc != 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unregister_kprobe (&amp; kp-&gt;dummy);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; rc = register_kretprobe (&amp; kp-&gt;u.krp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; } else {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; kp-&gt;u.kp.addr = (void *) relocated_addr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; kp-&gt;u.kp.pre_handler = &amp;enter_kprobe_probe;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #ifdef __ia64__</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; kp-&gt;dummy.addr = kp-&gt;u.kp.addr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; kp-&gt;dummy.pre_handler = NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; rc = register_kprobe (&amp; kp-&gt;dummy);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (rc == 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rc = register_kprobe (&amp; kp-&gt;u.kp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (rc != 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unregister_kprobe (&amp; kp-&gt;dummy);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; rc = register_kprobe (&amp; kp-&gt;u.kp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; if (rc) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; sdp-&gt;registered_p = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (!sdp-&gt;optional_p)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; _stp_warn ("probe %s (address 0x%lx) registration error (rc %d)", probe_point, (unsigned long) relocated_addr, rc);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; rc = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; else sdp-&gt;registered_p = 1;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; if (rc) {</font></div><div><font size="2"   >&nbsp; &nbsp; if (probe_point)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_error ("probe %s registration error (rc %d)", probe_point, rc);</font></div><div><font size="2"   >&nbsp; &nbsp; atomic_set (&amp;session_state, STAP_SESSION_ERROR);</font></div><div><font size="2"   >&nbsp; &nbsp; goto out;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; if (atomic_read (&amp;session_state) == STAP_SESSION_STARTING)</font></div><div><font size="2"   >&nbsp; &nbsp; atomic_set (&amp;session_state, STAP_SESSION_RUNNING);</font></div><div><font size="2"   >&nbsp; return 0;</font></div><div><font size="2"   >out:</font></div><div><font size="2"   >&nbsp; atomic_set (&amp;session_state, STAP_SESSION_STOPPED);</font></div><div><font size="2"   >&nbsp; #ifdef STAPCONF_SYNCHRONIZE_SCHED</font></div><div><font size="2"   >&nbsp; synchronize_sched();</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; #ifdef STAP_NEED_GETTIMEOFDAY</font></div><div><font size="2"   >&nbsp; &nbsp;_stp_kill_time();</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; for_each_possible_cpu(cpu) {</font></div><div><font size="2"   >&nbsp; &nbsp; if (contexts[cpu] != NULL) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_kfree(contexts[cpu]);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; contexts[cpu] = NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; return rc;</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >static void systemtap_module_refresh (void) {</font></div><div><font size="2"   >&nbsp; int i=0, j=0;</font></div><div><font size="2"   >&nbsp; (void) i;</font></div><div><font size="2"   >&nbsp; (void) j;</font></div><div><font size="2"   >&nbsp; for (i=0; i&lt;1; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; struct stap_dwarf_probe *sdp = &amp; stap_dwarf_probes[i];</font></div><div><font size="2"   >&nbsp; &nbsp; struct stap_dwarf_kprobe *kp = &amp; stap_dwarf_kprobes[i];</font></div><div><font size="2"   >&nbsp; &nbsp; unsigned long relocated_addr = _stp_kmodule_relocate (sdp-&gt;module, sdp-&gt;section, sdp-&gt;address);</font></div><div><font size="2"   >&nbsp; &nbsp; int rc;</font></div><div><font size="2"   >&nbsp; &nbsp; if (sdp-&gt;registered_p == 0 &amp;&amp; relocated_addr != 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (sdp-&gt;return_p) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;u.krp.kp.addr = (void *) relocated_addr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (sdp-&gt;maxactive_p) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;u.krp.maxactive = sdp-&gt;maxactive_val;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; } else {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;u.krp.maxactive = KRETACTIVE;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;u.krp.handler = &amp;enter_kretprobe_probe;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,25)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (sdp-&gt;entry_probe) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;u.krp.entry_handler = &amp;enter_kretprobe_entry_probe;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;u.krp.data_size = sdp-&gt;saved_longs * sizeof(int64_t) +&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sdp-&gt;saved_strings * MAXSTRINGLEN;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #ifdef __ia64__</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;dummy.addr = kp-&gt;u.krp.kp.addr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;dummy.pre_handler = NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rc = register_kprobe (&amp; kp-&gt;dummy);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (rc == 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc = register_kretprobe (&amp; kp-&gt;u.krp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (rc != 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unregister_kprobe (&amp; kp-&gt;dummy);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rc = register_kretprobe (&amp; kp-&gt;u.krp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; } else {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;u.kp.addr = (void *) relocated_addr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;u.kp.pre_handler = &amp;enter_kprobe_probe;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #ifdef __ia64__</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;dummy.addr = kp-&gt;u.kp.addr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; kp-&gt;dummy.pre_handler = NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rc = register_kprobe (&amp; kp-&gt;dummy);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (rc == 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc = register_kprobe (&amp; kp-&gt;u.kp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (rc != 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unregister_kprobe (&amp; kp-&gt;dummy);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; rc = register_kprobe (&amp; kp-&gt;u.kp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (rc == 0) sdp-&gt;registered_p = 1;</font></div><div><font size="2"   >&nbsp; &nbsp; } else if (sdp-&gt;registered_p == 1 &amp;&amp; relocated_addr == 0) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (sdp-&gt;return_p) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; unregister_kretprobe (&amp;kp-&gt;u.krp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; atomic_add (kp-&gt;u.krp.nmissed, &amp; skipped_count);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (kp-&gt;u.krp.nmissed)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _stp_warn ("Skipped due to missed kretprobe/1 on '%s': %d\n", sdp-&gt;probe-&gt;pp, kp-&gt;u.krp.nmissed);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; atomic_add (kp-&gt;u.krp.kp.nmissed, &amp; skipped_count);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (kp-&gt;u.krp.kp.nmissed)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _stp_warn ("Skipped due to missed kretprobe/2 on '%s': %lu\n", sdp-&gt;probe-&gt;pp, kp-&gt;u.krp.kp.nmissed);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; } else {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; unregister_kprobe (&amp;kp-&gt;u.kp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; atomic_add (kp-&gt;u.kp.nmissed, &amp; skipped_count);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (kp-&gt;u.kp.nmissed)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _stp_warn ("Skipped due to missed kprobe on '%s': %lu\n", sdp-&gt;probe-&gt;pp, kp-&gt;u.kp.nmissed);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #if defined(__ia64__)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; unregister_kprobe (&amp;kp-&gt;dummy);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; sdp-&gt;registered_p = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >static void systemtap_module_exit (void) {</font></div><div><font size="2"   >&nbsp; int holdon;</font></div><div><font size="2"   >&nbsp; int i=0, j=0;</font></div><div><font size="2"   >&nbsp; int cpu;</font></div><div><font size="2"   >&nbsp; unsigned long hold_start;</font></div><div><font size="2"   >&nbsp; int hold_index;</font></div><div><font size="2"   >&nbsp; (void) i;</font></div><div><font size="2"   >&nbsp; (void) j;</font></div><div><font size="2"   >&nbsp; if (atomic_read (&amp;session_state) == STAP_SESSION_STARTING)</font></div><div><font size="2"   >&nbsp; &nbsp; return;</font></div><div><font size="2"   >&nbsp; if (atomic_read (&amp;session_state) == STAP_SESSION_RUNNING)</font></div><div><font size="2"   >&nbsp; &nbsp; atomic_set (&amp;session_state, STAP_SESSION_STOPPING);</font></div><div><font size="2"   >&nbsp; #if defined(STAPCONF_UNREGISTER_KPROBES)</font></div><div><font size="2"   >&nbsp; j = 0;</font></div><div><font size="2"   >&nbsp; for (i=0; i&lt;1; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; struct stap_dwarf_probe *sdp = &amp; stap_dwarf_probes[i];</font></div><div><font size="2"   >&nbsp; &nbsp; struct stap_dwarf_kprobe *kp = &amp; stap_dwarf_kprobes[i];</font></div><div><font size="2"   >&nbsp; &nbsp; if (! sdp-&gt;registered_p) continue;</font></div><div><font size="2"   >&nbsp; &nbsp; if (!sdp-&gt;return_p)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; stap_unreg_kprobes[j++] = &amp;kp-&gt;u.kp;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; unregister_kprobes((struct kprobe **)stap_unreg_kprobes, j);</font></div><div><font size="2"   >&nbsp; j = 0;</font></div><div><font size="2"   >&nbsp; for (i=0; i&lt;1; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; struct stap_dwarf_probe *sdp = &amp; stap_dwarf_probes[i];</font></div><div><font size="2"   >&nbsp; &nbsp; struct stap_dwarf_kprobe *kp = &amp; stap_dwarf_kprobes[i];</font></div><div><font size="2"   >&nbsp; &nbsp; if (! sdp-&gt;registered_p) continue;</font></div><div><font size="2"   >&nbsp; &nbsp; if (sdp-&gt;return_p)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; stap_unreg_kprobes[j++] = &amp;kp-&gt;u.krp;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; unregister_kretprobes((struct kretprobe **)stap_unreg_kprobes, j);</font></div><div><font size="2"   >&nbsp; #ifdef __ia64__</font></div><div><font size="2"   >&nbsp; j = 0;</font></div><div><font size="2"   >&nbsp; for (i=0; i&lt;1; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; struct stap_dwarf_probe *sdp = &amp; stap_dwarf_probes[i];</font></div><div><font size="2"   >&nbsp; &nbsp; struct stap_dwarf_kprobe *kp = &amp; stap_dwarf_kprobes[i];</font></div><div><font size="2"   >&nbsp; &nbsp; if (! sdp-&gt;registered_p) continue;</font></div><div><font size="2"   >&nbsp; &nbsp; stap_unreg_kprobes[j++] = &amp;kp-&gt;dummy;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; unregister_kprobes((struct kprobe **)stap_unreg_kprobes, j);</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; for (i=0; i&lt;1; i++) {</font></div><div><font size="2"   >&nbsp; &nbsp; struct stap_dwarf_probe *sdp = &amp; stap_dwarf_probes[i];</font></div><div><font size="2"   >&nbsp; &nbsp; struct stap_dwarf_kprobe *kp = &amp; stap_dwarf_kprobes[i];</font></div><div><font size="2"   >&nbsp; &nbsp; if (! sdp-&gt;registered_p) continue;</font></div><div><font size="2"   >&nbsp; &nbsp; if (sdp-&gt;return_p) {</font></div><div><font size="2"   >&nbsp; &nbsp; #if !defined(STAPCONF_UNREGISTER_KPROBES)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; unregister_kretprobe (&amp;kp-&gt;u.krp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; atomic_add (kp-&gt;u.krp.nmissed, &amp; skipped_count);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (kp-&gt;u.krp.nmissed)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; _stp_warn ("Skipped due to missed kretprobe/1 on '%s': %d\n", sdp-&gt;probe-&gt;pp, kp-&gt;u.krp.nmissed);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; atomic_add (kp-&gt;u.krp.kp.nmissed, &amp; skipped_count);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (kp-&gt;u.krp.kp.nmissed)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; _stp_warn ("Skipped due to missed kretprobe/2 on '%s': %lu\n", sdp-&gt;probe-&gt;pp, kp-&gt;u.krp.kp.nmissed);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; } else {</font></div><div><font size="2"   >&nbsp; &nbsp; #if !defined(STAPCONF_UNREGISTER_KPROBES)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; unregister_kprobe (&amp;kp-&gt;u.kp);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; atomic_add (kp-&gt;u.kp.nmissed, &amp; skipped_count);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (kp-&gt;u.kp.nmissed)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; _stp_warn ("Skipped due to missed kprobe on '%s': %lu\n", sdp-&gt;probe-&gt;pp, kp-&gt;u.kp.nmissed);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; #if !defined(STAPCONF_UNREGISTER_KPROBES) &amp;&amp; defined(__ia64__)</font></div><div><font size="2"   >&nbsp; &nbsp; unregister_kprobe (&amp;kp-&gt;dummy);</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; sdp-&gt;registered_p = 0;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; #ifdef STAPCONF_SYNCHRONIZE_SCHED</font></div><div><font size="2"   >&nbsp; synchronize_sched();</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; hold_start = jiffies;</font></div><div><font size="2"   >&nbsp; hold_index = -1;</font></div><div><font size="2"   >&nbsp; do {</font></div><div><font size="2"   >&nbsp; &nbsp; int i;</font></div><div><font size="2"   >&nbsp; &nbsp; holdon = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; for_each_possible_cpu(i)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (contexts[i] != NULL &amp;&amp; atomic_read (&amp; contexts[i]-&gt;busy)) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; holdon = 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (time_after(jiffies, hold_start + HZ) &amp;&amp; (i &gt; hold_index)) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hold_index = i;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printk(KERN_ERR "%s context[%d] stuck: %s\n", THIS_MODULE-&gt;name, i, contexts[i]-&gt;probe_point);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STAP_OVERRIDE_STUCK_CONTEXT</font></div><div><font size="2"   >&nbsp; &nbsp; if (time_after(jiffies, hold_start + HZ*10)) {&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; printk(KERN_ERR "%s overriding stuck context to allow module shutdown.", THIS_MODULE-&gt;name);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; holdon = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; #else</font></div><div><font size="2"   >&nbsp; &nbsp; msleep (250);</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; yield ();</font></div><div><font size="2"   >&nbsp; } while (holdon);</font></div><div><font size="2"   >&nbsp; atomic_set (&amp;session_state, STAP_SESSION_STOPPED);</font></div><div><font size="2"   >&nbsp; #ifdef STAPCONF_SYNCHRONIZE_SCHED</font></div><div><font size="2"   >&nbsp; synchronize_sched();</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; for_each_possible_cpu(cpu) {</font></div><div><font size="2"   >&nbsp; &nbsp; if (contexts[cpu] != NULL) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_kfree(contexts[cpu]);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; contexts[cpu] = NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; #ifdef STAP_NEED_GETTIMEOFDAY</font></div><div><font size="2"   >&nbsp; &nbsp;_stp_kill_time();</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; preempt_disable();</font></div><div><font size="2"   >&nbsp; #if defined(STP_TIMING) || defined(STP_ALIBI)</font></div><div><font size="2"   >&nbsp; _stp_printf("----- probe hit report: \n");</font></div><div><font size="2"   >&nbsp; for (i = 0; i &lt; ARRAY_SIZE(stap_probes); ++i) {</font></div><div><font size="2"   >&nbsp; &nbsp; struct stap_probe *const p = &amp;stap_probes[i];</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STP_ALIBI</font></div><div><font size="2"   >&nbsp; &nbsp; int alibi = atomic_read(&amp;(p-&gt;alibi));</font></div><div><font size="2"   >&nbsp; &nbsp; if (alibi)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_printf ("%s, (%s), hits: %d,%s\n",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p-&gt;pp, p-&gt;location, alibi, p-&gt;derivation);</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; if (likely (p-&gt;timing)) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; struct stat_data *stats = _stp_stat_get (p-&gt;timing, 0);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (stats-&gt;count) {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int64_t avg = _stp_div64 (NULL, stats-&gt;sum, stats-&gt;count);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; _stp_printf ("%s, (%s), hits: %lld, cycles: %lldmin/%lldavg/%lldmax,%s\n",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p-&gt;pp, p-&gt;location, (long long) stats-&gt;count,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (long long) stats-&gt;min, (long long) avg, (long long) stats-&gt;max,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p-&gt;derivation);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; _stp_stat_del (p-&gt;timing);</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; _stp_print_flush();</font></div><div><font size="2"   >&nbsp; #endif</font></div><div><font size="2"   >&nbsp; if (atomic_read (&amp; skipped_count) || atomic_read (&amp; error_count) || atomic_read (&amp; skipped_count_reentrant)) {</font></div><div><font size="2"   >&nbsp; &nbsp; _stp_warn ("Number of errors: %d, skipped probes: %d\n", (int) atomic_read (&amp; error_count), (int) atomic_read (&amp; skipped_count));</font></div><div><font size="2"   >&nbsp; &nbsp; #ifdef STP_TIMING</font></div><div><font size="2"   >&nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; int ctr;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; ctr = atomic_read (&amp; skipped_count_lowstack);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (ctr) _stp_warn ("Skipped due to low stack: %d\n", ctr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; ctr = atomic_read (&amp; skipped_count_reentrant);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (ctr) _stp_warn ("Skipped due to reentrancy: %d\n", ctr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; ctr = atomic_read (&amp; skipped_count_uprobe_reg);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (ctr) _stp_warn ("Skipped due to uprobe register failure: %d\n", ctr);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; ctr = atomic_read (&amp; skipped_count_uprobe_unreg);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; if (ctr) _stp_warn ("Skipped due to uprobe unregister failure: %d\n", ctr);</font></div><div><font size="2"   >&nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; #endif</font></div><div><font size="2"   >&nbsp; &nbsp; _stp_print_flush();</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; preempt_enable_no_resched();</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >#include "stap-symbols.h"</font></div><div><font size="2"   >MODULE_DESCRIPTION("systemtap-generated probe");</font></div><div><font size="2"   >MODULE_LICENSE("GPL");</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>