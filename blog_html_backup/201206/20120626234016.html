<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">cann't use pg_class's trigger trace user_table's create,modify,delete Time</h2>
	<h5 id="">2012-06-26 23:40:16&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012526105017774/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">最近经常有朋友会问在PostgreSQL中如何查询表的创建时间, MODIFY时间, 删除时间等.<div>首先来理一理思路:</div><div>1. PostgreSQL中pg_class系统表存储了表, 索引, 视图, 序列, TOAST 等数据对象的基本元信息。</div><div>&nbsp; &nbsp; 每次创建一个新的对象都会往这个系统表插入一条记录。</div><div>&nbsp; &nbsp; 当涉及到这个系统表的元信息更新时，记录会随之更新。</div><div>&nbsp; &nbsp; 那么是否可以在pg_class上创建触发器来跟踪一下pg_class里面每条记录的轨迹呢? 从而就可以知道表是什么时候创建的，什么时候被修改的，什么时候被删除的了。就用我前面讲到的HSTORE来存储。</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201252575529358/"   >http://blog.163.com/digoal@126/blog/static/163877040201252575529358/</a> </div><div>这样可行吗？</div><div>答案是不可行，不是因为不能在pg_class上创建触发器，而是触发器没有办法被触发。</div><div>如果你需要测试一下的话, 在pg_class上创建触发器前请修改一个隐含参数 : &nbsp;( allow_system_table_mods = on ) 然后重启数据库.</div><div>注意这个参数比较危险，请慎用。</div><div>想要得到更详细的情形, 使用gdb进行跟踪.</div><div><br></div><div>2. 既然trigger没有办法被触发, 那么rule行不行呢, 我这里测试了是不行的。</div><div><br></div><div>3. 那么在pg_class里面还有什么信息可以挖掘的?</div><div>还记得tupleHead么? 里面有几个隐含字段, ctic, cmin, cmax, xmin, xmax.</div><div>xmin和xmax分别记录的是记录被插入的事务ID和被更新时的事务ID, 而事务ID和时间是挂钩的, 只是事务ID的信息要和时间匹配上的话, 需要检索pg_xlog里面的信息.</div><div>而且事务ID是可能被vacuum掉成为frozenXID的, 那就没有参考价值了. 索引使用xmin, xmax来搜寻表的创建时间也就不可取了.</div><div><br></div><div>4. 那么外挂一个程序实时的去查询pg_class的新增数据并记录到一个新表行不行呢?</div><div>&nbsp; &nbsp;这个办法理论上来说是可行的, pg_class 的 oid字段上是有索引的, 而且oid是往上增长的, (当然系统中不建议创建with oid的用户表)</div><div>&nbsp; &nbsp;查询max(oid)的值与自建的用来存储表信息的表的max(oid)进行比较, 不相等则表示有新增数据进入, 把新增的数据插入到自建表即可.</div><div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=# create table table_pg_class (reloid oid, relname text, relnsp oid, relkind text, crt_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >create or replace function rec_pg_class () returns int as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >src_max_oid oid;</font></div><div><font size="2"   >des_max_oid oid;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >select max(oid) into src_max_oid from pg_class;</font></div><div><font size="2"   >select max(reloid) into des_max_oid from table_pg_class;</font></div><div><font size="2"   >if ( src_max_oid &lt;&gt; des_max_oid or des_max_oid is null ) then</font></div><div><font size="2"   >insert into table_pg_class (reloid,relname,relnsp,relkind,crt_time) select t1.oid,t1.relname,t1.relnamespace,t1.relkind,now() from pg_class t1 &nbsp;where oid not in (select reloid from table_pg_class t2);</font></div><div><font size="2"   >end if;</font></div><div><font size="2"   >return 0;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# create index idx_pg_class_1 on table_pg_class (reloid);</font></div><div><font size="2"   >CREATE INDEX</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# create table test (id int);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select * from rec_pg_class();</font></div><div><font size="2"   >&nbsp;rec_pg_class&nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select count(*) from table_pg_class ;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp;297</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select count(*) from pg_class;</font></div><div><font size="2"   >&nbsp;count&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp;297</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >digoal=# select * from table_pg_class where relname='test';</font></div><div><font size="2"   >&nbsp;reloid | relname | relnsp | relkind | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------+---------+--------+---------+----------------------------</font></div><div><font size="2"   >&nbsp; 24103 | test &nbsp; &nbsp;| &nbsp; 2200 | r &nbsp; &nbsp; &nbsp; | 2012-06-26 23:36:29.653227</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# select * from rec_pg_class();</font></div><div><font size="2"   >&nbsp;rec_pg_class&nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Time: 0.307 ms</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=# explain select max(oid) into src_max_oid from pg_class;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Result &nbsp;(cost=0.05..0.06 rows=1 width=0)</font></div><div><font size="2"   >&nbsp; &nbsp;InitPlan 1 (returns $0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;-&gt; &nbsp;Limit &nbsp;(cost=0.00..0.05 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan Backward using pg_class_oid_index on pg_class &nbsp;(cost=0.00..15.15 rows=280 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (oid IS NOT NULL)</font></div><div><font size="2"   >(5 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Time: 0.529 ms</font></div><div><font size="2"   >digoal=# explain select max(reloid) into des_max_oid from table_pg_class;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Result &nbsp;(cost=0.04..0.05 rows=1 width=0)</font></div><div><font size="2"   >&nbsp; &nbsp;InitPlan 1 (returns $0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;-&gt; &nbsp;Limit &nbsp;(cost=0.00..0.04 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan Backward using idx_pg_class_1 on table_pg_class &nbsp;(cost=0.00..10.40 rows=294 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (reloid IS NOT NULL)</font></div><div><font size="2"   >(5 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Time: 0.389 ms</font></div></div><div></div><p></p></pre></div></div><div>rec_pg_class()这个函数的调用可以放在操作系统的crontab里面.</div><div><br></div><div>5. 当然传统的方法还有使用csvlog来查询表的创建时间, 这个需要配置postgresql.conf的log_statement='ddl', 那么会记录下所有的DDL语句, 当然包含表的创建语句. 以及时间等信息.</div><div><br></div><div>6. 查看表对应的文件的时间戳也是一种办法, 只是表在被truncate, cluster, rewrite后都会改变文件的创建时间, 或新建文件. 所以不是太准确.</div><div><br></div><div>那么最后，还有什么方法呢?</div><div>PostgreSQL支持钩子, 所以用钩子来实现是最靠谱的.</div><div>例如</div><div><a target="_blank" rel="nofollow" href="http://pgxn.org/dist/pgaudit/1.0.0/"   >http://pgxn.org/dist/pgaudit/1.0.0/</a></div></div>
	</div>
</div>
</body>
</html>