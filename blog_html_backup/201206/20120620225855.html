<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">分页优化, add max_tag column speedup Query in max match enviroment</h2>
	<h5 id="">2012-06-20 22:58:55&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012520105855757/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div>昨天在一个业务库中发现一个比较耗时的SQL, 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >select t.APP_ID, t.APP_VER, t.CN_NAME, t.PACKAGE, t.APK_SIZE, t.APP_SHOW_VER, t.DESCRIPTION,t.CONTENT_PROVIDER,at.APP_TAG,h.SCORE &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >from&nbsp;</font></div><div><font size="2"  >(select APP_ID,max(APP_VER) APP_VER from test1 group by APP_ID) s</font></div><div><font size="2"  >join test1 t</font></div><div><font size="2"  >on s.APP_ID=t.APP_ID and s.APP_VER=t.APP_VER and t.DELETED=0 &nbsp;</font></div><div><font size="2"  >left outer join test2 at&nbsp;</font></div><div><font size="2"  >on t.APP_ID=at.APP_ID &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >left outer join&nbsp;</font></div><div><font size="2"  >test3 h&nbsp;</font></div><div><font size="2"  >on t.APP_ID=h.APP_ID &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >limit 24 offset 0;</font></div><p></p></pre></div><div>注意到这里面有一个子查询select APP_ID,max(APP_VER) APP_VER from test1 group by APP_ID, 用来取出app_id上面的max(app_ver).</div><div>也就是要检索的是最大版本的app_id. 每个表上的app_id上都有索引.&nbsp;</div><div><br></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >create index idx_test1_2 on test1(app_id);</font></div><div><font size="2"  >create index idx_test2_1 on test2(app_id);</font></div><div><font size="2"  >create index idx_test3_1 on test3(app_id);</font></div><p></p></pre></div><div><br></div><div>目前的执行计划如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; explain analyze select t.APP_ID, t.APP_VER, t.CN_NAME, t.PACKAGE, t.APK_SIZE, t.APP_SHOW_VER, t.DESCRIPTION,t.CONTENT_PROVIDER,at.APP_TAG,h.SCORE &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >from&nbsp;</font></div><div><font size="2"  >(select APP_ID,max(APP_VER) APP_VER from test1 group by APP_ID) s</font></div><div><font size="2"  >join test1 t</font></div><div><font size="2"  >on s.APP_ID=t.APP_ID and s.APP_VER=t.APP_VER and t.DELETED=0 &nbsp;</font></div><div><font size="2"  >left outer join test2 at&nbsp;</font></div><div><font size="2"  >on t.APP_ID=at.APP_ID &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >left outer join&nbsp;</font></div><div><font size="2"  >test3 h&nbsp;</font></div><div><font size="2"  >on t.APP_ID=h.APP_ID &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >limit 24 offset 0;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >------------------------</font></div><div><font size="2"  >&nbsp;Limit &nbsp;(cost=0.00..13251.13 rows=24 width=530) (actual time=0.054..0.447 rows=24 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Nested Loop Left Join &nbsp;(cost=0.00..41409.79 rows=75 width=530) (actual time=0.053..0.442 rows=24 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Merge Left Join &nbsp;(cost=0.00..41387.81 rows=75 width=527) (actual time=0.046..0.318 rows=24 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Merge Cond: (t.app_id = at.app_id)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Merge Join &nbsp;(cost=0.00..41372.03 rows=75 width=526) (actual time=0.036..0.290 rows=24 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Merge Cond: (test1.app_id = t.app_id)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Join Filter: ((max(test1.app_ver)) = t.app_ver)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;GroupAggregate &nbsp;(cost=0.00..19900.37 rows=80420 width=11) (actual time=0.020..0.160 rows=25 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test1_2 on test1 &nbsp;(cost=0.00..18542.94 rows=110646 width=11) (actual time=0.013.</font></div><div><font size="2"  >.0.116 rows=62 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test1_2 on test1 t &nbsp;(cost=0.00..18819.56 rows=109790 width=526) (actual time=0.012..0.</font></div><div><font size="2"  >076 rows=60 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (deleted = 0::numeric)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test2_1 on test2 at &nbsp;(cost=0.00..14.39 rows=476 width=7) (actual time=0.009..0.010 rows=6 lo</font></div><div><font size="2"  >ops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test3_1 on test3 h &nbsp;(cost=0.00..0.28 rows=1 width=9) (actual time=0.004..0.005 rows=1 loops=24)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (t.app_id = app_id)</font></div><div><font size="2"  >&nbsp;Total runtime: 0.565 ms</font></div><div><font size="2"  >(15 rows)</font></div><p></p></pre></div><div><br></div><div>-- offset&nbsp;<span style="line-height: 22px;"  >100000 后执行时间就变得很漫长</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; explain analyze select t.APP_ID, t.APP_VER, t.CN_NAME, t.PACKAGE, t.APK_SIZE, t.APP_SHOW_VER, t.DESCRIPTION,t.CONTENT_PROVIDER,at.APP_TAG,h.SCORE &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >digoal-&gt; from&nbsp;</font></div><div><font size="2"  >digoal-&gt; (select APP_ID,max(APP_VER) APP_VER from test1 group by APP_ID) s</font></div><div><font size="2"  >digoal-&gt; join test1 t</font></div><div><font size="2"  >digoal-&gt; on s.APP_ID=t.APP_ID and s.APP_VER=t.APP_VER and t.DELETED=0 &nbsp;</font></div><div><font size="2"  >digoal-&gt; left outer join test2 at&nbsp;</font></div><div><font size="2"  >digoal-&gt; on t.APP_ID=at.APP_ID &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >digoal-&gt; left outer join&nbsp;</font></div><div><font size="2"  >digoal-&gt; test3 h&nbsp;</font></div><div><font size="2"  >digoal-&gt; on t.APP_ID=h.APP_ID &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >digoal-&gt; limit 24 offset&nbsp; <span style="line-height: 22px;"  >100000</span>;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >------------------------------</font></div><div><font size="2"  >&nbsp;Limit &nbsp;(cost=42009.25..42009.25 rows=1 width=531) (actual time=1060.506..1060.506 rows=0 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Nested Loop Left Join &nbsp;(cost=0.00..42009.25 rows=73 width=531) (actual time=0.088..1051.995 rows=92075 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Merge Left Join &nbsp;(cost=0.00..41987.83 rows=73 width=528) (actual time=0.073..605.712 rows=92075 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Merge Cond: (t.app_id = at.app_id)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Merge Join &nbsp;(cost=0.00..41972.06 rows=73 width=527) (actual time=0.056..564.375 rows=92075 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Merge Cond: (test1.app_id = t.app_id)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Join Filter: ((max(test1.app_ver)) = t.app_ver)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;GroupAggregate &nbsp;(cost=0.00..20200.50 rows=79932 width=11) (actual time=0.030..279.882 rows=92796 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test1_2 on test1 &nbsp;(cost=0.00..18847.95 rows=110646 width=11) (actual time=0.015.</font></div><div><font size="2"  >.155.840 rows=110646 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test1_2 on test1 t &nbsp;(cost=0.00..19124.56 rows=109857 width=527) (actual time=0.019..15</font></div><div><font size="2"  >4.435 rows=109855 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filter: (deleted = 0::numeric)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test2_1 on test2 at &nbsp;(cost=0.00..14.39 rows=476 width=7) (actual time=0.015..0.283 rows=476&nbsp;</font></div><div><font size="2"  >loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test3_1 on test3 h &nbsp;(cost=0.00..0.28 rows=1 width=9) (actual time=0.004..0.004 rows=1 loops=92075)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Index Cond: (t.app_id = app_id)</font></div><div><font size="2"  >&nbsp;Total runtime: 1060.683 ms</font></div><div><font size="2"  >(15 rows)</font></div><p></p></pre></div><div><br></div><div><br></div><div>【优化1】 :&nbsp;</div><div>消除子查询,&nbsp;<span style="line-height: 22px;"  >select APP_ID,max(APP_VER) APP_VER from test1 group by APP_ID .&nbsp;</span></div><div><span style="line-height: 22px;"  >这是个读多写少的表, 所以可以这么来优化.</span></div><div>通过增加一个ismax字段, 标记该app_id的app_ver是否是max版本. 因此需要建立一个触发器来完成这个字段的更新, 确保最新的状态.</div><div>另外需要一个约束, 确保不会出现ismax重复为true的情况. (由于并发的情况下这个比较难保证, 新增的数据可能都会认为自己是max的版本,所以还有优化2).</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >alter table test1 add column ismax boolean ;</font></div><div><font size="2"  >update test1 set ismax = true where (app_id,app_ver) in (select app_id,max(app_ver) from test1 group by app_id);</font></div><div><font size="2"  >create index idx_test1_1 on test1(app_id) where ismax is true and deleted=0;</font></div><p></p></pre></div><div><br></div><div>-- 修改后的查询SQL :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >select t.APP_ID, t.APP_VER, t.CN_NAME, t.PACKAGE, t.APK_SIZE, t.APP_SHOW_VER, t.DESCRIPTION,t.CONTENT_PROVIDER,at.APP_TAG,h.SCORE &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >from&nbsp;</font></div><div><font size="2"  >test1 t</font></div><div><font size="2"  >left outer join test2 at&nbsp;</font></div><div><font size="2"  >on (t.APP_ID=at.APP_ID and t.DELETED=0 and t.ismax is true)</font></div><div><font size="2"  >left outer join&nbsp;</font></div><div><font size="2"  >test3 h&nbsp;</font></div><div><font size="2"  >on (t.APP_ID=h.APP_ID)</font></div><div><font size="2"  >limit 24 offset 0;</font></div><p></p></pre></div><div><br></div><div>-- 修改后的执行计划</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; explain analyze select t.APP_ID, t.APP_VER, t.CN_NAME, t.PACKAGE, t.APK_SIZE, t.APP_SHOW_VER, t.DESCRIPTION,t.CONTENT_PROVIDER,at.APP_TAG,h.SCORE &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >from&nbsp;</font></div><div><font size="2"  >test1 t</font></div><div><font size="2"  >left outer join test2 at&nbsp;</font></div><div><font size="2"  >on (t.APP_ID=at.APP_ID and t.DELETED=0 and t.ismax is true)</font></div><div><font size="2"  >left outer join&nbsp;</font></div><div><font size="2"  >test3 h&nbsp;</font></div><div><font size="2"  >on (t.APP_ID=h.APP_ID)</font></div><div><font size="2"  >limit 24 offset 0;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >---------------------</font></div><div><font size="2"  >&nbsp;Limit &nbsp;(cost=0.00..5.04 rows=24 width=530) (actual time=0.060..0.242 rows=24 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Merge Right Join &nbsp;(cost=0.00..23241.69 rows=110646 width=530) (actual time=0.059..0.231 rows=24 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Merge Cond: (h.app_id = t.app_id)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test3_1 on test3 h &nbsp;(cost=0.00..2511.68 rows=89962 width=9) (actual time=0.017..0.030 rows=8 loops</font></div><div><font size="2"  >=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Materialize &nbsp;(cost=0.00..19122.03 rows=110646 width=527) (actual time=0.037..0.163 rows=24 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Merge Left Join &nbsp;(cost=0.00..18845.41 rows=110646 width=527) (actual time=0.032..0.126 rows=24 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Merge Cond: (t.app_id = at.app_id)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Join Filter: ((t.ismax IS TRUE) AND (t.deleted = 0::numeric))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test1_2 on test1 t &nbsp;(cost=0.00..18542.94 rows=110646 width=530) (actual time=0.013..0.</font></div><div><font size="2"  >055 rows=24 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Materialize &nbsp;(cost=0.00..15.58 rows=476 width=7) (actual time=0.014..0.017 rows=8 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test2_1 on test2 at &nbsp;(cost=0.00..14.39 rows=476 width=7) (actual time=0.013..0.0</font></div><div><font size="2"  >15 rows=3 loops=1)</font></div><div><font size="2"  >&nbsp;Total runtime: 0.345 ms</font></div><div><font size="2"  >(12 rows)</font></div><p></p></pre></div><div><br></div><div>-- 修改后的最长执行时间.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=&gt; explain analyze select t.APP_ID, t.APP_VER, t.CN_NAME, t.PACKAGE, t.APK_SIZE, t.APP_SHOW_VER, t.DESCRIPTION,t.CONTENT_PROVIDER,at.APP_TAG,h.SCORE &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >from&nbsp;</font></div><div><font size="2"  >test1 t</font></div><div><font size="2"  >left outer join test2 at&nbsp;</font></div><div><font size="2"  >on (t.APP_ID=at.APP_ID and t.DELETED=0 and t.ismax is true)</font></div><div><font size="2"  >left outer join&nbsp;</font></div><div><font size="2"  >test3 h&nbsp;</font></div><div><font size="2"  >on (t.APP_ID=h.APP_ID)</font></div><div><font size="2"  >limit 24 offset&nbsp; <span style="line-height: 22px;"  >100000</span>;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >---------------------------</font></div><div><font size="2"  >&nbsp;Limit &nbsp;(cost=23606.24..23606.24 rows=1 width=531) (actual time=584.619..584.619 rows=0 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp;-&gt; &nbsp;Merge Right Join &nbsp;(cost=0.00..23606.24 rows=110646 width=531) (actual time=0.060..576.238 rows=110646 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Merge Cond: (h.app_id = t.app_id)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test3_1 on test3 h &nbsp;(cost=0.00..2566.38 rows=91875 width=9) (actual time=0.017..83.853 rows=91875&nbsp;</font></div><div><font size="2"  >loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Materialize &nbsp;(cost=0.00..19427.10 rows=110646 width=528) (actual time=0.037..353.038 rows=110646 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Merge Left Join &nbsp;(cost=0.00..19150.48 rows=110646 width=528) (actual time=0.032..261.624 rows=110646 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Merge Cond: (t.app_id = at.app_id)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Join Filter: ((t.ismax IS TRUE) AND (t.deleted = 0::numeric))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test1_2 on test1 t &nbsp;(cost=0.00..18847.95 rows=110646 width=531) (actual time=0.011..15</font></div><div><font size="2"  >9.184 rows=110646 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Materialize &nbsp;(cost=0.00..15.58 rows=476 width=7) (actual time=0.015..0.642 rows=900 loops=1)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-&gt; &nbsp;Index Scan using idx_test2_1 on test2 at &nbsp;(cost=0.00..14.39 rows=476 width=7) (actual time=0.013..0.3</font></div><div><font size="2"  >47 rows=476 loops=1)</font></div><div><font size="2"  >&nbsp;Total runtime: 584.740 ms</font></div><div><font size="2"  >(12 rows)</font></div><p></p></pre></div></div><div><br></div><div>【优化2】 :&nbsp;</div><div>通过优化1, 查询性能基本上有1倍左右的提升.&nbsp;</div><div>但是从总时长来看, 越到后面, 每一次翻页都需要消耗几百毫秒. 每页显示的数量越少, 全部翻完所消耗的时间就越长.</div><div>我们来用一个函数测试一下使用大小不一样的分页, 看看时间分别是多少.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >create or replace function f_test1(i_limit int) returns int as $$</font></div><div><font size="2"  >declare</font></div><div><font size="2"  >v_work int;</font></div><div><font size="2"  >v_count int;</font></div><div><font size="2"  >v_offset int;</font></div><div><font size="2"  >i int;</font></div><div><font size="2"  >begin</font></div><div><font size="2"  >v_work := 0;</font></div><div><font size="2"  >v_count := 0;</font></div><div><font size="2"  >v_offset := 0;</font></div><div><font size="2"  >i := 1;</font></div><div><font size="2"  >raise notice 'start time:%',clock_timestamp();</font></div><div><font size="2"  >loop</font></div><div><font size="2"  >&nbsp; select count(*) into v_work from&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; (select 1 from&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; test1 t</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; left outer join test2 at&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; on (t.APP_ID=at.APP_ID and t.DELETED=0 and t.ismax is true)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; left outer join&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; test3 h&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; on (t.APP_ID=h.APP_ID)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; limit i_limit offset v_offset</font></div><div><font size="2"  >&nbsp; &nbsp; )t;</font></div><div><font size="2"  >&nbsp; if v_work=0 then</font></div><div><font size="2"  >&nbsp; &nbsp; exit;</font></div><div><font size="2"  >&nbsp; end if;</font></div><div><font size="2"  >&nbsp; v_offset := i * i_limit;</font></div><div><font size="2"  >&nbsp; v_count := v_count + v_work;</font></div><div><font size="2"  >&nbsp; i := i+1;</font></div><div><font size="2"  >end loop;</font></div><div><font size="2"  >raise notice 'end time:%',clock_timestamp();</font></div><div><font size="2"  >return v_count;</font></div><div><font size="2"  >end;</font></div><div><font size="2"  >$$ language plpgsql;</font></div><p></p></pre></div><div><br></div><div>-- 测试每页10000条</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=&gt; select * from f_test1(10000);</font></div><div><font size="2"  >NOTICE: &nbsp;start time:2012-06-21 10:44:34.148575+08</font></div><div><font size="2"  >NOTICE: &nbsp;end time:2012-06-21 10:44:36.095619+08</font></div><div><font size="2"  >&nbsp;f_test1&nbsp;</font></div><div><font size="2"  >---------</font></div><div><font size="2"  >&nbsp; 110646</font></div><div><font size="2"  >(1 row)</font></div></div><div><font size="2"  >耗时2秒.</font></div><p></p></pre></div><div><br></div><div>-- 测试每页100条</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >digoal=&gt; select * from f_test1(100);</font></div><div><font size="2"  >NOTICE: &nbsp;start time:2012-06-21 10:44:45.448933+08</font></div><div><font size="2"  >NOTICE: &nbsp;end time:2012-06-21 10:46:53.070959+08</font></div><div><font size="2"  >&nbsp;f_test1&nbsp;</font></div><div><font size="2"  >---------</font></div><div><font size="2"  >&nbsp; 110646</font></div><div><font size="2"  >(1 row)</font></div></div><div><font size="2"  >耗时128秒.</font></div><p></p></pre></div><div><br></div><div>所以第二种优化手段是, 提高每页获取的数量, 增加应用层缓存, 也就是说每次取的页数多一点, 不用每一页都来数据库取. 当然如果应用能够一次把数据全取过去就最好了.</div><div><br></div><div>最后一点, 本例的分页SQL都没有ORDER BY, 算是个业务层的BUG, 这种分页是不可取的, 因为无法保证返回的顺序.</div><div>参考修改如下 :&nbsp;</div><div><pre class="prettyprint"  style="line-height: 22px;"  ><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >select t.APP_ID, t.APP_VER, t.CN_NAME, t.PACKAGE, t.APK_SIZE, t.APP_SHOW_VER, t.DESCRIPTION,t.CONTENT_PROVIDER,at.APP_TAG,h.SCORE &nbsp; &nbsp;&nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >from&nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >test1 t</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >left outer join test2 at&nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >on (t.APP_ID=at.APP_ID and t.DELETED=0 and t.ismax is true)</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >left outer join&nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >test3 h&nbsp;</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >on (t.APP_ID=h.APP_ID)</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >order by t.app_id</font></div><div style="line-height: 22px;"  ><font size="2"  style="line-height: 19px;"  >limit 24 offset 0;</font></div></pre></div></div>
	</div>
</div>
</body>
</html>