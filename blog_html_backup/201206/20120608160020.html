<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">use PostgreSQL bytea type custom uuid and range filter</h2>
	<h5 id="">2012-06-08 16:00:20&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020125825053773/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>今天和一位兄弟聊天的时候了解到的一个需求, 他们在业务中需要使用UUID来作为PK, 并且uuid里面可能要存储一些业务逻辑的信息.<span style="line-height: 22px;"  >同时可能会按照字段里面的位置范围的内容进行过滤或排序取数.</span></div><div>一开始想用uuid类型, 但是如果使用postgresql里面的uuid类型需要16字节,&nbsp;</div><div>看能不能使用其他字段来替代, 或者想自建一个类型.&nbsp;</div><div>我一开始想到的是mongoDB里面的_id的默认类型, BSON objectid</div><div><div>BSON ObjectID Specification</div><div><div><img title="use PostgreSQL bytea type custom uuid and range filter - 德哥@Digoal - The Heart,The World."  alt="use PostgreSQL bytea type custom uuid and range filter - 德哥@Digoal - The Heart,The World."  style="margin:0 10px 0 0;"  src="http://img5.ph.126.net/kVYS_6jtsAEY60m6DWKxew==/1561060220854913715.jpg"  ></div>&nbsp;bson objectid使用了12个字节, 相比UUID有一定的优势.</div></div><div>如上图, 分为四组, 分别存储epoch时间, 机器的md5, 进程ID, 自增数字.</div><div>那么这个怎么在PostgreSQL里面存储比较好呢?</div><div>1. varchar(12) , 1字节的头(长varchar则4字节头) , 因此存储12个字节实际需要13字节 (注意只有存储ascii码表里的字符时是占用1字节1字符, 如果存储中文则和选择的字符集有关, 一般是2-3字节)。</div><div>2. bit(96), 4字节的头,&nbsp;<span style="line-height: 22px;"  >因此存储12个字节实际需要17字节。</span></div><div>3. bytea, 1字节的头<span style="line-height: 22px;"  >(长bytea则4字节头),&nbsp;</span><span style="line-height: 22px;"  >因此存储12个字节实际需要13字节。</span></div><div><span style="line-height: 22px;"  ><br></span></div><div>所以选择bytea可能比较合适. 范围取值排序则可以通过substring()的函数索引来加速.</div><div>例如 :&nbsp;</div><div>-- 创建测试表</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# create table test (uid bytea check (octet_length(uid)=12));</font></div><div><font size="2"  >CREATE TABLE</font></div><p></p></pre></div><div>-- 这里假设需要按照最后两个字段查询或排序, 所以建立<span style="line-height: 22px;"  >substring(uid,11,2)索引</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# create index idx_test_uid on test (substring(uid,11,2));</font></div><div><font size="2"  >CREATE INDEX</font></div><p></p></pre></div></div><div>-- 插入测试数据, 建立了约束, 所以仅仅允许插入12字节</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# insert into test values (E'\\x0102030405060708090a0b0c0d');</font></div><div><font size="2"  >ERROR: &nbsp;new row for relation "test" violates check constraint "test_uid_check"</font></div><div><font size="2"  >DETAIL: &nbsp;Failing row contains (\x0102030405060708090a0b0c0d).</font></div><div><font size="2"  >postgres=# insert into test values (E'\\x0102030405060708090a0b0c');</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >postgres=# insert into test values (E'\\x0102030405060708090a0b01');</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >postgres=# insert into test values (E'\\x0102030405060708090a0b02');</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >postgres=# insert into test values (E'\\x0102030405060708090a0bff');</font></div><div><font size="2"  >INSERT 0 1</font></div><p></p></pre></div><div>-- 查看按最后两字节排序是否会走索引</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# explain select * from test order by substring(uid,11,2) ;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >--------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Index Scan using idx_test_uid on test &nbsp;(cost=0.00..6.32 rows=4 width=13)</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>-- 查看索引排序是否正常</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# select * from test order by substring(uid,11,2) ;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >----------------------------</font></div><div><font size="2"  >&nbsp;\x0102030405060708090a0b01</font></div><div><font size="2"  >&nbsp;\x0102030405060708090a0b02</font></div><div><font size="2"  >&nbsp;\x0102030405060708090a0b0c</font></div><div><font size="2"  >&nbsp;\x0102030405060708090a0bff</font></div><div><font size="2"  >(4 rows)</font></div><p></p></pre></div></div><div>-- 查看字段长度</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# select pg_column_size(uid) from test;</font></div><div><font size="2"  >&nbsp;pg_column_size&nbsp;</font></div><div><font size="2"  >----------------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;13</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;13</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;13</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;13</font></div><div><font size="2"  >(4 rows)</font></div><p></p></pre></div><div>-- 按照最后两个字段进行检索</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# explain select * from test where substring(uid,11,2) =bytea E'\\x0b01';</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >--------------------------------------------------------------------------</font></div><div><font size="2"  >&nbsp;Index Scan using idx_test_uid on test &nbsp;(cost=0.00..4.27 rows=1 width=13)</font></div><div><font size="2"  >&nbsp; &nbsp;Index Cond: ("substring"(uid, 11, 2) = '\\x0b01'::bytea)</font></div><div><font size="2"  >(2 rows)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >postgres=# select * from test where substring(uid,11,2) =bytea E'\\x0b01';</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >----------------------------</font></div><div><font size="2"  >&nbsp;\x0102030405060708090a0b01</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br></div><div>【参考】</div><wbr><div><a rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/datatype-binary.html"  >http://www.postgresql.org/docs/9.2/static/datatype-binary.html</a> </div><div><a rel="nofollow" href="http://www.mongodb.org/display/DOCS/Object+IDs#ObjectIDs-UUIDs"  >http://www.mongodb.org/display/DOCS/Object+IDs#ObjectIDs-UUIDs</a> </div><div><a rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/datatype-uuid.html"  >http://www.postgresql.org/docs/9.2/static/datatype-uuid.html</a> </div></div>
	</div>
</div>
</body>
</html>