<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL range gist index 20x+ speedup than Mysql index combine query</h2>
	<h5 id="">2012-06-07 0:24:17&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020125701029222/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">今天一位兄弟跟我抱怨MYSQL里面查IP地址库并发几千每秒的查询数据库就抗不住了.<div>于是问他要来了他们的IP地址库数据和查询用的SQL以及MYSQL里面的表结构。</div><div>把数据转到PostgreSQL里面做一下相对应的压力测试，看看PostgreSQL的表现。</div><div>MYSQL里面的表结构如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE TABLE ip_address_pool (</font></div><div><font size="2"   >&nbsp; id int(10) NOT NULL AUTO_INCREMENT COMMENT '自增主键',</font></div><div><font size="2"   >&nbsp; start_ip varchar(20) NOT NULL COMMENT '起始ip',</font></div><div><font size="2"   >&nbsp; end_ip varchar(20) NOT NULL COMMENT '截止ip',</font></div><div><font size="2"   >&nbsp; province varchar(128) NOT NULL COMMENT '省名',</font></div><div><font size="2"   >&nbsp; city varchar(128) NOT NULL COMMENT '城市',</font></div><div><font size="2"   >&nbsp; region_name varchar(128) NOT NULL COMMENT '地区名',</font></div><div><font size="2"   >&nbsp; company_name varchar(128) NOT NULL COMMENT '公司名',</font></div><div><font size="2"   >&nbsp; start_ip_decimal bigint(10) DEFAULT NULL,</font></div><div><font size="2"   >&nbsp; end_ip_decimal bigint(10) DEFAULT NULL,</font></div><div><font size="2"   >&nbsp; PRIMARY KEY (id),</font></div><div><font size="2"   >&nbsp; KEY idx_start_ip_Decimal (start_ip_decimal),</font></div><div><font size="2"   >&nbsp; KEY idx_end_ip_Decimal (end_ip_decimal)</font></div><div><font size="2"   >) ENGINE=InnoDB AUTO_INCREMENT=436820 DEFAULT CHARSET=utf8 COMMENT='ip地址对应表';</font></div><p></p></pre></div><div>MYSQL里面的查询SQL如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >select&nbsp;</font></div><div><font size="2"   >&nbsp; province,</font></div><div><font size="2"   >&nbsp; start_ip_Decimal as startIpDecimal,</font></div><div><font size="2"   >&nbsp; end_ip_Decimal as endIpDecimal</font></div><div><font size="2"   >&nbsp; from ip_address_pool</font></div><div><font size="2"   >&nbsp; where</font></div><div><font size="2"   >&nbsp; #{ip}&gt;=start_ip_Decimal and</font></div><div><font size="2"   >&nbsp; #{ip}&lt;=end_ip_Decimal;</font></div><p></p></pre></div><div>数据量大概40W.</div><div>由于MYSQL里面没有IP地址类型, &nbsp;所以他们把IP地址转换为数值类型来存储并用来做IP地址范围的匹配.</div><div>IP地址的转换算法是32位的二进制IP地址转10进制数字。</div>在PostgreSQL9.2里面新增了range类型, 例如可以用来存储ip地址范围, int值的范围.<div>具体的应用可以参见我以前写的BLOG :&nbsp;</div><div><div>《PostgreSQL 9.2 NEW Type, range》</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020124174238681/"   >http://blog.163.com/digoal@126/blog/static/16387704020124174238681/</a></div><div>《PostgreSQL 9.2 range type usage case》</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201241752537254/"   >http://blog.163.com/digoal@126/blog/static/163877040201241752537254/</a></div></div><div>因此这个应用场景, PostgreSQL有三种选择来实现它 :&nbsp;</div><div>1. 和MySQL里面一样, 使用两个字段分别存储起始的IP数字</div><div>2. 使用iprange, 直接存储IP地址范围</div><div>3. 使用int8range, 存储转换后的数字范围</div><div><br></div><div>接下来是三种方法的表结构 :&nbsp;</div><div>1.&nbsp;<span style="line-height: 22px;"   >和MySQL里面一样, 使用两个字段分别存储起始的IP数字</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE TABLE ip_address_pool (</font></div><div><font size="2"   >&nbsp; id serial8 primary key,</font></div><div><font size="2"   >&nbsp; start_ip inet NOT NULL ,</font></div><div><font size="2"   >&nbsp; end_ip inet NOT NULL ,</font></div><div><font size="2"   >&nbsp; province varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; city varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; region_name varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; company_name varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; start_ip_decimal bigint ,</font></div><div><font size="2"   >&nbsp; end_ip_decimal bigint&nbsp;</font></div><div><font size="2"   >) ;</font></div><div><font size="2"   >-- 以下索引其实只需要建一个就够了, PostgreSQL btree索引支持&gt;=,&gt;,&lt;=,&lt;,=等几种操作符, 同时IP地址段也不存在交叠的情况. </font></div><div><font size="2"   >-- 如何避免交叠呢, 在并发的情况下插入和更新ip_address_pool表, 是没有办法避免交叠情况的发生的, 例如</font></div><div><font size="2"   ><span style="line-height: 19px;"   >-- 1. 先查询需要插入的IP地址段是否已经存在表里面</span></font></div><div><font size="2"   ><span style="line-height: 19px;"   >-- 2. 不存在则插入.但是这里存在一个问题, 并发的情况下, 多个进程都可能认为插入的数据不存在, 都插入了, 但是并发插入的数据中可能有交叠的.</span></font></div><div><font size="2"   ><span style="line-height: 19px;"   >-- 3. 在MYSQL中只能使用全表锁来避免这个问题.</span></font></div><div><font size="2"   ><span style="line-height: 19px;"   >-- 4. 在PostgreSQL中则不需要全表锁, 因为可以使用range类型, 建立range类型的exclusive 约束, 这个在我前面两篇关于range的BLOG里面讲到过.</span></font></div><div><font size="2"   >create index idx_ip_address_pool_sip on ip_address_pool (start_ip_decimal);</font></div><div><font size="2"   >create index idx_ip_address_pool_eip on ip_address_pool (end_ip_decimal);</font></div></pre></div><div><span style="line-height: 22px;"   >2. 使用iprange, 直接存储IP地址范围</span> </div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create type iprange as range (subtype=inet);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CREATE TABLE ip_address_pool_2 (</font></div><div><font size="2"   >&nbsp; id serial8 primary key,</font></div><div><font size="2"   >&nbsp; ip_segment iprange NOT NULL ,</font></div><div><font size="2"   >&nbsp; province varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; city varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; region_name varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; company_name varchar(128) NOT NULL</font></div><div><font size="2"   >) ;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CREATE INDEX ip_address_pool_2_range ON ip_address_pool_2 USING gist (ip_segment);</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >3. 使用int8range, 存储转换后的数字范围</span> </div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE TABLE ip_address_pool_3 (</font></div><div><font size="2"   >&nbsp; id serial8 primary key,</font></div><div><font size="2"   >&nbsp; start_ip inet NOT NULL ,</font></div><div><font size="2"   >&nbsp; end_ip inet NOT NULL ,</font></div><div><font size="2"   >&nbsp; province varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; city varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; region_name varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; company_name varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; ip_decimal_segment int8range</font></div><div><font size="2"   >) ;</font></div><p></p></pre></div><div>-- 从第一个表把数据转换成range类型并存储到这个表</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >insert into ip_address_pool_3 (id,start_ip,end_ip,province,city,region_name,company_name,ip_decimal_segment) select id,start_ip,end_ip,province,city,region_name,company_name,int8range(start_ip_decimal,end_ip_decimal+1) from ip_address_pool;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >CREATE INDEX ip_address_pool_3_range ON ip_address_pool_3 USING gist (ip_decimal_segment);</font></div><p></p></pre></div></div><div><br></div><div>接下来测试一下第一种方法和第三种方法的性能差别 :&nbsp;</div><div>1.&nbsp;</div><div>测试脚本:</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp;\setrandom ip 0 2094967294</font></div><div><font size="2"   >select province, start_ip_Decimal as startIpDecimal, end_ip_Decimal as endIpDecimal from ip_address_pool where :ip&gt;=start_ip_Decimal and :ip&lt;=end_ip_Decimal;</font></div><p></p></pre></div><div>&nbsp;测试结果:</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg92@db-172-16-3-33-&gt; pgbench -M prepared -c 8 -j 8 -f ./ip_test.sql -n -T 60 -h 127.0.0.1 -U postgres postgres</font></div><div><font size="2"   >transaction type: Custom query<br>scaling factor: 1<br>query mode: simple<br>number of clients: 8<br>number of threads: 8<br>duration: 60 s<br>number of transactions actually processed: 20389<br>tps = 339.576580 (including connections establishing)<br>tps = 339.618604 (excluding connections establishing)</font></div><p></p></pre></div><div>为什么只有300多呢？原因是建立的不是复合索引, 注意因为这里使用的是范围检索, 不是= , 所以检索速度和取值范围关系很大, 分别取三个值, 从小到大. &nbsp;来看看查询耗时.</div><div><br></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# explain analyze select province, start_ip_Decimal as startIpDecimal, end_ip_Decimal as endIpDecimal from ip_address_pool where 1&gt;=start_ip_Decimal and 1&lt;=end_ip_Decimal;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >--------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_ip_address_pool_sip on ip_address_pool &nbsp;(cost=10000000000.00..10000000004.51 rows=1 width=22) (actual time=0.0</font></div><div><font size="2"   >04..0.004 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (1 &gt;= start_ip_decimal)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (1 &lt;= end_ip_decimal)</font></div><div><font size="2"   >&nbsp;Total runtime: 0.014 ms</font></div><div><font size="2"   >(4 rows)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# explain analyze select province, start_ip_Decimal as startIpDecimal, end_ip_Decimal as endIpDecimal from ip_address_pool where 1123371940&gt;=start_ip_Decimal and 1123371940&lt;=end_ip_Decimal;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >---------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_ip_address_pool_sip on ip_address_pool &nbsp;(cost=0.00..3899.49 rows=75277 width=22) (actual time=37.572..37.573 r</font></div><div><font size="2"   >ows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (1123371940 &gt;= start_ip_decimal)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (1123371940 &lt;= end_ip_decimal)</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Filter: 96523</font></div><div><font size="2"   >&nbsp;Total runtime: 37.604 ms</font></div><div><font size="2"   >(5 rows)</font></div></div><div><font size="2"   ><br></font></div><div><div><div><font size="2"   >postgres=# explain analyze select province, start_ip_Decimal as startIpDecimal, end_ip_Decimal as endIpDecimal from ip_address_pool where 4123371940&gt;=start_ip_Decimal and 4123371940&lt;=end_ip_Decimal;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >-----------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_ip_address_pool_sip on ip_address_pool &nbsp;(cost=0.00..17557.23 rows=1251 width=22) (actual time=168.138..168.139</font></div><div><font size="2"   >&nbsp;rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (4123371940::bigint &gt;= start_ip_decimal)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (4123371940::bigint &lt;= end_ip_decimal)</font></div><div><font size="2"   >&nbsp; &nbsp;Rows Removed by Filter: 436810</font></div><div><font size="2"   >&nbsp;Total runtime: 168.165 ms</font></div><div><font size="2"   >(5 rows)</font></div></div></div><p></p></pre></div><div><div><div>-- 所以需要建立复合索引,&nbsp;</div></div></div><div><pre class="prettyprint"   ><div><span style="line-height: 19px; font-size: small;"   >create index idx_ip_address_pool_ip on ip_address_pool (start_ip_decimal,</span><span style="font-size: small; line-height: 19px;"   >end_ip_decimal</span><span style="font-size: small; line-height: 19px;"   >);</span></div><div><span style="font-size: small; line-height: 19px;"   ><br></span></div><div><span style="font-size: small; line-height: 19px;"   >-- 建完后还是分三个值来测试一下响应时间 : </span></div><div><font size="2"   ><span style="line-height: 19px;"   >postgres=# explain analyze select province, start_ip_Decimal as startIpDecimal, end_ip_Decimal as endIpDecimal from ip_address_pool where 1&gt;=start_ip_Decimal and 1&lt;=end_ip_Decimal;<br>                                                               QUERY PLAN                                                           <br>     <br>------------------------------------------------------------------------------------------------------------------------------------<br>-----<br> Index Scan using idx_ip_address_pool_ip on ip_address_pool  (cost=0.00..4.61 rows=1 width=22) (actual time=0.004..0.005 rows=1 loop<br>s=1)<br>   Index Cond: ((1 &gt;= start_ip_decimal) AND (1 &lt;= end_ip_decimal))<br> Total runtime: 0.014 ms<br>(3 rows)<br><br>postgres=# explain analyze select province, start_ip_Decimal as startIpDecimal, end_ip_Decimal as endIpDecimal from ip_address_pool where 1123371940&gt;=start_ip_Decimal and 1123371940&lt;=end_ip_Decimal;<br>                                                                   QUERY PLAN                                                       <br>            <br>------------------------------------------------------------------------------------------------------------------------------------<br>------------<br> Index Scan using idx_ip_address_pool_ip on ip_address_pool  (cost=0.00..8754.53 rows=75277 width=22) (actual time=5.995..5.996 rows<br>=1 loops=1)<br>   Index Cond: ((1123371940 &gt;= start_ip_decimal) AND (1123371940 &lt;= end_ip_decimal))<br> Total runtime: 6.017 ms<br>(3 rows)<br><br>postgres=# explain analyze select province, start_ip_Decimal as startIpDecimal, end_ip_Decimal as endIpDecimal from ip_address_pool where 4123371940&gt;=start_ip_Decimal and 4123371940&lt;=end_ip_Decimal;<br>                                                                   QUERY PLAN                                                       <br>             <br>------------------------------------------------------------------------------------------------------------------------------------<br>-------------<br> Index Scan using idx_ip_address_pool_ip on ip_address_pool  (cost=0.00..8737.49 rows=1251 width=22) (actual time=27.042..27.044 row<br>s=1 loops=1)<br>   Index Cond: ((4123371940::bigint &gt;= start_ip_decimal) AND (4123371940::bigint &lt;= end_ip_decimal))<br> Total runtime: 27.079 ms<br>(3 rows)<br><br>-- 那么它的TPS能达到多少呢?</span></font></div><div><span style="line-height: 19px; font-size: small;"   >pg92@db-172-16-3-33-&gt; pgbench -M prepared -c 8 -j 8 -f ./ip_test.sql -n -T 60 -h 127.0.0.1 -U postgres postgres</span><br></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 8</font></div><div><font size="2"   >number of threads: 8</font></div><div><font size="2"   >duration: 60 s</font></div><div><font size="2"   >number of transactions actually processed: 216400</font></div><div><font size="2"   >tps = 3606.368660 (including connections establishing)</font></div><div><font size="2"   >tps = 3606.821632 (excluding connections establishing)</font></div><div><font size="2"   >-- 有提高, 但是还远远不够.</font></div><p></p></pre></div><div>3.&nbsp;</div><div>测试脚本:</div><div><p></p><div><pre class="prettyprint"   ><p></p><div><font size="2"   >\setrandom ip 0 2094967294</font></div><div><font size="2"   >select province,ip_decimal_segment &nbsp;from ip_address_pool_3 where ip_decimal_segment @&gt; :ip::int8;</font></div><p></p></pre></div><div><font size="2"   >测试结果:</font></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg92@db-172-16-3-33-&gt; pgbench -M simple -c 8 -j 8 -f ./ip_test.sql -n -T 60 -h 127.0.0.1 -U postgres postgres</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: simple</font></div><div><font size="2"   >number of clients: 8</font></div><div><font size="2"   >number of threads: 8</font></div><div><font size="2"   >duration: 60 s</font></div><div><font size="2"   >number of transactions actually processed: 3498195</font></div><div><font size="2"   >tps = 58301.468890 (including connections establishing)</font></div><div><font size="2"   >tps = 58307.865068 (excluding connections establishing)</font></div><p></p></pre></div><p></p></div><div>-- 使用prepared还能有提升, 如下</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg92@db-172-16-3-33-&gt; pgbench -M prepared -c 8 -j 8 -f ./ip_test.sql -n -T 60 -h 127.0.0.1 -U postgres postgres</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 8</font></div><div><font size="2"   >number of threads: 8</font></div><div><font size="2"   >duration: 60 s</font></div><div><font size="2"   >number of transactions actually processed: 4810415</font></div><div><font size="2"   >tps = 80171.925111 (including connections establishing)</font></div><div><font size="2"   >tps = 80180.458975 (excluding connections establishing)</font></div><p></p></pre></div><div><br></div><div>-- 使用range类型还是测试一下那三个值的耗时, 分布就比较均匀了.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# explain analyze select province,ip_decimal_segment &nbsp;from ip_address_pool_3 where ip_decimal_segment @&gt; int8 '1';</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >------------</font></div><div><font size="2"   >&nbsp;Index Scan using ip_address_pool_3_range on ip_address_pool_3 &nbsp;(cost=0.00..862.55 rows=437 width=38) (actual time=0.034..0.035 rows</font></div><div><font size="2"   >=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (ip_decimal_segment @&gt; 1::bigint)</font></div><div><font size="2"   >&nbsp;Total runtime: 0.045 ms</font></div><div><font size="2"   >(3 rows)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# explain analyze select province,ip_decimal_segment &nbsp;from ip_address_pool_3 where ip_decimal_segment @&gt; int8 '1123371940';</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >------------</font></div><div><font size="2"   >&nbsp;Index Scan using ip_address_pool_3_range on ip_address_pool_3 &nbsp;(cost=0.00..862.55 rows=437 width=38) (actual time=0.036..0.036 rows</font></div><div><font size="2"   >=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (ip_decimal_segment @&gt; 1123371940::bigint)</font></div><div><font size="2"   >&nbsp;Total runtime: 0.052 ms</font></div><div><font size="2"   >(3 rows)</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres=# explain analyze select province,ip_decimal_segment &nbsp;from ip_address_pool_3 where ip_decimal_segment @&gt; int8 '4123371940';</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >------------</font></div><div><font size="2"   >&nbsp;Index Scan using ip_address_pool_3_range on ip_address_pool_3 &nbsp;(cost=0.00..862.55 rows=437 width=38) (actual time=0.058..0.059 rows</font></div><div><font size="2"   >=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (ip_decimal_segment @&gt; 4123371940::bigint)</font></div><div><font size="2"   >&nbsp;Total runtime: 0.069 ms</font></div><div><font size="2"   >(3 rows)</font></div></div><p></p></pre></div><div><br></div><div>【其他】</div><div>1. PostgreSQL支持函数索引，所以我们不需要改表结构就可以使用函数索引来达到加速的目的。</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >CREATE TABLE ip_address_pool (</font></div><div><font size="2"   >&nbsp; id serial8 primary key,</font></div><div><font size="2"   >&nbsp; start_ip inet NOT NULL ,</font></div><div><font size="2"   >&nbsp; end_ip inet NOT NULL ,</font></div><div><font size="2"   >&nbsp; province varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; city varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; region_name varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; company_name varchar(128) NOT NULL ,</font></div><div><font size="2"   >&nbsp; start_ip_decimal bigint ,</font></div><div><font size="2"   >&nbsp; end_ip_decimal bigint&nbsp;</font></div><div><font size="2"   >) ;</font></div></div><div><font size="2"   >create index idx_ip_address_1 on ip_address_pool using index gist (int8range(<span style="line-height: 28px;"   >start_ip_decimal,&nbsp;</span><span style="line-height: 28px;"   >end_ip_decimal+1::int8</span><span style="line-height: 28px;"   >));</span></font></div><div><font size="2"   ><span style="line-height: 28px;"   >select * from&nbsp;</span><span style="line-height: 28px;"   >ip_address_pool</span><span style="line-height: 28px;"   >&nbsp;where&nbsp;</span><span style="line-height: 28px;"   >int8range(</span><span style="line-height: 28px;"   >start_ip_decimal,&nbsp;</span><span style="line-height: 28px;"   >end_ip_decimal+1::int8</span><span style="line-height: 28px;"   >) @&gt; ?;</span></font></div><p></p></pre></div><div><br></div><div>【注意】</div><div>1. pgbench 的random值使用的是有符号int4类型 , 因此超出了本例最大的40亿的值, 所以在测试过程中我使用了0到20亿的数值区间.&nbsp;</div><div>不过这个基本上不影响测试结果.</div><div>&nbsp;如果要让pgbench支持int8需要修改pgbench的源码.</div><div>2. PostgreSQL的range类型除了可以很好的利用它的gist索引作为检索之外, 还可以使用它来做排他约束, 也就是防止数据交叠.</div><div>这个在MySQL中就只能通过全表锁来搞定.&nbsp;</div>3. MySQL里面可以使用osdb来测试, 源码<div><a rel="nofollow" href="http://osdb.sourceforge.net/"   >http://osdb.sourceforge.net/</a> </div>4. PostgreSQL 优化相关的BLOG可以参考如下:<div>《PostgreSQL性能优化综合案例讲解》<br><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201221382150858/"   >http://blog.163.com/digoal@126/blog/static/163877040201221382150858/</a> </div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201221333411196/"   >http://blog.163.com/digoal@126/blog/static/163877040201221333411196/</a> </div></div><div>5. 使用PostgreSQL存储IP数据的话, 还可以使用掩码, 这样的话就不需要存储两个字段了, 直接存在一个字段就可以.</div><div>当然也可以加一个存储比特位的字段, 使用bit函数来处理包含关系.</div><div>另一种用法是把这个比特运算放到内存中执行, 内存中存储IP比特位以及对应到数据库的记录的ID信息, 获取ID后去数据库查询, 也就是把数据库的范围查询变成主键查询. 也可以提高效率.</div>6. range类型是9.2新增的数据类型, 如果要在其他版本中使用, 可以参考 <a rel="nofollow" href="http://blog.osdba.net/?post=96"   >http://blog.osdba.net/?post=96</a>, 实现了float8range.&nbsp;<div>timestamprange则可以参考<a target="_blank" rel="nofollow" href="http://www.pgxn.org/dist/temporal/"   >http://www.pgxn.org/dist/temporal/</a></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL range gist index 20x+ speedup than Mysql index combine query - 德哥@Digoal - PostgreSQL"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>