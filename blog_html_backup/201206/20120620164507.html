<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">UNIQUE constraint PostgreSQL's BUG or Oracle's BUG OR not</h2>
	<h5 id="">2012-06-20 16:45:07&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020125204312568/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">今天一位同事找到我, 发现在PostgreSQL中做联合唯一约束时, 某字段为空,其他字段非空, 可以插入多次. 而这个在Oracle里面是不允许的.<div>先来了解一下什么是NULL, 下面三种情况是在PostgreSQL和Oracle里面的真假.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >NULL = NULL is false</font></div><div><font size="2"  >NULL &lt;&gt; NULL is false</font></div><div><font size="2"  >NULL IS NULL is true</font></div><p></p></pre></div><div><br></div><div>Oracle :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >SQL&gt; select 1 from dual where null=null;</font></div><div><font size="2"  >no rows selected</font></div><div><font size="2"  >SQL&gt; select 1 from dual where null&lt;&gt;null;</font></div><div><font size="2"  >no rows selected</font></div><div><font size="2"  >SQL&gt; select 1 from dual where null is null;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><p></p></pre></div><div><br></div><div>PostgreSQL :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >mns=&gt; select 1 where null = null;</font></div><div><font size="2"  >&nbsp;?column?&nbsp;</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >(0 rows)</font></div><div><font size="2"  >mns=&gt; select 1 where null &lt;&gt; null;</font></div><div><font size="2"  >&nbsp;?column?&nbsp;</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >(0 rows)</font></div><div><font size="2"  >mns=&gt; select 1 where null is null;</font></div><div><font size="2"  >&nbsp;?column?&nbsp;</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; 1</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div><br><div>具体是什么样子呢? 看个测试:</div><div>Oracle :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >SQL&gt; create table test_null (c1 int,c2 int);</font></div><div><font size="2"  >Table created.</font></div></div><div><div><font size="2"  >SQL&gt; insert into test_null values (null,null);</font></div><div><font size="2"  >1 row created.</font></div><div><font size="2"  >SQL&gt; insert into test_null values (null,null);</font></div><div><font size="2"  >1 row created.</font></div><div><font size="2"  >SQL&gt; insert into test_null values (null,null);</font></div><div><font size="2"  >1 row created.</font></div></div><div><div><font size="2"  >SQL&gt; insert into test_null values (1,null);</font></div><div><font size="2"  >1 row created.</font></div><div><font size="2"  >-- oracle不允许以下SQL</font></div><div><font size="2"  >SQL&gt; insert into test_null values (1,null);</font></div><div><font size="2"  >insert into test_null values (1,null)</font></div><div><font size="2"  >*</font></div><div><font size="2"  >ERROR at line 1:</font></div><div><font size="2"  >ORA-00001: unique constraint (SYS.IDX_TEST_NULL) violated</font></div></div><div><div><font size="2"  >-- 从group by 来看, null输出1行. oracle认为null,null是重复的. 但是unique约束又允许它插入多条, 矛盾.</font></div><div><font size="2"  >SQL&gt; select c1,c2 from test_null group by c1,c2;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; C1 &nbsp; &nbsp; &nbsp; &nbsp; C2</font></div><div><font size="2"  >---------- ----------</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div></div><p></p></pre></div><div><br></div><div><br></div><div>PostgreSQL :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >mns=&gt; create table null_test (c1 int,c2 int);</font></div><div><font size="2"  >CREATE TABLE</font></div><div><font size="2"  >mns=&gt; create unique index idx_null_test on null_test (c1,c2);</font></div><div><font size="2"  >CREATE INDEX</font></div></div><div><font size="2"  >-- postgresql允许这样的情况发生</font></div><div><div><font size="2"  >mns=&gt; insert into null_test values (1,null);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >mns=&gt; insert into null_test values (1,null);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >mns=&gt; insert into null_test values (1,null);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >mns=&gt; insert into null_test values (1,null);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >mns=&gt; insert into null_test values (1,null);</font></div><div><font size="2"  >INSERT 0 1</font></div></div><div><div><font size="2"  >mns=&gt; insert into null_test values (null,null);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >mns=&gt; insert into null_test values (null,null);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >mns=&gt; insert into null_test values (null,null);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >mns=&gt; insert into null_test values (null,null);</font></div><div><font size="2"  >INSERT 0 1</font></div></div><div><font size="2"  >-- group by 时, PostgreSQL认为1,null和1, null是重复的, null,null与null,null也是重复的. 但是他们都允许在unique约束时重复插入, 矛盾.</font></div><div><div><font size="2"  >mns=&gt; select c1,c2 from null_test group by c1,c2;</font></div><div><font size="2"  >&nbsp;c1 | c2&nbsp;</font></div><div><font size="2"  >----+----</font></div><div><font size="2"  >&nbsp; &nbsp; | &nbsp;&nbsp;</font></div><div><font size="2"  >&nbsp; 1 | &nbsp;&nbsp;</font></div><div><font size="2"  >(2 rows)</font></div></div><p></p></pre></div><div>下面测试的是非联合唯一约束, 也就是单列上的唯一约束.</div><div>结果, Oracle和PostgreSQL测试结果一致.</div><div>Oracle :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >SQL&gt; create table test (id int unique);</font></div><div><font size="2"  >Table created.</font></div><div><font size="2"  >SQL&gt; insert into test values (1);</font></div><div><font size="2"  >1 row created.</font></div><div><font size="2"  >SQL&gt; insert into test values (1);</font></div><div><font size="2"  >insert into test values (1)</font></div><div><font size="2"  >*</font></div><div><font size="2"  >ERROR at line 1:</font></div><div><font size="2"  >ORA-00001: unique constraint (SYS.SYS_C0070356) violated</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SQL&gt; insert into test values (null);</font></div><div><font size="2"  >1 row created.</font></div><div><font size="2"  >SQL&gt; insert into test values (null);</font></div><div><font size="2"  >1 row created.</font></div><div><font size="2"  >SQL&gt; insert into test values (null);</font></div><div><font size="2"  >1 row created.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SQL&gt; set null NULL</font></div><div><font size="2"  >SQL&gt; select id from test group by id;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ID</font></div><div><font size="2"  >----------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"  >NULL</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >SQL&gt; select id,count(*) from test group by id;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ID &nbsp; COUNT(*)</font></div><div><font size="2"  >---------- ----------</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"  >NULL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3</font></div><p></p></pre></div><div><br></div><div>PostgreSQL :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# create table test (id int unique);</font></div><div><font size="2"  >ERROR: &nbsp;42P07: relation "test" already exists</font></div><div><font size="2"  >LOCATION: &nbsp;heap_create_with_catalog, heap.c:1027</font></div><div><font size="2"  >postgres=# drop table test;</font></div><div><font size="2"  >DROP TABLE</font></div><div><font size="2"  >postgres=# create table test (id int unique);</font></div><div><font size="2"  >NOTICE: &nbsp;00000: CREATE TABLE / UNIQUE will create implicit index "test_id_key" for table "test"</font></div><div><font size="2"  >LOCATION: &nbsp;DefineIndex, indexcmds.c:600</font></div><div><font size="2"  >CREATE TABLE</font></div><div><font size="2"  >postgres=# insert into test values (1);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >postgres=# insert into test values (1);</font></div><div><font size="2"  >ERROR: &nbsp;23505: duplicate key value violates unique constraint "test_id_key"</font></div><div><font size="2"  >DETAIL: &nbsp;Key (id)=(1) already exists.</font></div><div><font size="2"  >LOCATION: &nbsp;_bt_check_unique, nbtinsert.c:396</font></div><div><font size="2"  >postgres=# insert into test values (null);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >postgres=# insert into test values (null);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >postgres=# insert into test values (null);</font></div><div><font size="2"  >INSERT 0 1</font></div><div><font size="2"  >postgres=# select id,count(*) from test group by id;</font></div><div><font size="2"  >&nbsp;id | count&nbsp;</font></div><div><font size="2"  >----+-------</font></div><div><font size="2"  >&nbsp; &nbsp; | &nbsp; &nbsp; 3</font></div><div><font size="2"  >&nbsp; 1 | &nbsp; &nbsp; 1</font></div><div><font size="2"  >(2 rows)</font></div><p></p></pre></div><div>接下来看看PostgreSQL在这两块遵循的SQL标准.</div><div>supported feature :&nbsp;</div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >E141-02<span> </span>Core<span> </span>UNIQUE constraints of NOT NULL columns</font></div><div><font size="2"  >T591<span> </span> <span> </span>UNIQUE constraints of possibly null columns</font></div><p></p></pre></div><div>unsupported feature :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >F291<span> </span> <span> </span>UNIQUE predicate</font></div><div><font size="2"  >S291<span> </span> <span> </span>Unique constraint on entire row</font></div></div><div></div><p></p></pre></div></div><div>到底是PostgreSQL还是Oracle的问题, 先不追究了.<wbr></div></div><div>但是如果你有数据要从Oracle到PG, 就要注意这方面的差别了.</div></div>
	</div>
</div>
</body>
</html>