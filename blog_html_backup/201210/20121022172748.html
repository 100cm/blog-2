<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">use pg_stat_plans in PostgreSQL 9.0, 9.1 and 9.2</h2>
	<h5 id="">2012-10-22 17:27:48&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201292245228613/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>pg_stat_plans 类似于auto_explain和pg_stat_statements的结合. 或者说它是从pg_stat_statements扩展而来.</div><div>pg_stat_statements一般被用来跟踪数据库中执行的SQL语句的次数, 共计执行时间, 块扫描的信息等等. 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Column &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; Type &nbsp; &nbsp; &nbsp; | Modifiers &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >---------------------+------------------+----------- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >&nbsp;userid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;dbid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;query &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;calls &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;total_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| double precision |&nbsp;</font></div><div><font size="2"  >&nbsp;rows &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;shared_blks_hit &nbsp; &nbsp; | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;shared_blks_read &nbsp; &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;shared_blks_dirtied | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;shared_blks_written | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;local_blks_hit &nbsp; &nbsp; &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;local_blks_read &nbsp; &nbsp; | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;local_blks_dirtied &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;local_blks_written &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;temp_blks_read &nbsp; &nbsp; &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;temp_blks_written &nbsp; | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;blk_read_time &nbsp; &nbsp; &nbsp; | double precision |&nbsp;</font></div><div><font size="2"  >&nbsp;blk_write_time &nbsp; &nbsp; &nbsp;| double precision |&nbsp;</font></div><p></p></pre></div><div>而pg_stat_plans呢? 除了记录调用次数, 共计执行时间以外, 还需要记录planid(从query tree hash而来), 如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Column &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; Type &nbsp; &nbsp; &nbsp; | Modifiers&nbsp;</font></div><div><font size="2"  >---------------------+------------------+-----------</font></div><div><font size="2"  >&nbsp;userid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;dbid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;planid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| oid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;query &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;had_our_search_path | boolean &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;query_valid &nbsp; &nbsp; &nbsp; &nbsp; | boolean &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"  >&nbsp;calls &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;total_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| double precision |&nbsp;</font></div><div><font size="2"  >&nbsp;rows &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;shared_blks_hit &nbsp; &nbsp; | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;shared_blks_read &nbsp; &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;shared_blks_written | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;local_blks_hit &nbsp; &nbsp; &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;local_blks_read &nbsp; &nbsp; | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;local_blks_written &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;temp_blks_read &nbsp; &nbsp; &nbsp;| bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;temp_blks_written &nbsp; | bigint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"  >&nbsp;last_startup_cost &nbsp; | double precision |&nbsp;</font></div><div><font size="2"  >&nbsp;last_total_cost &nbsp; &nbsp; | double precision |&nbsp;</font></div><p></p></pre></div><div>换句话说, pg_stat_plans并没有真正记录explain的内容, 而是换算成了hash值, 这可以省去不少存储空间, 因为这些都是消耗内存的.</div><div>pg_stat_plans需要的共享内存在数据库启动时就被分配, 约等于pg_stat_plans.max * plans_query_size bytes;</div><div><br></div><div>【安装】</div><div>1. 下载</div><div><a target="_blank" rel="nofollow" href="https://github.com/2ndQuadrant/pg_stat_plans.git"  >https://github.com/2ndQuadrant/pg_stat_plans.git</a></div><div>2. 下载后解压到 $PG_SRC/contrib/</div><div>3. 编译安装需要用到pg_config, 所以需要把它放到PATH中.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >su - root</font></div><div><font size="2"  >. /home/postgres/.bash_profile</font></div><div><font size="2"  >cd $PG_SRC/contrib/pg_stat_plans/</font></div><div><font size="2"  >gmake clean</font></div><div><font size="2"  >gmake</font></div><div><font size="2"  >gmake install</font></div><p></p></pre></div><div>4. 9.1和9.2 使用create extension 安装.</div><div>&nbsp; &nbsp; 9.0则使用pg_stat_plans.sql来安装.</div><div>5. 安装完后需要修改postgresql.conf重启数据库.</div><div>简单的配置如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  ># postgresql.conf</font></div><div><font size="2"  >shared_preload_libraries = 'pg_stat_plans'</font></div><div><font size="2"  ># Optionally:</font></div><div><font size="2"  >pg_stat_plans.max = 10000</font></div><div><font size="2"  >pg_stat_plans.track = all</font></div><p></p></pre></div><div>如果<span style="line-height: 22.22222328186035px;"  >plans_query_size bytes=2048的话, 需要大约20MB的共享内存.(如果</span><span style="line-height: 22.21666717529297px;"  >track_activity_query_size没有设置的话,&nbsp;</span><span style="line-height: 22.22222328186035px;"  >query_size使用PostgreSQL的全局参数值)</span></div><div><br></div><div>其他可用到的参数 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg_stat_plans adds the following configuration parameters:</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >pg_stat_plans.max (integer)</font></div><div><font size="2"  >pg_stat_plans.max is the maximum number of plans tracked by the module (i.e., the maximum number of rows in the pg_stat_plans view). If more distinct plans than that are observed, information about the least-executed statements is discarded. The default value is 1000. This parameter can only be set at server start.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >pg_stat_plans.track (enum)</font></div><div><font size="2"  >pg_stat_plans.track controls which statements' plans are counted by the module. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable plan statistics collection. The default value is top. Only superusers can change this setting.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >pg_stat_plans.save (boolean)</font></div><div><font size="2"  >pg_stat_plans.save specifies whether to save plan statistics across server shutdowns. If it is off then statistics are not saved at shutdown nor reloaded at server start. The default value is on. This parameter can only be set in the postgresql.conf file or on the server command line.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >pg_stat_plans.planid_notice (boolean)</font></div><div><font size="2"  >Raise notice of a plan's id after its execution. Useful for verifying explain output on an ad-hoc basis.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >pg_stat_plans.explain_format (enum)</font></div><div><font size="2"  >pg_stat_plans.explain_format selects the EXPLAIN output format to be used (i.e the format that will be returned by pg_stat_plans_explain()). The allowed values are text, xml, json, and yaml. The default is text.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >pg_stat_plans.verbose (boolean)</font></div><div><font size="2"  >pg_stat_plans.verbose specifies if explain output should be verbose (that is, equivalent to specifying VERBOSE with SQL EXPLAIN). The default is off.</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >pg_stat_plans.plans_query_size (integer)</font></div><div><font size="2"  >Controls the length in bytes of the stored SQL query string. Because truncating the stored strings prevents subsequently explaining the entry, it may be necessary to increase this value. The default is 2048.</font></div><p></p></pre></div><div><br></div><div>配置好后重启数据库.</div><div><br></div><div>【测试】</div><div>我这里使用PostgreSQL 9.2beta4进行测试.</div><div>1. 在PSQL中查看是否安装好了pg_stat_plans.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# \dx</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List of installed extensions</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;Name &nbsp; &nbsp; &nbsp;| Version | &nbsp; Schema &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Description &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"  >---------------+---------+------------+-----------------------------------</font></div><div><font size="2"  >&nbsp;pg_stat_plans | 0.1 &nbsp; &nbsp; | public &nbsp; &nbsp; | Monitors execution costs of plans</font></div><p></p></pre></div><div><br></div><div>2. 可以看到新增了3个函数, 2个视图.</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >-[ RECORD 7 ]-------+---------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >--------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >Schema &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| public</font></div><div><font size="2"  >Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| pg_stat_plans_explain</font></div><div><font size="2"  >Result data type &nbsp; &nbsp;| text</font></div><div><font size="2"  >Argument data types | planid oid, userid oid DEFAULT NULL::oid, dbid oid DEFAULT NULL::oid, encodingid oid DEFAULT NULL::oid</font></div><div><font size="2"  >Type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| normal</font></div><div><font size="2"  >-[ RECORD 8 ]-------+---------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >--------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >Schema &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| public</font></div><div><font size="2"  >Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| pg_stat_plans_pprint</font></div><div><font size="2"  >Result data type &nbsp; &nbsp;| text</font></div><div><font size="2"  >Argument data types | sqltext text</font></div><div><font size="2"  >Type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| normal</font></div><div><font size="2"  >-[ RECORD 9 ]-------+---------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >--------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >Schema &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| public</font></div><div><font size="2"  >Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| pg_stat_plans_reset</font></div><div><font size="2"  >Result data type &nbsp; &nbsp;| void</font></div><div><font size="2"  >Argument data types |&nbsp;</font></div><div><font size="2"  >Type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| normal</font></div></div><div><font size="2"  ><br></font></div><div><div><font size="2"  >postgres=# &nbsp;\dv</font></div><div><font size="2"  >List of relations</font></div><div><font size="2"  >-[ RECORD 1 ]-----------------</font></div><div><font size="2"  >Schema | public</font></div><div><font size="2"  >Name &nbsp; | pg_stat_plans</font></div><div><font size="2"  >Type &nbsp; | view</font></div><div><font size="2"  >Owner &nbsp;| postgres</font></div><div><font size="2"  >-[ RECORD 2 ]-----------------</font></div><div><font size="2"  >Schema | public</font></div><div><font size="2"  >Name &nbsp; | pg_stat_plans_queries</font></div><div><font size="2"  >Type &nbsp; | view</font></div><div><font size="2"  >Owner &nbsp;| postgres</font></div></div><p></p></pre></div><div><br></div><div>3.&nbsp;</div><div>创建测试表, 插入测试数据. 分别测试一个SQL的两种执行计划. 那么pg_stat_plans将跟踪到这个改变, 并在pg_log中记录WARNING告警.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# drop table test;</font></div><div><font size="2"  >DROP TABLE</font></div><div><font size="2"  >postgres=# create table test (id int);</font></div><div><font size="2"  >CREATE TABLE</font></div><div><font size="2"  >postgres=# select pg_stat_plans_reset();</font></div><div><font size="2"  >&nbsp;pg_stat_plans_reset&nbsp;</font></div><div><font size="2"  >---------------------</font></div><div><font size="2"  >&nbsp;(1 row)</font></div><div><div><font size="2"  >postgres=# insert into test select generate_series(1,100000);</font></div><div><font size="2"  >INSERT 0 100000</font></div><div><font size="2"  >postgres=# select * from test where id=1;</font></div><div><font size="2"  >&nbsp;id&nbsp;</font></div><div><font size="2"  >----</font></div><div><font size="2"  >&nbsp; 1</font></div><div><font size="2"  >(1 row)</font></div></div><p></p></pre></div><div><div>-- 创建索引, 执行同一条SQL, 执行计划将发生变化. 以此来观察pg_stat_plans的变化.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# create index idx_test on test(id);</font></div><div><font size="2"  >CREATE INDEX</font></div><div><font size="2"  >postgres=# select * from test where id=1;</font></div><div><font size="2"  >&nbsp;id&nbsp;</font></div><div><font size="2"  >----</font></div><div><font size="2"  >&nbsp; 1</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div></div><div>-- 查询pg_stat_plans, 可以看出planid=<span style="line-height: 22.22222328186035px;"  >2758236521的记录发生了变化, query_valid=t变成了query_valid=f ;&nbsp;</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# select planid,query,query_valid,pg_stat_plans_explain(planid, userid, dbid) from pg_stat_plans where dbid=12788 and query ~ 'test';</font></div><div><div><div><div><font size="2"  >-[ RECORD 1 ]---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >planid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 2758236521</font></div><div><font size="2"  >query &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | select * from test where id=1;</font></div><div><font size="2"  >query_valid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | f</font></div><div><font size="2"  >pg_stat_plans_explain | ***** Existing entry's planid (2758236521) and explain of original SQL query string planid (1252991393) differ *****</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Index Only Scan using idx_test on test &nbsp;(cost=0.00..2.30 rows=1 width=4)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; Index Cond: (id = 1)</font></div></div><div><font size="2"  >-[ RECORD 5 ]---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >planid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 1252991393</font></div><div><font size="2"  >query &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | select * from test where id=1;</font></div><div><font size="2"  >query_valid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | t</font></div><div><font size="2"  >pg_stat_plans_explain | Index Only Scan using idx_test on test &nbsp;(cost=0.00..2.30 rows=1 width=4)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; Index Cond: (id = 1)</font></div></div></div><p></p></pre></div><div>从这个信息来看, planid=<span style="line-height: 22.22222328186035px;"  >2758236521对应的SQL, 当前的执行计划(通过</span><span style="line-height: 22.22222328186035px;"  >pg_stat_plans_explain(planid, userid, dbid)得到</span><span style="line-height: 22.22222328186035px;"  >)与执行时的执行计划不一致, 也就是发生了改变, 所以"</span><span style="line-height: 22.22222328186035px;"  >Existing entry's planid (2758236521) and explain of original SQL query string planid (1252991393) differ</span><span style="line-height: 22.22222328186035px;"  >".</span></div><div><span style="line-height: 22.22222328186035px;"  >并且query_valid修改成f. 同时在pg_stat_plans中新增了一条planid=</span><span style="line-height: 22.22222328186035px;"  >1252991393的执行计划. 与当前执行计划一致.</span></div><div><br></div><div>柱状图 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# select * from pg_stat_plans_queries where normalize_query ~ 'test';</font></div><div><font size="2"  >-[ RECORD 1 ]-------+----------------------------------------------</font></div><div><font size="2"  >userid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 10</font></div><div><font size="2"  >dbid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 12788</font></div><div><font size="2"  >plan_ids &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| {2758236521,1252991393}</font></div><div><font size="2"  >calls_histogram &nbsp; &nbsp; | {1,5}</font></div><div><font size="2"  >avg_time_histogram &nbsp;| {21.224,0.016}</font></div><div><font size="2"  >normalize_query &nbsp; &nbsp; | select * from test where id=?;</font></div><div><font size="2"  >calls &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 6</font></div><div><font size="2"  >total_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 21.304</font></div><div><font size="2"  >time_variance &nbsp; &nbsp; &nbsp; | 224.889632</font></div><div><font size="2"  >time_stddev &nbsp; &nbsp; &nbsp; &nbsp; | 14.9963206154043</font></div><div><font size="2"  >rows &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 2</font></div><div><font size="2"  >shared_blks_hit &nbsp; &nbsp; | 444</font></div><div><font size="2"  >shared_blks_read &nbsp; &nbsp;| 3</font></div><div><font size="2"  >shared_blks_written | 0</font></div><div><font size="2"  >local_blks_hit &nbsp; &nbsp; &nbsp;| 0</font></div><div><font size="2"  >local_blks_read &nbsp; &nbsp; | 0</font></div><div><font size="2"  >local_blks_written &nbsp;| 0</font></div><div><font size="2"  >temp_blks_read &nbsp; &nbsp; &nbsp;| 0</font></div><div><font size="2"  >temp_blks_written &nbsp; | 0</font></div><p></p></pre></div><div>解释 :&nbsp;</div><div><span style="line-height: 22.22222328186035px;"  >plan_ids 存储planid的数组</span></div><div><span style="line-height: 22.22222328186035px;"  >calls_histogram 存储的是对应的调用次数的数组</span></div><div><span style="line-height: 22.22222328186035px;"  >avg_time_histogram 存储的是对应的平均执行时间的数组.</span></div><div><span style="line-height: 22.22222328186035px;"  >从这里查询到的信息, 使用planid=</span><span style="line-height: 22.22222328186035px;"  >2758236521这个执行计划的SQL, 调用了1次, 平均执行时间21.224毫秒.</span></div><div><span style="line-height: 22.22222328186035px;"  >使用planid=</span><span style="line-height: 22.22222328186035px;"  >2758236521</span><span style="line-height: 22.22222328186035px;"  >这个执行计划的SQL, 调用了5次, 平均执行时间0.016毫秒.</span></div><div><br></div><div>4. 接下来观察一下当执行计划与原先一致时, query_valid再变回去t值.</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >删除索引 : </font></div><div><font size="2"  >postgres=# drop index idx_test;</font></div><div><font size="2"  >DROP INDEX</font></div></div><div><font size="2"  >重新查看</font><span style="font-size: small; line-height: 21.111112594604492px;"  >pg_stat_plans_explain : </span></div><div><div><font size="2"  >postgres=# select planid,query,query_valid,pg_stat_plans_explain(planid, userid, dbid) from pg_stat_plans where dbid=12788 and query ~ 'test';</font></div><div><font size="2"  >NOTICE: &nbsp;updated pg_stat_plans query string of entry 2758236521</font></div><div><font size="2"  >CONTEXT: &nbsp;SQL statement "EXPLAIN select * from test where id=1;"</font></div><div><font size="2"  >WARNING: &nbsp;Existing pg_stat_plans entry planid (1252991393) differs from new plan for query (2758236521).</font></div></div><div><div><font size="2"  >-[ RECORD 1 ]---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >planid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 2758236521</font></div><div><font size="2"  >query &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | select * from test where id=1;</font></div><div><font size="2"  >query_valid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | f</font></div><div><font size="2"  >pg_stat_plans_explain | Seq Scan on test &nbsp;(cost=0.00..1693.00 rows=1 width=4)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; Filter: (id = 1)</font></div></div><div><div><font size="2"  >-[ RECORD 6 ]---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"  >planid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 1252991393</font></div><div><font size="2"  >query &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | select * from test where id=1;</font></div><div><font size="2"  >query_valid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | t</font></div><div><font size="2"  >pg_stat_plans_explain | ***** Existing entry's planid (1252991393) and explain of original SQL query string planid (2758236521) differ *****</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Seq Scan on test &nbsp;(cost=0.00..1693.00 rows=1 width=4)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; Filter: (id = 1)</font></div></div><p></p></pre></div><div>显然这里发生了调换, planid=<span style="line-height: 22.22222328186035px;"  >2758236521的执行计划变回去了, 而planid=</span><span style="line-height: 22.22222328186035px;"  >1252991393的SQL的执行计划则与之前index only scan不同.</span></div><div><span style="line-height: 22.22222328186035px;"  >所以这里发生了两个更新记录的操作. 都是修改query_valid.</span></div><div><br></div><div>【小结】</div><div>1. pg_stat_plans 一般可以用来发现数据库中执行计划发生变化的SQL。</div><div>第一, &nbsp;从pg_stat_plans视图的<span style="line-height: 22.22222328186035px;"  >query_valid</span>字段值为false可以发现当前的SQL执行计划与执行这个SQL时用到的执行计划不一致.</div><div>第二, &nbsp;从PostgreSQL log中的WARNING也能发现这个不一致.</div><div><pre class="prettyprint"  ><p><font size="2"  >2012-10-22 17:08:12.118 CST,"postgres","postgres",6720,"[local]",50850932.1a40,2,"SELECT",2012-10-22 16:52:02 CST,2/426,0,WARNING,55000,"Existing pg_stat_plans entry planid (2758236521) differs from new plan for query (1252991393).",,,,,,,,,"psql"</font></p></pre></div><div>2.&nbsp;<span style="line-height: 22.22222328186035px;"  >pg_stat_plans_explain(planid, userid, dbid) 函数将调用PostgreSQL中的explain得到执行计划(query tree). 调用pg_stat_plans_explain除了得到当前的执行计划外, 还需要对query tree的hash值与planid进行匹配, 如果不匹配则修改query_valid字段中存储的值为false. 所以不调用</span><span style="line-height: 22.22222328186035px;"  >pg_stat_plans_explain()的话不会对query_valid的内容进行更改.</span></div><div><span style="line-height: 22.22222328186035px;"  ><br></span></div><div><span style="line-height: 22.22222328186035px;"  >3. </span><span style="line-height: 22.21666717529297px;"  >planId |= hash_any(jstate.jumble, jstate.jumble_len) , 不同的执行计划可能得到同样的hash值, 也就是planid. 尽管这种概率较小.</span></div><div><br></div>【参考】<div>1.&nbsp;<a rel="nofollow" href="https://github.com/2ndQuadrant/pg_stat_plans"  >https://github.com/2ndQuadrant/pg_stat_plans</a></div><div>2.&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201151534631313/"  >http://blog.163.com/digoal@126/blog/static/163877040201151534631313/</a></div><div>3.&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201221382150858/"  >http://blog.163.com/digoal@126/blog/static/163877040201221382150858/</a></div><div>4.&nbsp;<a target="_blank" rel="nofollow" href="http://blog.ioguix.net/"  >http://blog.ioguix.net/</a></div><div>5.&nbsp;src/backend/access/hash/hashfunc.c</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >00289 /*</font></div><div><font size="2"  >00290 &nbsp;* hash_any() -- hash a variable-length key into a 32-bit value</font></div><div><font size="2"  >00291 &nbsp;* &nbsp; &nbsp; &nbsp;k &nbsp; &nbsp; &nbsp; : the key (the unaligned variable-length array of bytes)</font></div><div><font size="2"  >00292 &nbsp;* &nbsp; &nbsp; &nbsp;len &nbsp; &nbsp; : the length of the key, counting by bytes</font></div><div><font size="2"  >00293 &nbsp;*</font></div><div><font size="2"  >00294 &nbsp;* Returns a uint32 value. &nbsp;Every bit of the key affects every bit of</font></div><div><font size="2"  >00295 &nbsp;* the return value. &nbsp;Every 1-bit and 2-bit delta achieves avalanche.</font></div><div><font size="2"  >00296 &nbsp;* About 6*len+35 instructions. The best hash table sizes are powers</font></div><div><font size="2"  >00297 &nbsp;* of 2. &nbsp;There is no need to do mod a prime (mod is sooo slow!).</font></div><div><font size="2"  >00298 &nbsp;* If you need less than 32 bits, use a bitmask.</font></div><div><font size="2"  >00299 &nbsp;*</font></div><div><font size="2"  >00300 &nbsp;* Note: we could easily change this function to return a 64-bit hash value</font></div><div><font size="2"  >00301 &nbsp;* by using the final values of both b and c. &nbsp;b is perhaps a little less</font></div><div><font size="2"  >00302 &nbsp;* well mixed than c, however.</font></div><div><font size="2"  >00303 &nbsp;*/</font></div><div><font size="2"  >00304 Datum</font></div><div><font size="2"  >00305 hash_any(register const unsigned char *k, register int keylen)</font></div><div><font size="2"  >00306 {</font></div><div><font size="2"  >00307 &nbsp; &nbsp; register uint32 a,</font></div><div><font size="2"  >00308 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b,</font></div><div><font size="2"  >00309 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c,</font></div><div><font size="2"  >00310 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;</font></div><div><font size="2"  >00311&nbsp;</font></div><div><font size="2"  >00312 &nbsp; &nbsp; /* Set up the internal state */</font></div><div><font size="2"  >00313 &nbsp; &nbsp; len = keylen;</font></div><div><font size="2"  >00314 &nbsp; &nbsp; a = b = c = 0x9e3779b9 + len + 3923095;</font></div><div><font size="2"  >00315&nbsp;</font></div><div><font size="2"  >00316 &nbsp; &nbsp; /* If the source pointer is word-aligned, we use word-wide fetches */</font></div><div><font size="2"  >00317 &nbsp; &nbsp; if (((intptr_t) k &amp; UINT32_ALIGN_MASK) == 0)</font></div><div><font size="2"  >00318 &nbsp; &nbsp; {</font></div><div><font size="2"  >00319 &nbsp; &nbsp; &nbsp; &nbsp; /* Code path for aligned source data */</font></div><div><font size="2"  >00320 &nbsp; &nbsp; &nbsp; &nbsp; register const uint32 *ka = (const uint32 *) k;</font></div><div><font size="2"  >00321&nbsp;</font></div><div><font size="2"  >00322 &nbsp; &nbsp; &nbsp; &nbsp; /* handle most of the key */</font></div><div><font size="2"  >00323 &nbsp; &nbsp; &nbsp; &nbsp; while (len &gt;= 12)</font></div><div><font size="2"  >00324 &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >00325 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ka[0];</font></div><div><font size="2"  >00326 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ka[1];</font></div><div><font size="2"  >00327 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += ka[2];</font></div><div><font size="2"  >00328 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mix(a, b, c);</font></div><div><font size="2"  >00329 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ka += 3;</font></div><div><font size="2"  >00330 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len -= 12;</font></div><div><font size="2"  >00331 &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >00332&nbsp;</font></div><div><font size="2"  >00333 &nbsp; &nbsp; &nbsp; &nbsp; /* handle the last 11 bytes */</font></div><div><font size="2"  >00334 &nbsp; &nbsp; &nbsp; &nbsp; k = (const unsigned char *) ka;</font></div><div><font size="2"  >00335 #ifdef WORDS_BIGENDIAN</font></div><div><font size="2"  >00336 &nbsp; &nbsp; &nbsp; &nbsp; switch (len)</font></div><div><font size="2"  >00337 &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >00338 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 11:</font></div><div><font size="2"  >00339 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += ((uint32) k[10] &lt;&lt; 8);</font></div><div><font size="2"  >00340 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00341 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 10:</font></div><div><font size="2"  >00342 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += ((uint32) k[9] &lt;&lt; 16);</font></div><div><font size="2"  >00343 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00344 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 9:</font></div><div><font size="2"  >00345 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += ((uint32) k[8] &lt;&lt; 24);</font></div><div><font size="2"  >00346 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* the lowest byte of c is reserved for the length */</font></div><div><font size="2"  >00347 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00348 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 8:</font></div><div><font size="2"  >00349 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ka[1];</font></div><div><font size="2"  >00350 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ka[0];</font></div><div><font size="2"  >00351 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >00352 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 7:</font></div><div><font size="2"  >00353 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ((uint32) k[6] &lt;&lt; 8);</font></div><div><font size="2"  >00354 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00355 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 6:</font></div><div><font size="2"  >00356 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ((uint32) k[5] &lt;&lt; 16);</font></div><div><font size="2"  >00357 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00358 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 5:</font></div><div><font size="2"  >00359 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ((uint32) k[4] &lt;&lt; 24);</font></div><div><font size="2"  >00360 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00361 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 4:</font></div><div><font size="2"  >00362 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ka[0];</font></div><div><font size="2"  >00363 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >00364 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 3:</font></div><div><font size="2"  >00365 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ((uint32) k[2] &lt;&lt; 8);</font></div><div><font size="2"  >00366 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00367 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 2:</font></div><div><font size="2"  >00368 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ((uint32) k[1] &lt;&lt; 16);</font></div><div><font size="2"  >00369 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00370 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 1:</font></div><div><font size="2"  >00371 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ((uint32) k[0] &lt;&lt; 24);</font></div><div><font size="2"  >00372 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* case 0: nothing left to add */</font></div><div><font size="2"  >00373 &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >00374 #else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* !WORDS_BIGENDIAN */</font></div><div><font size="2"  >00375 &nbsp; &nbsp; &nbsp; &nbsp; switch (len)</font></div><div><font size="2"  >00376 &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >00377 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 11:</font></div><div><font size="2"  >00378 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += ((uint32) k[10] &lt;&lt; 24);</font></div><div><font size="2"  >00379 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00380 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 10:</font></div><div><font size="2"  >00381 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += ((uint32) k[9] &lt;&lt; 16);</font></div><div><font size="2"  >00382 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00383 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 9:</font></div><div><font size="2"  >00384 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += ((uint32) k[8] &lt;&lt; 8);</font></div><div><font size="2"  >00385 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* the lowest byte of c is reserved for the length */</font></div><div><font size="2"  >00386 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00387 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 8:</font></div><div><font size="2"  >00388 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ka[1];</font></div><div><font size="2"  >00389 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ka[0];</font></div><div><font size="2"  >00390 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >00391 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 7:</font></div><div><font size="2"  >00392 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ((uint32) k[6] &lt;&lt; 16);</font></div><div><font size="2"  >00393 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00394 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 6:</font></div><div><font size="2"  >00395 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ((uint32) k[5] &lt;&lt; 8);</font></div><div><font size="2"  >00396 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00397 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 5:</font></div><div><font size="2"  >00398 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += k[4];</font></div><div><font size="2"  >00399 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00400 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 4:</font></div><div><font size="2"  >00401 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ka[0];</font></div><div><font size="2"  >00402 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >00403 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 3:</font></div><div><font size="2"  >00404 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ((uint32) k[2] &lt;&lt; 16);</font></div><div><font size="2"  >00405 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00406 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 2:</font></div><div><font size="2"  >00407 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ((uint32) k[1] &lt;&lt; 8);</font></div><div><font size="2"  >00408 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* fall through */</font></div><div><font size="2"  >00409 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 1:</font></div><div><font size="2"  >00410 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += k[0];</font></div><div><font size="2"  >00411 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* case 0: nothing left to add */</font></div><div><font size="2"  >00412 &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >00413 #endif &nbsp; /* WORDS_BIGENDIAN */</font></div><div><font size="2"  >00414 &nbsp; &nbsp; }</font></div><div><font size="2"  >00415 &nbsp; &nbsp; else</font></div><div><font size="2"  >00416 &nbsp; &nbsp; {</font></div><div><font size="2"  >00417 &nbsp; &nbsp; &nbsp; &nbsp; /* Code path for non-aligned source data */</font></div><div><font size="2"  >00418&nbsp;</font></div><div><font size="2"  >00419 &nbsp; &nbsp; &nbsp; &nbsp; /* handle most of the key */</font></div><div><font size="2"  >00420 &nbsp; &nbsp; &nbsp; &nbsp; while (len &gt;= 12)</font></div><div><font size="2"  >00421 &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >00422 #ifdef WORDS_BIGENDIAN</font></div><div><font size="2"  >00423 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += (k[3] + ((uint32) k[2] &lt;&lt; 8) + ((uint32) k[1] &lt;&lt; 16) + ((uint32) k[0] &lt;&lt; 24));</font></div><div><font size="2"  >00424 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += (k[7] + ((uint32) k[6] &lt;&lt; 8) + ((uint32) k[5] &lt;&lt; 16) + ((uint32) k[4] &lt;&lt; 24));</font></div><div><font size="2"  >00425 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += (k[11] + ((uint32) k[10] &lt;&lt; 8) + ((uint32) k[9] &lt;&lt; 16) + ((uint32) k[8] &lt;&lt; 24));</font></div><div><font size="2"  >00426 #else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* !WORDS_BIGENDIAN */</font></div><div><font size="2"  >00427 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += (k[0] + ((uint32) k[1] &lt;&lt; 8) + ((uint32) k[2] &lt;&lt; 16) + ((uint32) k[3] &lt;&lt; 24));</font></div><div><font size="2"  >00428 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += (k[4] + ((uint32) k[5] &lt;&lt; 8) + ((uint32) k[6] &lt;&lt; 16) + ((uint32) k[7] &lt;&lt; 24));</font></div><div><font size="2"  >00429 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += (k[8] + ((uint32) k[9] &lt;&lt; 8) + ((uint32) k[10] &lt;&lt; 16) + ((uint32) k[11] &lt;&lt; 24));</font></div><div><font size="2"  >00430 #endif &nbsp; /* WORDS_BIGENDIAN */</font></div><div><font size="2"  >00431 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mix(a, b, c);</font></div><div><font size="2"  >00432 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k += 12;</font></div><div><font size="2"  >00433 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len -= 12;</font></div><div><font size="2"  >00434 &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >00435&nbsp;</font></div><div><font size="2"  >00436 &nbsp; &nbsp; &nbsp; &nbsp; /* handle the last 11 bytes */</font></div><div><font size="2"  >00437 #ifdef WORDS_BIGENDIAN</font></div><div><font size="2"  >00438 &nbsp; &nbsp; &nbsp; &nbsp; switch (len) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* all the case statements fall through */</font></div><div><font size="2"  >00439 &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >00440 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 11:</font></div><div><font size="2"  >00441 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += ((uint32) k[10] &lt;&lt; 8);</font></div><div><font size="2"  >00442 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 10:</font></div><div><font size="2"  >00443 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += ((uint32) k[9] &lt;&lt; 16);</font></div><div><font size="2"  >00444 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 9:</font></div><div><font size="2"  >00445 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += ((uint32) k[8] &lt;&lt; 24);</font></div><div><font size="2"  >00446 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* the lowest byte of c is reserved for the length */</font></div><div><font size="2"  >00447 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 8:</font></div><div><font size="2"  >00448 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += k[7];</font></div><div><font size="2"  >00449 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 7:</font></div><div><font size="2"  >00450 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ((uint32) k[6] &lt;&lt; 8);</font></div><div><font size="2"  >00451 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 6:</font></div><div><font size="2"  >00452 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ((uint32) k[5] &lt;&lt; 16);</font></div><div><font size="2"  >00453 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 5:</font></div><div><font size="2"  >00454 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ((uint32) k[4] &lt;&lt; 24);</font></div><div><font size="2"  >00455 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 4:</font></div><div><font size="2"  >00456 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += k[3];</font></div><div><font size="2"  >00457 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 3:</font></div><div><font size="2"  >00458 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ((uint32) k[2] &lt;&lt; 8);</font></div><div><font size="2"  >00459 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 2:</font></div><div><font size="2"  >00460 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ((uint32) k[1] &lt;&lt; 16);</font></div><div><font size="2"  >00461 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 1:</font></div><div><font size="2"  >00462 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ((uint32) k[0] &lt;&lt; 24);</font></div><div><font size="2"  >00463 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* case 0: nothing left to add */</font></div><div><font size="2"  >00464 &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >00465 #else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* !WORDS_BIGENDIAN */</font></div><div><font size="2"  >00466 &nbsp; &nbsp; &nbsp; &nbsp; switch (len) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* all the case statements fall through */</font></div><div><font size="2"  >00467 &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >00468 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 11:</font></div><div><font size="2"  >00469 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += ((uint32) k[10] &lt;&lt; 24);</font></div><div><font size="2"  >00470 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 10:</font></div><div><font size="2"  >00471 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += ((uint32) k[9] &lt;&lt; 16);</font></div><div><font size="2"  >00472 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 9:</font></div><div><font size="2"  >00473 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c += ((uint32) k[8] &lt;&lt; 8);</font></div><div><font size="2"  >00474 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* the lowest byte of c is reserved for the length */</font></div><div><font size="2"  >00475 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 8:</font></div><div><font size="2"  >00476 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ((uint32) k[7] &lt;&lt; 24);</font></div><div><font size="2"  >00477 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 7:</font></div><div><font size="2"  >00478 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ((uint32) k[6] &lt;&lt; 16);</font></div><div><font size="2"  >00479 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 6:</font></div><div><font size="2"  >00480 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += ((uint32) k[5] &lt;&lt; 8);</font></div><div><font size="2"  >00481 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 5:</font></div><div><font size="2"  >00482 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b += k[4];</font></div><div><font size="2"  >00483 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 4:</font></div><div><font size="2"  >00484 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ((uint32) k[3] &lt;&lt; 24);</font></div><div><font size="2"  >00485 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 3:</font></div><div><font size="2"  >00486 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ((uint32) k[2] &lt;&lt; 16);</font></div><div><font size="2"  >00487 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 2:</font></div><div><font size="2"  >00488 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += ((uint32) k[1] &lt;&lt; 8);</font></div><div><font size="2"  >00489 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 1:</font></div><div><font size="2"  >00490 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += k[0];</font></div><div><font size="2"  >00491 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* case 0: nothing left to add */</font></div><div><font size="2"  >00492 &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >00493 #endif &nbsp; /* WORDS_BIGENDIAN */</font></div><div><font size="2"  >00494 &nbsp; &nbsp; }</font></div><div><font size="2"  >00495&nbsp;</font></div><div><font size="2"  >00496 &nbsp; &nbsp; final(a, b, c);</font></div><div><font size="2"  >00497&nbsp;</font></div><div><font size="2"  >00498 &nbsp; &nbsp; /* report the result */</font></div><div><font size="2"  >00499 &nbsp; &nbsp; return UInt32GetDatum(c);</font></div><div><font size="2"  >00500 }</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>