<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Avoid repeat-calculate in WHERE and SELECT clause</h2>
	<h5 id="">2012-10-23 13:30:27&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402012923105033587/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">今天群里的讨论的一个话题 :&nbsp;<div><div>where不能直接引用列的别名</div><div>但可以在结果中order by引用列的别名</div><div>比如 : &nbsp;&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >select 50*col1 as test from table where test &gt; 100;</font></div><div><font size="2"   >select 50*col1 from table where 50*col1 &gt; 100;</font></div><p></p></pre></div><div>第二种我是不是算了两次?</div><div><br></div><div>这个问题的回答在PostgreSQL邮件归档里面已经有了, 我这就不多说了, 首先第一条SQL肯定是不对的, 原因如下 :&nbsp;</div><div><pre class="prettyprint"   ><p><font size="2"   >No. &nbsp;Evaluation of the WHERE clause logically precedes evaluation of the SELECT list, so it's really quite nonsensical to expect SELECT outputs to be available in WHERE.</font></p></pre></div><div>详细请参考。</div><div><a rel="nofollow" href="http://archives.postgresql.org/pgsql-general/2002-11/msg01411.php"   >http://archives.postgresql.org/pgsql-general/2002-11/msg01411.php</a></div><div><br></div><div>接下来要说说第二个SQL, 确实计算了两次. 下面来测试一下 :&nbsp;</div><div>1. 创建测试表</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \d test</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;Table "digoal.test"</font></div><div><font size="2"   >&nbsp;Column | &nbsp;Type &nbsp; | Modifiers&nbsp;</font></div><div><font size="2"   >--------+---------+-----------</font></div><div><font size="2"   >&nbsp;id &nbsp; &nbsp; | integer |&nbsp;</font></div><p></p></pre></div><div><br></div><div>2. 插入测试数据</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# insert into test values (10000000);</font></div><div><font size="2"   >INSERT 0 1</font></div><p></p></pre></div><div><br></div><div>3. 创建测试函数</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE OR REPLACE FUNCTION public.f_test(i_max integer)</font></div><div><font size="2"   >&nbsp;RETURNS numeric</font></div><div><font size="2"   >&nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >&nbsp;VOLATILE</font></div><div><font size="2"   >AS $function$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; result numeric;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; select avg(id) into result from (select generate_series(1,i_max) as id) as t;&nbsp;</font></div><div><font size="2"   >&nbsp; return result;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$function$;</font></div><p></p></pre></div><div><br></div><div>4. 测试</div><div>&nbsp;-- f_test(id)在SELECT子句中, 整个SQL执行时间<span style="line-height: 22px;"   >1396.352 ms</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select f_test(id) from test ;</font></div><div><font size="2"   >-[ RECORD 1 ]----------------</font></div><div><font size="2"   >f_test | 5000000.500000000000</font></div><div><font size="2"   >Time: 1396.352 ms</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >&nbsp;-- f_test(id)在WHERE子句中, 整个SQL执行时间</span><span style="line-height: 22px;"   >1522.211 ms</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select id from test where f_test(id)&gt;1000;</font></div><div><font size="2"   >-[ RECORD 1 ]</font></div><div><font size="2"   >id | 10000000</font></div><div><font size="2"   >Time: 1522.211 ms</font></div><p></p></pre></div></div><div><span style="line-height: 22px;"   >&nbsp;-- f_test(id)在WHERE子句和SELECT子句中, 整个SQL执行时间</span><span style="line-height: 22px;"   >2925.725 ms</span></div><div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >postgres=# select f_test(id) from test where f_test(id)&gt;1000;</font></div><div style="line-height: 22px;"   ><font size="2"   >-[ RECORD 1 ]----------------</font></div><div style="line-height: 22px;"   ><font size="2"   >f_test | 5000000.500000000000</font></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >Time: 2925.725 ms</font></span></div><p></p></pre></div></div><div>从时间上看, f_test(id)确实执行了两遍. 这也验证了Tom Lane的回答 :&nbsp;</div><div><pre class="prettyprint"   ><p><font size="2"   >&nbsp; Evaluation of the WHERE clause logically precedes evaluation of the SELECT list, so it's really quite nonsensical to expect SELECT outputs to be available in WHERE.</font></p></pre></div><div><br></div><div>那接下来看看怎么优化一下 :&nbsp;</div><div>4.1. 前面已经说过了, SELECT子句中的别名不能在WHERE子句中使用, 会报错如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select f_test(id) as res from test where res&gt;1000;</font></div><div><font size="2"   >ERROR: &nbsp;42703: column "res" does not exist at character 42</font></div><div><font size="2"   >LOCATION: &nbsp;errorMissingColumn, parse_relation.c:2616</font></div><div><font size="2"   >STATEMENT: &nbsp;select f_test(id) as res from test where res&gt;1000;</font></div><div><font size="2"   >ERROR: &nbsp;column "res" does not exist</font></div><div><font size="2"   >LINE 1: select f_test(id) as res from test where res&gt;1000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^</font></div><p></p></pre></div><div>4.2. 使用子查询进行优化</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select res from (select f_test(id) as res from test) t where res&gt;1000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;res &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;5000000.500000000000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 1430.874 ms</font></div><p></p></pre></div><div>注意函数的稳定性是 volatile.</div><div>volatile函数多次调用,&nbsp;<span style="line-height: 28px;"   >在输入参数一致的情况下</span><span style="line-height: 28px;"   >返回结果可能不一致.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select pronamespace,proname,provolatile from pg_proc where proname='f_test';</font></div><div><font size="2"   >&nbsp;pronamespace | proname | provolatile&nbsp;</font></div><div><font size="2"   >--------------+---------+-------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2200 | f_test &nbsp;| v</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>如果把函数改成immutable 或者 stable的, 执行时间还是这样吗?</div><div>immutable和stable函数, (在输入参数一致的情况下, 多次调用, 返回值一致)&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# alter function f_test(int) STABLE;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><div><font size="2"   >Time: 0.385 ms</font></div><div><font size="2"   >postgres=# select pronamespace,proname,provolatile from pg_proc where proname='f_test';</font></div><div><font size="2"   >&nbsp;pronamespace | proname | provolatile&nbsp;</font></div><div><font size="2"   >--------------+---------+-------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2200 | f_test &nbsp;| s</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 0.668 ms</font></div><div><font size="2"   >postgres=# select res from (select f_test(id) as res from test) t where res&gt;1000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;res &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;5000000.500000000000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 2798.577 ms</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# alter function f_test(int) IMMUTABLE;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><div><font size="2"   >Time: 0.460 ms</font></div><div><div><font size="2"   >postgres=# select pronamespace,proname,provolatile from pg_proc where proname='f_test';</font></div><div><font size="2"   >&nbsp;pronamespace | proname | provolatile&nbsp;</font></div><div><font size="2"   >--------------+---------+-------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2200 | f_test &nbsp;| i</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >postgres=# select res from (select f_test(id) as res from test) t where res&gt;1000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;res &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;5000000.500000000000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 2780.895 ms</font></div><p></p></pre></div><div>函数改成stable或者immutable后, 在这个SQL中, f_test(id)被执行了两次. 而当函数f_test是volatile的时候, f_test函数只执行了一遍.</div><div>所以使用子查询对这个SQL进行优化只适合函数是volatile的.</div><div>[注意]</div><div>这里有点无法理解PostgreSQL的做法, 不管函数什么稳定性, 使用select res from (select f_test(id) as res from test) t where res&gt;1000后, 完全都可以做成仅调用一次的.&nbsp;</div><div>原因在于优化器在搞鬼, stable,immutable函数和volatile函数在处理时不一样.</div><div>要解决这个问题, 需要用WITH语法, 见本文后面的部分.</div><div>volatile函数, 用了子查询 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain (analyze,verbose,costs,buffers,timing) select res from (select f_test(id) as res from test) t where res&gt;1000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Subquery Scan on t &nbsp;(cost=0.00..2634.18 rows=3210 width=32) (actual time=1386.403..1386.404 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: t.res</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (t.res &gt; 1000::numeric)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=1</font></div><div><font size="2"   >&nbsp; &nbsp;-&gt; &nbsp;Seq Scan on public.test &nbsp;(cost=0.00..2513.80 rows=9630 width=4) (actual time=1386.399..1386.400 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output: f_test(test.id)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffers: shared hit=1</font></div><div><font size="2"   >&nbsp;Planning time: 0.062 ms</font></div><div><font size="2"   >&nbsp;Execution time: 1386.425 ms</font></div><div><font size="2"   >(9 rows)</font></div><p></p></pre></div><div>immutable, stable函数, 没有用子查询 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain (analyze,verbose,costs,buffers,timing) select res from (select f_test(id) as res from test) t where res&gt;1000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Seq Scan on public.test &nbsp;(cost=0.00..3340.38 rows=3210 width=4) (actual time=2756.246..2756.247 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: f_test(test.id)</font></div><div><font size="2"   >&nbsp; &nbsp;Filter: (f_test(test.id) &gt; 1000::numeric)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=7</font></div><div><font size="2"   >&nbsp;Planning time: 0.053 ms</font></div><div><font size="2"   >&nbsp;Execution time: 2756.262 ms</font></div><div><font size="2"   >(6 rows)</font></div><p></p></pre></div><div><br></div><div>5. 操作符的稳定性</div><div>在PostgreSQL中操作符其实可以理解为函数的一种使用形式或别名. 从创建操作符的语法能看出这一点.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Command: &nbsp; &nbsp; CREATE OPERATOR</font></div><div><font size="2"   >Description: define a new operator</font></div><div><font size="2"   >Syntax:</font></div><div><font size="2"   >CREATE OPERATOR name (</font></div><div><font size="2"   >&nbsp; &nbsp; PROCEDURE = function_name</font></div><div><font size="2"   >&nbsp; &nbsp; [, LEFTARG = left_type ] [, RIGHTARG = right_type ]</font></div><div><font size="2"   >&nbsp; &nbsp; [, COMMUTATOR = com_op ] [, NEGATOR = neg_op ]</font></div><div><font size="2"   >&nbsp; &nbsp; [, RESTRICT = res_proc ] [, JOIN = join_proc ]</font></div><div><font size="2"   >&nbsp; &nbsp; [, HASHES ] [, MERGES ]</font></div><div><font size="2"   >)</font></div><p></p></pre></div><div>所以操作符也是有稳定性的, 那么操作符的稳定性在哪里能查到呢? 通过pg_proc和pg_operator就可以查询.</div><div>例如*这个操作符 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select oprname,pronamespace,proname,provolatile from pg_operator o,pg_proc f where o.oprcode=f.oid and oprname='*' order by proname;</font></div><div><font size="2"   >&nbsp;oprname | pronamespace | &nbsp; &nbsp; proname &nbsp; &nbsp; | provolatile&nbsp;</font></div><div><font size="2"   >---------+--------------+-----------------+-------------</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | box_mul &nbsp; &nbsp; &nbsp; &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | cash_mul_flt4 &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | cash_mul_flt8 &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | cash_mul_int2 &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | cash_mul_int4 &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | circle_mul_pt &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | float48mul &nbsp; &nbsp; &nbsp;| i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | float4mul &nbsp; &nbsp; &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | float84mul &nbsp; &nbsp; &nbsp;| i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | float8mul &nbsp; &nbsp; &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | flt4_mul_cash &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | flt8_mul_cash &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | int24mul &nbsp; &nbsp; &nbsp; &nbsp;| i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | int28mul &nbsp; &nbsp; &nbsp; &nbsp;| i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | int2_mul_cash &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | int2mul &nbsp; &nbsp; &nbsp; &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | int42mul &nbsp; &nbsp; &nbsp; &nbsp;| i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | int48mul &nbsp; &nbsp; &nbsp; &nbsp;| i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | int4_mul_cash &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | int4mul &nbsp; &nbsp; &nbsp; &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | int82mul &nbsp; &nbsp; &nbsp; &nbsp;| i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | int84mul &nbsp; &nbsp; &nbsp; &nbsp;| i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | int8mul &nbsp; &nbsp; &nbsp; &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | interval_mul &nbsp; &nbsp;| i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | mul_d_interval &nbsp;| i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | numeric_mul &nbsp; &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | path_mul_pt &nbsp; &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | point_mul &nbsp; &nbsp; &nbsp; | i</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | range_intersect | i</font></div><div><font size="2"   >(29 rows)</font></div><p></p></pre></div><div>都是immutable的. 所以对于子查询的优化无效.</div><div>那有没有更好的优化办法呢?</div><div><br></div><div>6. 使用WITH 查询, 不管f_test的稳定性如何, 以下f_test函数肯定只执行一次.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# alter function f_test(int) volatile;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><div><font size="2"   >Time: 0.286 ms</font></div><div><font size="2"   >postgres=# with res as &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >(select f_test(id) as aid from test)</font></div><div><font size="2"   >select * from res where aid&gt;100;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;aid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;5000000.500000000000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 1401.281 ms</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# alter function f_test(int) stable;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><div><font size="2"   >Time: 0.623 ms</font></div><div><font size="2"   >postgres=# with res as &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >(select f_test(id) as aid from test)</font></div><div><font size="2"   >select * from res where aid&gt;100;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;aid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;5000000.500000000000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 1410.731 ms</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# alter function f_test(int) immutable;</font></div><div><font size="2"   >ALTER FUNCTION</font></div><div><font size="2"   >Time: 0.360 ms</font></div><div><font size="2"   >postgres=# with res as &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >(select f_test(id) as aid from test)</font></div><div><font size="2"   >select * from res where aid&gt;100;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;aid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----------------------</font></div><div><font size="2"   >&nbsp;5000000.500000000000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 1403.333 ms</font></div><p></p></pre></div><div><br></div>【参考】<wbr></div><div>1. Using an ALIAS in WHERE clause</div><div><a target="_blank" rel="nofollow" href="http://archives.postgresql.org/pgsql-general/2002-11/msg01409.php"   >http://archives.postgresql.org/pgsql-general/2002-11/msg01409.php</a></div><div>2. function 稳定性</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201151011105494/"   >http://blog.163.com/digoal@126/blog/static/163877040201151011105494/</a></div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201252641410920/"   >http://blog.163.com/digoal@126/blog/static/163877040201252641410920/</a></div><div>3.&nbsp;<a rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/catalog-pg-operator.html"   >http://www.postgresql.org/docs/9.2/static/catalog-pg-operator.html</a></div><div>4. with子句</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201132843255911/"   >http://blog.163.com/digoal@126/blog/static/163877040201132843255911/</a></div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201132782850752/"   >http://blog.163.com/digoal@126/blog/static/163877040201132782850752/</a></div><div><br></div><div>【附加Oracle的同类测试】</div><div>1. 创建测试表, 插入测试数据</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; drop table test;</font></div><div><font size="2"   >Table dropped.</font></div><div><font size="2"   >SQL&gt; create table test(id int);</font></div><div><font size="2"   >Table created.</font></div><div><font size="2"   >SQL&gt; insert into test values (10000000);</font></div><div><font size="2"   >1 row created.</font></div><p></p></pre></div><div><br></div><div>2. 创建测试函数 :&nbsp;</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; create or replace function f_test (i_max int) return number as</font></div><div><font size="2"   >&nbsp; 2 &nbsp;result number;</font></div><div><font size="2"   >&nbsp; 3 &nbsp;begin</font></div><div><font size="2"   >&nbsp; 4 &nbsp;select avg(id) into result from ( select rownum as id from dual connect by level &lt;= i_max ) t;</font></div><div><font size="2"   >&nbsp; 5 &nbsp;return result;</font></div><div><font size="2"   >&nbsp; 6 &nbsp;end;</font></div><div><font size="2"   >&nbsp; 7 &nbsp;/</font></div><div><font size="2"   >Function created.</font></div><div><font size="2"   >Elapsed: 00:00:00.07</font></div><p></p></pre></div><div><br></div><div><span style="line-height: 22px;"   >&nbsp;-- f_test(id)在SELECT子句中, 整个SQL执行时间</span><span style="line-height: 22px;"   >8.1秒</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; select f_test(id) from test;</font></div><div><font size="2"   >F_TEST(ID)</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;5000000.5</font></div><div><font size="2"   >Elapsed: 00:00:08.10</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >&nbsp;-- f_test(id)在WHERE子句中, 整个SQL执行时间</span><span style="line-height: 22px;"   >7.57秒</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; select id from test where f_test(id)&gt;100;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ID</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; 10000000</font></div><div><font size="2"   >Elapsed: 00:00:07.57</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >&nbsp;-- f_test(id)在WHERE子句和SELECT子句中, 整个SQL执行时间</span><span style="line-height: 22px;"   >14.32 秒</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; select f_test(id) as aid from test where f_test(id)&gt;100;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;AID</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;5000000.5</font></div><div><font size="2"   >Elapsed: 00:00:14.32</font></div><p></p></pre></div><div>从执行时间上看, f_test被执行了两遍, 并且相比PostgreSQL执行时间较长. PostgreSQL但次执行时间为1.5秒左右.</div><div><br></div><div>Oracle同样不支持SELECT子句中的别名出现在WHERE子句中.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; select f_test(id) as aid from test where aid&gt;100;</font></div><div><font size="2"   >select f_test(id) as aid from test where aid&gt;100</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >ERROR at line 1:</font></div><div><font size="2"   >ORA-00904: "AID": invalid identifier</font></div><div><font size="2"   >Elapsed: 00:00:00.06</font></div><p></p></pre></div><div><br></div><div>Oracle使用子查询无法对这种情况进行优化.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SQL&gt; select aid from (select f_test(id) as aid from test) t where aid&gt;100;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;AID</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp;5000000.5</font></div><div><font size="2"   >Elapsed: 00:00:14.41</font></div><p></p></pre></div></div><div><span style="line-height: 28px;"   >这里用到的是Oracle 10.2.0.4的版本. 这个测试中PG略胜Oracle.</span></div></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">284466130 - 2012-10-23 15:42:46</h5>
				<div>nice Digoal... soga</div>
			</div>
	</div>
</div>
</body>
</html>