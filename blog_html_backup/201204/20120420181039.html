<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL HOT Standby Query and Recovery Conflict Introduction</h2>
	<h5 id="">2012-04-20 18:10:39&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201232021644846/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><span style="line-height: 22px;"  >本文基于PostgreSQL9.0.4版本来说.</span></div><div><span style="line-height: 22px;"  >PostgreSQL 的 Hot Standby常被用来当只读的数据库提供查询或者统计服务, 但是由于各种原因查询SQL可能被cancel掉。</span></div><div><span style="line-height: 22px;"  >例如,&nbsp;</span></div><div><span style="line-height: 22px;"  >1. 主库执行了DROP某TABLE的操作, 而standby库上某用户正在查询这个表的数据. 当standby接收到了这些XLOG的信息并且准备在standby库上apply的时候, 如果这个SQL还在执行, 就发生冲突了, 这个时候standby 要判断是否要cancel掉这个SQL使得apply可以正常进行下去, 或者standby选择等待多长时间.&nbsp;</span></div><div><span style="line-height: 22px;"  >2. 主库执行删除表空间或者删除库等相关的操作也会遇到上面的问题.</span></div><div><span style="line-height: 22px;"  >3. 更隐晦的是主库上执行了vacuum操作, 这些被vacuum掉的tuple, 可能是standby库上的SQL可见的TUPLE, 也会发生冲突.</span></div><div><span style="line-height: 22px;"  >4. 还有其他原因, 详细参考附录</span></div><div><span style="line-height: 22px;"  >那么Standby根据什么来判断是CANCEL SQL还是选择等待, 如果等待, 等多长时间?</span></div><div>有两个参数</div><div>max_standby_archive_delay</div><div>max_standby_streaming_delay</div><div>如果值等于-1表示永不因为recovery 和SQL冲突原因cancel standby上的SQL.</div><div>如果设置了一个值如30秒, 那么在cancel 冲突的SQL前, 会等待, 等待多长时间, 看下面几个函数.</div><div><div>1. 取自src/backend/storage/ipc/standby.c</div><div>通过GetStandbyLimitTime来判断是否要触发CANCEL SQL, 当GetStandbyLimitTime返回的值为0 时表示永不触发CANCEL, 如果返回的是一个时间值, 这个时间值和当前时间进行比较, 如果小于当前时间则进行CANCEL操作.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Determine the cutoff time at which we want to start canceling conflicting</font></div><div><font size="2"  >&nbsp;* transactions. &nbsp;Returns zero (a time safely in the past) if we are willing</font></div><div><font size="2"  >&nbsp;* to wait forever.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >static TimestampTz</font></div><div><font size="2"  >GetStandbyLimitTime(void)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz rtime;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fromStream;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The cutoff time is the last WAL data receipt time plus the appropriate</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* delay variable. &nbsp; &nbsp; &nbsp;Delay of -1 means wait forever.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; GetXLogReceiptTime(&amp;rtime, &amp;fromStream);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (fromStream)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (max_standby_streaming_delay &lt; 0)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* wait forever */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return TimestampTzPlusMilliseconds(rtime, max_standby_streaming_delay);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (max_standby_archive_delay &lt; 0)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* wait forever */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return TimestampTzPlusMilliseconds(rtime, max_standby_archive_delay);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >}</font></div><p></p></pre></div></div><div><span style="line-height: 22px;"  >rtime是通过</span><span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >GetXLogReceiptTime获取的.</span></div><div><span style="line-height: 22px;"  >从上面的代码中可以看出, SQL是否被CANCEL不仅仅取决于</span>max_standby_streaming_delay或max_standby_archive_delay设定的时间, 而是取决于GetXLogReceiptTime设置的rtime加<span style="line-height: 22px;"  >max_standby_streaming_delay或max_standby_archive_delay的这个结果是否大于当前的时间点.&nbsp;</span></div><div><span style="line-height: 22px;"  >GetXLogReceiptTime&nbsp;</span>如下 :&nbsp;</div><div>src/backend/access/transam/xlog.c</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Returns time of receipt of current chunk of XLOG data, as well as</font></div><div><font size="2"  >&nbsp;* whether it was received from streaming replication or from archives.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >void</font></div><div><font size="2"  >GetXLogReceiptTime(TimestampTz *rtime, bool *fromStream)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* This must be executed in the startup process, since we don't export the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* relevant state to shared memory.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; Assert(InRecovery);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; *rtime = XLogReceiptTime;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; *fromStream = (XLogReceiptSource == XLOG_FROM_STREAM);</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>而XLogReceiptTime变量又是通过如下逻辑来修改的,</div><div><div>src/backend/access/transam/xlog.c</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Walreceiver is active, so see if new data has arrived.</font></div><div><font size="2"  >&nbsp;* We only advance XLogReceiptTime when we obtain fresh</font></div><div><font size="2"  >&nbsp;* WAL from walreceiver and observe that we had already</font></div><div><font size="2"  >&nbsp;* processed everything before the most recent "chunk"</font></div><div><font size="2"  >&nbsp;* that it flushed to disk. &nbsp;In steady state where we are</font></div><div><font size="2"  >&nbsp;* keeping up with the incoming data, XLogReceiptTime will</font></div><div><font size="2"  >&nbsp;* be updated on each cycle. &nbsp;When we are behind,</font></div><div><font size="2"  >&nbsp;* XLogReceiptTime will not advance, so the grace time</font></div><div><font size="2"  >&nbsp;* alloted to conflicting queries will decrease.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >if (XLByteLT(*RecPtr, receivedUpto))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; havedata = true;</font></div><div><font size="2"  >else</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;latestChunkStart;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; receivedUpto = GetWalRcvWriteRecPtr(&amp;latestChunkStart);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (XLByteLT(*RecPtr, receivedUpto))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; havedata = true;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!XLByteLT(*RecPtr, latestChunkStart))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogReceiptTime = GetCurrentTimestamp();</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; havedata = false;</font></div><div><font size="2"  >}</font></div><div><font size="2"  >if (havedata)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Great, streamed far enough. Open the file if it's</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* not open already. &nbsp;Use XLOG_FROM_STREAM so that</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* source info is set correctly and XLogReceiptTime</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* isn't changed.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (readFile &lt; 0)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readFile =</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogFileRead(readId, readSeg, PANIC,</font></div><div><font size="2"  ><span>    </span>recoveryTargetTLI,</font></div><div><font size="2"  ><span>    </span>XLOG_FROM_STREAM, false);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(readFile &gt;= 0);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switched_segment = true;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* just make sure source info is correct... */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readSource = XLOG_FROM_STREAM;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogReceiptSource = XLOG_FROM_STREAM;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"  >}</font></div><p></p></pre></div></div><div>src/include/access/xlogdefs.h</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >#define XLByteLT(a, b) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((a).xlogid &lt; (b).xlogid || \</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;((a).xlogid == (b).xlogid &amp;&amp; (a).xrecoff &lt; (b).xrecoff))</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >#define XLByteLE(a, b) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((a).xlogid &lt; (b).xlogid || \</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;((a).xlogid == (b).xlogid &amp;&amp; (a).xrecoff &lt;= (b).xrecoff))</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >#define XLByteEQ(a, b) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((a).xlogid == (b).xlogid &amp;&amp; (a).xrecoff == (b).xrecoff)</font></div><p></p></pre></div><div>RecPtr的更新参见</div><div>src/backend/access/transam/xlog.c</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Insert an XLOG record having the specified RMID and info bytes,</font></div><div><font size="2"  >&nbsp;* with the body of the record being the data chunk(s) described by</font></div><div><font size="2"  >&nbsp;* the rdata chain (see xlog.h for notes about rdata).</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Returns XLOG pointer to end of record (beginning of next record).</font></div><div><font size="2"  >&nbsp;* This can be used as LSN for data pages affected by the logged action.</font></div><div><font size="2"  >&nbsp;* (LSN is the XLOG point up to which the XLOG must be flushed to disk</font></div><div><font size="2"  >&nbsp;* before the data page can be written out. &nbsp;This implements the basic</font></div><div><font size="2"  >&nbsp;* WAL rule "write the log before the data".)</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* NB: this routine feels free to scribble on the XLogRecData structs,</font></div><div><font size="2"  >&nbsp;* though not on the data they reference. &nbsp;This is OK since the XLogRecData</font></div><div><font size="2"  >&nbsp;* structs are always just temporaries in the calling code.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >XLogRecPtr</font></div><div><font size="2"  >XLogInsert(RmgrId rmid, uint8 info, XLogRecData *rdata)</font></div><div><font size="2"  >{</font></div></div><div><font size="2"  >略</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>src/backend/replication/walreceiverfuncs.c</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Returns the last+1 byte position that walreceiver has written.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Optionally, returns the previous chunk start, that is the first byte</font></div><div><font size="2"  >&nbsp;* written in the most recent walreceiver flush cycle. &nbsp;Callers not</font></div><div><font size="2"  >&nbsp;* interested in that value may pass NULL for latestChunkStart.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >XLogRecPtr</font></div><div><font size="2"  >GetWalRcvWriteRecPtr(XLogRecPtr *latestChunkStart)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* use volatile pointer to prevent code rearrangement */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; volatile WalRcvData *walrcv = WalRcv;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr &nbsp; &nbsp; &nbsp;recptr;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walrcv-&gt;mutex);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; recptr = walrcv-&gt;receivedUpto;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (latestChunkStart)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *latestChunkStart = walrcv-&gt;latestChunkStart;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; return recptr;</font></div><div><font size="2"  >}</font></div><p></p></pre></div><div>XLogReceiptTime这个变量到底什么时候才会更新成GetCurrentTimestamp()呢, 更新这个变量必须满足如下两个条件,</div><div>1. 在WALreceiver运行时调用,</div><div>2. 已经recover的XLOG的位置必须大于或等于latestChunkStart.</div><div>因此当standby的recover很慢, 但是receiver很快, 并且recover一直都没有跟上receiver到的xlog的位置时, 这个<span style="line-height: 22px;"  >XLogReceiptTime就一直都没有办法更新</span><font face="monospace"  size="2"  ><span style="line-height: 19px; white-space: pre;"  >到当前时间.</span></font></div><div>在这种情况下留给在standby上执行SQL的时间窗口就会很小.&nbsp;</div><div>怎么解决呢?</div><div>1. 把max_standby_streaming_delay, max_standby_archive_delay调成-1. 如果要调整SQL的超时通过statement_timeout来设置.</div><div>2. 提高standby 的IO能力. 让standby数据库的recover能跟上接收到的XLOG的节奏.</div><div>3. 使用PostgreSQL 9.1版本, 9.1加大了<span style="line-height: 22px;"  >max_standby_streaming_delay, max_standby_archive_delay允许的最大值, 并且添加了</span>pg_xlog_replay_pause()函数可以暂停recover, 以及hot_standby_feedback参数降低被cancel的概率.</div><div>以下取自PostgreSQL 9.1 HISTORY.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >Hot Standby</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;* Add configuration parameter hot_standby_feedback to enable standbys</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;to postpone cleanup of old row versions on the primary (Simon</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Riggs)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;This helps avoid canceling long-running queries on the standby.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;* Add the pg_stat_database_conflicts system view to show queries that</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;have been canceled and the reason (Magnus Hagander)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Cancellations can occur because of dropped tablespaces, lock</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;timeouts, old snapshots, pinned buffers, and deadlocks.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;* Add a conflicts count to pg_stat_database (Magnus Hagander)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;This is the number of conflicts that occurred in the database.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;* Increase the maximum values for max_standby_archive_delay and</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;max_standby_streaming_delay</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The maximum value for each of these parameters was previously only</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;about 35 minutes. Much larger values are now allowed.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;* Add ERRCODE_T_R_DATABASE_DROPPED error code to report recovery</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;conflicts due to dropped databases (Tatsuo Ishii)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;This is useful for connection pooling software.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;__________________________________________________________________</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >Recovery Control</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;* Add functions to control streaming replication replay (Simon Riggs)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;The new functions are pg_xlog_replay_pause(),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;pg_xlog_replay_resume(), and the status function</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;pg_is_xlog_replay_paused().</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;* Add "recovery.conf" setting pause_at_recovery_target to pause</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;recovery at target (Simon Riggs)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;This allows a recovery server to be queried to check whether the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;recovery point is the one desired.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;* Add the ability to create named restore points using</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;pg_create_restore_point() (Jaime Casanova)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;These named restore points can be specified as recovery targets</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;using the new "recovery.conf" setting recovery_target_name.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;* Allow standby recovery to switch to a new timeline automatically</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;(Heikki Linnakangas)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Now standby servers scan the archive directory for new timelines</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;periodically. &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;* Add restart_after_crash setting which disables automatic server</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;restart after a backend crash (Robert Haas)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;This allows external cluster management software to control whether</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;the database server restarts or not.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp;* Allow "recovery.conf" to use the same quoting behavior as</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;"postgresql.conf" (Dimitri Fontaine)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp;Previously all values had to be quoted.</font></div><p></p></pre></div><div><br></div><div>下面是关于xlog文件的读取和写入的介绍,</div><div>主库的wal sender进程.</div><div>1.&nbsp;postgres: wal sender process 这个进程是读取xlog文件并发往standby的receiver进程的.</div><div>2.&nbsp;postgres: wal writer process 这个进程负责写和更新XLOG日志.</div><div>standby库的startup进程和receiver进程.</div><div>1. postgres: startup process &nbsp; recovering 这个进程是读取xlog文件的.</div><div><span style="line-height: 22px;"  >2.&nbsp;</span>postgres: wal receiver process 这个进程是接收主库的sender发送过来的XLOG信息并初始化并更新到xlog文件的.</div><div>使用lsof去看这些进程的打开文件可以看出来,&nbsp;</div><div>读取xlog的sender进程或startup进程例如</div><div>postgres &nbsp; 4756 &nbsp;postgres &nbsp; &nbsp;5r &nbsp; &nbsp; &nbsp;REG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;104,3 &nbsp; 16777216 &nbsp; 14160028 /pg_xlog/000000050000029B000000D6</div><div>更新到xlog文件的例如receiver进程, 因为主库每次切换XLOG后都会新建一个XLOG文件. 填满初始值, 可能是0, 后面就是receiver接收并更新这个XLOG的内容.</div><div>postgres &nbsp;4151 &nbsp;postgres &nbsp; &nbsp;4u &nbsp; &nbsp; &nbsp;REG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;253,0 &nbsp; 67108864 &nbsp; &nbsp;1836097 /pg_xlog/0000000200000F5B0000001A</div><div><br></div><div><span style="line-height: 22px;"  >standby.c中query cancel逻辑部分建附录.</span></div><div><span style="line-height: 22px;"  >【小结】</span></div><div>PostgreSQL 9.0.4中有两个函数</div><div>pg_last_xlog_replay_location()</div><div>pg_last_xlog_receive_location()</div><div>这两个函数存在差异时, 则表示wal receiver接收到新的XLOG时不会更新<span style="line-height: 22px;"  >XLogReceiptTime这个变量.</span></div><div>到PostgreSQL 9.1 新增了几个函数, 例如查<span style="line-height: 22px;"  >询</span><span style="line-height: 22px;"  >pg_last_xact_replay_timestamp可以反映STANDBY最后一次commit/abort record被恢复的时间, 但是没有函数可以返回</span><span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >XLogReceiptTime的值, 还是值得期待的. 那样就可以方便的知道接下来执行的SQL有可能会在多长时间内被CANCEL掉。</span></div><div><span style="font-family: monospace; font-size: small; line-height: 19px; white-space: pre;"  >以下取自PostgreSQL 9.1 </span><font face="monospace"  size="2"  ><span style="line-height: 19px; white-space: pre;"  >src/backend/access/transam/xlog.c</span></font></div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Fetch timestamp of latest processed commit/abort record.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >static TimestampTz</font></div><div><font size="2"  >GetLatestXTime(void)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* use volatile pointer to prevent code rearrangement */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; volatile XLogCtlData *xlogctl = XLogCtl;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz xtime;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;xlogctl-&gt;info_lck);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; xtime = xlogctl-&gt;recoveryLastXTime;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;xlogctl-&gt;info_lck);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; return xtime;</font></div><div><font size="2"  >}</font></div></div><div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Returns timestamp of latest processed commit/abort record.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* When the server has been started normally without recovery the function</font></div><div><font size="2"  >&nbsp;* returns NULL.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >Datum</font></div><div><font size="2"  >pg_last_xact_replay_timestamp(PG_FUNCTION_ARGS)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz xtime;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; xtime = GetLatestXTime();</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (xtime == 0)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(xtime);</font></div><div><font size="2"  >}</font></div></div><p></p></pre></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >postgres=# \df *.*rece*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of functions</font></div><div><font size="2"  >&nbsp; &nbsp;Schema &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Result data type | Argument data types | &nbsp;Type &nbsp;</font></div><div><font size="2"  >------------+-------------------------------+------------------+---------------------+--------</font></div><div><font size="2"  >&nbsp;pg_catalog | pg_last_xlog_receive_location | text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | normal</font></div><div><font size="2"  >(1 row)</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >postgres=# \df *.*replay*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of functions</font></div><div><font size="2"  >&nbsp; &nbsp;Schema &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; Result data type &nbsp; &nbsp; | Argument data types | &nbsp;Type &nbsp;</font></div><div><font size="2"  >------------+-------------------------------+--------------------------+---------------------+--------</font></div><div><font size="2"  >&nbsp;pg_catalog | pg_is_xlog_replay_paused &nbsp; &nbsp; &nbsp;| boolean &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | normal</font></div><div><font size="2"  >&nbsp;pg_catalog | pg_last_xact_replay_timestamp | timestamp with time zone | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | normal</font></div><div><font size="2"  >&nbsp;pg_catalog | pg_last_xlog_replay_location &nbsp;| text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | normal</font></div><div><font size="2"  >&nbsp;pg_catalog | pg_xlog_replay_pause &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| void &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | normal</font></div><div><font size="2"  >&nbsp;pg_catalog | pg_xlog_replay_resume &nbsp; &nbsp; &nbsp; &nbsp; | void &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | normal</font></div><div><font size="2"  >(5 rows)</font></div><p></p></pre></div><div><span style="line-height: 22px;"  ><br></span></div>【参考】<div><a rel="nofollow" href="http://www.postgresql.org/docs/9.0/static/hot-standby.html#HOT-STANDBY-CONFLICT"  >http://www.postgresql.org/docs/9.0/static/hot-standby.html#HOT-STANDBY-CONFLICT</a>&nbsp;<br>src/backend/access/transam/xlog.c<wbr></div><div>src/backend/storage/ipc/standby.c</div><div>src/include/utils/timestamp.h</div><div>【附】</div><div>rdata结构, src/include/access/xlog.h</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* The rmgr data to be written by XLogInsert() is defined by a chain of</font></div><div><font size="2"  >&nbsp;* one or more XLogRecData structs. &nbsp;(Multiple structs would be used when</font></div><div><font size="2"  >&nbsp;* parts of the source data aren't physically adjacent in memory, or when</font></div><div><font size="2"  >&nbsp;* multiple associated buffers need to be specified.)</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* If buffer is valid then XLOG will check if buffer must be backed up</font></div><div><font size="2"  >&nbsp;* (ie, whether this is first change of that page since last checkpoint).</font></div><div><font size="2"  >&nbsp;* If so, the whole page contents are attached to the XLOG record, and XLOG</font></div><div><font size="2"  >&nbsp;* sets XLR_BKP_BLOCK_X bit in xl_info. &nbsp;Note that the buffer must be pinned</font></div><div><font size="2"  >&nbsp;* and exclusive-locked by the caller, so that it won't change under us.</font></div><div><font size="2"  >&nbsp;* NB: when the buffer is backed up, we DO NOT insert the data pointed to by</font></div><div><font size="2"  >&nbsp;* this XLogRecData struct into the XLOG record, since we assume it's present</font></div><div><font size="2"  >&nbsp;* in the buffer. &nbsp;Therefore, rmgr redo routines MUST pay attention to</font></div><div><font size="2"  >&nbsp;* XLR_BKP_BLOCK_X to know what is actually stored in the XLOG record.</font></div><div><font size="2"  >&nbsp;* The i'th XLR_BKP_BLOCK bit corresponds to the i'th distinct buffer</font></div><div><font size="2"  >&nbsp;* value (ignoring InvalidBuffer) appearing in the rdata chain.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* When buffer is valid, caller must set buffer_std to indicate whether the</font></div><div><font size="2"  >&nbsp;* page uses standard pd_lower/pd_upper header fields. &nbsp;If this is true, then</font></div><div><font size="2"  >&nbsp;* XLOG is allowed to omit the free space between pd_lower and pd_upper from</font></div><div><font size="2"  >&nbsp;* the backed-up page image. &nbsp;Note that even when buffer_std is false, the</font></div><div><font size="2"  >&nbsp;* page MUST have an LSN field as its first eight bytes!</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Note: data can be NULL to indicate no rmgr data associated with this chain</font></div><div><font size="2"  >&nbsp;* entry. &nbsp;This can be sensible (ie, not a wasted entry) if buffer is valid.</font></div><div><font size="2"  >&nbsp;* The implication is that the buffer has been changed by the operation being</font></div><div><font size="2"  >&nbsp;* logged, and so may need to be backed up, but the change can be redone using</font></div><div><font size="2"  >&nbsp;* only information already present elsewhere in the XLOG entry.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >typedef struct XLogRecData</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *data; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* start of rmgr data to include */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; uint32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;len; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* length of rmgr data to include */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; Buffer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;buffer; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* buffer associated with data, if any */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;buffer_std; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* buffer has standard pd_lower/pd_upper */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; struct XLogRecData *next; &nbsp; &nbsp; &nbsp; /* next struct in chain, or NULL */</font></div><div><font size="2"  >} XLogRecData;</font></div><p></p></pre></div><div>standby.c中query cancel逻辑部分</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* -----------------------------------------------------</font></div><div><font size="2"  >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Standby wait timers and backend cancel logic</font></div><div><font size="2"  >&nbsp;* -----------------------------------------------------</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Determine the cutoff time at which we want to start canceling conflicting</font></div><div><font size="2"  >&nbsp;* transactions. &nbsp;Returns zero (a time safely in the past) if we are willing</font></div><div><font size="2"  >&nbsp;* to wait forever.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >static TimestampTz</font></div><div><font size="2"  >GetStandbyLimitTime(void)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz rtime;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fromStream;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The cutoff time is the last WAL data receipt time plus the appropriate</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* delay variable. &nbsp; &nbsp; &nbsp;Delay of -1 means wait forever.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; GetXLogReceiptTime(&amp;rtime, &amp;fromStream);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (fromStream)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (max_standby_streaming_delay &lt; 0)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* wait forever */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return TimestampTzPlusMilliseconds(rtime, max_standby_streaming_delay);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (max_standby_archive_delay &lt; 0)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* wait forever */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return TimestampTzPlusMilliseconds(rtime, max_standby_archive_delay);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >#define STANDBY_INITIAL_WAIT_US &nbsp;1000</font></div><div><font size="2"  >static int &nbsp; &nbsp; &nbsp;standbyWait_us = STANDBY_INITIAL_WAIT_US;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* Standby wait logic for ResolveRecoveryConflictWithVirtualXIDs.</font></div><div><font size="2"  >&nbsp;* We wait here for a while then return. If we decide we can't wait any</font></div><div><font size="2"  >&nbsp;* more then we return true, if we can wait some more return false.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >static bool</font></div><div><font size="2"  >WaitExceedsMaxStandbyDelay(void)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz ltime;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* Are we past the limit time? */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ltime = GetStandbyLimitTime();</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (ltime &amp;&amp; GetCurrentTimestamp() &gt;= ltime)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Sleep a bit (this is essential to avoid busy-waiting).</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; pg_usleep(standbyWait_us);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Progressively increase the sleep times, but not to more than 1s, since</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* pg_usleep isn't interruptable on some platforms.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; standbyWait_us *= 2;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (standbyWait_us &gt; 1000000)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standbyWait_us = 1000000;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; return false;</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* This is the main executioner for any query backend that conflicts with</font></div><div><font size="2"  >&nbsp;* recovery processing. Judgement has already been passed on it within</font></div><div><font size="2"  >&nbsp;* a specific rmgr. Here we just issue the orders to the procs. The procs</font></div><div><font size="2"  >&nbsp;* then throw the required error as instructed.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >static void</font></div><div><font size="2"  >ResolveRecoveryConflictWithVirtualXIDs(VirtualTransactionId *waitlist,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ProcSignalReason reason)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; while (VirtualTransactionIdIsValid(*waitlist))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz waitStart;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *new_status;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_waiting(true);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waitStart = GetCurrentTimestamp();</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_status = NULL; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* we haven't changed the ps display */</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* reset standbyWait_us for each xact we wait for */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standbyWait_us = STANDBY_INITIAL_WAIT_US;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* wait until the virtual xid is gone */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (!ConditionalVirtualXactLockTableWait(*waitlist))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Report via ps if we have been waiting for more than 500 msec</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* (should that be configurable?)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (update_process_title &amp;&amp; new_status == NULL &amp;&amp;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampDifferenceExceeds(waitStart, GetCurrentTimestamp(),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;500))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const char *old_status;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_status = get_ps_display(&amp;len);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_status = (char *) palloc(len + 8 + 1);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(new_status, old_status, len);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcpy(new_status + len, " waiting");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(new_status, false);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_status[len] = '\0'; /* truncate off " waiting" */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Is it time to kill it? */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (WaitExceedsMaxStandbyDelay())</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid_t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Now find out who to throw out of the balloon.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(VirtualTransactionIdIsValid(*waitlist));</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid = CancelVirtualTransaction(*waitlist, reason);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Wait a little bit for it to die so that we avoid flooding</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* an unresponsive backend when system is heavily loaded.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pid != 0)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_usleep(5000L);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Reset ps display if we changed it */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (new_status)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(new_status, false);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfree(new_status);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_waiting(false);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* The virtual transaction is gone now, wait for the next one */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waitlist++;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void</font></div><div><font size="2"  >ResolveRecoveryConflictWithSnapshot(TransactionId latestRemovedXid, RelFileNode node)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId *backends;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If we get passed InvalidTransactionId then we are a little surprised,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* but it is theoretically possible in normal running. It also happens</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* when replaying already applied WAL records after a standby crash or</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* restart. If latestRemovedXid is invalid then there is no conflict. That</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* rule applies across all record types that suffer from this conflict.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (!TransactionIdIsValid(latestRemovedXid))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; backends = GetConflictingVirtualXIDs(latestRemovedXid,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;node.dbNode);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ResolveRecoveryConflictWithVirtualXIDs(backends,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PROCSIG_RECOVERY_CONFLICT_SNAPSHOT);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void</font></div><div><font size="2"  >ResolveRecoveryConflictWithTablespace(Oid tsid)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId *temp_file_users;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Standby users may be currently using this tablespace for for their</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* temporary files. We only care about current users because</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* temp_tablespace parameter will just ignore tablespaces that no longer</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* exist.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Ask everybody to cancel their queries immediately so we can ensure no</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* temp files remain and we can remove the tablespace. Nuke the entire</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* site from orbit, it's the only way to be sure.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* XXX: We could work out the pids of active backends using this</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* tablespace by examining the temp filenames in the directory. We would</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* then convert the pids into VirtualXIDs before attempting to cancel</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* them.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We don't wait for commit because drop tablespace is non-transactional.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; temp_file_users = GetConflictingVirtualXIDs(InvalidTransactionId,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ResolveRecoveryConflictWithVirtualXIDs(temp_file_users,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PROCSIG_RECOVERY_CONFLICT_TABLESPACE);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void</font></div><div><font size="2"  >ResolveRecoveryConflictWithDatabase(Oid dbid)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We don't do ResolveRecoveryConflictWithVirtualXIDs() here since that</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* only waits for transactions and completely idle sessions would block</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* us. This is rare enough that we do this as simply as possible: no wait,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* just force them off immediately.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* No locking is required here because we already acquired</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* AccessExclusiveLock. Anybody trying to connect while we do this will</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* block during InitPostgres() and then disconnect when they see the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* database has been removed.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; while (CountDBBackends(dbid) &gt; 0)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CancelDBBackends(dbid, PROCSIG_RECOVERY_CONFLICT_DATABASE, true);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Wait awhile for them to die so that we avoid flooding an</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* unresponsive backend when system is heavily loaded.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_usleep(10000);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >static void</font></div><div><font size="2"  >ResolveRecoveryConflictWithLock(Oid dbOid, Oid relOid)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId *backends;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;report_memory_error = false;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lock_acquired = false;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_attempts = 0;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG &nbsp; &nbsp; &nbsp; &nbsp; locktag;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_RELATION(locktag, dbOid, relOid);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If blowing away everybody with conflicting locks doesn't work, after</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* the first two attempts then we just start blowing everybody away until</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* it does work. We do this because its likely that we either have too</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* many locks and we just can't get one at all, or that there are many</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* people crowding for the same table. Recovery must win; the end</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* justifies the means.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; while (!lock_acquired)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (++num_attempts &lt; 3)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backends = GetLockConflicts(&amp;locktag, AccessExclusiveLock);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backends = GetConflictingVirtualXIDs(InvalidTransactionId,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;InvalidOid);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; report_memory_error = true;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResolveRecoveryConflictWithVirtualXIDs(backends,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PROCSIG_RECOVERY_CONFLICT_LOCK);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (LockAcquireExtended(&amp;locktag, AccessExclusiveLock, true, true, false)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; != LOCKACQUIRE_NOT_AVAIL)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock_acquired = true;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* ResolveRecoveryConflictWithBufferPin is called from LockBufferForCleanup()</font></div><div><font size="2"  >&nbsp;* to resolve conflicts with other backends holding buffer pins.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* We either resolve conflicts immediately or set a SIGALRM to wake us at</font></div><div><font size="2"  >&nbsp;* the limit of our patience. The sleep in LockBufferForCleanup() is</font></div><div><font size="2"  >&nbsp;* performed here, for code clarity.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Resolve conflicts by sending a PROCSIG signal to all backends to check if</font></div><div><font size="2"  >&nbsp;* they hold one of the buffer pins that is blocking Startup process. If so,</font></div><div><font size="2"  >&nbsp;* backends will take an appropriate error action, ERROR or FATAL.</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* We also must check for deadlocks. &nbsp;Deadlocks occur because if queries</font></div><div><font size="2"  >&nbsp;* wait on a lock, that must be behind an AccessExclusiveLock, which can only</font></div><div><font size="2"  >&nbsp;* be cleared if the Startup process replays a transaction completion record.</font></div><div><font size="2"  >&nbsp;* If Startup process is also waiting then that is a deadlock. The deadlock</font></div><div><font size="2"  >&nbsp;* can occur if the query is waiting and then the Startup sleeps, or if</font></div><div><font size="2"  >&nbsp;* Startup is sleeping and the query waits on a lock. We protect against</font></div><div><font size="2"  >&nbsp;* only the former sequence here, the latter sequence is checked prior to</font></div><div><font size="2"  >&nbsp;* the query sleeping, in CheckRecoveryConflictDeadlock().</font></div><div><font size="2"  >&nbsp;*</font></div><div><font size="2"  >&nbsp;* Deadlocks are extremely rare, and relatively expensive to check for,</font></div><div><font size="2"  >&nbsp;* so we don't do a deadlock check right away ... only if we have had to wait</font></div><div><font size="2"  >&nbsp;* at least deadlock_timeout. &nbsp;Most of the logic about that is in proc.c.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >void</font></div><div><font size="2"  >ResolveRecoveryConflictWithBufferPin(void)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sig_alarm_enabled = false;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz ltime;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz now;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; Assert(InHotStandby);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ltime = GetStandbyLimitTime();</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; now = GetCurrentTimestamp();</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (!ltime)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We're willing to wait forever for conflicts, so set timeout for</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* deadlock check (only)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (enable_standby_sig_alarm(now, now, true))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sig_alarm_enabled = true;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, "could not set timer for process wakeup");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; else if (now &gt;= ltime)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We're already behind, so clear a path as quickly as possible.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SendRecoveryConflictWithBufferPin(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN);</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Wake up at ltime, and check for deadlocks as well if we will be</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* waiting longer than deadlock_timeout</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (enable_standby_sig_alarm(now, ltime, false))</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sig_alarm_enabled = true;</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, "could not set timer for process wakeup");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /* Wait to be signaled by UnpinBuffer() */</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ProcWaitForSignal();</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (sig_alarm_enabled)</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!disable_standby_sig_alarm())</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, "could not disable timer for process wakeup");</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >void</font></div><div><font size="2"  >SendRecoveryConflictWithBufferPin(ProcSignalReason reason)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; Assert(reason == PROCSIG_RECOVERY_CONFLICT_BUFFERPIN ||</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reason == PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We send signal to all backends to ask them if they are holding the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* buffer pin which is delaying the Startup process. We must not set the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* conflict flag yet, since most backends will be innocent. Let the</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* SIGUSR1 handling in each backend decide their own fate.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; CancelDBBackends(InvalidOid, reason, false);</font></div><div><font size="2"  >}</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >/*</font></div><div><font size="2"  >&nbsp;* In Hot Standby perform early deadlock detection. &nbsp;We abort the lock</font></div><div><font size="2"  >&nbsp;* wait if are about to sleep while holding the buffer pin that Startup</font></div><div><font size="2"  >&nbsp;* process is waiting for. The deadlock occurs because we can only be</font></div><div><font size="2"  >&nbsp;* waiting behind an AccessExclusiveLock, which can only clear when a</font></div><div><font size="2"  >&nbsp;* transaction completion record is replayed, which can only occur when</font></div><div><font size="2"  >&nbsp;* Startup process is not waiting. So if Startup process is waiting we</font></div><div><font size="2"  >&nbsp;* never will clear that lock, so if we wait we cause deadlock. If we</font></div><div><font size="2"  >&nbsp;* are the Startup process then no need to check for deadlocks.</font></div><div><font size="2"  >&nbsp;*/</font></div><div><font size="2"  >void</font></div><div><font size="2"  >CheckRecoveryConflictDeadlock(LWLockId partitionLock)</font></div><div><font size="2"  >{</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; Assert(!InRecovery);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; if (!HoldingBufferPinThatDelaysRecovery())</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; LWLockRelease(partitionLock);</font></div><div><font size="2"  ><br></font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Error message should match ProcessInterrupts() but we avoid calling</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* that because we aren't handling an interrupt at this point. Note that</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* we only cancel the current transaction here, so if we are in a</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* subtransaction and the pin is held by a parent, then the Startup</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* process will continue to wait even though we have avoided deadlock.</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_T_R_DEADLOCK_DETECTED),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("canceling statement due to conflict with recovery"),</font></div><div><font size="2"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errdetail("User transaction caused buffer deadlock with recovery.")));</font></div><div><font size="2"  >}</font></div><p></p></pre></div></div>
	</div>
</div>
</body>
</html>