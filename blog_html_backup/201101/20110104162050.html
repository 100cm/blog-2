<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL HOT STANDBY using Stream replication</h2>
	<h5 id="">2011-01-04 16:20:50&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020110442050808/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">案例解析二、<br>PostgreSQL HOT STANDBY by stream replication 测试:<br>一、准备硬件<br>1. 主节点硬件配置<br>DISK : 146GB*6<br>MEM : 14GB<br>CPU : 2.83GHz*8<br>2. standby节点硬件配置<br>DISK : 146GB*4<br>MEM : 8GB<br>CPU : 2.0GHz*8<br><br>二、准备环境<br>1. 系统<br>Red Hat Enterprise Linux Server release 5.5 (Tikanga) x64<br>2. 时钟同步<br>8 * * * * /usr/sbin/ntpdate asia.pool.ntp.org &amp;&amp; /sbin/hwclock --systohc<br>3. 配置目录<br><pre class="prettyprint"   ><p><font size="2"   >mkdir -p /database/pgdata/tbs1<br>mkdir -p /database/pgdata/tbs2<br>mkdir -p /database/pgdata/tbs3<br>mkdir -p /database/pgdata/tbs4<br>mkdir -p /database/pgdata/tbs5<br>fdisk<br>mkfs.ext3<br>mount /dev/cciss/c0d1p1 /database/pgdata/tbs1<br>mount /dev/cciss/c0d2p1 /database/pgdata/tbs2<br>mount /dev/cciss/c0d3p1 /database/pgdata/tbs3<br>mount /dev/cciss/c0d4p1 /database/pgdata/tbs4<br>mount /dev/cciss/c0d5p1 /database/pgdata/tbs5</font></p></pre>master节点:<br><pre class="prettyprint"   ><p><font size="2"   >[root@db-172-16-3-33 ~]# df -h<br>Filesystem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Size&nbsp; Used Avail Use% Mounted on<br>/dev/cciss/c0d0p1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31G&nbsp; 8.1G&nbsp;&nbsp; 21G&nbsp; 29% /<br>/dev/cciss/c0d0p3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 88G&nbsp; 1.7G&nbsp;&nbsp; 81G&nbsp;&nbsp; 3% /opt<br>tmpfs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.9G&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; 6.9G&nbsp;&nbsp; 0% /dev/shm<br>/dev/cciss/c0d1p1&nbsp;&nbsp;&nbsp;&nbsp; 135G&nbsp;&nbsp; 76M&nbsp; 128G&nbsp;&nbsp; 1% /database/pgdata/tbs1<br>/dev/cciss/c0d2p1&nbsp;&nbsp;&nbsp;&nbsp; 135G&nbsp; 6.1G&nbsp; 122G&nbsp;&nbsp; 5% /database/pgdata/tbs2<br>/dev/cciss/c0d3p1&nbsp;&nbsp;&nbsp;&nbsp; 135G&nbsp; 3.3G&nbsp; 125G&nbsp;&nbsp; 3% /database/pgdata/tbs3<br>/dev/cciss/c0d4p1&nbsp;&nbsp;&nbsp;&nbsp; 135G&nbsp; 5.6G&nbsp; 123G&nbsp;&nbsp; 5% /database/pgdata/tbs4<br>/dev/cciss/c0d5p1&nbsp;&nbsp;&nbsp;&nbsp; 135G&nbsp;&nbsp; 16G&nbsp; 113G&nbsp; 13% /database/pgdata/tbs5</font></p></pre>slave节点:<br><pre class="prettyprint"   ><p><font size="2"   >Filesystem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Size&nbsp; Used Avail Use% Mounted on<br>/dev/sda1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31G&nbsp; 3.5G&nbsp;&nbsp; 26G&nbsp; 13% /<br>/dev/sda3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 94G&nbsp; 386M&nbsp;&nbsp; 89G&nbsp;&nbsp; 1% /opt<br>tmpfs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.9G&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; 3.9G&nbsp;&nbsp; 0% /dev/shm<br>/dev/sdb1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 134G&nbsp;&nbsp; 76M&nbsp; 128G&nbsp;&nbsp; 1% /database/pgdata/tbs1<br>/dev/sdc1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 134G&nbsp; 188M&nbsp; 127G&nbsp;&nbsp; 1% /database/pgdata/tbs2<br>/dev/sdd1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 134G&nbsp; 2.9G&nbsp; 125G&nbsp;&nbsp; 3% /database/pgdata/tbs3<br>172.16.3.33:/database/pgdata/pg_arch<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 135G&nbsp; 5.6G&nbsp; 123G&nbsp;&nbsp; 5% /database/pgdata/pg_arch</font></p></pre>vi /etc/fstab<div><br>4. 在主节点配置nfs,将wal归档目录export出去,<br>(这里没有使用中央日志服务器,有条件的话还是需要一个比较大的日志服务器为好,以便支持更多的slave节点)<br>/database/pgdata/pg_arch 172.16.3.39/32(rw,no_root_squash,sync)<br>&nbsp; slave节点mount这个目录.<br>&nbsp; 确保master节点和slave节点的postgres用户gid uid相同,否则可能有权限的问题.<br>5. 配置内核参数等<br><pre class="prettyprint"   ><p><font size="2"   >kernel.shmmni = 4096<br>kernel.sem = 501000 6412800000 501000 12800<br>fs.file-max = 767246<br>net.ipv4.ip_local_port_range = 1024 65000<br>net.core.rmem_default = 1048576<br>net.core.rmem_max = 1048576<br>net.core.wmem_default = 262144<br>net.core.wmem_max = 262144<br>net.ipv4.tcp_tw_recycle=1 <br>net.ipv4.tcp_max_syn_backlog=4096 <br>net.core.netdev_max_backlog=10000<br>vm.overcommit_memory=0<br>net.ipv4.ip_conntrack_max=655360<br><br>*&nbsp; soft&nbsp;&nbsp;&nbsp; nofile&nbsp; 131072<br>*&nbsp; hard&nbsp;&nbsp;&nbsp; nofile&nbsp; 131072<br>*&nbsp; soft&nbsp;&nbsp;&nbsp; nproc&nbsp;&nbsp; 131072<br>*&nbsp; hard&nbsp;&nbsp;&nbsp; nproc&nbsp;&nbsp; 131072<br>*&nbsp; soft&nbsp;&nbsp;&nbsp; core&nbsp;&nbsp;&nbsp; unlimited<br>*&nbsp; hard&nbsp;&nbsp;&nbsp; core&nbsp;&nbsp;&nbsp; unlimited<br>*&nbsp; soft&nbsp;&nbsp;&nbsp; memlock 50000000<br>*&nbsp; hard&nbsp;&nbsp;&nbsp; memlock 50000000</font></p></pre><br>6. 配置系统服务<br><pre class="prettyprint"   ><p><font size="2"   >chkconfig --level 35 nfs on<br>chkconfig --level 35 portmap pn</font></p></pre><br>7. 配置防火墙<br>vi /etc/sysconfig/iptables</div><div>允许master-slave相互访问nfs, PostgreSQL监听端口<br><br>8. 升级操作系统补丁,驱动等<br><br>三、安装PostgreSQL 9.0.2<br>1. postgres user profile:<br><pre class="prettyprint"   ><p><font size="2"   >export PS1="$USER@`/bin/hostname -s`-&gt; "<br>export PGPORT=1921<br>export PGDATA=/database/pgdata/tbs1/pg_root<br>export PGARCHIVE=/database/pgdata/pg_arch<br><br>export LANG=en_US.utf8<br><br>export PGHOME=/opt/pgsql<br>export LD_LIBRARY_PATH=$PGHOME/lib:/lib64:/usr/lib64:/usr/local/lib64:/lib:/usr/lib:/usr/local/lib<br>export DATE=`date +"%Y%m%d%H%M"`<br>export PATH=$PGHOME/bin:$PATH:.<br>export MANPATH=$PGHOME/share/man:$MANPATH<br>alias rm='rm -i'<br>alias ll='ls -lh'</font></p></pre><br>2. 配置数据库相关目录<br>2.1 pghome<br>&nbsp; /opt/pgsql<br>2.2 pgdata<br>&nbsp; /database/pgdata/tbs1/pg_root<br>2.3 pgarchive<br>&nbsp; /database/pgdata/pg_arch<br><br>3. 初始化数据库<br>initdb -D /database/pgdata/tbs1/pg_root -E UTF8 --locale=C -U postgres -X /database/pgdata/tbs2/pg_xlog -W <br><br>四、配置master节点<br>1. 新建slave用于连接master的数据库超级用户(在v8的版本中建议为每个stream standby新建一个超级用户,在v9中使用一个用户的情况下建议不同的stream standby配置不同的application_name参数值来区分不同的stream standby.)<br>&nbsp;&nbsp; 为了安全的考虑,配置pg_hba.conf,数据库复制的超级用户只允许从使用该用户的stream standby的主机连过来.<br>&nbsp;&nbsp; 连接限制:一个stream standby数据库至少需要一个连接,因为连接有hang住的可能,建议不要配太少了.<br>create role repuser1 SUPERUSER LOGIN CONNECTION LIMIT 20 ENCRYPTED PASSWORD 'repuser1REPUSER1';<br><br>2. pg_hba.conf<br><pre class="prettyprint"   ><p><font size="2"   ># "local" is for Unix domain socket connections only<br>local&nbsp;&nbsp; all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trust<br># IPv4 local connections:<br>host&nbsp;&nbsp;&nbsp; all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 127.0.0.1/32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trust<br># IPv6 local connections:<br># host&nbsp;&nbsp;&nbsp; all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::1/128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trust<br>host replication repuser1 172.16.3.39/32&nbsp; md5</font></p></pre><br>3. postgresql.conf<br><pre class="prettyprint"   ><p><font size="2"   >listen_addresses = '*'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # what IP address(es) to listen on;<br>port = 1921&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # (change requires restart)<br>max_connections = 2000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # (change requires restart)<br>unix_socket_directory = '/database/pgdata/tbs1/pg_root'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # (change requires restart)<br>unix_socket_permissions = 0700&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # begin with 0 to use octal notation<br>password_encryption = on<br>shared_buffers = 2048MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # min 128kB<br>maintenance_work_mem = 2048MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # min 1MB<br>max_stack_depth = 8MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # min 100kB<br>wal_level = hot_standby&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # minimal, archive, or hot_standby<br>synchronous_commit = off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # immediate fsync at commit<br>wal_sync_method = fdatasync&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # the default is the first option <br>wal_buffers = 128000kB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # min 32kB<br>wal_writer_delay = 20ms&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 1-10000 milliseconds<br>checkpoint_segments = 64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # in logfile segments, min 1, 16MB each<br>checkpoint_timeout = 30min&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # range 30s-1h<br>archive_mode = on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # allows archiving to be done<br>archive_command = 'cp %p $PGARCHIVE/%f'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # command to use to archive a logfile segment<br>max_wal_senders = 30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # max number of walsender processes<br>wal_keep_segments = 1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # in logfile segments, 16MB each; 0 disables;因为本例使用的logfile segment单个=64M,所以这里需要至少64*1000=64GB的pg_xlog目录空间,否则可能空间溢出.<br>random_page_cost = 2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # same scale as above<br>effective_cache_size = 12800MB<br>constraint_exclusion = partition&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # on, off, or partition<br>log_destination = 'csvlog'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Valid values are combinations of<br>logging_collector = on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Enable capturing of stderr and csvlog<br>log_connections = on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 调试阶段建议主库和standby都打开log_connections,调试完后建议关闭.<br>log_directory = 'pg_log'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # directory where log files are written,<br>log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log' # log file name pattern,<br>log_truncate_on_rotation = on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If on, an existing log file of the<br>log_rotation_age = 1d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Automatic rotation of logfiles will<br>log_rotation_size = 10MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Automatic rotation of logfiles will <br>log_min_duration_statement = 1000ms&nbsp;&nbsp;&nbsp;&nbsp; # -1 is disabled, 0 logs all statements<br>log_checkpoints = on<br>log_lock_waits = on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # log lock waits &gt;= deadlock_timeout<br>log_statement = 'ddl'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # none, ddl, mod, all<br>track_activity_query_size = 2048&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # (change requires restart)<br>autovacuum = on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Enable autovacuum subprocess?&nbsp; 'on' <br>log_autovacuum_min_duration = 0 # -1 disables, 0 logs all actions and<br>check_function_bodies = on<br>bytea_output = 'escape'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # hex, escape<br>datestyle = 'iso, mdy'<br>lc_messages = 'C'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # locale for system error message<br>lc_monetary = 'C'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # locale for monetary formatting<br>lc_numeric = 'C'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # locale for number formatting<br>lc_time = 'C'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # locale for time formatting<br>default_text_search_config = 'pg_catalog.english'<br>deadlock_timeout = 1s<br>tcp_keepalives_idle = 60</font></p></pre><br>4. 启动主节点.<br><br>五、传输基础文件至slave节点,模拟一个正在运行的数据库生成复制库的操作.<br>1. on the master<br>select pg_start_backup('replication backup');<br>2. on the master<br>scp $PGDATA $SLAVE_IP:$PGDATA<br>3. on the master<br>select pg_stop_backup();<br><br>六、配置slave节点<br>1. on the slave<br><pre class="prettyprint"   ><p><font size="2"   >chown -R postgres:postgres $PGDATA<br>su - postgres<br>cd $PGDATA<br>rm postmaster.pid<br>rm .s.PGSQL.1921.lock<br>rm -rf pg_xlog<br>ln -s /database/pgdata/tbs2/pg_xlog ./pg_xlog</font></p></pre>如果有非默认表空间,需要手工处理pg_tblspc<br><br>2. 配置pg_hba.conf<br>允许需要访问的客户端,<br><br>3. 配置postgresql.conf<br><pre class="prettyprint"   ><p><font size="2"   >listen_addresses = '*'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # what IP address(es) to listen on;<br>port = 1921&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # (change requires restart)<br>max_connections = 2000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # (change requires restart)<br>unix_socket_directory = '/database/pgdata/tbs1/pg_root'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # (change requires restart)<br>unix_socket_permissions = 0700&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # begin with 0 to use octal notation<br>password_encryption = on<br>shared_buffers = 2048MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # min 128kB<br>maintenance_work_mem = 2048MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # min 1MB<br>max_stack_depth = 8MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # min 100kB<br>wal_level = hot_standby&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # minimal, archive, or hot_standby<br>synchronous_commit = off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # immediate fsync at commit<br>wal_sync_method = fdatasync&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # the default is the first option <br>wal_buffers = 128000kB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # min 32kB<br>wal_writer_delay = 20ms&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 1-10000 milliseconds<br>checkpoint_segments = 64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # in logfile segments, min 1, 16MB each<br>checkpoint_timeout = 30min&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # range 30s-1h<br>archive_mode = on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # allows archiving to be done<br>archive_command = 'cp %p $PGARCHIVE/%f'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # command to use to archive a logfile segment<br>max_wal_senders = 30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # max number of walsender processes<br>wal_keep_segments = 1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # in logfile segments, 16MB each; 0 disables;因为本例使用的logfile segment单个=64M,所以这里需要至少64*1000=64GB的pg_xlog目录空间,否则可能空间溢出.<br>random_page_cost = 2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # same scale as above<br>effective_cache_size = 12800MB<br>constraint_exclusion = partition&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # on, off, or partition<br>log_destination = 'csvlog'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Valid values are combinations of<br>logging_collector = on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Enable capturing of stderr and csvlog<br>log_connections = on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 调试阶段建议主库和standby都打开log_connections,调试完后建议关闭.<br>log_directory = 'pg_log'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # directory where log files are written,<br>log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log' # log file name pattern,<br>log_truncate_on_rotation = on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If on, an existing log file of the<br>log_rotation_age = 1d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Automatic rotation of logfiles will<br>log_rotation_size = 10MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Automatic rotation of logfiles will <br>log_min_duration_statement = 1000ms&nbsp;&nbsp;&nbsp;&nbsp; # -1 is disabled, 0 logs all statements<br>log_checkpoints = on<br>log_lock_waits = on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # log lock waits &gt;= deadlock_timeout<br>log_statement = 'ddl'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # none, ddl, mod, all<br>track_activity_query_size = 2048&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # (change requires restart)<br>autovacuum = on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Enable autovacuum subprocess?&nbsp; 'on' <br>log_autovacuum_min_duration = 0 # -1 disables, 0 logs all actions and<br>check_function_bodies = on<br>bytea_output = 'escape'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # hex, escape<br>datestyle = 'iso, mdy'<br>lc_messages = 'C'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # locale for system error message<br>lc_monetary = 'C'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # locale for monetary formatting<br>lc_numeric = 'C'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # locale for number formatting<br>lc_time = 'C'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # locale for time formatting<br>default_text_search_config = 'pg_catalog.english'<br>deadlock_timeout = 1s<br>hot_standby = off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 这个参数在初始化slave的时候关闭是比较明智的选择,在初始同步完成后在开启<br>tcp_keepalives_idle = 60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # </font></p></pre><br>3. 配置recovery.conf<br><pre class="prettyprint"   ><p><font size="2"   >cp $PGHOME/share/recovery.conf.sample $PGDATA/<br>cd $PGDATA<br>mv recovery.conf.sample recovery.conf<br>vi recovery.conf<br>restore_command = 'cp $PGARCHIVE/%f %p'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # e.g. 'cp /mnt/server/archivedir/%f %p'<br>archive_cleanup_command = 'pg_archivecleanup $PGARCHIVE %r'<br>standby_mode = 'on'<br>trigger_file = '/database/pgdata/tbs1/pg_root/postgresql.trigger.1921'<br>primary_conninfo = 'host=172.16.3.33 port=1921 user=repuser1 keepalives_idle=60'&nbsp; # application_name也可以加在这里</font><br></p></pre>4. 配置~/.pgpass 或$PGPASSFILE (PGPASSFILE specifies the name of the password file to use for lookups. If not set, it defaults to ~/.pgpass)<br>格式:hostname:port:database:username:password<br>172.16.3.33:1921:replication:repuser1:repuser1REPUSER1<br><br>chmod 400 .pgpass<br><br>5. 启动slave节点<br><br>启动完后,可以通过top看到slave节点在拼命的恢复pg_start_backup以来的所有wal.<br><br>查看slave节点日志:<br><pre class="prettyprint"   ><p><font size="2"   >2011-01-04 14:51:51.363 CST,,,25950,,4d22c387.655e,1,,2011-01-04 14:51:51 CST,,0,LOG,00000,"database system was shut down in recovery at 2011-01-04 14:51:26 CST",,,,,,,,,""<br>2011-01-04 14:51:51.363 CST,,,25950,,4d22c387.655e,2,,2011-01-04 14:51:51 CST,,0,LOG,00000,"entering standby mode",,,,,,,,,""<br>2011-01-04 14:51:51.442 CST,,,25950,,4d22c387.655e,3,,2011-01-04 14:51:51 CST,,0,LOG,00000,"restored log file ""00000001000000020000003E"" from archive",,,,,,,,,""<br>2011-01-04 14:51:51.443 CST,,,25950,,4d22c387.655e,4,,2011-01-04 14:51:51 CST,,0,LOG,00000,"redo starts at 2/F8000020",,,,,,,,,""<br>2011-01-04 14:51:51.443 CST,,,25950,,4d22c387.655e,5,,2011-01-04 14:51:51 CST,,0,LOG,00000,"consistent recovery state reached at 2/FC000000",,,,,,,,,""<br>2011-01-04 14:51:51.480 CST,,,25954,,4d22c387.6562,1,,2011-01-04 14:51:51 CST,,0,LOG,00000,"streaming replication successfully connected to primary",,,,,,,,,""</font></p></pre><br>查看主节点进程:<br>postgres: wal sender process repuser1 172.16.3.39(18716) startup<br><br>恢复完后修改hot_standby = on,重启slave节点<br><br>七、测试<br>1. (on master)新建用户<br><pre class="prettyprint"   ><p><font size="2"   >create role digoal nosuperuser login encrypted password 'digoal';<br>&nbsp;&nbsp; (on slave)查看,比log shipping模式快很多,在master建立好用户后slave马上就可以看到已经复制过来了.<br>postgres=# \du<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List of roles<br>&nbsp;Role name |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Attributes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Member of <br>-----------+-----------------------------------+-----------<br>&nbsp;digoal&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | {}<br>&nbsp;postgres&nbsp; | Superuser, Create role, Create DB | {}<br>&nbsp;repuser1&nbsp; | Superuser&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +| {}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 20 connections&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | </font></p></pre><br>2. 新建表空间<br><pre class="prettyprint"   ><p><font size="2"   >on master<br>su - postgres<br>mkdir /database/pgdata/tbs3/tbs_digoal<br>on slave<br>su - postgres<br>mkdir /database/pgdata/tbs3/tbs_digoal<br>on master<br>create tablespace tbs_digoal owner digoal location '/database/pgdata/tbs3/tbs_digoal';<br>on slave (查看)<br>postgres=# \db<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List of tablespaces<br>&nbsp;&nbsp;&nbsp; Name&nbsp;&nbsp;&nbsp; |&nbsp; Owner&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Location&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>------------+----------+----------------------------------<br>&nbsp;pg_default | postgres | <br>&nbsp;pg_global&nbsp; | postgres | <br>&nbsp;tbs_digoal | digoal&nbsp;&nbsp; | /database/pgdata/tbs3/tbs_digoal<br>(3 rows)</font></p></pre><br>3. (on master)新建数据库<br><pre class="prettyprint"   ><p><font size="2"   >create database digoal with owner digoal template template0 encoding 'UTF8' tablespace tbs_digoal;<br>&nbsp;&nbsp; (on slave)查看<br>postgres=# \l<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List of databases<br>&nbsp;&nbsp; Name&nbsp;&nbsp;&nbsp; |&nbsp; Owner&nbsp;&nbsp; | Encoding | Collation | Ctype |&nbsp;&nbsp; Access privileges&nbsp; &nbsp;<br>-----------+----------+----------+-----------+-------+-----------------------<br>&nbsp;digoal&nbsp;&nbsp;&nbsp; | digoal&nbsp;&nbsp; | UTF8&nbsp;&nbsp;&nbsp;&nbsp; | C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | C&nbsp;&nbsp;&nbsp;&nbsp; | <br>&nbsp;postgres&nbsp; | postgres | UTF8&nbsp;&nbsp;&nbsp;&nbsp; | C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | C&nbsp;&nbsp;&nbsp;&nbsp; | <br>&nbsp;template0 | postgres | UTF8&nbsp;&nbsp;&nbsp;&nbsp; | C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | C&nbsp;&nbsp;&nbsp;&nbsp; | =c/postgres&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | postgres=CTc/postgres<br>&nbsp;template1 | postgres | UTF8&nbsp;&nbsp;&nbsp;&nbsp; | C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | C&nbsp;&nbsp;&nbsp;&nbsp; | =c/postgres&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | postgres=CTc/postgres<br>(4 rows)</font></p></pre><br>4. (on master)新建schema<br><pre class="prettyprint"   ><p><font size="2"   >\c digoal digoal<br>create schema digoal authorization digoal;<br>&nbsp;&nbsp; (on slave)查看<br>postgres=# \c digoal digoal<br>You are now connected to database "digoal" as user "digoal".<br>digoal=&gt; \dn<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List of schemas<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; Owner&nbsp; &nbsp;<br>--------------------+----------<br>&nbsp;digoal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | digoal<br>&nbsp;information_schema | postgres<br>&nbsp;pg_catalog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | postgres<br>&nbsp;pg_toast&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | postgres<br>&nbsp;pg_toast_temp_1&nbsp;&nbsp;&nbsp; | postgres<br>&nbsp;public&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | postgres<br>(6 rows)</font></p></pre><br>5. (on master)新建表<br><pre class="prettyprint"   ><p><font size="2"   >\c digoal digoal<br>create table tbl_users (id int8 , nick varchar(32));<br>&nbsp;&nbsp; (on slave)查看<br>digoal=&gt; \c digoal digoal<br>You are now connected to database "digoal".<br>digoal=&gt; \d tbl_users <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table "digoal.tbl_users"<br>&nbsp;Column |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Modifiers <br>--------+-----------------------+-----------<br>&nbsp;id&nbsp;&nbsp;&nbsp;&nbsp; | bigint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | <br>&nbsp;nick&nbsp;&nbsp; | character varying(32) | </font></p></pre><br>6. (on master)插入测试数据<br>测试脚本,开50个进程后台插入.<br><pre class="prettyprint"   ><p><font size="2"   >#!/bin/bash<br>for ((i=0;i&lt;50;i++))<br>do<br>psql -h 127.0.0.1 digoal digoal -c "insert into tbl_users select generate_series(1,1000000),'digoal'" &amp;<br>done</font></p></pre><br>查看主节点,仅仅有一个sender进程在发送数据,一个standby对应一个sender<br><pre class="prettyprint"   ><p><font size="2"   >[root@db-172-16-3-33 ~]# ps -ewf|grep sender<br>postgres 20921 20622&nbsp; 0 14:56 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:00:02 postgres: wal sender process repuser1 172.16.3.39(18716) streaming 3/70000000<br>[root@db-172-16-3-33 ~]# netstat -anp|grep 172.16.3.39<br>tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 172.16.3.33:1921&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 172.16.3.39:18716&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESTABLISHED 20921/EF5BDEC8 </font></p></pre><br>查看standby节点,<br><pre class="prettyprint"   ><p><font size="2"   >top<br>26154 postgres&nbsp; 25&nbsp;&nbsp; 0 2389m 1.0g 1.0g R 100.2 13.3&nbsp;&nbsp; 0:51.64 postgres: startup process&nbsp;&nbsp; recovering 00000001000000030000001D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>26159 postgres&nbsp; 15&nbsp;&nbsp; 0 2401m 6052 1652 S 12.9&nbsp; 0.1&nbsp;&nbsp; 0:06.28 postgres: wal receiver process&nbsp;&nbsp; streaming 3/80000000<br>[root@db-172-16-3-39 ~]# netstat -anp|grep 172.16.3.33<br>tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 172.16.3.39:18716&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 172.16.3.33:1921&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESTABLISHED 26159/90940000 </font></p></pre><br>很快,standby和master最终数据一致.<br><pre class="prettyprint"   ><p><font size="2"   >digoal=&gt; select count(*) from tbl_users ;<br>&nbsp; count&nbsp; &nbsp;<br>----------<br>&nbsp;50000000<br>(1 row)</font></p></pre><br>7. (on master)使用DDL测试冲突<br><pre class="prettyprint"   ><p><font size="2"   >on master<br>alter table tbl_users add column first_name varchar(32) default 'zhou';<br>alter table tbl_users add column last_name varchar(32) default 'digoal';</font></p></pre><br>on slave 在slave恢复期间,在slave节点执行 select count(*) from tbl_users;发生等待事件.<br><pre class="prettyprint"   ><p><font size="2"   >26232 postgres&nbsp; 18&nbsp;&nbsp; 0 2392m 2.0g 2.0g S&nbsp; 0.0 26.3&nbsp;&nbsp; 0:09.78 postgres: digoal digoal 127.0.0.1(39324) SELECT waiting</font></p></pre><br>on slave $PGDATA/pg_log中查看最近一个日志文件,<br><pre class="prettyprint"   ><p><font size="2"   >2011-01-04 15:17:43.268 CST,"digoal","digoal",26232,"127.0.0.1:39324",4d22c709.6678,4,"SELECT waiting",2011-01-04 15:06:49 CST,2/19,0,LOG,00000,"process 26232 still waiting for AccessShareLock on relation 16404 of database 16402 after 1000.302 ms",,,,,,"select count(*) from tbl_users;",22,,"psql"</font></p></pre><br>主节点执行完后,slave节点的waiting很快消失,不会像log shipping模式可能出现继续等待含有SQL结束的WAL的情况.<br><br>8. (on master)测试checkpoint<br>在PostgreSQL中发生checkpoint后,在此之前的WAL在做数据库恢复时就用不到了,因为确保数据都写入数据文件了.<br>pg_archivecleanup也是根据checkpoint来判断和删除不需要的WAL的.<br><br>9. (on slave)测试cleanarchive<br>在做checkpoint前,去看$PGARCHIVE目录,已经被apply的文件还存在,并没有被pg_archivecleanup命令清除掉,原因就是这些文件是最近一次checkpoint以来的WAL文件,在数据库恢复时是需要用到的.<br>如果你手工执行pg_archivecleanup $PGARCHIVE 000000010000000200000031 (假设000000010000000200000031这个是在$PGARCHIVE中的一个WAL的文件名)<br>这条命令将删除000000010000000200000031以前生成的所有WAL文件,一定要小心操作,万一不小心把最近一次CHECKPOINT以来的WAL删除了,<br>补救的方法是赶紧到master上做一次checkpoint,让slave知道这次checkpoint,否则的话下次slave启动还会读到000000010000000200000031这个文件以前的文件,那时候就只能找到这些文件或重建slave了.<br><br>10. (on slave)测试active slave<br>激活SLAVE很简单,了解到已经apply了最新的WAL后,执行以下<br>su - postgres<br>touch /database/pgdata/tbs1/pg_root/postgresql.trigger.1921<br>数据库会触发激活的动作,激活后/database/pgdata/tbs1/pg_root/postgresql.trigger.1921这个文件会自动删掉,并且recovery.conf被重命名为recovery.done.<br>激活后的slave不可逆转为slave了.需要重建.<br><br>11. (on slave)测试write操作<br>postgres=# create table tbl_test (id int);<br>ERROR:&nbsp; cannot execute CREATE TABLE in a read-only transaction<br><br>12. 监控<br><pre class="prettyprint"   ><p><font size="2"   >pg_current_xlog_insert_location<br>pg_current_xlog_location<br>pg_last_xlog_receive_location<br>pg_last_xlog_replay_location<br>top<br>CREATE OR REPLACE VIEW pg_stat_replication AS<br>&nbsp;&nbsp;&nbsp; SELECT<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.procpid,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.usesysid,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; U.rolname AS usename,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.application_name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.client_addr,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.client_port,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S.backend_start<br>&nbsp;&nbsp;&nbsp; FROM pg_stat_get_activity(NULL) AS S, pg_authid U<br>&nbsp;&nbsp;&nbsp; WHERE S.usesysid = U.oid AND S.datid = 0;</font></p></pre><br>13. 优化<br>1. Both the WALSender and WALReceiver will work continuously on any outstanding data to be <br>replicated until the queue is empty. If there is a quiet period, then the WALReceiver will sleep <br>for 100ms at a time, and the WALSender will sleep for wal_sender_delay. Typically, the <br>value of wal_sender_delay need not be altered, because it only affects behavior during <br>momentary quiet periods. The default value is a good balance between effciency and data <br>protection. If the Master and Standby are connected by a low bandwidth network, and the <br>write rate on the Master is high, you may wish to lower this value to perhaps 20ms or 50ms. <br>Reducing this value will reduce the amount of data loss if the Master becomes permanently <br>unavailable, though will also marginally increase the cost of streaming the transaction log <br>data to the Standbys.<br><br>2. If the connection drops between Master and Standby, it will take some time for that to be <br>noticed across an indirect network. To ensure that a dropped connection is noticed as soon &nbsp;<br>as possible, you may wish to adjust the keepalive settings.<br>If you want a Standby to notice that the connection to the Master has dropped, you need &nbsp;<br>to set the keepalives in the primary_conninfo in the recovery.conf on the Standby <br>as follows:<br>primary_conninfo = '….keepalives_idle= 60 …'<br>If you want the Master to notice that a streaming Standby connection has dropped, you can <br>set the keepalive parameters in postgresql.conf on the Master, such as:<br>tcp_keepalives_idle = 60&nbsp;&nbsp; # time before we send keepalives<br>That setting will then apply to all connections from users and replication. If you want to be very <br>specifc, and just set that for replication, you must supply this as an option to be passed to the <br>Master, which is specifed like the following:<br>primary_conninfo = '….options="-c tcp_keepalives_idle= 60" …'<br>All of the preceding examples set the length of time the connection will be idle before we start <br>sending keepalives to be 60 seconds. The default is two hours, and is not recommended. <br>There are multiple keepalive parameters we can set; I have avoided showing those here <br>for clarity. A related option is connection_timeout. Remember, you can hide all of this <br>complexity in a connection service fle, so that primary_conninfo only refers to a single <br>service name, as described in the First Steps chapter.<br><br>3. One thing that is a possibility is to set archive_command only until the end of the catch <br>up period. After that you can reset it to the dummy value ("cd") and then continue just with <br>streaming replication. Data is only transferred from the Master to the Standby once that data <br>has been written (or more precisely, fsynced) to disk. So setting synchronous_commit = <br>off will not improve the replication delay, even if that improves performance on the Master. <br>Once WAL data is received by the Standby, the WAL data is fsynced to disk on the Standby to <br>ensure that it is not lost if the Standby system restarts.<br><br>4. For streaming replication, the Master keeps a number of fles that is at least wal_keep_<br>segments. If the Standby database server has been down for long enough, the Master will have <br>moved on and will no longer have the data for the last point of transfer. If that should occur, then <br>the Standby needs to be re-confgured using the same procedure with which we started.<br><br>5. You may also wish to increase max_wal_senders, so that it will be possible to reconnect <br>even before a dropped connection is noted; this allows a manual restart to re-establish <br>connections more easily. If you do this, then also increase the connection limit for the <br>replication user.<br>Data transfer may stop because the connection drops or the Standby server or the Standby <br>system is shutdown. If replication data transfer stops for any reason, it will attempt to restart <br>from the point of last transfer.<br><br>14. 注意事项<br>1. 清除归档时需要考虑到master-slave是一对多的情况,使用一对多的PGARCHIVE或者是全局的pg_archivecleanup<br><br>八、附pgctl.sh脚本<br><pre class="prettyprint"   ><p><font size="2"   >#!/bin/bash<br><br># environment.<br># Get the aliases and functions<br>if [ -f ~/.bashrc ]; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . ~/.bashrc<br>fi<br><br># User specific environment and startup programs<br><br>export PGHOME=/opt/pgsql<br>export PATH=$PGHOME/bin:$PATH<br>export PGDATA=/database/pgdata/tbs1/pg_root<br>export PGPORT=1921<br>export LANG='en_US.utf8'<br>export LD_LIBRARY_PATH=$PGHOME/lib:/lib64:/usr/lib64:/usr/local/lib64:/lib:/usr/lib:/usr/local/lib<br><br>RETVAL=1<br><br>start() {<br>su - postgres -c "/usr/bin/nohup $PGHOME/bin/postgres -D $PGDATA -p $PGPORT &gt;/dev/null 2&gt;&gt;$PGDATA/pg_log/start_err.log&nbsp; &lt;/dev/null &amp;"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETVAL=$?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $RETVAL<br>}<br><br>stop() {<br>su - postgres -c "$PGHOME/bin/pg_ctl stop -D $PGDATA -m fast"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETVAL=$?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $RETVAL<br>}<br><br>reload() {<br>su - postgres -c "$PGHOME/bin/pg_ctl reload -D $PGDATA"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETVAL=$?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $RETVAL<br>}<br><br># See how we were called.<br>case "$1" in<br>&nbsp; start)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;<br>&nbsp; stop)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;<br>&nbsp; restart)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;<br>&nbsp; reload)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reload<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;<br>&nbsp; *)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo $"Usage: $prog {start|stop|restart|reload}"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit 2<br>esac<br><br>exit $RETVAL<br># Auth Digoal.Zhou<br># Corp. Sky-Mobi</font></p></pre><br></div></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">bingbhu - 2011-05-15 23:28:05</h5>
				<div>su - postgres -c "/usr/bin/nohup $PGHOME/bin/postgres -D $PGDATA -p $PGPORT &gt;/dev/null 2&gt;&gt;/var/applog/pg_log/start_err.log&nbsp; &lt;/dev/null &amp;"<BR>启动脚本有问题</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 bingbhu - 2011-05-15 23:28:05</h5>
				<div style="width:600px;">不知道哪里有问题，请大侠指正。</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">bingbhu 回复 德哥@Digoal - 2011-05-15 23:28:05</h5>
				<div style="width:600px;"><P>估计是我使用debian 6的问题;也拜读您新的文档,有个疑问:如果master当了能否做到slave自动接管IP及数据库服务?</P></div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 bingbhu - 2011-05-15 23:28:05</h5>
				<div style="width:600px;">HI,这个可以自由发挥.</div>
			</div>
	</div>
</div>
</body>
</html>