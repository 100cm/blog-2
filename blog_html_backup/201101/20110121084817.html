<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">MySQL TOO BAD row's Range Lock Compare with PostgreSQL and Oracle</h2>
	<h5 id="">2011-01-21 8:48:17&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201102184120813/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><br>MySQL的InnoDB引擎，当UPDATE一个范围的数据时，会锁住比预期更多的ROW，而Oracle和PostgreSQL没有这种现象.<br>来自《High Performance MySQL》一书。<br>测试版本:<br>MySQL 5.5.10<br>PostgreSQL 9.0.2<br>Oracle 10.2.0.4<br>举例如下:<br>1. MySQL (有索引的情况)<br>Session One:<br>mysql&gt; create table tbl_user (id int,firstname varchar(32),lastname varchar(32),corp varchar(32),primary key (id)) engine=innodb;<br>Query OK, 0 rows affected (0.08 sec)<br>mysql&gt; begin;<br>mysql&gt; insert into tbl_user values(1,'zhou','digoal','sky-mobi');<br>mysql&gt; insert into tbl_user values(2,'zhou','digoal','sky-mobi');<br>mysql&gt; insert into tbl_user values(3,'zhou','digoal','sky-mobi');<br>mysql&gt; insert into tbl_user values(4,'zhou','digoal','sky-mobi');<br>mysql&gt; insert into tbl_user values(5,'zhou','digoal','sky-mobi');<br>mysql&gt; insert into tbl_user values(6,'zhou','digoal','sky-mobi');<br>mysql&gt; insert into tbl_user values(7,'zhou','digoal','sky-mobi');<br>mysql&gt; insert into tbl_user values(8,'zhou','digoal','sky-mobi');<br>mysql&gt; insert into tbl_user values(9,'zhou','digoal','sky-mobi');<br>mysql&gt; insert into tbl_user values(10,'zhou','digoal','sky-mobi');<br>mysql&gt; commit;<br># 测试range scan in INDEX<br># 从结果上看，这个session应该只对id=2,3,4的三行持锁，实际上不是<br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; select * from tbl_user where id&lt;5 and id&lt;&gt;1 for update;<br>+----+-----------+----------+----------+<br>| id | firstname | lastname | corp&nbsp;&nbsp;&nbsp;&nbsp; |<br>+----+-----------+----------+----------+<br>|&nbsp; 2 | zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | digoal&nbsp;&nbsp; | sky-mobi |<br>|&nbsp; 3 | zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | digoal&nbsp;&nbsp; | sky-mobi |<br>|&nbsp; 4 | zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | digoal&nbsp;&nbsp; | sky-mobi |<br>+----+-----------+----------+----------+<br>3 rows in set (0.00 sec)<br># 打开另一个SESSION来看看情况如何<br>Session TWO : <br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; update tbl_user set corp='skymobi' where id=1;<br>Ctrl-C -- sending "KILL QUERY 4" to server ...<br>Ctrl-C -- query aborted.<br>ERROR 1317 (70100): Query execution was interrupted<br># id=1的记录被锁<br>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; update tbl_user set corp='skymobi' where id=5;<br>Ctrl-C -- sending "KILL QUERY 4" to server ...<br>Ctrl-C -- query aborted.<br>ERROR 1317 (70100): Query execution was interrupted<br># id=5的记录被锁<br>mysql&gt; <br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; update tbl_user set corp='skymobi' where id=10;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1&nbsp; Changed: 1&nbsp; Warnings: 0<br><br>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.02 sec)<br><br>mysql&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; update tbl_user set corp='skymobi' where id=6;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1&nbsp; Changed: 1&nbsp; Warnings: 0<br><br>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.02 sec)<br># 比预期的多锁了两行id=1,5<br><br># MySQL没有索引的情况，锁全表<br>Session One : <br>mysql&gt; create table tbl_user (id int,firstname varchar(32),lastname varchar(32),corp varchar(32)) engine=innodb;<br>mysql&gt; select * from tbl_user where id&lt;5 and id&lt;&gt;1 for update;<br>+------+-----------+----------+----------+<br>| id&nbsp;&nbsp; | firstname | lastname | corp&nbsp;&nbsp;&nbsp;&nbsp; |<br>+------+-----------+----------+----------+<br>|&nbsp;&nbsp;&nbsp; 2 | zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | digoal&nbsp;&nbsp; | sky-mobi |<br>|&nbsp;&nbsp;&nbsp; 3 | zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | digoal&nbsp;&nbsp; | sky-mobi |<br>|&nbsp;&nbsp;&nbsp; 4 | zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | digoal&nbsp;&nbsp; | sky-mobi |<br>+------+-----------+----------+----------+<br>3 rows in set (0.00 sec)<br><br>Session Two : <br><br>mysql&gt; update tbl_user set corp='skymobi' where id=5;<br>Ctrl-C -- sending "KILL QUERY 4" to server ...<br>Ctrl-C -- query aborted.<br>ERROR 1317 (70100): Query execution was interrupted<br>mysql&gt; <br>mysql&gt; update tbl_user set corp='skymobi' where id=6;<br>Ctrl-C -- sending "KILL QUERY 4" to server ...<br>Ctrl-C -- query aborted.<br>ERROR 1317 (70100): Query execution was interrupted<br>mysql&gt; update tbl_user set corp='skymobi' where id=1;<br>Ctrl-C -- sending "KILL QUERY 4" to server ...<br>Ctrl-C -- query aborted.<br>^[[AERROR 1317 (70100): Query execution was interrupted<br><br>2. PostgreSQL同样的测试，不存在多锁的情况<br>Session One : <br>digoal=&gt; create table tbl_user (id serial,firstname varchar(32),lastname varchar(32),corp varchar(32),primary key (id));<br>NOTICE:&nbsp; CREATE TABLE will create implicit sequence "tbl_user_id_seq" for serial column "tbl_user.id"<br>NOTICE:&nbsp; CREATE TABLE / PRIMARY KEY will create implicit index "tbl_user_pkey" for table "tbl_user"<br>CREATE TABLE<br>digoal=&gt; insert into tbl_user select generate_series(1,1000),'zhou','digoal','sky-mobi';<br>INSERT 0 1000<br>digoal=&gt; begin;<br>BEGIN<br>digoal=&gt; select * from tbl_user where id&lt;5 and id&lt;&gt;1 for update;<br>&nbsp;id | firstname | lastname |&nbsp;&nbsp; corp&nbsp;&nbsp; <br>----+-----------+----------+----------<br>&nbsp; 2 | zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | digoal&nbsp;&nbsp; | sky-mobi<br>&nbsp; 3 | zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | digoal&nbsp;&nbsp; | sky-mobi<br>&nbsp; 4 | zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | digoal&nbsp;&nbsp; | sky-mobi<br>(3 rows)<br><br>Session Two : <br>digoal=&gt; begin;<br>BEGIN<br>digoal=&gt; update tbl_user set corp='skymobi' where id=2;<br>Cancel request sent<br>ERROR:&nbsp; canceling statement due to user request<br>digoal=&gt; rollback;<br>ROLLBACK<br>digoal=&gt; begin;<br>BEGIN<br>digoal=&gt; update tbl_user set corp='skymobi' where id=1;<br>UPDATE 1<br>digoal=&gt; rollback;<br>ROLLBACK<br>digoal=&gt; begin;<br>BEGIN<br>digoal=&gt; update tbl_user set corp='skymobi' where id=5;<br>UPDATE 1<br>digoal=&gt; rollback;<br>ROLLBACK<br>digoal=&gt; <br><br>PostgreSQL无索引测试，结果和有索引一致<br>digoal=&gt; create table tbl_user (id serial,firstname varchar(32),lastname varchar(32),corp varchar(32));<br>NOTICE:&nbsp; CREATE TABLE will create implicit sequence "tbl_user_id_seq" for serial column "tbl_user.id"<br>CREATE TABLE<br>digoal=&gt; insert into tbl_user select generate_series(1,1000),'zhou','digoal','sky-mobi';<br>INSERT 0 1000<br>digoal=&gt; begin;<br>BEGIN<br>digoal=&gt; select * from tbl_user where id&lt;5 and id&lt;&gt;1 for update;<br>&nbsp;id | firstname | lastname |&nbsp;&nbsp; corp&nbsp;&nbsp; <br>----+-----------+----------+----------<br>&nbsp; 2 | zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | digoal&nbsp;&nbsp; | sky-mobi<br>&nbsp; 3 | zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | digoal&nbsp;&nbsp; | sky-mobi<br>&nbsp; 4 | zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | digoal&nbsp;&nbsp; | sky-mobi<br>(3 rows)<br><br>Session Two : <br>digoal=&gt; begin;<br>BEGIN<br>digoal=&gt; update tbl_user set corp='skymobi' where id=5;<br>UPDATE 1<br>digoal=&gt; update tbl_user set corp='skymobi' where id=1;<br>UPDATE 1<br>digoal=&gt; update tbl_user set corp='skymobi' where id=2;<br>Cancel request sent<br>ERROR:&nbsp; canceling statement due to user request<br>digoal=&gt; rollback;<br>ROLLBACK<br><br>3. Oracle 同样的测试，不存在多锁的情况<br>Session One : <br>SQL&gt; create table tbl_user (id int,firstname varchar2(32),lastname varchar2(32),corp varchar2(32) ,primary key (id));<br><br>Table created.<br><br>SQL&gt; insert into tbl_user select rownum,'zhou','digoal','sky-mobi' from dual connect by level &lt;=1000;<br><br>1000 rows created.<br><br>SQL&gt; commit;<br><br>Commit complete.<br><br>SQL&gt; select * from tbl_user where id&lt;5 and id&lt;&gt;1 for update;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID FIRSTNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LASTNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CORP<br>---------- -------------------------------- -------------------------------- --------------------------------<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digoal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sky-mobi<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digoal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sky-mobi<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digoal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sky-mobi<br><br>Session Two : <br>SQL&gt; update tbl_user set corp='skymobi' where id=1;<br><br>1 row updated.<br><br>SQL&gt; rollback;<br><br>Rollback complete.<br><br>SQL&gt; update tbl_user set corp='skymobi' where id=2;<br>update tbl_user set corp='skymobi' where id=2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br>ERROR at line 1:<br>ORA-01013: user requested cancel of current operation<br><br><br><br>SQL&gt; update tbl_user set corp='skymobi' where id=5;<br><br>1 row updated.<br><br>SQL&gt; rollback;<br><br>Rollback complete.<br><br># Oracle无索引和有索引结果一致<br>Session One : <br>SQL&gt; create table tbl_user (id int,firstname varchar2(32),lastname varchar2(32),corp varchar2(32));<br><br>Table created.<br><br>SQL&gt; insert into tbl_user select rownum,'zhou','digoal','sky-mobi' from dual connect by level &lt;=1000;<br><br>1000 rows created.<br><br>SQL&gt; commit;<br><br>Commit complete.<br><br>SQL&gt; select * from tbl_user where id&lt;5 and id&lt;&gt;1 for update;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID FIRSTNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LASTNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CORP<br>---------- -------------------------------- -------------------------------- --------------------------------<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digoal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sky-mobi<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digoal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sky-mobi<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 zhou&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digoal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sky-mobi<br><br>Session Two : <br>SQL&gt; update tbl_user set corp='skymobi' where id=5;<br><br>1 row updated.<br><br>SQL&gt; update tbl_user set corp='skymobi' where id=1;<br><br>1 row updated.<br><br>SQL&gt; update tbl_user set corp='skymobi' where id=2;<br>update tbl_user set corp='skymobi' where id=2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br>ERROR at line 1:<br>ORA-01013: user requested cancel of current operation<br><br><br>小结 : <br>1. MySQL InnoDB引擎表按照范围来获取锁时，会锁住比预期更多的ROWS(使用索引略好，不使用索引的话就是全表)。<br>2. PostgreSQL和Oracle不存在这种情况.<br>越来越觉得MySQL High不起来了<br><div>3. 后续, Mysql 锁范围放大的原因.&nbsp;</div><div>PostgreSQL repeatable read, serializable和read committed 隔离级别都不会造成这种锁范围放大的情况.</div><div>原因是PostgreSQL 的多版本并发控制机制利用了tuple infomask标记, 新老版本并存, committed 状态, 事务snapshot状态等信息.</div><div>并发能力相当高.</div><div><div style="line-height: 22px;"   >而mysql 锁范围放大和它的锁机制有关:</div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   >主要原因是mysql利用了索引来加锁. 除了read uncommitted, 其他隔离级别都会造成锁放大.&nbsp;</div><div style="line-height: 22px;"   >默认隔离级别为repeatable read;&nbsp;</div></div></div><div><a rel="nofollow" href="http://dev.mysql.com/doc/refman/5.6/en/set-transaction.html#isolevel_repeatable-read"   >http://dev.mysql.com/doc/refman/5.6/en/set-transaction.html#isolevel_repeatable-read</a></div><div><a rel="nofollow" href="http://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_gap"   >http://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_gap</a></div><div><div>repeatable read:</div><div><pre class="prettyprint"   ><p><font size="2"   >For locking reads (SELECT with FOR UPDATE or LOCK IN SHARE MODE), UPDATE, and DELETE statements, locking depends on whether the statement uses a unique index with a unique search condition, or a range-type search condition. For a unique index with a unique search condition, InnoDB locks only the index record found, not the gap before it. For other search conditions, InnoDB locks the index range scanned, using gap locks or next-key locks to block insertions by other sessions into the gaps covered by the range.</font></p></pre></div><div>read committed:</div><div><pre class="prettyprint"   ><p><font size="2"   >For locking reads (SELECT with FOR UPDATE or LOCK IN SHARE MODE), UPDATE statements, and DELETE statements, InnoDB locks only index records, not the gaps before them, and thus permits the free insertion of new records next to locked records.</font></p></pre></div></div></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">aca_applet - 2013-05-25 11:06:35</h5>
				<div>和mysql默认隔离级别有关系。。</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 aca_applet - 2013-05-25 11:06:35</h5>
				<div style="width:600px;">mysql什么隔离级别会导致锁范围放大?</div>
			</div>
			<div style="padding-left:40px;">
				<h5 id="">德哥@Digoal 回复 aca_applet - 2013-05-25 11:06:35</h5>
				<div style="width:600px;">感谢, 刚才测试了一下, 只有read uncommitted不会造成锁放大.<div>http://dev.mysql.com/doc/refman/5.6/en/set-transaction.html#isolevel_repeatable-read</div><div>主要原因是mysql利用了索引来加锁.&nbsp;</div><div>默认隔离级别为repeatable read;</div><div>repeatable read:<span style=""  >For a unique index with a unique search condition,&nbsp;</span>InnoDB<span style=""  >&nbsp;locks only the index record found, not the</span>gap<span style=""  >&nbsp;before it. For other search conditions,&nbsp;</span>InnoDB<span style=""  >&nbsp;locks the index range scanned, using&nbsp;</span>gap locks<span style=""  >&nbsp;or&nbsp;</span>next-key locks<span style=""  >&nbsp;to block insertions by other sessions into the gaps covered by the range.</span></div><div><span style=""  >read committed:</span></div><div><span style=""  >For&nbsp;</span>locking reads<span style=""  >&nbsp;(</span>SELECT<span style=""  >&nbsp;with&nbsp;</span>FOR UPDATE<span style=""  >&nbsp;or&nbsp;</span>LOCK IN SHARE MODE<span style=""  >),&nbsp;</span>UPDATE</div></div>
			</div>
	</div>
</div>
</body>
</html>