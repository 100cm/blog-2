<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.1 serializable isolation conflict occur condition and compared with Oracle</h2>
	<h5 id="">2011-09-16 16:24:12&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020118162950691/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div><div><span style="white-space:pre;"   > </span>PostgreSQL 9.1&nbsp;隔离级别为serializable时，事务冲突检测条件 :&nbsp;</div><div>1. 首先圈定发生冲突的事务的隔离级别 : = serializable 。</div><div>换句话说冲突只会在serializable 和serializable的事务之间发生，不会发生在serializable和read committed的事务之间等等。后面会有例子。</div><div>2. 发生冲突的事务必须存在至少同一个表的操作交集。（一个事务查询了某些记录，另一个事务更新或删除了这些记录中的部分或全部。或者两个事务同时查询了相同的记录。）</div><div>3. 发生冲突的事务必须对产生交集的表都有写的操作(insert,delete,update之一) ，并且每个事务的写操作必须至少影响1行记录及以上。</div><div>4. 发生冲突的事务都必须有2条或以上SQL(当DML和DSL没有已经存在的行交集时)，或者其中一个SESSION的DML（update,delete）与另一个SESSION有行交集。</div><div><br></div><div>其实是事务提交时, 会检测预加锁是否有冲突. &nbsp;例如页的冲突, 行的冲突, 对象的冲突等等.</div><div><br></div><div><span style="white-space:pre;"   > </span>当冲突发生时，第一时间提交的事务可以成功返回，在冲突域里面，后提交的所有事务都被自动ROLLBACK。并且报错 ：</div><div><div>ERROR: &nbsp;could not serialize access due to read/write dependencies among transactions</div><div>DETAIL: &nbsp;Reason code: Canceled on identification as a pivot, during commit attempt .&nbsp;</div><div>HINT: &nbsp;The transaction might succeed if retried .&nbsp;</div></div><div><br></div><div><span style="white-space:pre;"   > </span>serializable可以认为是把原子操作带入到逻辑层面。此话怎讲，看完例子就明白了。</div><div>为了测试方便，设置PostgreSQL数据库的 default_transaction_isolation 参数 = 'serializable' 。</div><div><br></div><div>1. &nbsp;统计，更新操作。</div><div>测试表 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create table&nbsp;isolation_test (id int,consume numeric,crt_time timestamp without time zone default now()) ;</font></div><div><font size="2"   >insert into isolation_test(id,consume) select generate_series(1,10),100;</font></div><div><font size="2"   >create table&nbsp;isolation_test_1 (id int,consume numeric,crt_time timestamp without time zone default now()) ;</font></div><p></p></pre></div><div>以下是PostgreSQL 9.1 下面的测试。</div><div>设置PostgreSQL数据库的 default_transaction_isolation 参数 = 'serializable'</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SESSION A :&nbsp;</font></div><div><div><font size="2"   >digoal=&gt; begin ;&nbsp;</font></div><div><font size="2"   >BEGIN</font></div></div><div><div><div><font size="2"   >digoal=&gt; select sum(consume) from isolation_test where id=1;</font></div><div><font size="2"   >&nbsp;sum&nbsp;</font></div><div><font size="2"   >-----</font></div><div><font size="2"   >&nbsp;100</font></div><div><font size="2"   >(1 row)</font></div></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >SESSION B :&nbsp;</font></div><div><div><font size="2"   >digoal=&gt; begin ;&nbsp;</font></div><div><font size="2"   >BEGIN</font></div></div><div><div style="line-height: 22px;"   ><font size="2"   >digoal=&gt; select sum(consume) from isolation_test where id=1;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;sum&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >-----</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;100</font></div><div style="line-height: 22px;"   ><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   ># 此时A和B存在交集&nbsp;isolation_test where id=1&nbsp;</div><div style="line-height: 22px;"   ># 确保每个事务对产生交集的表都有写的操作，接下来对产生交集的表都进行操作。</div><div><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><font size="2"   >SESSION A :&nbsp;</font></div><div><div><div><font size="2"   >digoal=&gt; insert into isolation_test values (11,200);</font></div><div><font size="2"   >INSERT 0 1</font></div></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >SESSION B :&nbsp;</font></div><div><div><div><font size="2"   >digoal=&gt; insert into isolation_test values (12,200);</font></div><div><font size="2"   >INSERT 0 1</font></div></div></div><div><font size="2"   >commit; (先提交的事务成功)</font></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div style="line-height: 22px;"   ><font size="2"   >SESSION A :&nbsp;</font></div><div><div><font size="2"   >digoal=&gt; commit; (后提交的事务失败)</font></div><div><font size="2"   >ERROR: &nbsp;could not serialize access due to read/write dependencies among transactions</font></div><div><font size="2"   >DETAIL: &nbsp;Reason code: Canceled on identification as a pivot, during commit attempt.</font></div><div><font size="2"   >HINT: &nbsp;The transaction might succeed if retried.</font></div></div><p></p></pre></div><div>错误代码 40001</div><div><span style="font-family: verdana, sans-serif; font-size: 12px; line-height: normal;"   ><table border="1"   style="margin-left: 2ex; -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; border-collapse: collapse; margin-top: 2ex; margin-right: 0px; margin-bottom: 2ex; background-color: rgb(224, 236, 239); border-top-width: 2px; border-right-width: 2px; border-bottom-width: 2px; border-left-width: 2px; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(167, 198, 223); border-right-color: rgb(167, 198, 223); border-bottom-color: rgb(167, 198, 223); border-left-color: rgb(167, 198, 223);"   ><tbody><tr><td style="border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; background-color: rgb(255, 255, 255); border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-top-color: rgb(167, 198, 223); border-right-color: rgb(167, 198, 223); border-bottom-color: rgb(167, 198, 223); border-left-color: rgb(167, 198, 223); padding-top: 0.5ex; padding-right: 0.5ex; padding-bottom: 0.5ex; padding-left: 0.5ex;"   ><tt>40001</tt></td><td style="border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; background-color: rgb(255, 255, 255); border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-top-color: rgb(167, 198, 223); border-right-color: rgb(167, 198, 223); border-bottom-color: rgb(167, 198, 223); border-left-color: rgb(167, 198, 223); padding-top: 0.5ex; padding-right: 0.5ex; padding-bottom: 0.5ex; padding-left: 0.5ex;"   ><tt>serialization_failure</tt></td></tr></table></span></div><div><br></div><div>以下是 PostgreSQL 9.0 下面的测试。</div><div>略，结果是两个SESSION都可以提交成功。也就是说隔离级别serializable在9.0里面没有实现。</div><div><br></div><div>以下是 Oracle 10.2.0.4 下面的测试。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >SQL&gt; create table isolation_test (id int,consume numeric,crt_time date default sysdate);</font></div><div><font size="2"   >SQL&gt; create table isolation_test_1 (id int,consume numeric,crt_time date default sysdate);</font></div><div><font size="2"   >SQL&gt; insert into isolation_test (id,consume) select rownum,100 from dual connect by level&lt;=100;</font></div><div><font size="2"   >SESSION A :&nbsp;</font></div></div><div><div><font size="2"   >SQL&gt; conn digoal/digoal_123</font></div><div><font size="2"   >Connected.</font></div><div><font size="2"   >SQL&gt; set transaction isolation level serializable;</font></div><div><font size="2"   >Transaction set.</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >SESSION B :&nbsp;</font></div><div><div style="line-height: 22px;"   ><font size="2"   >SQL&gt; conn digoal/digoal_123</font></div><div style="line-height: 22px;"   ><font size="2"   >Connected.</font></div><div style="line-height: 22px;"   ><font size="2"   >SQL&gt; set transaction isolation level serializable;</font></div><div style="line-height: 22px;"   ><font size="2"   >Transaction set.</font></div></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div><font size="2"   >SESSION A :&nbsp;</font></div><div><font size="2"   >SQL&gt; insert into isolation_test(id,consume) values (101,200);</font></div><div><div style="line-height: 22px;"   ><font size="2"   >1 row created.</font></div></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div><font size="2"   >SESSION B :&nbsp;</font></div><div><div style="line-height: 22px;"   ><font size="2"   >SQL&gt; insert into isolation_test(id,consume) values (101,200);</font></div><div><div style="line-height: 22px;"   ><font size="2"   >1 row created.</font></div><div><div><font size="2"   >SQL&gt; commit;</font></div><div><font size="2"   >Commit complete.</font></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div></div></div></div><div><div style="line-height: 22px;"   ><font size="2"   >SESSION A :&nbsp;</font></div><div><div style="line-height: 22px;"   ><font size="2"   >SQL&gt; commit;</font></div><div style="line-height: 22px;"   ><font size="2"   >Commit complete.</font></div></div></div><p></p></pre></div><div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   >结果两个SESSION都可以提交成功。Oracle并没有实现严格的Serializable隔离级别. 只实现了SQL92定义的serializable隔离级别.</div><div style="line-height: 22px;"   >以下是Oracle的测试.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SESSION A :&nbsp;</font></div><div><font size="2"   >SQL&gt; set transaction isolation level serializable;</font></div><div><font size="2"   >Transaction set.</font></div><div><font size="2"   >SQL&gt; update isolation_test set crt_time=sysdate where id=1;</font></div><div><font size="2"   >2 rows updated.</font></div><p></p></pre></div><div><br></div></div><div># 在A提交前，启动SESSION B的事务。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >SESSION B :&nbsp;</font></div><div><div><font size="2"   >SQL&gt; set transaction isolation level serializable;</font></div><div><font size="2"   >Transaction set.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >SESSION A :&nbsp;</font></div><div><div style="line-height: 22px;"   ><font size="2"   >SQL&gt; commit;</font></div><div style="line-height: 22px;"   ><font size="2"   >Commit complete.</font></div></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div style="line-height: 22px;"   ><font size="2"   >SESSION B :&nbsp;</font></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><font size="2"   >SQL&gt; update isolation_test set crt_time=sysdate where id=1;</font></div><div style="line-height: 22px;"   ><font size="2"   >update isolation_test set crt_time=sysdate where id=1</font></div></div><div><font size="2"   >*</font></div><div><font size="2"   >ERROR at line 1:</font></div><div><font size="2"   >ORA-08177: can't serialize access for this transaction</font></div></div><p></p></pre></div><div><br></div><div>那么PostgreSQL 9.0 和 9.1 有没有实现SQL92所提到的serializable隔离级别呢 ?</div><div>当然实现了, 只是PostgreSQL中repeatable read隔离级别就已经实现了SQL92标准的serializable隔离级别.</div><div>9.1则在此之上追加了更加严格的隔离级别, 实现了真正的serializable隔离级别.</div><div>只是需要注意的是, PostgreSQL开始一个事务并不是在BEGIN后就马上开始, 而是BEGIN后的第一条SQL发出的时候开始的.</div><div>参考</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201192715948181/"   >http://blog.163.com/digoal@126/blog/static/163877040201192715948181/</a> </div><div>所以在测试时需要非常注意.</div><div><br></div><div>【参考】</div></div><div><a rel="nofollow" href="http://wiki.postgresql.org/wiki/Serializable"   >http://wiki.postgresql.org/wiki/Serializable</a></div><div><a rel="nofollow" href="http://wiki.postgresql.org/wiki/SSI"   >http://wiki.postgresql.org/wiki/SSI</a></div><div><a rel="nofollow" href="http://en.wikipedia.org/wiki/Serializable_(databases)"   >http://en.wikipedia.org/wiki/Serializable_(databases)</a></div><div><br></div><div>ORACLE :&nbsp;</div><div><span style="font-family: Tahoma, sans-serif; line-height: normal; font-size: small;"   >The&nbsp;<code style="font-family: monospace; font-size: 12px;"   >SERIALIZABLE</code>&nbsp;setting specifies serializable transaction isolation mode as defined in the SQL92 standard. If a serializable transaction contains data manipulation language (DML) that attempts to update any resource that may have been updated in a transaction uncommitted at the start of the serializable transaction, then the DML statement fails.</span></div></div><div><font face="Tahoma, sans-serif"   size="2"   ><span style="line-height: normal;"   ><br></span></font></div></div>
	</div>
</div>
</body>
</html>