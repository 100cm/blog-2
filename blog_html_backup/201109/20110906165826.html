<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">chat with an ad-union developer</h2>
	<h5 id="">2011-09-06 16:58:26&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020118641849388/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">今天和一位广告联盟的兄弟聊天，得知他们在MySQL和PostgreSQL之间做选择。<wbr><div>其中的一个应用场景是:</div><div>&nbsp; REDIS做每小时的数据统计，每小时把前一个小时的REDIS统计出来的数据写入数据库。</div><div>&nbsp; 写入的程序是PHP写的，从REDIS取出写入到RDBMS，连数据库只开了一个连接（这里我不太了解内情，反正只开一个连接，要开多个连接的话可能要改程序，还是极力推荐他修改为可以配置多连接的方式）。</div><div>&nbsp; 数据库服务器是一台普通的PC服务器，SATA硬盘，2GB内存，FREEBSD的操作系统。</div><div>&nbsp; MySQL每秒约插入5000条（innodb引擎），24小时候后的平均插入约3000多条每秒，没有UK违反约束的错误。</div><div>&nbsp; 而PostgreSQL9.1beta3压下了插入每秒不到2000条，有UK违反约束的错误。</div><div>&nbsp; 我连到他的服务器上，在压时观察数据库服务器的压力情况，发现服务器基本上没有压力，但是每秒的写入只有2000多。</div><div>&nbsp; PHP程序不方便贴出。就不多说了。</div><div>&nbsp; （对于违反约束的错误，我怀疑是程序重复提交了同一SQL造成的。总不至于MYSQL不检查约束吧。）</div><div>&nbsp; &nbsp;因为操作比较简单，所以我在我的系统里面模拟和他的程序同样的操作：</div><div>&nbsp; &nbsp;表结构</div><div><div>digoal=&gt; \d insert_test_log</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Table "digoal.insert_test_log"</div><div>&nbsp;Column | &nbsp; &nbsp; Type &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Modifiers &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>--------+---------------+--------------------------------------------------------------</div><div>&nbsp;id &nbsp; &nbsp; | integer &nbsp; &nbsp; &nbsp; | not null default nextval('insert_test_log_id_seq'::regclass)</div><div>&nbsp;day &nbsp; &nbsp;| date &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</div><div>&nbsp;hour &nbsp; | integer &nbsp; &nbsp; &nbsp; |&nbsp;</div><div>&nbsp;uid &nbsp; &nbsp;| integer &nbsp; &nbsp; &nbsp; |&nbsp;</div><div>&nbsp;siteid | integer &nbsp; &nbsp; &nbsp; |&nbsp;</div><div>&nbsp;adid &nbsp; | integer &nbsp; &nbsp; &nbsp; |&nbsp;</div><div>&nbsp;num &nbsp; &nbsp;| integer &nbsp; &nbsp; &nbsp; |&nbsp;</div><div>&nbsp;md5 &nbsp; &nbsp;| character(32) |&nbsp;</div><div>Indexes:</div><div>&nbsp; &nbsp; "insert_test_log_pkey" PRIMARY KEY, btree (id)</div><div>&nbsp; &nbsp; "insert_test_log_md5_key" UNIQUE CONSTRAINT, btree (md5)</div></div><div><br></div><div>测试使用插入函数:</div><div><div>CREATE OR REPLACE FUNCTION ins_insert_test_log</div><div>(i_day integer, i_hour integer, i_uid integer, i_siteid integer, i_adid integer, i_num integer)</div><div>&nbsp;RETURNS integer</div><div>&nbsp;LANGUAGE plpgsql</div><div>AS $function$</div><div>declare</div><div>begin</div><div>insert into insert_test_log (day,hour,uid,siteid,adid,num,md5) values (current_date+i_day,i_hour,i_uid,i_siteid,i_adid,i_num,md5(clock_timestamp()::text));</div><div>return 0;</div><div>exception</div><div>when others then</div><div>return 1;</div><div>end;</div><div>$function$;</div></div><div><br></div><div>测试使用的pgbench脚本文件:</div><div><div>\setrandom i_date -365 365</div><div>\setrandom i_hour 1 1999999999</div><div>\setrandom i_uid 1 1999999999</div><div>\setrandom i_siteid 1 1999999999</div><div>\setrandom i_adid 1 1999999999</div><div>\setrandom i_num 1 1999999999</div><div>select ins_insert_test_log(:i_date,:i_hour,:i_uid,:i_siteid,:i_adid,:i_num);</div></div><div><br></div><div>pgbench测试脚本，同样使用1个连接:</div><div><div>#!/bin/bash</div><div>. /home/postgres/.bash_profile</div><div>pgbench -M prepared -c 1 -f /home/postgres/pgbench/insert_test_unlog.sql -j 1 -n -T 180 -h xxx.xxx.xxx.xxx -p xxxx -U digoal digoal</div></div><div><br></div><div>测试结果:</div><div><div>transaction type: Custom query</div><div>scaling factor: 1</div><div>query mode: prepared</div><div>number of clients: 1</div><div>number of threads: 1</div><div>duration: 180 s</div><div>number of transactions actually processed: 624236</div><div>tps = 3467.965139 (including connections establishing)</div><div>tps = 3468.037698 (excluding connections establishing)</div></div><div>每秒处理的事务数是3400多.</div><div>数据库服务器90% idle ，&nbsp;负载0.5左右。</div><div><br></div><div>来说说单连接和多连接的区别:</div><div>从上面的测试来看，PostgreSQL单连接处理的情况下，数据库服务器的资源还很空闲。单条SQL的平均响应时间是1000/3468=0.29毫秒.</div><div>如果开2个连接，并且数据库服务器的资源够用的情况下，并且单条SQL平均响应时间趋于不变，每秒应该可以处理一倍的SQL请求=6936。</div><div><br></div><div>虽然程序不支持多数据库连接，为了告知他多连接的好处，还是测试一下多连接的情况:</div><div><div style="line-height: 22px;"  ><div style="line-height: 22px;"  >pgbench -M prepared -c 32 -f /home/postgres/pgbench/insert_test_unlog.sql -j 32 -n -T 180 -h xxx.xxx.xxx.xxx -p xxxx -U digoal digoal</div><div><div>transaction type: Custom query</div><div>scaling factor: 1</div><div>query mode: prepared</div><div>number of clients: 32</div><div>number of threads: 32</div><div>duration: 180 s</div><div>number of transactions actually processed: 4969116</div><div>tps = 27581.990980 (including connections establishing)</div><div>tps = 27585.349709 (excluding connections establishing)</div></div></div></div><div>开32个连接，数据库服务器25% idle ，&nbsp;负载12左右。</div><div>每秒处理SQL请求27581次。单条SQL的平均响应时间=1000/(27581/32)=1.1毫秒。</div><div>虽然平均SQL响应时间长了，但是总的吞吐量变大了。</div><div><br></div><div>另一个应用场景是 :&nbsp;</div><div>实时更新URL的访问次数。</div><div>比如访问<a href="http://blog.163.com/digoal@126/"  >http://blog.163.com/digoal@126/</a>&nbsp;每次被访问，都要使点击率加1.</div><div>做法大概是 update table set uv=uv+1 where md5=$? ;&nbsp;</div><div>在测试系统中压力测试，显示PG某些SQL会很慢，长的要好几秒。</div><div>对于数据库来说，这是一个比较常见的ROW LOCK等待问题，例如同一个时间段内频繁的更新同一条记录(对于热门访问的URL)，因为更新记录需要锁行，就是说一个SESSION在更新某一条记录时，其他SESSION要等待。所以就有可能出现长的要好几秒的情况。</div><div>之前写过一篇oracle和postgresql处理死锁的文章，如下，有兴趣的朋友可以参考一下。</div><div>http://blog.163.com/digoal@126/blog/static/16387704020113811711716/</div><div><br></div><div>解决这个问题的办法，</div><div>1. 提高数据库单条记录更新速度，注意PostgreSQL更新记录的做法是老的记录并没有实际的删除掉，而是修改了行的头部信息，有兴趣的朋友可以看看heaptuple的结构。因此每次不管更新啥，在物理存储上都会多出一条记录，后台VACUUM去回收已经标记为删除并且所有事务都不会看到的记录。当然PG选择这种MVCC模式，也带来了很多好处，比如并发能力非常，可以把DDL封装到事务里面等等。</div><div>&nbsp; &nbsp; 因此要提高数据库单条UPDATE速度，可以考虑使用另外的MVCC模式的数据库，如 mongoDB , oracle .&nbsp;</div><div>2. 缓存访问计数，非实时的更新数据库，就不存在热门URL频繁更新数据库的问题了。</div><div><br></div><div>个人还是推荐第二种解决办法。</div></div>
	</div>
</div>
</body>
</html>