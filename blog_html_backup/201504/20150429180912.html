<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">How to prevent object bloat in PostgreSQL</h2>
	<h5 id="">2015-04-29 18:09:12&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402015329115636287/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>经常看到有人说表又膨胀了，那么导致对象膨胀的常见原因有哪些呢？</div><div><br></div><div>1. 未开启autovacuum</div><div>对于未开启autovacuum的用户，同时又没有合理的自定义vacuum调度的话，表的垃圾没有及时回收，新的数据又不断进来，膨胀是必然的。（新的数据包括插入和更新，更新产生新版本的记录）</div><div><br></div><div>2. 开启了autovacuum, 但是各种原因导致回收不及时，并且新的数据又不断产生，从而导致膨胀。</div><div>回收不及时的原因：</div><div>2.1. IO差</div><div>当数据库非常繁忙时，如果IO比较差，会导致回收垃圾变慢，从而导致膨胀。</div><div>这种一般出现在数据库中存在非常巨大的表，并且这些表在执行whole table vacuum (prevent xid wrapped, 或当表的年龄大于vacuum_freeze_table_age时会全表扫)，因此产生大量IO，这期间很容易导致自身或其他表膨胀。</div><div><br></div><div>2.2. autovacuum触发较迟</div><div>什么情况会触发autovacuum呢?</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp;* A table needs to be vacuumed if the number of dead tuples exceeds a</font></div><div><font size="2"   >&nbsp;* threshold. &nbsp;This threshold is calculated as</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* threshold = vac_base_thresh + vac_scale_factor * reltuples</font></div><p></p></pre></div><div>如果没有设置表级别的autovacuum thresh和factor,那么默认使用参数文件配置的值。如下：</div><div><div>int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; autovacuum_vac_thresh; &nbsp;// 默认50</div><div>double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;autovacuum_vac_scale; &nbsp;// 默认0.2</div></div><div>也就是说dead tuple达到约为表的20%时，才触发autovacuum。</div><div>然后回收又需要一定的时间，所以最终表的膨胀应该是超过20%的。</div><div><br></div><div>2.3. 所有worker繁忙，某些表产生的垃圾如果超过阈值，但是在此期间没有worker可以为它处理垃圾回收的事情。导致可能发生膨胀。</div><div>可fork的worker进程个数是参数<span style="line-height: 28px;"   >autovacuum_max_workers决定的，初始化autovacuum共享内存时已固定了它的最大进程数。见代码，</span></div><div>src/backend/postmaster/autovacuum.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* AutoVacuumShmemInit</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Allocate and initialize autovacuum-related shared memory</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >AutoVacuumShmemInit(void)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;found;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; AutoVacuumShmem = (AutoVacuumShmemStruct *)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ShmemInitStruct("AutoVacuum Data",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AutoVacuumShmemSize(),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!IsUnderPostmaster)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WorkerInfo &nbsp; &nbsp; &nbsp;worker;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AutoVacuumShmem-&gt;av_launcherpid = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;AutoVacuumShmem-&gt;av_freeWorkers);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;AutoVacuumShmem-&gt;av_runningWorkers);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AutoVacuumShmem-&gt;av_startingWorker = NULL;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker = (WorkerInfo) ((char *) AutoVacuumShmem +</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MAXALIGN(sizeof(AutoVacuumShmemStruct)));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* initialize the WorkerInfo free list */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; autovacuum_max_workers; i++)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_head(&amp;AutoVacuumShmem-&gt;av_freeWorkers,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;worker[i].wi_links);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(found);</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>如果数据库的表很多，而且都比较大，那么当需要vacuum的表超过了配置<span style="line-height: 28px;"   >autovacuum_max_workers的数量，某些表就要等待空闲的worker。这个阶段就容易出现表的膨胀。</span></div><div><div>以前的PostgreSQL版本，一个数据库同一时间只会起一个worker进程，现在的版本已经没有这个限制了：</div><div><span style="line-height: 28px;"   >src/backend/postmaster/autovacuum.c</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp;* Note that there can be more than one worker in a database concurrently.</font></div><div><font size="2"   >&nbsp;* They will store the table they are currently vacuuming in shared memory, so</font></div><div><font size="2"   >&nbsp;* that other workers avoid being blocked waiting for the vacuum lock for that</font></div><div><font size="2"   >&nbsp;* table. &nbsp;They will also reload the pgstats data just before vacuuming each</font></div><div><font size="2"   >&nbsp;* table, to avoid vacuuming a table that was just finished being vacuumed by</font></div><div><font size="2"   >&nbsp;* another worker and thus is no longer noted in shared memory. &nbsp;However,</font></div><div><font size="2"   >&nbsp;* there is a window (caused by pgstat delay) on which a worker may choose a</font></div><div><font size="2"   >&nbsp;* table that was already vacuumed; this is a bug in the current design.</font></div><p></p></pre></div></div><div>所以如果你的PostgreSQL集群有很多数据库的话，可能需要更多的worker进程来支撑。</div><div>另外需要注意一点，worker进程在工作时，每个worker最多会消耗的内存由以下参数决定：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >#maintenance_work_mem = 64MB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# min 1MB</font></div><div><font size="2"   >#autovacuum_work_mem = -1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # min 1MB, or -1 to use maintenance_work_mem</font></div><p></p></pre></div><div>所以worker进程越多，内存需求量也越大。</div><div><br></div><div>2.4. 数据库中存在持有事务Exclusive锁的长事务</div><div>PostgreSQL目前存在一个非常严重的缺陷，当<span style="line-height: 28px;"   >数据库中存在持有事务Exclusive锁的长事务，事务过程中产生垃圾的话，无法回收，导致数据库膨胀。</span></div><div><span style="line-height: 28px;"   >原因见：</span></div><div>src/backend/utils/time/tqual.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* HeapTupleSatisfiesVacuum</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;Determine the status of tuples for VACUUM purposes. &nbsp;Here, what</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;we mainly want to know is if a tuple is potentially visible to *any*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp;running transaction. &nbsp;If so, it can't be removed yet by VACUUM.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* OldestXmin is a cutoff XID (obtained from GetOldestXmin()). &nbsp;Tuples</font></div><div><font size="2"   >&nbsp;* deleted by XIDs &gt;= OldestXmin are deemed "recently dead"; they might</font></div><div><font size="2"   >&nbsp;* still be visible to some open transaction, so we can't remove them,</font></div><div><font size="2"   >&nbsp;* even if we see that the deleting transaction has committed.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >HTSV_Result</font></div><div><font size="2"   >HeapTupleSatisfiesVacuum(HeapTuple htup, TransactionId OldestXmin,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Buffer buffer)</font></div><div><font size="2"   >{</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >后面通过测试来展示。</span></div><div><br></div><div>2.5. 开启了autovacuum_vacuum_cost_delay。</div><div>在开启了autovacuum_vacuum_cost_delay后，会使用基于成本的垃圾回收，这个可以有利于降低VACUUM带来的IO影响，但是对于IO没有问题的系统，就没有必要开启<span style="line-height: 28px;"   >autovacuum_vacuum_cost_delay，因为这会使得垃圾回收的时间变长。</span></div><div><span style="line-height: 28px;"   >当autovacuum进程达到autovacuum_vacuum_cost_limit后，会延迟</span><span style="line-height: 28px;"   >autovacuum_vacuum_cost_delay后继续。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Adjust cost limit of each active worker to balance the total of cost</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* limit to autovacuum_vacuum_cost_limit.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; cost_avail = (double) vac_cost_limit / vac_cost_delay;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(iter, &amp;AutoVacuumShmem-&gt;av_runningWorkers)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WorkerInfo &nbsp; &nbsp; &nbsp;worker = dlist_container(WorkerInfoData, wi_links, iter.cur);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (worker-&gt;wi_proc != NULL &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;wi_dobalance &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;wi_cost_limit_base &gt; 0 &amp;&amp; worker-&gt;wi_cost_delay &gt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit = (int)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cost_avail * worker-&gt;wi_cost_limit_base / cost_total);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We put a lower bound of 1 on the cost_limit, to avoid division-</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* by-zero in the vacuum code. &nbsp;Also, in case of roundoff trouble</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* in these calculations, let's be sure we don't ever set</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* cost_limit to more than the base value.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;wi_cost_limit = Max(Min(limit,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;wi_cost_limit_base),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><p></p></pre></div><div>限制计算方法由另外几个参数决定：</div><div>包括在SHARED BUFFER中命中的块，未命中的块，非脏块的额外成本。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >vacuum_cost_page_hit (integer)</font></div><div><font size="2"   >The estimated cost for vacuuming a buffer found in the shared buffer cache. It represents the cost to lock the buffer pool, lookup the shared hash table and scan the content of the page. The default value is one.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >vacuum_cost_page_miss (integer)</font></div><div><font size="2"   >The estimated cost for vacuuming a buffer that has to be read from disk. This represents the effort to lock the buffer pool, lookup the shared hash table, read the desired block in from the disk and scan its content. The default value is 10.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >vacuum_cost_page_dirty (integer)</font></div><div><font size="2"   >The estimated cost charged when vacuum modifies a block that was previously clean. It represents the extra I/O required to flush the dirty block out to disk again. The default value is 20.</font></div><p></p></pre></div><div>对于IO没有问题的系统，不建议设置<span style="line-height: 28px;"   >autovacuum_vacuum_cost_limit。</span></div><div><br></div><div>2.6.autovacuum launcher process 唤醒时间太长</div><div>唤醒时间由参数autovacuum_naptime决定，autovacuum launcher进程负责告诉postmaster需要fork worker进程来进行垃圾回收，但是如果<span style="line-height: 28px;"   >autovacuum launcher进程一直在睡觉的话，那完蛋了，有垃圾了它还在睡觉，那不就等着膨胀吗？</span></div><div>另外还有一个限制在代码中，也就是说不能小于<span style="line-height: 28px;"   >MIN_AUTOVAC_SLEEPTIME 100毫秒</span><span style="line-height: 28px;"   >：</span></div><div>src/backend/postmaster/autovacuum.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/* the minimum allowed time between two awakenings of the launcher */</font></div><div><font size="2"   >#define MIN_AUTOVAC_SLEEPTIME 100.0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* milliseconds */</font></div></div><div><font size="2"   >......</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* The smallest time we'll allow the launcher to sleep. */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (nap-&gt;tv_sec &lt;= 0 &amp;&amp; nap-&gt;tv_usec &lt;= MIN_AUTOVAC_SLEEPTIME * 1000)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nap-&gt;tv_sec = 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nap-&gt;tv_usec = MIN_AUTOVAC_SLEEPTIME * 1000;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><div><font size="2"   >......</font></div><div><font size="2"   >                /*<br>                 * Wait until naptime expires or we get some type of signal (all the<br>                 * signal handlers will wake us by calling SetLatch).<br>                 */<br>                rc = WaitLatch(&amp;MyProc-&gt;procLatch,<br>                                           WL_LATCH_SET | WL_TIMEOUT | WL_POSTMASTER_DEATH,<br>                                           (nap.tv_sec * 1000L) + (nap.tv_usec / 1000L));</font></div><p></p></pre></div><div>这个后面我会进行测试来展示它。</div><div><br></div><div>2.7 批量删除或批量更新，</div><div>例如对于一个10GB的表，一条SQL或一个事务中删除或更新9GB的数据，这9GB的数据必须在事务结束后才能进行垃圾回收，无形中增加了膨胀的可能。</div><div><br></div><div>2.8 大量的非HOT更新，会导致索引膨胀，对于BTREE索引来说，整个索引页没有任何引用才能被回收利用，因此索引比较容易膨胀。</div><div><br></div><div>[测试]</div><div>测试过程使用如下参数：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >autovacuum = on</font></div><div><font size="2"   >log_autovacuum_min_duration = 0</font></div></div><div><div><font size="2"   >autovacuum_max_workers = 10</font></div><div><font size="2"   >autovacuum_naptime = 1</font></div><div><font size="2"   >autovacuum_vacuum_threshold = 5</font></div><div><font size="2"   >autovacuum_analyze_threshold = 5</font></div><div><font size="2"   >autovacuum_vacuum_scale_factor = 0.002</font></div><div><font size="2"   >autovacuum_analyze_scale_factor = 0.001</font></div></div><div><font size="2"   >autovacuum_vacuum_cost_delay = 0</font></div><p></p></pre></div><div>测试数据：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create table tbl (id int primary key, info text, crt_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# insert into tbl select generate_series(1,2000000),md5(random()::text),clock_timestamp();</font></div><div><font size="2"   >INSERT 0 2000000</font></div><div><font size="2"   >postgres=# \dt+ tbl</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | Name | Type &nbsp;| &nbsp;Owner &nbsp; | &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+------+-------+----------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | tbl &nbsp;| table | postgres | 146 MB |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# \di+ tbl_pkey&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp; Name &nbsp; | Type &nbsp;| &nbsp;Owner &nbsp; | Table | Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+----------+-------+----------+-------+-------+-------------</font></div><div><font size="2"   >&nbsp;public | tbl_pkey | index | postgres | tbl &nbsp; | 43 MB |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>测试脚本：</div><div>一次最多更新25万条</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >$ vi test.sql</font></div><div><font size="2"   >\setrandom id 1 2000000</font></div><div><font size="2"   >update tbl set info=md5(random()::text) where id between :id-250000 and :id+250000;</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >测试两个东西：</span></div><div><span style="line-height: 28px;"   >1. 数据库中存在持有事务Exclusive锁的长事务，这个事务时间段内，数据库产生的垃圾无法被回收。</span></div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; pgbench -M prepared -n -r -f ./test.sql -c 1 -j 1 -T 500000</font></div><div></div><p></p></pre><div><span style="line-height: 28px;"   >观察日志</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; tail -f -n 1 postgresql-2015-04-29_174535.csv|grep removable</font></div><div><font size="2"   >tuples: 500001 removed, 1710872 remain, 0 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 478 remain, 3 are dead but not yet removable</font></div><div><font size="2"   >tuples: 499647 removed, 1844149 remain, 0 are dead but not yet removable</font></div><div><font size="2"   >tuples: 500001 removed, 1830118 remain, 0 are dead but not yet removable</font></div><div><font size="2"   >tuples: 290450 removed, 1865527 remain, 0 are dead but not yet removable</font></div><p></p></pre></div><div>现在看没有问题，接下来我开一个持有事务Exclusive锁的事务，</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >postgres=# select txid_current();</font></div><div><font size="2"   >&nbsp;txid_current&nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp; &nbsp; 314030959</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >postgres=# select pg_backend_pid();</font></div><div><font size="2"   >&nbsp;pg_backend_pid&nbsp;</font></div><div><font size="2"   >----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6073</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >-[ RECORD 1 ]------+--------------</font></div><div><font size="2"   >locktype &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | virtualxid</font></div><div><font size="2"   >database &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >relation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >page &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >tuple &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >virtualxid &nbsp; &nbsp; &nbsp; &nbsp; | 4/180</font></div><div><font size="2"   >transactionid &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >classid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >objid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >objsubid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >virtualtransaction | 4/180</font></div><div><font size="2"   >pid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 6073</font></div><div><font size="2"   >mode &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | ExclusiveLock</font></div><div><font size="2"   >granted &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| t</font></div><div><font size="2"   >fastpath &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | t</font></div><div><font size="2"   >-[ RECORD 2 ]------+--------------</font></div><div><font size="2"   >locktype &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | transactionid</font></div><div><font size="2"   >database &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >relation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >page &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >tuple &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >virtualxid &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >transactionid &nbsp; &nbsp; &nbsp;| 314030959</font></div><div><font size="2"   >classid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >objid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >objsubid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >virtualtransaction | 4/180</font></div><div><font size="2"   >pid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 6073</font></div><div><font size="2"   >mode &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | ExclusiveLock</font></div><div><font size="2"   >granted &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| t</font></div><div><font size="2"   >fastpath &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | f</font></div></div><p></p></pre></div><div>这个事务在另一个会话中通过txid_current_snapshot可以看到它是一个未结束的事务。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select * from txid_current_snapshot();</font></div><div><font size="2"   >-[ RECORD 1 ]---------+------------------------------</font></div><div><font size="2"   >txid_current_snapshot | 314030959:314030981:314030959</font></div><p></p></pre></div><div>接下来看看日志：</div><div>不可回收的行在不断的增长。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >tuples: 0 removed, 2391797 remain, 500001 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 484 remain, 9 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 2459288 remain, 500001 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 484 remain, 9 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 2713489 remain, 760235 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 487 remain, 12 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 2572991 remain, 760235 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 487 remain, 12 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 2849378 remain, 760235 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 487 remain, 12 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 3023757 remain, 760235 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 487 remain, 12 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 3135900 remain, 1137469 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 490 remain, 15 are dead but not yet removable</font></div><p></p></pre></div><div>索引和表也明显膨胀了：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \dt+ tbl</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | Name | Type &nbsp;| &nbsp;Owner &nbsp; | &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+------+-------+----------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | tbl &nbsp;| table | postgres | 781 MB |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# \di+ tbl_pkey&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp; Name &nbsp; | Type &nbsp;| &nbsp;Owner &nbsp; | Table | &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+----------+-------+----------+-------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | tbl_pkey | index | postgres | tbl &nbsp; | 308 MB |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>关闭这个事务后：这个事务期间没有被回收的垃圾可以正常回收</div><div>停之前，另外再开一个</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# begin;</font></div><div><font size="2"   >BEGIN</font></div><div><font size="2"   >postgres=# select txid_current();</font></div><div><font size="2"   >&nbsp;txid_current&nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp; &nbsp; 314031042</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>然后停前面那个</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# end;</font></div><div><font size="2"   >COMMIT</font></div><p></p></pre></div><div>这里主要为了说明，这样的连续事务，不会影响上一个事务过程造成影响的未回收的垃圾。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >tuples: 0 removed, 481 remain, 6 are dead but not yet removable</font></div><div><font size="2"   >tuples: 13629196 removed, 2515757 remain, 500001 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 4845701 remain, 1000002 are dead but not yet removable</font></div><div><font size="2"   >tuples: 0 removed, 7146782 remain, 1500003 are dead but not yet removable</font></div><p></p></pre></div><div>后面启动的那个也停掉，垃圾完全回收了：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# end;</font></div><div><font size="2"   >COMMIT</font></div></div><div><div><font size="2"   >tuples: 7183691 removed, 11252550 remain, 0 are dead but not yet removable</font></div><div><font size="2"   >tuples: 500001 removed, 6234858 remain, 0 are dead but not yet removable</font></div></div><p></p></pre></div><div>但是表和索引已经膨胀了，无法收缩，除非使用rewrite table（vacuum full, cluster）或者pg_reorg,pg_repack这样的工具。</div><div>我再举一个实际可能存在的例子，例如持续的并发批量更新，也可能导致膨胀：</div><div>例如我有一个表包含100万条记录，分成10个进程，每个进程批量更新其中的10万条，并且持续不断的更新。</div><div>为什么说这样操作会引起膨胀呢，因为worker process 最小粒度是表级别的，同一张表同一时间只有一个进程在回收垃圾。这种场景会产生三个问题：</div><div>1. 瞬时产生垃圾的速度可能超过回收的速度，</div><div>2. 产生新TUPLE版本的需求超过FSM的剩余空间，</div><div>3. 回收过程中（其他进程可能会启动并发的更新，持有事务排他锁）会遇到不可回收的问题，就是前面这个例子提到的问题。</div><div>这几种原因会导致扩展新的数据块可能性变大，即膨胀。</div><div>测试例子：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# truncate tbl;</font></div><div><font size="2"   >TRUNCATE TABLE</font></div><div><font size="2"   >postgres=# insert into tbl select generate_series(1,1000000),md5(random()::text),clock_timestamp();</font></div><div><font size="2"   >INSERT 0 1000000</font></div><div><font size="2"   >postgres=# \dt+ tbl</font></div><div><font size="2"   >List of relations</font></div><div><font size="2"   >-[ RECORD 1 ]---------</font></div><div><font size="2"   >Schema &nbsp; &nbsp; &nbsp;| public</font></div><div><font size="2"   >Name &nbsp; &nbsp; &nbsp; &nbsp;| tbl</font></div><div><font size="2"   >Type &nbsp; &nbsp; &nbsp; &nbsp;| table</font></div><div><font size="2"   >Owner &nbsp; &nbsp; &nbsp; | postgres</font></div><div><font size="2"   >Size &nbsp; &nbsp; &nbsp; &nbsp;| 73 MB</font></div><div><font size="2"   >Description |&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# \di+ tbl_pkey&nbsp;</font></div><div><font size="2"   >List of relations</font></div><div><font size="2"   >-[ RECORD 1 ]---------</font></div><div><font size="2"   >Schema &nbsp; &nbsp; &nbsp;| public</font></div><div><font size="2"   >Name &nbsp; &nbsp; &nbsp; &nbsp;| tbl_pkey</font></div><div><font size="2"   >Type &nbsp; &nbsp; &nbsp; &nbsp;| index</font></div><div><font size="2"   >Owner &nbsp; &nbsp; &nbsp; | postgres</font></div><div><font size="2"   >Table &nbsp; &nbsp; &nbsp; | tbl</font></div><div><font size="2"   >Size &nbsp; &nbsp; &nbsp; &nbsp;| 21 MB</font></div><div><font size="2"   >Description |&nbsp;</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >$ vi t1.sql</font></div><div><div><font size="2"   >update tbl set info=info,crt_time=clock_timestamp() where id &gt;=1 and id&lt;100000;</font></div><div><span style="line-height: 28px;"   ><font size="2"   >$ vi t2.sql</font></span></div><div><font size="2"   >update tbl set info=info,crt_time=clock_timestamp() where id &gt;=100001 and id&lt;200000;</font></div><div><span style="line-height: 28px;"   ><font size="2"   >$ vi t3.sql</font></span></div><div><font size="2"   >update tbl set info=info,crt_time=clock_timestamp() where id &gt;=200001 and id&lt;300000;</font></div><div><span style="line-height: 28px;"   ><font size="2"   >$ vi t4.sql</font></span></div><div><font size="2"   >update tbl set info=info,crt_time=clock_timestamp() where id &gt;=300001 and id&lt;400000;</font></div><div><span style="line-height: 28px;"   ><font size="2"   >$ vi t5.sql</font></span></div><div><font size="2"   >update tbl set info=info,crt_time=clock_timestamp() where id &gt;=400001 and id&lt;500000;</font></div><div><span style="line-height: 28px;"   ><font size="2"   >$ vi t6.sql</font></span></div><div><font size="2"   >update tbl set info=info,crt_time=clock_timestamp() where id &gt;=500001 and id&lt;600000;</font></div><div><span style="line-height: 28px;"   ><font size="2"   >$ vi t7.sql</font></span></div><div><font size="2"   >update tbl set info=info,crt_time=clock_timestamp() where id &gt;=600001 and id&lt;700000;</font></div><div><span style="line-height: 28px;"   ><font size="2"   >$ vi t8.sql</font></span></div><div><font size="2"   >update tbl set info=info,crt_time=clock_timestamp() where id &gt;=700001 and id&lt;800000;</font></div><div><span style="line-height: 28px;"   ><font size="2"   >$ vi t9.sql</font></span></div><div><font size="2"   >update tbl set info=info,crt_time=clock_timestamp() where id &gt;=800001 and id&lt;900000;</font></div></div><div><span style="line-height: 28px;"   ><font size="2"   >$ vi t10.sql</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   >update tbl set info=info,crt_time=clock_timestamp() where id &gt;=900001 and id&lt;=1000000;</font></span></div><div><span style="line-height: 28px;"   ><font size="2"   ><br></font></span></div><div><font size="2"   >pgbench -M prepared -n -r -f ./t1.sql -c 1 -j 1 -T 500000 &amp;</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./t2.sql -c 1 -j 1 -T 500000 &amp;</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./t3.sql -c 1 -j 1 -T 500000 &amp;</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./t4.sql -c 1 -j 1 -T 500000 &amp;</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./t5.sql -c 1 -j 1 -T 500000 &amp;</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./t6.sql -c 1 -j 1 -T 500000 &amp;</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./t7.sql -c 1 -j 1 -T 500000 &amp;</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./t8.sql -c 1 -j 1 -T 500000 &amp;</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./t9.sql -c 1 -j 1 -T 500000 &amp;</font></div><div><font size="2"   >pgbench -M prepared -n -r -f ./t10.sql -c 1 -j 1 -T 500000 &amp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >观察到出现了不可回收的垃圾</font></div><div><div><font size="2"   >tuples: 0 removed, 2049809 remain, 999991 are dead but not yet removable</font></div><div><font size="2"   >tuples: 501373 removed, 2176172 remain, 999991 are dead but not yet removable</font></div><div><font size="2"   >tuples: 1603158 removed, 2517367 remain, 899562 are dead but not yet removable</font></div><div><font size="2"   >tuples: 405093 removed, 2647780 remain, 899992 are dead but not yet removable</font></div></div><div><div><font size="2"   >tuples: 1100546 removed, 2724724 remain, 899562 are dead but not yet removable</font></div><div><font size="2"   >tuples: 528200 removed, 2864735 remain, 1141307 are dead but not yet removable</font></div><div><font size="2"   >tuples: 981628 removed, 2757909 remain, 933307 are dead but not yet removable</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >膨胀</font></div><div><font size="2"   ><span style="line-height: 21px;"   >postgres=# \dt+ tbl<br>List of relations<br>-[ RECORD 1 ]---------<br>Schema      | public<br>Name        | tbl<br>Type        | table<br>Owner       | postgres<br>Size        | 554 MB<br>Description | <br><br>postgres=# \di+ tbl_pkey <br>List of relations<br>-[ RECORD 1 ]---------<br>Schema      | public<br>Name        | tbl_pkey<br>Type        | index<br>Owner       | postgres<br>Table       | tbl<br>Size        | 114 MB<br>Description | </span></font></div><p></p></pre></div><div><span style="line-height: 28px;"   >如果</span><span style="line-height: 28px;"   >产生新TUPLE版本的需求超过FSM的剩余空间，</span><span style="line-height: 28px;"   >还会继续膨胀下去。</span></div><div><span style="line-height: 28px;"   >这个问题的改进非常简单，将批量更新的粒度降低，即单个事务时间缩短，可以降低事务排他锁持有时间，减少</span>not yet removable的情况，同时事务变小后，单个事务对剩余空间的需求量也变小了，所以不需要扩展数据块。就不会膨胀。</div><div>例子：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create sequence seq cache 10;</font></div><div><font size="2"   >CREATE SEQUENCE</font></div></div><div><div><font size="2"   >postgres=# vacuum full tbl;</font></div><div><font size="2"   >VACUUM</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >postgres@db-172-16-3-150-&gt; vi test.sql</font></div><div><font size="2"   >update tbl set info=info,crt_time=clock_timestamp() where id=mod(nextval('seq'),2000001);</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >为了提高速度，我这里将nextval改为immutable, 让以上SQL可以走索引扫描（生产环境请勿模仿）。</font></div><div><font size="2"   >postgres=# alter function nextval(regclass) immutable;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; pgbench -M prepared -n -r -f ./test.sql -c 20 -j 10 -T 500000</font></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >因为事务很短，所以只能看到少量的<span style="line-height: 28px;"   >not yet removable，</span></font></div><div><span style="line-height: 28px;"   ><font size="2"   >同时因为一次更新带来的新版本需要的空间也比较小，所以不会超出FSM中的剩余空间，不需要EXTEND BLOCK。</font></span></div><div><font size="2"   >tuples: 11116 removed, 977673 remain, 591 are dead but not yet removable</font></div><div><font size="2"   >tuples: 12050 removed, 978437 remain, 979 are dead but not yet removable</font></div><div><font size="2"   >tuples: 12687 removed, 981375 remain, 227 are dead but not yet removable</font></div><div><font size="2"   >tuples: 12911 removed, 978912 remain, 831 are dead but not yet removable</font></div><div><font size="2"   >tuples: 7 removed, 475 remain, 0 are dead but not yet removable</font></div><div><font size="2"   >tuples: 13133 removed, 979761 remain, 522 are dead but not yet removable</font></div><div><font size="2"   >tuples: 14419 removed, 977651 remain, 1077 are dead but not yet removable</font></div><div><font size="2"   >tuples: 12111 removed, 978558 remain, 700 are dead but not yet removable</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >半小时后，并未出现膨胀</font></div><div><div><font size="2"   >postgres=# \dt+ tbl</font></div><div><font size="2"   >List of relations</font></div><div><font size="2"   >-[ RECORD 1 ]---------</font></div><div><font size="2"   >Schema &nbsp; &nbsp; &nbsp;| public</font></div><div><font size="2"   >Name &nbsp; &nbsp; &nbsp; &nbsp;| tbl</font></div><div><font size="2"   >Type &nbsp; &nbsp; &nbsp; &nbsp;| table</font></div><div><font size="2"   >Owner &nbsp; &nbsp; &nbsp; | postgres</font></div><div><font size="2"   >Size &nbsp; &nbsp; &nbsp; &nbsp;| 75 MB</font></div><div><font size="2"   >Description |&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# \di+ tbl_pkey&nbsp;</font></div><div><font size="2"   >List of relations</font></div><div><font size="2"   >-[ RECORD 1 ]---------</font></div><div><font size="2"   >Schema &nbsp; &nbsp; &nbsp;| public</font></div><div><font size="2"   >Name &nbsp; &nbsp; &nbsp; &nbsp;| tbl_pkey</font></div><div><font size="2"   >Type &nbsp; &nbsp; &nbsp; &nbsp;| index</font></div><div><font size="2"   >Owner &nbsp; &nbsp; &nbsp; | postgres</font></div><div><font size="2"   >Table &nbsp; &nbsp; &nbsp; | tbl</font></div><div><font size="2"   >Size &nbsp; &nbsp; &nbsp; &nbsp;| 21 MB</font></div><div><font size="2"   >Description |&nbsp;</font></div></div><p></p></pre></div><div><br></div><div><span style="line-height: 28px;"   >2. autovacuum launcher process 唤醒时间太长会影响垃圾回收。</span></div><div>调整autovacuum_naptime = 1000， 1000秒的睡觉时间，看看怎么完蛋的吧。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg_ctl reload</font></div><div><div><font size="2"   >postgres=# vacuum full tbl;</font></div><div><font size="2"   >VACUUM</font></div><div><font size="2"   >postgres=# \dt+ tbl</font></div><div><font size="2"   >List of relations</font></div><div><font size="2"   >-[ RECORD 1 ]---------</font></div><div><font size="2"   >Schema &nbsp; &nbsp; &nbsp;| public</font></div><div><font size="2"   >Name &nbsp; &nbsp; &nbsp; &nbsp;| tbl</font></div><div><font size="2"   >Type &nbsp; &nbsp; &nbsp; &nbsp;| table</font></div><div><font size="2"   >Owner &nbsp; &nbsp; &nbsp; | postgres</font></div><div><font size="2"   >Size &nbsp; &nbsp; &nbsp; &nbsp;| 145 MB</font></div><div><font size="2"   >Description |&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# \di+ tbl_pkey&nbsp;</font></div><div><font size="2"   >List of relations</font></div><div><font size="2"   >-[ RECORD 1 ]---------</font></div><div><font size="2"   >Schema &nbsp; &nbsp; &nbsp;| public</font></div><div><font size="2"   >Name &nbsp; &nbsp; &nbsp; &nbsp;| tbl_pkey</font></div><div><font size="2"   >Type &nbsp; &nbsp; &nbsp; &nbsp;| index</font></div><div><font size="2"   >Owner &nbsp; &nbsp; &nbsp; | postgres</font></div><div><font size="2"   >Table &nbsp; &nbsp; &nbsp; | tbl</font></div><div><font size="2"   >Size &nbsp; &nbsp; &nbsp; &nbsp;| 43 MB</font></div><div><font size="2"   >Description |&nbsp;</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres@db-172-16-3-150-&gt; pgbench -M prepared -n -r -f ./test.sql -c 1 -j 1 -T 500000</font></div><p></p></pre></div><div>现在不看日志，一段时间之后，你看看<span style="line-height: 28px;"   >pg_stat_all_tables：</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres@db-172-16-3-150-&gt; psql</font></div><div><font size="2"   >psql (9.4.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >postgres=# \x</font></div><div><font size="2"   >Expanded display is on.</font></div><div><div><font size="2"   >postgres=# select * from pg_stat_all_tables where relname='tbl';</font></div><div><font size="2"   >-[ RECORD 1 ]-------+------------------------------</font></div><div><font size="2"   >relid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 60511</font></div><div><font size="2"   >schemaname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| public</font></div><div><font size="2"   >relname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | tbl</font></div><div><font size="2"   >seq_scan &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 6</font></div><div><font size="2"   >seq_tup_read &nbsp; &nbsp; &nbsp; &nbsp;| 12082648</font></div><div><font size="2"   >idx_scan &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 116</font></div><div><font size="2"   >idx_tup_fetch &nbsp; &nbsp; &nbsp; | 49232974</font></div><div><font size="2"   >n_tup_ins &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2000000</font></div><div><font size="2"   >n_tup_upd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 50732969</font></div><div><font size="2"   >n_tup_del &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 0</font></div><div><font size="2"   >n_tup_hot_upd &nbsp; &nbsp; &nbsp; | 81869</font></div><div><font size="2"   >n_live_tup &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 2328301</font></div><div><font size="2"   >n_dead_tup &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 7895450</font></div><div><font size="2"   >n_mod_since_analyze | 7825343</font></div><div><font size="2"   >last_vacuum &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp;</font></div><div><font size="2"   >last_autovacuum &nbsp; &nbsp; | 2015-04-29 18:02:45.325102+08</font></div><div><font size="2"   >last_analyze &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >last_autoanalyze &nbsp; &nbsp;| 2015-04-29 18:02:45.596096+08</font></div><div><font size="2"   >vacuum_count &nbsp; &nbsp; &nbsp; &nbsp;| 0</font></div><div><font size="2"   >autovacuum_count &nbsp; &nbsp;| 247</font></div><div><font size="2"   >analyze_count &nbsp; &nbsp; &nbsp; | 0</font></div><div><font size="2"   >autoanalyze_count &nbsp; | 91</font></div></div><p></p></pre></div><div>表已经膨胀了：</div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >postgres=# \dt+ tbl</font></div><div style="line-height: 28px;"   ><font size="2"   >List of relations</font></div><div style="line-height: 28px;"   ><font size="2"   >-[ RECORD 1 ]---------</font></div><div style="line-height: 28px;"   ><font size="2"   >Schema &nbsp; &nbsp; &nbsp;| public</font></div><div style="line-height: 28px;"   ><font size="2"   >Name &nbsp; &nbsp; &nbsp; &nbsp;| tbl</font></div><div style="line-height: 28px;"   ><font size="2"   >Type &nbsp; &nbsp; &nbsp; &nbsp;| table</font></div><div style="line-height: 28px;"   ><font size="2"   >Owner &nbsp; &nbsp; &nbsp; | postgres</font></div><div style="line-height: 28px;"   ><font size="2"   >Size &nbsp; &nbsp; &nbsp; &nbsp;| 393 MB</font></div><div style="line-height: 28px;"   ><font size="2"   >Description |&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >postgres=# \di+ tbl_pkey&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >List of relations</font></div><div style="line-height: 28px;"   ><font size="2"   >-[ RECORD 1 ]---------</font></div><div style="line-height: 28px;"   ><font size="2"   >Schema &nbsp; &nbsp; &nbsp;| public</font></div><div style="line-height: 28px;"   ><font size="2"   >Name &nbsp; &nbsp; &nbsp; &nbsp;| tbl_pkey</font></div><div style="line-height: 28px;"   ><font size="2"   >Type &nbsp; &nbsp; &nbsp; &nbsp;| index</font></div><div style="line-height: 28px;"   ><font size="2"   >Owner &nbsp; &nbsp; &nbsp; | postgres</font></div><div style="line-height: 28px;"   ><font size="2"   >Table &nbsp; &nbsp; &nbsp; | tbl</font></div><div style="line-height: 28px;"   ><font size="2"   >Size &nbsp; &nbsp; &nbsp; &nbsp;| 115 MB</font></div><div style="line-height: 28px;"   ><font size="2"   >Description |&nbsp;</font></div><p></p></pre></div></div><div><br></div><div>[小结]</div><div>通过上面的分析，我们应该如何减少或避免PostgreSQL数据膨胀呢？</div><div><span style="line-height: 28px;"   >1. 一定要开启autovacuum。</span></div><div><span style="line-height: 28px;"   >2. 提高系统的IO能力，越高越好。</span></div><div><span style="line-height: 28px;"   >3. 调整触发阈值，让触发阈值和记录数匹配。调小</span>autovacuum_vacuum_scale_factor和autovacuum_analyze_scale_factor。比如我想在有1万条垃圾记录后就触发垃圾回收，那么对于一个1000万的表来说，我应该把<span style="line-height: 28px;"   >autovacuum_vacuum_scale_factor调到千分之一即0.001，而</span><span style="line-height: 28px;"   >autovacuum_analyze_scale_factor应该调到0.0005。</span></div><div><span style="line-height: 28px;"   >4. 增加</span>autovacuum_max_workers，同时增加autovacuum_work_mem，同时增加系统内存。</div><div>例如对于有大量表需要频繁更新的数据库集群，可以将<span style="line-height: 28px;"   >autovacuum_max_workers调整为与CPU核数一致，并将</span><span style="line-height: 28px;"   >autovacuum_work_mem调整为2GB，同时需要确保系统预留的内存大于</span><span style="line-height: 28px;"   >autovacuum_max_workers*</span><span style="line-height: 28px;"   >autovacuum_work_mem。</span></div><div><span style="line-height: 28px;"   >5. 应用程序设计时，尽量避免持有事务Exclusive锁的长事务（DDL,DML都会持有</span><span style="line-height: 28px;"   >事务Exclusive锁</span><span style="line-height: 28px;"   >）</span></div><div><span style="line-height: 28px;"   >6. 对于IO没有问题的系统，关闭autovacuum_vacuum_cost_delay。</span></div><div><span style="line-height: 28px;"   >7. 调整</span>autovacuum_naptime参数到最低，如果还是唤醒时间太长，可以调整代码中的限制，例如改为1毫秒：</div><div><span style="line-height: 28px;"   >#define MIN_AUTOVAC_SLEEPTIME 1.0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* milliseconds */</span></div><div><span style="line-height: 28px;"   >8. 应用程序设计时，避免使用大批量的更新，删除操作，可以切分为多个事务进行。</span></div><div><span style="line-height: 28px;"   >9. 使用大的数据块，对于现代的硬件水平，32KB是比较好的选择，fillfactor实际上不需要太关注，100就可以了，调低它其实没有必要，因为数据库总是有垃圾，也就是说每个块在被更新后实际上都不可能是满的。</span></div><div><span style="line-height: 28px;"   >10. 万一真的膨胀了，可以通过table rewrite来回收(如vacuum full, cluster)，但是需要迟排他锁。建议使用pg_reorg或者pg_repack来回收，实际上用到了交换 filenode可以缩短需要持有排他锁的时间。</span></div><div><span style="line-height: 28px;"   ><br></span></div>[参考]<wbr><div>1.&nbsp;src/backend/postmaster/autovacuum.c</div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="How to prevent object bloat in PostgreSQL - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>