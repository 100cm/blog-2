<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">use generate_series and outer join fill gap rows</h2>
	<h5 id="">2015-04-09 14:27:55&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201539218216/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>群里一位网友的需求 :&nbsp;</div><div><div>姓名 序号 成绩</div><div>------------------</div><div>张三 &nbsp;1 &nbsp; &nbsp; 11</div><div>张三 &nbsp;2 &nbsp; &nbsp; 31</div><div>李四 &nbsp;1 &nbsp; &nbsp; 53</div><div>李四 &nbsp;3 &nbsp; &nbsp; 23</div><div><br></div><div>想得到的结果：</div><div>张三 &nbsp;1 &nbsp; &nbsp;11</div><div>张三 &nbsp;2 &nbsp; &nbsp;31</div><div>张三 &nbsp;3 &nbsp; &nbsp;0 &nbsp; --&gt; 补出来的记录行</div><div>李四 &nbsp;1 &nbsp; &nbsp;53</div><div>李四 &nbsp;2 &nbsp; &nbsp;0 &nbsp; &nbsp;--&gt; 补出来的记录行</div><div>李四 &nbsp;3 &nbsp; &nbsp;23</div><div><br></div><div>PostgreSQL中，有没有什么分析函数可以自动补全“按序号，缺少的每一行记录”？</div></div><div><br></div><div>之前写过一个使用generate_series来填充缺失的ip地址的例子, 有兴趣请参考.</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201111805555263/"   >http://blog.163.com/digoal@126/blog/static/163877040201111805555263/</a></div><div><br></div><div>这位网友的问题和这个差不多, 都是有补齐的需求.</div><div>要补齐记录, 不能使用窗口, 因为窗口函数返回一条记录. 有不能使用聚合, 聚合是把多条变成一条记录.</div><div>还是老方法, 使用generate_series生成需要补齐的记录, 然后使用OUTER JOIN.</div><div><br></div><div>例子 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create table tbl(id int, info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# insert into tbl values (1, 'a1');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into tbl values (1, 'a3');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into tbl values (1, 'b2');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into tbl values (1, 'b10');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# select * from tbl;</font></div><div><font size="2"   >&nbsp;id | info&nbsp;</font></div><div><font size="2"   >----+------</font></div><div><font size="2"   >&nbsp; 1 | a1</font></div><div><font size="2"   >&nbsp; 1 | a3</font></div><div><font size="2"   >&nbsp; 1 | b2</font></div><div><font size="2"   >&nbsp; 1 | b10</font></div><div><font size="2"   >(4 rows)</font></div><p></p></pre></div><div>使用substring分裂info字段.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select id,info,substring(info,'([a-z]*)\d*') as x, substring(info,'[a-z]*(\d*)') as y from tbl;</font></div><div><font size="2"   >&nbsp;id | info | x | y &nbsp;</font></div><div><font size="2"   >----+------+---+----</font></div><div><font size="2"   >&nbsp; 1 | a1 &nbsp; | a | 1</font></div><div><font size="2"   >&nbsp; 1 | a3 &nbsp; | a | 3</font></div><div><font size="2"   >&nbsp; 1 | b2 &nbsp; | b | 2</font></div><div><font size="2"   >&nbsp; 1 | b10 &nbsp;| b | 10</font></div><div><font size="2"   >(4 rows)</font></div><p></p></pre></div><div><br></div><div>使用WITH语法, 将最终需求合成一条SQL.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# with t1 as (</font></div><div><font size="2"   >&nbsp; &nbsp; select id,info,substring(info,'([a-z]*)\d*') as x,&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; substring(info,'[a-z]*(\d*)') as y<span style="line-height: 28px;"   >&nbsp;from tbl</span></font></div><div><span style="line-height: 28px;"   ><font size="2"   >),&nbsp;</font></span></div><div><font size="2"   >t2 as (</font></div><div><font size="2"   >&nbsp; &nbsp; select generate_series(min,max) id from (select min(y::int8),max(y::int8) from t1) t</font></div><div><font size="2"   >),&nbsp;</font></div><div><font size="2"   >t3 as (</font></div><div><font size="2"   >&nbsp; &nbsp; select t.x||t2.id as info from ( select x from t1 group by x) t,t2</font></div><div><font size="2"   >)&nbsp;</font></div><div><font size="2"   >select case when t1.id is not null then t1.id else 0 end,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case when t1.info is null then t3.info else t1.info end&nbsp;</font></div><div><font size="2"   >from t3 left outer join t1&nbsp;</font></div><div><font size="2"   >on t1.info=t3.info;</font></div><div><font size="2"   >&nbsp;case | info&nbsp;</font></div><div><font size="2"   >------+------</font></div><div><font size="2"   >&nbsp; &nbsp; 1 | a1</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | a10</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | a2</font></div><div><font size="2"   >&nbsp; &nbsp; 1 | a3</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | a4</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | a5</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | a6</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | a7</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | a8</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | a9</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | b1</font></div><div><font size="2"   >&nbsp; &nbsp; 1 | b10</font></div><div><font size="2"   >&nbsp; &nbsp; 1 | b2</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | b3</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | b4</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | b5</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | b6</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | b7</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | b8</font></div><div><font size="2"   >&nbsp; &nbsp; 0 | b9</font></div><div><font size="2"   >(20 rows)</font></div><p></p></pre></div><div><br></div><div>如果info字段本来就是两个字段的话, 不需要split的过程.</div><div><br></div>[参考]<div>1.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201111805555263/"   >http://blog.163.com/digoal@126/blog/static/163877040201111805555263/</a></div><div>这里还有一个时间gap填充的例子 :&nbsp;<br><wbr><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://stackoverflow.com/questions/13728489/how-to-fill-timestamp-gaps-in-a-postgres-query"   >http://stackoverflow.com/questions/13728489/how-to-fill-timestamp-gaps-in-a-postgres-query</a></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >DROP SCHEMA tmp CASCADE;</font></div><div><font size="2"   >CREATE SCHEMA tmp ;</font></div><div><font size="2"   >SET search_path = tmp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >DROP TABLE IF EXISTS channel1m CASCADE;</font></div><div><font size="2"   >CREATE TABLE channel1m (</font></div><div><font size="2"   >&nbsp; zts TIMESTAMP WITHOUT TIME ZONE NOT NULL,</font></div><div><font size="2"   >&nbsp; zitemid BIGINT,</font></div><div><font size="2"   >&nbsp; zvalue BIGINT</font></div><div><font size="2"   >);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >-- in which a row may be inserted each minute, per zitemid, as follows:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >INSERT INTO channel1m(zts, zitemid, zvalue) VALUES</font></div><div><font size="2"   >&nbsp;('2012-12-03 15:29:00', &nbsp; 100, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1)</font></div><div><font size="2"   >,('2012-12-03 15:30:00', &nbsp; 100, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2)</font></div><div><font size="2"   >,('2012-12-03 15:30:00', &nbsp; 101, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0)</font></div><div><font size="2"   >,('2012-12-03 15:32:00', &nbsp; 100, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1)</font></div><div><font size="2"   >,('2012-12-03 15:32:00', &nbsp; 101, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; -- CTE to the rescue!!!</font></div><div><font size="2"   >WITH cal AS (</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; WITH mm AS (</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SELECT MIN(xx.zts) AS minmin, MAX(xx.zts) AS maxmax</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FROM channel1m xx)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SELECT generate_series(mm.minmin , mm.maxmax , '1 min'::interval) AS stamp</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FROM mm</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; )</font></div><div><font size="2"   >, ite AS (</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; SELECT DISTINCT zitemid AS zitemid</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; FROM channel1m</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; )</font></div><div><font size="2"   >SELECT cal.stamp</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; , ite.zitemid</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; , tab.zvalue</font></div><div><font size="2"   >FROM cal</font></div><div><font size="2"   >JOIN ite ON 1=1 -- Note: this is a cartesian product of the {time,id} -domains</font></div><div><font size="2"   >LEFT JOIN channel1m tab ON tab.zts = cal.stamp AND tab.zitemid = ite.zitemid</font></div><div><font size="2"   >ORDER BY stamp ASC</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ;</font></div><div><font size="2"   >Output:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >NOTICE: &nbsp;drop cascades to table tmp.channel1m</font></div><div><font size="2"   >DROP SCHEMA</font></div><div><font size="2"   >CREATE SCHEMA</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >NOTICE: &nbsp;table "channel1m" does not exist, skipping</font></div><div><font size="2"   >DROP TABLE</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >INSERT 0 5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; stamp &nbsp; &nbsp; &nbsp; &nbsp;| zitemid | zvalue&nbsp;</font></div><div><font size="2"   >---------------------+---------+--------</font></div><div><font size="2"   >&nbsp;2012-12-03 15:29:00 | &nbsp; &nbsp; 101 | &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;2012-12-03 15:29:00 | &nbsp; &nbsp; 100 | &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"   >&nbsp;2012-12-03 15:30:00 | &nbsp; &nbsp; 100 | &nbsp; &nbsp; &nbsp;2</font></div><div><font size="2"   >&nbsp;2012-12-03 15:30:00 | &nbsp; &nbsp; 101 | &nbsp; &nbsp; &nbsp;0</font></div><div><font size="2"   >&nbsp;2012-12-03 15:31:00 | &nbsp; &nbsp; 100 | &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;2012-12-03 15:31:00 | &nbsp; &nbsp; 101 | &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp;2012-12-03 15:32:00 | &nbsp; &nbsp; 100 | &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"   >&nbsp;2012-12-03 15:32:00 | &nbsp; &nbsp; 101 | &nbsp; &nbsp; &nbsp;1</font></div><div><font size="2"   >(8 rows)</font></div><p></p></pre></div><div><br></div></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="use generate_series and outer join fill gap rows - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>