<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL standby startup hang because it cann't probe the newest history file or XLOG file</h2>
	<h5 id="">2015-04-19 3:10:53&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201531925123675/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>最近在一个跨广域网的PostgreSQL primary standby环境中遇到一个比较奇特的问题。</div><div>首先primary standby是跨广域网的，但这不是问题的重点。重点是归档也是跨光域网并且使用NFS来让standby访问归档文件。</div><div>standby通过NFS获取归档，通过TCP连接primary实现流复制。</div><div>但是不知道什么原因，NFS出现了问题，即standby无法正常的访问归档文件了，访问NFS的命令会hang住。</div><div>接下来描述一下问题，然后再从PostgreSQL源码分析问题的原因。</div><div>1. standby的restore_command命令(cp /nfsdir/%f %p)hang住，停留在拷贝某个归档xlog的状态。</div><div>2. 手工kill 这个cp命令，紧接着standby数据库crash了。</div><div>3. 重启standby数据库，发现hang在cp /nfsdir/0000009.history %p的状态，然而实际上<span style="line-height: 28px;"   >0000009.history是不存在的，主库的时间线是8，备库的时间线也是8，那么是什么原因导致standby要去找一个不存在的时间线文件呢？</span></div><div><span style="line-height: 28px;"   >这个原因要到源代码去寻找答案。</span></div><div>&nbsp; &nbsp; 我们一般配置流复制环境，会设置recovery_target_timeline=latest，这样做的目的是配置一个hot_standby，如果上游切换了时间线，可以自动跟上。</div><div>&nbsp; &nbsp; 而这个就可以解释为什么<span style="line-height: 28px;"   >standby recovery的时候要去找一个不存在的时间线文件？</span></div><div><br></div><div>见源码：</div><div>src/backend/access/transam/timeline.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Find the newest existing timeline, assuming that startTLI exists.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: while this is somewhat heuristic, it does positively guarantee</font></div><div><font size="2"   >&nbsp;* that (result + 1) is not a known timeline, and therefore it should</font></div><div><font size="2"   >&nbsp;* be safe to assign that ID to a new timeline.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >TimeLineID</font></div><div><font size="2"   >findNewestTimeLine(TimeLineID startTLI)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID &nbsp; &nbsp; &nbsp;newestTLI;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID &nbsp; &nbsp; &nbsp;probeTLI;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* The algorithm is just to probe for the existence of timeline history</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* files. &nbsp;XXX is it useful to allow gaps in the sequence?</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; newestTLI = startTLI;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; for (probeTLI = startTLI + 1;; probeTLI++) &nbsp; &nbsp; &nbsp;# 问题就出在这里, 探测下一个时间线是否存在。</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (existsTimeLineHistory(probeTLI))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newestTLI = probeTLI; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* probeTLI exists */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* doesn't exist, assume we're done */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return newestTLI;</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>src/backend/access/transam/xlog.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*<br> * See if there is a recovery command file (recovery.conf), and if so<br> * read in parameters for archive recovery and XLOG streaming.<br> *<br> * The file is parsed using the main configuration parser.<br> */<br>static void<br>readRecoveryCommandFile(void)</font></div><div><font size="2"   >......</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (strcmp(item-&gt;name, "recovery_target_timeline") == 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtliGiven = true;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (strcmp(item-&gt;value, "latest") == 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtli = 0;</font></div></div><div><font size="2"   >.....</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If user specified recovery_target_timeline, validate it or compute the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* "latest" value. &nbsp;We can't do this until after we've gotten the restore</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* command and set InArchiveRecovery, because we need to fetch timeline</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* history files from the archive.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (rtliGiven)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (rtli)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Timeline 1 does not have a history file, all else should */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (rtli != 1 &amp;&amp; !existsTimeLineHistory(rtli))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errmsg("recovery target timeline %u does not exist",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtli)));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recoveryTargetTLI = rtli;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recoveryTargetIsLatest = false;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* We start the "latest" search from pg_control's timeline */ &nbsp; # 问题出在这里，我配置的就是<span style="line-height: 28px;"   >recovery_target_timeline=</span><span style="line-height: 28px;"   >latest, 所以需要调用</span><span style="line-height: 28px;"   >findNewestTimeLine. 控制文件是8，所以find 0000009.history.</span></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recoveryTargetTLI = findNewestTimeLine(recoveryTargetTLI);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recoveryTargetIsLatest = true;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div></div><p></p></pre></div><div><br></div><div>找到原因后，把NFS的问题解决掉，重启数据库就好了，再也不会hang住。</div><div><br></div>[参考]<wbr><div>1.&nbsp;src/backend/access/transam/xlog.c</div><div>2.&nbsp;src/backend/access/transam/timeline.c</div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL standby startup hang because it cannt probe the newest history file or XLOG file - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>