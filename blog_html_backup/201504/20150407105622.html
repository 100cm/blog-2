<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL aggregate function 3 : Aggregate Functions for Ordered-Set</h2>
	<h5 id="">2015-04-07 10:56:22&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402015379286873/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>之前写了两篇关于一般聚合和统计类聚合的函数的用法,&nbsp;</div><div><div style="line-height: 28px;"   ><a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020152223539859/"   >http://blog.163.com/digoal@126/blog/static/16387704020152223539859/</a></div><div style="line-height: 28px;"   ><a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015224124337/"   >http://blog.163.com/digoal@126/blog/static/1638770402015224124337/</a></div></div><div>本文主要讲一下分组排序聚合的例子.</div><div><div style="font-family: verdana, sans-serif; font-size: 12.1599998474121px; line-height: normal;"   ><p style="font-size: 1em; line-height: 1.5em; margin: 1.2em 0em; font-weight: bold;"   >Table 9-51. Ordered-Set Aggregate Functions</p><table border="1"   style="margin: 2ex 0px 2ex 2ex; -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border-spacing: 0px; border-collapse: collapse; border: 2px solid rgb(167, 198, 223); background-color: rgb(224, 236, 239);"   ><colgroup><col><col><col><col><col><thead><tr><th style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex;"   >Function</th><th style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex;"   >Direct Argument Type(s)</th><th style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex;"   >Aggregated Argument Type(s)</th><th style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex;"   >Return Type</th><th style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex;"   >Description</th></tr></thead><tbody><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><code>mode() WITHIN GROUP (ORDER BY<tt style="font-style: italic; font-size: 1em;"   >sort_expression</tt>)</code></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >&nbsp;</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >any sortable type</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >same as sort expression</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >returns the most frequent input value (arbitrarily choosing the first one if there are multiple equally-frequent results)</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><code>percentile_cont(<tt style="font-style: italic; font-size: 1em;"   >fraction</tt>) WITHIN GROUP (ORDER BY&nbsp;<tt style="font-style: italic; font-size: 1em;"   >sort_expression</tt>)</code></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>double precision</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>double precision</tt>or&nbsp;<tt>interval</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >same as sort expression</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >continuous percentile: returns a value corresponding to the specified fraction in the ordering, interpolating between adjacent input items if needed</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><code>percentile_cont(<tt style="font-style: italic; font-size: 1em;"   >fractions</tt>) WITHIN GROUP (ORDER BY&nbsp;<tt style="font-style: italic; font-size: 1em;"   >sort_expression</tt>)</code></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>double precision[]</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>double precision</tt>or&nbsp;<tt>interval</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >array of sort expression's type</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >multiple continuous percentile: returns an array of results matching the shape of the&nbsp;<tt>fractions</tt>parameter, with each non-null element replaced by the value corresponding to that percentile</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><code>percentile_disc(<tt style="font-style: italic; font-size: 1em;"   >fraction</tt>) WITHIN GROUP (ORDER BY&nbsp;<tt style="font-style: italic; font-size: 1em;"   >sort_expression</tt>)</code></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>double precision</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >any sortable type</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >same as sort expression</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >discrete percentile: returns the first input value whose position in the ordering equals or exceeds the specified fraction</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><code>percentile_disc(<tt style="font-style: italic; font-size: 1em;"   >fractions</tt>) WITHIN GROUP (ORDER BY&nbsp;<tt style="font-style: italic; font-size: 1em;"   >sort_expression</tt>)</code></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>double precision[]</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >any sortable type</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >array of sort expression's type</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >multiple discrete percentile: returns an array of results matching the shape of the&nbsp;<tt>fractions</tt>parameter, with each non-null element replaced by the input value corresponding to that percentile</td></tr></table></div><p style="font-size: 12.1599998474121px; line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   >All the aggregates listed in&nbsp;<a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/functions-aggregate.html#FUNCTIONS-ORDEREDSET-TABLE"   >Table 9-51</a>&nbsp;ignore null values in their sorted input. For those that take a&nbsp;<tt style="font-style: italic;"   >fraction</tt>&nbsp;parameter, the fraction value must be between 0 and 1; an error is thrown if not. However, a null fraction value simply produces a null result.</p></div><div>mode比较好理解, 就是取分组中出现频率最高的值或表达式, 如果最高频率的值有多个, 则随机取一个.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create table test(id int, info text);</font></div><div><font size="2"   >CREATE TABLE</font></div></div><div><div><font size="2"   >postgres=# insert into test values (1,'test1');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (1,'test1');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (1,'test2');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (1,'test3');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (2,'test1');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (2,'test1');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (2,'test1');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (3,'test4');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (3,'test4');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (3,'test4');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (3,'test4');</font></div><div><font size="2"   >INSERT 0 1</font></div></div><div><div><font size="2"   >postgres=# insert into test values (3,'test4');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# select * from test;</font></div><div><font size="2"   >&nbsp;id | info &nbsp;</font></div><div><font size="2"   >----+-------</font></div><div><font size="2"   >&nbsp; 1 | test1</font></div><div><font size="2"   >&nbsp; 1 | test1</font></div><div><font size="2"   >&nbsp; 1 | test2</font></div><div><font size="2"   >&nbsp; 1 | test3</font></div><div><font size="2"   >&nbsp; 2 | test1</font></div><div><font size="2"   >&nbsp; 2 | test1</font></div><div><font size="2"   >&nbsp; 2 | test1</font></div><div><font size="2"   >&nbsp; 3 | test4</font></div><div><font size="2"   >&nbsp; 3 | test4</font></div><div><font size="2"   >&nbsp; 3 | test4</font></div><div><font size="2"   >&nbsp; 3 | test4</font></div><div><font size="2"   >&nbsp; 3 | test4</font></div><div><font size="2"   >(12 rows)</font></div></div><p></p></pre></div><div>取出所有数据中, 出现频率最高的info, 有可能是test1也有可能是test4, 因为他们的出现频率一致.</div><div>mode的返回结果数据类型和order by后面的表达式一致.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select mode() within group (order by info) from test;</font></div><div><font size="2"   >&nbsp;mode &nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;test1</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>如果按INFO来分组的话, 取出出现频率最高的info, 实际上这个操作是没有任何意义的, 返回值就是所有记录的info的唯一值.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select mode() within group (order by info) from test group by info;</font></div><div><font size="2"   >&nbsp;mode &nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;test1</font></div><div><font size="2"   >&nbsp;test2</font></div><div><font size="2"   >&nbsp;test3</font></div><div><font size="2"   >&nbsp;test4</font></div><div><font size="2"   >(4 rows)</font></div><p></p></pre></div><div>按id来分组, 取出组内出现频率最高的info值, 这个是有意义的.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select mode() within group (order by info) from test group by id;</font></div><div><font size="2"   >&nbsp;mode &nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp;test1</font></div><div><font size="2"   >&nbsp;test1</font></div><div><font size="2"   >&nbsp;test4</font></div><div><font size="2"   >(3 rows)</font></div><p></p></pre></div><div>id=1 , 出现频率最高的info是test1. 出现2次.</div><div>如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select id,info,count(*) from test group by id,info;</font></div><div><font size="2"   >&nbsp;id | info &nbsp;| count&nbsp;</font></div><div><font size="2"   >----+-------+-------</font></div><div><font size="2"   >&nbsp; 1 | test1 | &nbsp; &nbsp; 2</font></div><div><font size="2"   >&nbsp; 1 | test3 | &nbsp; &nbsp; 1</font></div><div><font size="2"   >&nbsp; 3 | test4 | &nbsp; &nbsp; 5</font></div><div><font size="2"   >&nbsp; 1 | test2 | &nbsp; &nbsp; 1</font></div><div><font size="2"   >&nbsp; 2 | test1 | &nbsp; &nbsp; 3</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div>如果要返回mode()并返回频率次数. 可以使用row_number()窗口来实现. 如下.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select id,info,cnt from (select id,info,cnt,row_number() over(partition by id order by cnt desc) as rn from (select id,info,count(*) cnt from test group by id,info) t) t where t.rn=1;</font></div><div><font size="2"   >&nbsp;id | info &nbsp;| cnt&nbsp;</font></div><div><font size="2"   >----+-------+-----</font></div><div><font size="2"   >&nbsp; 1 | test1 | &nbsp; 2</font></div><div><font size="2"   >&nbsp; 2 | test1 | &nbsp; 3</font></div><div><font size="2"   >&nbsp; 3 | test4 | &nbsp; 5</font></div><div><font size="2"   >(3 rows)</font></div><p></p></pre></div><div>其他,&nbsp;<span style="line-height: 28px;"   >mode的返回结果数据类型和order by后面的表达式一致.</span></div><div style="line-height: 28px;"   ></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select mode() within group (order by id) from test;</font></div><div><font size="2"   >&nbsp;mode&nbsp;</font></div><div><font size="2"   >------</font></div><div><font size="2"   >&nbsp; &nbsp; 3</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >postgres=# select mode() within group (order by id+1) from test;</font></div><div><font size="2"   >&nbsp;mode&nbsp;</font></div><div><font size="2"   >------</font></div><div><font size="2"   >&nbsp; &nbsp; 4</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>另外还有4个函数是和数据分布有关的, 需要指定从0到1的分布位置. 返回排序后, 在指定分布位置的值或表达式的值.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >src/backend/utils/adt/orderedsetaggs.c</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (percentile &lt; 0 || percentile &gt; 1 || isnan(percentile))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("percentile value %g is not between 0 and 1",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; percentile)));</font></div></div><p></p></pre></div><div>同时还需要注意区分连续分布和离散分布.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create table test(id int, info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# insert into test values (1,'test1');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (2,'test2');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (3,'test2');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (4,'test2');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (5,'test2');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (6,'test2');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (7,'test2');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (8,'test3');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (100,'test3');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# insert into test values (1000,'test4');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >postgres=# select * from test;</font></div><div><font size="2"   >&nbsp; id &nbsp;| info &nbsp;</font></div><div><font size="2"   >------+-------</font></div><div><font size="2"   >&nbsp; &nbsp; 1 | test1</font></div><div><font size="2"   >&nbsp; &nbsp; 2 | test2</font></div><div><font size="2"   >&nbsp; &nbsp; 3 | test2</font></div><div><font size="2"   >&nbsp; &nbsp; 4 | test2</font></div><div><font size="2"   >&nbsp; &nbsp; 5 | test2</font></div><div><font size="2"   >&nbsp; &nbsp; 6 | test2</font></div><div><font size="2"   >&nbsp; &nbsp; 7 | test2</font></div><div><font size="2"   >&nbsp; &nbsp; 8 | test3</font></div><div><font size="2"   >&nbsp; 100 | test3</font></div><div><font size="2"   >&nbsp;1000 | test4</font></div><div><font size="2"   >(10 rows)</font></div><p></p></pre></div><div>取连续分布的中位数可以用<span style="line-height: 28px;"   >percentile_cont(0.5)来获得.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select percentile_cont(0.5) within group (order by id) from test;</font></div><div><font size="2"   >&nbsp;percentile_cont&nbsp;</font></div><div><font size="2"   >-----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5.5</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>这个5.5是怎么计算来的呢?&nbsp;<span style="line-height: 28px;"   >参考本文末尾 :&nbsp;</span></div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >&nbsp; If (CRN = FRN = RN) then the result is</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; (value of expression from row at RN)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; Otherwise the result is</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; (CRN - RN) * (value of expression for row at FRN) +</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; (RN - FRN) * (value of expression for row at CRN)</font></div><p></p></pre></div></div><div style="line-height: 28px;"   >解释 :&nbsp;</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >N =&nbsp;<span style="line-height: 28px;"   >当前分组的行数 = 10</span></font></div><div style="line-height: 28px;"   ><font size="2"   >RN =&nbsp;<span style="line-height: 28px;"   >(1+传入参数*(N-1)) =&nbsp;</span><span style="line-height: 28px;"   >(1+0.5*(10-1)) = 5.5</span></font></div><div style="line-height: 28px;"   ><font size="2"   >CRN =&nbsp;<span style="line-height: 28px;"   >ceiling(RN) = 6</span></font></div><div style="line-height: 28px;"   ><font size="2"   >FRN =&nbsp;<span style="line-height: 28px;"   >floor(RN) = 5</span></font></div><div style="line-height: 28px;"   ><font size="2"   ><span style="line-height: 28px;"   >value of expression for row at FRN : 当前分组内第</span><span style="line-height: 28px;"   >FRN行的值 = 5</span></font></div><div style="line-height: 28px;"   ><font size="2"   ><span style="line-height: 28px;"   >value of expression for row at CRN :&nbsp;</span><span style="line-height: 28px;"   >当前分组内第</span><span style="line-height: 28px;"   >CRN行的值 = 6</span></font></div><div style="line-height: 28px;"   ><font size="2"   ><span style="line-height: 28px;"   >所以最终</span><span style="line-height: 28px;"   >中位数</span><span style="line-height: 28px;"   >值 :&nbsp;</span></font></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; (CRN - RN) * (value of expression for row at FRN) +</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; (RN - FRN) * (value of expression for row at CRN) =&nbsp;</font></div></div></div><div style="line-height: 28px;"   ><font size="2"   >(6-5.5)*(5) + (5.5 - 5)*(6) = 5.5;</font></div><p></p></pre></div></div><div style="line-height: 28px;"   >使用info分组 :&nbsp;</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >postgres=# select percentile_cont(0.5) within group (order by id),info from test group by info;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;percentile_cont | info &nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >-----------------+-------</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 | test1</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4.5 | test2</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 54 | test3</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1000 | test4</font></div><div style="line-height: 28px;"   ><font size="2"   >(4 rows)</font></div><p></p></pre></div><div style="line-height: 28px;"   >验证这个值<span style="line-height: 28px;"   >4.5 | test2</span><span style="line-height: 28px;"   >&nbsp;:&nbsp;</span></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; 2 | test2</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; 3 | test2</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; 4 | test2</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; 5 | test2</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; 6 | test2</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; 7 | test2</font></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >N =&nbsp;<span style="line-height: 28px;"   >当前分组的行数 = 6</span></font></div><div style="line-height: 28px;"   ><font size="2"   >RN =&nbsp;<span style="line-height: 28px;"   >(1+传入参数*(N-1)) =&nbsp;</span><span style="line-height: 28px;"   >(1+0.5*(6-1)) = 3.5</span></font></div><div style="line-height: 28px;"   ><font size="2"   >CRN =&nbsp;<span style="line-height: 28px;"   >ceiling(RN) = 4</span></font></div><div style="line-height: 28px;"   ><font size="2"   >FRN =&nbsp;<span style="line-height: 28px;"   >floor(RN) = 3</span></font></div><div style="line-height: 28px;"   ><font size="2"   ><span style="line-height: 28px;"   >value of expression for row at FRN : 当前分组内第</span><span style="line-height: 28px;"   >FRN行的值 = 4</span></font></div><div style="line-height: 28px;"   ><font size="2"   ><span style="line-height: 28px;"   >value of expression for row at CRN :&nbsp;</span><span style="line-height: 28px;"   >当前分组内第</span><span style="line-height: 28px;"   >CRN行的值 = 5</span></font></div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >所以最终中位数值 :&nbsp;</font></span></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; (CRN - RN) * (value of expression for row at FRN) +</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; (RN - FRN) * (value of expression for row at CRN) =&nbsp;</font></div></div></div><div style="line-height: 28px;"   ><font size="2"   >(4-3.5)*(4) + (3.5 - 3)*(5) = 4.5;</font></div></div><p></p></pre></div></div><div style="line-height: 28px;"   ><br></div><div style="line-height: 28px;"   >当输入参数为数组时, 返回值也是数组, 如下 :&nbsp;</div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >postgres=# select percentile_cont(array[0.5, 1]) within group (order by id) from test;</font></span></div></div><div><div><font size="2"   >&nbsp;percentile_cont&nbsp;</font></div><div><font size="2"   >-----------------</font></div><div><font size="2"   >&nbsp;{5.5,1000}</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div></div><div><br></div><div>接下来看一下稀疏分布 :&nbsp;</div><div>返回行号大于等于指定百分比的值或表达式值.</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select id from test;</font></div><div><font size="2"   >&nbsp; id &nbsp;</font></div><div><font size="2"   >------</font></div><div><font size="2"   >&nbsp; &nbsp; 1</font></div><div><font size="2"   >&nbsp; &nbsp; 2</font></div><div><font size="2"   >&nbsp; &nbsp; 3</font></div><div><font size="2"   >&nbsp; &nbsp; 4</font></div><div><font size="2"   >&nbsp; &nbsp; 5</font></div><div><font size="2"   >&nbsp; &nbsp; 6</font></div><div><font size="2"   >&nbsp; &nbsp; 7</font></div><div><font size="2"   >&nbsp; &nbsp; 8</font></div><div><font size="2"   >&nbsp; 100</font></div><div><font size="2"   >&nbsp;1000</font></div><div><font size="2"   >(10 rows)</font></div><p></p></pre></div><div>当前组一共10行, 取位置在0.5的.即行号&gt;=0.5*10的第一行的值或表达式的值.</div><div><div style="line-height: 28px;"   ><pre class="prettyprint"   ><p></p><div><div style="line-height: 28px;"   ><font size="2"   >postgres=# select percentile_disc(0.5) within group (order by id) from test;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;percentile_disc&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >-----------------</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5</font></div><div style="line-height: 28px;"   ><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >postgres=# select percentile_disc(0.5) within group (order by id^2) from test;</font></div><div><font size="2"   >&nbsp;percentile_disc&nbsp;</font></div><div><font size="2"   >-----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 25</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div></div><div>输入0.11, 表示行号返回&gt;=1.1的第一行的值.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select percentile_disc(0.11) within group (order by id) from test;</font></div><div><font size="2"   >&nbsp;percentile_disc&nbsp;</font></div><div><font size="2"   >-----------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>再看个例子</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select id,info,count(*) over (partition by info) from test;</font></div><div><font size="2"   >&nbsp; id &nbsp;| info &nbsp;| count&nbsp;</font></div><div><font size="2"   >------+-------+-------</font></div><div><font size="2"   >&nbsp; &nbsp; 1 | test1 | &nbsp; &nbsp; 1</font></div><div><font size="2"   >&nbsp; &nbsp; 2 | test2 | &nbsp; &nbsp; 6</font></div><div><font size="2"   >&nbsp; &nbsp; 3 | test2 | &nbsp; &nbsp; 6</font></div><div><font size="2"   >&nbsp; &nbsp; 4 | test2 | &nbsp; &nbsp; 6</font></div><div><font size="2"   >&nbsp; &nbsp; 5 | test2 | &nbsp; &nbsp; 6</font></div><div><font size="2"   >&nbsp; &nbsp; 6 | test2 | &nbsp; &nbsp; 6</font></div><div><font size="2"   >&nbsp; &nbsp; 7 | test2 | &nbsp; &nbsp; 6</font></div><div><font size="2"   >&nbsp; &nbsp; 8 | test3 | &nbsp; &nbsp; 2</font></div><div><font size="2"   >&nbsp; 100 | test3 | &nbsp; &nbsp; 2</font></div><div><font size="2"   >&nbsp;1000 | test4 | &nbsp; &nbsp; 1</font></div><div><font size="2"   >(10 rows)</font></div><p></p></pre></div><div>取分组的数据, 主要看test2 这个组一共有6行, 0.3*6=1.8, 所以它需要取第二行的数据.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select info,percentile_disc(0.3) within group (order by id) from test group by info;</font></div><div><font size="2"   >&nbsp;info &nbsp;| percentile_disc&nbsp;</font></div><div><font size="2"   >-------+-----------------</font></div><div><font size="2"   >&nbsp;test1 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1</font></div><div><font size="2"   >&nbsp;test2 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3</font></div><div><font size="2"   >&nbsp;test3 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8</font></div><div><font size="2"   >&nbsp;test4 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1000</font></div><div><font size="2"   >(4 rows)</font></div><p></p></pre></div></div><div><br></div><div><br></div><div>[注意]</div><div>最终计算的是表达式的分布数, 而不是计算列值的分布数后再计算表达式.</div><div>验证如下 :&nbsp;</div><div>或者你可以看代码 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select percentile_cont(0.5) within group (order by id^2),info from test group by info;</font></div><div><font size="2"   >&nbsp;percentile_cont | info &nbsp;</font></div><div><font size="2"   >-----------------+-------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 | test1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 20.5 | test2</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5032 | test3</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1000000 | test4</font></div><div><font size="2"   >(4 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# select percentile_cont(0.5) within group (order by id),info from test group by info;</font></div><div><font size="2"   >&nbsp;percentile_cont | info &nbsp;</font></div><div><font size="2"   >-----------------+-------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 | test1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4.5 | test2</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 54 | test3</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1000 | test4</font></div><div><font size="2"   >(4 rows)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# select 4.5^2;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; ?column? &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------</font></div><div><font size="2"   >&nbsp;20.2500000000000000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# select 54^2;</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;2916</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/devel/static/functions-aggregate.html"   >http://www.postgresql.org/docs/devel/static/functions-aggregate.html</a></div><div>2.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020152223539859/"   >http://blog.163.com/digoal@126/blog/static/16387704020152223539859/</a></div><div>3.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402015224124337/"   >http://blog.163.com/digoal@126/blog/static/1638770402015224124337/</a></div><div>4.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020137124851944"   >http://blog.163.com/digoal@126/blog/static/16387704020137124851944</a></div><div>5.&nbsp;src/backend/utils/adt/orderedsetaggs.c</div><div>6. 算法 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >PERCENTILE_CONT函数解释 :&nbsp;</font></div><div><font size="2"   >The result of PERCENTILE_CONT is computed by linear interpolation between values after ordering them. Using the percentile value (P) and the number of rows (N) in the aggregation group, you can compute the row number you are interested in after ordering the rows with respect to the sort specification. This row number (RN) is computed according to the formula RN = (1+(P*(N-1)). The final result of the aggregate function is computed by linear interpolation between the values from rows at row numbers CRN = CEILING(RN) and FRN = FLOOR(RN).</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The final result will be:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; If (CRN = FRN = RN) then the result is</font></div><div><font size="2"   >&nbsp; &nbsp; (value of expression from row at RN)</font></div><div><font size="2"   >&nbsp; Otherwise the result is</font></div><div><font size="2"   >&nbsp; &nbsp; (CRN - RN) * (value of expression for row at FRN) +</font></div><div><font size="2"   >&nbsp; &nbsp; (RN - FRN) * (value of expression for row at CRN)</font></div><div><font size="2"   ><br></font></div><div><div style="line-height: 28px;"   ><font size="2"   >PERCENTILE_DISC函数解释 :&nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >The first expr must evaluate to a numeric value between 0 and 1, because it is a percentile value. This expression must be constant within each aggregate group. The ORDER BY clause takes a single expression that can be of any type that can be sorted.</font></div><div style="line-height: 28px;"   ><font size="2"   ><br style="line-height: 28px;"   ></font></div><div style="line-height: 28px;"   ><font size="2"   >For a given percentile value P, PERCENTILE_DISC sorts the values of the expression in the ORDER BY clause and returns the value with the smallest CUME_DIST value (with respect to the same sort specification) that is greater than or equal to P.</font></div></div><div style="line-height: 28px;"   ><font size="2"   ><br></font></div><div><font size="2"   >MEDIAN(中位数)详解, Oracle有单独的计算中位数的函数, 实际上就是<span style="line-height: 28px;"   >PERCENTILE_CONT(0.5)</span><span style="line-height: 28px;"   >&nbsp;:&nbsp;</span></font></div><div><font size="2"   >MEDIAN is an inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns the middle value or an interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you specify only expr, then the function returns the same data type as the numeric data type of the argument. If you specify the OVER clause, then Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type.</font></div><div><font size="2"   >The result of MEDIAN is computed by first ordering the rows. Using N as the number of rows in the group, Oracle calculates the row number (RN) of interest with the formula RN = (1 + (0.5*(N-1)). The final result of the aggregate function is computed by linear interpolation between the values from rows at row numbers CRN = CEILING(RN) and FRN = FLOOR(RN).</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >The final result will be:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >if (CRN = FRN = RN) then</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; (value of expression from row at RN)</font></div><div><font size="2"   >&nbsp; &nbsp;else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; (CRN - RN) * (value of expression for row at FRN) +</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; (RN - FRN) * (value of expression for row at CRN)</font></div><p></p></pre></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL aggregate function 3 : Aggregate Functions for Ordered-Set - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>