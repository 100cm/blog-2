<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">use md5 or hashtext?</h2>
	<h5 id="">2015-04-21 9:47:48&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201532192934592/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>我们在PostgreSQL中存储较长的字符串时，如果数据量较大，并且要实现精确匹配的话，有什么好的方法呢？</div><div>首选想到的是索引，但是当字符串太长，超出索引长度限制(见<span style="line-height: 28px;"   >src/backend/access/common/indextuple.c，长度限制为</span><span style="line-height: 28px;"   >INDEX_SIZE_MASK</span><span style="line-height: 28px;"   >)，是无法创建索引的。另外，字符串的索引效率也比较低下。</span></div><div>那么有其他方法吗？</div><div>我们可以将字符串转换为更短的字符或数字，例如md5, hashtext.</div><div>这些转换不一定是一一对应的，所以在查询出来之后，还需要使用字符串进行最终的过滤。</div><div>例如：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create table t2 (info text);</font></div><div><div><font size="2"   >postgres=# insert into t2 values (repeat(md5(random()::text),100000));</font></div><div><font size="2"   >INSERT 0 1</font></div></div><div><div><font size="2"   >postgres=# create index idx_test on t2(info);</font></div><div><font size="2"   >ERROR: &nbsp;54000: index row requires 36688 bytes, maximum size is 8191</font></div><div><font size="2"   >LOCATION: &nbsp;index_form_tuple, indextuple.c:174</font></div></div><div><div><font size="2"   >postgres=# select hashtext(info),md5(info) from t2;</font></div><div><font size="2"   >&nbsp; hashtext &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; md5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-------------+----------------------------------</font></div><div><font size="2"   >&nbsp;-1986549156 | b62583576dcc9820316585a1714acc78</font></div></div><p></p></pre></div><div>我们看到md5返回的还是字符串，而hashtext返回int.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \df hashtext</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of functions</font></div><div><font size="2"   >&nbsp; &nbsp;Schema &nbsp; | &nbsp; Name &nbsp; | Result data type | Argument data types | &nbsp;Type &nbsp;</font></div><div><font size="2"   >------------+----------+------------------+---------------------+--------</font></div><div><font size="2"   >&nbsp;pg_catalog | hashtext | integer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| normal</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# \df md5</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of functions</font></div><div><font size="2"   >&nbsp; &nbsp;Schema &nbsp; | Name | Result data type | Argument data types | &nbsp;Type &nbsp;</font></div><div><font size="2"   >------------+------+------------------+---------------------+--------</font></div><div><font size="2"   >&nbsp;pg_catalog | md5 &nbsp;| text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | bytea &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | normal</font></div><div><font size="2"   >&nbsp;pg_catalog | md5 &nbsp;| text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| normal</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>那么哪个计算效率高一点呢？</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \timing</font></div><div><font size="2"   >Timing is on.</font></div><div><font size="2"   >postgres=# select count(hashtext(i::text)) from generate_series(1,1000000) t(i);</font></div><div><font size="2"   >&nbsp; count &nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;1000000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 662.121 ms</font></div><div><font size="2"   >postgres=# select count(md5(i::text)) from generate_series(1,1000000) t(i);</font></div><div><font size="2"   >&nbsp; count &nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;1000000</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 986.254 ms</font></div><p></p></pre></div><div>显然hashtext计算效率略高。</div><div>那么转换为索引的效率哪个更高？我分别插入1000万条数据，然后使用pgbench测试检索速度。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create table t_md5(info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >Time: 4.594 ms</font></div><div><font size="2"   >postgres=# create table t_hashtext(info int);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >Time: 2.874 ms</font></div></div><div><div><font size="2"   >postgres=# insert into t_md5 select md5(i::text) from generate_series(1,10000000) t(i);</font></div><div><font size="2"   >INSERT 0 10000000</font></div><div><font size="2"   >Time: 34427.290 ms</font></div></div><div><div><font size="2"   >postgres=# insert into t_hashtext select hashtext(i::text) from generate_series(1,10000000) t(i);</font></div><div><font size="2"   >INSERT 0 10000000</font></div><div><font size="2"   >Time: 22678.304 ms</font></div></div><p></p></pre></div><div>创建索引速度对比</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# create index idx_t_hashtext on t_hashtext(info);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >Time: 27838.217 ms</font></div></div><div><div><font size="2"   >postgres=# create index idx_t_md5 on t_md5(info);</font></div><div><font size="2"   >CREATE INDEX</font></div><div><font size="2"   >Time: 58043.625 ms</font></div></div><p></p></pre></div><div>表，索引大小对比</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# \dt+ t_hashtext&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp; &nbsp;Name &nbsp; &nbsp;| Type &nbsp;| &nbsp;Owner &nbsp; | &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+------------+-------+----------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | t_hashtext | table | postgres | 344 MB |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# \dt+ t_md5&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | Name &nbsp;| Type &nbsp;| &nbsp;Owner &nbsp; | &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+-------+-------+----------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | t_md5 | table | postgres | 650 MB |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# \di+ idx_t_hashtext&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp; &nbsp; &nbsp;Name &nbsp; &nbsp; &nbsp;| Type &nbsp;| &nbsp;Owner &nbsp; | &nbsp; Table &nbsp; &nbsp;| &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+----------------+-------+----------+------------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | idx_t_hashtext | index | postgres | t_hashtext | 213 MB |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >postgres=# \di+ idx_t_md5&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List of relations</font></div><div><font size="2"   >&nbsp;Schema | &nbsp; Name &nbsp; &nbsp;| Type &nbsp;| &nbsp;Owner &nbsp; | Table | &nbsp;Size &nbsp;| Description&nbsp;</font></div><div><font size="2"   >--------+-----------+-------+----------+-------+--------+-------------</font></div><div><font size="2"   >&nbsp;public | idx_t_md5 | index | postgres | t_md5 | 553 MB |&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>查询速度对比，首选确保使用了索引。</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain select * from t_hashtext where info=hashtext(1::text);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Only Scan using idx_t_hashtext on t_hashtext &nbsp;(cost=0.43..8.45 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (info = (-631133447))</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   >postgres=# explain select * from t_md5 where info=md5(1::text);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Only Scan using idx_t_md5 on t_md5 &nbsp;(cost=0.43..8.45 rows=1 width=33)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (info = 'c4ca4238a0b923820dcc509a6f75849b'::text)</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>使用pgbench测试</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres@db-172-16-3-150-&gt; vi test.sql</font></div><div><font size="2"   >\setrandom id 1 10000000</font></div><div><font size="2"   >select * from t_md5 where info=md5(:id::text);</font></div></div><div><div><font size="2"   >postgres@db-172-16-3-150-&gt; pgbench -M prepared -f ./test.sql -n -r -c 16 -j 8 -T 30</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 16</font></div><div><font size="2"   >number of threads: 8</font></div><div><font size="2"   >duration: 30 s</font></div><div><font size="2"   >number of transactions actually processed: 1944319</font></div><div><font size="2"   >latency average: 0.247 ms</font></div><div><font size="2"   >tps = 64809.373871 (including connections establishing)</font></div><div><font size="2"   >tps = 64833.546859 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.002463 &nbsp; &nbsp; &nbsp; &nbsp;\setrandom id 1 10000000</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.242614 &nbsp; &nbsp; &nbsp; &nbsp;select * from t_md5 where info=md5(:id::text);</font></div></div><div><font size="2"   ><br></font></div><div><div style="line-height: 28px;"   ><font size="2"   >postgres@db-172-16-3-150-&gt; vi test.sql</font></div><div style="line-height: 28px;"   ><font size="2"   >\setrandom id 1 10000000</font></div><div style="line-height: 28px;"   ><font size="2"   >select * from t_hashtext where info=hashtext(:id::text);</font></div></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   ><font size="2"   >postgres@db-172-16-3-150-&gt; pgbench -M prepared -f ./test.sql -n -r -c 16 -j 8 -T 30</font></div><div style="line-height: 28px;"   ><font size="2"   >transaction type: Custom query</font></div><div style="line-height: 28px;"   ><font size="2"   >scaling factor: 1</font></div><div style="line-height: 28px;"   ><font size="2"   >query mode: prepared</font></div><div style="line-height: 28px;"   ><font size="2"   >number of clients: 16</font></div><div style="line-height: 28px;"   ><font size="2"   >number of threads: 8</font></div><div style="line-height: 28px;"   ><font size="2"   >duration: 30 s</font></div><div style="line-height: 28px;"   ><font size="2"   >number of transactions actually processed: 2045818</font></div><div style="line-height: 28px;"   ><font size="2"   >latency average: 0.235 ms</font></div><div style="line-height: 28px;"   ><font size="2"   >tps = 68192.664950 (including connections establishing)</font></div><div style="line-height: 28px;"   ><font size="2"   >tps = 68217.163836 (excluding connections establishing)</font></div><div style="line-height: 28px;"   ><font size="2"   >statement latencies in milliseconds:</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.002492 &nbsp; &nbsp; &nbsp; &nbsp;\setrandom id 1 10000000</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.230370 &nbsp; &nbsp; &nbsp; &nbsp;select * from t_hashtext where info=hashtext(:id::text);</font></div></div><p></p></pre></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   >查询效率相差不大.</div></div><div>以上测试用到的主机2颗CPU&nbsp;Intel(R) Xeon(R) CPU &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; E5504 &nbsp;@ 2.00GHz，</div><div>系统为CentOS 6.x x64。</div><div><br></div>[参考]<wbr><div>1.&nbsp;src/backend/access/hash/hashfunc.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Datum</font></div><div><font size="2"   >hashtext(PG_FUNCTION_ARGS)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; text &nbsp; &nbsp; &nbsp; *key = PG_GETARG_TEXT_PP(0);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Datum &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Note: this is currently identical in behavior to hashvarlena, but keep</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* it as a separate function in case we someday want to do something</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* different in non-C locales. &nbsp;(See also hashbpchar, if so.)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; result = hash_any((unsigned char *) VARDATA_ANY(key),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(key));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Avoid leaking memory for toasted inputs */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(key, 0);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return result;</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >...</font></div><div><font size="2"   >/*<br> * hash_any() -- hash a variable-length key into a 32-bit value<br> *              k               : the key (the unaligned variable-length array of bytes)<br> *              len             : the length of the key, counting by bytes<br> *<br> * Returns a uint32 value.  Every bit of the key affects every bit of<br> * the return value.  Every 1-bit and 2-bit delta achieves avalanche.<br> * About 6*len+35 instructions. The best hash table sizes are powers<br> * of 2.  There is no need to do mod a prime (mod is sooo slow!).<br> * If you need less than 32 bits, use a bitmask.<br> *<br> * Note: we could easily change this function to return a 64-bit hash value<br> * by using the final values of both b and c.  b is perhaps a little less<br> * well mixed than c, however.<br> */<br>Datum<br>hash_any(register const unsigned char *k, register int keylen)<br>{</font></div><div><font size="2"   >......</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>2.&nbsp;src/backend/utils/adt/varlena.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Create an md5 hash of a text string and return it as hex</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* md5 produces a 16 byte (128 bit) hash; double it for hex</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >#define MD5_HASH_LEN &nbsp;32</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Datum</font></div><div><font size="2"   >md5_text(PG_FUNCTION_ARGS)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; text &nbsp; &nbsp; &nbsp; *in_text = PG_GETARG_TEXT_PP(0);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; size_t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;len;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hexsum[MD5_HASH_LEN + 1];</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* Calculate the length of the buffer using varlena metadata */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(in_text);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* get the hash result */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (pg_md5_hash(VARDATA_ANY(in_text), len, hexsum) == false)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_OUT_OF_MEMORY),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("out of memory")));</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* convert to text and return it */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(cstring_to_text(hexsum));</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>3. backend/libpq/md5.c</div><div>md5计算函数。</div><div>4.&nbsp;src/backend/access/common/indextuple.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Here we make sure that the size will fit in the field reserved for it</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* in t_info.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if ((size &amp; INDEX_SIZE_MASK) != size)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;errmsg("index row requires %zu bytes, maximum size is %zu",</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size, (Size) INDEX_SIZE_MASK)));</font></div><p></p></pre></div><div>5. src/include/access/itup.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >#define INDEX_SIZE_MASK 0x1FFF</font></div><div></div><p></p></pre></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="use md5 or hashtext? - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
	<h3>评论</h3>
	<div class="" id="" style="padding:0 20px;">
			<div id="">
				<h5 id="">aa - 2015-04-22 17:47:12</h5>
				<div><img src="http://b.bst.126.net/common/portrait/face/preview/face0.gif"  ></div>
			</div>
	</div>
</div>
</body>
</html>