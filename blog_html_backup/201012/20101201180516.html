<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL single-user mode usage,like Repair Database</h2>
	<h5 id="">2010-12-01 18:05:16&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201011152042497/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">PostgreSQL单用户模式通过以下语法来调用:<br>postgres --single -D $PGDATA db_name<br>可选选项:<br>-E <br>echo all commands<br>-j <br>Disables use of newline as a statement delimiter.<br>-r $FILENAME<br>Send all server log output to <tt><i>filename</i></tt>.  In normal multiuser         mode, this option is ignored, and <span>stderr</span> is         used by all processes.<br><br>单用户模式典型的应用,1.当多用户模式不接收所有命令时, 2.initdb时 3.修复系统表。<br>例如:<br>数据库中任何带relfrozenxid标记的记录,年龄不能超过2^31(二十亿);当数据库中存在年龄大于{(2^31)-1千万}的记录时,数据库将报类似如下提示:<br><pre>WARNING:  database "mydb" must be vacuumed within 177009986 transactions<br>HINT:  To avoid a database shutdown, execute a database-wide VACUUM in "mydb".<br>提示需要手工的消除这些警告,如果忽略不去处理的话,后面数据库可能需要关闭来处理,下面会提到.处理的方法是使用超级用户<br>VACUUM mydb.<br>(这里用到超级用户的原因是需要更新系统表的datfrozenxid列值)<br>如果忽略上面的警告,当数据库中存在年龄大于{(2^31)-1百万}的记录时,数据库将报类似如下错误:<br>ERROR:  database is not accepting commands to avoid wraparound data loss in database "mydb"<br>HINT:  Stop the postmaster and use a standalone backend to VACUUM in "mydb".<br>数据库将不再新建任何新的事务,只能通过单用户模式修复。<br>(100万被认为是一个比较安全的临界值,管理员可以在此年龄范围内对数据库进行VACUUM修复,)<br><br>单用户使用举例:<br># su - postgres<br>（确保数据库已经关闭）<br>$ postgres --single mydb_name<br><br>postgres@db-bak-192-168-105-35-&gt; postgres --single rmt_rescue<br>PostgreSQL stand-alone backend 9.0.1<br>backend&gt; vacuum full; (不带任何参数的VACUUM将对所有当前用户有权限的表进行操作)<br>backend&gt; Ctrl+D 退出单用户模式.<br><br><br>附录:<br>1. 查看表的年龄:<br>rmt_rescue=&gt; SELECT relname, age(relfrozenxid) FROM pg_class WHERE relname='tbl_test1';<br>  relname  | age <br>-----------+-----<br> tbl_test1 |  14<br>(1 row)<br><br>2. 查看数据库的年龄:<br>rmt_rescue=&gt; select datname,age(datfrozenxid) from pg_database;<br>  datname   |  age   <br>------------+--------<br> template1  |   8099<br> template0  | 676734<br> postgres   | 676734<br> rmt_rescue | 676734<br>(4 rows)<br><br>3. 查看表中记录的年龄:<br>rmt_rescue=&gt; select id,ctid,cmin,cmax,xmin,xmax,age(xmin),age(xmax) from tbl_test where id=1;<br> id | ctid  | cmin | cmax |  xmin  | xmax | age |    age     <br>----+-------+------+------+--------+------+-----+------------<br>  1 | (0,1) |    0 |    0 | 677333 |    0 |  53 | 2147483647<br>(1 row)<br>年龄=53<br>rmt_rescue=&gt; update tbl_test set name='test' where id=1;<br>UPDATE 1<br>rmt_rescue=&gt; select id,ctid,cmin,cmax,xmin,xmax,age(xmin),age(xmax) from tbl_test where id=1;<br> id |    ctid    | cmin | cmax |  xmin  | xmax | age |    age     <br>----+------------+------+------+--------+------+-----+------------<br>  1 | (4424,177) |    0 |    0 | 677387 |    0 |   1 | 2147483647<br>(1 row)<br>更新该记录后,年龄=1.<br><br>4. 年龄:<br>normal xid和当前事务id进行比较得到的一个值.SELECT语句也会增加数据库当前事务ID的值.<br>还有一种比较特殊的XID不参与比较,在任何状态下都被视为"in the past"状态，这就是frozenxid，使用vacuum freezen或vacuum且<br>当年龄大于vacuum_freeze_min_age时可以将tuple的XID转换为in the past状态，不过update后XID又会回到NORMAL状态.因此建议将<br>vacuum_freeze_min_age设置为: tuple从创建到不会被更新所经过的年龄是比较合适的.<br><br>5. age函数<br>                                            List of functions<br>   Schema   | Name | Result data type |                   Argument data types                    |  Type  <br>------------+------+------------------+----------------------------------------------------------+--------<br> pg_catalog | age  | interval         | timestamp with time zone                                 | normal<br> pg_catalog | age  | interval         | timestamp with time zone, timestamp with time zone       | normal<br> pg_catalog | age  | interval         | timestamp without time zone                              | normal<br> pg_catalog | age  | interval         | timestamp without time zone, timestamp without time zone | normal<br> pg_catalog | age  | integer          | xid                                                      | normal<br>(5 rows)<br><br>6.1 <br>vacuum<br>VACUUM 的NORMAL模式，只扫描含有DEAD TUPLES的PAGE，其他不扫描。（因此在没有DEAD TUPLES的PAGE中的年龄大于<br><a rel="nofollow" href="http://www.postgresql.org/docs/9.0/static/runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE"  >vacuum_freeze_min_age</a>的记录不会被FREEZE掉，当然在含有DEAD TUPLES中的年龄大于<br><a rel="nofollow" href="http://www.postgresql.org/docs/9.0/static/runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE"  >vacuum_freeze_min_age</a>的记录是被FREEZE掉的）<br><br>6.2<br>vacuum full<br>VACUUM的FULL模式，扫描所有PAGE。<br><br><br><br><br></pre></div>
	</div>
</div>
</body>
</html>