<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Increasing the OpLog Size in MongoDB(don't need full resync)</h2>
	<h5 id="">2010-12-06 18:22:55&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201011654535891/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">OpLog用于MongoDB数据库复制场合,特征:<br>1. 设置容量上限,<br>2. 循环使用<br>3. local数据库专用<br><br>对于MongoDB来说设置好适当的OpLog上限是非常有必要的，因为加大OpLog Size需要重启Master和Slave数据库，并且Slave数据库需要重新同步(full sync).<br>如果不做FULL SYNC，看看会出现什么样的情况:<br>MASTER:<br>[root@db6 data1]# /opt/mongodb-linux-x86_64-1.6.4/bin/mongo 127.0.0.1:5282/test<br>MongoDB shell version: 1.6.4<br>connecting to: 127.0.0.1:5282/test<br>&gt; db.tbl_test.insert({"id":2,"name":"digoal"})&nbsp;&nbsp;&nbsp;&nbsp; <br>&gt; exit<br>bye<br><br>SlAVE<br>[root@db6 data1]# /opt/mongodb-linux-x86_64-1.6.4/bin/mongo 127.0.0.1:5283/test<br>MongoDB shell version: 1.6.4<br>connecting to: 127.0.0.1:5283/test<br>&gt; db.tbl_test.find()<br>{ "_id" : ObjectId("4cfcbbffb405701a1a121820"), "id" : 1, "name" : "digoal.zhou" }<br>已经无法完成同步:<br>分析原因:<br>MASTER:<br>&gt; db.printReplicationInfo()&nbsp;&nbsp;&nbsp;&nbsp; <br>configured oplog size:&nbsp;&nbsp; 990MB<br>log length start to end: 91secs (0.03hrs)<br>oplog first event time:&nbsp; Mon Dec 06 2010 18:38:14 GMT+0800 (CST)<br>oplog last event time:&nbsp;&nbsp; Mon Dec 06 2010 18:39:45 GMT+0800 (CST)<br>now:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mon Dec 06 2010 18:39:52 GMT+0800 (CST)<br>&gt; exit<br><br>SLAVE:<br>&gt; db.printSlaveReplicationInfo()<br>source:&nbsp;&nbsp; db6:5282<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syncedTo: Mon Dec 06 2010 18:34:41 GMT+0800 (CST)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 286secs ago (0.08hrs)<br>&gt; exit<br>bye<br>时间已经错过了,取不到所要的数据.<br>解决办法:<br>(首先确保MASTER SLAVE在关闭时数据是一致的，否则数据还是会有问题)<br>在删除OpLog后，启动MASTER前调整MASTER服务器的时间到db.printSlaveReplicationInfo()输出的时间之前(Mon Dec 06 2010 18:34:41 GMT+0800 (CST)),这样的话启动MASTER得到的db.printReplicationInfo()时间会比SLAVE需要的时间早,数据会继续同步.确认同步后再把两台服务器的时间同步一下.以正确的时间为准.（OPLOG里面是存储时间戳的,oplog.$main具体的字段如下）<br>ts<br>Timestamp for the operation. The timestamp type is an internal type used to track<br>when operations are performed. It is composed of a 4-byte timestamp and a 4-byte<br>incrementing counter.<br>op<br>Type of operation performed as a 1-byte code (e.g., “i” for an insert).<br>ns<br>Namespace (collection name) where the operation was performed.<br>o<br>Document further specifying the operation to perform. For an insert, this would<br>be the document to insert.<br><br><br>加大OpLog Size的几个原因分析:<br>1. Slave长时间Down机或与Master断开连接，超过OpLog轮循时间。<br>&nbsp;如，在SLAVE节点执行<br>&gt; db.printSlaveReplicationInfo();<br>&nbsp;&nbsp;&nbsp; source:&nbsp;&nbsp; localhost:27017<br>&nbsp;&nbsp;&nbsp; syncedTo: Tue Mar 30 2010 16:44:01 GMT-0400 (EDT)<br>&nbsp;&nbsp;&nbsp; = 12secs ago (0hrs)<br>同步截至12秒前。如果OpLog中最早的记录 比 Tue Mar 30 2010 16:44:01 GMT-0400 (EDT)&nbsp; 还要新的话,完蛋,需要做full sync。<br>2. SLAVE数据库做FULL SYNC的时间过长，超过了OpLog可以容纳的操作时间。<br>如: 在SLAVE数据库使用如下命令开始从master数据库full sync : <br>&gt; use admin <br>&gt; db.runCommand({resync: 1}) <br>或 调用--autoresync参数重启SLAVE: mongod --slave --autoresync <br><br><span style="font-weight: bold;">例 : 增加OpLog SIZE<br><br></span>1. 查看Master OpLog Size<br><pre>&gt; db.printReplicationInfo();<br>configured oplog size:   1048.576MB<br>log length start to end: 7200secs (2hrs)<br>oplog first event time:  Wed Mar 03 2010 16:20:39 GMT-0500 (EST)<br>oplog last event time:   Wed Mar 03 2010 18:20:39 GMT-0500 (EST)<br>now:                     Wed Mar 03 2010 18:40:34 GMT-0500 (EST)<br><br>2. 关闭master mongod<br>$ # Stop mongod - killall mongod or kill -2 or ctrl-c) - then:<br>$ rm /data/db/local.*<br>$ mongod --oplog=8038 --master<br>加到8G<br><br>3. 重启slave<br>mongod --slave --autoresync<br><br>例 :  Manually Allocating OpLog Files<br>MongoDB允许在数据库开启前先手工分配OpLog 文件.可能是出于文件在DISK上存储连续性的考虑吧.(猜测)<br>1. 生成文件 (20GB)<br>cd /tmp/local<br>  <span>for</span> i in {0..9}<br>      <span>do</span><br>      echo $i<br>      head -c 2146435072 /dev/zero &gt; local.$i<br>      done<br></pre>Note that the datafiles aren't exactly 2GB due MongoDB's max int size.<br><br>2. 关闭master mongodb<br><br>3. 移动文件 (假设$MONGODB = /data/db )<br><pre>$ mv /data/db/local.* /safe/place<br>$ mv /tmp/local/* /data/db/</pre>4. 重启master<br><pre>$ mongod --master --oplogSize=20000</pre>5. Finally, resync the slave. This can be done by shutting down the slave, deleting all its datafiles, and restarting it.</div>
	</div>
</div>
</body>
</html>