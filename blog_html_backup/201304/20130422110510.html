<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL use array reduce log table's storage requirement</h2>
	<h5 id="">2013-04-22 11:05:10&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201332210920390/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>本文主要讲解一个使用数组来降低冗余数据的案例.</div>举一个例子, 终端的应用程序列表, 每个终端在启动时将程序列表信息汇总到数据库中.<div>数据结构如下 :&nbsp;</div><div><pre class="prettyprint"   ><p><font size="2"   >create table t(id serial8, user_id int8, app_name text, startup_time timestamp, crt_time timestamp);</font></p></pre></div><div>对于一个用户来说, 如果启动了100个应用, 那么每次汇总的时候需要上传100条数据.&nbsp;</div><div>-- 插入测试数据1000100条.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >insert into t(user_id, app_name, startup_time, crt_time) select generate_series(1,10001),md5((random()*generate_series(1,100))::text), clock_timestamp(),now();</font></div><div><font size="2"   >INSERT 0 1000100</font></div><p></p></pre></div><div>-- 每个用户每次启动时对应100条.</div><div>-- 创建索引</div><div><pre class="prettyprint"   ><p><font size="2"   >create index idx_t_1 on t(user_id);</font></p></pre></div><div>-- 表和索引大小</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select pg_relation_size('t');</font></div><div><font size="2"   >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; <span style="line-height: 19px;"   >101146624</span></font></div><div><font size="2"   >(1 row)</font></div><div><div><font size="2"   >postgres=# select pg_relation_size('idx_t_1');</font></div><div><font size="2"   >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="line-height: 19px;"   >30081024</span></font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div><br></div><div>-- 如果使用数组来存储app_name和startup_time. 将改成如下表结构 :&nbsp;</div><div><pre class="prettyprint"   ><p><font size="2"   >create table t_agg(id serial8, user_id int8, app_name text[], startup_time timestamp[], crt_time timestamp);</font></p></pre></div><div>-- 将以上数据聚合以后插入t_agg表.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >insert into t_agg(user_id,app_name,startup_time,crt_time) select user_id,array_agg(app_name order by startup_time),array_agg(startup_time order by startup_time),crt_time from t group by user_id,crt_time;</font></div><div><font size="2"   >INSERT 0 10001</font></div><p></p></pre></div><div><div style="line-height: 22px;"   >-- 每个用户每次启动时对应1条.</div><div style="line-height: 22px;"   >-- 创建索引</div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p><font size="2"   >create index idx_t_agg_1 on t_agg(user_id);</font></p></pre></div><div style="line-height: 22px;"   >-- 表和索引大小</div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select pg_relation_size('t_agg');</font></div><div><font size="2"   >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 9109504</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >postgres=# select pg_relation_size('idx_t_agg_1');</font></div><div><font size="2"   >&nbsp;pg_relation_size&nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;245760</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>-- 使用数组存储后, 表和索引占用空间分别为原来的9%, 0.8%.</div><div>-- 根据user_id进行查询的性能将得到提升.</div><div><span style="line-height: 22px;"   >-- 原结构需要扫描103个数据块.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain (analyze,verbose,buffers) select * from t where user_id=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_t_1 on public.t &nbsp;(cost=0.00..4482.19 rows=5309 width=64) (actual time=0.014..0.092 rows=100 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, user_id, app_name, startup_time, crt_time</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (t.user_id = 1)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=103</font></div><div><font size="2"   >&nbsp;Total runtime: 0.121 ms</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div>-- 改成数组后只需要扫描3个数据块.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain (analyze,verbose,buffers) select * from t_agg where user_id=1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------------------------------------------------------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Scan using idx_t_agg_1 on public.t_agg &nbsp;(cost=0.00..51.13 rows=50 width=88) (actual time=0.009..0.010 rows=1 loops=1)</font></div><div><font size="2"   >&nbsp; &nbsp;Output: id, user_id, app_name, startup_time, crt_time</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (t_agg.user_id = 1)</font></div><div><font size="2"   >&nbsp; &nbsp;Buffers: shared hit=3</font></div><div><font size="2"   >&nbsp;Total runtime: 0.029 ms</font></div><div><font size="2"   >(5 rows)</font></div><p></p></pre></div><div><br></div><div>[小结<span style="line-height: 22px;"   >]</span></div><div><span style="line-height: 22px;"   >1. 本场景使用数组存储后, 减少了数据冗余. 除了可以降低存储开销, 同时也降低了内存的开销. 提高了查询性能.</span></div><div><span style="line-height: 22px;"   ><br></span></div><wbr></div></div>
	</div>
</div>
</body>
</html>