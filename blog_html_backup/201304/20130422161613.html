<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL notreal-time insert-only count(*) performance tuning case - 6</h2>
	<h5 id="">2013-04-22 16:16:13&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020133224161563/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">前五篇关于PostgreSQL实时和非实时数据统计的案例如下 :&nbsp;<div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201331252945440/"   >http://blog.163.com/digoal@126/blog/static/163877040201331252945440/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020133151402415/"   >http://blog.163.com/digoal@126/blog/static/16387704020133151402415/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020133155179877/"   >http://blog.163.com/digoal@126/blog/static/16387704020133155179877/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020133156636579/"   >http://blog.163.com/digoal@126/blog/static/16387704020133156636579/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020133218305242/"   >http://blog.163.com/digoal@126/blog/static/16387704020133218305242/</a></div><div>本文主要添加一个动态的新增统计维度的功能.</div><div><div>【详细的实施过程如下 : 】</div><div>-- # 测试表 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create table log&nbsp;</font></div><div><font size="2"   >(</font></div><div><font size="2"   >&nbsp; id serial primary key,&nbsp;</font></div><div><font size="2"   >&nbsp; xid int8 default txid_current() not null,&nbsp;</font></div><div><font size="2"   >&nbsp; c1 int not null,&nbsp;</font></div><div><font size="2"   >&nbsp; c2 int not null,&nbsp;</font></div><div><font size="2"   >&nbsp; c3 int not null,&nbsp;</font></div><div><font size="2"   >&nbsp; c4 text not null,&nbsp;</font></div><div><font size="2"   >&nbsp; crt_time timestamp default now()</font></div><div><font size="2"   >);</font></div><div><font size="2"   >create index idx_log_1 on log(xid);</font></div><p></p></pre></div><div><br></div><div>-- # 存放count(*)的表, 假设经常需要按log.c1以及log.crt_time分天, 周, 月, 年进行count(*)</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create table log_c1_cnt_day (c1 int, cnt int8, stat_time text, primary key(c1,stat_time));</font></div><div><font size="2"   >create table log_c1_cnt_week (c1 int, cnt int8, stat_time text, primary key(c1,stat_time));</font></div><div><font size="2"   >create table log_c1_cnt_month (c1 int, cnt int8, stat_time text, primary key(c1,stat_time));</font></div><div><font size="2"   >create table log_c1_cnt_year (c1 int, cnt int8, stat_time text, primary key(c1,stat_time));</font></div><p></p></pre></div><div><br></div><div>-- # 存放count(*)的表, 假设经常需要按log.c2, log.c3以及log.crt_time分天, 周, 月, 年进行count(*)</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create table log_c2_c3_cnt_day (c2 int, c3 int, cnt int8, stat_time text, primary key(c2,c3,stat_time));</font></div><div><font size="2"   >create table log_c2_c3_cnt_week (c2 int, c3 int, cnt int8, stat_time text, primary key(c2,c3,stat_time));</font></div><div><font size="2"   >create table log_c2_c3_cnt_month (c2 int, c3 int, cnt int8, stat_time text, primary key(c2,c3,stat_time));</font></div><div><font size="2"   >create table log_c2_c3_cnt_year (c2 int, c3 int, cnt int8, stat_time text, primary key(c2,c3,stat_time));</font></div><p></p></pre></div><div><br></div><div>-- 插入测试数据</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >insert into log (c1,c2,c3,c4) values (1,1,1,1);</font></div><div><font size="2"   >insert into log (c1,c2,c3,c4) values (2,2,2,2);</font></div><p></p></pre></div><div><br></div><div>-- 验证</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from log;</font></div><div><font size="2"   >&nbsp;id | &nbsp; &nbsp;xid &nbsp; &nbsp;| c1 | c2 | c3 | c4 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----+-----------+----+----+----+----+----------------------------</font></div><div><font size="2"   >&nbsp; 1 | 480125659 | &nbsp;1 | &nbsp;1 | &nbsp;1 | 1 &nbsp;| 2013-04-21 20:55:45.907713</font></div><div><font size="2"   >&nbsp; 2 | 480125660 | &nbsp;2 | &nbsp;2 | &nbsp;2 | 2 &nbsp;| 2013-04-21 20:55:46.286933</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div><br></div><div>-- # 创建分析注册表, 记录每个明细表每次分析的截止xid, xip.</div><div>-- # xid 记录统计到哪个xid了, xip记录当前活动事务, 不计入当前统计范畴. 避免气泡问题.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 19px;"   >create table log_read <br>(<br>tablename name not null, <br>xid int8 not null, <br>xip int8[], <br>xip_res int8[],  -- 用于与xid比对的数据. 必须保留所有&gt;=xid的xip信息.<br>mod_time timestamp, <br>primary key (tablename)<br>);</span></font></div><p></p></pre></div><div>-- # 插入初始记录, 表的初始记录xid取值范围( &gt;=0 and &lt;=txid_snapshot_xmin-1 )</div><div><pre class="prettyprint"   ><p><font size="2"   ><span style="line-height: 19px;"   >insert into log_read values ('log', 0, null, null, now());</span></font></p></pre></div><div><br></div><div>-- # 创建分析维度信息注册表, 记录每个维度的初始xid信息,&nbsp;</div><div>-- # 因为所有维度使用同一个表级别的截至值(log_read.xid), 但是维度可能是后期加入的, 所以初始xid可能不一样.</div><div>-- # 增加func 字段. tablename+func组合pk.</div><div>-- # 增加初始init_xid字段. ( 历史数据的统计交给其他进程来处理, 历史数据将统计到 &lt;=init_xid and 不包含init_xip )</div><div>-- # 增加isinit字段, &nbsp;标识是否为新加的维度.</div><div>-- # 增加func 字段, 标识该维度调用的函数.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 19px;"   >create table log_read_func (<br>  tablename name not null, <br>  func text not null,  -- 统计函数名<br>  init_xid int8,  -- 初始值由analyze_log计算并更新.<br>  init_xip int8[],  -- 初始值由analyze_log计算并更新.<br>  isinit boolean not null,  -- true标识这个维度是初始的, false标识不是初始的.<br>  info text,  -- 备注<br>  primary key (tablename, func)<br>);<br>alter table log_read_func add constraint fk_log_read_func_1 foreign key(tablename) references log_read(tablename);</span></font></div><p></p></pre></div><div>-- # 插入维度初始记录</div><div><pre class="prettyprint"   ><p><font size="2"   ><span style="line-height: 19px;"   >insert into log_read_func(tablename,func,init_xid,init_xip,isinit,info) <br>  values('log','stat_log_c1',null,null,true,null);</span></font></p></pre></div><div><br></div><div>-- # 创建log表的串行批量数据分析函数</div><div>-- 注意v_limit用于限制多少个xid, 而不是多少条记录, 当一个XID有多条记录时, 如果取到这个XID的话, 这个XID的数据也会全部被处理.</div><div>-- 但是如果使用v_limit来限定行数, 就会出现比较危险的情况, 因为如果一个事务包含多条记录的话, 限定行数的方法可能导致一个事务的数据只取到中间部分, 而剩余部分下次就取不到了.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 19px;"   >create or replace function analyze_log(v_limit int) returns void as $$<br>declare<br>  v_advisory_xact_lock int8 := null;  -- 串行处理锁.<br>  <br>  v_xid_snap txid_snapshot := null;  -- 当前事务状态快照<br>  v_xmin int8 := null;  -- 当前事务状态快照中未完成的最小事务<br>  v_xmax int8 := null;  -- 当前事务状态快照中未分配的最小事务<br>  v_xip int8[] := null;  -- 当前事务状态快照中未完成的事务数组<br><br>  v_func_agg text[];  -- 统计维度函数数组<br>  v_func text;  -- 统计维度函数<br><br>  v_log_read_log_xid int8 := null;  -- 上次log的xid分析截止位<br>  v_log_read_log_xid_update int8 := null;  -- 更新值, 不能为空<br><br>  v_log_read_log_xip int8[] := null;  -- 上次log_read.xip(tablename=log)<br>  v_log_read_log_xip_do int8[] := null;  -- 解析本次log_read.xip(tablename=log) where (xip !@ txid_snapshot)<br>  v_log_read_log_xip_update int8[] := null;  -- xip更新值<br>  v_log_read_log_xip_res int8[] := null;  -- xip保留值<br>  v_log_read_log_xip_res_update int8[] := null;  -- xip保留更新值, 所有大于v_log_read_log_xid_update的元素必须保留.<br><br>  v_log log[] := null;  -- 聚合本次log的分析数组, [末尾调用,false]<br>  v_log_doxip log[] := null;  -- 聚合本次分析log数组: <br>                          -- where log.xid (@ log_read.xip(tablename=log) and !@ txid_snapshot) , [末尾调用,false]<br><br>  v_log_read_func_xid int8;  -- 本次取出的v_log中的最小xid-1, 没有则取OLD.log_read.xid. [用于更新log_read_func.init_xid where isinit=true] <br>  v_log_read_func_xip int8[];  -- (OLD.log_read.xip + v_xip) ; [用于更新log_read_func.init_xip where isinit=true] <br><br>begin<br>  -- 判断limit<br>  if v_limit &lt;=0 then<br>    raise notice 'please ensure v_limit &gt; 0 .';<br>    return;<br>  end if;<br><br>  -- 串行处理, 如果不能获得锁则直接退出. 确保v_advisory_xact_lock全局唯一.<br>  v_advisory_xact_lock := 1;<br>  if not pg_try_advisory_xact_lock(v_advisory_xact_lock) then<br>    raise notice 'Another function is calling, this call will exit.';<br>    return;<br>  end if;<br><br>  -- 生成统计维度, 没有则直接退出<br>  perform 1 from log_read_func where tablename='log' limit 1;<br>  if not found then<br>    raise notice 'No func in log_read_func with tablename:%.', 'log';<br>    return;<br>  else<br>    select array_agg(func) into v_func_agg from log_read_func where tablename='log';<br>  end if;<br><br>  -- 生成 xid snapshot 数据.<br>  v_xid_snap := txid_current_snapshot();<br>  v_xmin := txid_snapshot_xmin(v_xid_snap);<br>  v_xmax := txid_snapshot_xmax(v_xid_snap);<br>  select array_agg(t) into v_xip from txid_snapshot_xip(v_xid_snap) g(t);<br><br>  -- 取v_log_read_log_xid截止值, v_log_read_log_xip数组.<br>  select xid,xip,xip_res into v_log_read_log_xid,v_log_read_log_xip,v_log_read_log_xip_res from log_read where tablename='log';<br>  if not found then<br>    raise notice 'log_read no log entry. please add it in log_read table first.';<br>    return;<br>  end if;<br><br>  -- 生成v_log_read_func_xip.<br>  -- 必须放在更新log_read之前, 否则取到的就是更新后的数据了.<br>  v_log_read_func_xip := array_cat(v_log_read_log_xip, v_xip);<br><br>  -- 取log1(取非xip中的数据, 隔离log2操作)<br>  -- 取xid临界点<br>  select max(xid) into v_log_read_log_xid_update from (select xid from log where xid &gt; v_log_read_log_xid and xid &lt; v_xmax and xid not in (select * from unnest(v_xip) union all select * from unnest(v_log_read_log_xip_res)) order by xid limit v_limit) t;<br>  if v_log_read_log_xid_update is not null then<br>    raise notice '取log1';<br>    -- 根据临界点, 取log数据<br>    select array_agg(log) into v_log from (select log from log where xid &gt; v_log_read_log_xid and xid&lt;=v_log_read_log_xid_update and xid not in (select * from unnest(v_xip) union all select * from unnest(v_log_read_log_xip_res)) order by xid) t;<br>    -- 如果有数据, v_log_read_func_xid取v_log.min(xid) - 1<br>    select min(i.xid) - 1 into v_log_read_func_xid from unnest(v_log) i;<br>  else <br>    -- 如果没有数据, 更新值不变<br>    v_log_read_log_xid_update := v_log_read_log_xid;<br>    -- 如果没有数据, v_log_read_func_xid取OLD.log_read.xid<br>    v_log_read_func_xid := v_log_read_log_xid;<br>  end if;<br><br>  -- 取log2 (log_xip - v_xip) (取xip中的数据, 隔离log1操作)<br>  -- 生成log_read.xip(tablename=log) do数组(已经完成的事务)<br>  select array_agg(i) into v_log_read_log_xip_do from (select * from unnest(v_log_read_log_xip) i except select * from unnest(v_xip))t where i is not null;<br>  -- 生成log_read.xip(tablename=log) update数组(未完成的事务)<br>  select array_agg(i) into v_log_read_log_xip_update from <br>  (  select i from (select * from unnest(v_log_read_log_xip) i union all select * from unnest(v_xip)<br>     except select * from unnest(v_log_read_log_xip_do)) t where i is not null group by i ) t;<br>  -- 生成xip_res更新值<br>  select array_agg(i) into v_log_read_log_xip_res_update from (select * from unnest(v_log_read_log_xip_res) i union select * from unnest(v_log_read_log_xip) union select * from unnest(v_xip))t where i&gt;v_log_read_log_xid_update;<br>  -- 生成log do数组<br>  select array_agg(log) into v_log_doxip from log where xid in (select * from unnest(v_log_read_log_xip_do));<br><br>  -- 更新log_read(tablename=log)<br>  update log_read set <br>    xip=v_log_read_log_xip_update, <br>    xid=v_log_read_log_xid_update, <br>    xip_res=v_log_read_log_xip_res_update,<br>    mod_time=now() <br>  where tablename='log';<br>  -- raise notice 'log_read.oldxip(log): %.', v_log_read_log_xip;<br>  -- raise notice 'log_read.newxip(log): %.', v_log_read_log_xip_update;<br>  -- raise notice 'log_read.newxipres(log): %.', v_log_read_log_xip_res_update;<br><br>  -- 分析函数可以另外写, 在此调用.<br>  foreach v_func in array v_func_agg loop<br>    -- 更新log_read_func where isinit=true<br>    update log_read_func set <br>      init_xid=v_log_read_func_xid,<br>      init_xip=v_log_read_func_xip,<br>      isinit=false <br>      where tablename='log' <br>      and func=v_func <br>      and isinit;<br>    -- 执行统计函数<br>    execute 'select '||v_func||'($1)' using v_log;<br>    execute 'select '||v_func||'($1)' using v_log_doxip;<br>  end loop;<br><br>return;<br>end;<br>$$ language plpgsql;</span></font></div><p></p></pre></div><div><br></div><div>-- # 统计函数stat_log_c1</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE OR REPLACE FUNCTION public.stat_log_c1(v_log log[])</font></div><div><font size="2"   >&nbsp;RETURNS void</font></div><div><font size="2"   >&nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >AS $function$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; v_stat_time text;</font></div><div><font size="2"   >&nbsp; v_c1 int;</font></div><div><font size="2"   >&nbsp; v_cnt int8;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; -- 统计log_c1_cnt_day</font></div><div><font size="2"   >&nbsp; for v_stat_time, v_c1, v_cnt in select to_char(crt_time, 'yyyymmdd'), c1 , count(*) from (select ((unnest(v_log)::log)).*) t group by to_char(crt_time, 'yyyymmdd'), c1 loop</font></div><div><font size="2"   >&nbsp; &nbsp; perform 1 from log_c1_cnt_day where c1=v_c1 and stat_time=v_stat_time;</font></div><div><font size="2"   >&nbsp; &nbsp; if not found then</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; insert into log_c1_cnt_day(c1, cnt, stat_time) values (v_c1, v_cnt, v_stat_time);</font></div><div><font size="2"   >&nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; update log_c1_cnt_day set cnt=cnt+v_cnt where c1=v_c1 and stat_time=v_stat_time;</font></div><div><font size="2"   >&nbsp; &nbsp; end if;</font></div><div><font size="2"   >&nbsp; end loop;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$function$;</font></div><p></p></pre></div><div><br></div><div>-- # 测试, 清理原始数据</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 19px;"   >truncate log;<br>truncate log_c1_cnt_day;<br>truncate log_c1_cnt_week;<br>update log_read set xid=0, xip=null, xip_res=null;<br>update log_read_func set isinit=true;</span></font></div><p></p></pre></div><div><br></div><div>-- # pgbench脚本, 测试插入场景</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >cat ins.sql&nbsp;</font></div><div><font size="2"   >insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><p></p></pre></div><div><br></div><div>-- # pgbench</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg92@digoal-PowerEdge-R610-&gt; pgbench -M prepared -f ./ins.sql -r -n -h $PGDATA -U postgres -T 60 -c 8 -j 2</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 8</font></div><div><font size="2"   >number of threads: 2</font></div><div><font size="2"   >duration: 60 s</font></div><div><font size="2"   >number of transactions actually processed: 2940924</font></div><div><font size="2"   >tps = 49015.188418 (including connections establishing)</font></div><div><font size="2"   >tps = 49026.219678 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.161868 &nbsp; &nbsp; &nbsp; &nbsp;insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><p></p></pre></div><div><br></div><div><div>-- # 压力测试的同时执行analyze_log. 确保pgbench同时执行analyze_log.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg92@digoal-PowerEdge-R610-&gt; cat analyze.sh&nbsp;</font></div><div><font size="2"   >#!/bin/bash</font></div><div><font size="2"   >for ((i=0;i&lt;100;i++))</font></div><div><font size="2"   >do</font></div><div><font size="2"   >psql -c "select * from analyze_log(1);"</font></div><div><font size="2"   >psql -c "select * from analyze_log(1000000);"</font></div><div><font size="2"   >done</font></div><div><font size="2"   ># 调用analyze.sh</font></div><p></p></pre></div></div><div><br><p></p></div><div>-- # 验证数据是否准确</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select c1,count(*),to_char(crt_time,'yyyymmdd') from log group by c1,to_char(crt_time,'yyyymmdd') order by c1;</font></div><div><font size="2"   >&nbsp;c1 | count &nbsp;| to_char &nbsp;</font></div><div><font size="2"   >----+--------+----------</font></div><div><font size="2"   >&nbsp; 0 | 147225 | 20130422</font></div><div><font size="2"   >&nbsp; 1 | 294651 | 20130422</font></div><div><font size="2"   >&nbsp; 2 | 294146 | 20130422</font></div><div><font size="2"   >&nbsp; 3 | 293377 | 20130422</font></div><div><font size="2"   >&nbsp; 4 | 295507 | 20130422</font></div><div><font size="2"   >&nbsp; 5 | 294433 | 20130422</font></div><div><font size="2"   >&nbsp; 6 | 293960 | 20130422</font></div><div><font size="2"   >&nbsp; 7 | 292733 | 20130422</font></div><div><font size="2"   >&nbsp; 8 | 294489 | 20130422</font></div><div><font size="2"   >&nbsp; 9 | 293249 | 20130422</font></div><div><font size="2"   >&nbsp;10 | 147154 | 20130422</font></div><div><font size="2"   >(11 rows)</font></div><div><font size="2"   >Time: 6453.502 ms</font></div><div><font size="2"   >digoal=# select * from log_c1_cnt_day where cnt&lt;&gt;0 order by c1;</font></div><div><font size="2"   >&nbsp;c1 | &nbsp;cnt &nbsp; | stat_time&nbsp;</font></div><div><font size="2"   >----+--------+-----------</font></div><div><font size="2"   >&nbsp; 0 | 147225 | 20130422</font></div><div><font size="2"   >&nbsp; 1 | 294651 | 20130422</font></div><div><font size="2"   >&nbsp; 2 | 294146 | 20130422</font></div><div><font size="2"   >&nbsp; 3 | 293377 | 20130422</font></div><div><font size="2"   >&nbsp; 4 | 295507 | 20130422</font></div><div><font size="2"   >&nbsp; 5 | 294433 | 20130422</font></div><div><font size="2"   >&nbsp; 6 | 293960 | 20130422</font></div><div><font size="2"   >&nbsp; 7 | 292733 | 20130422</font></div><div><font size="2"   >&nbsp; 8 | 294489 | 20130422</font></div><div><font size="2"   >&nbsp; 9 | 293249 | 20130422</font></div><div><font size="2"   >&nbsp;10 | 147154 | 20130422</font></div><div><font size="2"   >(11 rows)</font></div><div><font size="2"   >Time: 0.660 ms</font></div><p></p></pre></div><div><br></div><div>-- # 测试多SQL, 带回滚场景.</div><div>-- # pgbench脚本</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >cat ins.sql</font></div><div><font size="2"   >begin;</font></div><div><font size="2"   >insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >begin;</font></div><div><font size="2"   >insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >rollback;</font></div><div><font size="2"   >insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div></pre></div><div>-- # pgbench</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg92@digoal-PowerEdge-R610-&gt; pgbench -M prepared -f ./ins.sql -r -n -h $PGDATA -U postgres -T 60 -c 8 -j 2</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 8</font></div><div><font size="2"   >number of threads: 2</font></div><div><font size="2"   >duration: 60 s</font></div><div><font size="2"   >number of transactions actually processed: 394520</font></div><div><font size="2"   >tps = 6573.363077 (including connections establishing)</font></div><div><font size="2"   >tps = 6574.835673 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.057675 &nbsp; &nbsp; &nbsp; &nbsp;begin;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.152981 &nbsp; &nbsp; &nbsp; &nbsp;insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.148598 &nbsp; &nbsp; &nbsp; &nbsp;insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.076637 &nbsp; &nbsp; &nbsp; &nbsp;end;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.054797 &nbsp; &nbsp; &nbsp; &nbsp;begin;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.153712 &nbsp; &nbsp; &nbsp; &nbsp;insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.148711 &nbsp; &nbsp; &nbsp; &nbsp;insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.077051 &nbsp; &nbsp; &nbsp; &nbsp;rollback;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.168767 &nbsp; &nbsp; &nbsp; &nbsp;insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.167405 &nbsp; &nbsp; &nbsp; &nbsp;insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><p></p></pre></div><div><br></div><div><div>-- # 压力测试的同时执行analyze_log. 确保pgbench同时执行analyze_log.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg92@digoal-PowerEdge-R610-&gt; cat analyze.sh&nbsp;</font></div><div><font size="2"   >#!/bin/bash</font></div><div><font size="2"   >for ((i=0;i&lt;100;i++))</font></div><div><font size="2"   >do</font></div><div><font size="2"   >psql -c "select * from analyze_log(1);"</font></div><div><font size="2"   >psql -c "select * from analyze_log(1000000);"</font></div><div><font size="2"   >done</font></div><div><font size="2"   ># 调用analyze.sh</font></div><p></p></pre></div></div><div><p></p></div><div><span style="line-height: 22px;"   >-- # 验证数据是否准确</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select c1,count(*),to_char(crt_time,'yyyymmdd') from log group by c1,to_char(crt_time,'yyyymmdd') order by c1;</font></div><div><font size="2"   >&nbsp;c1 | count &nbsp;| to_char &nbsp;</font></div><div><font size="2"   >----+--------+----------</font></div><div><font size="2"   >&nbsp; 0 | 206061 | 20130422</font></div><div><font size="2"   >&nbsp; 1 | 412799 | 20130422</font></div><div><font size="2"   >&nbsp; 2 | 411847 | 20130422</font></div><div><font size="2"   >&nbsp; 3 | 409796 | 20130422</font></div><div><font size="2"   >&nbsp; 4 | 411644 | 20130422</font></div><div><font size="2"   >&nbsp; 5 | 412170 | 20130422</font></div><div><font size="2"   >&nbsp; 6 | 410857 | 20130422</font></div><div><font size="2"   >&nbsp; 7 | 411128 | 20130422</font></div><div><font size="2"   >&nbsp; 8 | 411509 | 20130422</font></div><div><font size="2"   >&nbsp; 9 | 411140 | 20130422</font></div><div><font size="2"   >&nbsp;10 | 205053 | 20130422</font></div><div><font size="2"   >(11 rows)</font></div><div><font size="2"   >Time: 8760.367 ms</font></div><div><font size="2"   >digoal=# select * from log_c1_cnt_day where cnt&lt;&gt;0 order by c1;</font></div><div><font size="2"   >&nbsp;c1 | &nbsp;cnt &nbsp; | stat_time&nbsp;</font></div><div><font size="2"   >----+--------+-----------</font></div><div><font size="2"   >&nbsp; 0 | 206061 | 20130422</font></div><div><font size="2"   >&nbsp; 1 | 412799 | 20130422</font></div><div><font size="2"   >&nbsp; 2 | 411847 | 20130422</font></div><div><font size="2"   >&nbsp; 3 | 409796 | 20130422</font></div><div><font size="2"   >&nbsp; 4 | 411644 | 20130422</font></div><div><font size="2"   >&nbsp; 5 | 412170 | 20130422</font></div><div><font size="2"   >&nbsp; 6 | 410857 | 20130422</font></div><div><font size="2"   >&nbsp; 7 | 411128 | 20130422</font></div><div><font size="2"   >&nbsp; 8 | 411509 | 20130422</font></div><div><font size="2"   >&nbsp; 9 | 411140 | 20130422</font></div><div><font size="2"   >&nbsp;10 | 205053 | 20130422</font></div><div><font size="2"   >(11 rows)</font></div><div><font size="2"   >Time: 0.716 ms</font></div><p></p></pre></div><div><br></div><div>-- # 新增测试项目, 增加统计维度.</div><div>-- # 统计函数stat_log_c1_week</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >CREATE OR REPLACE FUNCTION public.stat_log_c1_week(v_log log[])</font></div><div><font size="2"   >&nbsp;RETURNS void</font></div><div><font size="2"   >&nbsp;LANGUAGE plpgsql</font></div><div><font size="2"   >AS $function$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; v_stat_time text;</font></div><div><font size="2"   >&nbsp; v_c1 int;</font></div><div><font size="2"   >&nbsp; v_cnt int8;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; -- 统计log_c1_cnt_week</font></div><div><font size="2"   >&nbsp; for v_stat_time, v_c1, v_cnt in select to_char(date(crt_time)-(EXTRACT(ISODOW FROM date(crt_time)))::int+1,'yyyymmdd'), c1 , count(*) from (select ((unnest(v_log)::log)).*) t group by to_char(date(crt_time)-(EXTRACT(ISODOW FROM date(crt_time)))::int+1,'yyyymmdd'), c1 loop</font></div><div><font size="2"   >&nbsp; &nbsp; perform 1 from log_c1_cnt_week where c1=v_c1 and stat_time=v_stat_time;</font></div><div><font size="2"   >&nbsp; &nbsp; if not found then</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; insert into log_c1_cnt_week(c1, cnt, stat_time) values (v_c1, v_cnt, v_stat_time);</font></div><div><font size="2"   >&nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; update log_c1_cnt_week set cnt=cnt+v_cnt where c1=v_c1 and stat_time=v_stat_time;</font></div><div><font size="2"   >&nbsp; &nbsp; end if;</font></div><div><font size="2"   >&nbsp; end loop;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$function$;</font></div><p></p></pre></div><div><br></div><div>-- # 注册统计维度函数, 注册时isinit=true. 第一次调用analyze_log后更新为false, 同时更新init_xid, init_xip等.</div><div><pre class="prettyprint"   ><p><font size="2"   >insert into log_read_func(tablename,func,init_xid,init_xip,isinit,info) values('log','stat_log_c1_week',null,null,true,null);</font></p></pre></div><div><span style="line-height: 22px;"   >-- pgbench</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg92@digoal-PowerEdge-R610-&gt; pgbench -M prepared -f ./ins.sql -r -n -h $PGDATA -U postgres -T 60 -c 8 -j 2</font></div><div><font size="2"   >transaction type: Custom query</font></div><div><font size="2"   >scaling factor: 1</font></div><div><font size="2"   >query mode: prepared</font></div><div><font size="2"   >number of clients: 8</font></div><div><font size="2"   >number of threads: 2</font></div><div><font size="2"   >duration: 60 s</font></div><div><font size="2"   >number of transactions actually processed: 365012</font></div><div><font size="2"   >tps = 6083.034829 (including connections establishing)</font></div><div><font size="2"   >tps = 6084.366283 (excluding connections establishing)</font></div><div><font size="2"   >statement latencies in milliseconds:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.066413 &nbsp; &nbsp; &nbsp; &nbsp;begin;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.163332 &nbsp; &nbsp; &nbsp; &nbsp;insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.159310 &nbsp; &nbsp; &nbsp; &nbsp;insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.086508 &nbsp; &nbsp; &nbsp; &nbsp;end;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.063532 &nbsp; &nbsp; &nbsp; &nbsp;begin;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.163740 &nbsp; &nbsp; &nbsp; &nbsp;insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.159271 &nbsp; &nbsp; &nbsp; &nbsp;insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.086722 &nbsp; &nbsp; &nbsp; &nbsp;rollback;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.177647 &nbsp; &nbsp; &nbsp; &nbsp;insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 0.177949 &nbsp; &nbsp; &nbsp; &nbsp;insert into log (c1,c2,c3,c4) values(round(random()*10),1,2,3);</font></div><p></p></pre></div><div><div>-- # 压力测试的同时执行analyze_log. 确保pgbench同时执行analyze_log.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg92@digoal-PowerEdge-R610-&gt; cat analyze.sh&nbsp;</font></div><div><font size="2"   >#!/bin/bash</font></div><div><font size="2"   >for ((i=0;i&lt;100;i++))</font></div><div><font size="2"   >do</font></div><div><font size="2"   >psql -c "select * from analyze_log(1);"</font></div><div><font size="2"   >psql -c "select * from analyze_log(1000000);"</font></div><div><font size="2"   >done</font></div><div><font size="2"   ># 调用analyze.sh</font></div><p></p></pre></div></div><div><span style="line-height: 22px;"   >-- # 数据全部取完后</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select analyze_log(1000000);</font></div><div><font size="2"   >NOTICE: &nbsp;v_log_read_log_xip no element.</font></div><div><font size="2"   >NOTICE: &nbsp;no data in log table which xid&gt;493263112 and xid&lt;493263115 and xid not in (select unnest(&lt;NULL&gt;) union all select unnest(&lt;NULL&gt;)).</font></div><div><font size="2"   >&nbsp;analyze_log&nbsp;</font></div><div><font size="2"   >-------------</font></div><div><font size="2"   >&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 1.169 ms</font></div><div><font size="2"   >digoal=# select * from log_read;</font></div><div><font size="2"   >&nbsp;tablename | &nbsp; &nbsp;xid &nbsp; &nbsp;| xip | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mod_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----------+-----------+-----+----------------------------</font></div><div><font size="2"   >&nbsp;log &nbsp; &nbsp; &nbsp; | 493263112 | &nbsp; &nbsp; | 2013-04-22 15:51:00.450235</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >Time: 0.566 ms</font></div><div><font size="2"   >digoal=# select * from log_read_func;</font></div><div><font size="2"   >&nbsp;tablename | &nbsp; &nbsp; &nbsp; func &nbsp; &nbsp; &nbsp; | init_xid &nbsp;| &nbsp; &nbsp; &nbsp; init_xip &nbsp; &nbsp; &nbsp; &nbsp;| isinit | info&nbsp;</font></div><div><font size="2"   >-----------+------------------+-----------+-----------------------+--------+------</font></div><div><font size="2"   >&nbsp;log &nbsp; &nbsp; &nbsp; | stat_log_c1 &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | f &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;log &nbsp; &nbsp; &nbsp; | stat_log_c1_week | 491803059 | {492492724,492492725} | f &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   >Time: 0.349 ms</font></div><p></p></pre></div><div><br></div><div>-- # 数据校验</div><div>-- log_c1_cnt_day (取&gt;0 or 包含init_xip)</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select c1,count(*),to_char(crt_time,'yyyymmdd') from log where xid&gt;0 group by c1,to_char(crt_time,'yyyymmdd') order by c1;</font></div><div><font size="2"   >&nbsp;c1 | count &nbsp;| to_char &nbsp;</font></div><div><font size="2"   >----+--------+----------</font></div><div><font size="2"   >&nbsp; 0 | 278990 | 20130422</font></div><div><font size="2"   >&nbsp; 1 | 559150 | 20130422</font></div><div><font size="2"   >&nbsp; 2 | 557552 | 20130422</font></div><div><font size="2"   >&nbsp; 3 | 555797 | 20130422</font></div><div><font size="2"   >&nbsp; 4 | 557475 | 20130422</font></div><div><font size="2"   >&nbsp; 5 | 558780 | 20130422</font></div><div><font size="2"   >&nbsp; 6 | 556803 | 20130422</font></div><div><font size="2"   >&nbsp; 7 | 557337 | 20130422</font></div><div><font size="2"   >&nbsp; 8 | 557065 | 20130422</font></div><div><font size="2"   >&nbsp; 9 | 557328 | 20130422</font></div><div><font size="2"   >&nbsp;10 | 277775 | 20130422</font></div><div><font size="2"   >(11 rows)</font></div><div><font size="2"   >Time: 15838.259 ms</font></div><div><font size="2"   >digoal=# select * from log_c1_cnt_day where cnt&lt;&gt;0 order by c1;</font></div><div><font size="2"   >&nbsp;c1 | &nbsp;cnt &nbsp; | stat_time&nbsp;</font></div><div><font size="2"   >----+--------+-----------</font></div><div><font size="2"   >&nbsp; 0 | 278990 | 20130422</font></div><div><font size="2"   >&nbsp; 1 | 559150 | 20130422</font></div><div><font size="2"   >&nbsp; 2 | 557552 | 20130422</font></div><div><font size="2"   >&nbsp; 3 | 555797 | 20130422</font></div><div><font size="2"   >&nbsp; 4 | 557475 | 20130422</font></div><div><font size="2"   >&nbsp; 5 | 558780 | 20130422</font></div><div><font size="2"   >&nbsp; 6 | 556803 | 20130422</font></div><div><font size="2"   >&nbsp; 7 | 557337 | 20130422</font></div><div><font size="2"   >&nbsp; 8 | 557065 | 20130422</font></div><div><font size="2"   >&nbsp; 9 | 557328 | 20130422</font></div><div><font size="2"   >&nbsp;10 | 277775 | 20130422</font></div><div><font size="2"   >(11 rows)</font></div><div><font size="2"   >Time: 0.668 ms</font></div><p></p></pre></div><div><br></div><div>-- log_c1_cnt_week (取&gt;491803059 or 包含init_xip)</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select c1,count(*),to_char(date(crt_time)-(EXTRACT(ISODOW FROM date(crt_time)))::int+1,'yyyymmdd') from log where xid&gt;491803059 or xid in (492492724,492492725) group by c1,to_char(date(crt_time)-(EXTRACT(ISODOW FROM date(crt_time)))::int+1,'yyyymmdd') order by c1;</font></div><div><font size="2"   >&nbsp;c1 | count &nbsp;| to_char &nbsp;</font></div><div><font size="2"   >----+--------+----------</font></div><div><font size="2"   >&nbsp; 0 | &nbsp;72929 | 20130422</font></div><div><font size="2"   >&nbsp; 1 | 146351 | 20130422</font></div><div><font size="2"   >&nbsp; 2 | 145705 | 20130422</font></div><div><font size="2"   >&nbsp; 3 | 146001 | 20130422</font></div><div><font size="2"   >&nbsp; 4 | 145831 | 20130422</font></div><div><font size="2"   >&nbsp; 5 | 146610 | 20130422</font></div><div><font size="2"   >&nbsp; 6 | 145946 | 20130422</font></div><div><font size="2"   >&nbsp; 7 | 146209 | 20130422</font></div><div><font size="2"   >&nbsp; 8 | 145556 | 20130422</font></div><div><font size="2"   >&nbsp; 9 | 146188 | 20130422</font></div><div><font size="2"   >&nbsp;10 | &nbsp;72722 | 20130422</font></div><div><font size="2"   >(11 rows)</font></div><div><font size="2"   >Time: 5415.514 ms</font></div><div><font size="2"   >digoal=# select * from log_c1_cnt_week where cnt&lt;&gt;0 order by c1;</font></div><div><font size="2"   >&nbsp;c1 | &nbsp;cnt &nbsp; | stat_time&nbsp;</font></div><div><font size="2"   >----+--------+-----------</font></div><div><font size="2"   >&nbsp; 0 | &nbsp;72929 | 20130422</font></div><div><font size="2"   >&nbsp; 1 | 146351 | 20130422</font></div><div><font size="2"   >&nbsp; 2 | 145705 | 20130422</font></div><div><font size="2"   >&nbsp; 3 | 146001 | 20130422</font></div><div><font size="2"   >&nbsp; 4 | 145831 | 20130422</font></div><div><font size="2"   >&nbsp; 5 | 146610 | 20130422</font></div><div><font size="2"   >&nbsp; 6 | 145946 | 20130422</font></div><div><font size="2"   >&nbsp; 7 | 146209 | 20130422</font></div><div><font size="2"   >&nbsp; 8 | 145556 | 20130422</font></div><div><font size="2"   >&nbsp; 9 | 146188 | 20130422</font></div><div><font size="2"   >&nbsp;10 | &nbsp;72722 | 20130422</font></div><div><font size="2"   >(11 rows)</font></div><div><font size="2"   >Time: 0.658 ms</font></div><p></p></pre></div><div><br></div><div>-- # 历史数据分析</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=# select * from log_read_func;</font></div><div><font size="2"   >&nbsp;tablename | &nbsp; &nbsp; &nbsp; func &nbsp; &nbsp; &nbsp; | init_xid &nbsp;| &nbsp; &nbsp; &nbsp; init_xip &nbsp; &nbsp; &nbsp; &nbsp;| isinit | info&nbsp;</font></div><div><font size="2"   >-----------+------------------+-----------+-----------------------+--------+------</font></div><div><font size="2"   >&nbsp;log &nbsp; &nbsp; &nbsp; | stat_log_c1 &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; 0 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | f &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >&nbsp;log &nbsp; &nbsp; &nbsp; | stat_log_c1_week | 491803059 | {492492724,492492725} | f &nbsp; &nbsp; &nbsp;|&nbsp;</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   >Time: 0.349 ms</font></div><p></p></pre></div><div>-- stat_log_c1 历史数据分析条件(xid&lt;=0)</div><div>-- stat_log_c1_week 历史数据分析条件(xid&lt;=491803059 and xid not in (492492724,492492725))</div><div><br></div><div>【特别注意】</div><div>由于本例采用了PostgreSQL系统xid来解决气泡问题, 所以特别需要注意以下问题 :&nbsp;</div><div>-- xid的问题, 当使用pg_resetxlog修改xid时(如果xid改小)将打破使用该方法的统计. 所以安全的做法是xid改大可以, 改小不行.</div><div>-- 当使用pg_dump导出明细数据到另一个库后, 记得先使用pg_resetxlog将新集群的xid调整到大于明细表的max(xid)</div></div><br><wbr></div>[参考]<div><div>为方便大家查询, 汇总PostgreSQL实时和非实时数据统计的案例分析文章系列 - 如下 :&nbsp;</div><div>1.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201331252945440/"   >http://blog.163.com/digoal@126/blog/static/163877040201331252945440/</a></div><div>2.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020133151402415/"   >http://blog.163.com/digoal@126/blog/static/16387704020133151402415/</a></div><div>3.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020133155179877/"   >http://blog.163.com/digoal@126/blog/static/16387704020133155179877/</a></div><div>4.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020133156636579/"   >http://blog.163.com/digoal@126/blog/static/16387704020133156636579/</a></div><div>5.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020133218305242/"   >http://blog.163.com/digoal@126/blog/static/16387704020133218305242/</a></div><div>6.&nbsp;<a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020133224161563/"   >http://blog.163.com/digoal@126/blog/static/16387704020133224161563/</a></div></div><span style="line-height: 22px;"   >7.&nbsp;</span><a style="line-height: 22px;" href="http://blog.163.com/digoal@126/blog/static/16387704020133271134563/"   >http://blog.163.com/digoal@126/blog/static/16387704020133271134563/</a><br><div><span style="color: rgb(51, 51, 51); font-family: Arial, Helvetica, simsun, u5b8bu4f53; line-height: 25px;"   >8.&nbsp;</span><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020134311144755/"   >http://blog.163.com/digoal@126/blog/static/16387704020134311144755/</a></div></div>
	</div>
</div>
</body>
</html>