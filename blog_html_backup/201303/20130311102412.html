<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL trigger introduction - 1</h2>
	<h5 id="">2013-03-11 10:24:12&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013283547959/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>以PostgreSQL 9.2为例, 介绍触发器的使用<span style="line-height: 22px;"   >. 分两部分.</span></div><div><span style="line-height: 22px;"   >第二部分链接 :&nbsp;</span></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402013211102130526/"   >http://blog.163.com/digoal@126/blog/static/1638770402013211102130526/</a></div><div><br></div><wbr><div>包含如下内容 :&nbsp;</div><div>一、</div><div>1. 什么是触发器? 触发器有什么用? 创建触发器的语法?</div><div><span style="line-height: 22px;"   >2. 什么是触发器函数,&nbsp;</span><span style="line-height: 22px;"   >触发器函数可以用哪些语言编写</span><span style="line-height: 22px;"   >?</span></div><div><span style="line-height: 22px;"   >3. 触发器有哪些分类?</span></div><div><span style="line-height: 22px;"   >4. 同一个表或视图上可以建多少个触发器?&nbsp;</span><span style="line-height: 22px;"   >如果一个表或视图上有多个触发器, 调用顺序如何决定?</span></div><div>5. 同一个触发器函数可以被多个触发器调用吗? 触发器函数的返回类型时什么? 触发器函数的返回值是否会影响下一个触发器函数<span style="line-height: 22px;"   >或者被操作的行的数据</span><span style="line-height: 22px;"   >? NEW 或者OLD record修改后会带来什么影响? 哪些触发器函数的返回值没有意义?</span></div><div>6. 触发器函数的返回值与返回行数的关系, 与变量FOUND, ROW_COUNT, RETURNING的关系.</div><div><span style="line-height: 22px;"   >7. 触发器的</span><span style="line-height: 22px;"   >延时属性和</span><span style="line-height: 22px;"   >状态.</span></div><div><span style="line-height: 22px;"   >8. 可以在系统表或系统视图上创建触发器吗?</span></div><div>二、</div><div>以plpgsql语言为例, 讲解触发器函数.</div><div>9. 触发器函数的返回值.</div><div>10. 触发器函数的参数.</div><div>11. 触发器函数中的变量与传递.</div><div><span style="line-height: 22px;"   >12. 触发器函数的数据可视与什么有关?</span></div><div><span style="line-height: 22px;"   >13. 触发器会无限递归吗? 如何避免?</span></div><div><span style="line-height: 22px;"   >14. 触发条件与性能.</span></div><div><span style="line-height: 22px;"   >15. 加入触发器后的事务特性.</span></div><div><span style="line-height: 22px;"   >16. 触发器的返回值是如何影响returning的结果的?</span></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >【正文】</span></div><div><span style="line-height: 22px;"   >一、</span></div><div><span style="line-height: 22px;"   >1. 什么是触发器? 触发器有什么用? 创建触发器的语法?</span></div><div>定义还是用原文比较好 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >A trigger is a specification that the database should automatically execute a particular function whenever a certain type of operation is performed.&nbsp;</font></div><div><font size="2"   >Triggers can be attached to both tables and views.&nbsp;</font></div><p></p></pre></div><div>创建触发器的语法如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >Command: &nbsp; &nbsp; CREATE TRIGGER</font></div><div><font size="2"   >Description: define a new trigger</font></div><div><font size="2"   >Syntax:</font></div><div><font size="2"   >CREATE [ CONSTRAINT ] TRIGGER name { BEFORE | AFTER | INSTEAD OF } { event [ OR ... ] }</font></div><div><font size="2"   >&nbsp; &nbsp; ON table_name</font></div><div><font size="2"   >&nbsp; &nbsp; [ FROM referenced_table_name ]</font></div><div><font size="2"   >&nbsp; &nbsp; { NOT DEFERRABLE | [ DEFERRABLE ] { INITIALLY IMMEDIATE | INITIALLY DEFERRED } }</font></div><div><font size="2"   >&nbsp; &nbsp; [ FOR [ EACH ] { ROW | STATEMENT } ]</font></div><div><font size="2"   >&nbsp; &nbsp; [ WHEN ( condition ) ]</font></div><div><font size="2"   >&nbsp; &nbsp; EXECUTE PROCEDURE function_name ( arguments )</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >where event can be one of:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; INSERT</font></div><div><font size="2"   >&nbsp; &nbsp; UPDATE [ OF column_name [, ... ] ]</font></div><div><font size="2"   >&nbsp; &nbsp; DELETE</font></div><div><font size="2"   >&nbsp; &nbsp; TRUNCATE</font></div><p></p></pre></div><div><br></div><div>2.&nbsp;<span style="line-height: 22px;"   >什么是触发器函数?&nbsp;</span><span style="line-height: 22px;"   >触发器函数可以用哪些语言编写</span><span style="line-height: 22px;"   >?</span></div><div><span style="line-height: 22px;"   >给表或者视图创建触发器时需要指定这个触发器被触发时执行的函数, 这个函数就是触发器函数.</span></div><div><span style="line-height: 22px;"   >触发器函数的返回类型为trigger, 如果需要给触发器函数传入参数, 不能定义在触发器函数的参数列表中, 而是通过其他方式传入(TriggerData数据结构).</span></div><div><span style="line-height: 22px;"   >例如使用plpgsql写的触发器函数, 通过变量TG_ARGV[]来接收传入的变量值.&nbsp;</span></div><div><pre class="prettyprint"   ><p><font size="2"   >The trigger function must be defined before the trigger itself can be created. The trigger function must be declared as a function taking no arguments and returning type trigger. (The trigger function receives its input through a specially-passed TriggerData structure, not in the form of ordinary function arguments.)</font></p></pre></div><div>TriggerData数据结构 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >00029 typedef struct TriggerData</font></div><div><font size="2"   >00030 {</font></div><div><font size="2"   >00031 &nbsp; &nbsp; NodeTag &nbsp; &nbsp; type;</font></div><div><font size="2"   >00032 &nbsp; &nbsp; TriggerEvent tg_event;</font></div><div><font size="2"   >00033 &nbsp; &nbsp; Relation &nbsp; &nbsp;tg_relation;</font></div><div><font size="2"   >00034 &nbsp; &nbsp; HeapTuple &nbsp; tg_trigtuple;</font></div><div><font size="2"   >00035 &nbsp; &nbsp; HeapTuple &nbsp; tg_newtuple;</font></div><div><font size="2"   >00036 &nbsp; &nbsp; Trigger &nbsp; &nbsp;*tg_trigger;</font></div><div><font size="2"   >00037 &nbsp; &nbsp; Buffer &nbsp; &nbsp; &nbsp;tg_trigtuplebuf;</font></div><div><font size="2"   >00038 &nbsp; &nbsp; Buffer &nbsp; &nbsp; &nbsp;tg_newtuplebuf;</font></div><div><font size="2"   >00039 } TriggerData;</font></div><p></p></pre></div><div>Trigger数据结构, 传入的参数数据结构 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >00023 typedef struct Trigger</font></div><div><font size="2"   >00024 {</font></div><div><font size="2"   >00025 &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; tgoid; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* OID of trigger (pg_trigger row) */</font></div><div><font size="2"   >00026 &nbsp; &nbsp; /* Remaining fields are copied from pg_trigger, see pg_trigger.h */</font></div><div><font size="2"   >00027 &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *tgname;</font></div><div><font size="2"   >00028 &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; tgfoid;</font></div><div><font size="2"   >00029 &nbsp; &nbsp; int16 &nbsp; &nbsp; &nbsp; tgtype;</font></div><div><font size="2"   >00030 &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp;tgenabled;</font></div><div><font size="2"   >00031 &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;tgisinternal;</font></div><div><font size="2"   >00032 &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; tgconstrrelid;</font></div><div><font size="2"   >00033 &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; tgconstrindid;</font></div><div><font size="2"   >00034 &nbsp; &nbsp; Oid &nbsp; &nbsp; &nbsp; &nbsp; tgconstraint;</font></div><div><font size="2"   >00035 &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;tgdeferrable;</font></div><div><font size="2"   >00036 &nbsp; &nbsp; bool &nbsp; &nbsp; &nbsp; &nbsp;tginitdeferred;</font></div><div><font size="2"   >00037 &nbsp; &nbsp; int16 &nbsp; &nbsp; &nbsp; tgnargs;</font></div><div><font size="2"   >00038 &nbsp; &nbsp; int16 &nbsp; &nbsp; &nbsp; tgnattr;</font></div><div><font size="2"   >00039 &nbsp; &nbsp; int16 &nbsp; &nbsp; &nbsp;*tgattr;</font></div><div><font size="2"   >00040 &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp;**tgargs;</font></div><div><font size="2"   >00041 &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *tgqual;</font></div><div><font size="2"   >00042 } Trigger;</font></div><p></p></pre></div><div>触发器函数可以使用系统自带的过程语言(例如plpgsql, pltcl, plperl, plpython)来写, 也可以使用C来写.</div><div>后面的实例将使用plpgsql来写.</div><div><br></div><div><span style="line-height: 22px;"   >3. 触发器有哪些分类?</span></div><div><span style="line-height: 22px;"   >-- 表</span></div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >-- On tables, triggers can be defined to execute either before or after any INSERT, UPDATE, or DELETE operation, either once per modified row, or once per SQL statement.&nbsp;</font></div><div><font size="2"   >UPDATE triggers can moreover be set to fire only if certain columns are mentioned in the SET clause of the UPDATE statement.&nbsp;</font></div><div><font size="2"   >Triggers can also fire for TRUNCATE statements.&nbsp;</font></div><div><font size="2"   >If a trigger event occurs, the trigger's function is called at the appropriate time to handle the event.</font></div><p></p></pre></div><div>表触发器的创建分类 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >(before | after) (INSERT | UPDATE | DELETE) (FOR EACH ROW)&nbsp;<span style="line-height: 22px;"   >(WHEN NEW.? and,or OLD.? ... other boolean express ....)</span></font></div><div><font size="2"   ><span style="line-height: 22px;"   >(before | after) (</span><span style="line-height: 22px;"   >INSERT | UPDATE | DELETE | TRUNCATE</span><span style="line-height: 22px;"   >) (FOR EACH&nbsp;</span><span style="line-height: 22px;"   >STATEMENT</span><span style="line-height: 22px;"   >)&nbsp;</span><span style="line-height: 22px;"   >(WHEN BOOLEAN express except NEW or OLD or columns)</span></font></div><p></p></pre></div><div><span style="line-height: 22px;"   >-- 视图</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >-- On views, triggers can be defined to execute instead of INSERT, UPDATE, or DELETE operations.&nbsp;</font></div><div><font size="2"   >INSTEAD OF triggers are fired once for each row that needs to be modified in the view.&nbsp;</font></div><div><font size="2"   >It is the responsibility of the trigger's function to perform the necessary modifications to the underlying base tables and, where appropriate, return the modified row as it will appear in the view.&nbsp;</font></div><div><font size="2"   >Triggers on views can also be defined to execute once per SQL statement, before or after INSERT, UPDATE, or DELETE operations.</font></div><p></p></pre></div></div><div>视图触发器的创建分类 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >(INSTEAD OF)&nbsp;<span style="line-height: 22px;"   >(INSERT | UPDATE | DELETE)&nbsp;</span><span style="line-height: 22px;"   >(FOR EACH ROW)&nbsp;</span><span style="line-height: 22px;"   >(WHEN NEW.? and,or OLD.? ... other boolean express ....)</span></font></div><div><font size="2"   ><span style="line-height: 22px;"   >(</span><span style="line-height: 22px;"   >before | after</span><span style="line-height: 22px;"   >)&nbsp;</span><span style="line-height: 22px;"   >(INSERT | UPDATE | DELETE)&nbsp;</span><span style="line-height: 22px;"   >(FOR EACH STATEMENT)&nbsp;</span><span style="line-height: 22px;"   >(WHEN BOOLEAN express except NEW or OLD or columns)</span></font></div><p></p></pre></div><div>分类总结如下 :&nbsp;</div><div><table border="1"   style="margin: 2ex 0px 2ex 2ex; -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border-spacing: 0px; border-collapse: collapse; background-color: rgb(224, 236, 239); border: 2px solid rgb(167, 198, 223); color: rgb(0, 0, 0); font-family: verdana, sans-serif; font-size: 12px; line-height: normal;"   ><thead><tr><th style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex;"   >When</th><th style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex;"   >Event</th><th style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex;"   >Row-level</th><th style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex;"   >Statement-level</th></tr></thead><tbody><tr><td rowspan="2"   align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   ><tt>BEFORE</tt></td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   ><tt>INSERT</tt>/<tt>UPDATE</tt>/<tt>DELETE</tt></td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Tables</td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Tables and views</td></tr><tr><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   ><tt>TRUNCATE</tt></td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >―</td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Tables</td></tr><tr><td rowspan="2"   align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   ><tt>AFTER</tt></td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   ><tt>INSERT</tt>/<tt>UPDATE</tt>/<tt>DELETE</tt></td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Tables</td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Tables and views</td></tr><tr><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   ><tt>TRUNCATE</tt></td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >―</td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Tables</td></tr><tr><td rowspan="2"   align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   ><tt>INSTEAD OF</tt></td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   ><tt>INSERT</tt>/<tt>UPDATE</tt>/<tt>DELETE</tt></td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >Views</td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(255, 255, 255); padding: 0.5ex;"   >―</td></tr><tr><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   ><tt>TRUNCATE</tt></td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >―</td><td align="center"   style="border: 1px solid rgb(167, 198, 223); background-color: rgb(239, 239, 239); padding: 0.5ex;"   >―</td></tr></table></div><div><br></div><div>4.&nbsp;<span style="line-height: 22px;"   >同一个表或视图上可以建多个触发器吗?&nbsp;</span><span style="line-height: 22px;"   >如果一个表或视图上有多个触发器, 调用顺序如何决定?</span></div><div><span style="line-height: 22px;"   >同一个表或视图上可以创建多个触发器, 调用的顺序和触发器的类型有关.&nbsp;</span></div><div>-- 表上各种触发器的调用先后顺序如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >1. before for each statement</font></div><div><font size="2"   >2. before for each row</font></div><div><font size="2"   >3. after for each row</font></div><div><font size="2"   >4. after for each statement</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >-- 视图</span><span style="line-height: 22px;"   >上各种触发器的调用先后顺序如下</span><span style="line-height: 22px;"   >&nbsp;:&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><font size="2"   >1. before for each statement</font></span></div><div><font size="2"   >2. instead for each row</font></div><div><font size="2"   >3. after for each statement</font></div><p></p></pre></div><div><span style="line-height: 22px;"   >-- 同类触发器如果有多个, 调用顺序则和触发器的名字有关, 按照名字的排序进行调用.</span></div><div><span style="line-height: 22px;"   >举例, 使用raise notice TG_NAME跟踪调用顺序 :&nbsp;</span></div><div><span style="line-height: 22px;"   >-- 表举例</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><font size="2"   >-- 创建测试表</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   ><div>postgres=# create table digoal (id int);</div><div>CREATE TABLE</div><div>-- 创建触发器函数</div><div><div>postgres=# create or replace function debug() returns trigger as $$</div><div>declare&nbsp;</div><div>begin &nbsp;</div><div>&nbsp; raise notice '%', TG_NAME;</div><div>&nbsp; return new;</div><div>end;</div><div>$$ language plpgsql;</div><div>CREATE FUNCTION</div></div><div>-- 创建4种类型的触发器</div></font></span></div><div><font size="2"   ><span style="line-height: 22px;"   ><div>postgres=# create trigger tg1 before insert on digoal for each statement execute procedure debug();</div><div>CREATE TRIGGER</div><div>postgres=# create trigger tg2 before insert on digoal for each row execute procedure debug();</div><div>CREATE TRIGGER</div><div>postgres=# create trigger tg3 after insert on digoal for each row execute procedure debug();</div><div>CREATE TRIGGER</div><div>postgres=# create trigger tg4 after insert on digoal for each statement execute procedure debug();</div><div>CREATE TRIGGER</div><div>-- 创建多个同类型的触发器</div><div>postgres=# create trigger tg01 before insert on digoal for each statement execute procedure debug();</div><div>CREATE TRIGGER</div><div>postgres=# create trigger tg02 before insert on digoal for each row execute procedure debug();</div><div>CREATE TRIGGER</div><div>postgres=# create trigger tg03 after insert on digoal for each row execute procedure debug();</div><div>CREATE TRIGGER</div><div>postgres=# create trigger tg04 after insert on digoal for each statement execute procedure debug();</div><div>CREATE TRIGGER</div><div>-- 插入测试 :&nbsp;</div><div>postgres=# insert into digoal values (1);</div><div>NOTICE: &nbsp;00000: tg01 &nbsp;-- 第1被触发的是tg01, before for each statement, 同类触发器tg01按字母顺序排在tg1的前面.</div><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>NOTICE: &nbsp;00000: tg1<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;-- 第2</span><span style="line-height: 22px;"   >被触发的是tg1, before for each statement</span></div></span><span style="line-height: 22px;"   ><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>NOTICE: &nbsp;00000: tg02<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;-- 第3</span><span style="line-height: 22px;"   >被触发的是tg02</span><span style="line-height: 22px;"   >, before for each row, 同类触发器tg02按字母顺序排在tg2的前面.</span></div></span><span style="line-height: 22px;"   ><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>NOTICE: &nbsp;00000: tg2<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;-- 第4</span><span style="line-height: 22px;"   >被触发的是tg2, before for each row</span></div></span><span style="line-height: 22px;"   ><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>NOTICE: &nbsp;00000: tg03<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;-- 第5</span><span style="line-height: 22px;"   >被触发的是tg03</span><span style="line-height: 22px;"   >, after for each row, 同类触发器tg03按字母顺序排在tg3的前面.</span></div></span><span style="line-height: 22px;"   ><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>NOTICE: &nbsp;00000: tg3<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;-- 第6</span><span style="line-height: 22px;"   >被触发的是tg3, after for each row</span></div></span><span style="line-height: 22px;"   ><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>NOTICE: &nbsp;00000: tg04<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;-- 第7</span><span style="line-height: 22px;"   >被触发的是tg04</span><span style="line-height: 22px;"   >, after for each statement, 同类触发器tg04按字母顺序排在tg4的前面.</span></div></span><span style="line-height: 22px;"   ><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>NOTICE: &nbsp;00000: tg4<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;-- 第8</span><span style="line-height: 22px;"   >被触发的是tg4, after for each statement</span></div></span><span style="line-height: 22px;"   ><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>INSERT 0 1</div></span></font></div><p></p></pre></div><div><span style="line-height: 22px;"   >-- 视图举例</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><font size="2"   >-- 创建测试视图</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   ><div>postgres=# create view v_digoal as select * from digoal;</div><div>CREATE VIEW</div><div>-- 创建触发器</div><div>postgres=# create trigger tg1 before insert on v_digoal for each statement execute procedure debug();</div><div>CREATE TRIGGER</div><div>postgres=# create trigger tg2 instead of insert on v_digoal for each row execute procedure debug();</div><div>CREATE TRIGGER</div><div>postgres=# create trigger tg3 after insert on v_digoal for each statement execute procedure debug();</div><div>CREATE TRIGGER</div><div>postgres=# create trigger tg01 before insert on v_digoal for each statement execute procedure debug();</div><div>CREATE TRIGGER</div><div>postgres=# create trigger tg02 instead of insert on v_digoal for each row execute procedure debug();</div><div>CREATE TRIGGER</div><div>postgres=# create trigger tg03 after insert on v_digoal for each statement execute procedure debug();</div><div>CREATE TRIGGER</div><div>-- 测试</div><div><div>postgres=# insert into v_digoal values (2);</div><div>NOTICE: &nbsp;00000: tg01 &nbsp;-- 第1被触发的是tg01, before for each statement, 同类触发器tg01按字母顺序排在tg1的前面.</div><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>NOTICE: &nbsp;00000: tg1<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;-- 第2被触发的是tg1, before for each statement</span></div><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>NOTICE: &nbsp;00000: tg02<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;-- 第3被触发的是tg02, instead of for each row, 同类触发器tg02按字母顺序排在tg2的前面.</span></div><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>NOTICE: &nbsp;00000: tg2<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;-- 第4被触发的是tg2, instead of for each row</span></div><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>NOTICE: &nbsp;00000: tg03<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;-- 第5被触发的是tg03, after for each statement, 同类触发器tg03按字母顺序排在tg3的前面.</span></div><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>NOTICE: &nbsp;00000: tg3<span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >&nbsp;-- 第6被触发的是tg3, after for each statement</span></div><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>INSERT 0 1</div></div></font></span></div><p></p></pre></div><div><span style="line-height: 22px;"   ><br></span></div><div><span style="line-height: 22px;"   >5. 同一个触发器函数可以被多个触发器调用吗? 触发器函数的返回类型是什么? 触发器函数的返回值是否会影响下一个触发器函数</span><span style="line-height: 22px;"   >或者被操作的行的数据</span><span style="line-height: 22px;"   >?&nbsp;</span><span style="line-height: 22px;"   >NEW 或者OLD record修改后会带来什么影响? 哪些触发器函数的返回值没有意义?</span></div><div><span style="line-height: 22px;"   >-- 同一个触发器函数可以多次被触发器调用, 上面的例子中表和视图的14个触发器中都是调用的debug()触发器函数.</span></div><div><span style="line-height: 22px;"   >-- 触发器函数的返回值为空 或者是 表或视图对应的record类型.</span></div><div><span style="line-height: 22px;"   >返回值举例 :&nbsp;</span></div><div><span style="line-height: 22px;"   >-- 表触发器返回空测试</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><font size="2"   >-- 创建测试表</font></span></div><div><span style="line-height: 22px;"   ><div><font size="2"   >postgres=# create table t_ret (id int, info text, crt_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >-- 创建触发器函数, 返回空.</font></div><div><div><font size="2"   >postgres=# create or replace function tg_t_ret() returns trigger as $$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; raise notice '%', TG_NAME;&nbsp;</font></div><div><font size="2"   >&nbsp; return null;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div></div><div><font size="2"   >-- 创建触发器</font></div><div><div><font size="2"   >postgres=# create trigger tg1 before insert on t_ret for each statement execute procedure tg_t_ret();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >postgres=# create trigger tg2 before insert on t_ret for each row execute procedure tg_t_ret();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >postgres=# create trigger tg3 after insert on t_ret for each row execute procedure tg_t_ret();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >postgres=# create trigger tg4 after insert on t_ret for each statement execute procedure tg_t_ret();</font></div><div><font size="2"   >CREATE TRIGGER</font></div></div><div><div><font size="2"   >postgres=# create trigger tg01 before insert on t_ret for each statement execute procedure tg_t_ret();</font></div><div><font size="2"   >CREATE TRIGGER</font></div></div><div><div><font size="2"   >postgres=# create trigger tg02 before insert on t_ret for each row execute procedure tg_t_ret();</font></div><div><font size="2"   >CREATE TRIGGER</font></div></div><div><div><font size="2"   >postgres=# create trigger tg03 after insert on t_ret for each row execute procedure tg_t_ret();</font></div><div><font size="2"   >CREATE TRIGGER</font></div></div><div><div><font size="2"   >postgres=# create trigger tg04 after insert on t_ret for each statement execute procedure tg_t_ret();</font></div><div><font size="2"   >CREATE TRIGGER</font></div></div><div><font size="2"   >-- 插入测试</font></div><div><div><font size="2"   >postgres=# insert into t_ret values(1,'digoal',now());</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg01, before for each statement的触发器函数返回空, 不影响后续的触发器是否被调用.</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg1</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg02, 注意在第一个before for each row触发器调用的触发器函数返回空后, 后续的for each row触发器将不被调用. 说明这个返回值传递给了下一个for each row触发器. 并且对后续的for each row触发器造成了影响.</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >-- 对表的操作发生在在最后一个before for each row触发器 和 第一个after for each row触发器之间.</font></div><div><font size="2"   >-- 因为前面的for each row触发器返回了空, 所以没有真正操作的行, 因此不会有记录被插入到表里面.</font></div><div><font size="2"   >-- 也就是没有发生表记录的操作.</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg04,&nbsp;<span style="line-height: 22px;"   >after for each statement的触发器函数返回空, 不影响后续的触发器是否被调用.</span></font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg4</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >INSERT 0 0</font></div><div><font size="2"   >-- 因为before for each row返回空, 所以无值插入</font></div><div><font size="2"   >postgres=# select * from t_ret ;</font></div><div><font size="2"   >&nbsp;id | info | crt_time&nbsp;</font></div><div><font size="2"   >----+------+----------</font></div><div><font size="2"   >(0 rows)</font></div></div><div><font size="2"   >-- 这个将影响plpgsql函数中FOUND和ROW_COUNT变量的值.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >-- 把before for each row的触发器删掉, 再测试插入 :&nbsp;</font></div><div><div><font size="2"   >postgres=# drop trigger tg02 on t_ret;</font></div><div><font size="2"   >DROP TRIGGER</font></div><div><font size="2"   >postgres=# drop trigger tg2 on t_ret;</font></div><div><font size="2"   >DROP TRIGGER</font></div><div><font size="2"   >postgres=# insert into t_ret values(1,'digoal',now());</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg01</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg1</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg03, after for each row 的触发器函数返回空, 不影响<span style="line-height: 22px;"   >后续的触发器是否被调用.</span></font></div><div><span style="line-height: 22px;"   ><font size="2"   >因为只要表上面发生了真正的行操作, after for each row就会被触发, 除非when条件不满足. (这个后面会讲到)</font></span></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg3</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg04</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg4</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >-- 有数据插入. 这也说明了before for each statement的返回值为空并不会影响数据库对行的操作. 只有before for each row的返回值会影响数据库对行的操作.</font></div><div><font size="2"   >postgres=# select * from t_ret ;</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----+--------+----------------------------</font></div><div><font size="2"   >&nbsp; 1 | digoal | 2013-03-10 16:50:39.551481</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >-- 针对上例, 对tg03触发器的触发加一个when条件.</font></div><div><div><font size="2"   >postgres=# drop trigger tg03 on t_ret;</font></div><div><font size="2"   >DROP TRIGGER</font></div><div><font size="2"   >-- 只有当表的行数据真正受到影响时, after for each row 触发器才会被触发, 加了when条件后, 则还需要判断这个条件.</font></div><div><div><font size="2"   >postgres=# create trigger tg03 after insert on t_ret for each row when (new.info is not null) execute procedure tg_t_ret();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >-- 因为new.info 为空, 不满足WHEN条件, 所以tg03没有被触发.</font></div><div><font size="2"   >postgres=# insert into t_ret values(1,null,now());</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg01</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg1</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg3</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg04</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg4</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >INSERT 0 1</font></div></div></div></span></div><p></p></pre></div><div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >-- 表触发器返回record测试,&nbsp;</span><span style="line-height: 22px;"   >NEW 或者OLD record修改后会带来什么影响?</span></div><div><pre class="prettyprint"   ><p style="line-height: 22px;"   ><span style="line-height: 22px;"   ></span></p><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >-- 前面的例子已经知道, for each statement的返回值对行的值以及for each row的触发器没有影响. 所以下面的例子都是针对for each row的.</font></span></div><div style="line-height: 22px;"   ><font size="2"   >INSERT before for each row 触发器函数 接收 NEW,&nbsp;<span style="line-height: 22px;"   >修改这个record对结果的影响是什么?</span></font></div><div><font size="2"   ><div style="line-height: 22px;"   >-- 创建测试表</div><div style="line-height: 22px;"   >postgres=# drop table t_ret ;</div><div style="line-height: 22px;"   >DROP TABLE</div><div style="line-height: 22px;"   >postgres=# create table t_ret(id int, info text, crt_time timestamp);</div><div style="line-height: 22px;"   >CREATE TABLE</div><div style="line-height: 22px;"   >-- 创建触发器函数, 修改NEW并返回.</div><div style="line-height: 22px;"   >postgres=# create or replace function tg_t_ret() returns trigger as $$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div style="line-height: 22px;"   >declare</div><div style="line-height: 22px;"   >begin</div><div style="line-height: 22px;"   >&nbsp; NEW.id := NEW.id+1;&nbsp;</div><div style="line-height: 22px;"   >&nbsp; raise notice '%, id:%', TG_NAME, NEW.id;&nbsp;</div><div style="line-height: 22px;"   >&nbsp; -- 修改NEW.id , 并返回修改后的NEW. 影响插入数据的并不是NEW变量本身, &nbsp;而是return的值, 这个在后面将会有例子举证.</div><div style="line-height: 22px;"   >&nbsp; return NEW;</div><div style="line-height: 22px;"   >end;</div><div style="line-height: 22px;"   >$$ language plpgsql;</div><div style="line-height: 22px;"   >CREATE FUNCTION</div><div style="line-height: 22px;"   >-- 创建触发器</div><div style="line-height: 22px;"   ><div>postgres=# create trigger tg1 before insert ON t_ret for each row execute procedure tg_t_ret();</div><div>CREATE TRIGGER</div></div><div style="line-height: 22px;"   >-- 注意INSERT语句中values提供的id=1, 但是注意插入到表里的ID是2. 因此before for each row的返回值对插入行这个动作造成了影响.</div><div style="line-height: 22px;"   ><div>postgres=# insert into t_ret values (1,'digoal',now());</div><div>NOTICE: &nbsp;00000: tg1, id:2</div><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>INSERT 0 1</div><div>-- 插入的值被最后一个before for each row触发器函数的返回值取代, 篡改为2了:</div><div>postgres=# select * from t_ret;</div><div>&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div><div>----+--------+----------------------------</div><div>&nbsp; 2 | digoal | 2013-03-10 17:32:50.648323</div><div>(1 row)</div></div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   >-- 用这个触发器函数, 更能看出多个触发器函数以及对行数据操作时使用的是触发器函数的返回值, 而不是NEW变量本身.</div><div>postgres=# \d t_ret<br>                Table "public.t_ret"<br>  Column  |            Type             | Modifiers <br>----------+-----------------------------+-----------<br> id       | integer                     | <br> info     | text                        | <br> crt_time | timestamp without time zone | <br>Triggers:<br>    tg01 BEFORE INSERT ON t_ret FOR EACH ROW EXECUTE PROCEDURE tg_t_ret()<br>    tg02 AFTER INSERT ON t_ret FOR EACH ROW EXECUTE PROCEDURE tg_t_ret()<br>    tg1 BEFORE INSERT ON t_ret FOR EACH ROW EXECUTE PROCEDURE tg_t_ret()<br>    tg2 AFTER INSERT ON t_ret FOR EACH ROW EXECUTE PROCEDURE tg_t_ret()<span style="line-height: 19px; font-family: Arial, Helvetica, sans-serif;"   >-- 触发器函数如下 : </span></div><div style="line-height: 22px;"   ><div>postgres=# create or replace function tg_t_ret() returns trigger as $$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>declare&nbsp;</div><div>&nbsp; -- r用来记录原始的NEW值, 并返回原始的NEW值.</div><div>&nbsp; r record;</div><div>begin</div><div>&nbsp; -- 将NEW赋予给r.</div><div>&nbsp; r := NEW;&nbsp;</div><div>&nbsp; NEW.id := NEW.id+1;&nbsp;</div><div>&nbsp; raise notice '%, id:%', TG_NAME, NEW.id;&nbsp;</div><div>&nbsp; -- 修改NEW.id , 并返回修改前的NEW .&nbsp;</div><div>&nbsp; return r;</div><div>end;</div><div>$$ language plpgsql;</div><div>CREATE FUNCTION</div><div>-- 插入测试数据</div><div>postgres=# insert into t_ret values (100,'digoal',now());</div><div>NOTICE: &nbsp;00000: tg01, id:101</div><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>-- 第1个before for each row 的触发器函数中原始NEW.id=100(来自SQL语句的输入), 返回值r.id=100. 但是NEW.id=101.</div><div>NOTICE: &nbsp;00000: tg1, id:101</div><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div><span style="line-height: 22px;"   >-- 第2个before for each row&nbsp;</span><span style="line-height: 22px;"   >的触发器函数中原始NEW.id=100(来自上一个for each row函数的返回值), 返回值r.id=100. 但是NEW.id=101.</span></div><div><span style="line-height: 22px;"   >-- 原始的NEW值没有因为第一个触发器函数的修改而改变, 这个触发器函数中的NEW继承了上一个before for each row触发器函数的返回值.</span></div><div>-- 真正写入行的数据, 则是最后一个before for each row的返回值. 注意不是NEW变量的值. 而是最终的返回值.</div><div>NOTICE: &nbsp;00000: tg02, id:101</div><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div>NOTICE: &nbsp;00000: tg2, id:101</div><div>LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</div><div><span style="line-height: 22px;"   >-- after for each row 的触发器函数中NEW值(统一来自真正被影响的行数据), 与前一个after for each row触发器的返回值无关. (下例举证)</span></div><div><span style="line-height: 22px;"   >-- 当然这个NEW值也可以理解为(最后一个before for each row的返回值).</span></div><div>INSERT 0 1</div><div>postgres=# select * from t_ret ;</div><div>&nbsp;id &nbsp;| &nbsp;info &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div><div>-----+--------+----------------------------</div><div>&nbsp;100 | digoal | 2013-03-10 17:50:04.680794</div><div>(1 row)</div></div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   >-- 使用这个函数更能观察出after for each row触发器函数的返回值并不影响下一个after for each row的NEW变量.</div></div><div style="line-height: 22px;"   >-- 因为<span style="line-height: 22px;"   >after for each row 的触发器函数中NEW值(统一来自真正被影响的行数据)</span></div></font><div style="line-height: 22px;"   ><div><font size="2"   >-- 修改触发器函数 :&nbsp;</font></div><div><font size="2"   >postgres=# create or replace function tg_t_ret() returns trigger as $$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >declare r record;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; NEW.id := NEW.id+1;&nbsp;</font></div><div><font size="2"   >&nbsp; raise notice '%, id:%', TG_NAME, NEW.id;&nbsp;</font></div><div><font size="2"   >&nbsp; -- 修改NEW.id , 并返回修改后的NEW .&nbsp;</font></div><div><font size="2"   >&nbsp; return NEW;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><div><font size="2"   >-- 插入测试数据</font></div><div><font size="2"   >postgres=# insert into t_ret values (123,'digoal',now());</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg01, id:124</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg1, id:125</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg02, id:126</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg2, id:126</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >INSERT 0 1</font></div></div><div style="line-height: 22px;"   ><font size="2"   >-- 注意after for each row的触发器函数中, 原始NEW.id值都是125, 因此打印的修改后的NEW.id都=126.</font></div><div style="line-height: 22px;"   ><font size="2"   >-- after for each row触发器函数的返回值并不会影响returning的值, returning的值也是来自真正的行数据. (view的触发器场景除外)</font></div><div style="line-height: 22px;"   ><div><font size="2"   >postgres=# insert into t_ret values (123,'digoal',now()) returning id;</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg01, id:124</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg1, id:125</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg02, id:126</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg2, id:126</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >-- 如下, returning 的值为125, 而不是126.</font></div><div><font size="2"   >&nbsp;id &nbsp;</font></div><div><font size="2"   >-----</font></div><div><font size="2"   >&nbsp;125</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >INSERT 0 1</font></div></div></div><p style="line-height: 22px;"   ></p></pre></div><div><div><br></div></div><div style="line-height: 22px;"   >-- DELETE before&nbsp;<span style="line-height: 22px;"   >for each row 触发器函数&nbsp;</span><span style="line-height: 22px;"   >接收 OLD,&nbsp;</span><span style="line-height: 22px;"   >修改这个record对结果的影响是什么?</span></div><div><div><pre class="prettyprint"   ><p style="line-height: 22px;"   ></p><div><div style="line-height: 22px;"   ><font size="2"   >postgres=# create or replace function tg_t_ret() returns trigger as $$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >declare</font></div><div style="line-height: 22px;"   ><font size="2"   >begin</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; OLD.id := OLD.id+1;&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; raise notice '%, id:%', TG_NAME, OLD.id;&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; return OLD;</font></div><div style="line-height: 22px;"   ><font size="2"   >end;</font></div><div style="line-height: 22px;"   ><font size="2"   >$$ language plpgsql;</font></div><div style="line-height: 22px;"   ><font size="2"   >CREATE FUNCTION</font></div><div style="line-height: 22px;"   ><font size="2"   >postgres=# create trigger tg3 before DELETE ON t_ret for each row execute procedure tg_t_ret();</font></div><div style="line-height: 22px;"   ><font size="2"   >CREATE TRIGGER</font></div><div style="line-height: 22px;"   ><font size="2"   >postgres=# delete from t_ret where id=1;</font></div><div style="line-height: 22px;"   ><font size="2"   >DELETE 0</font></div><div style="line-height: 22px;"   ><font size="2"   >postgres=# delete from t_ret where id=2;</font></div><div style="line-height: 22px;"   ><font size="2"   >NOTICE: &nbsp;00000: tg3, id:3</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div style="line-height: 22px;"   ><font size="2"   >-- 虽然触发器函数返回的OLD.id=3, 但是实际上删除的行是id=2的行. 说明delete before for each row的触发器函数返回值并不能改变行的定位. 与此不同的是, 当delete before for each row触发器函数的返回值为空时, 不会执行delete数据行的操作.</font></div><div style="line-height: 22px;"   ><font size="2"   >DELETE 1</font></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >postgres=# select * from t_ret ;</font></span></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >----+--------+----------------------------</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; 3 | digoal | 2013-03-10 17:33:32.91286</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; 3 | digoal | 2013-03-10 17:34:17.854048</font></div><div style="line-height: 22px;"   ><font size="2"   >(2 rows)</font></div><div style="line-height: 22px;"   ><font size="2"   >-- 返回空, 不会执行delete操作, 如下</font></div><div><font size="2"   >postgres=# CREATE OR REPLACE FUNCTION public.tg_t_ret()<br> RETURNS trigger<br> LANGUAGE plpgsql<br>AS $function$                         <br>declare<br>begin<br>  OLD.id := OLD.id+1; <br>  raise notice '%, id:%', TG_NAME, OLD.id; <br>  return null;<br>end;<br>$function$;<br>CREATE FUNCTION</font></div><div><font size="2"   >postgres=# create trigger tg1 before delete on t_ret for each row execute procedure tg_t_ret();<br>CREATE TRIGGER</font></div><div><font size="2"   >postgres=# delete from t_ret where id=1;<br>NOTICE:  00000: tg1, id:1<br>LOCATION:  exec_stmt_raise, pl_exec.c:2840<br>DELETE 0</font></div><div><font size="2"   >-- 没有删除数据. 因为tg_t_ret触发器函数返回空.<br>postgres=# select * from t_ret;<br> id | info |          crt_time          <br>----+------+----------------------------<br>  1 | abc  | 2013-03-10 20:38:50.951669<br>(1 row)</font></div><div style="line-height: 22px;"   ><font size="2"   >-- before for each row 的返回值不影响returning的值, returning 的值来自真实的受影响的行数据.</font></div><div style="line-height: 22px;"   ><div><font size="2"   >postgres=# delete from t_ret where id=100 returning *;</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg3, id:101</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg3, id:101</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >&nbsp;id &nbsp;| &nbsp;info &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----+--------+----------------------------</font></div><div><font size="2"   >&nbsp;100 | digoal | 2013-03-10 17:50:04.680794</font></div><div><font size="2"   >&nbsp;100 | digoal | 2013-03-10 17:54:58.572425</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   >DELETE 2</font></div></div><div style="line-height: 22px;"   ><font size="2"   >-- 如上, DELETE before for each row触发器函数的返回值OLD.id=101, 但是returning的值是被删除的行数据的值 , 因此ID=100.</font></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >-- 如下DELETE after for each row的返回值也不影响returning的返回值. returning的值取自真正被影响的行.</font></span></div></div><div style="line-height: 22px;"   ><div><font size="2"   >postgres=# create trigger tg04 after DELETE ON t_ret for each row execute procedure tg_t_ret();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >postgres=# delete from t_ret where id=123 returning *;</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg3, id:124</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg04, id:124 , 触发器函数返回值OLD.id为124, returning id为123.</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >&nbsp;id &nbsp;| &nbsp;info &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >-----+--------+----------------------------</font></div><div><font size="2"   >&nbsp;123 | digoal | 2013-03-10 17:55:02.809048</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >DELETE 1</font></div></div><p style="line-height: 22px;"   ></p></pre></div></div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >-- UPDATE before&nbsp;</span><span style="line-height: 22px;"   >for each row 触发器函数&nbsp;</span><span style="line-height: 22px;"   >接收 NEW 还是 OLD? 修改这个record对结果的影响是什么?</span></div><div><pre class="prettyprint"   ><p style="line-height: 22px;"   ></p><div style="line-height: 22px;"   ><div><font size="2"   >postgres=# drop table t_ret;</font></div><div><font size="2"   >DROP TABLE</font></div><div><font size="2"   >postgres=# create table t_ret(id int, info text, crt_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# insert into t_ret values (1,'digoal',now()), (2,'DIGOAL',now()), (3,'digoal',now()), (4,'abc',now());</font></div><div><font size="2"   >INSERT 0 4</font></div></div><div style="line-height: 22px;"   ><div><font size="2"   >postgres=# create or replace function tg_t_ret() returns trigger as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; OLD.id := OLD.id+1;</font></div><div><font size="2"   >&nbsp; NEW.id := NEW.id+1;</font></div><div><font size="2"   >&nbsp; raise notice '%, old.id:%. new.id:%', TG_NAME, OLD.id, NEW.id;</font></div><div><font size="2"   >&nbsp; return null;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div></div><div style="line-height: 22px;"   ><div><font size="2"   >postgres=# create trigger tg1 before update ON t_ret for each row execute PROCEDURE tg_t_ret();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >postgres=# create trigger tg2 before update ON t_ret for each row execute PROCEDURE tg_t_ret();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >-- update before for each row 触发器函数返回空, 将不会执行update操作.</font></div><div><font size="2"   >postgres=# update t_ret set info='new' where id=1 returning *;</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg1, old.id:2. new.id:2</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >&nbsp;id | info | crt_time&nbsp;</font></div><div><font size="2"   >----+------+----------</font></div><div><font size="2"   >(0 rows)</font></div><div><font size="2"   >UPDATE 0</font></div></div><div style="line-height: 22px;"   ><font size="2"   ><br></font></div><div style="line-height: 22px;"   ><font size="2"   >-- 当update before for each row 触发器函数的返回值不为空时, 被更改的行的最终值将与最后一个执行的before for each row 触发器函数的返回值一致.</font></div><div style="line-height: 22px;"   ><font size="2"   >-- 本例的tg2是最后一次调用的update before for each row触发器函数, 它的返回值为NEW.id := 3, NEW.info := 'new', NEW.crt_time保持原值.</font></div><div style="line-height: 22px;"   ><font size="2"   >-- 因此更新后的值id = 3, 而不是原来的1.</font></div><div><div style="line-height: 22px;"   ><font size="2"   >postgres=# create or replace function tg_t_ret() returns trigger as $$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >declare</font></div><div style="line-height: 22px;"   ><font size="2"   >begin</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; OLD.id := OLD.id+1;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; NEW.id := NEW.id+1;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; raise notice '%, old.id:%. new.id:%', TG_NAME, OLD.id, NEW.id;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; return NEW;&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >end;</font></div><div style="line-height: 22px;"   ><font size="2"   >$$ language plpgsql;</font></div><div style="line-height: 22px;"   ><font size="2"   >CREATE FUNCTION</font></div><div style="line-height: 22px;"   ><font size="2"   >postgres=# update t_ret set info='new' where id=1 returning *;</font></div><div style="line-height: 22px;"   ><font size="2"   >NOTICE: &nbsp;00000: tg1, old.id:2. new.id:2</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div style="line-height: 22px;"   ><font size="2"   >-- 前后两次调用的触发器函数OLD的值一样, 说明OLD的值是从原始的HeapTuple拷贝过来的, 而不是拷贝的指针.</font></div><div><font size="2"   style="line-height: 22px;"   >-- 第一个update before for each row触发器函数中的NEW值一部分是从SQL语句传入的(修改的值), 另一</font><font size="2"   ><span style="line-height: 19px;"   >部分是从原始的HeapTuple拷贝过来的(未修改的值).</span></font></div><div><font size="2"   ><span style="line-height: 19px;"   >-- 接下来的update before for each row 触发器函数则是上一个触发器函数的返回值.</span></font></div><div><font size="2"   ><span style="line-height: 19px;"   >-- 最终被更新的行数据则是最后一个update before for each row 触发器函数的返回值.</span></font></div><div style="line-height: 22px;"   ><font size="2"   >NOTICE: &nbsp;00000: tg2, old.id:2. new.id:3</font></div><div style="line-height: 22px;"   ><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;id | info | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >----+------+----------------------------</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; 3 | new &nbsp;| 2013-03-10 20:56:52.339739</font></div><div style="line-height: 22px;"   ><font size="2"   >(1 row)</font></div><div style="line-height: 22px;"   ><font size="2"   >UPDATE 1</font></div><div style="line-height: 22px;"   ><font size="2"   >postgres=# select * from t_ret ;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >----+--------+----------------------------</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; 2 | DIGOAL | 2013-03-10 20:56:52.339739</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; 3 | digoal | 2013-03-10 20:56:52.339739</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; 4 | abc &nbsp; &nbsp;| 2013-03-10 20:56:52.339739</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; 3 | new &nbsp; &nbsp;| 2013-03-10 20:56:52.339739</font></div><div style="line-height: 22px;"   ><font size="2"   >(4 rows)</font></div></div><p style="line-height: 22px;"   ></p></pre></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><br></span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >-- 返回的record必须与触发这个触发器的表的结构一致. 否则无法转换成该tuple结构. 报错.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create or replace function tg_t_ret() returns trigger as $$</font></div><div><font size="2"   >declare&nbsp;</font></div><div><font size="2"   >&nbsp; r record;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; OLD.id := OLD.id+1;</font></div><div><font size="2"   >&nbsp; NEW.id := NEW.id+1;</font></div><div><font size="2"   >&nbsp; select 1 as id into r;&nbsp;</font></div><div><font size="2"   >&nbsp; raise notice '%, old.id:%. new.id:%', TG_NAME, OLD.id, NEW.id;</font></div><div><font size="2"   >&nbsp; return r;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><div><font size="2"   >postgres=# update t_ret set info='new' where id=2 returning *;</font></div><div><font size="2"   >NOTICE: &nbsp;00000: tg1, old.id:3. new.id:3</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >ERROR: &nbsp;42804: returned row structure does not match the structure of the triggering table</font></div><div><font size="2"   >DETAIL: &nbsp;Number of returned columns (1) does not match expected column count (3).</font></div><div><font size="2"   >CONTEXT: &nbsp;PL/pgSQL function tg_t_ret() during function exit</font></div><div><font size="2"   >LOCATION: &nbsp;convert_tuples_by_position, tupconvert.c:137</font></div><p></p></pre></div></div><div style="line-height: 22px;"   >【小结1】</div><div style="line-height: 22px;"   >INSERT 触发器: for TABLE</div><div><pre class="prettyprint"   ><p style="line-height: 22px;"   ></p><div style="line-height: 22px;"   ><font size="2"   >1. before for each statement (触发器函数的返回值无意义)</font></div><div style="line-height: 22px;"   ><font size="2"   >2. before for each row (第一个被触发的触发器, 触发器函数的NEW值取自SQL语句)</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; 返回值的流水 :&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; 2.1 返回值传递给下一个被触发的before for each row触发器, 作为下一个触发器调用的触发器函数的NEW值.</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; 2.2 如果下面没有before for each row触发器, 则将返回值传递给操作插入行数据的C函数.&nbsp;</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; 2.3 如果返回值为空, 那么跳过本行操作, (如果SQL语句涉及多行, 则跳到下一行的第一个before for each row触发器; 如果SQL不涉及多行或者已经到达最后行, 则直接跳到语句结束或after for each statement的操作;)</font></div><div style="line-height: 22px;"   ><font size="2"   >3. before for each row(可选)</font></div><div style="line-height: 22px;"   ><font size="2"   >4. 检查约束, 插入行的操作</font></div><div style="line-height: 22px;"   ><font size="2"   >5. 以下触发器或returning语句的NEW值取自HeapTuple, 表示物理的数据行中的数据, 因此这里的触发器返回值没有意义, 不会作为NEW值传递给其他触发器.</font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; after for each row 触发器 (&gt;=0个)</font></div><div><font size="2"   style="line-height: 22px;"   >&nbsp; &nbsp; returning 语句, </font><font size="2"   ><span style="line-height: 19px;"   >被插入的行的真实数据, 其实就是最后一个before for each row触发器函数的返回值.</span></font></div><div style="line-height: 22px;"   ><font size="2"   >&nbsp; &nbsp; after for each statement 触发器 (<span style="line-height: 22px;"   >&gt;=0个</span><span style="line-height: 22px;"   >)</span></font></div><p style="line-height: 22px;"   ></p></pre></div><div><div>DELETE 触发器: for TABLE</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >1. before for each statement (触发器函数的返回值无意义)</font></div><div><font size="2"   >2. before for each row (第一个被触发的触发器, 触发器函数的OLD值取自SQL语句)</font></div><div><font size="2"   >&nbsp; &nbsp; 返回值的流水 :&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; 2.1 返回值传递给下一个被触发的before for each row触发器, 作为下一个触发器调用的触发器函数的OLD值.</font></div><div><font size="2"   >&nbsp; &nbsp; 2.2 如果下面没有before for each row触发器, 则进入DELETE行的操作, 注意删除行不是通过上面返回的OLD值定位的, 所以before for each row函数的返回值不会篡改删除行的操作. (注意它和INSERT触发器的分别, 已经存在的数据(DELETE)和不存在的数据(INSERT)).</font></div><div><font size="2"   >&nbsp; &nbsp; 2.3 如果返回值为空, 那么跳过本行操作, (如果SQL语句涉及多行, 则跳到下一行的第一个before for each row触发器; 如果SQL不涉及多行或者已经到达最后行, 则直接跳到语句结束或after for each statement的操作;)</font></div><div><font size="2"   >3. before for each row(可选)</font></div><div><font size="2"   >4. 检查约束, 删除行的操作</font></div><div><font size="2"   >5. 以下触发器或returning语句的OLD值取自HeapTuple, 表示物理的数据行中的数据, 因此这里的触发器返回值没有意义, 不会作为OLD值传递给其他触发器.</font></div><div><font size="2"   >&nbsp; &nbsp; after for each row 触发器 (&gt;=0个)</font></div><div><font size="2"   >&nbsp; &nbsp; returning 语句, 被删除的行的原始数据, 注意不是最后一个before for each row触发器函数的返回值.</font></div><div><font size="2"   >&nbsp; &nbsp; after for each statement 触发器 (&gt;=0个)</font></div><p></p></pre></div></div><div><div>UPDATE 触发器: for TABLE</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >1. before for each statement (触发器函数的返回值无意义)</font></div><div><font size="2"   >2. before for each row (第一个被触发的触发器, 触发器函数的OLD值和NEW值取自SQL语句)</font></div><div><font size="2"   >&nbsp; &nbsp; 返回值的流水 :&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; 2.1 返回值传递给下一个被触发的before for each row触发器, 作为下一个触发器调用的触发器函数的NEW值. OLD值修改不影响下一个触发器函数.</font></div><div><font size="2"   >&nbsp; &nbsp; 2.2 如果下面没有before for each row触发器, 则进入UPDATE行的操作, 注意被更新的行不是通过触发器函数修改过的OLD值定位的, 所以before for each row函数中对OLD值的修改不会篡改删除行的操作. (注意它和INSERT触发器的分别, 已经存在的数据(DELETE)和不存在的数据(INSERT)).</font></div><div><font size="2"   >&nbsp; &nbsp; 例如update t set info='new' where id=1; 如果在触发器中修改了OLD.id=2, 不会变成update t set info='new' where id=2; 修改的行依然是1;</font></div><div><font size="2"   >&nbsp; &nbsp; 2.3 如果返回值为空, 那么跳过本行操作, (如果SQL语句涉及多行, 则跳到下一行的第一个before for each row触发器; 如果SQL不涉及多行或者已经到达最后行, 则直接跳到语句结束或after for each statement的操作;)</font></div><div><font size="2"   >3. before for each row(可选, 上一个before for each row触发器函数的返回值影响这个触发器函数的NEW值, 不影响OLD值)</font></div><div><font size="2"   >4. 检查约束, 删除行的操作, NEW值来自最后一个before for each row触发器函数的返回值.</font></div><div><font size="2"   >5. 以下触发器或returning语句的NEW值取自HeapTuple, 表示物理的数据行中的数据, 因此这里的触发器返回值没有意义, 不会作为NEW值传递给其他触发器.</font></div><div><font size="2"   >&nbsp; &nbsp; after for each row 触发器 (&gt;=0个)</font></div><div><font size="2"   >&nbsp; &nbsp; returning 语句, 展示被更新的行的最终数据, 其实就是最后一个before for each row触发器函数的返回值.</font></div><div><font size="2"   >&nbsp; &nbsp; after for each statement 触发器 (&gt;=0个)</font></div><p></p></pre></div></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><br></span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >-- 视图触发器</span><span style="line-height: 22px;"   >返回空测试</span></div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >-- 创建基表</font></span></div><div><div><div><font size="2"   >digoal=&gt; create table tbl (id int, info text, crt_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >-- 创建视图</font></div><div><font size="2"   >digoal=&gt; create view v_tbl as select * from tbl;</font></div><div><font size="2"   >CREATE VIEW</font></div></div><div><font size="2"   >-- 创建触发器函数</font></div><div><font size="2"   >digoal=&gt; create or replace function tg() returns trigger as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; case TG_OP</font></div><div><font size="2"   >&nbsp; when 'INSERT' then</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%, %, %, %, new:%', TG_OP, TG_NAME, TG_WHEN, TG_LEVEL, NEW;</font></div><div><font size="2"   >&nbsp; when 'UPDATE' then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%, %, %, %, new:%, old:%', TG_OP, TG_NAME, TG_WHEN, TG_LEVEL, NEW, OLD;</font></div><div><font size="2"   >&nbsp; when 'DELETE' then</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%, %, %, %, old:%', TG_OP, TG_NAME, TG_WHEN, TG_LEVEL, OLD;</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >&nbsp; return null;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div></div><div><span style="line-height: 22px;"   ><font size="2"   >-- 创建触发器</font></span></div><div><span style="line-height: 22px;"   ><div><font size="2"   >digoal=&gt; create trigger tg0 instead of insert or update or delete on v_tbl for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><div><font size="2"   >digoal=&gt; create trigger tg1 instead of insert or update or delete on v_tbl for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div></div><div><font size="2"   >-- 插入数据</font></div><div><div><font size="2"   >digoal=&gt; insert into v_tbl values (1, 'digoal', now());</font></div><div><font size="2"   >NOTICE: &nbsp;INSERT, tg0, INSTEAD OF, ROW, new:(1,digoal,"2013-03-11 08:33:54.457727")</font></div><div><font size="2"   >INSERT 0 0</font></div></div><div><font size="2"   >-- ROW_COUNT为0.</font></div><div><font size="2"   >-- before for each row触发器返回空, 将导致后面的for each row 触发器不被触发(注意for each statement不会跳过), 同时跳过对该行的操作.&nbsp;</font></div><div><font size="2"   >-- 数据未插入</font></div><div><div><font size="2"   >digoal=&gt; select * from tbl;</font></div><div><font size="2"   >&nbsp;id | info | crt_time&nbsp;</font></div><div><font size="2"   >----+------+----------</font></div><div><font size="2"   >(0 rows)</font></div></div></span></div><p></p></pre></div><div><span style="line-height: 22px;"   ><div><br></div><div><span style="line-height: 22px;"   >-- 视图触发器</span><span style="line-height: 22px;"   >返回record测试,&nbsp;</span><span style="line-height: 22px;"   >NEW 或者OLD record修改后会带来什么影响?</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><div><span style="line-height: 22px;"   ><font size="2"   >-- 创建触发器函数</font></span></div></span></div><div><div><font size="2"   >digoal=&gt; create or replace function tg() returns trigger as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; case TG_OP</font></div><div><font size="2"   >&nbsp; when 'INSERT' then</font></div><div><font size="2"   >&nbsp; &nbsp; NEW.id := NEW.id+1;</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%, %, %, %, new:%', TG_OP, TG_NAME, TG_WHEN, TG_LEVEL, NEW;</font></div><div><font size="2"   >&nbsp; &nbsp; return NEW;</font></div><div><font size="2"   >&nbsp; when 'UPDATE' then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; NEW.id := NEW.id+1;</font></div><div><font size="2"   >&nbsp; &nbsp; OLD.id := OLD.id+1;</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%, %, %, %, new:%, old:%', TG_OP, TG_NAME, TG_WHEN, TG_LEVEL, NEW, OLD;</font></div><div><font size="2"   >&nbsp; &nbsp; return NEW;</font></div><div><font size="2"   >&nbsp; when 'DELETE' then</font></div><div><font size="2"   >&nbsp; &nbsp; OLD.id := OLD.id+1;</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%, %, %, %, old:%', TG_OP, TG_NAME, TG_WHEN, TG_LEVEL, OLD;</font></div><div><font size="2"   >&nbsp; &nbsp; return OLD;</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div></div><div><font size="2"   >-- 插入测试, 视图的最后一个被触发的instead of for each row触发器的返回值将对ROW_COUNT和RETURNING带来影响. 如下 :&nbsp;</font></div><div><div><font size="2"   >digoal=&gt; insert into v_tbl values (1, 'digoal', now()) returning *;</font></div><div><font size="2"   >NOTICE: &nbsp;INSERT, tg0, INSTEAD OF, ROW, new:(2,digoal,"2013-03-11 08:49:22.983877")</font></div><div><font size="2"   >NOTICE: &nbsp;INSERT, tg1, INSTEAD OF, ROW, new:(3,digoal,"2013-03-11 08:49:22.983877")</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----+--------+----------------------------</font></div><div><font size="2"   >&nbsp; 3 | digoal | 2013-03-11 08:49:22.983877</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >INSERT 0 1</font></div></div><div><font size="2"   >-- 最后一个触发器的返回值变成了returning的输出.</font></div><div><font size="2"   >-- 最后一个触发器如果不返回空, 则ROW_COUNT增1, 如果返回空, ROW_COUNT则不增加.</font></div><div><div><font size="2"   >digoal=&gt; select * from tbl;</font></div><div><font size="2"   >&nbsp;id | info | crt_time&nbsp;</font></div><div><font size="2"   >----+------+----------</font></div><div><font size="2"   >(0 rows)</font></div></div><div><font size="2"   ><br></font></div><div><font size="2"   >-- 需要注意OLD的修改不会传递给下一个instead for each row触发器函数, 也不会传递给操作行的C函数, 也不会传递给returning.&nbsp;</font></div><div><div><font size="2"   >-- 基表数据插入</font></div><div><font size="2"   >digoal=&gt; insert into tbl values (1, 'digoal', now());</font></div><div><font size="2"   >INSERT 0 1</font></div></div><div><font size="2"   >-- 基表数据</font></div><div><div><font size="2"   >digoal=&gt; select * from tbl;</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----+--------+----------------------------</font></div><div><font size="2"   >&nbsp; 1 | digoal | 2013-03-11 08:56:20.326402</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >-- 删除操作, 触发器函数的返回值为OLD. 但是显然没有传递给下一个触发器函数的OLD变量.</font></div><div><font size="2"   >-- 因为两次修改后的OLD.id都是2, 如果传递过去的话, 第二次修改后的OLD.id应该是3</font></div><div><div><font size="2"   >digoal=&gt; delete from v_tbl where id=1 returning *;</font></div><div><font size="2"   >NOTICE: &nbsp;DELETE, tg0, INSTEAD OF, ROW, old:(2,digoal,"2013-03-11 08:56:20.326402")</font></div><div><font size="2"   >NOTICE: &nbsp;DELETE, tg1, INSTEAD OF, ROW, old:(2,digoal,"2013-03-11 08:56:20.326402")</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----+--------+----------------------------</font></div><div><font size="2"   >&nbsp; 1 | digoal | 2013-03-11 08:56:20.326402</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >DELETE 1</font></div></div><div><font size="2"   >-- 因为返回值不为空, 所以row_count变量增1, 同时returning的值来自真实的行数据. 而不是OLD的值.</font></div><div><div><font size="2"   >digoal=&gt; select * from tbl;</font></div><div><font size="2"   >&nbsp;id | &nbsp;info &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;crt_time &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >----+--------+----------------------------</font></div><div><font size="2"   >&nbsp; 1 | digoal | 2013-03-11 08:56:20.326402</font></div><div><font size="2"   >(1 row)</font></div></div><div><font size="2"   >-- 因为id=2不存在, 所以不会触发instead of for each row触发器.</font></div><div><div><font size="2"   >digoal=&gt; delete from v_tbl where id=2 returning *;</font></div><div><font size="2"   >&nbsp;id | info | crt_time&nbsp;</font></div><div><font size="2"   >----+------+----------</font></div><div><font size="2"   >(0 rows)</font></div><div><font size="2"   >DELETE 0</font></div></div><p></p></pre></div></span></div><div><br></div><div>-- 以上触发器函数修改一下, 可以实现修改视图, 并且想修改表一样可以正常返回ROW_COUNT和RETURNING.</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >create or replace function tg() returns trigger as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; case TG_OP</font></div><div><font size="2"   >&nbsp; when 'INSERT' then</font></div><div><font size="2"   >&nbsp; &nbsp; insert into tbl values (NEW.*);</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%, %, %, %, new:%', TG_OP, TG_NAME, TG_WHEN, TG_LEVEL, NEW;</font></div><div><font size="2"   >&nbsp; &nbsp; return NEW;</font></div><div><font size="2"   >&nbsp; when 'UPDATE' then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; delete from tbl where tbl.* = OLD.*;</font></div><div><font size="2"   >&nbsp; &nbsp; insert into tbl values (NEW.*);</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%, %, %, %, new:%, old:%', TG_OP, TG_NAME, TG_WHEN, TG_LEVEL, NEW, OLD;</font></div><div><font size="2"   >&nbsp; &nbsp; return NEW;</font></div><div><font size="2"   >&nbsp; when 'DELETE' then</font></div><div><font size="2"   >&nbsp; &nbsp; delete from tbl where tbl.* = OLD.*;</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%, %, %, %, old:%', TG_OP, TG_NAME, TG_WHEN, TG_LEVEL, OLD;</font></div><div><font size="2"   >&nbsp; &nbsp; return OLD;</font></div><div><font size="2"   >&nbsp; end case;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><p></p></pre></div><div><br></div></div><div>【小结2】</div><div>1. 给视图触发器函数添加返回值, 可以令视图的DML操作和操作表一样正常返回ROW_COUNT和RETURNING值.</div><div>2. 当一个视图上创建了多个instead of for each row触发器时, 触发器函数的返回值将传递给下一个被调用的instead of for each row触发器函数的NEW变量, (OLD不传递).</div><div><br></div><div><span style="line-height: 22px;"   >【小结3】</span></div><div><span style="line-height: 22px;"   >1. 哪些触发器函数的返回值没有意义?</span></div><div><span style="line-height: 22px;"   >&nbsp; &nbsp; -- for each statement的触发器函数的返回值没有意义, 不会造成任何影响. 不管是返回NULL还是HeapTuple都无意义, 所以返回NULL就可以了.</span></div><div><span style="line-height: 22px;"   >&nbsp; &nbsp; -- after for each row 的触发器函数的</span><span style="line-height: 22px;"   >返回值也没有意义, 不会造成任何影响.&nbsp;</span><span style="line-height: 22px;"   >不管是返回NULL还是HeapTuple都无意义,&nbsp;</span><span style="line-height: 22px;"   >所以返回NULL就可以了.</span></div><div>&nbsp; &nbsp; -- 因此有意义的就是before for each row的触发器函数的返回值.&nbsp;</div><div><span style="line-height: 22px;"   >&nbsp; &nbsp; -- before for each row触发器函数</span><span style="line-height: 22px;"   >返回NULL将造成跳过该行的操作, 同时跳过后面所有的for each row触发器.</span></div><div><span style="line-height: 22px;"   >&nbsp; &nbsp; -- before for each row触发器函数返回HeapTuple时, 返回值将传递给下一个</span><span style="line-height: 22px;"   >before for each row的触发器函数的NEW, 或者行操作的C函数.</span></div><div><span style="line-height: 22px;"   >&nbsp; &nbsp; -- 注意OLD不会传递给下一个触发器函数或操作行的C函数.</span></div><div><br></div><div><br></div><div><div style="line-height: 22px;"   >6. 触发器函数的返回值与返回行数的关系, 与变量FOUND, ROW_COUNT, RETURNING的关系.</div><div style="line-height: 22px;"   >FOUND和ROW_COUNT在plpgsql函数中使用 :&nbsp;</div><div style="line-height: 22px;"   >如果表的before for each row触发器函数返回空, 将导致跳过该行处理, 因此如果整个SQL的行都跳过处理那么最终的FOUND=false, ROW_COUNT=0;</div><div style="line-height: 22px;"   >视图的instead of for each row触发器函数返回空, 一样,&nbsp;<span style="line-height: 22px;"   >如果整个SQL的行都跳过处理那么最终的FOUND=false, ROW_COUNT=0;</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >表的returning 取真正被操作的行的最终数据.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >视图的returning 取最后一个instead of for each row触发器函数的返回值.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >FOUND和ROW_COUNT的用法如下 :&nbsp;</span></div><div style="line-height: 22px;"   ><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ></p><pre class="prettyprint"   ><p></p><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ><font size="2"   >There are several ways to determine the effect of a command. The first method is to use the&nbsp;<tt>GET DIAGNOSTICS</tt>&nbsp;command, which has the form:</font></p><pre style="-webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border: 1px solid rgb(207, 207, 207); padding: 2ex; margin-top: 2ex; margin-bottom: 2ex; margin-left: 2ex; overflow: auto; border-top-left-radius: 8px; border-top-right-radius: 8px; border-bottom-right-radius: 8px; border-bottom-left-radius: 8px; background-color: rgb(247, 247, 247); line-height: normal;"   ><font size="2"   >GET [<span> CURRENT </span>] DIAGNOSTICS <tt style="font-weight: bold; font-style: italic;"   >variable</tt> = <tt style="font-weight: bold; font-style: italic;"   >item</tt> [<span> , ... </span>];
</font></pre><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ><font size="2"   >This command allows retrieval of system status indicators. Each&nbsp;<tt style="font-weight: bold; font-style: italic;"   >item</tt>&nbsp;is a key word identifying a status value to be assigned to the specified variable (which should be of the right data type to receive it). The currently available status items are&nbsp;<tt>ROW_COUNT</tt>, the number of rows processed by the last&nbsp;<acronym>SQL&nbsp;command sent to the&nbsp;<acronym>SQL&nbsp;engine, and&nbsp;<tt>RESULT_OID</tt>, the OID of the last row inserted by the most recent&nbsp;<acronym>SQL&nbsp;command. Note that&nbsp;<tt>RESULT_OID</tt>&nbsp;is only useful after an&nbsp;<tt>INSERT</tt>&nbsp;command into a table containing OIDs.</font></p><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ><font size="2"   >An example:</font></p><pre style="-webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border: 1px solid rgb(207, 207, 207); padding: 2ex; margin-top: 2ex; margin-bottom: 2ex; margin-left: 2ex; overflow: auto; border-top-left-radius: 8px; border-top-right-radius: 8px; border-bottom-right-radius: 8px; border-bottom-left-radius: 8px; background-color: rgb(247, 247, 247); line-height: normal;"   ><font size="2"   >GET DIAGNOSTICS integer_var = ROW_COUNT;
</font></pre><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ><font size="2"   >The second method to determine the effects of a command is to check the special variable named&nbsp;<tt>FOUND</tt>, which is of type&nbsp;<tt>boolean</tt>.&nbsp;<tt>FOUND</tt>&nbsp;starts out false within each&nbsp;<span>PL/pgSQL</span>function call. It is set by each of the following types of statements:</font></p><ul style="line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em; font-family: verdana, sans-serif;"   ><li style="line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em;"   ><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em;"   ><font size="2"   >A&nbsp;<tt>SELECT INTO</tt>&nbsp;statement sets&nbsp;<tt>FOUND</tt>&nbsp;true if a row is assigned, false if no row is returned.</font></p></li><li style="line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em;"   ><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em;"   ><font size="2"   >A&nbsp;<tt>PERFORM</tt>&nbsp;statement sets&nbsp;<tt>FOUND</tt>&nbsp;true if it produces (and discards) one or more rows, false if no row is produced.</font></p></li><li style="line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em;"   ><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em;"   ><font size="2"   ><tt>UPDATE</tt>,&nbsp;<tt>INSERT</tt>, and&nbsp;<tt>DELETE</tt>&nbsp;statements set&nbsp;<tt>FOUND</tt>&nbsp;true if at least one row is affected, false if no row is affected.</font></p></li><li style="line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em;"   ><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em;"   ><font size="2"   >A&nbsp;<tt>FETCH</tt>&nbsp;statement sets&nbsp;<tt>FOUND</tt>&nbsp;true if it returns a row, false if no row is returned.</font></p></li><li style="line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em;"   ><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em;"   ><font size="2"   >A&nbsp;<tt>MOVE</tt>&nbsp;statement sets&nbsp;<tt>FOUND</tt>&nbsp;true if it successfully repositions the cursor, false otherwise.</font></p></li><li style="line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em;"   ><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em;"   ><font size="2"   >A&nbsp;<tt>FOR</tt>&nbsp;or&nbsp;<tt>FOREACH</tt>&nbsp;statement sets&nbsp;<tt>FOUND</tt>&nbsp;true if it iterates one or more times, else false.&nbsp;<tt>FOUND</tt>&nbsp;is set this way when the loop exits; inside the execution of the loop,&nbsp;<tt>FOUND</tt>&nbsp;is not modified by the loop statement, although it might be changed by the execution of other statements within the loop body.</font></p></li><li style="line-height: 1.5em; margin-top: 0.2em; margin-bottom: 0.1em;"   ><p style="line-height: 1.5em; margin: 0.2em 0em 1.2em;"   ><font size="2"   ><tt>RETURN QUERY</tt>&nbsp;and&nbsp;<tt>RETURN QUERY EXECUTE</tt>&nbsp;statements set&nbsp;<tt>FOUND</tt>&nbsp;true if the query returns at least one row, false if no row is returned.</font></p></li></ul><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ><font size="2"   >Other&nbsp;<span>PL/pgSQL</span>&nbsp;statements do not change the state of&nbsp;<tt>FOUND</tt>. Note in particular that&nbsp;<tt>EXECUTE</tt>&nbsp;changes the output of&nbsp;<tt>GET DIAGNOSTICS</tt>, but does not change&nbsp;<tt>FOUND</tt>.</font></p><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ><font size="2"   ><tt>FOUND</tt>&nbsp;is a local variable within each&nbsp;<span>PL/pgSQL</span>&nbsp;function; any changes to it affect only the current function.</font></p><p></p></pre></div><div style="line-height: 22px;"   >参见 :&nbsp;</div><div><a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/plpgsql-statements.html"   >http://www.postgresql.org/docs/9.2/static/plpgsql-statements.html</a></div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >7. 触发器的</span><span style="line-height: 22px;"   >延时属性和</span><span style="line-height: 22px;"   >状态.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >当触发器为约束触发器时, 可以增加延时属性, 约束触发器必须创建为after for each row触发器.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >延时触发指放在事务结束时触发.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >非延时触发指放在SQL语句结束时触发.</span></div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p><font size="2"   ><span style="font-family: verdana, sans-serif; line-height: 18.234375px;"   >When the&nbsp;</span><tt style="line-height: 18.234375px;"   >CONSTRAINT</tt><span style="font-family: verdana, sans-serif; line-height: 18.234375px;"   >&nbsp;option is specified, this command creates a&nbsp;</span><i style="font-family: verdana, sans-serif; line-height: 18.234375px;"   >constraint trigger</i><span style="font-family: verdana, sans-serif; line-height: 18.234375px;"   >. This is the same as a regular trigger except that the timing of the trigger firing can be adjusted using&nbsp;</span><a style="color: rgb(0, 78, 102); font-family: verdana, sans-serif; line-height: 18.234375px;" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/sql-set-constraints.html"   >SET CONSTRAINTS</a><span style="font-family: verdana, sans-serif; line-height: 18.234375px;"   >. Constraint triggers must be&nbsp;</span><tt style="line-height: 18.234375px;"   >AFTER ROW</tt><span style="font-family: verdana, sans-serif; line-height: 18.234375px;"   >&nbsp;triggers. They can be fired either at the end of the statement causing the triggering event, or at the end of the containing transaction; in the latter case they are said to be&nbsp;</span><i style="font-family: verdana, sans-serif; line-height: 18.234375px;"   >deferred</i><span style="font-family: verdana, sans-serif; line-height: 18.234375px;"   >. A pending deferred-trigger firing can also be forced to happen immediately by using&nbsp;</span><tt style="line-height: 18.234375px;"   >SET CONSTRAINTS</tt><span style="font-family: verdana, sans-serif; line-height: 18.234375px;"   >. Constraint triggers are expected to raise an exception when the constraints they implement are violated.</span></font></p><p><span style="font-family: verdana, sans-serif; font-size: 12px; line-height: 18.234375px; white-space: normal;"   ><br></span></p><p><span style="font-family: verdana, sans-serif; font-size: 12px; line-height: 18.234375px; white-space: normal;"   >Note that for constraint triggers, evaluation of the&nbsp;</span><tt style="font-size: 12px; line-height: 18.234375px; white-space: normal;"   >WHEN</tt><span style="font-family: verdana, sans-serif; font-size: 12px; line-height: 18.234375px; white-space: normal;"   >&nbsp;condition is not deferred, but occurs immediately after the row update operation is performed. If the condition does not evaluate to true then the trigger is not queued for deferred execution.</span></p></pre></div><div><span style="line-height: 22px;"   >触发器还有一个和会话参数</span>session_replication_role结合使用的隐含特性, 需要使用ALTER TABLE来修改, 如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >session_replication_role (enum)</font></div><div><font size="2"   >Controls firing of replication-related triggers and rules for the current session. Setting this variable requires superuser privilege and results in discarding any previously cached query plans.&nbsp;</font></div><div><font size="2"   >Possible values are origin (the default), replica and local.&nbsp;</font></div><div><font size="2"   >See ALTER TABLE for more information.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >DISABLE/ENABLE [ REPLICA | ALWAYS ] TRIGGER</font></div><div><font size="2"   >These forms configure the firing of trigger(s) belonging to the table. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. For a deferred trigger, the enable status is checked when the event occurs, not when the trigger function is actually executed.&nbsp;</font></div><div><font size="2"   >One can disable or enable a single trigger specified by name, or all triggers on the table, or only user triggers (this option excludes internally generated constraint triggers such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints).&nbsp;</font></div><div><font size="2"   >Disabling or enabling internally generated constraint triggers requires superuser privileges; it should be done with caution since of course the integrity of the constraint cannot be guaranteed if the triggers are not executed.&nbsp;</font></div><div><font size="2"   >The trigger firing mechanism is also affected by the configuration variable session_replication_role.&nbsp;</font></div><div><font size="2"   >Simply enabled triggers will fire when the replication role is "origin" (the default) or "local".&nbsp;</font></div><div><font size="2"   >Triggers configured as ENABLE REPLICA will only fire if the session is in "replica" mode, and triggers configured as ENABLE ALWAYS will fire regardless of the current replication mode.</font></div><p></p></pre></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >如果在表上面执行enable replica trigger $tg_name, 那么这个触发器只有当</span><span style="line-height: 22px;"   >会话参数session_replication_role=replica时,</span><span style="line-height: 22px;"   >&nbsp;才会被触发</span><span style="line-height: 22px;"   >.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >如果会话参数session_replication_role=origin或者local, 这个触发器将不会被触发.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >如果在表上面执行</span><span style="line-height: 22px;"   >enable always trigger $tg_name, 那么这个触发器不管会话参数</span><span style="line-height: 22px;"   >session_replication_role的值是什么, 都会被触发.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >其实这个用法还可以通过application_name参数以及触发器中配置判断application_name的控制语句来实现, 当然效率没有上面的方法高 :&nbsp;</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >例如 :&nbsp;</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >pgsql中的application_name可以这么来修改 :&nbsp;</span></div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >-- 连接参数中修改</font></span></div><div><div><font size="2"   >ocz@db-172-16-3-150-&gt; psql postgresql://:9201/digoal?application_name=digoal</font></div><div><font size="2"   >psql (9.2.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >digoal=# show application_name;</font></div><div><font size="2"   >&nbsp;application_name&nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >&nbsp;digoal</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=# \q</font></div><div><font size="2"   >-- 会话中修改 :&nbsp;</font></div><div><font size="2"   >ocz@db-172-16-3-150-&gt; psql</font></div><div><font size="2"   >psql (9.2.1)</font></div><div><font size="2"   >Type "help" for help.</font></div><div><font size="2"   >postgres=# show application_name;</font></div><div><font size="2"   >&nbsp;application_name&nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >&nbsp;psql</font></div><div><font size="2"   >(1 row)</font></div></div><div><div><font size="2"   >postgres=# set application_name='abc';</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >postgres=# show application_name;</font></div><div><font size="2"   >&nbsp;application_name&nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >&nbsp;abc</font></div><div><font size="2"   >(1 row)</font></div></div><p></p></pre></div><div>使用application_name实现触发器内部控制 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table abc(id int, info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=&gt; create or replace function tg() returns trigger as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; v_app_name text;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; select setting into v_app_name from pg_settings where name='application_name';</font></div><div><font size="2"   >&nbsp; if v_app_name='digoal' then</font></div><div><font size="2"   >&nbsp; &nbsp; return null;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; return NEW;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><div><font size="2"   >digoal=&gt; create trigger tg0 before insert on abc for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; select setting from pg_settings where name='application_name';</font></div><div><font size="2"   >&nbsp;setting&nbsp;</font></div><div><font size="2"   >---------</font></div><div><font size="2"   >&nbsp;psql</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >digoal=&gt; insert into abc values(1,'digoal');</font></div><div><font size="2"   >INSERT 0 1</font></div><div><font size="2"   >-- 当application_name='digoal'时不插入数据.</font></div><div><font size="2"   >digoal=&gt; set application_name='digoal';</font></div><div><font size="2"   >SET</font></div><div><font size="2"   >digoal=&gt; insert into abc values(1,'digoal');</font></div><div><font size="2"   >INSERT 0 0</font></div><p></p></pre></div><div>使用session_replication_role来控制触发器是否被触发.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; create table abc(id int, info text);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=&gt; create or replace function tg() returns trigger as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; raise notice '%', TG_NAME;</font></div><div><font size="2"   >&nbsp; return NEW;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><div><font size="2"   >digoal=&gt; alter table abc enable replica trigger tg0;</font></div><div><font size="2"   >ALTER TABLE</font></div><div><font size="2"   >-- 当<span style="line-height: 22px;"   >session_replication_role=origin并且trigger tg0 修改为enable replica时, 触发器未被触发.</span></font></div><div><div><font size="2"   >digoal=&gt; show session_replication_role;</font></div><div><font size="2"   >&nbsp;session_replication_role&nbsp;</font></div><div><font size="2"   >--------------------------</font></div><div><font size="2"   >&nbsp;origin</font></div><div><font size="2"   >(1 row)</font></div></div></div><div><div><font size="2"   >digoal=&gt; insert into abc values (1,'digoal');</font></div><div><font size="2"   >INSERT 0 1</font></div></div><div><font size="2"   ><br></font></div><div><span style="line-height: 22px;"   ><font size="2"   >-- set session_replication_role需要超级用户权限 :&nbsp;</font></span></div><div><div><font size="2"   >digoal=&gt; \c digoal postgres</font></div><div><font size="2"   >You are now connected to database "digoal" as user "postgres".</font></div><div><font size="2"   ><span style="line-height: 22px;"   >-- 当</span><span style="line-height: 22px;"   >session_replication_role=replica并且trigger tg0 修改为enable replica时, 触发器被触发了.</span></font></div><div><font size="2"   >digoal=# set session_replication_role='replica';</font></div><div><font size="2"   >SET</font></div></div><div><div><font size="2"   >digoal=# insert into digoal.abc values (1,'digoal');</font></div><div><font size="2"   >NOTICE: &nbsp;tg0</font></div><div><font size="2"   >INSERT 0 1</font></div></div><p></p></pre></div><div><br></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >8. 可以在系统表或系统视图上创建触发器吗?</span></div></div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >不可以, 如下 :&nbsp;</font></span></div><div><div><font size="2"   >digoal=# create trigger tg before insert on pg_database for each row execute procedure tg();</font></div><div><font size="2"   >ERROR: &nbsp;42501: permission denied: "pg_database" is a system catalog</font></div><div><font size="2"   >LOCATION: &nbsp;CreateTrigger, trigger.c:195</font></div></div><div><font size="2"   >详见</font></div><div><font size="2"   >src/backend/commands/trigger.c</font></div><p></p></pre></div><div><br></div><div>【小结】</div><div>1. 注意各种触发器在操作流中的顺序, 返回值的传递, 返回值的意义.</div><div>2. 注意当1个表上有多个同类触发器时, 需要注意他们之间的参数传递, 触发顺序.</div><div>3. 还要注意触发器的可视, 下一篇中会着重讲可视特性.</div><div><br></div>【参考】<div>1.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/trigger-definition.html"   >http://www.postgresql.org/docs/9.2/static/trigger-definition.html</a></div><div>2.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/trigger-datachanges.html"   >http://www.postgresql.org/docs/9.2/static/trigger-datachanges.html</a></div><div>3.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/spi-visibility.html"   >http://www.postgresql.org/docs/9.2/static/spi-visibility.html</a></div><div>4.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/trigger-example.html"   >http://www.postgresql.org/docs/9.2/static/trigger-example.html</a></div><div>5.&nbsp;<a target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/plpgsql-trigger.html"   >http://www.postgresql.org/docs/9.2/static/plpgsql-trigger.html</a><br>6.&nbsp;<wbr><a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/sql-createtrigger.html"   >http://www.postgresql.org/docs/9.2/static/sql-createtrigger.html</a></div><div>7.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/trigger-interface.html"   >http://www.postgresql.org/docs/9.2/static/trigger-interface.html</a></div><div>8.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/sql-set-constraints.html"   >http://www.postgresql.org/docs/9.2/static/sql-set-constraints.html</a></div><div>9.&nbsp;src/backend/commands/trigger.c</div><div>10.&nbsp;src/include/commands/trigger.h</div><div>11.&nbsp;src/include/utils/reltrigger.h</div>12. 触发器的应用 :&nbsp;<div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020128772037884/"   >http://blog.163.com/digoal@126/blog/static/16387704020128772037884/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020120133019990/"   >http://blog.163.com/digoal@126/blog/static/16387704020120133019990/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201251931517556/"   >http://blog.163.com/digoal@126/blog/static/163877040201251931517556/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020130931040444/"   >http://blog.163.com/digoal@126/blog/static/16387704020130931040444/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201301483549300/"   >http://blog.163.com/digoal@126/blog/static/163877040201301483549300/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012325111528424/"   >http://blog.163.com/digoal@126/blog/static/1638770402012325111528424/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201211193542316/"   >http://blog.163.com/digoal@126/blog/static/163877040201211193542316/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012731203716/"   >http://blog.163.com/digoal@126/blog/static/1638770402012731203716/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012731944439/"   >http://blog.163.com/digoal@126/blog/static/1638770402012731944439/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020128142829610/"   >http://blog.163.com/digoal@126/blog/static/16387704020128142829610/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020129851138327/"   >http://blog.163.com/digoal@126/blog/static/16387704020129851138327/</a></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201119111234570/"   >http://blog.163.com/digoal@126/blog/static/163877040201119111234570/</a></div></div></div>
	</div>
</div>
</body>
</html>