<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL trigger introduction - 2</h2>
	<h5 id="">2013-03-11 12:51:26&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013211102130526/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div style="line-height: 22px;"   >以PostgreSQL 9.2为例, 介绍触发器的使用<span style="line-height: 22px;"   >.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >接上一篇 :&nbsp;</span></div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402013283547959/"   >http://blog.163.com/digoal@126/blog/static/1638770402013283547959/</a></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><br></span></div><wbr style="line-height: 22px;"   ><div style="line-height: 22px;"   >包含如下内容 :&nbsp;</div><div style="line-height: 22px;"   >一、</div><div style="line-height: 22px;"   >1. 什么是触发器? 触发器有什么用? 创建触发器的语法?</div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >2. 什么是触发器函数,&nbsp;</span><span style="line-height: 22px;"   >触发器函数可以用哪些语言编写</span><span style="line-height: 22px;"   >?</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >3. 触发器有哪些分类?</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >4. 同一个表或视图上可以建多少个触发器?&nbsp;</span><span style="line-height: 22px;"   >如果一个表或视图上有多个触发器, 调用顺序如何决定?</span></div><div style="line-height: 22px;"   >5. 同一个触发器函数可以被多个触发器调用吗? 触发器函数的返回类型时什么? 触发器函数的返回值是否会影响下一个触发器函数<span style="line-height: 22px;"   >或者被操作的行的数据</span><span style="line-height: 22px;"   >? NEW 或者OLD record修改后会带来什么影响? 哪些触发器函数的返回值没有意义?</span></div><div style="line-height: 22px;"   >6. 触发器函数的返回值与返回行数的关系, 与变量FOUND, ROW_COUNT, RETURNING的关系.</div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >7. 触发器的</span><span style="line-height: 22px;"   >延时属性和</span><span style="line-height: 22px;"   >状态.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >8. 可以在系统表或系统视图上创建触发器吗?</span></div><div style="line-height: 22px;"   >二、</div><div style="line-height: 22px;"   >以plpgsql语言为例, 讲解触发器函数.</div><div style="line-height: 22px;"   >9. 触发器函数的返回值.</div><div style="line-height: 22px;"   >10. 触发器函数的参数与值传递.</div><div style="line-height: 22px;"   >11. 触发器函数中的变量与传递.</div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >12. 触发器函数的数据可视与什么有关?</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >13. 触发器会无限递归吗? 如何避免?</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >14. 触发条件与性能.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >15. 加入触发器后的事务特性.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >16. 触发器的返回值是如何影响returning的结果的?</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><br style="line-height: 22px;"   ></span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >【正文】</span></div><div><div style="line-height: 22px;"   >二、</div><div style="line-height: 22px;"   >以plpgsql语言为例, 讲解触发器函数.</div><div style="line-height: 22px;"   >9. 触发器函数的返回值.</div><div style="line-height: 22px;"   >上一篇中有大量的例子进行讲解, 文章末尾也做了总结, 这里就略过了.</div><div style="line-height: 22px;"   >稍微小结一下,</div><div style="line-height: 22px;"   >[返回值的类型 : ]</div><div style="line-height: 22px;"   >&nbsp; 空 或者 触发器函数所在表或视图的结构化数据(record类型).</div><div style="line-height: 22px;"   >[返回值的意义 : ]</div><div style="line-height: 22px;"   ><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"   ><span style="line-height: 22px;"   >&nbsp; &nbsp; -- for each statement的触发器函数的返回值没有意义, 不会造成任何影响. 不管是返回NULL还是HeapTuple都无意义, 所以返回NULL就可以了.</span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"   ><span style="line-height: 22px;"   >&nbsp; &nbsp; -- after for each row 的触发器函数的</span><span style="line-height: 22px;"   >返回值也没有意义, 不会造成任何影响.&nbsp;</span><span style="line-height: 22px;"   >不管是返回NULL还是HeapTuple都无意义,&nbsp;</span><span style="line-height: 22px;"   >所以返回NULL就可以了.</span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"   >&nbsp; &nbsp; -- 因此有意义的就是before for each row的触发器函数的返回值.&nbsp;</div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"   ><span style="line-height: 22px;"   >&nbsp; &nbsp; -- before for each row触发器函数</span><span style="line-height: 22px;"   >返回NULL将造成跳过该行的操作, 同时跳过后面所有的for each row触发器.</span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"   ><span style="line-height: 22px;"   >&nbsp; &nbsp; -- before for each row触发器函数返回HeapTuple时, 返回值将传递给下一个</span><span style="line-height: 22px;"   >before for each row的触发器函数的NEW, 或者行操作的C函数.</span></div><div style="line-height: 25px; font-family: Arial, Helvetica, simsun, u5b8bu4f53;"   ><span style="line-height: 22px;"   >&nbsp; &nbsp; -- 注意OLD不会传递给下一个触发器函数或操作行的C函数.</span></div></div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   >10. 触发器函数的参数与值传递.</div><div style="line-height: 22px;"   >这里说的是plpgsql触发器函数的参数, 不是放在形参定义中, 而是使用TG_ARGV[]来获取.</div><div style="line-height: 22px;"   >参数的值传递 :&nbsp;</div><div style="line-height: 22px;"   >在创建触发器时传递, 以STRING常量类型传递, 如果不是string类型, 会自动转换成string类型.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >arguments</font></div><div><font size="2"   >An optional comma-separated list of arguments to be provided to the function when the trigger is executed. The arguments are literal string constants. Simple names and numeric constants can be written here, too, but they will all be converted to strings. Please check the description of the implementation language of the trigger function to find out how these arguments can be accessed within the function; it might be different from normal function arguments.</font></div><p></p></pre></div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; create or replace function tg() returns trigger as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; raise notice 'args:%', TG_NARGS;&nbsp;</font></div><div><font size="2"   >&nbsp; if TG_NARGS&gt;0 then</font></div><div><font size="2"   >&nbsp; &nbsp; for i in 0..(TG_NARGS-1) loop</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; raise notice 'ARG%: %', i, TG_ARGV[i];</font></div><div><font size="2"   >&nbsp; &nbsp; end loop;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >&nbsp; return new;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div></div><div><div><font size="2"   >digoal=&gt; create table arg_test (id int, info text, crt_time timestamp);</font></div><div><font size="2"   >CREATE TABLE</font></div></div><div><font size="2"   >-- 参数是字符串常量, 不是变量.</font></div><div><div><font size="2"   >digoal=&gt; create trigger tg0 before insert on arg_test for each row execute procedure tg(id, info, crt_time);</font></div><div><font size="2"   >CREATE TRIGGER</font></div></div><div><div><font size="2"   >digoal=&gt; insert into arg_test values (1,'digoal',now());</font></div><div><font size="2"   >NOTICE: &nbsp;args:3</font></div><div><font size="2"   >NOTICE: &nbsp;ARG0: id</font></div><div><font size="2"   >NOTICE: &nbsp;ARG1: info</font></div><div><font size="2"   >NOTICE: &nbsp;ARG2: crt_time</font></div><div><font size="2"   >INSERT 0 1</font></div></div><p></p></pre></div><div><br></div><div style="line-height: 22px;"   >11. 触发器函数中的变量与传递.&nbsp;</div><div style="line-height: 22px;"   >特殊变量, 这些变量自动被创建 :&nbsp;</div><div style="line-height: 22px;"   ><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ></p><pre class="prettyprint"   ><p></p><p style="line-height: 1.5em; margin: 1.2em 0em; font-family: verdana, sans-serif;"   ><font size="2"   >When a&nbsp;<span>PL/pgSQL</span>&nbsp;function is called as a trigger, several special variables are created automatically in the top-level block. They are:</font></p><div style="font-family: verdana, sans-serif; line-height: normal;"   ><dl><dt><tt><font size="2"   >NEW</font></tt></dt><dd><p style="line-height: 1.5em; margin: 1.2em 0em;"   ><font size="2"   >Data type&nbsp;<tt>RECORD</tt>; variable holding the new database row for&nbsp;<tt>INSERT</tt>/<tt>UPDATE</tt>&nbsp;operations in row-level triggers. This variable is&nbsp;<tt>NULL</tt>&nbsp;in statement-level triggers and for&nbsp;<tt>DELETE</tt>operations.</font></p></dd><dt><tt><font size="2"   >OLD</font></tt></dt><dd><p style="line-height: 1.5em; margin: 1.2em 0em;"   ><font size="2"   >Data type&nbsp;<tt>RECORD</tt>; variable holding the old database row for&nbsp;<tt>UPDATE</tt>/<tt>DELETE</tt>&nbsp;operations in row-level triggers. This variable is&nbsp;<tt>NULL</tt>&nbsp;in statement-level triggers and for&nbsp;<tt>INSERT</tt>operations.</font></p></dd><dt><tt><font size="2"   >TG_NAME</font></tt></dt><dd><p style="line-height: 1.5em; margin: 1.2em 0em;"   ><font size="2"   >Data type&nbsp;<tt>name</tt>; variable that contains the name of the trigger actually fired.</font></p></dd><dt><tt><font size="2"   >TG_WHEN</font></tt></dt><dd><p style="line-height: 1.5em; margin: 1.2em 0em;"   ><font size="2"   >Data type&nbsp;<tt>text</tt>; a string of&nbsp;<tt>BEFORE</tt>,&nbsp;<tt>AFTER</tt>, or&nbsp;<tt>INSTEAD OF</tt>, depending on the trigger's definition.</font></p></dd><dt><tt><font size="2"   >TG_LEVEL</font></tt></dt><dd><p style="line-height: 1.5em; margin: 1.2em 0em;"   ><font size="2"   >Data type&nbsp;<tt>text</tt>; a string of either&nbsp;<tt>ROW</tt>&nbsp;or&nbsp;<tt>STATEMENT</tt>&nbsp;depending on the trigger's definition.</font></p></dd><dt><tt><font size="2"   >TG_OP</font></tt></dt><dd><p style="line-height: 1.5em; margin: 1.2em 0em;"   ><font size="2"   >Data type&nbsp;<tt>text</tt>; a string of&nbsp;<tt>INSERT</tt>,&nbsp;<tt>UPDATE</tt>,&nbsp;<tt>DELETE</tt>, or&nbsp;<tt>TRUNCATE</tt>&nbsp;telling for which operation the trigger was fired.</font></p></dd><dt><tt><font size="2"   >TG_RELID</font></tt></dt><dd><p style="line-height: 1.5em; margin: 1.2em 0em;"   ><font size="2"   >Data type&nbsp;<tt>oid</tt>; the object ID of the table that caused the trigger invocation.</font></p></dd><dt><tt><font size="2"   >TG_RELNAME</font></tt></dt><dd><p style="line-height: 1.5em; margin: 1.2em 0em;"   ><font size="2"   >Data type&nbsp;<tt>name</tt>; the name of the table that caused the trigger invocation. This is now deprecated, and could disappear in a future release. Use&nbsp;<tt>TG_TABLE_NAME</tt>&nbsp;instead.</font></p></dd><dt><tt><font size="2"   >TG_TABLE_NAME</font></tt></dt><dd><p style="line-height: 1.5em; margin: 1.2em 0em;"   ><font size="2"   >Data type&nbsp;<tt>name</tt>; the name of the table that caused the trigger invocation.</font></p></dd><dt><tt><font size="2"   >TG_TABLE_SCHEMA</font></tt></dt><dd><p style="line-height: 1.5em; margin: 1.2em 0em;"   ><font size="2"   >Data type&nbsp;<tt>name</tt>; the name of the schema of the table that caused the trigger invocation.</font></p></dd><dt><tt><font size="2"   >TG_NARGS</font></tt></dt><dd><p style="line-height: 1.5em; margin: 1.2em 0em;"   ><font size="2"   >Data type&nbsp;<tt>integer</tt>; the number of arguments given to the trigger procedure in the&nbsp;<tt>CREATE TRIGGER</tt>&nbsp;statement.</font></p></dd><dt><tt><font size="2"   >TG_ARGV[]</font></tt></dt><dd><p style="line-height: 1.5em; margin: 1.2em 0em;"   ><font size="2"   >Data type array of&nbsp;<tt>text</tt>; the arguments from the&nbsp;<tt>CREATE TRIGGER</tt>&nbsp;statement. The index counts from 0. Invalid indexes (less than 0 or greater than or equal to&nbsp;<tt>tg_nargs</tt>) result in a null value.</font></p></dd></dl></div><p></p></pre></div><div style="line-height: 22px;"   >其他变量 :&nbsp;</div><div style="line-height: 22px;"   >与plpgsql函数的用法一致.&nbsp;</div><div style="line-height: 22px;"   >declare 中声明.</div><div style="line-height: 22px;"   >begin 中使用.</div><div style="line-height: 22px;"   >这里不详细讲解.</div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >12. 触发器函数的数据可视与什么有关?</span></div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >在触发器函数中执行SQL时, 需要特别注意数据的可视, 是否能看到触发这个触发器的SQL语句前面已经修改过的行数据.</font></span></div><div><div><font size="2"   >If you execute SQL commands in your trigger function, and these commands access the table that the trigger is for, then you need to be aware of the data visibility rules, because they determine whether these SQL commands will see the data change that the trigger is fired for. Briefly:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Statement-level triggers follow simple visibility rules: none of the changes made by a statement are visible to statement-level triggers that are invoked before the statement, whereas all modifications are visible to statement-level AFTER triggers.</font></div><div><font size="2"   >before for each statement 不能看到任何数据更改.&nbsp;</font></div><div><span style="line-height: 22px;"   ><font size="2"   >after for each statement 能看到所有的数据更改.&nbsp;</font></span></div><div><font size="2"   ><br></font></div><div><font size="2"   >The data change (insertion, update, or deletion) causing the trigger to fire is naturally not visible to SQL commands executed in a row-level BEFORE trigger, because it hasn't happened yet.</font></div><div><font size="2"   >before for each row触发器不能看到insert , update , delete对本行数据的更改. 因为本行数据变更尚未发生.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >However, SQL commands executed in a row-level BEFORE trigger will see the effects of data changes for rows previously processed in the same outer command. This requires caution, since the ordering of these change events is not in general predictable; a SQL command that affects multiple rows can visit the rows in any order.</font></div><div><font size="2"   >before for each row触发器可以看到其他已经变更的行的数据, 因为一条SQL语句可能操作多条数据, 后面的行触发器可以看到前面已经变更的行数据.&nbsp;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >Similarly, a row-level INSTEAD OF trigger will see the effects of data changes made by previous firings of INSTEAD OF triggers in the same outer command.</font></div><div><font size="2"   >instead of 触发器与上面类似,&nbsp;<span style="line-height: 22px;"   >可以看到其他已经变更的行的数据, 因为一条SQL语句可能操作多条数据, 后面的行触发器可以看到前面已经变更的行数据.&nbsp;</span></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >When a row-level AFTER trigger is fired, all data changes made by the outer command are already complete, and are visible to the invoked trigger function.</font></div><div><font size="2"   >注意, after for each row触发器函数可以看到所有的数据变更, 因为after for each row触发器是在所有行都操作完后触发的.&nbsp;</font></div><div><font size="2"   >例如SQL语句更新10条记录, 那么是这样的流程 :&nbsp;</font></div><div><font size="2"   >1. before for each statement(触发1次)</font></div><div><font size="2"   >2. 循环10次</font></div><div><font size="2"   >{</font></div><div><font size="2"   >before for each row (触发1次)</font></div><div><font size="2"   >检查约束, 操作行.</font></div><div><font size="2"   >}</font></div><div><font size="2"   >3. after for each row(触发10次)</font></div><div><font size="2"   >4. after for each statement(触发1次)</font></div><div><font size="2"   ><br></font></div><div><span style="line-height: 22px;"   ><font size="2"   >If your trigger function is written in any of the standard procedural languages, then the above statements apply only if the function is declared VOLATILE.&nbsp;</font></span></div><div><span style="line-height: 22px;"   ><font size="2"   >Functions that are declared STABLE or IMMUTABLE will not see changes made by the calling command in any case.</font></span></div></div><div><span style="line-height: 22px;"   ><font size="2"   >以上对变更数据的可视仅限于函数为volatile, 当触发器函数为stable或者immutable时, 任何情况下都不能看到已经变更的数据.</font></span></div><p></p></pre></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><br></span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >举例 :&nbsp;</span></div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >-- 创建测试表</font></span></div><div><div><font size="2"   >digoal=&gt; create table test(id int);</font></div><div><font size="2"   >CREATE TABLE</font></div></div><div><font size="2"   >-- 创建触发器函数</font></div><div><div><font size="2"   >digoal=&gt; create or replace function tg() returns trigger as $$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; cnt int8;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; select count(*) into cnt from test where id=1;</font></div><div><font size="2"   >&nbsp; raise notice '%, %, %, %, cnt:%', TG_LEVEL, TG_WHEN, TG_OP, TG_NAME, cnt;</font></div><div><font size="2"   >&nbsp; return new;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql volatile;</font></div><div><font size="2"   >CREATE FUNCTION</font></div></div><div><font size="2"   >-- 创建触发器</font></div><div><div><font size="2"   >digoal=&gt; create trigger tg0 before insert on test for each statement execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; create trigger tg1 after insert on test for each statement execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; create trigger tg2 before insert on test for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; create trigger tg3 before insert on test for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; create trigger tg4 before insert on test for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; create trigger tg5 after insert on test for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; create trigger tg6 after insert on test for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; create trigger tg7 after insert on test for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >-- 插入1行数据</font></span></div><div><div><font size="2"   >digoal=&gt; insert into test values (1);</font></div><div><font size="2"   >NOTICE: &nbsp;STATEMENT, BEFORE, INSERT, tg0, cnt:0</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg2, cnt:0</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg3, cnt:0</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg4, cnt:0</font></div><div><font size="2"   >-- after for each row看到了已经插入的数据.</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg5, cnt:1</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg6, cnt:1</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg7, cnt:1</font></div><div><font size="2"   >NOTICE: &nbsp;STATEMENT, AFTER, INSERT, tg1, cnt:1</font></div><div><font size="2"   >INSERT 0 1</font></div></div><div><font size="2"   ><br></font></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >-- 插入多行数据</font></span></div><div><div><font size="2"   >digoal=&gt; insert into test values (1),(1),(1);</font></div><div><font size="2"   >NOTICE: &nbsp;STATEMENT, BEFORE, INSERT, tg0, cnt:1</font></div><div><font size="2"   >-- 第一行触发以下触发器.</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg2, cnt:1</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg3, cnt:1</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg4, cnt:1</font></div><div><font size="2"   >-- 第2行触发以下触发器.</font></div><div><font size="2"   >-- 能够看到前面1条变更.</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg2, cnt:2</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg3, cnt:2</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg4, cnt:2</font></div><div><div style="line-height: 22px;"   ><font size="2"   >-- 第3行触发以下触发器.</font></div><div style="line-height: 22px;"   ><font size="2"   >-- 能够看到前面2条变更.</font></div></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg2, cnt:3</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg3, cnt:3</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg4, cnt:3</font></div><div><font size="2"   >-- 以下分别为3行after for each row触发的触发器.</font></div><div><font size="2"   >-- after for each row触发器是在所有的before for each row都调用完后, 也就是SQL语句的所有的行操作完成后调用的, 每行调用1次.</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg5, cnt:4</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg6, cnt:4</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg7, cnt:4</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg5, cnt:4</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg6, cnt:4</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg7, cnt:4</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg5, cnt:4</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg6, cnt:4</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg7, cnt:4</font></div><div><font size="2"   >-- 最后为after for each statement触发器, 可以看到所有变更.</font></div><div><font size="2"   >NOTICE: &nbsp;STATEMENT, AFTER, INSERT, tg1, cnt:4</font></div><div><font size="2"   >INSERT 0 3</font></div></div><p></p></pre></div><div style="line-height: 22px;"   >UPDATE :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; create trigger tg8 before update on test for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; create trigger tg9 before update on test for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; create trigger tg10 after update on test for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; update test set id=2;</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg8, cnt:4</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg9, cnt:4</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg8, cnt:3</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg9, cnt:3</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg8, cnt:2</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg9, cnt:2</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg8, cnt:1</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg9, cnt:1</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, UPDATE, tg10, cnt:0</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, UPDATE, tg10, cnt:0</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, UPDATE, tg10, cnt:0</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, UPDATE, tg10, cnt:0</font></div><div><font size="2"   >UPDATE 4</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >digoal=&gt; update test set id=1;</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg8, cnt:0</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg9, cnt:0</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg8, cnt:1</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg9, cnt:1</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg8, cnt:2</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg9, cnt:2</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg8, cnt:3</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, UPDATE, tg9, cnt:3</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, UPDATE, tg10, cnt:4</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, UPDATE, tg10, cnt:4</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, UPDATE, tg10, cnt:4</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, UPDATE, tg10, cnt:4</font></div><div><font size="2"   >UPDATE 4</font></div></div><p></p></pre></div><div><br></div><div>DELETE :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create trigger tg12 before delete on test for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; create trigger tg13 before delete on test for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; create trigger tg14 after delete on test for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><div><font size="2"   >digoal=&gt; create or replace function tg() returns trigger as $$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >&nbsp; cnt int8;</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; select count(*) into cnt from test where id=1;</font></div><div><font size="2"   >&nbsp; raise notice '%, %, %, %, cnt:%', TG_LEVEL, TG_WHEN, TG_OP, TG_NAME, cnt;</font></div><div><font size="2"   >&nbsp; return old;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql volatile;</font></div><div><font size="2"   >digoal=&gt; delete from test where id=1;</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, DELETE, tg12, cnt:3</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, DELETE, tg13, cnt:3</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, DELETE, tg12, cnt:2</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, DELETE, tg13, cnt:2</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, DELETE, tg12, cnt:1</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, DELETE, tg13, cnt:1</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, DELETE, tg14, cnt:0</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, DELETE, tg14, cnt:0</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, DELETE, tg14, cnt:0</font></div><div><font size="2"   >DELETE 3</font></div></div><p></p></pre></div><div>触发器函数改为stable :&nbsp;</div><div>重新以上测试 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; alter function tg() stable;</font></div><div><font size="2"   >ALTER FUNCTION</font></div></div><div><div><font size="2"   >digoal=&gt; select * from test ;</font></div><div><font size="2"   >&nbsp;id&nbsp;</font></div><div><font size="2"   >----</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >(5 rows)</font></div></div><div><div><font size="2"   >digoal=&gt; insert into test values (1),(1),(1),(1);</font></div><div><font size="2"   >NOTICE: &nbsp;STATEMENT, BEFORE, INSERT, tg0, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg2, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg3, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg4, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg2, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg3, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg4, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg2, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg3, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg4, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg2, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg3, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, BEFORE, INSERT, tg4, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg5, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg6, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg7, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg5, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg6, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg7, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg5, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg6, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg7, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg5, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg6, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;ROW, AFTER, INSERT, tg7, cnt:5</font></div><div><font size="2"   >NOTICE: &nbsp;STATEMENT, AFTER, INSERT, tg1, cnt:5</font></div><div><font size="2"   >INSERT 0 4</font></div></div><p></p></pre></div><div>-- 触发器函数改为stable或immutable后, 看不到SQL语句中发生的变更.</div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><br></span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >13. 触发器会无限递归吗? 如何避免?</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >会, 例如 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; create table rec (id int);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=&gt; create or replace function tg() returns trigger as $$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >&nbsp; -- 这里将会造成无限递归.</font></div><div><font size="2"   >&nbsp; insert into rec values(2);</font></div><div><font size="2"   >&nbsp; raise notice '%, %, %, %, cnt:%', TG_LEVEL, TG_WHEN, TG_OP, TG_NAME, cnt;</font></div><div><font size="2"   >&nbsp; return new; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >end; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >$$ language plpgsql volatile;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><div><font size="2"   >digoal=&gt; create trigger tg0 before insert on rec for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div></div><div><div><font size="2"   >digoal=&gt; insert into rec values (1);</font></div><div><font size="2"   >ERROR: &nbsp;54001: stack depth limit exceeded</font></div><div><font size="2"   >HINT: &nbsp;Increase the configuration parameter "max_stack_depth" (currently 2048kB), after ensuring the platform's stack depth limit is adequate.</font></div><div><font size="2"   >CONTEXT: &nbsp;SQL statement "insert into rec values(2)"</font></div><div><font size="2"   >PL/pgSQL function tg() line 4 at SQL statement</font></div><div><font size="2"   >SQL statement "insert into rec values(2)"</font></div></div><div><font size="2"   >LOCATION: &nbsp;check_stack_depth, postgres.c:3076</font></div></pre></div><div>-- 不要在触发器函数中执行会再次触发触发器的SQL, 防止无限递归.</div><div><br></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >14. 触发条件与性能.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >这里指的是创建触发器时在WHEN中指定的触发条件. 在上一篇BLOG中已经提到了. 如下 :&nbsp;</span></div><div style="line-height: 22px;"   ><pre class="prettyprint"   ><p></p><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >表触发器 :&nbsp;</font></span></div><div><div><font size="2"   >(before | after) (INSERT | UPDATE | DELETE) (FOR EACH ROW) (WHEN NEW.? and,or OLD.? ... other boolean express ....)</font></div><div><font size="2"   >(before | after) (INSERT | UPDATE | DELETE | TRUNCATE) (FOR EACH STATEMENT) (WHEN BOOLEAN express except NEW or OLD or columns)</font></div></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >视图触发器 :&nbsp;</font></span></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><font size="2"   >(INSTEAD OF) (INSERT | UPDATE | DELETE) (FOR EACH ROW) (WHEN NEW.? and,or OLD.? ... other boolean express ....)</font></div><div style="line-height: 22px;"   ><font size="2"   >(before | after) (INSERT | UPDATE | DELETE) (FOR EACH STATEMENT) (WHEN BOOLEAN express except NEW or OLD or columns)</font></div></div><p></p></pre></div><div style="line-height: 22px;"   ><div style="line-height: 22px;"   >使用WHEN和在触发器中使用条件控制两者的性能有什么分别呢?</div></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >A trigger definition can also specify a Boolean WHEN condition, which will be tested to see whether the trigger should be fired. In row-level triggers the WHEN condition can examine the old and/or new values of columns of the row.&nbsp;</font></div><div><font size="2"   >(Statement-level triggers can also have WHEN conditions, although the feature is not so useful for them.)&nbsp;</font></div><div><font size="2"   >In a BEFORE trigger, the WHEN condition is evaluated just before the function is or would be executed, so using WHEN is not materially different from testing the same condition at the beginning of the trigger function.&nbsp;</font></div><div><font size="2"   >However, in an AFTER trigger, the WHEN condition is evaluated just after the row update occurs, and it determines whether an event is queued to fire the trigger at the end of statement.&nbsp;</font></div><div><font size="2"   >So when an AFTER trigger's WHEN condition does not return true, it is not necessary to queue an event nor to re-fetch the row at end of statement.&nbsp;</font></div><div><font size="2"   >This can result in significant speedups in statements that modify many rows, if the trigger only needs to be fired for a few of the rows.&nbsp;</font></div><div><font size="2"   >INSTEAD OF triggers do not support WHEN conditions.</font></div><div style="line-height: 22px;"   ></div><p></p></pre></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >能够带来性能提升的是当SQL语句带来多行的变更时, after for each row触发器中加判断条件或者使用WHEN这两种方法的性能存在极大差异.</span></div><div style="line-height: 22px;"   >因为after for each row触发器创建时的WHEN条件是在该行操作发生后进行的, 如果不为TRUE则不会把这个事件放入QUEUE中供后面的after for each row触发器使用. 并且在after for each statement触发器前, 也不需要获取已变更的行数据.</div><div style="line-height: 22px;"   >如果不放在WHEN中, 那么每一被变更的行都需要在<span style="line-height: 22px;"   >after for each statement触发器前, 获取已变更的行数据, 供after for each row触发器函数使用.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >例如 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; create table perf (id int);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >digoal=&gt; insert into perf select generate_series(1,10000);</font></div><div><font size="2"   >INSERT 0 10000</font></div></div><div><div><font size="2"   >digoal=&gt; create or replace function tg() returns trigger as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; raise notice '%, %, %, %, old:%', TG_LEVEL, TG_WHEN, TG_OP, TG_NAME, OLD;</font></div><div><font size="2"   >&nbsp; return old;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div></div><div><div><font size="2"   >digoal=&gt; create trigger tg0 after delete on perf for each row when (old.id=10) execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div></div><div><div><font size="2"   >digoal=&gt; create trigger tg1 before delete on perf for each row when (old.id=10) execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div></div><div><font size="2"   >-- 测试</font></div><div><div><font size="2"   >digoal=&gt; delete from perf where id&lt;15 returning *;</font></div><div><font size="2"   >NOTICE: &nbsp;00000: ROW, BEFORE, DELETE, tg1, old:(10)</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: ROW, AFTER, DELETE, tg0, old:(10)</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >&nbsp;id&nbsp;</font></div><div><font size="2"   >----</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >&nbsp; 2</font></div><div><font size="2"   >&nbsp; 3</font></div><div><font size="2"   >&nbsp; 4</font></div><div><font size="2"   >&nbsp; 5</font></div><div><font size="2"   >&nbsp; 6</font></div><div><font size="2"   >&nbsp; 7</font></div><div><font size="2"   >&nbsp; 8</font></div><div><font size="2"   >&nbsp; 9</font></div><div><font size="2"   >&nbsp;10</font></div><div><font size="2"   >&nbsp;11</font></div><div><font size="2"   >&nbsp;12</font></div><div><font size="2"   >&nbsp;13</font></div><div><font size="2"   >&nbsp;14</font></div><div><font size="2"   >(14 rows)</font></div><div><font size="2"   >DELETE 14</font></div></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >-- 从上面来看好像BEFORE和AFTER FOR EACH ROW使用WHEN时都有效率提高, 实际上after 的提高更明显.&nbsp;</font></span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >请看如下流程 :&nbsp;</font></span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >id=1</font></span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >before for each row when (false)</font></span></div><div style="line-height: 22px;"   ><font size="2"   ><span style="line-height: 22px;"   >after for each row when</span><span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >(false)</span></font></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >id=2</font></span></div><div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >before for each row when (false)</font></span></div><div style="line-height: 22px;"   ><font size="2"   ><span style="line-height: 22px;"   >after for each row when</span><span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >(false)</span></font></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >....</font></span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >id=10</font></span></div><div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >before for each row when (true)</font></span></div><div style="line-height: 22px;"   ><font size="2"   ><span style="line-height: 22px;"   >after for each row when</span><span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >(true)</span></font></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >...</font></span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >id=14</font></span></div><div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >before for each row when (false)</font></span></div><div style="line-height: 22px;"   ><font size="2"   ><span style="line-height: 22px;"   >after for each row when</span><span style="line-height: 22px;"   >&nbsp;</span><span style="line-height: 22px;"   >(false)</span></font></div></div></div></div><p></p></pre></div><div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><br></span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >修改触发器函数, 判断放到函数中 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><div><div><div><div><font size="2"   >digoal=&gt; create or replace function tg() returns trigger as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; if OLD.id=1 then&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; raise notice '%, %, %, %, old:%', TG_LEVEL, TG_WHEN, TG_OP, TG_NAME, OLD;</font></div><div><font size="2"   >&nbsp; &nbsp; return old;&nbsp;</font></div><div><font size="2"   >&nbsp; else&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; return null;&nbsp;</font></div><div><font size="2"   >&nbsp; end if;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div></div></div></div></div><div><div><font size="2"   >digoal=&gt; drop trigger tg0 on perf;</font></div><div><font size="2"   >DROP TRIGGER</font></div><div><font size="2"   >digoal=&gt; drop trigger tg1 on perf;</font></div><div><font size="2"   >DROP TRIGGER</font></div></div><div><div><font size="2"   >digoal=&gt; create trigger tg1 before delete on perf for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div><div><font size="2"   >digoal=&gt; create trigger tg0 after delete on perf for each row execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div></div><div><font size="2"   >-- 测试</font></div><div><div><font size="2"   >digoal=&gt; insert into perf select generate_series(1,10000);</font></div><div><font size="2"   >INSERT 0 10000</font></div><div><font size="2"   >digoal=&gt; delete from perf where id&lt;15 returning *;</font></div><div><font size="2"   >NOTICE: &nbsp;00000: ROW, BEFORE, DELETE, tg1, old:(1)</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >NOTICE: &nbsp;00000: ROW, AFTER, DELETE, tg0, old:(1)</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div><div><font size="2"   >&nbsp;id&nbsp;</font></div><div><font size="2"   >----</font></div><div><font size="2"   >&nbsp; 1</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >DELETE 1</font></div></div><div><font size="2"   >流程如下 :&nbsp;</font></div><div><div><font size="2"   >id=1</font></div><div><font size="2"   >before for each row</font></div><div><font size="2"   >行操作, 并放入event queue</font></div><div><font size="2"   >id=2</font></div><div><font size="2"   >before for each row</font></div><div><font size="2"   >无行操作</font></div><div><font size="2"   >....</font></div><div><font size="2"   >id=14</font></div><div><font size="2"   >before for each row</font></div><div><font size="2"   >无行操作</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >id=1</font></div><div><font size="2"   >after for each row</font></div></div><div><font size="2"   >如果把tg1删掉的话, 情况就发生了变化 :&nbsp;</font></div><div><div><font size="2"   >id=1</font></div><div><font size="2"   >before for each row</font></div><div><font size="2"   >行操作, 并放入event queue</font></div><div><font size="2"   >id=2</font></div><div><font size="2"   >before for each row</font></div><div><font size="2"   >行操作, 并放入event queue</font></div><div><font size="2"   >....</font></div><div><font size="2"   >id=14</font></div><div><font size="2"   >before for each row</font></div><div><font size="2"   >行操作, 并放入event queue</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >id=1</font></div><div><font size="2"   >after for each row</font></div><div><font size="2"   >id=2</font></div><div><font size="2"   >after for each row</font></div><div><font size="2"   >....</font></div><div><font size="2"   >id=14</font></div><div><font size="2"   >after for each row</font></div></div><p></p></pre></div></div><div>因此when 在多行处理中对 仅需要少量行触发after for each row触发器函数的场景 性能提升会非常明显.</div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >15. 加入触发器后的事务特性.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >加入触发器后, &nbsp;如果触发器函数抛出异常, 那么整个事务回滚.</span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >例如 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; create table err (id int);</font></div><div><font size="2"   >CREATE TABLE</font></div></div><div><div><font size="2"   >digoal=&gt; create or replace function tg() returns trigger as $$</font></div><div><font size="2"   >declare</font></div><div><font size="2"   >begin</font></div><div><font size="2"   >&nbsp; raise exception '';</font></div><div><font size="2"   >&nbsp; return new;</font></div><div><font size="2"   >end;</font></div><div><font size="2"   >$$ language plpgsql;</font></div><div><font size="2"   >CREATE FUNCTION</font></div></div><div><div><font size="2"   >digoal=&gt; create trigger tg0 after insert on err for each statement execute procedure tg();</font></div><div><font size="2"   >CREATE TRIGGER</font></div></div><div><div><font size="2"   >digoal=&gt; insert into err values (1);</font></div><div><font size="2"   >ERROR: &nbsp;P0001:&nbsp;</font></div><div><font size="2"   >LOCATION: &nbsp;exec_stmt_raise, pl_exec.c:2840</font></div></div><div><div><font size="2"   >digoal=&gt; select * from err;</font></div><div><font size="2"   >&nbsp;id&nbsp;</font></div><div><font size="2"   >----</font></div><div><font size="2"   >(0 rows)</font></div></div><p></p></pre></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><br></span></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >16. 触发器函数的返回值是如何影响returning的结果的?</span></div></div><div style="line-height: 22px;"   >上一篇blog已经详细讲解. 这里略.</div><div style="line-height: 22px;"   ><br></div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   >【参考】</span></div><div style="line-height: 22px;"   >1.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/trigger-definition.html"   >http://www.postgresql.org/docs/9.2/static/trigger-definition.html</a></div><div style="line-height: 22px;"   >2.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/trigger-datachanges.html"   >http://www.postgresql.org/docs/9.2/static/trigger-datachanges.html</a></div><div style="line-height: 22px;"   >3.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/spi-visibility.html"   >http://www.postgresql.org/docs/9.2/static/spi-visibility.html</a></div><div style="line-height: 22px;"   >4.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/trigger-example.html"   >http://www.postgresql.org/docs/9.2/static/trigger-example.html</a></div><div style="line-height: 22px;"   >5.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/plpgsql-trigger.html"   >http://www.postgresql.org/docs/9.2/static/plpgsql-trigger.html</a><br style="line-height: 22px;"   >6.&nbsp;<wbr style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/sql-createtrigger.html"   >http://www.postgresql.org/docs/9.2/static/sql-createtrigger.html</a></div><div style="line-height: 22px;"   >7.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/trigger-interface.html"   >http://www.postgresql.org/docs/9.2/static/trigger-interface.html</a></div><div style="line-height: 22px;"   >8.&nbsp;<a style="line-height: 22px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.2/static/sql-set-constraints.html"   >http://www.postgresql.org/docs/9.2/static/sql-set-constraints.html</a></div><div style="line-height: 22px;"   >9.&nbsp;src/backend/commands/trigger.c</div><div style="line-height: 22px;"   >10.&nbsp;src/include/commands/trigger.h</div><div style="line-height: 22px;"   >11.&nbsp;src/include/utils/reltrigger.h</div><span style="line-height: 22px;"   >12. 触发器的应用 :&nbsp;</span><div style="line-height: 22px;"   ><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020128772037884/"   >http://blog.163.com/digoal@126/blog/static/16387704020128772037884/</a></div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020120133019990/"   >http://blog.163.com/digoal@126/blog/static/16387704020120133019990/</a></div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201251931517556/"   >http://blog.163.com/digoal@126/blog/static/163877040201251931517556/</a></div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020130931040444/"   >http://blog.163.com/digoal@126/blog/static/16387704020130931040444/</a></div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201301483549300/"   >http://blog.163.com/digoal@126/blog/static/163877040201301483549300/</a></div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012325111528424/"   >http://blog.163.com/digoal@126/blog/static/1638770402012325111528424/</a></div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201211193542316/"   >http://blog.163.com/digoal@126/blog/static/163877040201211193542316/</a></div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012731203716/"   >http://blog.163.com/digoal@126/blog/static/1638770402012731203716/</a></div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012731944439/"   >http://blog.163.com/digoal@126/blog/static/1638770402012731944439/</a></div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020128142829610/"   >http://blog.163.com/digoal@126/blog/static/16387704020128142829610/</a></div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020129851138327/"   >http://blog.163.com/digoal@126/blog/static/16387704020129851138327/</a></div><div style="line-height: 22px;"   ><a style="line-height: 22px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201119111234570/"   >http://blog.163.com/digoal@126/blog/static/163877040201119111234570/</a></div><div><br></div></div><wbr></div>
	</div>
</div>
</body>
</html>