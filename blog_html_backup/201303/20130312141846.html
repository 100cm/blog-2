<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL combine SQLs update one tuple more than once Tuning To one tuple one update</h2>
	<h5 id="">2013-03-12 14:18:46&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402013212243854/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;">昨天一位兄弟的数据更新需求如下 :&nbsp;<div>-- 测试表<br><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; create table test (id int primary key, c1 int, c2 int, c3 int, d1 int, d2 int, d3 int);</font></div><div><font size="2"   >CREATE TABLE</font></div><p></p></pre></div><div>-- 测试数据</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; insert into test values (1,0,0,0,1,1,1);</font></div><div><font size="2"   >INSERT 0 1</font></div><div><div><font size="2"   >digoal=&gt; insert into test values (2,1,1,1,1,1,1);</font></div><div><font size="2"   >INSERT 0 1</font></div></div><p></p></pre></div><div>-- 注意ctid的信息, 后面比对有用</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select ctid,* from test;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | c1 | c2 | c3 | d1 | d2 | d3&nbsp;</font></div><div><font size="2"   >-------+----+----+----+----+----+----+----</font></div><div><font size="2"   >&nbsp;(0,1) | &nbsp;1 | &nbsp;0 | &nbsp;0 | &nbsp;0 | &nbsp;1 | &nbsp;1 | &nbsp;1</font></div><div><font size="2"   >&nbsp;(0,2) | &nbsp;2 | &nbsp;1 | &nbsp;1 | &nbsp;1 | &nbsp;1 | &nbsp;1 | &nbsp;1</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>-- 更新数据的需求如下 :&nbsp;</div><div>把所有d1=1的更新为c1的值.</div><div><span style="line-height: 22px;"   >把所有d2=1的更新为c2的值.</span></div><div><span style="line-height: 22px;"   >把所有d3=1的更新为c3的值.</span></div><div><span style="line-height: 22px;"   >正常情况下的SQL如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><span style="line-height: 22px;"   ><font size="2"   >update test set d1=c1 where d1=1;</font></span></div><div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >update test set d2=c2 where d2=1;</font></span></div></div><div><div style="line-height: 22px;"   ><span style="line-height: 22px;"   ><font size="2"   >update test set d3=c3 where d3=1;</font></span></div></div><p></p></pre></div><div><span style="line-height: 22px;"   >以上SQL需要更新6条tuple.</span></div><div><span style="line-height: 22px;"   >如下 :&nbsp;</span></div><div><span style="line-height: 22px;"   ><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; update test set d1=c1 where d1=1;</font></div><div><font size="2"   >UPDATE 2</font></div><div><font size="2"   >digoal=&gt; update test set d2=c2 where d2=1;</font></div><div><font size="2"   >UPDATE 2</font></div><div><font size="2"   >digoal=&gt; update test set d3=c3 where d3=1;</font></div><div><font size="2"   >UPDATE 2</font></div><p></p></pre></div><div>-- 更新完后产生了6个垃圾版本.</div><div>-- 因为每执行1条以上任意SQL都会产生2个垃圾版本. 总共将产生6个垃圾版本.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; select ctid,* from test;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | c1 | c2 | c3 | d1 | d2 | d3&nbsp;</font></div><div><font size="2"   >-------+----+----+----+----+----+----+----</font></div><div><font size="2"   >&nbsp;(0,7) | &nbsp;1 | &nbsp;0 | &nbsp;0 | &nbsp;0 | &nbsp;0 | &nbsp;0 | &nbsp;0</font></div><div><font size="2"   >&nbsp;(0,8) | &nbsp;2 | &nbsp;1 | &nbsp;1 | &nbsp;1 | &nbsp;1 | &nbsp;1 | &nbsp;1</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>-- vacuum 信息如下, 回收了6个垃圾版本 :&nbsp;</div></span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >digoal=&gt; vacuum verbose analyze test;</font></div><div><font size="2"   >INFO: &nbsp;00000: vacuuming "digoal.test"</font></div><div><font size="2"   >LOCATION: &nbsp;lazy_scan_heap, vacuumlazy.c:420</font></div><div><font size="2"   >INFO: &nbsp;00000: index "test_pkey" now contains 2 row versions in 2 pages</font></div><div><font size="2"   >DETAIL: &nbsp;0 index row versions were removed.</font></div><div><font size="2"   >0 index pages have been deleted, 0 are currently reusable.</font></div><div><font size="2"   >CPU 0.00s/0.00u sec elapsed 0.00 sec.</font></div><div><font size="2"   >LOCATION: &nbsp;lazy_cleanup_index, vacuumlazy.c:1309</font></div><div><font size="2"   >INFO: &nbsp;00000: "test": found 6 removable, 2 nonremovable row versions in 1 out of 1 pages</font></div><div><font size="2"   >DETAIL: &nbsp;0 dead row versions cannot be removed yet.</font></div><div><font size="2"   >There were 4 unused item pointers.</font></div><div><font size="2"   >0 pages are entirely empty.</font></div><div><font size="2"   >CPU 0.00s/0.00u sec elapsed 0.00 sec.</font></div><div><font size="2"   >LOCATION: &nbsp;lazy_scan_heap, vacuumlazy.c:1040</font></div><div><font size="2"   >INFO: &nbsp;00000: analyzing "digoal.test"</font></div><div><font size="2"   >LOCATION: &nbsp;do_analyze_rel, analyze.c:335</font></div><div><font size="2"   >INFO: &nbsp;00000: "test": scanned 1 of 1 pages, containing 2 live rows and 0 dead rows; 2 rows in sample, 2 estimated total rows</font></div><div><font size="2"   >LOCATION: &nbsp;acquire_sample_rows, analyze.c:1299</font></div><div><font size="2"   >VACUUM</font></div><p></p></pre></div><div>【优化】</div><div>对于这种需求减少垃圾版本是很有必要的, 可以将3条SQL合并成1条.</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >digoal=&gt; drop table test;</font></div><div><font size="2"   >DROP TABLE</font></div></div><div style="line-height: 22px;"   ><font size="2"   >digoal=&gt; create table test (id int primary key, c1 int, c2 int, c3 int, d1 int, d2 int, d3 int);</font></div><div style="line-height: 22px;"   ><font size="2"   >CREATE TABLE</font></div><div style="line-height: 22px;"   ><font size="2"   >digoal=&gt; insert into test values (1,0,0,0,1,1,1);</font></div><div style="line-height: 22px;"   ><font size="2"   >INSERT 0 1</font></div><div><div style="line-height: 22px;"   ><font size="2"   >digoal=&gt; insert into test values (2,1,1,1,1,1,1);</font></div><div style="line-height: 22px;"   ><font size="2"   >INSERT 0 1</font></div><div><div><font size="2"   >digoal=&gt; update test set d1=(case d1 when 1 then c1 else d1 end), d2=(case d2 when 1 then c2 else d2 end), d3=(case d3 when 1 then c3 else d3 end) where d1=1 or d2=1 or d3=1;</font></div><div><font size="2"   >UPDATE 2</font></div><div><font size="2"   >digoal=&gt; select ctid,* from test;</font></div><div><font size="2"   >&nbsp;ctid &nbsp;| id | c1 | c2 | c3 | d1 | d2 | d3&nbsp;</font></div><div><font size="2"   >-------+----+----+----+----+----+----+----</font></div><div><font size="2"   >&nbsp;(0,3) | &nbsp;1 | &nbsp;0 | &nbsp;0 | &nbsp;0 | &nbsp;0 | &nbsp;0 | &nbsp;0</font></div><div><font size="2"   >&nbsp;(0,4) | &nbsp;2 | &nbsp;1 | &nbsp;1 | &nbsp;1 | &nbsp;1 | &nbsp;1 | &nbsp;1</font></div><div><font size="2"   >(2 rows)</font></div></div></div><p></p></pre></div><div>-- 使用这种方法只产生了2个垃圾版本, 一条TUPLE不会被多次更新.</div><wbr></div><div>-- 对PostgreSQL的mvcc方法有了解的朋友一定知道怎么来做并发控制的, 一个很重要的点就是行的版本.(xmin, xmax)</div></div><div>-- 减少行变更处理带来以上好处, 还可以减少索引的更新几率(HOT的情况下索引不需要更新).</div></div>
	</div>
</div>
</body>
</html>