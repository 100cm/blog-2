<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">ganglia metric extended by mod_python</h2>
	<h5 id="">2014-09-23 16:18:34&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402014823102256805/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>ganglia 对监控数据(metric)的采样是模块化方式进行的, 例如 :&nbsp;</div><div><span style="line-height: 28px;"   >自带的监控项其实是放在一些C写的动态链接库来加载并通过gmond.conf配置来调度的.</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-221 ganglia]# cd /opt/ganglia-core-3.6.0/</font></div><div><font size="2"   >[root@db-172-16-3-221 ganglia-core-3.6.0]# ll</font></div><div><font size="2"   >total 24</font></div><div><font size="2"   >drwxr-xr-x 2 root root 4096 Sep &nbsp;9 11:03 bin</font></div><div><font size="2"   >drwxr-xr-x 3 root root 4096 Sep 15 09:31 etc</font></div><div><font size="2"   >drwxr-xr-x 2 root root 4096 Sep &nbsp;9 11:03 include</font></div><div><font size="2"   >drwxr-xr-x 3 root root 4096 Sep &nbsp;9 11:03 lib64</font></div><div><font size="2"   >drwxr-xr-x 2 root root 4096 Sep &nbsp;9 11:03 sbin</font></div><div><font size="2"   >drwxr-xr-x 3 root root 4096 Sep &nbsp;9 11:03 share</font></div><div><font size="2"   >[root@db-172-16-3-221 ganglia-core-3.6.0]# cd lib64/</font></div><div><font size="2"   >[root@db-172-16-3-221 lib64]# ll</font></div><div><font size="2"   >total 660</font></div><div><font size="2"   >drwxr-xr-x 2 root root &nbsp; 4096 Sep &nbsp;9 11:03 ganglia</font></div><div><font size="2"   >lrwxrwxrwx 1 root root &nbsp; &nbsp; 25 Sep &nbsp;9 11:03 libganglia-3.6.0.so.0 -&gt; libganglia-3.6.0.so.0.0.0</font></div><div><font size="2"   >-rwxr-xr-x 1 root root 257554 Sep &nbsp;9 11:03 libganglia-3.6.0.so.0.0.0</font></div><div><font size="2"   >-rw-r--r-- 1 root root 408276 Sep &nbsp;9 11:03 libganglia.a</font></div><div><font size="2"   >-rwxr-xr-x 1 root root &nbsp; 1270 Sep &nbsp;9 11:03 libganglia.la</font></div><div><font size="2"   >lrwxrwxrwx 1 root root &nbsp; &nbsp; 25 Sep &nbsp;9 11:03 libganglia.so -&gt; libganglia-3.6.0.so.0.0.0</font></div><div><font size="2"   >[root@db-172-16-3-221 lib64]# cd ganglia/</font></div><div><font size="2"   >[root@db-172-16-3-221 ganglia]# ll</font></div><div><font size="2"   >total 700</font></div><div><font size="2"   >-rwxr-xr-x 1 root root 86896 Sep &nbsp;9 11:03 modcpu.so</font></div><div><font size="2"   >-rwxr-xr-x 1 root root 84118 Sep &nbsp;9 11:03 moddisk.so</font></div><div><font size="2"   >-rwxr-xr-x 1 root root 17896 Sep &nbsp;9 11:03 modgstatus.so</font></div><div><font size="2"   >-rwxr-xr-x 1 root root 84078 Sep &nbsp;9 11:03 modload.so</font></div><div><font size="2"   >-rwxr-xr-x 1 root root 85832 Sep &nbsp;9 11:03 modmem.so</font></div><div><font size="2"   >-rwxr-xr-x 1 root root 31655 Sep &nbsp;9 11:03 modmulticpu.so</font></div><div><font size="2"   >-rwxr-xr-x 1 root root 84480 Sep &nbsp;9 11:03 modnet.so</font></div><div><font size="2"   >-rwxr-xr-x 1 root root 83862 Sep &nbsp;9 11:03 modproc.so</font></div><div><font size="2"   >-rwxr-xr-x 1 root root 53954 Sep &nbsp;9 11:03 modpython.so</font></div><div><font size="2"   >-rwxr-xr-x 1 root root 85136 Sep &nbsp;9 11:03 modsys.so</font></div><p></p></pre></div><div>在gmond中加载这些模块, 才可以使用这些模块来采样监控数据(metric).</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-221 ganglia]# cd /opt/ganglia-core-3.6.0/etc/</font></div><div><font size="2"   >[root@db-172-16-3-221 etc]# ll</font></div><div><font size="2"   >total 24</font></div><div><font size="2"   >drwxr-xr-x 2 root root 4096 Sep &nbsp;9 11:26 conf.d</font></div><div><font size="2"   >-rw-r--r-- 1 root root 7973 Sep 10 17:37 gmetad.conf</font></div><div><font size="2"   >-rw-r--r-- 1 root root 9157 Sep 15 09:31 gmond.conf</font></div><div><font size="2"   >[root@db-172-16-3-221 etc]# less gmond.conf</font></div></div><div><div><font size="2"   >/* Each metrics module that is referenced by gmond must be specified and</font></div><div><font size="2"   >&nbsp; &nbsp;loaded. If the module has been statically linked with gmond, it does</font></div><div><font size="2"   >&nbsp; &nbsp;not require a load path. However all dynamically loadable modules must</font></div><div><font size="2"   >&nbsp; &nbsp;include a load path. */</font></div><div><font size="2"   >modules {</font></div><div><font size="2"   >&nbsp; module {</font></div><div><font size="2"   >&nbsp; &nbsp; name = "core_metrics"</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; module {</font></div><div><font size="2"   >&nbsp; &nbsp; name = "cpu_module"</font></div><div><font size="2"   >&nbsp; &nbsp; path = "modcpu.so"</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; module {</font></div><div><font size="2"   >&nbsp; &nbsp; name = "disk_module"</font></div><div><font size="2"   >&nbsp; &nbsp; path = "moddisk.so"</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; module {</font></div><div><font size="2"   >&nbsp; &nbsp; name = "load_module"</font></div><div><font size="2"   >&nbsp; &nbsp; path = "modload.so"</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; module {</font></div><div><font size="2"   >&nbsp; &nbsp; name = "mem_module"</font></div><div><font size="2"   >&nbsp; &nbsp; path = "modmem.so"</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; module {</font></div><div><font size="2"   >&nbsp; &nbsp; name = "net_module"</font></div><div><font size="2"   >&nbsp; &nbsp; path = "modnet.so"</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; module {</font></div><div><font size="2"   >&nbsp; &nbsp; name = "proc_module"</font></div><div><font size="2"   >&nbsp; &nbsp; path = "modproc.so"</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >&nbsp; module {</font></div><div><font size="2"   >&nbsp; &nbsp; name = "sys_module"</font></div><div><font size="2"   >&nbsp; &nbsp; path = "modsys.so"</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div>以上模块都是C写的, 为了提高开发效率, ganglia metric 扩展还支持php, python, perl等语言的接口.</div><div>在编译ganglia时, 需要指定 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >[root@db-172-16-3-221 etc]# cd /opt/soft_bak/ganglia-3.6.0</font></div><div><font size="2"   >[root@db-172-16-3-221 ganglia-3.6.0]# ./configure --help</font></div></div><div><div><font size="2"   >&nbsp; --enable-perl &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; include mod_perl and support for metric modules written in perl</font></div><div><font size="2"   >&nbsp; --enable-php &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;include mod_php and support for metric modules written in php</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   >&nbsp; --with-python=PATH &nbsp; &nbsp; &nbsp;Specify prefix for python or full path to interpreter</font></div><div><font size="2"   >&nbsp; --with-perl=PATH &nbsp; &nbsp; &nbsp; &nbsp;Specify prefix for perl or full path to interpreter</font></div><div><font size="2"   >&nbsp; --with-php=PATH &nbsp; &nbsp; &nbsp; &nbsp; Specify prefix for php or full path to php-config</font></div></div><p></p></pre></div><div>默认是支持python扩展的, 如下, 我们可以看到modpython.so动态链接库.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-221 ~]# cd /opt/ganglia-core-3.6.0/</font></div><div><font size="2"   >[root@db-172-16-3-221 ganglia-core-3.6.0]# cd lib64/</font></div><div><font size="2"   >[root@db-172-16-3-221 lib64]# cd ganglia/</font></div><div><div><font size="2"   >[root@db-172-16-3-221 ganglia]# ll</font></div><div><font size="2"   >total 700</font></div><div><font size="2"   >...</font></div><div><font size="2"   >-rwxr-xr-x 1 root root 53954 Sep &nbsp;9 11:03 modpython.so</font></div></div><div><font size="2"   >...</font></div><p></p></pre></div><div>注意modpython.so, 显然这个模块也是C写的, 这个模块并不是直接用来采样监控数据(metric), 而是用来解释python脚本的, 并且被解释和执行的python脚本要按照一定的规则来定义.</div><div>例子可以参考github里面ganglia的gmond_python_modules项目.</div><div><a target="_blank" rel="nofollow" href="https://github.com/ganglia/gmond_python_modules"   >https://github.com/ganglia/gmond_python_modules</a></div><div><br></div><div>下面简单的讲一下如何使用python来扩展metric采样.</div><div>一. 配置gmond以支持python metric 模块.</div><div>首先要写一个配置文件, 配置modpython.so以及存放.py脚本的路径, 存放.py脚本对应的.pyconf配置文件的路径.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-221 etc]# cd /opt/ganglia-core-3.6.0/etc/conf.d/</font></div><div><font size="2"   ><span style="line-height: 28px;"   >[root@db-172-16-3-221 etc]</span># vi&nbsp;modpython.conf</font></div><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp; params - path to the directory where mod_python</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;should look for python metric modules</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; the "pyconf" files in the include directory below</font></div><div><font size="2"   >&nbsp; will be scanned for configurations for those modules</font></div><div><font size="2"   >*/</font></div><div><font size="2"   >modules {</font></div><div><font size="2"   >&nbsp; module {</font></div><div><font size="2"   >&nbsp; &nbsp; name = "python_module"</font></div><div><font size="2"   >&nbsp; &nbsp; path = "modpython.so"</font></div><div><font size="2"   >&nbsp; &nbsp; params = "/opt/ganglia-core-3.6.0/lib64/ganglia/python_modules" &nbsp; # 存放.py脚本的目录&nbsp;</font></div><div><font size="2"   >&nbsp; }</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >include ("/opt/ganglia-core-3.6.0/etc/conf.d/*.pyconf") &nbsp; &nbsp; # 存放.pyconf配置文件的目录.</font></div></div><p></p></pre></div><div>每一个python metric 模块, 都需要2个文件, 一个.py脚本文件, 一个.pyconf配置文件.&nbsp;</div><div>例如 :&nbsp;</div><div>postgres.py脚本以及对应的postgres.pyconf配置文件.&nbsp;</div><div><br></div><div>将<span style="line-height: 28px;"   >modpython.conf</span><span style="line-height: 28px;"   >这个配置文件加入gmond.conf</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >[root@db-172-16-3-221 etc]# vi /opt/ganglia-core-3.6.0/etc/gmond.conf</font></div><div><font size="2"   >include ("/opt/ganglia-core-3.6.0/etc/conf.d/*.conf")</font></div><p></p></pre></div><div><br></div><div>二. 编写python metric 模块</div><div>1. 编写.py脚本</div><div>.py脚本需要按照ganglia的协定编写, 必须包含3类函数 :&nbsp;</div><div>metric_init(params), metric_handler(name), and metric_cleanup().</div><div><br></div><div>metric_init(params) 函数, 有且仅有一个参数params, 这个函数在模块初始化时调用, 主要目的是构造metric的定义字典. (当然, 你也可以在初始化过程执行你想要的动作)</div><div>params参数是字典类型, 字典的内容取自.py脚本对应的.pyconf配置文件中module section定义的param/value值. 例如 :&nbsp;</div><div>gmond_python_modules / postgresql / conf.d / postgres.pyconf</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >modules {</font></div><div><font size="2"   >&nbsp; &nbsp;module {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "postgres"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;language = "python"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;param host {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;value = "hostname_goes_here" &nbsp;# 这里需要填写真实的主机名或IP, 例如127.0.0.1</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;param port {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;value = "port_goes_here" &nbsp; &nbsp;# 这里需要填写真实的postgresql监听端口, 如5432</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;param dbname {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;value = "database_goes_here" &nbsp; # 这里需要填写真实的数据库名, 如postgres</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;param username {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;value = "username_goes_here" &nbsp; &nbsp;# 这里需要填写真实的用户名</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;param password {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;value = "password_goes_here" &nbsp; # 这里需要填写真实的密码</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div>以上.pyconf配置文件中定义的param有host, port, dbname, username, password.&nbsp;</div><div>那么在<span style="line-height: 28px;"   >metric_init(params)函数中可以这么来用</span><span style="line-height: 28px;"   >:</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># Metric descriptors are initialized here&nbsp;</font></div><div><font size="2"   >def metric_init(params):</font></div><div><font size="2"   >&nbsp; &nbsp; HOST = str(params.get('host'))</font></div><div><font size="2"   >&nbsp; &nbsp; PORT = str(params.get('port'))</font></div><div><font size="2"   >&nbsp; &nbsp; DB = str(params.get('dbname'))</font></div><div><font size="2"   >&nbsp; &nbsp; USER = str(params.get('username'))</font></div><div><font size="2"   >&nbsp; &nbsp; PASSWORD = str(params.get('password'))</font></div><div><font size="2"   >&nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; global pgdsn</font></div><div><font size="2"   >&nbsp; &nbsp; pgdsn = "dbname=" + DB + " host=" + HOST + " user=" + USER + " port=" + PORT + " password=" + PASSWORD</font></div><p></p></pre></div><div>鉴于以上情形, postgresql python metric module for ganglia 需要访问数据库, 所以最好在数据库本地服务器安装gmond , 并且新建一个超级用户, 配置该超级用户只能从127.0.0.1访问, 其他不允许访问.</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >=&gt; create role digoal superuser login encrypted password 'digoal';</font></div><div><font size="2"   >vi $PGDATA/pg_hba.conf</font></div><div><font size="2"   >host all digoal 127.0.0.1/32 trust &nbsp; &nbsp; # 允许本地无密码访问</font></div><div><font size="2"   >host all digoal 0.0.0.0/0 reject &nbsp; &nbsp;# &nbsp;不允许从任何来源访问</font></div><p></p></pre></div><div><br></div><div>metric 定义字典是什么意思呢? 来看看例子 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; descriptors = [</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_idle_sessions','units':'Sessions','slope':'both','description':'PG Idle Sessions'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_active_sessions','units':'Sessions','slope':'both','description':'PG Active Sessions'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_idle_in_transaction_sessions','units':'Sessions','slope':'both','description':'PG Idle In Transaction Sessions'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_waiting_sessions','units':'Sessions','slope':'both','description':'PG Waiting Sessions Blocked'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_longest_xact','units':'Seconds','slope':'both','description':'PG Longest Transaction in Seconds'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_longest_query','units':'Seconds','slope':'both','description':'PG Longest Query in Seconds'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_locks_accessexclusive','units':'Locks','slope':'both','description':'PG AccessExclusive Locks read write blocking'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_locks_otherexclusive','units':'Locks','slope':'both','description':'PG Exclusive Locks write blocking'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_locks_shared','units':'Locks','slope':'both','description':'PG Shared Locks NON blocking'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_bgwriter_checkpoints_timed','units':'checkpoints','slope':'positive','description':'PG scheduled checkpoints'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_bgwriter_checkpoints_req','units':'checkpoints','slope':'positive','description':'PG unscheduled checkpoints'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_bgwriter_checkpoint_write_time','units':'ms','slope':'positive','description':'PG time to write checkpoints to disk'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_bgwriter_checkpoint_sync_time','units':'checkpoints','slope':'positive','description':'PG time to sync checkpoints to disk'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_bgwriter_buffers_checkpoint','units':'buffers','slope':'positive','description':'PG number of buffers written during checkpoint'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_bgwriter_buffers_clean','units':'buffers','slope':'positive','description':'PG number of buffers written by the background writer'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_bgwriter_buffers_backend','units':'buffers','slope':'positive','description':'PG number of buffers written directly by a backend'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_bgwriter_buffers_alloc','units':'buffers','slope':'positive','description':'PG number of buffers allocated'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_transactions','units':'xacts','slope':'positive','description':'PG Transactions'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_inserts','units':'tuples','slope':'positive','description':'PG Inserts'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_updates','units':'tuples','slope':'positive','description':'PG Updates'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_deletes','units':'tuples','slope':'positive','description':'PG Deletes'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_reads','units':'tuples','slope':'positive','description':'PG Reads'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_blks_diskread','units':'blocks','slope':'positive','description':'PG Blocks Read from Disk'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_blks_memread','units':'blocks','slope':'positive','description':'PG Blocks Read from Memory'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_tup_seqscan','units':'tuples','slope':'positive','description':'PG Tuples sequentially scanned'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_tup_idxfetch','units':'tuples','slope':'positive','description':'PG Tuples fetched from indexes'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_hours_since_last_vacuum','units':'hours','slope':'both','description':'PG hours since last vacuum'},</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'name':'Pypg_hours_since_last_analyze','units':'hours','slope':'both','description':'PG hours since last analyze'}]</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; for d in descriptors:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; # Add default values to dictionary, 本例所有metric对应的call_back函数都是同一个, 值类型都是uint</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; d.update({'call_back': metric_handler, 'time_max': 90, 'value_type': 'uint', 'format': '%d', 'groups': 'Postgres'})</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; return descriptors</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >metric_init(params)函数返回的</span>metric定义字典结构, 包含了以下基本信息(基本信息必须包含)</div><div>(还可以包含其他内容, 如SPOOF要用到的SPOOF_HOST, SPOOF_NAME等, 还有GROUP等(group用于gweb对图形分组)) :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >'name': '&lt;name&gt;', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#Name used in configuration</font></div><div><font size="2"   >'call_back': &lt;handler_function&gt;, &nbsp; &nbsp;        &nbsp;#Call back function queried by gmond</font></div><div><font size="2"   >'time_max': int(&lt;time_max&gt;), &nbsp; &nbsp; &nbsp; &nbsp;        &nbsp;#Maximum metric value gathering interval</font></div><div><font size="2"   >'value_type': '&lt;data_type&gt;', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     #Data type (string, uint, float, double)</font></div><div><font size="2"   >'units': '&lt;label&gt;', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  #Units label</font></div><div><font size="2"   >'slope': '&lt;slope_type&gt;', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp;#Slope ('zero' constant values, 'both' numeric values)</font></div><div><font size="2"   >'format': '&lt;format&gt;', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#String formatting ('%s', '%u','%f')</font></div><div><font size="2"   >'description': '&lt;description&gt;'} &nbsp; &nbsp; &nbsp; &nbsp;    &nbsp; #Free form metric description</font></div><p></p></pre></div><div>以上即每个metric都必须包含的基本信息,&nbsp;</div><div>在对metric进行采样时, 会调用<span style="line-height: 28px;"   >call_back指定的函数, call_back函数的参数是metric字典里的 name字段的值.</span></div><div><span style="line-height: 28px;"   ><br></span></div><div>接下来要说的是<span style="line-height: 28px;"   >metric_handler(name)函数,&nbsp;</span><span style="line-height: 28px;"   >在对metric进行采样时, 会调用</span><span style="line-height: 28px;"   >call_back指定的函数, call_back函数的参数是metric字典里的 name字段的值. &nbsp;</span></div><div><span style="line-height: 28px;"   >例如 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ><span style="line-height: 28px;"   >metric_handler(</span>Pypg_hours_since_last_analyze<span style="line-height: 28px;"   >)</span></font></div><div></div><p></p></pre></div><div><span style="line-height: 28px;"   >我们上面的例子中, 每个metric用的都是同一个函数</span><span style="line-height: 28px;"   >metric_handler</span><span style="line-height: 28px;"   >&nbsp;:&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; for d in descriptors:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; # Add default values to dictionary</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; d.update({'call_back': metric_handler, 'time_max': 90, 'value_type': 'uint', 'format': '%d', 'groups': 'Postgres'})</font></div><p></p></pre></div><div><span style="line-height: 28px;"   >这个函数的定义如下 :&nbsp;</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># Metric handler uses dictionary pg_metrics keys to return values from queries based on metric name</font></div><div><font size="2"   >def metric_handler(name):</font></div><div><font size="2"   >&nbsp; &nbsp; pg_metrics = pg_metrics_queries()</font></div><div><font size="2"   >&nbsp; &nbsp; return int(pg_metrics[name])</font></div><p></p></pre></div><div>每个metric被采样时都会触发这个函数, 也就是说都会调用<span style="line-height: 28px;"   >pg_metrics_queries(),&nbsp;</span><span style="line-height: 28px;"   >所以重复工作比较多.&nbsp;</span></div><div><span style="line-height: 28px;"   >这个module的作者显然是偷懒了, 应该为每个metric写一个call back函数比较好(或者这个pg_metrics_queries函数加个参数, 判断一下当前是那个metric触发的), 当然, 如果这些查询的效率很高的话, 重复就重复吧.(图省事)</span></div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >import psycopg2</font></div><div><font size="2"   >import psycopg2.extras</font></div><div><font size="2"   >import syslog</font></div><div><font size="2"   >import functools</font></div><div><font size="2"   >import time</font></div></div><div><font size="2"   ><br></font></div><div><div><font size="2"   ># Cache for postgres query values, this prevents opening db connections for each metric_handler callback</font></div><div><font size="2"   >class Cache(object):</font></div><div><font size="2"   >&nbsp; &nbsp; def __init__(self, expiry):</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; self.expiry = expiry</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; self.curr_time = 0</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; self.last_time = 0</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; self.last_value = None</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; def __call__(self, func):</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; @functools.wraps(func)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; def deco(*args, **kwds):</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.curr_time = time.time()</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if self.curr_time - self.last_time &gt; self.expiry:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.last_value = func(*args, **kwds)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.last_time = self.curr_time</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return self.last_value</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return deco</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ># Queries update the pg_metrics dict with their values based on cache interval</font></div><div><font size="2"   >@Cache(60)</font></div><div><font size="2"   >def pg_metrics_queries():</font></div><div><font size="2"   >&nbsp; &nbsp; pg_metrics = {}</font></div><div><font size="2"   >&nbsp; &nbsp; db_conn = psycopg2.connect(pgdsn)</font></div><div><font size="2"   >&nbsp; &nbsp; db_curs = db_conn.cursor()</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; # single session state query avoids multiple scans of pg_stat_activity</font></div><div><font size="2"   >&nbsp; &nbsp; # state is a different column name in postgres 9.2, previous versions will have to update this query accordingly</font></div><div><font size="2"   >&nbsp; &nbsp; db_curs.execute(</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'select state, waiting, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; extract(epoch from current_timestamp - xact_start)::int, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; extract(epoch from current_timestamp - query_start)::int from pg_stat_activity;')</font></div><div><font size="2"   >&nbsp; &nbsp; results = db_curs.fetchall()</font></div><div><font size="2"   >&nbsp; &nbsp; active = 0</font></div><div><font size="2"   >&nbsp; &nbsp; idle = 0</font></div><div><font size="2"   >&nbsp; &nbsp; idleintxn = 0</font></div><div><font size="2"   >&nbsp; &nbsp; waiting = 0</font></div><div><font size="2"   >&nbsp; &nbsp; active_results = []</font></div><div><font size="2"   >&nbsp; &nbsp; for state, waiting, xact_start_sec, query_start_sec in results:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if state == 'active':</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; active = int(active + 1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # build a list of query start times where query is active</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; active_results.append(query_start_sec)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if state == 'idle':</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idle = int(idle + 1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if state == 'idle in transaction':</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idleintxn = int(idleintxn + 1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if waiting == True:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waitingtrue = int(waitingtrue + 1)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; # determine longest transaction in seconds</font></div><div><font size="2"   >&nbsp; &nbsp; sorted_by_xact = sorted(results, key=lambda tup: tup[2], reverse=True)</font></div><div><font size="2"   >&nbsp; &nbsp; longest_xact_in_sec = (sorted_by_xact[0])[2]</font></div><div><font size="2"   >&nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; # determine longest active query in seconds</font></div><div><font size="2"   >&nbsp; &nbsp; sorted_by_query = sorted(active_results, reverse=True)</font></div><div><font size="2"   >&nbsp; &nbsp; longest_query_in_sec = sorted_by_query[0]</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; pg_metrics.update(</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'Pypg_idle_sessions':idle,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_active_sessions':active,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_waiting_sessions':waiting,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_idle_in_transaction_sessions':idleintxn,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_longest_xact':longest_xact_in_sec,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_longest_query':longest_query_in_sec})</font></div><div><font size="2"   >&nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; # locks query</font></div><div><font size="2"   >&nbsp; &nbsp; db_curs.execute('select mode, locktype from pg_locks;')</font></div><div><font size="2"   >&nbsp; &nbsp; results = db_curs.fetchall()</font></div><div><font size="2"   >&nbsp; &nbsp; accessexclusive = 0</font></div><div><font size="2"   >&nbsp; &nbsp; otherexclusive = 0</font></div><div><font size="2"   >&nbsp; &nbsp; shared = 0</font></div><div><font size="2"   >&nbsp; &nbsp; for mode, locktype in results:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (mode == 'AccessExclusiveLock' and locktype != 'virtualxid'):</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessexclusive = int(accessexclusive + 1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (mode != 'AccessExclusiveLock' and locktype != 'virtualxid'):</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if 'Exclusive' in mode:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherexclusive = int(otherexclusive + 1)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if ('Share' in mode and locktype != 'virtualxid'):</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared = int(shared + 1)&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; pg_metrics.update(</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'Pypg_locks_accessexclusive':accessexclusive,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_locks_otherexclusive':otherexclusive,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_locks_shared':shared})</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; # background writer query returns one row that needs to be parsed</font></div><div><font size="2"   >&nbsp; &nbsp; db_curs.execute(</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'select checkpoints_timed, checkpoints_req, checkpoint_write_time, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; checkpoint_sync_time, buffers_checkpoint, buffers_clean, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; buffers_backend, buffers_alloc from pg_stat_bgwriter;')</font></div><div><font size="2"   >&nbsp; &nbsp; results = db_curs.fetchall()</font></div><div><font size="2"   >&nbsp; &nbsp; bgwriter_values = results[0]</font></div><div><font size="2"   >&nbsp; &nbsp; checkpoints_timed = int(bgwriter_values[0])</font></div><div><font size="2"   >&nbsp; &nbsp; checkpoints_req = int(bgwriter_values[1])</font></div><div><font size="2"   >&nbsp; &nbsp; checkpoint_write_time = int(bgwriter_values[2])</font></div><div><font size="2"   >&nbsp; &nbsp; checkpoint_sync_time = int(bgwriter_values[3])</font></div><div><font size="2"   >&nbsp; &nbsp; buffers_checkpoint = int(bgwriter_values[4])</font></div><div><font size="2"   >&nbsp; &nbsp; buffers_clean = int(bgwriter_values[5])</font></div><div><font size="2"   >&nbsp; &nbsp; buffers_backend = int(bgwriter_values[6])</font></div><div><font size="2"   >&nbsp; &nbsp; buffers_alloc = int(bgwriter_values[7])</font></div><div><font size="2"   >&nbsp; &nbsp; pg_metrics.update(</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'Pypg_bgwriter_checkpoints_timed':checkpoints_timed,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_bgwriter_checkpoints_req':checkpoints_req,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_bgwriter_checkpoint_write_time':checkpoint_write_time,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_bgwriter_checkpoint_sync_time':checkpoint_sync_time,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_bgwriter_buffers_checkpoint':buffers_checkpoint,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_bgwriter_buffers_clean':buffers_clean,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_bgwriter_buffers_backend':buffers_backend,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_bgwriter_buffers_alloc':buffers_alloc})</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; # database statistics returns one row that needs to be parsed</font></div><div><font size="2"   >&nbsp; &nbsp; db_curs.execute(</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'select (sum(xact_commit) + sum(xact_rollback)), sum(tup_inserted), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; sum(tup_updated), sum(tup_deleted), (sum(tup_returned) + sum(tup_fetched)), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; sum(blks_read), sum(blks_hit) from pg_stat_database;')</font></div><div><font size="2"   >&nbsp; &nbsp; results = db_curs.fetchall()</font></div><div><font size="2"   >&nbsp; &nbsp; pg_stat_db_values = results[0]</font></div><div><font size="2"   >&nbsp; &nbsp; transactions = int(pg_stat_db_values[0])</font></div><div><font size="2"   >&nbsp; &nbsp; inserts = int(pg_stat_db_values[1])</font></div><div><font size="2"   >&nbsp; &nbsp; updates = int(pg_stat_db_values[2])</font></div><div><font size="2"   >&nbsp; &nbsp; deletes = int(pg_stat_db_values[3])</font></div><div><font size="2"   >&nbsp; &nbsp; reads = int(pg_stat_db_values[4])</font></div><div><font size="2"   >&nbsp; &nbsp; blksdisk = int(pg_stat_db_values[5])</font></div><div><font size="2"   >&nbsp; &nbsp; blksmem = int(pg_stat_db_values[6])</font></div><div><font size="2"   >&nbsp; &nbsp; pg_metrics.update(</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'Pypg_transactions':transactions,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_inserts':inserts,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_updates':updates,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_deletes':deletes,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_reads':reads,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_blks_diskread':blksdisk,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_blks_memread':blksmem})</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; # table statistics returns one row that needs to be parsed</font></div><div><font size="2"   >&nbsp; &nbsp; db_curs.execute(</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'select sum(seq_tup_read), sum(idx_tup_fetch), \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; extract(epoch from now() - min(last_vacuum))::int/60/60, \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; extract(epoch from now() - min(last_analyze))::int/60/60 \</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; from pg_stat_all_tables;')</font></div><div><font size="2"   >&nbsp; &nbsp; results = db_curs.fetchall()</font></div><div><font size="2"   >&nbsp; &nbsp; pg_stat_table_values = results[0]</font></div><div><font size="2"   >&nbsp; &nbsp; seqscan = int(pg_stat_table_values[0])</font></div><div><font size="2"   >&nbsp; &nbsp; idxfetch = int(pg_stat_table_values[1])</font></div><div><font size="2"   >&nbsp; &nbsp; hours_since_vacuum = int(pg_stat_table_values[2])</font></div><div><font size="2"   >&nbsp; &nbsp; hours_since_analyze = int(pg_stat_table_values[3])</font></div><div><font size="2"   >&nbsp; &nbsp; pg_metrics.update(</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {'Pypg_tup_seqscan':seqscan,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_tup_idxfetch':idxfetch,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_hours_since_last_vacuum':hours_since_vacuum,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 'Pypg_hours_since_last_analyze':hours_since_analyze})</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; db_curs.close()</font></div><div><font size="2"   >&nbsp; &nbsp; return pg_metrics</font></div></div><p></p></pre></div><div>以上pg_metrics字典其实已经包含了所有metric name对应的value , 所以在metric对应的call back函数直接返回其值int(pg_metrics[name])即可.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >def metric_handler(name):</font></div><div><font size="2"   >&nbsp; &nbsp; pg_metrics = pg_metrics_queries()</font></div><div><font size="2"   >&nbsp; &nbsp; return int(pg_metrics[name])</font></div><p></p></pre></div><div><br></div><div>最后一个必须的函数是metric_cleanup(), 在gmond关闭时调用它. 一般用于关闭打开的文件, 断开网络等.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >This function will be called once when gmond is shutting down. The cleanupfunction</font></div><div><font size="2"   >should include any code that is required to close files, disconnection from the network,</font></div><div><font size="2"   >or &nbsp;any &nbsp;other &nbsp;type &nbsp;of &nbsp;clean &nbsp;up &nbsp;functionality. &nbsp;Like &nbsp;the &nbsp;metric_init function, &nbsp;the</font></div><div><font size="2"   >cleanupfunction must be called metric_cleanupand must not take any parameters. In</font></div><div><font size="2"   >addition, the cleanupfunction must not return a value.</font></div><p></p></pre></div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># ganglia requires metric cleanup</font></div><div><font size="2"   >def metric_cleanup():</font></div><div><font size="2"   >&nbsp; &nbsp; '''Clean up the metric module.'''</font></div><div><font size="2"   >&nbsp; &nbsp; pass</font></div><p></p></pre></div><div><br></div><div>2. 编写.py脚本对应的.pyconf配置文件. &nbsp;注意这个配置文件的位置需对应在modpython.conf中配置的位置.</div><div>文件内容和gmond.conf其实差别不大(除了modules section).</div><div>例如postgres.pyconf</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >modules {</font></div><div><font size="2"   >&nbsp; &nbsp;module {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "postgres"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;language = "python"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;param host {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;value = "hostname_goes_here"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;param port {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;value = "port_goes_here"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;param dbname {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;value = "database_goes_here"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;param username {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;value = "username_goes_here"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;param password {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;value = "password_goes_here"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >collection_group {</font></div><div><font size="2"   >&nbsp; &nbsp;collect_every = 120</font></div><div><font size="2"   >&nbsp; &nbsp;time_threshold = 120</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_idle_sessions"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Idle Sessions"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_idle_in_transaction_sessions"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Idle In Transaction Sessions"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_active_sessions"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Active Sessions"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_hours_since_last_vacuum"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Hours Since Last Vacuum"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_hours_since_last_analyze"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Hours Since Last Analyze"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_waiting_sessions"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Waiting Sessions blocked"&nbsp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_locks_accessexclusive"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres AccessExclusive Locks read write blocking"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_locks_otherexclusive"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Exclusive Locks write blocking"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_locks_shared"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Shared Locks NON blocking"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_longest_xact"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Longest Transaction in Minutes"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_longest_query"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Longest Active Query in Minutes"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_transactions"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Transactions"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_inserts"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Inserts"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_updates"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Updates"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_deletes"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Deletes"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_reads"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Reads"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_blks_diskread"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Blocks Read From Disk"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_blks_memread"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Blocks Read From Memory Buffer Cache"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_tup_seqscan"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Tuples Read From Table Sequence Scans"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_tup_idxfetch"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Tuples Fetched From Indexes"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_bgwriter_checkpoints_timed"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Scheduled Checkpoints"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_bgwriter_checkpoints_req"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Unscheduled Checkpoints"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_bgwriter_checkpoint_write_time"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Time to Write Checkpoints to Disk"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_bgwriter_checkpoint_sync_time"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Time to Sync Checkpoints to Disk"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_bgwriter_buffers_checkpoint"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Buffers Written During Checkpoint"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_bgwriter_buffers_clean"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Buffers Written By Background Writer"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_bgwriter_buffers_backend"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Buffers Written Directly By Backend"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >&nbsp; &nbsp;metric {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;name = "Pypg_bgwriter_buffers_alloc"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;title = "Postgres Number Of Buffers Allocated"</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;value_threshold = 0</font></div><div><font size="2"   >&nbsp; &nbsp;}</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>三. 调试 python metric 模块. 这部分内容也写在.py脚本里面. 用以输出metric的值</div><div>例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   ># this code is for debugging and unit testing &nbsp; &nbsp;</font></div><div><font size="2"   >if __name__ == '__main__':</font></div><div><font size="2"   >&nbsp; &nbsp; descriptors = metric_init({"host":"hostname_goes_here","port":"port_goes_here","dbname":"database_name_goes_here","username":"username_goes_here","password":"password_goes_here"})</font></div><div><font size="2"   >&nbsp; &nbsp; while True:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; for d in descriptors:</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = d['call_back'](d['name'])</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print 'value for %s is %u' % (d['name'], &nbsp;v)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; time.sleep(5)</font></div><p></p></pre></div><div><br></div><div>四. 配置和部署python metric 模块</div><div>前面已经讲过了, 需要配置gmond.conf以及.pyconf配置文件.</div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/16387704020148345219914/"   >http://blog.163.com/digoal@126/blog/static/16387704020148345219914/</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201481835916946/"   >http://blog.163.com/digoal@126/blog/static/163877040201481835916946/</a></div><div>3.&nbsp;<a style="line-height: 28px;" target="_blank" href="http://blog.163.com/digoal@126/blog/static/163877040201481843417188/"   >http://blog.163.com/digoal@126/blog/static/163877040201481843417188/</a></div><div>4.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://github.com/ganglia/gmond_python_modules/blob/master/postgresql/conf.d/postgres.pyconf"   >https://github.com/ganglia/gmond_python_modules/blob/master/postgresql/conf.d/postgres.pyconf</a></div><div>5.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://github.com/ganglia/gmond_python_modules/blob/master/postgresql/python_modules/postgres.py"   >https://github.com/ganglia/gmond_python_modules/blob/master/postgresql/python_modules/postgres.py</a></div><div>6.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="https://github.com/ganglia/gmond_python_modules"   >https://github.com/ganglia/gmond_python_modules</a></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="ganglia metric extended by mod_python - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>