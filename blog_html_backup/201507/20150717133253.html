<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL (User defined Operator) UDO & Operator Optimization Information</h2>
	<h5 id="">2015-07-17 13:32:53&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020156158447718/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 支持自定义操作符，本质上是调用函数来实现的。</div><div>语法如下：</div><div><pre style="-webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border: 1px solid rgb(207, 207, 207); padding: 2ex; margin-top: 2ex; margin-bottom: 2ex; margin-left: 2ex; overflow: auto; border-radius: 8px; line-height: normal; background-color: rgb(247, 247, 247);"   ><font size="2"   >CREATE OPERATOR <tt style="font-weight: bold; font-style: italic;"   >name</tt> (
    PROCEDURE = <tt style="font-weight: bold; font-style: italic;"   >function_name</tt>
    [, LEFTARG = <tt style="font-weight: bold; font-style: italic;"   >left_type</tt> ] [, RIGHTARG = <tt style="font-weight: bold; font-style: italic;"   >right_type</tt> ]
    [, COMMUTATOR = <tt style="font-weight: bold; font-style: italic;"   >com_op</tt> ] [, NEGATOR = <tt style="font-weight: bold; font-style: italic;"   >neg_op</tt> ]
    [, RESTRICT = <tt style="font-weight: bold; font-style: italic;"   >res_proc</tt> ] [, JOIN = <tt style="font-weight: bold; font-style: italic;"   >join_proc</tt> ]
    [, HASHES ] [, MERGES ]
)</font></pre></div><wbr><div>例如创建一个求两个值的平均值的操作符：</div><div>首选要创建函数</div><div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create function f_avg(numeric,numeric) returns numeric as $$</font></div><div><font size="2"   >postgres$# &nbsp; select ($1+$2)/2;</font></div><div><font size="2"   >postgres$# $$ language sql strict;</font></div><div><font size="2"   >CREATE FUNCTION</font></div><p></p></pre></div><div>验证函数</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select f_avg(1,null);</font></div><div><font size="2"   >&nbsp;f_avg&nbsp;</font></div><div><font size="2"   >-------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >postgres=# select f_avg(1,2);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;f_avg &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------------</font></div><div><font size="2"   >&nbsp;1.5000000000000000</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div></div><div><span style="line-height: 28px;"   >创建操作符，指定左右参数类型，调用的函数名，</span><span style="line-height: 28px;"   >commutator是一个和优化器相关的选项，我后面会重点介绍</span><span style="line-height: 28px;"   >：</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create operator ## (procedure=f_avg, leftarg=numeric, rightarg=numeric, commutator='##');</font></div><div><font size="2"   >CREATE OPERATOR</font></div><div><font size="2"   >postgres=# select 1 ## 2;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; ?column? &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >--------------------</font></div><div><font size="2"   >&nbsp;1.5000000000000000</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div><br></div><div>注意到在创建操作符的语法中有6个和优化器有关的关键字：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >&nbsp; &nbsp; [, COMMUTATOR = com_op ] [, NEGATOR = neg_op ]</font></div><div><font size="2"   >&nbsp; &nbsp; [, RESTRICT = res_proc ] [, JOIN = join_proc ]</font></div><div><font size="2"   >&nbsp; &nbsp; [, HASHES ] [, MERGES ]</font></div><p></p></pre></div><div>介绍如下：</div><div>假设x表示操作符左侧的参数，y表示操作符右侧的参数</div><div>1. commutator，指明x op1 y等效于y op2 x，即操作数调换，返回的值一样。例如2&gt;1 和1&lt;2结果是一致的。那么&gt;就是&lt;的commutator或者反之。又例如1+2和2+1是等价的，那么+就是+的commutator。commutator只需要在创建其中一个操作符时指定，创建另一个对应的操作符时可以不需要指定，PostgreSQL会自动建立这个关系。例如创建&gt;操作符时指定了它的commutator是&lt;，那么在创建&lt;操作符时可以不需要指定&gt;是它的commutator。</div><div>另外需要注意，有commutator操作符的操作符的左右两侧的参数类型必须一致，这样才能满足x op1 y等价于y op2 x。</div><div>优化器如何利用commutator呢？例如索引扫描，必须列在操作符的左侧才能使用索引。1 &gt; tbl.c这个条件，如果&gt;没有commutator的话，是不能使用索引的。</div><div>例子，以int4的&gt;和&lt;操作符为例，实验一下：</div><div>&gt;和&lt;在PostgreSQL中是一对commutator</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select oprcom::regoper from pg_operator where oprname='&gt;' and oprcode='int4gt'::regproc;</font></div><div><font size="2"   >&nbsp; &nbsp; oprcom &nbsp; &nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp;pg_catalog.&lt;</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >postgres=# select oprcom::regoper from pg_operator where oprname='&lt;' and oprcode='int4lt'::regproc;</font></div><div><font size="2"   >&nbsp; &nbsp; oprcom &nbsp; &nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp;pg_catalog.&gt;</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>记录他们的oprcom对应的OID</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select * from pg_operator where oprname='&gt;' and oprcode='int4gt'::regproc;</font></div><div><font size="2"   >&nbsp;oprname | oprnamespace | oprowner | oprkind | oprcanmerge | oprcanhash | oprleft | oprright | oprresult | oprcom | oprnegate | oprc</font></div><div><font size="2"   >ode | &nbsp; oprrest &nbsp; | &nbsp; &nbsp; oprjoin &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------+--------------+----------+---------+-------------+------------+---------+----------+-----------+--------+-----------+-----</font></div><div><font size="2"   >----+-------------+-----------------</font></div><div><font size="2"   >&nbsp;&gt; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | &nbsp; &nbsp; &nbsp; 10 | b &nbsp; &nbsp; &nbsp; | f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;23 | &nbsp; &nbsp; &nbsp; 23 | &nbsp; &nbsp; &nbsp; &nbsp;16 | &nbsp; &nbsp; 97 | &nbsp; &nbsp; &nbsp; 523 | int4</font></div><div><font size="2"   >gt &nbsp;| scalargtsel | scalargtjoinsel</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   >postgres=# select * from pg_operator where oprname='&lt;' and oprcode='int4lt'::regproc;</font></div><div><font size="2"   >&nbsp;oprname | oprnamespace | oprowner | oprkind | oprcanmerge | oprcanhash | oprleft | oprright | oprresult | oprcom | oprnegate | oprc</font></div><div><font size="2"   >ode | &nbsp; oprrest &nbsp; | &nbsp; &nbsp; oprjoin &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------+--------------+----------+---------+-------------+------------+---------+----------+-----------+--------+-----------+-----</font></div><div><font size="2"   >----+-------------+-----------------</font></div><div><font size="2"   >&nbsp;&lt; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11 | &nbsp; &nbsp; &nbsp; 10 | b &nbsp; &nbsp; &nbsp; | f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;23 | &nbsp; &nbsp; &nbsp; 23 | &nbsp; &nbsp; &nbsp; &nbsp;16 | &nbsp; &nbsp;521 | &nbsp; &nbsp; &nbsp; 525 | int4</font></div><div><font size="2"   >lt &nbsp;| scalarltsel | scalarltjoinsel</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>接下来我要通过更新pg_operator解除他们的commutator关系，设置为0即可。</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# update pg_operator set oprcom=0 where oprname='&gt;' and oprcode='int4gt'::regproc;</font></div><div><font size="2"   >UPDATE 1</font></div></div><div><div><font size="2"   >postgres=# update pg_operator set oprcom=0 where oprname='&lt;' and oprcode='int4lt'::regproc;</font></div><div><font size="2"   >UPDATE 1</font></div></div><p></p></pre></div><div>创建测试表，插入测试数据，创建索引：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# create table tbl(id int);</font></div><div><font size="2"   >CREATE TABLE</font></div><div><font size="2"   >postgres=# insert into tbl select generate_series(1,100000);</font></div><div><font size="2"   >INSERT 0 100000</font></div><div><font size="2"   >postgres=# create index idx_tbl_id on tbl(id);</font></div><div><font size="2"   >CREATE INDEX</font></div><p></p></pre></div><div>将列放在条件的左边可以走索引，但是放在右边不走索引。因为优化器不能决定&gt;,&lt;是否为commutator</div><div><pre class="prettyprint"   ><p></p><div><div><span style="line-height: 28px;"   ><font size="2"   >postgres=# explain select * from tbl where id&lt;10;</font></span></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Only Scan using idx_tbl_id on tbl &nbsp;(cost=0.29..8.45 rows=9 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (id &lt; 10)</font></div><div><font size="2"   >(2 rows)</font></div></div><div><div style="line-height: 28px;"   ><font size="2"   >postgres=# explain select * from tbl where 10&gt;id;</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></div><div style="line-height: 28px;"   ><font size="2"   >----------------------------------------------------------</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp;Seq Scan on tbl &nbsp;(cost=0.00..1361.00 rows=33333 width=4)</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp;Filter: (10 &gt; id)</font></div><div style="line-height: 28px;"   ><font size="2"   >(2 rows)</font></div></div><p></p></pre></div><div style="line-height: 28px;"   >重新建立这两个 operator的commutator关系后，优化器会自动将10&gt;id转换为id&lt;10，并且走索引了：</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >postgres=# update pg_operator set oprcom=521 where oprname='&lt;' and oprcode='int4lt'::regproc;</font></div><div><font size="2"   >UPDATE 1</font></div></div><div><div><font size="2"   >postgres=# update pg_operator set oprcom=97 where oprname='&gt;' and oprcode='int4gt'::regproc;</font></div><div><font size="2"   >UPDATE 1</font></div><div><font size="2"   >postgres=# explain select * from tbl where 10&gt;id;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Only Scan using idx_tbl_id on tbl &nbsp;(cost=0.29..8.45 rows=9 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (id &lt; 10)</font></div><div><font size="2"   >(2 rows)</font></div></div><p></p></pre></div><div><br></div><div>2. negator，指x op1 y 等价于 not(y op2 x)，或者x op1等价于not( y op2)，或者op1 x 等价于not(op2 y)，因此negator支持一元和二元操作符。</div><div>例子:</div><div>如果=和&lt;&gt;是一对negator操作符，<span style="line-height: 28px;"   >NOT (x = y) 可以简化为 x &lt;&gt; y。</span></div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# explain select * from tbl where 10=id;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Only Scan using idx_tbl_id on tbl &nbsp;(cost=0.29..8.31 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (id = 10)</font></div><div><font size="2"   >(2 rows)</font></div><div><font size="2"   >postgres=# explain select * from tbl where not(10&lt;&gt;id);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QUERY PLAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div><font size="2"   >---------------------------------------------------------------------------</font></div><div><font size="2"   >&nbsp;Index Only Scan using idx_tbl_id on tbl &nbsp;(cost=0.29..8.31 rows=1 width=4)</font></div><div><font size="2"   >&nbsp; &nbsp;Index Cond: (id = 10)</font></div><div><font size="2"   >(2 rows)</font></div><p></p></pre></div><div>同样，操作符两侧参数x,y的类型必须一致。并且仅适用于返回布尔逻辑类型的操作符。</div><div><br></div><div>3. restrict，是用于评估选择性的函数，仅适用于二元操作符，例如where col&gt;100，这个查询条件，如何评估选择性呢？是通过操作符的restrict来指定的，选择性乘以pg_class.reltuples就可以评估得到这个查询条件的行数。</div><div>选择性函数的代码在 src/backend/utils/adt/&nbsp;</div><div>包括</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >-rw-r--r--. 1 1107 1107 &nbsp;33191 Jun 10 03:29 array_selfuncs.c</font></div><div><font size="2"   >-rw-r--r--. 1 1107 1107 &nbsp; 2316 Jun 10 03:29 geo_selfuncs.c</font></div><div><font size="2"   >-rw-r--r--. 1 1107 1107 &nbsp; &nbsp;720 Jun 10 03:29 network_selfuncs.c</font></div><div><font size="2"   >-rw-r--r--. 1 1107 1107 &nbsp;33895 Jun 10 03:29 rangetypes_selfuncs.c</font></div><div><font size="2"   >-rw-r--r--. 1 1107 1107 218809 Jun 10 03:29 selfuncs.c</font></div><p></p></pre></div><div>选择性函数，还需要依赖数据库的统计信息，从而计算选择性，常见的选择性计算函数有：</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select distinct oprrest from pg_operator order by 1;</font></div><div><font size="2"   >&nbsp; &nbsp;oprrest &nbsp; &nbsp;</font></div><div><font size="2"   >--------------</font></div><div><font size="2"   >&nbsp;-</font></div><div><font size="2"   >&nbsp;eqsel &nbsp;相等</font></div><div><font size="2"   >&nbsp;neqsel &nbsp;不相等</font></div><div><font size="2"   >&nbsp;scalarltsel &nbsp;小于等于</font></div><div><font size="2"   >&nbsp;scalargtsel &nbsp;大于等于</font></div><div><font size="2"   >&nbsp;areasel</font></div><div><font size="2"   >&nbsp;positionsel</font></div><div><font size="2"   >&nbsp;contsel</font></div><div><font size="2"   >&nbsp;iclikesel</font></div><div><font size="2"   >&nbsp;icnlikesel</font></div><div><font size="2"   >&nbsp;regexeqsel</font></div><div><font size="2"   >&nbsp;likesel</font></div><div><font size="2"   >&nbsp;icregexeqsel</font></div><div><font size="2"   >&nbsp;regexnesel</font></div><div><font size="2"   >&nbsp;nlikesel</font></div><div><font size="2"   >&nbsp;icregexnesel</font></div><div><font size="2"   >&nbsp;rangesel</font></div><div><font size="2"   >&nbsp;networksel</font></div><div><font size="2"   >&nbsp;tsmatchsel</font></div><div><font size="2"   >&nbsp;arraycontsel</font></div><div><font size="2"   >(20 rows)</font></div><p></p></pre></div><div>当然，用户如果自定义数据类型的话，也可以自定义选择性函数，或者使用以上标准的选择性函数，只是可能需要实现一下类型转换。</div><div>源码中的介绍：</div><div>src/backend/utils/adt/selfuncs.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*----------</font></div><div><font size="2"   >&nbsp;* Operator selectivity estimation functions are called to estimate the</font></div><div><font size="2"   >&nbsp;* selectivity of WHERE clauses whose top-level operator is their operator.</font></div><div><font size="2"   >&nbsp;* We divide the problem into two cases:</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Restriction clause estimation: the clause involves vars of just</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;one relation. &nbsp;一种是符合WHERE条件的选择性（百分比）。</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Join clause estimation: the clause involves vars of multiple rels.</font></div><div><font size="2"   >&nbsp;* Join selectivity estimation is far more difficult and usually less accurate</font></div><div><font size="2"   >&nbsp;* than restriction estimation. &nbsp;-- JOIN的选择性评估通常没有WHERE条件的选择性准确。</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* When dealing with the inner scan of a nestloop join, we consider the</font></div><div><font size="2"   >&nbsp;* join's joinclauses as restriction clauses for the inner relation, and</font></div><div><font size="2"   >&nbsp;* treat vars of the outer relation as parameters (a/k/a constants of unknown</font></div><div><font size="2"   >&nbsp;* values). &nbsp;So, restriction estimators need to be able to accept an argument</font></div><div><font size="2"   >&nbsp;* telling which relation is to be treated as the variable.</font></div></div><div><font size="2"   >在使用nestloop JOIN时，一个表的字段将作为变量，另一个表的字段（及其统计信息）与操作符作为JOIN评估子句。</font></div><div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The call convention for a restriction estimator (oprrest function) is</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Selectivity oprrest (PlannerInfo *root,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid operator,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *args,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int varRelid);</font></div><div><font size="2"   >&nbsp;* 评估选择性需要4个参数:</font></div><div><font size="2"   >&nbsp;* root: general information about the query (rtable and RelOptInfo lists</font></div><div><font size="2"   >&nbsp;* are particularly important for the estimator). &nbsp; plannerinfo信息。</font></div><div><font size="2"   >&nbsp;* operator: OID of the specific operator in question. 操作符的OID</font></div><div><font size="2"   >&nbsp;* args: argument list from the operator clause. &nbsp;操作符子句中的参数列表</font></div><div><font size="2"   >&nbsp;* varRelid: if not zero, the relid (rtable index) of the relation to</font></div><div><font size="2"   >&nbsp;* be treated as the variable relation. &nbsp;May be zero if the args list</font></div><div><font size="2"   >&nbsp;* is known to contain vars of only one relation. &nbsp; 表示where条件所包含的参数来自哪些relation。</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* This is represented at the SQL level (in pg_proc) as</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float8 oprrest (internal, oid, internal, int4); &nbsp; 在pg_proc数据字典中表示为oprrest指定的函数。</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The result is a selectivity, that is, a fraction (0 to 1) of the rows</font></div><div><font size="2"   >&nbsp;* of the relation that are expected to produce a TRUE result for the</font></div><div><font size="2"   >&nbsp;* given operator. &nbsp;选择性函数的评估结果就是一个百分比。乘以pg_class.reltuples就可以得到记录数。</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* The call convention for a join estimator (oprjoin function) is similar</font></div><div><font size="2"   >&nbsp;* except that varRelid is not needed, and instead join information is</font></div><div><font size="2"   >&nbsp;* supplied:</font></div><div><font size="2"   >&nbsp;* JOIN选择性的计算函数与WHERE选择性的计算函数参数有轻微差别，么有varRelid, 增加了join信息的参数。</font></div></div><div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Selectivity oprjoin (PlannerInfo *root,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid operator,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *args,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JoinType jointype,</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpecialJoinInfo *sjinfo);</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float8 oprjoin (internal, oid, internal, int2, internal);</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* (Before Postgres 8.4, join estimators had only the first four of these</font></div><div><font size="2"   >&nbsp;* parameters. &nbsp;That signature is still allowed, but deprecated.) &nbsp;The</font></div><div><font size="2"   >&nbsp;* relationship between jointype and sjinfo is explained in the comments for</font></div><div><font size="2"   >&nbsp;* clause_selectivity() --- the short version is that jointype is usually</font></div><div><font size="2"   >&nbsp;* best ignored in favor of examining sjinfo.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Join selectivity for regular inner and outer joins is defined as the</font></div><div><font size="2"   >&nbsp;* fraction (0 to 1) of the cross product of the relations that is expected</font></div><div><font size="2"   >&nbsp;* to produce a TRUE result for the given operator. &nbsp;For both semi and anti &nbsp;(半连接与预连接)</font></div><div><font size="2"   >&nbsp;* joins, however, the selectivity is defined as the fraction of the left-hand</font></div><div><font size="2"   >&nbsp;* side relation's rows that are expected to have a match (ie, at least one</font></div><div><font size="2"   >&nbsp;* row with a TRUE result) in the right-hand side.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* For both oprrest and oprjoin functions, the operator's input collation OID</font></div><div><font size="2"   >&nbsp;* (if any) is passed using the standard fmgr mechanism, so that the estimator</font></div><div><font size="2"   >&nbsp;* function can fetch it with PG_GET_COLLATION(). &nbsp;Note, however, that all</font></div><div><font size="2"   >&nbsp;* statistics in pg_statistic are currently built using the database's default</font></div><div><font size="2"   >&nbsp;* collation. &nbsp;Thus, in most cases where we are looking at statistics, we</font></div><div><font size="2"   >&nbsp;* should ignore the actual operator collation and use DEFAULT_COLLATION_OID.</font></div><div><font size="2"   >&nbsp;* We expect that the error induced by doing this is usually not large enough</font></div><div><font size="2"   >&nbsp;* to justify complicating matters.</font></div><div><font size="2"   >&nbsp;*----------</font></div></div><p></p></pre></div><div><br></div><div>4. join，是joinsel即join的选择性计算函数。</div><div>对应pg_operator.oprjoin</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >postgres=# select distinct oprjoin from pg_operator order by 1;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp;oprjoin &nbsp; &nbsp; &nbsp;</font></div><div><font size="2"   >------------------</font></div><div><font size="2"   >&nbsp;-</font></div><div><font size="2"   >&nbsp;eqjoinsel</font></div><div><font size="2"   >&nbsp;neqjoinsel</font></div><div><font size="2"   >&nbsp;scalarltjoinsel</font></div><div><font size="2"   >&nbsp;scalargtjoinsel</font></div><div><font size="2"   >&nbsp;areajoinsel</font></div><div><font size="2"   >&nbsp;positionjoinsel</font></div><div><font size="2"   >&nbsp;contjoinsel</font></div><div><font size="2"   >&nbsp;iclikejoinsel</font></div><div><font size="2"   >&nbsp;icnlikejoinsel</font></div><div><font size="2"   >&nbsp;regexeqjoinsel</font></div><div><font size="2"   >&nbsp;likejoinsel</font></div><div><font size="2"   >&nbsp;icregexeqjoinsel</font></div><div><font size="2"   >&nbsp;regexnejoinsel</font></div><div><font size="2"   >&nbsp;nlikejoinsel</font></div><div><font size="2"   >&nbsp;icregexnejoinsel</font></div><div><font size="2"   >&nbsp;networkjoinsel</font></div><div><font size="2"   >&nbsp;tsmatchjoinsel</font></div><div><font size="2"   >&nbsp;arraycontjoinsel</font></div><div><font size="2"   >(19 rows)</font></div><p></p></pre></div><div><br></div><div>5. hashes</div><div>6. merges</div><div>hashes和merges表示该操作符是否允许hash join和merge join, 只有返回布尔逻辑值的二元操作符满足这个要求。</div><div><br></div><div>我们在pg_operator这个catalog中也可以查看到对应的介绍：</div><div><table border="1"   style="margin: 2ex 0px 2ex 2ex; -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px; box-shadow: rgb(223, 223, 223) 3px 3px 5px; border-spacing: 0px; border-collapse: collapse; border: 2px solid rgb(167, 198, 223); color: rgb(0, 0, 0); font-family: verdana, sans-serif; font-size: 12.1599998474121px; line-height: normal; background-color: rgb(224, 236, 239);"   ><colgroup><col><col><col><col><thead><tr><th style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex;"   >Name</th><th style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex;"   >Type</th><th style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex;"   >References</th><th style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex;"   >Description</th></tr></thead><tbody><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >&nbsp;</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Row identifier (hidden attribute; must be explicitly selected)</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprname</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>name</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >&nbsp;</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Name of the operator</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprnamespace</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt><a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/catalog-pg-namespace.html"   ><tt style="font-size: 1em;"   >pg_namespace</tt></a>.oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >The OID of the namespace that contains this operator</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprowner</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt><a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/catalog-pg-authid.html"   ><tt style="font-size: 1em;"   >pg_authid</tt></a>.oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Owner of the operator</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprkind</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>char</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >&nbsp;</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>b</tt>&nbsp;= infix (<span>"between"</span>),&nbsp;<tt>l</tt>&nbsp;= prefix (<span>"left"</span>),&nbsp;<tt>r</tt>&nbsp;= postfix (<span>"right"</span>)<br>指定操作符在什么位置，例如中间，左侧，右侧</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprcanmerge</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>bool</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >&nbsp;</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >This operator supports merge joins<br>此操作符是否支持merge join</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprcanhash</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>bool</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >&nbsp;</td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >This operator supports hash joins<br>此操作符是否支持hash join</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprleft</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt><a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/catalog-pg-type.html"   ><tt style="font-size: 1em;"   >pg_type</tt></a>.oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Type of the left operand<br>操作符左侧的数据类型</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprright</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt><a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/catalog-pg-type.html"   ><tt style="font-size: 1em;"   >pg_type</tt></a>.oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Type of the right operand<br>操作符右侧的数据类型</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprresult</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt><a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/catalog-pg-type.html"   ><tt style="font-size: 1em;"   >pg_type</tt></a>.oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Type of the result<br>返回结果的数据类型</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprcom</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt><a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/catalog-pg-operator.html"   ><tt style="font-size: 1em;"   >pg_operator</tt></a>.oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Commutator of this operator, if any<br><br></td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprnegate</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt><a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/catalog-pg-operator.html"   ><tt style="font-size: 1em;"   >pg_operator</tt></a>.oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Negator of this operator, if any</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprcode</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>regproc</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt><a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/catalog-pg-proc.html"   ><tt style="font-size: 1em;"   >pg_proc</tt></a>.oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Function that implements this operator</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprrest</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>regproc</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt><a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/catalog-pg-proc.html"   ><tt style="font-size: 1em;"   >pg_proc</tt></a>.oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Restriction selectivity estimation function for this operator</td></tr><tr><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>oprjoin</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt>regproc</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   ><tt><a style="color: rgb(0, 78, 102);" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/catalog-pg-proc.html"   ><tt style="font-size: 1em;"   >pg_proc</tt></a>.oid</tt></td><td style="border: 1px solid rgb(167, 198, 223); padding: 0.5ex; background-color: rgb(255, 255, 255);"   >Join selectivity estimation function for this operator</td></tr></table></div><div><br></div>[参考]<wbr><div>1.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/sql-createoperator.html"   >http://www.postgresql.org/docs/9.4/static/sql-createoperator.html</a></div><div>2.&nbsp;<a style="line-height: 28px;" target="_blank" rel="nofollow" href="http://www.postgresql.org/docs/9.4/static/xoper-optimization.html"   >http://www.postgresql.org/docs/9.4/static/xoper-optimization.html</a></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL (User defined Operator) UDO  Operator Optimization Information - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>