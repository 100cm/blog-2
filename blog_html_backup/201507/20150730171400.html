<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL database cann't startup because memory overcommit</h2>
	<h5 id="">2015-07-30 17:14:00&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201563044143325/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>你可能遇到过类似的数据库无法启动的问题，</div><div><div>postgres@digoal-&gt; FATAL: &nbsp;XX000: could not map anonymous shared memory: Cannot allocate memory</div><div>HINT: &nbsp;This error usually means that PostgreSQL's request for a shared memory segment exceeded available memory, swap space, or huge pages. To reduce the request size (currently 3322716160 bytes), reduce PostgreSQL's shared memory usage, perhaps by reducing shared_buffers or max_connections.</div><div>LOCATION: &nbsp;CreateAnonymousSegment, pg_shmem.c:398</div></div><div><br></div><div>通过查看meminfo可以得到原因。</div><div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   >CommitLimit: Based on the overcommit ratio ('vm.overcommit_ratio'),</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this is the total amount of &nbsp;memory currently available to</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; be allocated on the system. This limit is only adhered to</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if strict overcommit accounting is enabled (mode 2 in</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'vm.overcommit_memory').</div></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The CommitLimit is calculated with the following formula:</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommitLimit = ([total RAM pages] - [total huge TLB pages]) *</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overcommit_ratio / 100 + [total swap pages]</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For example, on a system with 1G of physical RAM and 7G</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of swap with a `vm.overcommit_ratio` of 30 it would</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yield a CommitLimit of 7.3G.</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For more details, see the memory overcommit documentation</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in vm/overcommit-accounting.</div><div style="line-height: 28px;"   >Committed_AS: The amount of memory presently allocated on the system.</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The committed memory is a sum of all of the memory which</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has been allocated by processes, even if it has not been</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "used" by them as of yet. A process which malloc()'s 1G</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of memory, but only touches 300M of it will show up as</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using 1G. This 1G is memory which has been "committed" to</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; by the VM and can be used at any time by the allocating</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; application. With strict overcommit enabled on the system</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (mode 2 in 'vm.overcommit_memory'),allocations which would</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exceed the CommitLimit (detailed above) will not be permitted.</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This is useful if one needs to guarantee that processes will</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not fail due to lack of memory once that memory has been</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; successfully allocated.</div></div></div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >依据vm.overcommit_memory设置的值，</span></div><div><span style="line-height: 28px;"   >当</span><span style="line-height: 28px;"   >vm.overcommit_memory=0时，不允许普通用户overcommit, 但是允许root用户轻微的overcommit。</span></div><div><span style="line-height: 28px;"   >当vm.overcommit_memory=1时，允许overcommit.</span></div><div><span style="line-height: 28px;"   >当</span><span style="line-height: 28px;"   >vm.overcommit_memory=2时，</span><span style="line-height: 28px;"   >Committed_AS不能大于</span><span style="line-height: 28px;"   >CommitLimit。</span></div><div>commit 限制 计算方法</div><div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The CommitLimit is calculated with the following formula:</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommitLimit = ([total RAM pages] - [total huge TLB pages]) *</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overcommit_ratio / 100 + [total swap pages]</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For example, on a system with 1G of physical RAM and 7G</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of swap with a `vm.overcommit_ratio` of 30 it would</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yield a CommitLimit of 7.3G.</div></div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   >[root@digoal postgresql-9.4.4]# free</div><div style="line-height: 28px;"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;total &nbsp; &nbsp; &nbsp; used &nbsp; &nbsp; &nbsp; free &nbsp; &nbsp; shared &nbsp; &nbsp;buffers &nbsp; &nbsp; cached</div><div style="line-height: 28px;"   >Mem: &nbsp; &nbsp; &nbsp; 1914436 &nbsp; &nbsp; 713976 &nbsp; &nbsp;1200460 &nbsp; &nbsp; &nbsp;72588 &nbsp; &nbsp; &nbsp;32384 &nbsp; &nbsp; 529364</div><div style="line-height: 28px;"   >-/+ buffers/cache: &nbsp; &nbsp; 152228 &nbsp; &nbsp;1762208</div><div style="line-height: 28px;"   >Swap: &nbsp; &nbsp; &nbsp;1048572 &nbsp; &nbsp; 542080 &nbsp; &nbsp; 506492</div><div style="line-height: 28px;"   ><div style="line-height: 28px;"   >[root@digoal ~]# cat /proc/meminfo |grep Commit</div><div style="line-height: 28px;"   >CommitLimit: &nbsp; &nbsp; 2005788 kB</div><div style="line-height: 28px;"   >Committed_AS: &nbsp; &nbsp; 132384 kB</div><div style="line-height: 28px;"   >这个例子的2G就是以上公式计算得来。</div><div style="line-height: 28px;"   ><br></div><div style="line-height: 28px;"   >overcommit限制的初衷是malloc后，内存并不是立即使用掉，所以如果多个进程同时申请一批内存的话，不允许OVERCOMMIT可能导致某些进程申请内存失败，但实际上内存是还有的。所以Linux内核给出了几种选择，2是比较靠谱或者温柔的做法。1的话风险有点大，因为可能会导致OOM。</div><div style="line-height: 28px;"   ><br></div><div style="line-height: 28px;"   >所以当数据库无法启动时，要么你降低一下数据库申请内存的大小（例如降低shared_buffer或者max conn），要么就是修改一下overcommit的风格。</div></div></div><div><br></div>[参考]<wbr><div>1.&nbsp;kernel-doc-2.6.32/Documentation/filesystems/proc.txt</div><div><div>&nbsp; &nbsp; MemTotal: Total usable ram (i.e. physical ram minus a few reserved</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits and the kernel binary code)</div><div>&nbsp; &nbsp; &nbsp;MemFree: The sum of LowFree+HighFree</div><div>MemAvailable: An estimate of how much memory is available for starting new</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; applications, without swapping. Calculated from MemFree,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SReclaimable, the size of the file LRU lists, and the low</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; watermarks in each zone.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The estimate takes into account that the system needs some</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page cache to function well, and that not all reclaimable</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slab will be reclaimable, due to items being in use. The</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; impact of those factors will vary from system to system.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This line is only reported if sysctl vm.meminfo_legacy_layout = 0</div><div>&nbsp; &nbsp; &nbsp;Buffers: Relatively temporary storage for raw disk blocks</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shouldn't get tremendously large (20MB or so)</div><div>&nbsp; &nbsp; &nbsp; Cached: in-memory cache for files read from the disk (the</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagecache). &nbsp;Doesn't include SwapCached</div><div>&nbsp; SwapCached: Memory that once was swapped out, is swapped back in but</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; still also is in the swapfile (if memory is needed it</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; doesn't need to be swapped out AGAIN because it is already</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in the swapfile. This saves I/O)</div><div>&nbsp; &nbsp; &nbsp; Active: Memory that has been used more recently and usually not</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reclaimed unless absolutely necessary.</div><div>&nbsp; &nbsp; Inactive: Memory which has been less recently used. &nbsp;It is more</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eligible to be reclaimed for other purposes</div><div>&nbsp; &nbsp;HighTotal:</div><div>&nbsp; &nbsp; HighFree: Highmem is all memory above ~860MB of physical memory</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Highmem areas are for use by userspace programs, or</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for the pagecache. &nbsp;The kernel must use tricks to access</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this memory, making it slower to access than lowmem.</div><div>&nbsp; &nbsp; LowTotal:</div><div>&nbsp; &nbsp; &nbsp;LowFree: Lowmem is memory which can be used for everything that</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; highmem can be used for, but it is also available for the</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kernel's use for its own data structures. &nbsp;Among many</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; other things, it is where everything from the Slab is</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocated. &nbsp;Bad things happen when you're out of lowmem.</div><div>&nbsp; &nbsp;SwapTotal: total amount of swap space available</div><div>&nbsp; &nbsp; SwapFree: Memory which has been evicted from RAM, and is temporarily</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on the disk</div><div>&nbsp; &nbsp; &nbsp; &nbsp;Dirty: Memory which is waiting to get written back to the disk</div><div>&nbsp; &nbsp;Writeback: Memory which is actively being written back to the disk</div><div>&nbsp; &nbsp;AnonPages: Non-file backed pages mapped into userspace page tables</div><div>AnonHugePages: Non-file backed huge pages mapped into userspace page tables</div><div>&nbsp; &nbsp; &nbsp; Mapped: files which have been mmaped, such as libraries</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Slab: in-kernel data structures cache</div><div>SReclaimable: Part of Slab, that might be reclaimed, such as caches</div><div>&nbsp; SUnreclaim: Part of Slab, that cannot be reclaimed on memory pressure</div><div>&nbsp; PageTables: amount of memory dedicated to the lowest level of page</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tables.</div><div>NFS_Unstable: NFS pages sent to the server, but not yet committed to stable</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; storage</div><div>&nbsp; &nbsp; &nbsp; Bounce: Memory used for block device "bounce buffers"</div><div>WritebackTmp: Memory used by FUSE for temporary writeback buffers</div><div>&nbsp;CommitLimit: Based on the overcommit ratio ('vm.overcommit_ratio'),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this is the total amount of &nbsp;memory currently available to</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; be allocated on the system. This limit is only adhered to</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if strict overcommit accounting is enabled (mode 2 in</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'vm.overcommit_memory').</div></div><div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The CommitLimit is calculated with the following formula:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommitLimit = ([total RAM pages] - [total huge TLB pages]) *</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overcommit_ratio / 100 + [total swap pages]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For example, on a system with 1G of physical RAM and 7G</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of swap with a `vm.overcommit_ratio` of 30 it would</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yield a CommitLimit of 7.3G.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For more details, see the memory overcommit documentation</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in vm/overcommit-accounting.</div><div>Committed_AS: The amount of memory presently allocated on the system.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The committed memory is a sum of all of the memory which</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has been allocated by processes, even if it has not been</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "used" by them as of yet. A process which malloc()'s 1G</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of memory, but only touches 300M of it will show up as</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using 1G. This 1G is memory which has been "committed" to</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; by the VM and can be used at any time by the allocating</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; application. With strict overcommit enabled on the system</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (mode 2 in 'vm.overcommit_memory'),allocations which would</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exceed the CommitLimit (detailed above) will not be permitted.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This is useful if one needs to guarantee that processes will</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not fail due to lack of memory once that memory has been</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; successfully allocated.</div><div>VmallocTotal: total size of vmalloc memory area</div><div>&nbsp;VmallocUsed: amount of vmalloc area which is used</div><div>VmallocChunk: largest contiguous block of vmalloc area which is free</div></div><div><br></div><div>2.&nbsp;<span style="line-height: 28px;"   >kernel-doc-2.6.32/Documentation/</span><span style="line-height: 28px;"   >vm/overcommit-accounting</span></div><div><div>The Linux kernel supports the following overcommit handling modes</div><div><br></div><div>0 &nbsp; &nbsp; &nbsp; - &nbsp; &nbsp; &nbsp; Heuristic overcommit handling. Obvious overcommits of</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address space are refused. Used for a typical system. It</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ensures a seriously wild allocation fails while allowing</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overcommit to reduce swap usage. &nbsp;root is allowed to&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocate slighly more memory in this mode. This is the&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default.</div><div><br></div><div>1 &nbsp; &nbsp; &nbsp; - &nbsp; &nbsp; &nbsp; Always overcommit. Appropriate for some scientific</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; applications.</div><div><br></div><div>2 &nbsp; &nbsp; &nbsp; - &nbsp; &nbsp; &nbsp; Don't overcommit. The total address space commit</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for the system is not permitted to exceed swap + a</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; configurable amount (default is 50%) of physical RAM.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Depending on the amount you use, in most situations</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this means a process will not be killed while accessing</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pages but will receive errors on memory allocation as</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appropriate.</div><div><br></div><div>The overcommit policy is set via the sysctl `vm.overcommit_memory'.</div><div><br></div><div>The overcommit amount can be set via `vm.overcommit_ratio' (percentage)</div><div>or `vm.overcommit_kbytes' (absolute value).</div><div><br></div><div>The current overcommit limit and amount committed are viewable in</div><div>/proc/meminfo as CommitLimit and Committed_AS respectively.</div><div><br></div><div>Gotchas</div><div>-------</div><div><br></div><div>The C language stack growth does an implicit mremap. If you want absolute</div><div>guarantees and run close to the edge you MUST mmap your stack for the&nbsp;</div><div>largest size you think you will need. For typical stack usage this does</div><div>not matter much but it's a corner case if you really really care</div><div><br></div><div>In mode 2 the MAP_NORESERVE flag is ignored.&nbsp;</div><div><br></div><div><br></div><div>How It Works</div><div>------------</div><div><br></div><div>The overcommit is based on the following rules</div><div><br></div><div>For a file backed map</div><div>&nbsp; &nbsp; &nbsp; &nbsp; SHARED or READ-only &nbsp; &nbsp; - &nbsp; &nbsp; &nbsp; 0 cost (the file is the map not swap)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; PRIVATE WRITABLE &nbsp; &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp; size of mapping per instance</div><div><br></div><div>For an anonymous or /dev/zero map</div><div>&nbsp; &nbsp; &nbsp; &nbsp; SHARED &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp; size of mapping</div><div>&nbsp; &nbsp; &nbsp; &nbsp; PRIVATE READ-only &nbsp; &nbsp; &nbsp; - &nbsp; &nbsp; &nbsp; 0 cost (but of little use)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; PRIVATE WRITABLE &nbsp; &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp; size of mapping per instance</div><div><br></div><div>Additional accounting</div><div>&nbsp; &nbsp; &nbsp; &nbsp; Pages made writable copies by mmap</div><div>&nbsp; &nbsp; &nbsp; &nbsp; shmfs memory drawn from the same pool</div><div><br></div><div>Status</div><div>------</div><div><br></div><div>o &nbsp; &nbsp; &nbsp; We account mmap memory mappings</div><div>o &nbsp; &nbsp; &nbsp; We account mprotect changes in commit</div><div>o &nbsp; &nbsp; &nbsp; We account mremap changes in size</div><div>o &nbsp; &nbsp; &nbsp; We account brk</div><div>o &nbsp; &nbsp; &nbsp; We account munmap</div><div>o &nbsp; &nbsp; &nbsp; We report the commit status in /proc</div><div>o &nbsp; &nbsp; &nbsp; Account and check on fork</div><div>o &nbsp; &nbsp; &nbsp; Review stack handling/building on exec</div><div>o &nbsp; &nbsp; &nbsp; SHMfs accounting</div><div>o &nbsp; &nbsp; &nbsp; Implement actual limit enforcement</div><div><br></div><div>To Do</div><div>-----</div><div>o &nbsp; &nbsp; &nbsp; Account ptrace pages (this is hard)</div></div><div><br></div>
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"   ><img title="PostgreSQL database cannt startup because memory overcommit - 德哥@Digoal - PostgreSQL research"   src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"   alt="Flag Counter"   border="0"   ></a></div>
	</div>
</div>
</body>
</html>