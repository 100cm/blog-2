<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL Why psql -c "multi sql" only return the last sql result. but psql -f return all sql result</h2>
	<h5 id="">2014-03-26 17:48:20&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201422653927511/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>在使用psql时, 有-c和-f两种方式在命令行执行SQL.</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >man psql</font></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;-f filename, --file=filename</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Use the file filename as the source of commands instead of reading commands interactively. After the file</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;is processed, psql terminates. This is in many ways equivalent to the meta-command \i.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If filename is - (hyphen), then standard input is read.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Using this option is subtly different from writing psql &lt; filename. In general, both will do what you</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;expect, but using -f enables some nice features such as error messages with line numbers. There is also a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;slight chance that using this option will reduce the start-up overhead. On the other hand, the variant</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;using the shell's input redirection is (in theory) guaranteed to yield exactly the same output you would</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;have received had you entered everything by hand.</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp;-c command, --command=command</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Specifies that psql is to execute one command string, command, and then exit. This is useful in shell</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scripts. Start-up files (psqlrc and ~/.psqlrc) are ignored with this option.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;command must be either a command string that is completely parsable by the server (i.e., it contains no</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;psql-specific features), or a single backslash command. Thus you cannot mix SQL and psql meta-commands with</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this option. To achieve that, you could pipe the string into psql, for example: echo '\x \\ SELECT * FROM</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;foo;' | psql. (\\ is the separator meta-command.)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If the command string contains multiple SQL commands, they are processed in a single transaction, unless</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;there are explicit BEGIN/COMMIT commands included in the string to divide it into multiple transactions.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This is different from the behavior when the same string is fed to psql's standard input. Also, only the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result of the last SQL command is returned.</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Because of these legacy behaviors, putting more than one command in the -c string often has unexpected</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;results. It's better to feed multiple commands to psql's standard input, either using echo as illustrated</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;above, or via a shell here-document, for example:</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;psql &lt;&lt;EOF</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\x</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SELECT * FROM foo;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EOF</font></div></div><p></p></pre></div><div>但是实际使用时, 有一定的区别, 例如 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg93@db-172-16-3-150-&gt; psql -c "select 1;select 2;"</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 2</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>但是, 使用psql -f则可以看到两个返回. 如下 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >pg93@db-172-16-3-150-&gt; echo "select 1;select 2;"|psql -f -</font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 1</font></div><div><font size="2"   >(1 row)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp;?column?&nbsp;</font></div><div><font size="2"   >----------</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; 2</font></div><div><font size="2"   >(1 row)</font></div><p></p></pre></div><div>注意, 两种方式都会执行这两个查询, 只是-c只返回最后一条SQL的结果.</div><div><br></div><div>原因是psql -c直接把字符串提交给SendQuery.</div><div>psql -f 调用的是MainLoop, 分号将隔开这两句查询, 分两次递交给SendQuery, 看如下部分的解释.</div><div>SendQuery最后通过PQexecFinish把查询结果返回给客户端, 因为PQexecFinish这个函数只保存最后一个查询的结果, 所以使用psql -c我们只能看到最后一次调用的结果.</div><div><br></div>[参考]<wbr><div><div>1. psql 代码 :&nbsp;</div><div>-f 对应代码 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >src/bin/psql/startup.c</font></div><div><font size="2"   >process_file(options.action_string, options.single_txn, false)</font></div><div><font size="2"   ><br></font></div><div><div style="line-height: 28px;"   ><span style="line-height: 28px;"   ><font size="2"   >src/bin/psql/command.c</font></span></div><div style="line-height: 28px;"   ><font size="2"   >process_file</font></div><div style="line-height: 28px;"   ><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MainLoop(fd)</font></div></div><p></p></pre></div><div><br></div><div>-c 对应代码 :&nbsp;</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >src/bin/psql/startup.c</font></div><div><font size="2"   >SendQuery(options.action_string)</font></div><p></p></pre></div><div><br></div><div>2. psql -f通过MainLoop完成调用.</div><div>MainLoop中遇到分号则将当前的query_buf递交给SendQuery, 所以能返回多个结果.</div><div>src/bin/psql/mainloop.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >MainLoop(fd)</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Send command if semicolon found, or if end of line and we're in</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* single-line mode.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (scan_result == PSCAN_SEMICOLON ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (scan_result == PSCAN_EOL &amp;&amp; pset.singleline))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* execute query */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; success = SendQuery(query_buf-&gt;data);</font></div><p></p></pre></div><div><br></div><div>3. psql -c 直接使用SendQuery.</div><div>src/bin/psql/common.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* SendQuery: send the query string to the backend</font></div><div><font size="2"   >&nbsp;* (and print out results)</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note: This is the "front door" way to send a query. That is, use it to</font></div><div><font size="2"   >&nbsp;* send queries actually entered by the user. These queries will be subject to</font></div><div><font size="2"   >&nbsp;* single step mode.</font></div><div><font size="2"   >&nbsp;* To send "back door" queries (generated by slash commands, etc.) in a</font></div><div><font size="2"   >&nbsp;* controlled way, use PSQLexec().</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Returns true if the query executed successfully, false otherwise.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >bool</font></div><div><font size="2"   >SendQuery(const char *query)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >...</font></div><div><font size="2"   >results = PQexec(pset.db, query);</font></div><div><font size="2"   >...</font></div><p></p></pre></div><div><br></div><div><br></div><div>4.&nbsp;</div><div>src/interfaces/libpq/libpq-fe.h:</div><div>extern&nbsp;<span style="line-height: 28px;"   >PGresult *PQexec(PGconn *conn, const char *query);</span></div><div><br></div><div>5. psql用到的简单SQL调用. 由于历史原因, PQexecFinish只返回最后一个SQL的结果, 但是对错误则做合并处理.</div><div>src/interfaces/libpq/fe-exec.c</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* PQexec</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;send a query to the backend and package up the result in a PGresult</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* If the query was not even sent, return NULL; conn-&gt;errorMessage is set to</font></div><div><font size="2"   >&nbsp;* a relevant message.</font></div><div><font size="2"   >&nbsp;* If the query was sent, a new PGresult is returned (which could indicate</font></div><div><font size="2"   >&nbsp;* either success or failure).</font></div><div><font size="2"   >&nbsp;* The user is responsible for freeing the PGresult via PQclear()</font></div><div><font size="2"   >&nbsp;* when done with it.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >PGresult *</font></div><div><font size="2"   >PQexec(PGconn *conn, const char *query)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!PQexecStart(conn))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!PQsendQuery(conn, query))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return PQexecFinish(conn);</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* PQsendQuery</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; Submit a query, but don't wait for it to finish</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Returns: 1 if successfully submitted</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 if error (conn-&gt;errorMessage is set)</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >int</font></div><div><font size="2"   >PQsendQuery(PGconn *conn, const char *query)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!PQsendQueryStart(conn))</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* check the argument */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (!query)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printfPQExpBuffer(&amp;conn-&gt;errorMessage,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; libpq_gettext("command string is a null pointer\n"));</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* construct the outgoing Query message */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (pqPutMsgStart('Q', false, conn) &lt; 0 ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pqPuts(query, conn) &lt; 0 ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pqPutMsgEnd(conn) &lt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pqHandleSendFailure(conn);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* remember we are using simple query protocol */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; conn-&gt;queryclass = PGQUERY_SIMPLE;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* and remember the query text too, if possible */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* if insufficient memory, last_query just winds up NULL */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (conn-&gt;last_query)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(conn-&gt;last_query);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; conn-&gt;last_query = strdup(query);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Give the data a push. &nbsp;In nonblock mode, don't complain if we're unable</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* to send it all; PQgetResult() will do any additional flushing needed.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (pqFlush(conn) &lt; 0)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pqHandleSendFailure(conn);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* OK, it's launched! */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; conn-&gt;asyncStatus = PGASYNC_BUSY;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return 1;</font></div><div><font size="2"   >}</font></div><div><font size="2"   ><br></font></div><div><font size="2"   ><br></font></div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* Common code for PQexec and sibling routines: wait for command result</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >static PGresult *</font></div><div><font size="2"   >PQexecFinish(PGconn *conn)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PGresult &nbsp; *result;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PGresult &nbsp; *lastResult;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* For backwards compatibility, return the last result if there are more</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* than one --- but merge error messages if we get more than one error</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* result.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* We have to stop if we see copy in/out/both, however. We will resume</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* parsing after application performs the data transfer.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Also stop if the connection is lost (else we'll loop infinitely).</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; lastResult = NULL;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; while ((result = PQgetResult(conn)) != NULL)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (lastResult)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (lastResult-&gt;resultStatus == PGRES_FATAL_ERROR &amp;&amp;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;resultStatus == PGRES_FATAL_ERROR)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pqCatenateResultError(lastResult, result-&gt;errMsg);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQclear(result);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = lastResult;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Make sure PQerrorMessage agrees with concatenated result</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resetPQExpBuffer(&amp;conn-&gt;errorMessage);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendPQExpBufferStr(&amp;conn-&gt;errorMessage, result-&gt;errMsg);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQclear(lastResult);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastResult = result;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (result-&gt;resultStatus == PGRES_COPY_IN ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;resultStatus == PGRES_COPY_OUT ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;resultStatus == PGRES_COPY_BOTH ||</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conn-&gt;status == CONNECTION_BAD)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; return lastResult;</font></div><div><font size="2"   >}</font></div><p></p></pre></div><div><br></div><div>6. sql返回结果数据结构.</div><div>src/interfaces/libpq/libpq-int.h</div><div><pre class="prettyprint"   ><p></p><div><font size="2"   >struct pg_result</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntups;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numAttributes;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PGresAttDesc *attDescs;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PGresAttValue **tuples; &nbsp; &nbsp; &nbsp; &nbsp; /* each PGresTuple is an array of</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* PGresAttValue's */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupArrSize; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* allocated size of tuples array */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numParameters;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PGresParamDesc *paramDescs;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; ExecStatusType resultStatus;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmdStatus[CMDSTATUS_LEN]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* cmd status from the query */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binary; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* binary tuple values if binary == 1,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* otherwise text */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* These fields are copied from the originating PGconn, so that operations</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* on the PGresult don't have to reference the PGconn.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PGNoticeHooks noticeHooks;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PGEvent &nbsp; &nbsp;*events;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nEvents;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; client_encoding; &nbsp; &nbsp; &nbsp; &nbsp;/* encoding id */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Error information (all NULL if not an error result). &nbsp;errMsg is the</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* "overall" error message returned by PQresultErrorMessage. &nbsp;If we have</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* per-field info then it is stored in a linked list.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; *errMsg; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* error message, or NULL if no error */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PGMessageField *errFields; &nbsp; &nbsp; &nbsp;/* message broken into fields */</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /* All NULL attributes in the query result point to this null string */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;null_field[1];</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Space management information. &nbsp;Note that attDescs and error stuff, if</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* not null, point into allocated blocks. &nbsp;But tuples points to a</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* separately malloc'd block, so that we can realloc it.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; PGresult_data *curBlock; &nbsp; &nbsp; &nbsp; &nbsp;/* most recently allocated block */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curOffset; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* start offset of free space in block */</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spaceLeft; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* number of free bytes remaining in block */</font></div><div><font size="2"   >};</font></div><p></p></pre></div></div></div>
	</div>
</div>
</body>
</html>