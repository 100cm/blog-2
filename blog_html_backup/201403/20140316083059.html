<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL nestloop loop cost & cost_material run_cost</h2>
	<h5 id="">2014-03-16 8:30:59&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201421682357913/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>Nested Loop循环计算总成本时, 一般来说inner 节点循环多少次, 就要乘以多少次的inner 节点的total_cost.&nbsp;</div><div>例如这个例子 :&nbsp;</div><div><pre style=" box-shadow: rgb(223, 223, 223) 3px 3px 5px; margin-bottom: 2ex; border-bottom-right-radius: 8px; background-color: rgb(247, 247, 247); border-top-left-radius: 8px; line-height: normal; border-bottom-left-radius: 8px; overflow: auto; border: 1px solid rgb(207, 207, 207); -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px;font-size: 12px; margin-top: 2ex; border-top-right-radius: 8px; margin-left: 2ex; padding: 2ex;"   >EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;

                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Nested Loop  (cost=4.65..118.62 rows=10 width=488)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244)
         Recheck Cond: (unique1 &lt; 10)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.91 rows=1 width=244)
         Index Cond: (unique2 = t1.unique2)</pre></div><div>Nested Loop节点的118.62 = 39.47+10*7.91 + 一部分输出成本.</div><div><br></div><div>但是下面这个例子, 你看看如果这样算的话, 输出成本就不合理了.</div><div><span style="line-height: 18px; font-size: 12px; font-family: verdana, sans-serif;"   >In this example the join's output row count is the same as the product of the two scans' row counts, but that's not true in all cases because there can be additional&nbsp;</span><tt style="font-size: 12px;"   >WHERE</tt><span style="line-height: 18px; font-size: 12px; font-family: verdana, sans-serif;"   >&nbsp;</span><span style="line-height: 18px; font-size: 12px; font-family: verdana, sans-serif;"   >clauses that mention both tables and so can only be applied at the join point, not to either input scan. Here's an example:</span></div><div><pre style=" box-shadow: rgb(223, 223, 223) 3px 3px 5px; margin-bottom: 2ex; border-bottom-right-radius: 8px; background-color: rgb(247, 247, 247); border-top-left-radius: 8px; line-height: normal; border-bottom-left-radius: 8px; overflow: auto; border: 1px solid rgb(207, 207, 207); -webkit-box-shadow: rgb(223, 223, 223) 3px 3px 5px;font-size: 12px; margin-top: 2ex; border-top-right-radius: 8px; margin-left: 2ex; padding: 2ex;"   >EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t2.unique2 &lt; 10 AND t1.hundred &lt; t2.hundred;

                                         QUERY PLAN
---------------------------------------------------------------------------------------------
 Nested Loop  (cost=4.65..49.46 rows=33 width=488)
   Join Filter: (t1.hundred &lt; t2.hundred)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244)
         Recheck Cond: (unique1 &lt; 10)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Materialize  (cost=0.29..8.51 rows=10 width=244)
         -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..8.46 rows=10 width=244)
               Index Cond: (unique2 &lt; 10)
</pre><p style="font-size: 12px; margin: 1.2em 0em; font-family: verdana, sans-serif; line-height: 1.5em;"   >The condition&nbsp;<tt>t1.hundred &lt; t2.hundred</tt>&nbsp;can't be tested in the&nbsp;<tt>tenk2_unique2</tt>&nbsp;index, so it's applied at the join node. This reduces the estimated output row count of the join node, but does not change either input scan.</p><p style="font-size: 12px; margin: 1.2em 0em; font-family: verdana, sans-serif; line-height: 1.5em;"   >Notice that here the planner has chosen to&nbsp;<span>"materialize"</span>&nbsp;the inner relation of the join, by putting a Materialize plan node atop it. This means that the&nbsp;<tt>t2</tt>&nbsp;indexscan will be done just once, even though the nested-loop join node needs to read that data ten times, once for each row from the outer relation. The Materialize node saves the data in memory as it's read, and then returns the data from memory on each subsequent pass.</p></div><div>这个materialized节点表明, 索引扫描一次后, 如果work_mem可以放下这个物化节点的数据, 那么这部分数据都在内存中. 如果不能放下, 那么会用到一部分磁盘. 这里循环用到的是物化节点的run_cost. 代码如下 :&nbsp;</div><div>src/backend/optimizer/path/costsize.c</div><div><pre class="prettyprint"   ><p></p><div><div><font size="2"   >/*</font></div><div><font size="2"   >&nbsp;* cost_material</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;Determines and returns the cost of materializing a relation, including</font></div><div><font size="2"   >&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp;the cost of reading the input data.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* If the total volume of data to materialize exceeds work_mem, we will need</font></div><div><font size="2"   >&nbsp;* to write it to disk, so the cost is much higher in that case.</font></div><div><font size="2"   >&nbsp;*</font></div><div><font size="2"   >&nbsp;* Note that here we are estimating the costs for the first scan of the</font></div><div><font size="2"   >&nbsp;* relation, so the materialization is all overhead --- any savings will</font></div><div><font size="2"   >&nbsp;* occur only on rescan, which is estimated in cost_rescan.</font></div><div><font size="2"   >&nbsp;*/</font></div><div><font size="2"   >void</font></div><div><font size="2"   >cost_material(Path *path,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cost input_startup_cost, Cost input_total_cost,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; double tuples, int width)</font></div><div><font size="2"   >{</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Cost &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;startup_cost = input_startup_cost;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; Cost &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;run_cost = input_total_cost - input_startup_cost;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nbytes = relation_byte_size(tuples, width);</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; long &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;work_mem_bytes = work_mem * 1024L;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;rows = tuples;</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Whether spilling or not, charge 2x cpu_operator_cost per tuple to</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* reflect bookkeeping overhead. &nbsp;(This rate must be more than what</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* cost_rescan charges for materialize, ie, cpu_operator_cost per tuple;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* if it is exactly the same then there will be a cost tie between</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* nestloop with A outer, materialized B inner and nestloop with B outer,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* materialized A inner. &nbsp;The extra cost ensures we'll prefer</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* materializing the smaller rel.) &nbsp; &nbsp; &nbsp;Note that this is normally a good deal</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* less than cpu_tuple_cost; which is OK because a Material plan node</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* doesn't do qual-checking or projection, so it's got less overhead than</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* most plan nodes.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; run_cost += 2 * cpu_operator_cost * tuples;</font></div></div><div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; /*</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* If we will spill to disk, charge at the rate of seq_page_cost per page.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* This cost is assumed to be evenly spread through the plan run phase,</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* which isn't exactly accurate but our cost model doesn't allow for</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* nonuniform costs within the run phase.</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; if (nbytes &gt; work_mem_bytes)</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; {</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; double &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;npages = ceil(nbytes / BLCKSZ);</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; run_cost += seq_page_cost * npages;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; }</font></div><div><font size="2"   ><br></font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;startup_cost = startup_cost;</font></div><div><font size="2"   >&nbsp; &nbsp; &nbsp; &nbsp; path-&gt;total_cost = startup_cost + run_cost;</font></div><div><font size="2"   >}</font></div></div><p></p></pre></div><div>那么循环十次的话, 每次循环实际上只用到了<span style="line-height: 28px;"   >2 * cpu_operator_cost * tuples;这部分开销.</span></div><div><span style="line-height: 28px;"   >2*</span>0.0025*10=0.05</div><div>所以Nested Loop节点的总开销 49.46 =&nbsp;<span style="line-height: 28px;"   >39.47+0.5+8.46+ 一部分输出开销.</span></div><div><span style="line-height: 28px;"   ><br></span></div></div>
	</div>
</div>
</body>
</html>