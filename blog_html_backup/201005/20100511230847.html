<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">MongoDB Introduction</h2>
	<h5 id="">2010-05-11 23:08:47&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201041111847788/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><p style="text-indent: 2em;"  >开始学习MongoDB。先大概的介绍一下.</p> <p style="text-indent: 2em;"  >&nbsp; MongoDB 继承了文档型数据库，键值数据库，关系型数据库的优点。拥有键值数据库的高效、高扩展性，关系数据库的丰富查询功能和广泛的其他功能。MongoDB数据库是C++写的可扩展的，高性能的，开源的，文档型的数据库。</p> <p style="text-indent: 2em;"  >&nbsp; MongoDB特性：</p> <p style="text-indent: 2em;"  >&nbsp; 1. 文档导向的存储，<a rel="nofollow" href="http://bsonspec.org/"  >JSON-style documents</a>&nbsp;with dynamic schemas offer simplicity and power.</p> <p style="text-indent: 2em;"  >With Mongo, you do less “normalization” than you would perform designing a relational schema because there are no server-side “joins”. Generally, you will want one database collection for each of your top level objects.</p> <p style="text-indent: 2em;"  >&nbsp; 2.全索引支持，Index on any attribute, just like you’re used to.</p> <p style="text-indent: 2em;"  >Indexes enhance query performance, often dramatically. It’s important to think about the kinds of queries your application will need so that you can define relevant indexes. Once that’s done, actually creating the indexes in MongoDB is relatively easy.</p> <p style="text-indent: 2em;"  >Indexes in MongoDB are conceptually similar to those in RDBMSes like MySQL. You will want an index in MongoDB in the same sort of situations where you would have wanted an index in MySQL.</p> <p style="text-indent: 2em;"  >&nbsp; 3.复制与高可用，Mirror across LANs and WANs for scale and peace of mind.</p> <p style="text-indent: 2em;"  >MongoDB supports replication of data between servers for failover and redundancy.</p> <p style="text-indent: 2em;"  >MongoDB replication is an enhanced form of master-slave configuration: that is, only one server is active for writes (the master) at a given time. With a single active master at any point in time, we can achieve strong consistency semantics. One can also optionally run queries on the slaves when&nbsp;<a rel="nofollow" href="http://blog.mongodb.org/post/498145601/on-distributed-consistency-part-2-some-eventual"  >eventually consistent</a>&nbsp;read behavior is acceptable.</p> <p style="text-indent: 2em;"  >&nbsp; 4.自动共享，Scale horizontally without compromising functionality.</p> <p style="text-indent: 2em;"  >MongoDB has been designed to scale horizontally via an auto-sharding architecture. Auto-sharding permits the development of large-scale data clusters that incorporate additional machines dynamically, automatically accomodate changes in load and data distribution, and ensure automated failover.</p> <p style="text-indent: 2em;"  >MongoDB supports an automated sharding architecture, enabling horizontal scaling across multiple nodes. For applications that outgrow the resources of a single database server, MongoDB can convert to a sharded cluster, automatically managing failover and balancing of nodes, with few or no changes to the original application code.</p> <p style="text-indent: 2em;"  >&nbsp;&nbsp; 5.查询，Rich, document-based queries.</p> <p style="text-indent: 2em;"  >One of MongoDB’s best capabilities is its support for dynamic (ad hoc) queries. Systems that support dynamic queries don’t require any special indexing to find data; users can find data using any criteria. For relational databases, dynamic queries are the norm. If you’re moving to MongoDB from a relational databases, you’ll find that many SQL queries translate easily to MongoDB’s document-based query language.</p> <p style="text-indent: 2em;"  >&nbsp;&nbsp;&nbsp; 6.快速in-place update，Atomic modifiers for contention-free performance.</p> <p style="text-indent: 2em;"  >MongoDB supports atomic, in-place updates as well as more traditional updates for replacing an entire document.</p> <p style="text-indent: 2em;"  >&nbsp;&nbsp;&nbsp; 7.MAP/REDUCE ，Flexible aggregation and data processing</p> <p style="text-indent: 2em;"  >Map/reduce in MongoDB is useful for batch manipulation of data and aggregation operations. It is similar in spirit to using something like Hadoop with all input coming from a collection and output going to a collection. Often, in a situation where you would have used GROUP BY in SQL, map/reduce is the right tool in MongoDB.</p> <p style="text-indent: 2em;"  >Notes:</p> <p style="text-indent: 2em;"  >Indexing and standard queries in MongoDB are separate from map/reduce. If you have used CouchDB in the past, note this is a big difference: MongoDB is more like MySQL for basic querying and indexing. See the<a rel="nofollow" href="http://www.mongodb.org/display/DOCS/Advanced+Queries"  >queries</a>&nbsp;and&nbsp;<a rel="nofollow" href="http://www.mongodb.org/display/DOCS/Indexes"  >indexing</a>&nbsp;documentation for those operations.</p> <p style="text-indent: 2em;"  >&nbsp;&nbsp;&nbsp; 8.GridFS，Store files of any size without complicating your stack.</p> <p style="text-indent: 2em;"  >GridFS is a storage specification for large objects in MongoDB. It works by splitting large object into small chunks, usually 256k in size. Each chunk is stored as a separate document in a&nbsp;<tt>chunks</tt>&nbsp;collection. Metadata about the file, including the filename, content type, and any optional information needed by the developer, is stored as a document in a&nbsp;<tt>files</tt>&nbsp;collection.</p> <p style="text-indent: 2em;"  >So for any given file stored using GridFS, there will exist one document in&nbsp;<tt>files</tt>&nbsp;collection and one or more documents in the&nbsp;<tt>chunks</tt>&nbsp;collection.</p> <p style="text-indent: 2em;"  >GridFS uses two collections to store data:  </p><ul> <li><tt>files</tt>&nbsp;contains the object metadata</li> <li><tt>chunks</tt>&nbsp;contains the binary chunks with some additional accounting information</li></ul> <p></p> <p style="text-indent: 2em;"  >In order to make more than one GridFS namespace possible for a single database, the files and chunks collections are named with a prefix. By default the prefix is&nbsp;<tt>fs.</tt>, so any default GridFS store will consist of collections named&nbsp;<tt>fs.files</tt>&nbsp;and&nbsp;<tt>fs.chunks</tt>. The drivers make it possible to change this prefix, so you might, for instance, have another GridFS namespace specifically for photos where the collections would be<tt>photos.files</tt>&nbsp;and&nbsp;<tt>photos.chunks</tt>.</p></div>
	</div>
</div>
</body>
</html>