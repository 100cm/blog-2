<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">数据库与企业非易失电子盘</h2>
	<h5 id="">2010-05-11 23:11:45&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402010411111145651/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><P style="TEXT-INDENT: 2em;"  >一个OLTP系统最可能出现瓶颈的地方是随机型的IO。</P>  <P style="TEXT-INDENT: 2em;"  >优化手段当然有很多，如加数据库端的缓存，应用端的缓存，存储端的CACHE，降低读的IO。</P>  <P style="TEXT-INDENT: 2em;"  >写的IO的话估计没那么容易解决。通常的做法是增加硬盘，细化表空间，细化对象与表空间的关系，存储的话也可以提高盘阵的CACHE（需要配置write-back模式）。</P>  <P style="TEXT-INDENT: 2em;"  >随着电子盘的出现，随机型的IO能力提高成为可能。为啥这么说呢，电子盘没有机械手臂，没有了机械手臂的移动延时和拾取延时。</P>  <P style="TEXT-INDENT: 2em;"  >当然电子盘也离不开CACHE，CACHE永远是最快的。</P>  <P style="TEXT-INDENT: 2em;"  >下面是一个老外对SSD和数据库应用场景的描述：</P>  <P style="TEXT-INDENT: 2em;"  ><A rel="nofollow" href="http://en.wikipedia.org/wiki/Solid-state_drive"  >Solid-state drives</A>&nbsp;(SSD) are getting&nbsp;<A rel="nofollow" href="http://www.pcauthority.com.au/News/172014,ocz-combines-monstrous-capacity-with-a-monstrous-pricetag-for-new-ssds.aspx"  >larger</A>&nbsp;and more popular. Initially, SSDs appeared to be ideal for databases because they potentially allow fast I/O with non-volatile storage ― unfortunately, neither of these is completely true. Let me explain:</P>  <P style="TEXT-INDENT: 2em;"  >Fast I/O: While SSDs offer random I/O speeds far in excess of traditional hard drives (because there are no moving platters or heads), the sequential I/O speed of SSDs is only marginally better than mechanical drives. Database activity that causes random I/O, like index scans that do not fit in RAM, will benefit from SSDs’ superior random I/O speeds, but sequential scans only marginally benefit by using SSDs. (Greg Smith explains the limited use-case for SSDs in this&nbsp;<A rel="nofollow" href="http://archives.postgresql.org/pgsql-performance/2009-11/msg00151.php"  >email</A>.) Postgres 9.0 will allow&nbsp;<A rel="nofollow" href="http://developer.postgresql.org/pgdocs/postgres/runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS"  >random page cost</A>&nbsp;to be set&nbsp;<A rel="nofollow" href="http://developer.postgresql.org/pgdocs/postgres/sql-altertablespace.html"  >per tablespace</A>&nbsp;so administrators can indicate that random I/O has the same speed as sequential I/O for SSD-based tablespaces.</P>  <P style="TEXT-INDENT: 2em;"  >Non-Volatile Storage: Because SSDs offer permanent storage, it is often believed that they are an ideal place to store the Postgres&nbsp;<A rel="nofollow" href="http://developer.postgresql.org/pgdocs/postgres/wal-intro.html"  >Write-Ahead Logs</A>&nbsp;(WAL) which are&nbsp;<A rel="nofollow" href="http://developer.postgresql.org/pgdocs/postgres/wal-reliability.html"  >flushed to disk</A>&nbsp;on every transaction commit. However, SSDs typically write data in 256 kilobyte chunks, meaning the small write operations that occur at every commit are not ideal for SSD drives, and might not even be flushed to permanent storage immediately. (Many SSD vendors have been vague about this behavior.) (FYI,&nbsp;<A rel="nofollow" href="http://www.fusionio.com/products/"  >Fusion-io</A>&nbsp;drives are getting good reviews.) This&nbsp;<A rel="nofollow" href="http://research.microsoft.com/pubs/63596/USENIX-08-SSD.pdf"  >paper</A>&nbsp;explains the internal workings of SSD drives, and the article summary contains this warning:</P>  <P style="TEXT-INDENT: 2em;"  >&nbsp;We find that SSD performance and lifetime is highly workload-sensitive, and that complex systems problems that normally appear higher in the storage stack, or even in distributed systems, are relevant to device firmware.</P>  <P style="TEXT-INDENT: 2em;"  >&nbsp;反驳方:</P>  <P style="TEXT-INDENT: 2em;"  >&gt;&gt; the sequential I/O speed of SSDs is only marginally better than mechanical drives. … sequential scans only marginally benefit by using SSDs. &nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >Not even remotely true, even for retail level drives. Visit&nbsp;<A rel="nofollow" href="http://www.storagesearch.com/"  >http://www.storagesearch.com/</A>&nbsp;for theory and practice of SSD design and history. Visit<A rel="nofollow" href="http://www.anandtech.com/tag/storage"  >http://www.anandtech.com/tag/storage</A>&nbsp;for current drives and tests, for example:&nbsp;<A rel="nofollow" href="http://www.anandtech.com/show/2944/9"  >http://www.anandtech.com/show/2944/9</A>&nbsp;. Note the sequential speeds of SSDs versus the HDDs (fastest retail available). Enterprise drives (STEC, Violin, Texas Memory) aren’t as widely reviewed, since these parts are “qualified” to OEMs. They rip. &nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >&gt;&gt; SSDs typically write data in 256 kilobyte chunks, meaning the small write operations that occur at every commit are not ideal for SSD drives, and might not even be flushed to permanent storage immediately. &nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >Not really an issue. The 256K assumes that each write does a block erase for each write; controllers aren’t that naive’. The write size on the NAND isn’t the issue, beyond the factor of sector (512) writes vs. block (4K) writes. Controllers parse out the writes as they see fit. The SandForce controller even does deduping and compression on the fly; not everyone is thrilled with this, by the way. See:&nbsp;<A rel="nofollow" href="http://www.storagesearch.com/ram-in-flash-ssd.html"  >http://www.storagesearch.com/ram-in-flash-ssd.html</A>&nbsp;. The paper cited is quite dated; controllers today are far more sophisticated than what was current in 2007. Server/enterprise drives are/can be heavily cached (see link above), so that the size of the write from the OS is not relevant. Even retail level drives can be (those aimed at laptops and such aren’t). &nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >What has been ignored is the real strength of SSD with databases: implementing BCNF schemas. The strength of SSD is that supports the redundancy elimination of the relational model as joins are costless. As just a faster HDD, not so much; volumetric density of NAND will never reach areal density of rotating rust. It needs to stressed that what is viewed as a sequential operation at the application/OS level is not guaranteed to be into contiguous locations on the NAND, as it is on rotating rust. The probability is virtually zero.</P>  <P style="TEXT-INDENT: 2em;"  >In summary, SSD drives are not the panacea we hoped, or at least, not yet. A battery-backed disk drive controller is still the ideal solution for high performance at a reasonable cost. This Postgres email thread from&nbsp;<A rel="nofollow" href="http://archives.postgresql.org/pgsql-performance/2009-11/msg00132.php"  >November</A>and&nbsp;<A rel="nofollow" href="http://archives.postgresql.org/pgsql-performance/2009-12/msg00039.php"  >December</A>&nbsp;covers many of these details</P>  <P style="TEXT-INDENT: 2em;"  >Just for grins, and because it’s timely (published today), here’s the latest AnandTech SSD review:&nbsp;<A rel="nofollow" href="http://www.anandtech.com/show/3656/corsairs-force-ssd-reviewed-sf1200-is-very-good"  >http://www.anandtech.com/show/3656/corsairs-force-ssd-reviewed-sf1200-is-very-good</A>&nbsp;.&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >What’s important about this review:&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >- it’s for a SandForce 1200 controller, which is intended to be SF’s vanilla retail controller&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >- it’s really fast&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >- it uses no external DRAM cache, which is material to design decisions about how to build an SSD, which makes SF based SSD materially different from all others, retail or “enterprise”&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >- one can see the playing field of most retail SSD and top notch retail HDD in the tables&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >&nbsp;</P>  <P style="TEXT-INDENT: 2em;"  >SSD are not yet commodity parts, unlike HDD. Evolution continues; hopefully so will decisions about how best to utilize them in RDBMS.</P>  <P style="TEXT-INDENT: 2em;"  >到底有多大的提升，用了才知道。</P>  <P style="TEXT-INDENT: 2em;"  >就像某些存储厂商提供的数据一样，理论值大得惊人，用起来实际上达不到那么大的IOPS。</P></div>
	</div>
</div>
</body>
</html>