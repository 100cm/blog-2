<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">手工修改linux进程的CPU调度</h2>
	<h5 id="">2010-05-11 23:37:17&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/1638770402010411113717972/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><P style="TEXT-INDENT: 2em;"  >现在多核的CPU已经相当普遍了，那么这种多核的服务器如何让CPU得到充分利用，可以靠应用自己来定义，或者依赖操作系统来调度。根据红帽的说法RHEL5有一个很强壮的CPU调度机制，RHEL6就更强壮了，所以看起来跑在LINUX下面的应用应该都不用去管该用哪个CPU。</P>  <P style="TEXT-INDENT: 2em;"  >首先我们来看看CPU中断请求的统计:</P>  <P style="TEXT-INDENT: 2em;"  >CentOS release 5.2 (Final)</P>  <P style="TEXT-INDENT: 2em;"  ><A rel="nofollow" href="http://dba.sky-mobi.com/wp-content/uploads/2010/05/interupt.jpg"  ></A></P>  <P style="TEXT-INDENT: 2em;"  ><A target="_blank" href="http://img610.ph.126.net/d6IIED1YV5UfCG6lwrJKIw==/1685753635521577507.jpg" ><IMG title="手工修改linux进程的CPU调度 - 德哥(DiGoal,Just Do It!) - Not Only DBA"  alt="手工修改linux进程的CPU调度 - 德哥(DiGoal,Just Do It!) - Not Only DBA"  src="http://img610.ph.126.net/d6IIED1YV5UfCG6lwrJKIw==/1685753635521577507.jpg"  ></A></P>  <P style="TEXT-INDENT: 2em;"  >从图上看，CPU的使用基本上还是均匀的。不过CPU0负载还是最大的。</P>  <P style="TEXT-INDENT: 2em;"  >所有在某种情况下可能会需要手工来设置进程使用CPU核的优先级。</P>  <P style="TEXT-INDENT: 2em;"  >下面是一个操作的例子：</P>  <P style="TEXT-INDENT: 2em;"  >postgres &nbsp;6457 &nbsp; &nbsp; 1 &nbsp;0 May05 ? &nbsp; &nbsp; &nbsp; &nbsp;00:00:00 /app/pgsql/bin/postgres -D /database/pgdata -p 1921</P>  <P style="TEXT-INDENT: 2em;"  >[root@develop1 ~]# taskset -pc 6457</P>  <P style="TEXT-INDENT: 2em;"  >pid 6457’s current affinity list: 0-3</P>  <P style="TEXT-INDENT: 2em;"  >这个进程目前是默认与0-3 这4个核心亲和的。也就是说会在0-3这几个核心调度。</P>  <P style="TEXT-INDENT: 2em;"  >[root@develop1 ~]# taskset -pc 0-1 6457</P>  <P style="TEXT-INDENT: 2em;"  >pid 6457’s current affinity list: 0-3</P>  <P style="TEXT-INDENT: 2em;"  >pid 6457’s new affinity list: 0,1</P>  <P style="TEXT-INDENT: 2em;"  >修改之后我们看到，已经修改为0，1的范围了。</P>  <P style="TEXT-INDENT: 2em;"  >可以通过top -p 6457 [f -&gt; j]</P>  <P style="TEXT-INDENT: 2em;"  >查看P列可以看到当前运行的核心号。</P>  <P style="TEXT-INDENT: 2em;"  >如果该成在单个CORE上跑的话，马上就能看到CORE的变化。</P>  <P style="TEXT-INDENT: 2em;"  >下面是taskset的MAN PAGE：</P>  <P style="TEXT-INDENT: 2em;"  >从描述上来看的话，只要taskset返回结果了，那LINUX肯定是确保得到了你想要的结果。</P>  <P style="TEXT-INDENT: 2em;"  >DESCRIPTION</P>  <P style="TEXT-INDENT: 2em;"  >taskset &nbsp;is used to set or retrieve the CPU affinity of a running process given its PID or to launch a new COM-</P>  <P style="TEXT-INDENT: 2em;"  >MAND with a given CPU affinity. &nbsp;CPU affinity is a scheduler property that “bonds” a process to a given set &nbsp;of</P>  <P style="TEXT-INDENT: 2em;"  >CPUs &nbsp;on the system. &nbsp;The Linux scheduler will honor the given CPU affinity and the process will not run on any</P>  <P style="TEXT-INDENT: 2em;"  >other CPUs. &nbsp;Note that the Linux scheduler also supports natural CPU affinity: the scheduler attempts &nbsp;to &nbsp;keep</P>  <P style="TEXT-INDENT: 2em;"  >processes &nbsp;on &nbsp;the &nbsp;same &nbsp;CPU &nbsp;as long as practical for performance reasons. &nbsp;Therefore, forcing a specific CPU</P>  <P style="TEXT-INDENT: 2em;"  >affinity is useful only in certain applications.</P>  <P style="TEXT-INDENT: 2em;"  >The CPU affinity is represented as a bitmask, with the lowest order bit corresponding to the first logical &nbsp;CPU</P>  <P style="TEXT-INDENT: 2em;"  >and &nbsp;the highest order bit corresponding to the last logical CPU. &nbsp;Not all CPUs may exist on a given system but</P>  <P style="TEXT-INDENT: 2em;"  >a mask may specify more CPUs than are present. &nbsp;A retrieved mask will reflect only the bits that correspond &nbsp;to</P>  <P style="TEXT-INDENT: 2em;"  >CPUs physically on the system. &nbsp;If an invalid mask is given (i.e., one that corresponds to no valid CPUs on the</P>  <P style="TEXT-INDENT: 2em;"  >current system) an error is returned. &nbsp;The masks are typically given in hexadecimal. &nbsp;For example,</P>  <P style="TEXT-INDENT: 2em;"  >0×00000001</P>  <P style="TEXT-INDENT: 2em;"  >is processor #0</P>  <P style="TEXT-INDENT: 2em;"  >0×00000003</P>  <P style="TEXT-INDENT: 2em;"  >is processors #0 and #1</P>  <P style="TEXT-INDENT: 2em;"  >0xFFFFFFFF</P>  <P style="TEXT-INDENT: 2em;"  >is all processors (#0 through #31)</P>  <P style="TEXT-INDENT: 2em;"  >When taskset returns, it is guaranteed that the given program has been scheduled to a legal CPU.</P></div>
	</div>
</div>
</body>
</html>