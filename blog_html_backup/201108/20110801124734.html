<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">Thinking PostgreSQL's Column Compress</h2>
	<h5 id="">2011-08-01 12:47:34&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/16387704020117195749135/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>&nbsp; 今天我同事给了我一份表结构的数据，其中涉及到几个字段如下</div><div><div>&nbsp; create_time character varying(14) not null, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --创建时间</div><div>&nbsp; modify_time character varying(14) not null, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --修改时间</div></div><div>&nbsp; 这里用到了varchar来存储时间的值，后来下面从效率，存储的信息量，耗费的字节数，使用的便捷性几个方面来比较一下VARCHAR和timestamp without time zone在这个场景的应用。</div><div>&nbsp; 1. 信息量:</div><div>&nbsp; varchar(14) 存的信息 yyyymmddhh24miss 精确到秒。</div><div>&nbsp; timestamp without time zone 存的信息 yyyymmddhh24miss.ssssss 精确到百万分之一秒.</div><div>&nbsp; 2. 耗费的字节数</div><div>digoal=&gt; create table tbl_test(col1 character varying(14),col2 timestamp without time zone);</div><div>CREATE TABLE</div><div><div>digoal=&gt; insert into tbl_test values ('20110801091904',clock_timestamp());</div><div>INSERT 0 1</div></div><div><div>digoal=&gt; select pg_column_size(col1),pg_column_size(col2) from tbl_test ;</div><div>&nbsp;pg_column_size | pg_column_size&nbsp;</div><div>----------------+----------------</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;15 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8</div><div>(1 row)</div></div><div>varchar(14) 耗费15字节</div><div>timestamp without time zone 耗费8字节</div><div>&nbsp; 3. 写入效率</div><div>分别插入100万记录，从执行时间上来比较一下效率。</div><div>为了保持数据更加有说服力，我们这里都采用应用端生成的时间值来插入。而不使用now()或者其他的数据库函数来生成时间数据。</div><div><div>digoal=&gt; create table tbl_test (id int,crt_time varchar(14));</div><div>CREATE TABLE</div></div><div><div>digoal=&gt; insert into tbl_test select generate_series(1,1000000),'20110801100731';</div><div>INSERT 0 1000000</div><div>Time: 1608.014 ms</div></div><div><div>digoal=&gt; create table tbl_test (id int,crt_time timestamp without time zone);</div><div>CREATE TABLE</div></div><div><div><div>digoal=&gt; insert into tbl_test select generate_series(1,1000000),'2011-08-01 10:07:31'::timestamp without time zone;</div><div>INSERT 0 1000000</div><div>Time: 1421.685 ms</div></div></div><div>timestamp without time zone 耗费的时间 小于 varchar(14)耗费的时间。说明timestamp without time zone 效率高一点点。</div><div><br></div><div>如果是使用数据库的时间，比如now(),clock_timestamp()来生成时间。效率又如何？</div><div><div><div>digoal=&gt; create table tbl_test (id int,crt_time varchar(14));</div><div>CREATE TABLE</div><div>digoal=&gt; insert into tbl_test select generate_series(1,1000000),to_char(now(),'yyyymmddhh24miss');</div><div>INSERT 0 1000000</div><div>Time: 4370.596 ms</div></div><div>digoal=&gt; create table tbl_test (id int,crt_time timestamp without time zone);</div><div>CREATE TABLE</div></div><div><div>digoal=&gt; insert into tbl_test select generate_series(1,1000000),now();</div><div>INSERT 0 1000000</div><div>Time: 1895.120 ms</div></div><div>采用varchar类型，时间比原来多了一倍多，</div><div>采用timestamp without time zone 时间比原来多了约30%。</div><div>&nbsp; 4. 使用的便捷性</div><div>首先是索引，如果要进行时间上的比较，VARCHAR类型不得不使用函数索引。</div><div>然后是时间字段可以使用丰富的函数。</div><div><br></div><div>前面好像扯了一些和这篇BLOG不太相关的话题，其实看第二点和第三点就有一点点关系了。</div><div>&nbsp; 我们来把环境再延伸到操作系统层和住几层，假设服务器的内存是12GB。</div><div>&nbsp; 表一和表二存储的信息一致。用varchar存储时间的表15GB，用timestamp without time zone存储时间的表8GB。</div><div>&nbsp; 假设有一半的是活跃数据，那么varchar存储时间的表,文件系统CACHE可能用掉7.5GB；</div><div>&nbsp; &nbsp;而用timestamp without time zone存储时间的表,文件系统CACHE可能用掉4GB。</div><div>&nbsp; 没错，说明数据库的压缩技术是很重要的，特别是CPU资源很富裕,但是内存很紧缺的情况下。</div><div><br></div><div>&nbsp; 之前写过一篇关于PostgreSQL TOAST的博客,也是关于数据压缩的,如下,</div><div><a href="http://blog.163.com/digoal@126/blog/static/163877040201122910531988/"  >http://blog.163.com/digoal@126/blog/static/163877040201122910531988/</a></div><div>&nbsp; 有些重复的东西就不谈了，大家可以参考上面这篇BLOG。</div><div><br></div><div>接下来浮想联翩或者泛泛而谈一下（其实优点类似数据集得加密解密）:</div><div>1. 数<font size="3"  >据库端压缩</font></div><div><font size="3"  >优点，标准统一</font></div><div><font size="3"  >缺点，耗费数据库CPU，传输RAW数据</font></div><div><font size="3"  >2. 数据库驱动层压缩</font></div><div><font size="3"  >优点，不占用数据库CPU，传输压缩后的数据</font></div><div><font size="3"  >缺点，标准不容易统一，</font></div><div><font size="3"  >3. 客户端压缩</font></div><div><div style="line-height: 22px;"  ><font size="3"  style="line-height: 25px;"  >优点，不占用数据库CPU，传输压缩后的数据</font></div><div style="line-height: 22px;"  ><font size="3"  style="line-height: 25px;"  >缺点，标准不容易统一，</font></div></div><div><font size="3"  >4. 网络传输层压缩</font></div><div><font size="3"  >优点，传输压缩后的数据，</font></div><div><font size="3"  ><span style="line-height: 25px;"  >缺点，数据库存储RAW数据，</span></font></div><div><span style="line-height: 25px; font-size: medium;"  >另外，压缩和解压缩不一定要在同一端完成，如可以在数据库端压缩，但是在驱动端解压。等等</span></div><div><font size="3"  ><br></font></div><div><div style="line-height: 22px;"  ><font size="3"  >最后来测试一下Oracle 11G R2和PostgreSQL9.1 beta2在数据压缩方面的技术。</font></div></div><div style="line-height: 22px;"  ><font size="3"  >为了做到尽量公正,</font></div><div style="line-height: 22px;"  ><font size="3"  >Oracle fctfree=0</font></div><div style="line-height: 22px;"  ><font size="3"  >PostgreSQL&nbsp;<span style="font-family: monospace; line-height: normal;"  >fillfactor=100</span></font></div><div style="line-height: 22px;"  ><span style="font-family: monospace; line-height: normal;"  ><font size="3"  ><br></font></span></div><div style="line-height: 22px;"  ><span style="font-family: monospace; line-height: normal;"  ><font size="3"  >以下测试content插入704个字符.</font></span></div><div style="line-height: 22px;"  ><span style="font-family: monospace; line-height: normal;"  ><font size="3"  >先来看看Oracle</font></span></div><div style="line-height: 22px;"  ><font size="3"  >SQL&gt; create table tbl_test (id int,author varchar2(32),title varchar2(256),content varchar2(4000)) pctfree 0 compress basic ;&nbsp;</font></div><div><font size="3"  >SQL&gt; insert into tbl_test select rownum,'digoal'||rownum,'TOAST,The Oversized-Attribute Storage Technique'||rownum,'This section provides an overview of TOAST (The Oversized-Attribute Storage Technique). &nbsp;PostgreSQL uses a fixed page size (commonly 8 kB), and does not allow tuples to span multiple pages. Therefore, it is not possible to store very large field values directly. To overcome this limitation, large field values are compressed and/or broken up into multiple physical rows. This happens transparently to the user, with only small impact on most of the backend code. The technique is affectionately known as TOAST (or "the best thing since sliced bread"). &nbsp;Only certain data types support TOAST ― there is no need to impose the overhead on data types that cannot produce large field values. To support TOAST'||rownum from dual connect by level&lt;=1000000;</font></div><div><font size="3"  ><div>SQL&gt; select sum(bytes)/1024/1024||'MB' from dba_segments where segment_name='TBL_TEST' ;&nbsp;</div></font><span style="line-height: 25px; font-size: medium;"  >784MB</span></div><div><font size="3"  >插入耗时 9890ms</font></div><div><span style="line-height: 25px; font-size: medium;"  >占用空间 784MB (实际没有压缩)</span></div><div><span style="line-height: 25px; font-size: medium;"  >另外compress for oltp &nbsp;在这个测试中都没有起到作用。</span></div><div><span style="line-height: 25px; font-size: medium;"  >而compress for archive和compress for query需要Exadata存储支持。</span></div><div><span style="line-height: 25px; font-size: medium;"  ><div>SQL&gt; create table tbl_test (id int,author varchar2(32),title varchar2(256),content varchar2(4000)) pctfree 0 compress for archive;</div><div>create table tbl_test (id int,author varchar2(32),title varchar2(256),content varchar2(4000)) pctfree 0 compress for archive</div><div>*</div><div>ERROR at line 1:</div><div>ORA-64307: hybrid columnar compression is only supported in tablespaces</div><div>residing on Exadata storage</div><div><br></div></span><span style="font-family: monospace; line-height: 20px; font-size: medium;"  >以下测试content插入704个字符.</span></div><div><span style="line-height: 25px; font-size: medium;"  >接下来看看PostgreSQL的表现</span></div><div><div style="line-height: 25px; font-size: medium;"  >digoal=&gt; create table tbl_test (id int,author varchar(32),title varchar(256),content varchar(4000)) with(fillfactor=100);</div><div style="line-height: 25px; font-size: medium;"  >CREATE TABLE</div><div style="line-height: 25px; font-size: medium;"  >Time: 33.107 ms</div><div style="line-height: 25px; font-size: medium;"  >digoal=&gt; \d+ tbl_test;</div><div style="line-height: 25px; font-size: medium;"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Table "digoal.tbl_test"</div><div style="line-height: 25px; font-size: medium;"  >&nbsp;Column &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Modifiers | Storage &nbsp;| Description&nbsp;</div><div style="line-height: 25px; font-size: medium;"  >---------+-------------------------+-----------+----------+-------------</div><div style="line-height: 25px; font-size: medium;"  >&nbsp;id &nbsp; &nbsp; &nbsp;| integer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | plain &nbsp; &nbsp;|&nbsp;</div><div style="line-height: 25px; font-size: medium;"  >&nbsp;author &nbsp;| character varying(32) &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | extended |&nbsp;</div><div style="line-height: 25px; font-size: medium;"  >&nbsp;title &nbsp; | character varying(256) &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | extended |&nbsp;</div><div style="line-height: 25px; font-size: medium;"  >&nbsp;content | character varying(4000) | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | extended |&nbsp;</div><div style="line-height: 25px; font-size: medium;"  >Has OIDs: no</div><div style="line-height: 25px; font-size: medium;"  >Options: fillfactor=100</div><div style="line-height: 25px; font-size: medium;"  >varchar字段默认就是压缩存储的。</div><div style="line-height: 25px; font-size: medium;"  ><div>digoal=&gt; insert into tbl_test select generate_series(1,1000000),'digoal'||generate_series(1,1000000),'TOAST,The Oversized-Attribute Storage Technique'||generate_series(1,1000000),'This section provides an overview of TOAST (The Oversized-Attribute Storage Technique). &nbsp;PostgreSQL uses a fixed page size (commonly 8 kB), and does not allow tuples to span multiple pages. Therefore, it is not possible to store very large field values directly. To overcome this limitation, large field values are compressed and/or broken up into multiple physical rows. This happens transparently to the user, with only small impact on most of the backend code. The technique is affectionately known as TOAST (or "the best thing since sliced bread"). &nbsp;Only certain data types support TOAST ― there is no need o impose the overhead on data types that cannot produce large field values. To support TOAST'||generate_series(1,1000000);</div><div>INSERT 0 1000000</div><div>Time: 6593.629 ms</div><div>digoal=&gt; select pg_total_relation_size('tbl_test'::regclass)/1024/1024;</div><div>&nbsp;?column?&nbsp;</div><div>----------</div><div>&nbsp; &nbsp; &nbsp; 867</div><div>下面来看看Pg不压缩的情况</div><div>alter table tbl_test alter column author set storage plain;</div><div><div style="line-height: 25px;"  >alter table tbl_test alter column title set storage plain;</div></div><div>alter table tbl_test alter column content set storage plain;</div><div>digoal=&gt; insert into tbl_test select generate_series(1,1000000),'digoal'||generate_series(1,1000000),'TOAST,The Oversized-Attribute Storage Technique'||generate_series(1,1000000),'This section provides an overview of TOAST (The Oversized-Attribute Storage Technique). &nbsp;PostgreSQL uses a fixed page size (commonly 8 kB), and does not allow tuples to span multiple pages. Therefore, it is not possible to store very large field values directly. To overcome this limitation, large field values are compressed and/or broken up into multiple physical rows. This happens transparently to the user, with only small impact on most of the backend code. The technique is affectionately known as TOAST (or "the best thing since sliced bread"). &nbsp;Only certain data types support TOAST ― there is no need o impose the overhead on data types that cannot produce large field values. To support TOAST'||generate_series(1,1000000);</div></div><div><div><font size="3"  ><span style="line-height: 25px;"  >INSERT 0 1000000</span></font></div><div><font size="3"  ><span style="line-height: 25px;"  >Time: 6611.137 ms</span></font></div><div><font size="3"  ><span style="line-height: 25px;"  >digoal=&gt; select pg_total_relation_size('tbl_test'::regclass)/1024/1024;</span></font></div><div><font size="3"  ><span style="line-height: 25px;"  >&nbsp;?column?&nbsp;</span></font></div><div><font size="3"  ><span style="line-height: 25px;"  >----------</span></font></div><div><font size="3"  ><span style="line-height: 25px;"  >&nbsp; &nbsp; &nbsp; 867</span></font></div><div><font size="3"  ><span style="line-height: 25px;"  >(1 row)</span></font></div></div></div><div><font size="3"  ><span style="line-height: 25px;"  >从上面的测试看出，ORACLE和PG在插入的字段长度约700字符的时候，都没有在这里使用压缩.</span></font></div><div><font size="3"  ><span style="line-height: 25px;"  ><br></span></font></div><div><span style="line-height: 25px; font-size: medium;"  >那么插入7000个字符看看,已经超出ORACLE的VARCHAR2最大允许长度，所以不考虑ORACLE在这里的测试。下面来看看PG的表现。</span></div><div><span style="line-height: 25px; font-size: medium;"  >digoal=&gt; insert into tbl_test select generate_series(1,1000000),'digoal'||generate_series(1,1000000),'TOAST,The Oversized-Attribute Storage Technique'||generate_series(1,1000000),'此处省略7000字'||generate_series(1,1000000);</span></div><div><span style="line-height: 25px; font-size: medium;"  >耗费时间354343ms</span></div><div><span style="line-height: 25px; font-size: medium;"  >digoal=&gt; select pg_relation_size('tbl_test'::regclass)/1024/1024;</span></div><div><font size="3"  ><span style="line-height: 25px;"  ><div>&nbsp;?column?&nbsp;</div><div>----------</div><div>&nbsp; &nbsp; &nbsp; 119</div><div>(1 row)</div><div><div>digoal=&gt; select relname,reltoastrelid from pg_class where relname='tbl_test';</div><div>&nbsp;relname &nbsp;| reltoastrelid&nbsp;</div><div>----------+---------------</div><div>&nbsp;tbl_test | &nbsp; &nbsp; &nbsp; 1096285</div><div>(1 row)</div></div></span></font></div><div><font size="3"  ><div>digoal=&gt; select pg_relation_size(1096285)/1024/1024;</div><div>&nbsp;?column?&nbsp;</div><div>----------</div><div>&nbsp; &nbsp; &nbsp;3906</div><div>(1 row)</div><div><div>digoal=&gt; select pg_total_relation_size('tbl_test'::regclass)/1024/1024;</div><div>&nbsp;?column?&nbsp;</div><div>----------</div><div>&nbsp; &nbsp; &nbsp;4069</div><div>(1 row)</div></div></font></div><div><span style="line-height: 25px; font-size: medium;"  >这里用到了TOAST表，插入量是刚才的10倍，总的数据大小是刚才的4.8倍，压缩了一半。</span></div><div><br></div><div>【参考】</div><div>PostgreSQL</div><div><a rel="nofollow" href="http://www.postgresql.org/docs/9.0/static/storage-toast.html"  >http://www.postgresql.org/docs/9.0/static/storage-toast.html</a></div><div>src/backend/utils/adt/pg_lzcompress.c</div><div>Oracle 11G :&nbsp;</div><div>/E11882_01/server.112/e17118/statements_7002.htm</div></div>
	</div>
</div>
</body>
</html>