<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>PostgreSQL research</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">PostgreSQL research</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">PostgreSQL 9.2 can archive xlog realtime by adding pg_receivexlog utilis</h2>
	<h5 id="">2012-05-22 14:16:57&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/digoal@126/blog/static/163877040201242212612766/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><div>PostgreSQL 9.2 流复制增强，包括级联流复制，请参考我以前写的BLOG：</div><div><a style="line-height: 22px; " target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012012361519/"  >http://blog.163.com/digoal@126/blog/static/1638770402012012361519/</a> </div><div>同时PostgreSQL 9.2 把receive xlog的功能"独立"出一个小工具pg_receivexlog. 这个工具可以利用流复制协议实时的获取数据库产生的xlog信息, 并写入到指定的目录中.</div><div>以前我们备份XLOG的时候, 需要等到archive发生之后, 去备份归档出来的文件. (当然其实如果建立了流复制的standby的话, standby其实也是在实时的接收主节点发过来的xlog信息的. 但是pg_receivexlog工具不需要建立standby, 它是一个独立的小工具, 就是用来实时的接收xlog的)</div><div>有了pg_receivexlog之后, 备份xlog的信息将更加实时. 这个在企业中应该会大受欢迎.</div><div>因为PostgreSQL 9.2支持级联复制, 所以pg_receivexlog可以直接连主库也可以连级联的备库.</div><div>下面我们用3台主机来测试一下.</div><div>主节点 : 172.16.3.33</div><div>hot_standby节点 :&nbsp;<span style="line-height: 22px;"  >172.16.3.39</span></div><div>备份节点(执行pg_receivexlog的节点) :&nbsp;<span style="line-height: 22px;"  >172.16.3.40</span></div><div>主节点的需要修改的配置 :&nbsp;</div><div>postgresql.conf</div><div>pg_hba.conf</div><div><br></div><div>hot_standby节点需要修改的配置 :&nbsp;</div><div>~/.pgpass</div><div>$PGDATA/recovery.conf</div><div><br></div><div>备份节点的配置 :&nbsp;</div><div>~/.pgpass</div><div>以上如何配置可参看我以前写过的关于流复制的BLOG, 里面有数篇可供参考.</div><div><a href="http://blog.163.com/digoal@126/blog/static/1638770402010411111817376/"  >http://blog.163.com/digoal@126/blog/static/1638770402010411111817376/</a> </div><div><br></div><div>全部配置好后,&nbsp;</div><div>1. 在主节点创建测试表</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-33-&gt; psql digoal postgres</font></div><div><font size="2"  >psql (9.2beta1)</font></div><div><font size="2"  >Type "help" for help.</font></div><div><font size="2"  >digoal=# create table t1 (id int, info text);</font></div><div><font size="2"  >CREATE TABLE</font></div><p></p></pre></div><div><br></div><div>2. 这里测试备份节点使用pg_receivexlog连接到hot_standby节点去获取xlog的信息.</div><div>首先要创建备份目录,(存放xlog文件)</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >[root@db-172-16-3-40 ~]# cd /pgdata/digoal/1921/data02</font></div><div><div><font size="2"  >[root@db-172-16-3-40 data02]# mkdir pg92beta1_arch_realtime</font></div><div><font size="2"  >[root@db-172-16-3-40 data02]# chown pg92:pg92 pg92beta1_arch_realtime</font></div></div><div><font size="2"  >su - pg92</font></div><div><div><font size="2"  >pg92@db-172-16-3-40-&gt;&nbsp; pg_receivexlog -D /pgdata/digoal/1921/data02/pg92beta1_arch_realtime -v -s 10 -h 172.16.3.39 -p 1919 -U replica -w&nbsp;</font></div><div><font size="2"  >pg_receivexlog: starting log streaming at 0/80000000 (timeline 1)</font></div></div><p></p></pre></div><div>从上面的输出可以看到pg_receivexlog已经连接上了172.16.3.39, 开始接收的XLOG文件为<span style="line-height: 22px;"  >0/80000000.</span></div><div><br></div><div>3. 接下来到主节点执行一个SQL, 插入大量数据. 使之产生xlog信息.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-33-&gt; psql digoal postgres</font></div><div><font size="2"  >psql (9.2beta1)</font></div><div><font size="2"  >Type "help" for help.</font></div><div><font size="2"  >digoal=# insert into t1 select generate_series(1,1000000),'digoal'||generate_series(1,1000000);</font></div><div><font size="2"  >INSERT 0 1000000</font></div><p></p></pre></div><div><br></div><div>4. 回到172.16.3.40, 可以看到类似如下输出 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><div><font size="2"  >pg_receivexlog: finished segment at 0/82000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: finished segment at 0/83000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: finished segment at 0/84000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: finished segment at 0/85000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: finished segment at 0/86000000 (timeline 1)</font></div></div><div><span style="line-height: 22px;"  ><font size="2"  >pg_receivexlog: finished segment at 0/87000000 (timeline 1)</font></span></div><p></p></pre></div><div><span style="line-height: 22px;"  ><br></span></div><div>到相应的目录可以查看到文件如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-40-&gt; ll&nbsp;/pgdata/digoal/1921/data02/pg92beta1_arch_realtime</font></div><div><font size="2"  >total 144M</font></div><div><font size="2"  >-rw------- 1 pg92 pg92 16M May 22 13:27 000000010000000000000080</font></div><div><font size="2"  >-rw------- 1 pg92 pg92 16M May 22 13:27 000000010000000000000081</font></div><div><font size="2"  >-rw------- 1 pg92 pg92 16M May 22 13:27 000000010000000000000082</font></div><div><font size="2"  >-rw------- 1 pg92 pg92 16M May 22 13:27 000000010000000000000083</font></div><div><font size="2"  >-rw------- 1 pg92 pg92 16M May 22 13:27 000000010000000000000084</font></div><div><font size="2"  >-rw------- 1 pg92 pg92 16M May 22 13:27 000000010000000000000085</font></div><div><font size="2"  >-rw------- 1 pg92 pg92 16M May 22 13:28 000000010000000000000086</font></div><div><font size="2"  >-rw------- 1 pg92 pg92 16M May 22 13:28 000000010000000000000087</font></div><div><font size="2"  >-rw------- 1 pg92 pg92 16M May 22 13:31 000000010000000000000088.partial</font></div><p></p></pre></div><div><br></div><div>5. 在hot_standby节点可以查看到, 它既有wal_receiver进程又有wal_sender进程.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-39-&gt; ps -ewfL|grep pg92</font></div><div><font size="2"  >root &nbsp; &nbsp; &nbsp;5505 &nbsp;5394 &nbsp;5505 &nbsp;0 &nbsp; &nbsp;1 13:18 pts/0 &nbsp; &nbsp;00:00:00 su - pg92</font></div><div><font size="2"  >pg92 &nbsp; &nbsp; &nbsp;5506 &nbsp;5505 &nbsp;5506 &nbsp;0 &nbsp; &nbsp;1 13:18 pts/0 &nbsp; &nbsp;00:00:00 -bash</font></div><div><font size="2"  >pg92 &nbsp; &nbsp; &nbsp;5553 &nbsp; &nbsp; 1 &nbsp;5553 &nbsp;0 &nbsp; &nbsp;1 13:19 pts/0 &nbsp; &nbsp;00:00:00 /opt/pgsql92/bin/postgres</font></div><div><font size="2"  >pg92 &nbsp; &nbsp; &nbsp;5558 &nbsp;5553 &nbsp;5558 &nbsp;0 &nbsp; &nbsp;1 13:19 ? &nbsp; &nbsp; &nbsp; &nbsp;00:00:00 postgres: logger process &nbsp;&nbsp;</font></div><div><font size="2"  >pg92 &nbsp; &nbsp; &nbsp;5559 &nbsp;5553 &nbsp;5559 &nbsp;0 &nbsp; &nbsp;1 13:19 ? &nbsp; &nbsp; &nbsp; &nbsp;00:00:02 postgres: startup process &nbsp; recovering 000000010000000000000088</font></div><div><font size="2"  >pg92 &nbsp; &nbsp; &nbsp;5560 &nbsp;5553 &nbsp;5560 &nbsp;0 &nbsp; &nbsp;1 13:19 ? &nbsp; &nbsp; &nbsp; &nbsp;00:00:00 postgres: wal receiver process &nbsp; streaming 0/880D2820</font></div><div><font size="2"  >pg92 &nbsp; &nbsp; &nbsp;5561 &nbsp;5553 &nbsp;5561 &nbsp;0 &nbsp; &nbsp;1 13:19 ? &nbsp; &nbsp; &nbsp; &nbsp;00:00:00 postgres: checkpointer process &nbsp;&nbsp;</font></div><div><font size="2"  >pg92 &nbsp; &nbsp; &nbsp;5562 &nbsp;5553 &nbsp;5562 &nbsp;0 &nbsp; &nbsp;1 13:19 ? &nbsp; &nbsp; &nbsp; &nbsp;00:00:00 postgres: writer process &nbsp;&nbsp;</font></div><div><font size="2"  >pg92 &nbsp; &nbsp; &nbsp;5563 &nbsp;5553 &nbsp;5563 &nbsp;0 &nbsp; &nbsp;1 13:19 ? &nbsp; &nbsp; &nbsp; &nbsp;00:00:00 postgres: stats collector process &nbsp;&nbsp;</font></div><div><font size="2"  >pg92 &nbsp; &nbsp; &nbsp;5582 &nbsp;5553 &nbsp;5582 &nbsp;0 &nbsp; &nbsp;1 13:26 ? &nbsp; &nbsp; &nbsp; &nbsp;00:00:00 postgres: wal sender process replica 172.16.3.40(52680) streaming 0/880D2820</font></div><div><font size="2"  >pg92 &nbsp; &nbsp; &nbsp;5588 &nbsp;5506 &nbsp;5588 &nbsp;0 &nbsp; &nbsp;1 13:27 pts/0 &nbsp; &nbsp;00:00:00 ps -ewfL</font></div><div><font size="2"  >pg92 &nbsp; &nbsp; &nbsp;5589 &nbsp;5506 &nbsp;5589 &nbsp;0 &nbsp; &nbsp;1 13:27 pts/0 &nbsp; &nbsp;00:00:00 grep pg92</font></div><p></p></pre></div><div><br></div><div>6. 接下来模拟pg_receivexlog异常中断, 看看重新启动后能不能把中断过程中产生的XLOG接收过来. 答案当然是可以的, 但是需要配置wal_keep_segments够大, 也就是中断过程中产生的XLOG要还在pg_receivexlog连接的数据库服务器上, 否则就没办法了(只能通过archived的文件去取).</div><div>主节点配置的wal_keep_segments=16, hot_standby节点也是16. 所以只要pg_receivexlog中断过程中产生的xlog个数不超过16都是可以接上去的.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-33-&gt; psql digoal postgres</font></div><div><font size="2"  >psql (9.2beta1)</font></div><div><font size="2"  >Type "help" for help.</font></div><div><font size="2"  >digoal=# show wal_keep_segments;</font></div><div><font size="2"  >&nbsp;wal_keep_segments&nbsp;</font></div><div><font size="2"  >-------------------</font></div><div><font size="2"  >&nbsp;16</font></div><div><font size="2"  >(1 row)</font></div><p></p></pre></div><div>-- 主节点再次插入大量数据</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >digoal=# insert into t1 select generate_series(1,1000000),'digoal'||generate_series(1,1000000);</font></div><div><font size="2"  >INSERT 0 1000000</font></div><p></p></pre></div><div><br></div><div>7. 接下来启动172.16.3.40上的pg_receivexlog, 看看中断过程中产生的xlog能不能接收过来. 答案当然是没问题的, 因为这个过程中只产生了10个xlog文件. 没有超过16.</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-40-&gt; pg_receivexlog -D /pgdata/digoal/1921/data02/pg92beta1_arch_realtime -v -s 10 -h 172.16.3.39 -p 1919 -U replica -w</font></div><div><font size="2"  >pg_receivexlog: starting log streaming at 0/88000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: finished segment at 0/89000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: finished segment at 0/8A000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: finished segment at 0/8B000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: finished segment at 0/8C000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: finished segment at 0/8D000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: finished segment at 0/8E000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: finished segment at 0/8F000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: finished segment at 0/90000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: finished segment at 0/91000000 (timeline 1)</font></div><p></p></pre></div><div><br></div><div>8. 接下来模拟中断过程中主节点产生了超过16个XLOG文件的情况.</div><div><br></div><div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-40-&gt; pg_receivexlog -D /pgdata/digoal/1921/data02/pg92beta1_arch_realtime -v -s 10 -h 172.16.3.39 -p 1919 -U replica -w</font></div><div><font size="2"  >pg_receivexlog: starting log streaming at 0/C5000000 (timeline 1)</font></div><div><font size="2"  >pg_receivexlog: received interrupt signal, exiting.</font></div><div><font size="2"  >pg_receivexlog: not renaming 0000000100000000000000C5, segment is not complete.</font></div><p></p></pre></div><div>中断, 查看当前文件如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-40-&gt; ll</font></div><div><font size="2"  >total 16M</font></div><div><font size="2"  >-rw------- 1 pg92 pg92 16M May 22 13:58 0000000100000000000000C5.partial</font></div><div></div><p></p></pre></div><div>9. 在主节点执行如下 :&nbsp;</div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-33-&gt; psql digoal postgres</font></div><div><font size="2"  >psql (9.2beta1)</font></div><div><font size="2"  >Type "help" for help.</font></div><div><font size="2"  >digoal=# create table t1 (id int, info text);</font></div><div><font size="2"  >CREATE TABLE</font></div><div><font size="2"  >digoal=# insert into t1 select generate_series(1,1000000),'digoal'||generate_series(1,1000000);</font></div><div><font size="2"  >INSERT 0 1000000</font></div><div><font size="2"  >digoal=# truncate t1;</font></div><div><font size="2"  >TRUNCATE TABLE</font></div><div><font size="2"  >digoal=# insert into t1 select generate_series(1,5000000),'digoal'||generate_series(1,5000000);</font></div><div><font size="2"  >INSERT 0 5000000</font></div><div><font size="2"  >digoal=# insert into t1 select generate_series(1,5000000),'digoal'||generate_series(1,5000000);</font></div><div><font size="2"  >INSERT 0 5000000</font></div><div><font size="2"  >digoal=# delete from t1;</font></div><div><font size="2"  >DELETE 10000000</font></div><p></p></pre></div><div>执行完确保pg_xlog目录中已经没有<span style="line-height: 22px;"  >0000000100000000000000C5这个文件了. 或者该文件已经被覆写.</span></div><div><span style="line-height: 22px;"  ><br></span></div><div>10. 在备份节点上重新执行pg_receivexlog, 发现它重新从<span style="line-height: 22px;"  >0/F6000000开始同步, 而不是</span><span style="line-height: 22px;"  >0/C5000000.</span></div><div><pre class="prettyprint"  ><p></p><div><font size="2"  >pg92@db-172-16-3-40-&gt; pg_receivexlog -D /pgdata/digoal/1921/data02/pg92beta1_arch_realtime -v -s 10 -h 172.16.3.39 -p 1919 -U replica -w</font></div><div><font size="2"  >pg_receivexlog: starting log streaming at 0/F6000000 (timeline 1)</font></div><p></p></pre></div></div><div><br></div><div>【参考】</div><div><div>PostgreSQL 9.2 devel adding cascading replication support</div><div><a target="_blank" href="http://blog.163.com/digoal@126/blog/static/1638770402012012361519/"  >http://blog.163.com/digoal@126/blog/static/1638770402012012361519/</a></div><div>src/bin/pg_basebackup/pg_receivexlog.c</div><div>src/bin/pg_basebackup/streamutil.c</div></div></div>
	</div>
</div>
</body>
</html>